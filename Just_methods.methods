methods/lang3/CharSequenceUtils.java
static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart, final CharSequence substring, final int start, final int length) { [EOL]     if (cs instanceof String && substring instanceof String) { [EOL]         return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length); [EOL]     } else { [EOL]         int index1 = thisStart; [EOL]         int index2 = start; [EOL]         int tmpLen = length; [EOL]         while (tmpLen-- > 0) { [EOL]             char c1 = cs.charAt(index1++); [EOL]             char c2 = substring.charAt(index2++); [EOL]             if (c1 == c2) { [EOL]                 continue; [EOL]             } [EOL]             if (!ignoreCase) { [EOL]                 return false; [EOL]             } [EOL]             if (Character.toUpperCase(c1) != Character.toUpperCase(c2) && Character.toLowerCase(c1) != Character.toLowerCase(c2)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL] }
static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart, final CharSequence substring, final int start, final int length) { [EOL]     if (cs instanceof String && substring instanceof String) { [EOL]         return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length); [EOL]     } else { [EOL]         int index1 = thisStart; [EOL]         int index2 = start; [EOL]         int tmpLen = length; [EOL]         while (tmpLen-- > 0) { [EOL]             char c1 = cs.charAt(index1++); [EOL]             char c2 = substring.charAt(index2++); [EOL]             if (c1 == c2) { [EOL]                 continue; [EOL]             } [EOL]             if (!ignoreCase) { [EOL]                 return false; [EOL]             } [EOL]             if (Character.toUpperCase(c1) != Character.toUpperCase(c2) && Character.toLowerCase(c1) != Character.toLowerCase(c2)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL] }
static int lastIndexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().lastIndexOf(searchChar.toString(), start); [EOL] }
static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().indexOf(searchChar.toString(), start); [EOL] }
static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().indexOf(searchChar.toString(), start); [EOL] }
static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().indexOf(searchChar.toString(), start); [EOL] }
static char[] toCharArray(final CharSequence cs) { [EOL]     if (cs instanceof String) { [EOL]         return ((String) cs).toCharArray(); [EOL]     } else { [EOL]         final int sz = cs.length(); [EOL]         final char[] array = new char[cs.length()]; [EOL]         for (int i = 0; i < sz; i++) { [EOL]             array[i] = cs.charAt(i); [EOL]         } [EOL]         return array; [EOL]     } [EOL] }
public static CharSequence subSequence(final CharSequence cs, final int start) { [EOL]     return cs == null ? null : cs.subSequence(start, cs.length()); [EOL] }
public static CharSequence subSequence(final CharSequence cs, final int start) { [EOL]     return cs == null ? null : cs.subSequence(start, cs.length()); [EOL] }
static int lastIndexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().lastIndexOf(searchChar.toString(), start); [EOL] }
static int lastIndexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().lastIndexOf(searchChar.toString(), start); [EOL] }
static int lastIndexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().lastIndexOf(searchChar.toString(), start); [EOL] }
static int lastIndexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().lastIndexOf(searchChar.toString(), start); [EOL] }
static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().indexOf(searchChar.toString(), start); [EOL] }
static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().indexOf(searchChar.toString(), start); [EOL] }
static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().indexOf(searchChar.toString(), start); [EOL] }
static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart, final CharSequence substring, final int start, final int length) { [EOL]     if (cs instanceof String && substring instanceof String) { [EOL]         return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length); [EOL]     } else { [EOL]         int index1 = thisStart; [EOL]         int index2 = start; [EOL]         int tmpLen = length; [EOL]         while (tmpLen-- > 0) { [EOL]             char c1 = cs.charAt(index1++); [EOL]             char c2 = substring.charAt(index2++); [EOL]             if (c1 == c2) { [EOL]                 continue; [EOL]             } [EOL]             if (!ignoreCase) { [EOL]                 return false; [EOL]             } [EOL]             if (Character.toUpperCase(c1) != Character.toUpperCase(c2) && Character.toLowerCase(c1) != Character.toLowerCase(c2)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL] }
static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart, final CharSequence substring, final int start, final int length) { [EOL]     if (cs instanceof String && substring instanceof String) { [EOL]         return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length); [EOL]     } else { [EOL]         int index1 = thisStart; [EOL]         int index2 = start; [EOL]         int tmpLen = length; [EOL]         while (tmpLen-- > 0) { [EOL]             char c1 = cs.charAt(index1++); [EOL]             char c2 = substring.charAt(index2++); [EOL]             if (c1 == c2) { [EOL]                 continue; [EOL]             } [EOL]             if (!ignoreCase) { [EOL]                 return false; [EOL]             } [EOL]             if (Character.toUpperCase(c1) != Character.toUpperCase(c2) && Character.toLowerCase(c1) != Character.toLowerCase(c2)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL] }
static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart, final CharSequence substring, final int start, final int length) { [EOL]     if (cs instanceof String && substring instanceof String) { [EOL]         return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length); [EOL]     } else { [EOL]         int index1 = thisStart; [EOL]         int index2 = start; [EOL]         int tmpLen = length; [EOL]         while (tmpLen-- > 0) { [EOL]             char c1 = cs.charAt(index1++); [EOL]             char c2 = substring.charAt(index2++); [EOL]             if (c1 == c2) { [EOL]                 continue; [EOL]             } [EOL]             if (!ignoreCase) { [EOL]                 return false; [EOL]             } [EOL]             if (Character.toUpperCase(c1) != Character.toUpperCase(c2) && Character.toLowerCase(c1) != Character.toLowerCase(c2)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL] }
static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart, final CharSequence substring, final int start, final int length) { [EOL]     if (cs instanceof String && substring instanceof String) { [EOL]         return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length); [EOL]     } else { [EOL]         int index1 = thisStart; [EOL]         int index2 = start; [EOL]         int tmpLen = length; [EOL]         while (tmpLen-- > 0) { [EOL]             char c1 = cs.charAt(index1++); [EOL]             char c2 = substring.charAt(index2++); [EOL]             if (c1 == c2) { [EOL]                 continue; [EOL]             } [EOL]             if (!ignoreCase) { [EOL]                 return false; [EOL]             } [EOL]             if (Character.toUpperCase(c1) != Character.toUpperCase(c2) && Character.toLowerCase(c1) != Character.toLowerCase(c2)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL] }
static char[] toCharArray(final CharSequence cs) { [EOL]     if (cs instanceof String) { [EOL]         return ((String) cs).toCharArray(); [EOL]     } else { [EOL]         final int sz = cs.length(); [EOL]         final char[] array = new char[cs.length()]; [EOL]         for (int i = 0; i < sz; i++) { [EOL]             array[i] = cs.charAt(i); [EOL]         } [EOL]         return array; [EOL]     } [EOL] }
static char[] toCharArray(final CharSequence cs) { [EOL]     if (cs instanceof String) { [EOL]         return ((String) cs).toCharArray(); [EOL]     } else { [EOL]         final int sz = cs.length(); [EOL]         final char[] array = new char[cs.length()]; [EOL]         for (int i = 0; i < sz; i++) { [EOL]             array[i] = cs.charAt(i); [EOL]         } [EOL]         return array; [EOL]     } [EOL] }
static int lastIndexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().lastIndexOf(searchChar.toString(), start); [EOL] }
static int lastIndexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().lastIndexOf(searchChar.toString(), start); [EOL] }
static int lastIndexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().lastIndexOf(searchChar.toString(), start); [EOL] }
static int lastIndexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().lastIndexOf(searchChar.toString(), start); [EOL] }
static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().indexOf(searchChar.toString(), start); [EOL] }
public static CharSequence subSequence(final CharSequence cs, final int start) { [EOL]     return cs == null ? null : cs.subSequence(start, cs.length()); [EOL] }
static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) { [EOL]     return cs.toString().indexOf(searchChar.toString(), start); [EOL] }
methods/lang3/Validate.java
public static <T> void inclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) { [EOL]     if (value.compareTo(start) < 0 || value.compareTo(end) > 0) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] }
public static <T extends CharSequence> T validIndex(final T chars, final int index) { [EOL]     return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index)); [EOL] }
public static <T extends CharSequence> T validIndex(final T chars, final int index) { [EOL]     return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index)); [EOL] }
public static <T extends CharSequence> T notEmpty(final T chars) { [EOL]     return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE); [EOL] }
public static <T extends CharSequence> T notEmpty(final T chars) { [EOL]     return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE); [EOL] }
public static <T extends Iterable<?>> T noNullElements(final T iterable) { [EOL]     return noNullElements(iterable, DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE); [EOL] }
public static <T extends Iterable<?>> T noNullElements(final T iterable) { [EOL]     return noNullElements(iterable, DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE); [EOL] }
public static <T extends CharSequence> T validIndex(final T chars, final int index) { [EOL]     return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index)); [EOL] }
public static <T extends Iterable<?>> T noNullElements(final T iterable) { [EOL]     return noNullElements(iterable, DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE); [EOL] }
public static <T extends CharSequence> T notBlank(final T chars) { [EOL]     return notBlank(chars, DEFAULT_NOT_BLANK_EX_MESSAGE); [EOL] }
public static <T extends CharSequence> T notEmpty(final T chars) { [EOL]     return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE); [EOL] }
public static <T> T notNull(final T object, final String message, final Object... values) { [EOL]     if (object == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     return object; [EOL] }
public static <T> T notNull(final T object, final String message, final Object... values) { [EOL]     if (object == null) { [EOL]         throw new NullPointerException(String.format(message, values)); [EOL]     } [EOL]     return object; [EOL] }
public static void isAssignableFrom(final Class<?> superType, final Class<?> type, final String message, final Object... values) { [EOL]     if (superType.isAssignableFrom(type) == false) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] }
public static void isInstanceOf(final Class<?> type, final Object obj, final String message, final Object... values) { [EOL]     if (type.isInstance(obj) == false) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] }
public static void isInstanceOf(final Class<?> type, final Object obj, final String message, final Object... values) { [EOL]     if (type.isInstance(obj) == false) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] }
public static <T> void inclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) { [EOL]     if (value.compareTo(start) < 0 || value.compareTo(end) > 0) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] }
public static void matchesPattern(final CharSequence input, final String pattern, final String message, final Object... values) { [EOL]     if (Pattern.matches(pattern, input) == false) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] }
public static void matchesPattern(final CharSequence input, final String pattern, final String message, final Object... values) { [EOL]     if (Pattern.matches(pattern, input) == false) { [EOL]         throw new IllegalArgumentException(String.format(message, values)); [EOL]     } [EOL] }
public static void validState(final boolean expression, final String message, final Object... values) { [EOL]     if (expression == false) { [EOL]         throw new IllegalStateException(String.format(message, values)); [EOL]     } [EOL] }
public static <T extends CharSequence> T validIndex(final T chars, final int index) { [EOL]     return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index)); [EOL] }
public static <T extends CharSequence> T validIndex(final T chars, final int index) { [EOL]     return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index)); [EOL] }
public static <T extends CharSequence> T validIndex(final T chars, final int index) { [EOL]     return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index)); [EOL] }
public static <T extends Iterable<?>> T noNullElements(final T iterable) { [EOL]     return noNullElements(iterable, DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE); [EOL] }
public static <T extends CharSequence> T notBlank(final T chars) { [EOL]     return notBlank(chars, DEFAULT_NOT_BLANK_EX_MESSAGE); [EOL] }
public static <T extends CharSequence> T notEmpty(final T chars) { [EOL]     return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE); [EOL] }
public static <T extends CharSequence> T notEmpty(final T chars) { [EOL]     return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE); [EOL] }
public static <T extends CharSequence> T notEmpty(final T chars) { [EOL]     return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE); [EOL] }
public static void isTrue(final boolean expression) { [EOL]     if (expression == false) { [EOL]         throw new IllegalArgumentException(DEFAULT_IS_TRUE_EX_MESSAGE); [EOL]     } [EOL] }
public static <T extends CharSequence> T notEmpty(final T chars) { [EOL]     return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE); [EOL] }
public static <T extends Iterable<?>> T noNullElements(final T iterable) { [EOL]     return noNullElements(iterable, DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE); [EOL] }
methods/lang3/ObjectUtils.java
public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
public static short CONST_SHORT(final int v) throws IllegalArgumentException { [EOL]     if (v < Short.MIN_VALUE || v > Short.MAX_VALUE) { [EOL]         throw new IllegalArgumentException("Supplied value must be a valid byte literal between -32768 and 32767: [" + v + "]"); [EOL]     } [EOL]     return (short) v; [EOL] }
public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
public static byte CONST_BYTE(final int v) throws IllegalArgumentException { [EOL]     if (v < Byte.MIN_VALUE || v > Byte.MAX_VALUE) { [EOL]         throw new IllegalArgumentException("Supplied value must be a valid byte literal between -128 and 127: [" + v + "]"); [EOL]     } [EOL]     return (byte) v; [EOL] }
public static <T> T clone(final T obj) { [EOL]     if (obj instanceof Cloneable) { [EOL]         final Object result; [EOL]         if (obj.getClass().isArray()) { [EOL]             final Class<?> componentType = obj.getClass().getComponentType(); [EOL]             if (!componentType.isPrimitive()) { [EOL]                 result = ((Object[]) obj).clone(); [EOL]             } else { [EOL]                 int length = Array.getLength(obj); [EOL]                 result = Array.newInstance(componentType, length); [EOL]                 while (length-- > 0) { [EOL]                     Array.set(result, length, Array.get(obj, length)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             try { [EOL]                 final Method clone = obj.getClass().getMethod("clone"); [EOL]                 result = clone.invoke(obj); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e); [EOL]             } catch (final InvocationTargetException e) { [EOL]                 throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause()); [EOL]             } [EOL]         } [EOL]         @SuppressWarnings("unchecked") [EOL]         final T checked = (T) result; [EOL]         return checked; [EOL]     } [EOL]     return null; [EOL] }
public static <T> T cloneIfPossible(final T obj) { [EOL]     final T clone = clone(obj); [EOL]     return clone == null ? obj : clone; [EOL] }
public static <T> T median(final Comparator<T> comparator, final T... items) { [EOL]     Validate.notEmpty(items, "null/empty items"); [EOL]     Validate.noNullElements(items); [EOL]     Validate.notNull(comparator, "null comparator"); [EOL]     final TreeSet<T> sort = new TreeSet<T>(comparator); [EOL]     Collections.addAll(sort, items); [EOL]     @SuppressWarnings("unchecked") [EOL]     final T result = (T) sort.toArray()[(sort.size() - 1) / 2]; [EOL]     return result; [EOL] }
public static <T> T defaultIfNull(final T object, final T defaultValue) { [EOL]     return object != null ? object : defaultValue; [EOL] }

public static <T> T defaultIfNull(final T object, final T defaultValue) { [EOL]     return object != null ? object : defaultValue; [EOL] }

public static void identityToString(final StringBuffer buffer, final Object object) { [EOL]     if (object == null) { [EOL]         throw new NullPointerException("Cannot get the toString of a null identity"); [EOL]     } [EOL]     buffer.append(object.getClass().getName()).append('@').append(Integer.toHexString(System.identityHashCode(object))); [EOL] }
public static <T> T mode(final T... items) { [EOL]     if (ArrayUtils.isNotEmpty(items)) { [EOL]         final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(items.length); [EOL]         for (final T t : items) { [EOL]             final MutableInt count = occurrences.get(t); [EOL]             if (count == null) { [EOL]                 occurrences.put(t, new MutableInt(1)); [EOL]             } else { [EOL]                 count.increment(); [EOL]             } [EOL]         } [EOL]         T result = null; [EOL]         int max = 0; [EOL]         for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]             final int cmp = e.getValue().intValue(); [EOL]             if (cmp == max) { [EOL]                 result = null; [EOL]             } else if (cmp > max) { [EOL]                 max = cmp; [EOL]                 result = e.getKey(); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     return null; [EOL] }
public static <T> T median(final Comparator<T> comparator, final T... items) { [EOL]     Validate.notEmpty(items, "null/empty items"); [EOL]     Validate.noNullElements(items); [EOL]     Validate.notNull(comparator, "null comparator"); [EOL]     final TreeSet<T> sort = new TreeSet<T>(comparator); [EOL]     Collections.addAll(sort, items); [EOL]     @SuppressWarnings("unchecked") [EOL]     final T result = (T) sort.toArray()[(sort.size() - 1) / 2]; [EOL]     return result; [EOL] }
public static int hashCode(final Object obj) { [EOL]     return obj == null ? 0 : obj.hashCode(); [EOL] }
public static int hashCodeMulti(final Object... objects) { [EOL]     int hash = 1; [EOL]     if (objects != null) { [EOL]         for (final Object object : objects) { [EOL]             hash = hash * 31 + ObjectUtils.hashCode(object); [EOL]         } [EOL]     } [EOL]     return hash; [EOL] }
public static <T extends Comparable<? super T>> int compare(final T c1, final T c2, final boolean nullGreater) { [EOL]     if (c1 == c2) { [EOL]         return 0; [EOL]     } else if (c1 == null) { [EOL]         return nullGreater ? 1 : -1; [EOL]     } else if (c2 == null) { [EOL]         return nullGreater ? -1 : 1; [EOL]     } [EOL]     return c1.compareTo(c2); [EOL] }
public static <T> T clone(final T obj) { [EOL]     if (obj instanceof Cloneable) { [EOL]         final Object result; [EOL]         if (obj.getClass().isArray()) { [EOL]             final Class<?> componentType = obj.getClass().getComponentType(); [EOL]             if (!componentType.isPrimitive()) { [EOL]                 result = ((Object[]) obj).clone(); [EOL]             } else { [EOL]                 int length = Array.getLength(obj); [EOL]                 result = Array.newInstance(componentType, length); [EOL]                 while (length-- > 0) { [EOL]                     Array.set(result, length, Array.get(obj, length)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             try { [EOL]                 final Method clone = obj.getClass().getMethod("clone"); [EOL]                 result = clone.invoke(obj); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e); [EOL]             } catch (final InvocationTargetException e) { [EOL]                 throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause()); [EOL]             } [EOL]         } [EOL]         @SuppressWarnings("unchecked") [EOL]         final T checked = (T) result; [EOL]         return checked; [EOL]     } [EOL]     return null; [EOL] }
public static String toString(final Object obj, final String nullStr) { [EOL]     return obj == null ? nullStr : obj.toString(); [EOL] }
public static <T extends Comparable<? super T>> int compare(final T c1, final T c2, final boolean nullGreater) { [EOL]     if (c1 == c2) { [EOL]         return 0; [EOL]     } else if (c1 == null) { [EOL]         return nullGreater ? 1 : -1; [EOL]     } else if (c2 == null) { [EOL]         return nullGreater ? -1 : 1; [EOL]     } [EOL]     return c1.compareTo(c2); [EOL] }
public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
public static short CONST_SHORT(final int v) throws IllegalArgumentException { [EOL]     if (v < Short.MIN_VALUE || v > Short.MAX_VALUE) { [EOL]         throw new IllegalArgumentException("Supplied value must be a valid byte literal between -32768 and 32767: [" + v + "]"); [EOL]     } [EOL]     return (short) v; [EOL] }
public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
public static byte CONST_BYTE(final int v) throws IllegalArgumentException { [EOL]     if (v < Byte.MIN_VALUE || v > Byte.MAX_VALUE) { [EOL]         throw new IllegalArgumentException("Supplied value must be a valid byte literal between -128 and 127: [" + v + "]"); [EOL]     } [EOL]     return (byte) v; [EOL] }
public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }

public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
public static String toString(final Object obj, final String nullStr) { [EOL]     return obj == null ? nullStr : obj.toString(); [EOL] }
public static <T extends Comparable<? super T>> T min(final T... values) { [EOL]     T result = null; [EOL]     if (values != null) { [EOL]         for (final T value : values) { [EOL]             if (compare(value, result, true) < 0) { [EOL]                 result = value; [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public static <T> T clone(final T obj) { [EOL]     if (obj instanceof Cloneable) { [EOL]         final Object result; [EOL]         if (obj.getClass().isArray()) { [EOL]             final Class<?> componentType = obj.getClass().getComponentType(); [EOL]             if (!componentType.isPrimitive()) { [EOL]                 result = ((Object[]) obj).clone(); [EOL]             } else { [EOL]                 int length = Array.getLength(obj); [EOL]                 result = Array.newInstance(componentType, length); [EOL]                 while (length-- > 0) { [EOL]                     Array.set(result, length, Array.get(obj, length)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             try { [EOL]                 final Method clone = obj.getClass().getMethod("clone"); [EOL]                 result = clone.invoke(obj); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e); [EOL]             } catch (final InvocationTargetException e) { [EOL]                 throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause()); [EOL]             } [EOL]         } [EOL]         @SuppressWarnings("unchecked") [EOL]         final T checked = (T) result; [EOL]         return checked; [EOL]     } [EOL]     return null; [EOL] }
public static <T extends Comparable<? super T>> int compare(final T c1, final T c2, final boolean nullGreater) { [EOL]     if (c1 == c2) { [EOL]         return 0; [EOL]     } else if (c1 == null) { [EOL]         return nullGreater ? 1 : -1; [EOL]     } else if (c2 == null) { [EOL]         return nullGreater ? -1 : 1; [EOL]     } [EOL]     return c1.compareTo(c2); [EOL] }
public static <T extends Comparable<? super T>> int compare(final T c1, final T c2, final boolean nullGreater) { [EOL]     if (c1 == c2) { [EOL]         return 0; [EOL]     } else if (c1 == null) { [EOL]         return nullGreater ? 1 : -1; [EOL]     } else if (c2 == null) { [EOL]         return nullGreater ? -1 : 1; [EOL]     } [EOL]     return c1.compareTo(c2); [EOL] }
public static <T extends Comparable<? super T>> int compare(final T c1, final T c2, final boolean nullGreater) { [EOL]     if (c1 == c2) { [EOL]         return 0; [EOL]     } else if (c1 == null) { [EOL]         return nullGreater ? 1 : -1; [EOL]     } else if (c2 == null) { [EOL]         return nullGreater ? -1 : 1; [EOL]     } [EOL]     return c1.compareTo(c2); [EOL] }
public static boolean equals(final Object object1, final Object object2) { [EOL]     if (object1 == object2) { [EOL]         return true; [EOL]     } [EOL]     if (object1 == null || object2 == null) { [EOL]         return false; [EOL]     } [EOL]     return object1.equals(object2); [EOL] }
public static boolean equals(final Object object1, final Object object2) { [EOL]     if (object1 == object2) { [EOL]         return true; [EOL]     } [EOL]     if (object1 == null || object2 == null) { [EOL]         return false; [EOL]     } [EOL]     return object1.equals(object2); [EOL] }
public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
public static short CONST_SHORT(final int v) throws IllegalArgumentException { [EOL]     if (v < Short.MIN_VALUE || v > Short.MAX_VALUE) { [EOL]         throw new IllegalArgumentException("Supplied value must be a valid byte literal between -32768 and 32767: [" + v + "]"); [EOL]     } [EOL]     return (short) v; [EOL] }
public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
public static byte CONST_BYTE(final int v) throws IllegalArgumentException { [EOL]     if (v < Byte.MIN_VALUE || v > Byte.MAX_VALUE) { [EOL]         throw new IllegalArgumentException("Supplied value must be a valid byte literal between -128 and 127: [" + v + "]"); [EOL]     } [EOL]     return (byte) v; [EOL] }
public static <T> T clone(final T obj) { [EOL]     if (obj instanceof Cloneable) { [EOL]         final Object result; [EOL]         if (obj.getClass().isArray()) { [EOL]             final Class<?> componentType = obj.getClass().getComponentType(); [EOL]             if (!componentType.isPrimitive()) { [EOL]                 result = ((Object[]) obj).clone(); [EOL]             } else { [EOL]                 int length = Array.getLength(obj); [EOL]                 result = Array.newInstance(componentType, length); [EOL]                 while (length-- > 0) { [EOL]                     Array.set(result, length, Array.get(obj, length)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             try { [EOL]                 final Method clone = obj.getClass().getMethod("clone"); [EOL]                 result = clone.invoke(obj); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e); [EOL]             } catch (final InvocationTargetException e) { [EOL]                 throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause()); [EOL]             } [EOL]         } [EOL]         @SuppressWarnings("unchecked") [EOL]         final T checked = (T) result; [EOL]         return checked; [EOL]     } [EOL]     return null; [EOL] }
public static <T> T cloneIfPossible(final T obj) { [EOL]     final T clone = clone(obj); [EOL]     return clone == null ? obj : clone; [EOL] }

public static <T> T clone(final T obj) { [EOL]     if (obj instanceof Cloneable) { [EOL]         final Object result; [EOL]         if (obj.getClass().isArray()) { [EOL]             final Class<?> componentType = obj.getClass().getComponentType(); [EOL]             if (!componentType.isPrimitive()) { [EOL]                 result = ((Object[]) obj).clone(); [EOL]             } else { [EOL]                 int length = Array.getLength(obj); [EOL]                 result = Array.newInstance(componentType, length); [EOL]                 while (length-- > 0) { [EOL]                     Array.set(result, length, Array.get(obj, length)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             try { [EOL]                 final Method clone = obj.getClass().getMethod("clone"); [EOL]                 result = clone.invoke(obj); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e); [EOL]             } catch (final InvocationTargetException e) { [EOL]                 throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause()); [EOL]             } [EOL]         } [EOL]         @SuppressWarnings("unchecked") [EOL]         final T checked = (T) result; [EOL]         return checked; [EOL]     } [EOL]     return null; [EOL] }
public static <T> T cloneIfPossible(final T obj) { [EOL]     final T clone = clone(obj); [EOL]     return clone == null ? obj : clone; [EOL] }
public static <T> T mode(final T... items) { [EOL]     if (ArrayUtils.isNotEmpty(items)) { [EOL]         final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(items.length); [EOL]         for (final T t : items) { [EOL]             final MutableInt count = occurrences.get(t); [EOL]             if (count == null) { [EOL]                 occurrences.put(t, new MutableInt(1)); [EOL]             } else { [EOL]                 count.increment(); [EOL]             } [EOL]         } [EOL]         T result = null; [EOL]         int max = 0; [EOL]         for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]             final int cmp = e.getValue().intValue(); [EOL]             if (cmp == max) { [EOL]                 result = null; [EOL]             } else if (cmp > max) { [EOL]                 max = cmp; [EOL]                 result = e.getKey(); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     return null; [EOL] }
public static <T> T clone(final T obj) { [EOL]     if (obj instanceof Cloneable) { [EOL]         final Object result; [EOL]         if (obj.getClass().isArray()) { [EOL]             final Class<?> componentType = obj.getClass().getComponentType(); [EOL]             if (!componentType.isPrimitive()) { [EOL]                 result = ((Object[]) obj).clone(); [EOL]             } else { [EOL]                 int length = Array.getLength(obj); [EOL]                 result = Array.newInstance(componentType, length); [EOL]                 while (length-- > 0) { [EOL]                     Array.set(result, length, Array.get(obj, length)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             try { [EOL]                 final Method clone = obj.getClass().getMethod("clone"); [EOL]                 result = clone.invoke(obj); [EOL]             } catch (final NoSuchMethodException e) { [EOL]                 throw new CloneFailedException("Cloneable type " + obj.getClass().getName() + " has no clone method", e); [EOL]             } catch (final IllegalAccessException e) { [EOL]                 throw new CloneFailedException("Cannot clone Cloneable type " + obj.getClass().getName(), e); [EOL]             } catch (final InvocationTargetException e) { [EOL]                 throw new CloneFailedException("Exception cloning Cloneable type " + obj.getClass().getName(), e.getCause()); [EOL]             } [EOL]         } [EOL]         @SuppressWarnings("unchecked") [EOL]         final T checked = (T) result; [EOL]         return checked; [EOL]     } [EOL]     return null; [EOL] }

public static <T> T mode(final T... items) { [EOL]     if (ArrayUtils.isNotEmpty(items)) { [EOL]         final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(items.length); [EOL]         for (final T t : items) { [EOL]             final MutableInt count = occurrences.get(t); [EOL]             if (count == null) { [EOL]                 occurrences.put(t, new MutableInt(1)); [EOL]             } else { [EOL]                 count.increment(); [EOL]             } [EOL]         } [EOL]         T result = null; [EOL]         int max = 0; [EOL]         for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]             final int cmp = e.getValue().intValue(); [EOL]             if (cmp == max) { [EOL]                 result = null; [EOL]             } else if (cmp > max) { [EOL]                 max = cmp; [EOL]                 result = e.getKey(); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     return null; [EOL] }

public static <T> T mode(final T... items) { [EOL]     if (ArrayUtils.isNotEmpty(items)) { [EOL]         final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(items.length); [EOL]         for (final T t : items) { [EOL]             final MutableInt count = occurrences.get(t); [EOL]             if (count == null) { [EOL]                 occurrences.put(t, new MutableInt(1)); [EOL]             } else { [EOL]                 count.increment(); [EOL]             } [EOL]         } [EOL]         T result = null; [EOL]         int max = 0; [EOL]         for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]             final int cmp = e.getValue().intValue(); [EOL]             if (cmp == max) { [EOL]                 result = null; [EOL]             } else if (cmp > max) { [EOL]                 max = cmp; [EOL]                 result = e.getKey(); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     return null; [EOL] }

public static <T extends Comparable<? super T>> T min(final T... values) { [EOL]     T result = null; [EOL]     if (values != null) { [EOL]         for (final T value : values) { [EOL]             if (compare(value, result, true) < 0) { [EOL]                 result = value; [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] }

public static String toString(final Object obj, final String nullStr) { [EOL]     return obj == null ? nullStr : obj.toString(); [EOL] }
public static <T extends Comparable<? super T>> T max(final T... values) { [EOL]     T result = null; [EOL]     if (values != null) { [EOL]         for (final T value : values) { [EOL]             if (compare(value, result, false) > 0) { [EOL]                 result = value; [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public static <T extends Comparable<? super T>> T max(final T... values) { [EOL]     T result = null; [EOL]     if (values != null) { [EOL]         for (final T value : values) { [EOL]             if (compare(value, result, false) > 0) { [EOL]                 result = value; [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] }

public static <T extends Comparable<? super T>> T max(final T... values) { [EOL]     T result = null; [EOL]     if (values != null) { [EOL]         for (final T value : values) { [EOL]             if (compare(value, result, false) > 0) { [EOL]                 result = value; [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] }

public static <T extends Comparable<? super T>> T min(final T... values) { [EOL]     T result = null; [EOL]     if (values != null) { [EOL]         for (final T value : values) { [EOL]             if (compare(value, result, true) < 0) { [EOL]                 result = value; [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] }

public static String toString(final Object obj, final String nullStr) { [EOL]     return obj == null ? nullStr : obj.toString(); [EOL] }
public static <T> T mode(final T... items) { [EOL]     if (ArrayUtils.isNotEmpty(items)) { [EOL]         final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(items.length); [EOL]         for (final T t : items) { [EOL]             final MutableInt count = occurrences.get(t); [EOL]             if (count == null) { [EOL]                 occurrences.put(t, new MutableInt(1)); [EOL]             } else { [EOL]                 count.increment(); [EOL]             } [EOL]         } [EOL]         T result = null; [EOL]         int max = 0; [EOL]         for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]             final int cmp = e.getValue().intValue(); [EOL]             if (cmp == max) { [EOL]                 result = null; [EOL]             } else if (cmp > max) { [EOL]                 max = cmp; [EOL]                 result = e.getKey(); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     return null; [EOL] }
public static String toString(final Object obj, final String nullStr) { [EOL]     return obj == null ? nullStr : obj.toString(); [EOL] }

public static String toString(final Object obj, final String nullStr) { [EOL]     return obj == null ? nullStr : obj.toString(); [EOL] }
public static String toString(final Object obj, final String nullStr) { [EOL]     return obj == null ? nullStr : obj.toString(); [EOL] }

public static void identityToString(final StringBuffer buffer, final Object object) { [EOL]     if (object == null) { [EOL]         throw new NullPointerException("Cannot get the toString of a null identity"); [EOL]     } [EOL]     buffer.append(object.getClass().getName()).append('@').append(Integer.toHexString(System.identityHashCode(object))); [EOL] }
public static <T> T mode(final T... items) { [EOL]     if (ArrayUtils.isNotEmpty(items)) { [EOL]         final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(items.length); [EOL]         for (final T t : items) { [EOL]             final MutableInt count = occurrences.get(t); [EOL]             if (count == null) { [EOL]                 occurrences.put(t, new MutableInt(1)); [EOL]             } else { [EOL]                 count.increment(); [EOL]             } [EOL]         } [EOL]         T result = null; [EOL]         int max = 0; [EOL]         for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) { [EOL]             final int cmp = e.getValue().intValue(); [EOL]             if (cmp == max) { [EOL]                 result = null; [EOL]             } else if (cmp > max) { [EOL]                 max = cmp; [EOL]                 result = e.getKey(); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     return null; [EOL] }

public static void identityToString(final StringBuffer buffer, final Object object) { [EOL]     if (object == null) { [EOL]         throw new NullPointerException("Cannot get the toString of a null identity"); [EOL]     } [EOL]     buffer.append(object.getClass().getName()).append('@').append(Integer.toHexString(System.identityHashCode(object))); [EOL] }

public static int hashCode(final Object obj) { [EOL]     return obj == null ? 0 : obj.hashCode(); [EOL] }
public static int hashCodeMulti(final Object... objects) { [EOL]     int hash = 1; [EOL]     if (objects != null) { [EOL]         for (final Object object : objects) { [EOL]             hash = hash * 31 + ObjectUtils.hashCode(object); [EOL]         } [EOL]     } [EOL]     return hash; [EOL] }
public static boolean notEqual(final Object object1, final Object object2) { [EOL]     return ObjectUtils.equals(object1, object2) == false; [EOL] }
public static boolean equals(final Object object1, final Object object2) { [EOL]     if (object1 == object2) { [EOL]         return true; [EOL]     } [EOL]     if (object1 == null || object2 == null) { [EOL]         return false; [EOL]     } [EOL]     return object1.equals(object2); [EOL] }
public static boolean notEqual(final Object object1, final Object object2) { [EOL]     return ObjectUtils.equals(object1, object2) == false; [EOL] }
public static boolean equals(final Object object1, final Object object2) { [EOL]     if (object1 == object2) { [EOL]         return true; [EOL]     } [EOL]     if (object1 == null || object2 == null) { [EOL]         return false; [EOL]     } [EOL]     return object1.equals(object2); [EOL] }
public static <T> T firstNonNull(final T... values) { [EOL]     if (values != null) { [EOL]         for (final T val : values) { [EOL]             if (val != null) { [EOL]                 return val; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }

public static <T> T firstNonNull(final T... values) { [EOL]     if (values != null) { [EOL]         for (final T val : values) { [EOL]             if (val != null) { [EOL]                 return val; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }

public static <T> T firstNonNull(final T... values) { [EOL]     if (values != null) { [EOL]         for (final T val : values) { [EOL]             if (val != null) { [EOL]                 return val; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }

public static <T> T defaultIfNull(final T object, final T defaultValue) { [EOL]     return object != null ? object : defaultValue; [EOL] }

public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
public static <T> T CONST(final T v) { [EOL]     return v; [EOL] }
public static <T extends Comparable<? super T>> int compare(final T c1, final T c2, final boolean nullGreater) { [EOL]     if (c1 == c2) { [EOL]         return 0; [EOL]     } else if (c1 == null) { [EOL]         return nullGreater ? 1 : -1; [EOL]     } else if (c2 == null) { [EOL]         return nullGreater ? -1 : 1; [EOL]     } [EOL]     return c1.compareTo(c2); [EOL] }
methods/lang3/RandomStringUtils.java
public static String random(final int count, final char... chars) { [EOL]     if (chars == null) { [EOL]         return random(count, 0, 0, false, false, null, RANDOM); [EOL]     } [EOL]     return random(count, 0, chars.length, false, false, chars, RANDOM); [EOL] }
public static String randomAscii(final int count) { [EOL]     return random(count, 32, 127, false, false); [EOL] }

public static String random(final int count, final char... chars) { [EOL]     if (chars == null) { [EOL]         return random(count, 0, 0, false, false, null, RANDOM); [EOL]     } [EOL]     return random(count, 0, chars.length, false, false, chars, RANDOM); [EOL] }

public static String random(final int count, final char... chars) { [EOL]     if (chars == null) { [EOL]         return random(count, 0, 0, false, false, null, RANDOM); [EOL]     } [EOL]     return random(count, 0, chars.length, false, false, chars, RANDOM); [EOL] }




methods/lang3/CharEncoding.java
public static boolean isSupported(final String name) { [EOL]     if (name == null) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         return Charset.isSupported(name); [EOL]     } catch (final IllegalCharsetNameException ex) { [EOL]         return false; [EOL]     } [EOL] }
public static boolean isSupported(final String name) { [EOL]     if (name == null) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         return Charset.isSupported(name); [EOL]     } catch (final IllegalCharsetNameException ex) { [EOL]         return false; [EOL]     } [EOL] }
public static boolean isSupported(final String name) { [EOL]     if (name == null) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         return Charset.isSupported(name); [EOL]     } catch (final IllegalCharsetNameException ex) { [EOL]         return false; [EOL]     } [EOL] }
methods/lang3/ArrayUtils.java
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static void reverse(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     boolean tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     boolean tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     boolean tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     boolean tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     boolean tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     boolean tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     boolean tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     boolean tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] subarray = new boolean[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] }
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] subarray = new boolean[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] }
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] subarray = new boolean[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] }
public static String toString(final Object array, final String stringIfNull) { [EOL]     if (array == null) { [EOL]         return stringIfNull; [EOL]     } [EOL]     return new ToStringBuilder(array, ToStringStyle.SIMPLE_STYLE).append(array).toString(); [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
static Object removeAll(final Object array, final BitSet indices) { [EOL]     final int srcLength = ArrayUtils.getLength(array); [EOL]     final int removals = indices.cardinality(); [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals); [EOL]     int srcIndex = 0; [EOL]     int destIndex = 0; [EOL]     int count; [EOL]     int set; [EOL]     while ((set = indices.nextSetBit(srcIndex)) != -1) { [EOL]         count = set - srcIndex; [EOL]         if (count > 0) { [EOL]             System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]             destIndex += count; [EOL]         } [EOL]         srcIndex = indices.nextClearBit(set); [EOL]     } [EOL]     count = srcLength - srcIndex; [EOL]     if (count > 0) { [EOL]         System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]     } [EOL]     return result; [EOL] }
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Boolean b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.booleanValue()); [EOL]     } [EOL]     return result; [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
static Object removeAll(final Object array, final BitSet indices) { [EOL]     final int srcLength = ArrayUtils.getLength(array); [EOL]     final int removals = indices.cardinality(); [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals); [EOL]     int srcIndex = 0; [EOL]     int destIndex = 0; [EOL]     int count; [EOL]     int set; [EOL]     while ((set = indices.nextSetBit(srcIndex)) != -1) { [EOL]         count = set - srcIndex; [EOL]         if (count > 0) { [EOL]             System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]             destIndex += count; [EOL]         } [EOL]         srcIndex = indices.nextClearBit(set); [EOL]     } [EOL]     count = srcLength - srcIndex; [EOL]     if (count > 0) { [EOL]         System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]     } [EOL]     return result; [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
static Object removeAll(final Object array, final BitSet indices) { [EOL]     final int srcLength = ArrayUtils.getLength(array); [EOL]     final int removals = indices.cardinality(); [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals); [EOL]     int srcIndex = 0; [EOL]     int destIndex = 0; [EOL]     int count; [EOL]     int set; [EOL]     while ((set = indices.nextSetBit(srcIndex)) != -1) { [EOL]         count = set - srcIndex; [EOL]         if (count > 0) { [EOL]             System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]             destIndex += count; [EOL]         } [EOL]         srcIndex = indices.nextClearBit(set); [EOL]     } [EOL]     count = srcLength - srcIndex; [EOL]     if (count > 0) { [EOL]         System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]     } [EOL]     return result; [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
static Object removeAll(final Object array, final BitSet indices) { [EOL]     final int srcLength = ArrayUtils.getLength(array); [EOL]     final int removals = indices.cardinality(); [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals); [EOL]     int srcIndex = 0; [EOL]     int destIndex = 0; [EOL]     int count; [EOL]     int set; [EOL]     while ((set = indices.nextSetBit(srcIndex)) != -1) { [EOL]         count = set - srcIndex; [EOL]         if (count > 0) { [EOL]             System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]             destIndex += count; [EOL]         } [EOL]         srcIndex = indices.nextClearBit(set); [EOL]     } [EOL]     count = srcLength - srcIndex; [EOL]     if (count > 0) { [EOL]         System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]     } [EOL]     return result; [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
static Object removeAll(final Object array, final BitSet indices) { [EOL]     final int srcLength = ArrayUtils.getLength(array); [EOL]     final int removals = indices.cardinality(); [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals); [EOL]     int srcIndex = 0; [EOL]     int destIndex = 0; [EOL]     int count; [EOL]     int set; [EOL]     while ((set = indices.nextSetBit(srcIndex)) != -1) { [EOL]         count = set - srcIndex; [EOL]         if (count > 0) { [EOL]             System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]             destIndex += count; [EOL]         } [EOL]         srcIndex = indices.nextClearBit(set); [EOL]     } [EOL]     count = srcLength - srcIndex; [EOL]     if (count > 0) { [EOL]         System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]     } [EOL]     return result; [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
static Object removeAll(final Object array, final BitSet indices) { [EOL]     final int srcLength = ArrayUtils.getLength(array); [EOL]     final int removals = indices.cardinality(); [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals); [EOL]     int srcIndex = 0; [EOL]     int destIndex = 0; [EOL]     int count; [EOL]     int set; [EOL]     while ((set = indices.nextSetBit(srcIndex)) != -1) { [EOL]         count = set - srcIndex; [EOL]         if (count > 0) { [EOL]             System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]             destIndex += count; [EOL]         } [EOL]         srcIndex = indices.nextClearBit(set); [EOL]     } [EOL]     count = srcLength - srcIndex; [EOL]     if (count > 0) { [EOL]         System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]     } [EOL]     return result; [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static boolean isSameType(final Object array1, final Object array2) { [EOL]     if (array1 == null || array2 == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     return array1.getClass().getName().equals(array2.getClass().getName()); [EOL] }
public static boolean isEquals(final Object array1, final Object array2) { [EOL]     return new EqualsBuilder().append(array1, array2).isEquals(); [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static boolean[] clone(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static boolean[] clone(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static boolean[] clone(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static double[] addAll(final double[] array1, final double... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final double[] joinedArray = new double[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) { [EOL]     if (array == null) { [EOL]         if (index != 0) { [EOL]             throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0"); [EOL]         } [EOL]         final Object joinedArray = Array.newInstance(clss, 1); [EOL]         Array.set(joinedArray, 0, element); [EOL]         return joinedArray; [EOL]     } [EOL]     final int length = Array.getLength(array); [EOL]     if (index > length || index < 0) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(clss, length + 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     Array.set(result, index, element); [EOL]     if (index < length) { [EOL]         System.arraycopy(array, index, result, index + 1, length - index); [EOL]     } [EOL]     return result; [EOL] }
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) { [EOL]     if (array == null) { [EOL]         if (index != 0) { [EOL]             throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0"); [EOL]         } [EOL]         final Object joinedArray = Array.newInstance(clss, 1); [EOL]         Array.set(joinedArray, 0, element); [EOL]         return joinedArray; [EOL]     } [EOL]     final int length = Array.getLength(array); [EOL]     if (index > length || index < 0) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(clss, length + 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     Array.set(result, index, element); [EOL]     if (index < length) { [EOL]         System.arraycopy(array, index, result, index + 1, length - index); [EOL]     } [EOL]     return result; [EOL] }
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) { [EOL]     if (array == null) { [EOL]         if (index != 0) { [EOL]             throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0"); [EOL]         } [EOL]         final Object joinedArray = Array.newInstance(clss, 1); [EOL]         Array.set(joinedArray, 0, element); [EOL]         return joinedArray; [EOL]     } [EOL]     final int length = Array.getLength(array); [EOL]     if (index > length || index < 0) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(clss, length + 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     Array.set(result, index, element); [EOL]     if (index < length) { [EOL]         System.arraycopy(array, index, result, index + 1, length - index); [EOL]     } [EOL]     return result; [EOL] }
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) { [EOL]     if (array == null) { [EOL]         if (index != 0) { [EOL]             throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0"); [EOL]         } [EOL]         final Object joinedArray = Array.newInstance(clss, 1); [EOL]         Array.set(joinedArray, 0, element); [EOL]         return joinedArray; [EOL]     } [EOL]     final int length = Array.getLength(array); [EOL]     if (index > length || index < 0) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(clss, length + 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     Array.set(result, index, element); [EOL]     if (index < length) { [EOL]         System.arraycopy(array, index, result, index + 1, length - index); [EOL]     } [EOL]     return result; [EOL] }
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) { [EOL]     if (array == null) { [EOL]         if (index != 0) { [EOL]             throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0"); [EOL]         } [EOL]         final Object joinedArray = Array.newInstance(clss, 1); [EOL]         Array.set(joinedArray, 0, element); [EOL]         return joinedArray; [EOL]     } [EOL]     final int length = Array.getLength(array); [EOL]     if (index > length || index < 0) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(clss, length + 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     Array.set(result, index, element); [EOL]     if (index < length) { [EOL]         System.arraycopy(array, index, result, index + 1, length - index); [EOL]     } [EOL]     return result; [EOL] }
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) { [EOL]     if (array == null) { [EOL]         if (index != 0) { [EOL]             throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0"); [EOL]         } [EOL]         final Object joinedArray = Array.newInstance(clss, 1); [EOL]         Array.set(joinedArray, 0, element); [EOL]         return joinedArray; [EOL]     } [EOL]     final int length = Array.getLength(array); [EOL]     if (index > length || index < 0) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(clss, length + 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     Array.set(result, index, element); [EOL]     if (index < length) { [EOL]         System.arraycopy(array, index, result, index + 1, length - index); [EOL]     } [EOL]     return result; [EOL] }
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) { [EOL]     if (array == null) { [EOL]         if (index != 0) { [EOL]             throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0"); [EOL]         } [EOL]         final Object joinedArray = Array.newInstance(clss, 1); [EOL]         Array.set(joinedArray, 0, element); [EOL]         return joinedArray; [EOL]     } [EOL]     final int length = Array.getLength(array); [EOL]     if (index > length || index < 0) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(clss, length + 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     Array.set(result, index, element); [EOL]     if (index < length) { [EOL]         System.arraycopy(array, index, result, index + 1, length - index); [EOL]     } [EOL]     return result; [EOL] }
public static boolean isNotEmpty(final boolean[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isEmpty(final boolean[] array) { [EOL]     return array == null || array.length == 0; [EOL] }
public static boolean isEmpty(final boolean[] array) { [EOL]     return array == null || array.length == 0; [EOL] }
public static boolean isEmpty(final boolean[] array) { [EOL]     return array == null || array.length == 0; [EOL] }
public static boolean isEmpty(final boolean[] array) { [EOL]     return array == null || array.length == 0; [EOL] }
public static boolean isEmpty(final boolean[] array) { [EOL]     return array == null || array.length == 0; [EOL] }
public static boolean isEmpty(final boolean[] array) { [EOL]     return array == null || array.length == 0; [EOL] }
public static boolean isEmpty(final boolean[] array) { [EOL]     return array == null || array.length == 0; [EOL] }
public static boolean isEmpty(final boolean[] array) { [EOL]     return array == null || array.length == 0; [EOL] }
public static boolean isEmpty(final boolean[] array) { [EOL]     return array == null || array.length == 0; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int getLength(final Object array) { [EOL]     if (array == null) { [EOL]         return 0; [EOL]     } [EOL]     return Array.getLength(array); [EOL] }
public static boolean[] clone(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static boolean[] clone(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static boolean[] clone(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static boolean[] clone(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static boolean[] clone(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static boolean[] clone(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static boolean[] clone(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static boolean[] clone(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static String toString(final Object array, final String stringIfNull) { [EOL]     if (array == null) { [EOL]         return stringIfNull; [EOL]     } [EOL]     return new ToStringBuilder(array, ToStringStyle.SIMPLE_STYLE).append(array).toString(); [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static boolean[] removeElements(final boolean[] array, final boolean... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2); [EOL]     for (final boolean v : values) { [EOL]         final Boolean boxed = Boolean.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) { [EOL]         final Boolean v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.booleanValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (boolean[]) removeAll(array, toRemove); [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static boolean[] removeElements(final boolean[] array, final boolean... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2); [EOL]     for (final boolean v : values) { [EOL]         final Boolean boxed = Boolean.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) { [EOL]         final Boolean v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.booleanValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (boolean[]) removeAll(array, toRemove); [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static boolean[] removeElements(final boolean[] array, final boolean... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2); [EOL]     for (final boolean v : values) { [EOL]         final Boolean boxed = Boolean.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) { [EOL]         final Boolean v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.booleanValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (boolean[]) removeAll(array, toRemove); [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static boolean[] removeElements(final boolean[] array, final boolean... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2); [EOL]     for (final boolean v : values) { [EOL]         final Boolean boxed = Boolean.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) { [EOL]         final Boolean v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.booleanValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (boolean[]) removeAll(array, toRemove); [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static boolean[] removeElements(final boolean[] array, final boolean... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2); [EOL]     for (final boolean v : values) { [EOL]         final Boolean boxed = Boolean.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) { [EOL]         final Boolean v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.booleanValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (boolean[]) removeAll(array, toRemove); [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static boolean[] removeElements(final boolean[] array, final boolean... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2); [EOL]     for (final boolean v : values) { [EOL]         final Boolean boxed = Boolean.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) { [EOL]         final Boolean v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.booleanValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (boolean[]) removeAll(array, toRemove); [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static boolean[] removeElements(final boolean[] array, final boolean... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2); [EOL]     for (final boolean v : values) { [EOL]         final Boolean boxed = Boolean.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) { [EOL]         final Boolean v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.booleanValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (boolean[]) removeAll(array, toRemove); [EOL] }
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) { [EOL]     if (array == null) { [EOL]         if (index != 0) { [EOL]             throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0"); [EOL]         } [EOL]         final Object joinedArray = Array.newInstance(clss, 1); [EOL]         Array.set(joinedArray, 0, element); [EOL]         return joinedArray; [EOL]     } [EOL]     final int length = Array.getLength(array); [EOL]     if (index > length || index < 0) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(clss, length + 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     Array.set(result, index, element); [EOL]     if (index < length) { [EOL]         System.arraycopy(array, index, result, index + 1, length - index); [EOL]     } [EOL]     return result; [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static boolean[] removeElements(final boolean[] array, final boolean... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2); [EOL]     for (final boolean v : values) { [EOL]         final Boolean boxed = Boolean.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) { [EOL]         final Boolean v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.booleanValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (boolean[]) removeAll(array, toRemove); [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static boolean[] removeElements(final boolean[] array, final boolean... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2); [EOL]     for (final boolean v : values) { [EOL]         final Boolean boxed = Boolean.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) { [EOL]         final Boolean v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.booleanValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (boolean[]) removeAll(array, toRemove); [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static boolean[] removeElements(final boolean[] array, final boolean... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2); [EOL]     for (final boolean v : values) { [EOL]         final Boolean boxed = Boolean.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) { [EOL]         final Boolean v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.booleanValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (boolean[]) removeAll(array, toRemove); [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) { [EOL]     if (array == null) { [EOL]         if (index != 0) { [EOL]             throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0"); [EOL]         } [EOL]         final Object joinedArray = Array.newInstance(clss, 1); [EOL]         Array.set(joinedArray, 0, element); [EOL]         return joinedArray; [EOL]     } [EOL]     final int length = Array.getLength(array); [EOL]     if (index > length || index < 0) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(clss, length + 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     Array.set(result, index, element); [EOL]     if (index < length) { [EOL]         System.arraycopy(array, index, result, index + 1, length - index); [EOL]     } [EOL]     return result; [EOL] }
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) { [EOL]     if (array == null) { [EOL]         if (index != 0) { [EOL]             throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0"); [EOL]         } [EOL]         final Object joinedArray = Array.newInstance(clss, 1); [EOL]         Array.set(joinedArray, 0, element); [EOL]         return joinedArray; [EOL]     } [EOL]     final int length = Array.getLength(array); [EOL]     if (index > length || index < 0) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(clss, length + 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     Array.set(result, index, element); [EOL]     if (index < length) { [EOL]         System.arraycopy(array, index, result, index + 1, length - index); [EOL]     } [EOL]     return result; [EOL] }
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) { [EOL]     if (array == null) { [EOL]         if (index != 0) { [EOL]             throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0"); [EOL]         } [EOL]         final Object joinedArray = Array.newInstance(clss, 1); [EOL]         Array.set(joinedArray, 0, element); [EOL]         return joinedArray; [EOL]     } [EOL]     final int length = Array.getLength(array); [EOL]     if (index > length || index < 0) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(clss, length + 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     Array.set(result, index, element); [EOL]     if (index < length) { [EOL]         System.arraycopy(array, index, result, index + 1, length - index); [EOL]     } [EOL]     return result; [EOL] }
public static double[] addAll(final double[] array1, final double... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final double[] joinedArray = new double[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) { [EOL]     if (array == null) { [EOL]         if (index != 0) { [EOL]             throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0"); [EOL]         } [EOL]         final Object joinedArray = Array.newInstance(clss, 1); [EOL]         Array.set(joinedArray, 0, element); [EOL]         return joinedArray; [EOL]     } [EOL]     final int length = Array.getLength(array); [EOL]     if (index > length || index < 0) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(clss, length + 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     Array.set(result, index, element); [EOL]     if (index < length) { [EOL]         System.arraycopy(array, index, result, index + 1, length - index); [EOL]     } [EOL]     return result; [EOL] }
public static double[] addAll(final double[] array1, final double... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final double[] joinedArray = new double[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) { [EOL]     if (array == null) { [EOL]         if (index != 0) { [EOL]             throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0"); [EOL]         } [EOL]         final Object joinedArray = Array.newInstance(clss, 1); [EOL]         Array.set(joinedArray, 0, element); [EOL]         return joinedArray; [EOL]     } [EOL]     final int length = Array.getLength(array); [EOL]     if (index > length || index < 0) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(clss, length + 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     Array.set(result, index, element); [EOL]     if (index < length) { [EOL]         System.arraycopy(array, index, result, index + 1, length - index); [EOL]     } [EOL]     return result; [EOL] }
public static double[] addAll(final double[] array1, final double... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final double[] joinedArray = new double[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) { [EOL]     if (array == null) { [EOL]         if (index != 0) { [EOL]             throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0"); [EOL]         } [EOL]         final Object joinedArray = Array.newInstance(clss, 1); [EOL]         Array.set(joinedArray, 0, element); [EOL]         return joinedArray; [EOL]     } [EOL]     final int length = Array.getLength(array); [EOL]     if (index > length || index < 0) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(clss, length + 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     Array.set(result, index, element); [EOL]     if (index < length) { [EOL]         System.arraycopy(array, index, result, index + 1, length - index); [EOL]     } [EOL]     return result; [EOL] }
public static double[] addAll(final double[] array1, final double... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final double[] joinedArray = new double[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) { [EOL]     if (array == null) { [EOL]         if (index != 0) { [EOL]             throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0"); [EOL]         } [EOL]         final Object joinedArray = Array.newInstance(clss, 1); [EOL]         Array.set(joinedArray, 0, element); [EOL]         return joinedArray; [EOL]     } [EOL]     final int length = Array.getLength(array); [EOL]     if (index > length || index < 0) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(clss, length + 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     Array.set(result, index, element); [EOL]     if (index < length) { [EOL]         System.arraycopy(array, index, result, index + 1, length - index); [EOL]     } [EOL]     return result; [EOL] }
public static double[] addAll(final double[] array1, final double... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final double[] joinedArray = new double[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) { [EOL]     if (array == null) { [EOL]         if (index != 0) { [EOL]             throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0"); [EOL]         } [EOL]         final Object joinedArray = Array.newInstance(clss, 1); [EOL]         Array.set(joinedArray, 0, element); [EOL]         return joinedArray; [EOL]     } [EOL]     final int length = Array.getLength(array); [EOL]     if (index > length || index < 0) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(clss, length + 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     Array.set(result, index, element); [EOL]     if (index < length) { [EOL]         System.arraycopy(array, index, result, index + 1, length - index); [EOL]     } [EOL]     return result; [EOL] }
public static double[] addAll(final double[] array1, final double... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final double[] joinedArray = new double[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) { [EOL]     if (array == null) { [EOL]         if (index != 0) { [EOL]             throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0"); [EOL]         } [EOL]         final Object joinedArray = Array.newInstance(clss, 1); [EOL]         Array.set(joinedArray, 0, element); [EOL]         return joinedArray; [EOL]     } [EOL]     final int length = Array.getLength(array); [EOL]     if (index > length || index < 0) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(clss, length + 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     Array.set(result, index, element); [EOL]     if (index < length) { [EOL]         System.arraycopy(array, index, result, index + 1, length - index); [EOL]     } [EOL]     return result; [EOL] }
public static double[] addAll(final double[] array1, final double... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final double[] joinedArray = new double[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) { [EOL]     if (array == null) { [EOL]         if (index != 0) { [EOL]             throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0"); [EOL]         } [EOL]         final Object joinedArray = Array.newInstance(clss, 1); [EOL]         Array.set(joinedArray, 0, element); [EOL]         return joinedArray; [EOL]     } [EOL]     final int length = Array.getLength(array); [EOL]     if (index > length || index < 0) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(clss, length + 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     Array.set(result, index, element); [EOL]     if (index < length) { [EOL]         System.arraycopy(array, index, result, index + 1, length - index); [EOL]     } [EOL]     return result; [EOL] }
public static double[] addAll(final double[] array1, final double... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final double[] joinedArray = new double[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) { [EOL]     if (array == null) { [EOL]         if (index != 0) { [EOL]             throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0"); [EOL]         } [EOL]         final Object joinedArray = Array.newInstance(clss, 1); [EOL]         Array.set(joinedArray, 0, element); [EOL]         return joinedArray; [EOL]     } [EOL]     final int length = Array.getLength(array); [EOL]     if (index > length || index < 0) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(clss, length + 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     Array.set(result, index, element); [EOL]     if (index < length) { [EOL]         System.arraycopy(array, index, result, index + 1, length - index); [EOL]     } [EOL]     return result; [EOL] }
public static double[] addAll(final double[] array1, final double... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final double[] joinedArray = new double[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) { [EOL]     if (array == null) { [EOL]         if (index != 0) { [EOL]             throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0"); [EOL]         } [EOL]         final Object joinedArray = Array.newInstance(clss, 1); [EOL]         Array.set(joinedArray, 0, element); [EOL]         return joinedArray; [EOL]     } [EOL]     final int length = Array.getLength(array); [EOL]     if (index > length || index < 0) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(clss, length + 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     Array.set(result, index, element); [EOL]     if (index < length) { [EOL]         System.arraycopy(array, index, result, index + 1, length - index); [EOL]     } [EOL]     return result; [EOL] }
public static double[] addAll(final double[] array1, final double... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final double[] joinedArray = new double[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) { [EOL]     if (array == null) { [EOL]         if (index != 0) { [EOL]             throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0"); [EOL]         } [EOL]         final Object joinedArray = Array.newInstance(clss, 1); [EOL]         Array.set(joinedArray, 0, element); [EOL]         return joinedArray; [EOL]     } [EOL]     final int length = Array.getLength(array); [EOL]     if (index > length || index < 0) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(clss, length + 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     Array.set(result, index, element); [EOL]     if (index < length) { [EOL]         System.arraycopy(array, index, result, index + 1, length - index); [EOL]     } [EOL]     return result; [EOL] }
public static boolean isNotEmpty(final boolean[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final boolean[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final boolean[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final boolean[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final boolean[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final boolean[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final boolean[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final boolean[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final boolean[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
static Object removeAll(final Object array, final BitSet indices) { [EOL]     final int srcLength = ArrayUtils.getLength(array); [EOL]     final int removals = indices.cardinality(); [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals); [EOL]     int srcIndex = 0; [EOL]     int destIndex = 0; [EOL]     int count; [EOL]     int set; [EOL]     while ((set = indices.nextSetBit(srcIndex)) != -1) { [EOL]         count = set - srcIndex; [EOL]         if (count > 0) { [EOL]             System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]             destIndex += count; [EOL]         } [EOL]         srcIndex = indices.nextClearBit(set); [EOL]     } [EOL]     count = srcLength - srcIndex; [EOL]     if (count > 0) { [EOL]         System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]     } [EOL]     return result; [EOL] }
public static boolean isNotEmpty(final boolean[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final boolean[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final boolean[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final boolean[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final boolean[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final boolean[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final boolean[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final boolean[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final boolean[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final boolean[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isNotEmpty(final boolean[] array) { [EOL]     return (array != null && array.length != 0); [EOL] }
public static boolean isEmpty(final boolean[] array) { [EOL]     return array == null || array.length == 0; [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static boolean[] removeElements(final boolean[] array, final boolean... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2); [EOL]     for (final boolean v : values) { [EOL]         final Boolean boxed = Boolean.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) { [EOL]         final Boolean v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.booleanValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (boolean[]) removeAll(array, toRemove); [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static boolean[] removeElements(final boolean[] array, final boolean... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2); [EOL]     for (final boolean v : values) { [EOL]         final Boolean boxed = Boolean.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) { [EOL]         final Boolean v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.booleanValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (boolean[]) removeAll(array, toRemove); [EOL] }
public static boolean isEmpty(final boolean[] array) { [EOL]     return array == null || array.length == 0; [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static boolean[] removeElements(final boolean[] array, final boolean... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2); [EOL]     for (final boolean v : values) { [EOL]         final Boolean boxed = Boolean.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) { [EOL]         final Boolean v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.booleanValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (boolean[]) removeAll(array, toRemove); [EOL] }
public static boolean isEmpty(final boolean[] array) { [EOL]     return array == null || array.length == 0; [EOL] }
public static boolean isEmpty(final boolean[] array) { [EOL]     return array == null || array.length == 0; [EOL] }
public static boolean isEmpty(final boolean[] array) { [EOL]     return array == null || array.length == 0; [EOL] }
public static boolean isEmpty(final boolean[] array) { [EOL]     return array == null || array.length == 0; [EOL] }
public static boolean isEmpty(final boolean[] array) { [EOL]     return array == null || array.length == 0; [EOL] }
public static Boolean[] toObject(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     final Boolean[] result = new Boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE); [EOL]     } [EOL]     return result; [EOL] }
public static Boolean[] toObject(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     final Boolean[] result = new Boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE); [EOL]     } [EOL]     return result; [EOL] }
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Boolean b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.booleanValue()); [EOL]     } [EOL]     return result; [EOL] }
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Boolean b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.booleanValue()); [EOL]     } [EOL]     return result; [EOL] }
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Boolean b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.booleanValue()); [EOL]     } [EOL]     return result; [EOL] }
public static Boolean[] toObject(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     final Boolean[] result = new Boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE); [EOL]     } [EOL]     return result; [EOL] }
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Boolean b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.booleanValue()); [EOL]     } [EOL]     return result; [EOL] }
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Boolean b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.booleanValue()); [EOL]     } [EOL]     return result; [EOL] }
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Boolean b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.booleanValue()); [EOL]     } [EOL]     return result; [EOL] }
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Boolean b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.booleanValue()); [EOL]     } [EOL]     return result; [EOL] }
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Boolean b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.booleanValue()); [EOL]     } [EOL]     return result; [EOL] }
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Boolean b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.booleanValue()); [EOL]     } [EOL]     return result; [EOL] }
public static Boolean[] toObject(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     final Boolean[] result = new Boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE); [EOL]     } [EOL]     return result; [EOL] }
public static Boolean[] toObject(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     final Boolean[] result = new Boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE); [EOL]     } [EOL]     return result; [EOL] }
public static Boolean[] toObject(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     final Boolean[] result = new Boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE); [EOL]     } [EOL]     return result; [EOL] }
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Boolean b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.booleanValue()); [EOL]     } [EOL]     return result; [EOL] }
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Boolean b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.booleanValue()); [EOL]     } [EOL]     return result; [EOL] }
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Boolean b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.booleanValue()); [EOL]     } [EOL]     return result; [EOL] }
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Boolean b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.booleanValue()); [EOL]     } [EOL]     return result; [EOL] }
public static Boolean[] toObject(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     final Boolean[] result = new Boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE); [EOL]     } [EOL]     return result; [EOL] }
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Boolean b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.booleanValue()); [EOL]     } [EOL]     return result; [EOL] }
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Boolean b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.booleanValue()); [EOL]     } [EOL]     return result; [EOL] }
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Boolean b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.booleanValue()); [EOL]     } [EOL]     return result; [EOL] }
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Boolean b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.booleanValue()); [EOL]     } [EOL]     return result; [EOL] }
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Boolean b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.booleanValue()); [EOL]     } [EOL]     return result; [EOL] }
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Boolean b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.booleanValue()); [EOL]     } [EOL]     return result; [EOL] }
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Boolean b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.booleanValue()); [EOL]     } [EOL]     return result; [EOL] }
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Boolean b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.booleanValue()); [EOL]     } [EOL]     return result; [EOL] }
public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] result = new boolean[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Boolean b = array[i]; [EOL]         result[i] = (b == null ? valueForNull : b.booleanValue()); [EOL]     } [EOL]     return result; [EOL] }
public static boolean contains(final boolean[] array, final boolean valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final boolean[] array, final boolean valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final boolean[] array, final boolean valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final boolean[] array, final boolean valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final boolean[] array, final boolean valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final boolean[] array, final boolean valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final boolean[] array, final boolean valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final boolean[] array, final boolean valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final boolean[] array, final boolean valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final boolean[] array, final boolean valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final boolean[] array, final boolean valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final boolean[] array, final boolean valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final boolean[] array, final boolean valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final boolean[] array, final boolean valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static boolean[] removeElements(final boolean[] array, final boolean... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2); [EOL]     for (final boolean v : values) { [EOL]         final Boolean boxed = Boolean.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) { [EOL]         final Boolean v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.booleanValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (boolean[]) removeAll(array, toRemove); [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static void reverse(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     boolean tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     boolean tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     boolean tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     boolean tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     boolean tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     boolean tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     boolean tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static void reverse(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     int j = array.length - 1; [EOL]     boolean tmp; [EOL]     while (j > i) { [EOL]         tmp = array[j]; [EOL]         array[j] = array[i]; [EOL]         array[i] = tmp; [EOL]         j--; [EOL]         i++; [EOL]     } [EOL] }
public static boolean isSameType(final Object array1, final Object array2) { [EOL]     if (array1 == null || array2 == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     return array1.getClass().getName().equals(array2.getClass().getName()); [EOL] }
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean isSameLength(final boolean[] array1, final boolean[] array2) { [EOL]     if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] subarray = new boolean[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] }
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] subarray = new boolean[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] }
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] subarray = new boolean[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] }
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] subarray = new boolean[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] }
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] subarray = new boolean[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] }
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] subarray = new boolean[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] }
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] subarray = new boolean[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] }
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] subarray = new boolean[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] }
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] subarray = new boolean[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     if (startIndexInclusive < 0) { [EOL]         startIndexInclusive = 0; [EOL]     } [EOL]     if (endIndexExclusive > array.length) { [EOL]         endIndexExclusive = array.length; [EOL]     } [EOL]     final int newSize = endIndexExclusive - startIndexInclusive; [EOL]     if (newSize <= 0) { [EOL]         return EMPTY_BOOLEAN_ARRAY; [EOL]     } [EOL]     final boolean[] subarray = new boolean[newSize]; [EOL]     System.arraycopy(array, startIndexInclusive, subarray, 0, newSize); [EOL]     return subarray; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static boolean[] removeElements(final boolean[] array, final boolean... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2); [EOL]     for (final boolean v : values) { [EOL]         final Boolean boxed = Boolean.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) { [EOL]         final Boolean v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.booleanValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (boolean[]) removeAll(array, toRemove); [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static boolean[] removeElements(final boolean[] array, final boolean... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2); [EOL]     for (final boolean v : values) { [EOL]         final Boolean boxed = Boolean.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) { [EOL]         final Boolean v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.booleanValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (boolean[]) removeAll(array, toRemove); [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static boolean[] clone(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static double[] addAll(final double[] array1, final double... array2) { [EOL]     if (array1 == null) { [EOL]         return clone(array2); [EOL]     } else if (array2 == null) { [EOL]         return clone(array1); [EOL]     } [EOL]     final double[] joinedArray = new double[array1.length + array2.length]; [EOL]     System.arraycopy(array1, 0, joinedArray, 0, array1.length); [EOL]     System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); [EOL]     return joinedArray; [EOL] }
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) { [EOL]     if (array == null) { [EOL]         if (index != 0) { [EOL]             throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0"); [EOL]         } [EOL]         final Object joinedArray = Array.newInstance(clss, 1); [EOL]         Array.set(joinedArray, 0, element); [EOL]         return joinedArray; [EOL]     } [EOL]     final int length = Array.getLength(array); [EOL]     if (index > length || index < 0) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(clss, length + 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     Array.set(result, index, element); [EOL]     if (index < length) { [EOL]         System.arraycopy(array, index, result, index + 1, length - index); [EOL]     } [EOL]     return result; [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static boolean[] removeElements(final boolean[] array, final boolean... values) { [EOL]     if (isEmpty(array) || isEmpty(values)) { [EOL]         return clone(array); [EOL]     } [EOL]     final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2); [EOL]     for (final boolean v : values) { [EOL]         final Boolean boxed = Boolean.valueOf(v); [EOL]         final MutableInt count = occurrences.get(boxed); [EOL]         if (count == null) { [EOL]             occurrences.put(boxed, new MutableInt(1)); [EOL]         } else { [EOL]             count.increment(); [EOL]         } [EOL]     } [EOL]     final BitSet toRemove = new BitSet(); [EOL]     for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) { [EOL]         final Boolean v = e.getKey(); [EOL]         int found = 0; [EOL]         for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) { [EOL]             found = indexOf(array, v.booleanValue(), found); [EOL]             if (found < 0) { [EOL]                 break; [EOL]             } [EOL]             toRemove.set(found++); [EOL]         } [EOL]     } [EOL]     return (boolean[]) removeAll(array, toRemove); [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static boolean[] clone(final boolean[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     return array.clone(); [EOL] }
public static Map<Object, Object> toMap(final Object[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5)); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Object object = array[i]; [EOL]         if (object instanceof Map.Entry<?, ?>) { [EOL]             final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) object; [EOL]             map.put(entry.getKey(), entry.getValue()); [EOL]         } else if (object instanceof Object[]) { [EOL]             final Object[] entry = (Object[]) object; [EOL]             if (entry.length < 2) { [EOL]                 throw new IllegalArgumentException("Array element " + i + ", '" + object + "', has a length less than 2"); [EOL]             } [EOL]             map.put(entry[0], entry[1]); [EOL]         } else { [EOL]             throw new IllegalArgumentException("Array element " + i + ", '" + object + "', is neither of type Map.Entry nor an Array"); [EOL]         } [EOL]     } [EOL]     return map; [EOL] }
public static boolean isEmpty(final boolean[] array) { [EOL]     return array == null || array.length == 0; [EOL] }
public static Map<Object, Object> toMap(final Object[] array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } [EOL]     final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5)); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         final Object object = array[i]; [EOL]         if (object instanceof Map.Entry<?, ?>) { [EOL]             final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) object; [EOL]             map.put(entry.getKey(), entry.getValue()); [EOL]         } else if (object instanceof Object[]) { [EOL]             final Object[] entry = (Object[]) object; [EOL]             if (entry.length < 2) { [EOL]                 throw new IllegalArgumentException("Array element " + i + ", '" + object + "', has a length less than 2"); [EOL]             } [EOL]             map.put(entry[0], entry[1]); [EOL]         } else { [EOL]             throw new IllegalArgumentException("Array element " + i + ", '" + object + "', is neither of type Map.Entry nor an Array"); [EOL]         } [EOL]     } [EOL]     return map; [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
static Object removeAll(final Object array, final BitSet indices) { [EOL]     final int srcLength = ArrayUtils.getLength(array); [EOL]     final int removals = indices.cardinality(); [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals); [EOL]     int srcIndex = 0; [EOL]     int destIndex = 0; [EOL]     int count; [EOL]     int set; [EOL]     while ((set = indices.nextSetBit(srcIndex)) != -1) { [EOL]         count = set - srcIndex; [EOL]         if (count > 0) { [EOL]             System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]             destIndex += count; [EOL]         } [EOL]         srcIndex = indices.nextClearBit(set); [EOL]     } [EOL]     count = srcLength - srcIndex; [EOL]     if (count > 0) { [EOL]         System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]     } [EOL]     return result; [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static <T> T[] toArray(final T... items) { [EOL]     return items; [EOL] }
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) { [EOL]     if (array == null) { [EOL]         if (index != 0) { [EOL]             throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0"); [EOL]         } [EOL]         final Object joinedArray = Array.newInstance(clss, 1); [EOL]         Array.set(joinedArray, 0, element); [EOL]         return joinedArray; [EOL]     } [EOL]     final int length = Array.getLength(array); [EOL]     if (index > length || index < 0) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(clss, length + 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     Array.set(result, index, element); [EOL]     if (index < length) { [EOL]         System.arraycopy(array, index, result, index + 1, length - index); [EOL]     } [EOL]     return result; [EOL] }
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) { [EOL]     if (array == null) { [EOL]         if (index != 0) { [EOL]             throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0"); [EOL]         } [EOL]         final Object joinedArray = Array.newInstance(clss, 1); [EOL]         Array.set(joinedArray, 0, element); [EOL]         return joinedArray; [EOL]     } [EOL]     final int length = Array.getLength(array); [EOL]     if (index > length || index < 0) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(clss, length + 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     Array.set(result, index, element); [EOL]     if (index < length) { [EOL]         System.arraycopy(array, index, result, index + 1, length - index); [EOL]     } [EOL]     return result; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static Boolean[] nullToEmpty(final Boolean[] array) { [EOL]     if (array == null || array.length == 0) { [EOL]         return EMPTY_BOOLEAN_OBJECT_ARRAY; [EOL]     } [EOL]     return array; [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
static Object removeAll(final Object array, final BitSet indices) { [EOL]     final int srcLength = ArrayUtils.getLength(array); [EOL]     final int removals = indices.cardinality(); [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals); [EOL]     int srcIndex = 0; [EOL]     int destIndex = 0; [EOL]     int count; [EOL]     int set; [EOL]     while ((set = indices.nextSetBit(srcIndex)) != -1) { [EOL]         count = set - srcIndex; [EOL]         if (count > 0) { [EOL]             System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]             destIndex += count; [EOL]         } [EOL]         srcIndex = indices.nextClearBit(set); [EOL]     } [EOL]     count = srcLength - srcIndex; [EOL]     if (count > 0) { [EOL]         System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]     } [EOL]     return result; [EOL] }
public static boolean contains(final boolean[] array, final boolean valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final boolean[] array, final boolean valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static boolean contains(final boolean[] array, final boolean valueToFind) { [EOL]     return indexOf(array, valueToFind) != INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         startIndex = 0; [EOL]     } [EOL]     for (int i = startIndex; i < array.length; i++) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
static Object removeAll(final Object array, final BitSet indices) { [EOL]     final int srcLength = ArrayUtils.getLength(array); [EOL]     final int removals = indices.cardinality(); [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals); [EOL]     int srcIndex = 0; [EOL]     int destIndex = 0; [EOL]     int count; [EOL]     int set; [EOL]     while ((set = indices.nextSetBit(srcIndex)) != -1) { [EOL]         count = set - srcIndex; [EOL]         if (count > 0) { [EOL]             System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]             destIndex += count; [EOL]         } [EOL]         srcIndex = indices.nextClearBit(set); [EOL]     } [EOL]     count = srcLength - srcIndex; [EOL]     if (count > 0) { [EOL]         System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]     } [EOL]     return result; [EOL] }
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) { [EOL]     if (array == null) { [EOL]         if (index != 0) { [EOL]             throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0"); [EOL]         } [EOL]         final Object joinedArray = Array.newInstance(clss, 1); [EOL]         Array.set(joinedArray, 0, element); [EOL]         return joinedArray; [EOL]     } [EOL]     final int length = Array.getLength(array); [EOL]     if (index > length || index < 0) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(clss, length + 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     Array.set(result, index, element); [EOL]     if (index < length) { [EOL]         System.arraycopy(array, index, result, index + 1, length - index); [EOL]     } [EOL]     return result; [EOL] }
public static boolean isEquals(final Object array1, final Object array2) { [EOL]     return new EqualsBuilder().append(array1, array2).isEquals(); [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
static Object removeAll(final Object array, final BitSet indices) { [EOL]     final int srcLength = ArrayUtils.getLength(array); [EOL]     final int removals = indices.cardinality(); [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals); [EOL]     int srcIndex = 0; [EOL]     int destIndex = 0; [EOL]     int count; [EOL]     int set; [EOL]     while ((set = indices.nextSetBit(srcIndex)) != -1) { [EOL]         count = set - srcIndex; [EOL]         if (count > 0) { [EOL]             System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]             destIndex += count; [EOL]         } [EOL]         srcIndex = indices.nextClearBit(set); [EOL]     } [EOL]     count = srcLength - srcIndex; [EOL]     if (count > 0) { [EOL]         System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]     } [EOL]     return result; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
public static String toString(final Object array, final String stringIfNull) { [EOL]     if (array == null) { [EOL]         return stringIfNull; [EOL]     } [EOL]     return new ToStringBuilder(array, ToStringStyle.SIMPLE_STYLE).append(array).toString(); [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
static Object removeAll(final Object array, final BitSet indices) { [EOL]     final int srcLength = ArrayUtils.getLength(array); [EOL]     final int removals = indices.cardinality(); [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals); [EOL]     int srcIndex = 0; [EOL]     int destIndex = 0; [EOL]     int count; [EOL]     int set; [EOL]     while ((set = indices.nextSetBit(srcIndex)) != -1) { [EOL]         count = set - srcIndex; [EOL]         if (count > 0) { [EOL]             System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]             destIndex += count; [EOL]         } [EOL]         srcIndex = indices.nextClearBit(set); [EOL]     } [EOL]     count = srcLength - srcIndex; [EOL]     if (count > 0) { [EOL]         System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]     } [EOL]     return result; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
static Object removeAll(final Object array, final BitSet indices) { [EOL]     final int srcLength = ArrayUtils.getLength(array); [EOL]     final int removals = indices.cardinality(); [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals); [EOL]     int srcIndex = 0; [EOL]     int destIndex = 0; [EOL]     int count; [EOL]     int set; [EOL]     while ((set = indices.nextSetBit(srcIndex)) != -1) { [EOL]         count = set - srcIndex; [EOL]         if (count > 0) { [EOL]             System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]             destIndex += count; [EOL]         } [EOL]         srcIndex = indices.nextClearBit(set); [EOL]     } [EOL]     count = srcLength - srcIndex; [EOL]     if (count > 0) { [EOL]         System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]     } [EOL]     return result; [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
public static short[] removeElement(final short[] array, final short element) { [EOL]     final int index = indexOf(array, element); [EOL]     if (index == INDEX_NOT_FOUND) { [EOL]         return clone(array); [EOL]     } [EOL]     return remove(array, index); [EOL] }
private static Object remove(final Object array, final int index) { [EOL]     final int length = getLength(array); [EOL]     if (index < 0 || index >= length) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     if (index < length - 1) { [EOL]         System.arraycopy(array, index + 1, result, index, length - index - 1); [EOL]     } [EOL]     return result; [EOL] }
static Object removeAll(final Object array, final BitSet indices) { [EOL]     final int srcLength = ArrayUtils.getLength(array); [EOL]     final int removals = indices.cardinality(); [EOL]     final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals); [EOL]     int srcIndex = 0; [EOL]     int destIndex = 0; [EOL]     int count; [EOL]     int set; [EOL]     while ((set = indices.nextSetBit(srcIndex)) != -1) { [EOL]         count = set - srcIndex; [EOL]         if (count > 0) { [EOL]             System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]             destIndex += count; [EOL]         } [EOL]         srcIndex = indices.nextClearBit(set); [EOL]     } [EOL]     count = srcLength - srcIndex; [EOL]     if (count > 0) { [EOL]         System.arraycopy(array, srcIndex, result, destIndex, count); [EOL]     } [EOL]     return result; [EOL] }
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) { [EOL]     if (array == null) { [EOL]         if (index != 0) { [EOL]             throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0"); [EOL]         } [EOL]         final Object joinedArray = Array.newInstance(clss, 1); [EOL]         Array.set(joinedArray, 0, element); [EOL]         return joinedArray; [EOL]     } [EOL]     final int length = Array.getLength(array); [EOL]     if (index > length || index < 0) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(clss, length + 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     Array.set(result, index, element); [EOL]     if (index < length) { [EOL]         System.arraycopy(array, index, result, index + 1, length - index); [EOL]     } [EOL]     return result; [EOL] }
private static Object add(final Object array, final int index, final Object element, final Class<?> clss) { [EOL]     if (array == null) { [EOL]         if (index != 0) { [EOL]             throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0"); [EOL]         } [EOL]         final Object joinedArray = Array.newInstance(clss, 1); [EOL]         Array.set(joinedArray, 0, element); [EOL]         return joinedArray; [EOL]     } [EOL]     final int length = Array.getLength(array); [EOL]     if (index > length || index < 0) { [EOL]         throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); [EOL]     } [EOL]     final Object result = Array.newInstance(clss, length + 1); [EOL]     System.arraycopy(array, 0, result, 0, index); [EOL]     Array.set(result, index, element); [EOL]     if (index < length) { [EOL]         System.arraycopy(array, index, result, index + 1, length - index); [EOL]     } [EOL]     return result; [EOL] }
public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) { [EOL]     if (ArrayUtils.isEmpty(array)) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startIndex < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } else if (startIndex >= array.length) { [EOL]         startIndex = array.length - 1; [EOL]     } [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (valueToFind == array[i]) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
methods/lang3/CharUtils.java
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiAlpha(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'); [EOL] }
public static boolean isAsciiAlphanumeric(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9'); [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiAlpha(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'); [EOL] }
public static boolean isAsciiAlphanumeric(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9'); [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiAlpha(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'); [EOL] }
public static boolean isAsciiAlphanumeric(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9'); [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiAlpha(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'); [EOL] }
public static boolean isAsciiAlphanumeric(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9'); [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiAlpha(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'); [EOL] }
public static boolean isAsciiAlphanumeric(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9'); [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiAlpha(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'); [EOL] }
public static boolean isAsciiAlphanumeric(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9'); [EOL] }
public static int toIntValue(final Character ch, final int defaultValue) { [EOL]     if (ch == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     return toIntValue(ch.charValue(), defaultValue); [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiAlpha(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'); [EOL] }
public static boolean isAsciiAlphaLower(final char ch) { [EOL]     return ch >= 'a' && ch <= 'z'; [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiAlpha(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'); [EOL] }
public static boolean isAsciiAlphaLower(final char ch) { [EOL]     return ch >= 'a' && ch <= 'z'; [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiAlpha(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'); [EOL] }
public static boolean isAsciiAlphaUpper(final char ch) { [EOL]     return ch >= 'A' && ch <= 'Z'; [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiAlpha(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'); [EOL] }
public static boolean isAsciiAlphaUpper(final char ch) { [EOL]     return ch >= 'A' && ch <= 'Z'; [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiAlpha(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'); [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiAlpha(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'); [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiAlpha(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'); [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiAlpha(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'); [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiControl(final char ch) { [EOL]     return ch < 32 || ch == 127; [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiControl(final char ch) { [EOL]     return ch < 32 || ch == 127; [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiPrintable(final char ch) { [EOL]     return ch >= 32 && ch < 127; [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiPrintable(final char ch) { [EOL]     return ch >= 32 && ch < 127; [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static String unicodeEscaped(final Character ch) { [EOL]     if (ch == null) { [EOL]         return null; [EOL]     } [EOL]     return unicodeEscaped(ch.charValue()); [EOL] }
public static String toString(final Character ch) { [EOL]     if (ch == null) { [EOL]         return null; [EOL]     } [EOL]     return toString(ch.charValue()); [EOL] }
public static int toIntValue(final Character ch, final int defaultValue) { [EOL]     if (ch == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     return toIntValue(ch.charValue(), defaultValue); [EOL] }
public static int toIntValue(final Character ch, final int defaultValue) { [EOL]     if (ch == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     return toIntValue(ch.charValue(), defaultValue); [EOL] }
public static int toIntValue(final Character ch, final int defaultValue) { [EOL]     if (ch == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     return toIntValue(ch.charValue(), defaultValue); [EOL] }
public static char toChar(final String str, final char defaultValue) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return defaultValue; [EOL]     } [EOL]     return str.charAt(0); [EOL] }
public static char toChar(final String str, final char defaultValue) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return defaultValue; [EOL]     } [EOL]     return str.charAt(0); [EOL] }
public static char toChar(final String str, final char defaultValue) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return defaultValue; [EOL]     } [EOL]     return str.charAt(0); [EOL] }
public static char toChar(final String str, final char defaultValue) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return defaultValue; [EOL]     } [EOL]     return str.charAt(0); [EOL] }
public static char toChar(final String str, final char defaultValue) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return defaultValue; [EOL]     } [EOL]     return str.charAt(0); [EOL] }
public static char toChar(final String str, final char defaultValue) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return defaultValue; [EOL]     } [EOL]     return str.charAt(0); [EOL] }
public static Character toCharacterObject(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return null; [EOL]     } [EOL]     return Character.valueOf(str.charAt(0)); [EOL] }
public static char toChar(final String str, final char defaultValue) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return defaultValue; [EOL]     } [EOL]     return str.charAt(0); [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiNumeric(final char ch) { [EOL]     return ch >= '0' && ch <= '9'; [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiNumeric(final char ch) { [EOL]     return ch >= '0' && ch <= '9'; [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiNumeric(final char ch) { [EOL]     return ch >= '0' && ch <= '9'; [EOL] }
public static String toString(final Character ch) { [EOL]     if (ch == null) { [EOL]         return null; [EOL]     } [EOL]     return toString(ch.charValue()); [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiAlpha(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'); [EOL] }
public static boolean isAsciiAlphanumeric(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9'); [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiAlpha(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'); [EOL] }
public static boolean isAsciiAlphanumeric(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9'); [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiAlpha(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'); [EOL] }
public static boolean isAsciiAlphaLower(final char ch) { [EOL]     return ch >= 'a' && ch <= 'z'; [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiAlpha(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'); [EOL] }
public static boolean isAsciiAlphaLower(final char ch) { [EOL]     return ch >= 'a' && ch <= 'z'; [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiAlpha(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'); [EOL] }
public static boolean isAsciiAlphaUpper(final char ch) { [EOL]     return ch >= 'A' && ch <= 'Z'; [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiAlpha(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'); [EOL] }
public static boolean isAsciiAlphaUpper(final char ch) { [EOL]     return ch >= 'A' && ch <= 'Z'; [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiAlpha(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'); [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiAlpha(final char ch) { [EOL]     return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'); [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiControl(final char ch) { [EOL]     return ch < 32 || ch == 127; [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiControl(final char ch) { [EOL]     return ch < 32 || ch == 127; [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiPrintable(final char ch) { [EOL]     return ch >= 32 && ch < 127; [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAsciiPrintable(final char ch) { [EOL]     return ch >= 32 && ch < 127; [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static boolean isAscii(final char ch) { [EOL]     return ch < 128; [EOL] }
public static String unicodeEscaped(final Character ch) { [EOL]     if (ch == null) { [EOL]         return null; [EOL]     } [EOL]     return unicodeEscaped(ch.charValue()); [EOL] }
public static String unicodeEscaped(final Character ch) { [EOL]     if (ch == null) { [EOL]         return null; [EOL]     } [EOL]     return unicodeEscaped(ch.charValue()); [EOL] }
public static String unicodeEscaped(final Character ch) { [EOL]     if (ch == null) { [EOL]         return null; [EOL]     } [EOL]     return unicodeEscaped(ch.charValue()); [EOL] }
public static String unicodeEscaped(final Character ch) { [EOL]     if (ch == null) { [EOL]         return null; [EOL]     } [EOL]     return unicodeEscaped(ch.charValue()); [EOL] }
public static String toString(final Character ch) { [EOL]     if (ch == null) { [EOL]         return null; [EOL]     } [EOL]     return toString(ch.charValue()); [EOL] }
public static String toString(final Character ch) { [EOL]     if (ch == null) { [EOL]         return null; [EOL]     } [EOL]     return toString(ch.charValue()); [EOL] }
public static int toIntValue(final Character ch, final int defaultValue) { [EOL]     if (ch == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     return toIntValue(ch.charValue(), defaultValue); [EOL] }
public static int toIntValue(final Character ch, final int defaultValue) { [EOL]     if (ch == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     return toIntValue(ch.charValue(), defaultValue); [EOL] }
public static int toIntValue(final Character ch, final int defaultValue) { [EOL]     if (ch == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     return toIntValue(ch.charValue(), defaultValue); [EOL] }
public static int toIntValue(final Character ch, final int defaultValue) { [EOL]     if (ch == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     return toIntValue(ch.charValue(), defaultValue); [EOL] }
public static char toChar(final String str, final char defaultValue) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return defaultValue; [EOL]     } [EOL]     return str.charAt(0); [EOL] }
public static char toChar(final String str, final char defaultValue) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return defaultValue; [EOL]     } [EOL]     return str.charAt(0); [EOL] }
public static char toChar(final String str, final char defaultValue) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return defaultValue; [EOL]     } [EOL]     return str.charAt(0); [EOL] }
public static char toChar(final String str, final char defaultValue) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return defaultValue; [EOL]     } [EOL]     return str.charAt(0); [EOL] }
public static Character toCharacterObject(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return null; [EOL]     } [EOL]     return Character.valueOf(str.charAt(0)); [EOL] }
public static char toChar(final String str, final char defaultValue) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return defaultValue; [EOL]     } [EOL]     return str.charAt(0); [EOL] }
public static char toChar(final String str, final char defaultValue) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return defaultValue; [EOL]     } [EOL]     return str.charAt(0); [EOL] }
methods/lang3/LocaleUtils.java
public static List<Locale> countriesByLanguage(final String languageCode) { [EOL]     if (languageCode == null) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     List<Locale> countries = cCountriesByLanguage.get(languageCode); [EOL]     if (countries == null) { [EOL]         countries = new ArrayList<Locale>(); [EOL]         final List<Locale> locales = availableLocaleList(); [EOL]         for (int i = 0; i < locales.size(); i++) { [EOL]             final Locale locale = locales.get(i); [EOL]             if (languageCode.equals(locale.getLanguage()) && locale.getCountry().length() != 0 && locale.getVariant().isEmpty()) { [EOL]                 countries.add(locale); [EOL]             } [EOL]         } [EOL]         countries = Collections.unmodifiableList(countries); [EOL]         cCountriesByLanguage.putIfAbsent(languageCode, countries); [EOL]         countries = cCountriesByLanguage.get(languageCode); [EOL]     } [EOL]     return countries; [EOL] }
public static List<Locale> languagesByCountry(final String countryCode) { [EOL]     if (countryCode == null) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     List<Locale> langs = cLanguagesByCountry.get(countryCode); [EOL]     if (langs == null) { [EOL]         langs = new ArrayList<Locale>(); [EOL]         final List<Locale> locales = availableLocaleList(); [EOL]         for (int i = 0; i < locales.size(); i++) { [EOL]             final Locale locale = locales.get(i); [EOL]             if (countryCode.equals(locale.getCountry()) && locale.getVariant().isEmpty()) { [EOL]                 langs.add(locale); [EOL]             } [EOL]         } [EOL]         langs = Collections.unmodifiableList(langs); [EOL]         cLanguagesByCountry.putIfAbsent(countryCode, langs); [EOL]         langs = cLanguagesByCountry.get(countryCode); [EOL]     } [EOL]     return langs; [EOL] }
public static List<Locale> localeLookupList(final Locale locale, final Locale defaultLocale) { [EOL]     final List<Locale> list = new ArrayList<Locale>(4); [EOL]     if (locale != null) { [EOL]         list.add(locale); [EOL]         if (locale.getVariant().length() > 0) { [EOL]             list.add(new Locale(locale.getLanguage(), locale.getCountry())); [EOL]         } [EOL]         if (locale.getCountry().length() > 0) { [EOL]             list.add(new Locale(locale.getLanguage(), "")); [EOL]         } [EOL]         if (list.contains(defaultLocale) == false) { [EOL]             list.add(defaultLocale); [EOL]         } [EOL]     } [EOL]     return Collections.unmodifiableList(list); [EOL] }
public static List<Locale> localeLookupList(final Locale locale, final Locale defaultLocale) { [EOL]     final List<Locale> list = new ArrayList<Locale>(4); [EOL]     if (locale != null) { [EOL]         list.add(locale); [EOL]         if (locale.getVariant().length() > 0) { [EOL]             list.add(new Locale(locale.getLanguage(), locale.getCountry())); [EOL]         } [EOL]         if (locale.getCountry().length() > 0) { [EOL]             list.add(new Locale(locale.getLanguage(), "")); [EOL]         } [EOL]         if (list.contains(defaultLocale) == false) { [EOL]             list.add(defaultLocale); [EOL]         } [EOL]     } [EOL]     return Collections.unmodifiableList(list); [EOL] }
public static List<Locale> countriesByLanguage(final String languageCode) { [EOL]     if (languageCode == null) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     List<Locale> countries = cCountriesByLanguage.get(languageCode); [EOL]     if (countries == null) { [EOL]         countries = new ArrayList<Locale>(); [EOL]         final List<Locale> locales = availableLocaleList(); [EOL]         for (int i = 0; i < locales.size(); i++) { [EOL]             final Locale locale = locales.get(i); [EOL]             if (languageCode.equals(locale.getLanguage()) && locale.getCountry().length() != 0 && locale.getVariant().isEmpty()) { [EOL]                 countries.add(locale); [EOL]             } [EOL]         } [EOL]         countries = Collections.unmodifiableList(countries); [EOL]         cCountriesByLanguage.putIfAbsent(languageCode, countries); [EOL]         countries = cCountriesByLanguage.get(languageCode); [EOL]     } [EOL]     return countries; [EOL] }
public static List<Locale> languagesByCountry(final String countryCode) { [EOL]     if (countryCode == null) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     List<Locale> langs = cLanguagesByCountry.get(countryCode); [EOL]     if (langs == null) { [EOL]         langs = new ArrayList<Locale>(); [EOL]         final List<Locale> locales = availableLocaleList(); [EOL]         for (int i = 0; i < locales.size(); i++) { [EOL]             final Locale locale = locales.get(i); [EOL]             if (countryCode.equals(locale.getCountry()) && locale.getVariant().isEmpty()) { [EOL]                 langs.add(locale); [EOL]             } [EOL]         } [EOL]         langs = Collections.unmodifiableList(langs); [EOL]         cLanguagesByCountry.putIfAbsent(countryCode, langs); [EOL]         langs = cLanguagesByCountry.get(countryCode); [EOL]     } [EOL]     return langs; [EOL] }
public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } else { [EOL]         final char ch1 = str.charAt(1); [EOL]         if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 2) { [EOL]             return new Locale(str); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(2) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch3 = str.charAt(3); [EOL]         if (ch3 == '_') { [EOL]             return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]         } [EOL]         final char ch4 = str.charAt(4); [EOL]         if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 5) { [EOL]             return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]         } [EOL]         if (len < 7) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(5) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL]     } [EOL] }
public static boolean isAvailableLocale(final Locale locale) { [EOL]     return availableLocaleList().contains(locale); [EOL] }
public static boolean isAvailableLocale(final Locale locale) { [EOL]     return availableLocaleList().contains(locale); [EOL] }
public static List<Locale> localeLookupList(final Locale locale, final Locale defaultLocale) { [EOL]     final List<Locale> list = new ArrayList<Locale>(4); [EOL]     if (locale != null) { [EOL]         list.add(locale); [EOL]         if (locale.getVariant().length() > 0) { [EOL]             list.add(new Locale(locale.getLanguage(), locale.getCountry())); [EOL]         } [EOL]         if (locale.getCountry().length() > 0) { [EOL]             list.add(new Locale(locale.getLanguage(), "")); [EOL]         } [EOL]         if (list.contains(defaultLocale) == false) { [EOL]             list.add(defaultLocale); [EOL]         } [EOL]     } [EOL]     return Collections.unmodifiableList(list); [EOL] }
public static List<Locale> localeLookupList(final Locale locale, final Locale defaultLocale) { [EOL]     final List<Locale> list = new ArrayList<Locale>(4); [EOL]     if (locale != null) { [EOL]         list.add(locale); [EOL]         if (locale.getVariant().length() > 0) { [EOL]             list.add(new Locale(locale.getLanguage(), locale.getCountry())); [EOL]         } [EOL]         if (locale.getCountry().length() > 0) { [EOL]             list.add(new Locale(locale.getLanguage(), "")); [EOL]         } [EOL]         if (list.contains(defaultLocale) == false) { [EOL]             list.add(defaultLocale); [EOL]         } [EOL]     } [EOL]     return Collections.unmodifiableList(list); [EOL] }
public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } else { [EOL]         final char ch1 = str.charAt(1); [EOL]         if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 2) { [EOL]             return new Locale(str); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(2) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch3 = str.charAt(3); [EOL]         if (ch3 == '_') { [EOL]             return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]         } [EOL]         final char ch4 = str.charAt(4); [EOL]         if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 5) { [EOL]             return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]         } [EOL]         if (len < 7) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(5) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL]     } [EOL] }
public static Locale toLocale(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     final int len = str.length(); [EOL]     if (len < 2) { [EOL]         throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]     } [EOL]     final char ch0 = str.charAt(0); [EOL]     if (ch0 == '_') { [EOL]         if (len < 3) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch1 = str.charAt(1); [EOL]         final char ch2 = str.charAt(2); [EOL]         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 3) { [EOL]             return new Locale("", str.substring(1, 3)); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(3) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale("", str.substring(1, 3), str.substring(4)); [EOL]     } else { [EOL]         final char ch1 = str.charAt(1); [EOL]         if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 2) { [EOL]             return new Locale(str); [EOL]         } [EOL]         if (len < 5) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(2) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         final char ch3 = str.charAt(3); [EOL]         if (ch3 == '_') { [EOL]             return new Locale(str.substring(0, 2), "", str.substring(4)); [EOL]         } [EOL]         final char ch4 = str.charAt(4); [EOL]         if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (len == 5) { [EOL]             return new Locale(str.substring(0, 2), str.substring(3, 5)); [EOL]         } [EOL]         if (len < 7) { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         if (str.charAt(5) != '_') { [EOL]             throw new IllegalArgumentException("Invalid locale format: " + str); [EOL]         } [EOL]         return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6)); [EOL]     } [EOL] }
public static List<Locale> localeLookupList(final Locale locale, final Locale defaultLocale) { [EOL]     final List<Locale> list = new ArrayList<Locale>(4); [EOL]     if (locale != null) { [EOL]         list.add(locale); [EOL]         if (locale.getVariant().length() > 0) { [EOL]             list.add(new Locale(locale.getLanguage(), locale.getCountry())); [EOL]         } [EOL]         if (locale.getCountry().length() > 0) { [EOL]             list.add(new Locale(locale.getLanguage(), "")); [EOL]         } [EOL]         if (list.contains(defaultLocale) == false) { [EOL]             list.add(defaultLocale); [EOL]         } [EOL]     } [EOL]     return Collections.unmodifiableList(list); [EOL] }
public static List<Locale> availableLocaleList() { [EOL]     return SyncAvoid.AVAILABLE_LOCALE_LIST; [EOL] }
public static List<Locale> countriesByLanguage(final String languageCode) { [EOL]     if (languageCode == null) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     List<Locale> countries = cCountriesByLanguage.get(languageCode); [EOL]     if (countries == null) { [EOL]         countries = new ArrayList<Locale>(); [EOL]         final List<Locale> locales = availableLocaleList(); [EOL]         for (int i = 0; i < locales.size(); i++) { [EOL]             final Locale locale = locales.get(i); [EOL]             if (languageCode.equals(locale.getLanguage()) && locale.getCountry().length() != 0 && locale.getVariant().isEmpty()) { [EOL]                 countries.add(locale); [EOL]             } [EOL]         } [EOL]         countries = Collections.unmodifiableList(countries); [EOL]         cCountriesByLanguage.putIfAbsent(languageCode, countries); [EOL]         countries = cCountriesByLanguage.get(languageCode); [EOL]     } [EOL]     return countries; [EOL] }
public static Set<Locale> availableLocaleSet() { [EOL]     return SyncAvoid.AVAILABLE_LOCALE_SET; [EOL] }
methods/lang3/CharSetUtils.java
public static String squeeze(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return str; [EOL]     } [EOL]     final CharSet chars = CharSet.getInstance(set); [EOL]     final StringBuilder buffer = new StringBuilder(str.length()); [EOL]     final char[] chrs = str.toCharArray(); [EOL]     final int sz = chrs.length; [EOL]     char lastChar = ' '; [EOL]     char ch = ' '; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         ch = chrs[i]; [EOL]         if (ch == lastChar && i != 0 && chars.contains(ch)) { [EOL]             continue; [EOL]         } [EOL]         buffer.append(ch); [EOL]         lastChar = ch; [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public static String delete(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return str; [EOL]     } [EOL]     return modify(str, set, false); [EOL] }
public static String delete(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return str; [EOL]     } [EOL]     return modify(str, set, false); [EOL] }
public static String delete(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return str; [EOL]     } [EOL]     return modify(str, set, false); [EOL] }
public static String delete(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return str; [EOL]     } [EOL]     return modify(str, set, false); [EOL] }
public static String keep(final String str, final String... set) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.length() == 0 || deepEmpty(set)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     return modify(str, set, true); [EOL] }
public static String keep(final String str, final String... set) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.length() == 0 || deepEmpty(set)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     return modify(str, set, true); [EOL] }
public static String keep(final String str, final String... set) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.length() == 0 || deepEmpty(set)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     return modify(str, set, true); [EOL] }
public static int count(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return 0; [EOL]     } [EOL]     final CharSet chars = CharSet.getInstance(set); [EOL]     int count = 0; [EOL]     for (final char c : str.toCharArray()) { [EOL]         if (chars.contains(c)) { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return count; [EOL] }
public static int count(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return 0; [EOL]     } [EOL]     final CharSet chars = CharSet.getInstance(set); [EOL]     int count = 0; [EOL]     for (final char c : str.toCharArray()) { [EOL]         if (chars.contains(c)) { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return count; [EOL] }
public static int count(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return 0; [EOL]     } [EOL]     final CharSet chars = CharSet.getInstance(set); [EOL]     int count = 0; [EOL]     for (final char c : str.toCharArray()) { [EOL]         if (chars.contains(c)) { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return count; [EOL] }
public static int count(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return 0; [EOL]     } [EOL]     final CharSet chars = CharSet.getInstance(set); [EOL]     int count = 0; [EOL]     for (final char c : str.toCharArray()) { [EOL]         if (chars.contains(c)) { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return count; [EOL] }
public static boolean containsAny(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return false; [EOL]     } [EOL]     final CharSet chars = CharSet.getInstance(set); [EOL]     for (final char c : str.toCharArray()) { [EOL]         if (chars.contains(c)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean containsAny(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return false; [EOL]     } [EOL]     final CharSet chars = CharSet.getInstance(set); [EOL]     for (final char c : str.toCharArray()) { [EOL]         if (chars.contains(c)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean containsAny(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return false; [EOL]     } [EOL]     final CharSet chars = CharSet.getInstance(set); [EOL]     for (final char c : str.toCharArray()) { [EOL]         if (chars.contains(c)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean containsAny(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return false; [EOL]     } [EOL]     final CharSet chars = CharSet.getInstance(set); [EOL]     for (final char c : str.toCharArray()) { [EOL]         if (chars.contains(c)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static String squeeze(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return str; [EOL]     } [EOL]     final CharSet chars = CharSet.getInstance(set); [EOL]     final StringBuilder buffer = new StringBuilder(str.length()); [EOL]     final char[] chrs = str.toCharArray(); [EOL]     final int sz = chrs.length; [EOL]     char lastChar = ' '; [EOL]     char ch = ' '; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         ch = chrs[i]; [EOL]         if (ch == lastChar && i != 0 && chars.contains(ch)) { [EOL]             continue; [EOL]         } [EOL]         buffer.append(ch); [EOL]         lastChar = ch; [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public static String squeeze(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return str; [EOL]     } [EOL]     final CharSet chars = CharSet.getInstance(set); [EOL]     final StringBuilder buffer = new StringBuilder(str.length()); [EOL]     final char[] chrs = str.toCharArray(); [EOL]     final int sz = chrs.length; [EOL]     char lastChar = ' '; [EOL]     char ch = ' '; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         ch = chrs[i]; [EOL]         if (ch == lastChar && i != 0 && chars.contains(ch)) { [EOL]             continue; [EOL]         } [EOL]         buffer.append(ch); [EOL]         lastChar = ch; [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public static String squeeze(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return str; [EOL]     } [EOL]     final CharSet chars = CharSet.getInstance(set); [EOL]     final StringBuilder buffer = new StringBuilder(str.length()); [EOL]     final char[] chrs = str.toCharArray(); [EOL]     final int sz = chrs.length; [EOL]     char lastChar = ' '; [EOL]     char ch = ' '; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         ch = chrs[i]; [EOL]         if (ch == lastChar && i != 0 && chars.contains(ch)) { [EOL]             continue; [EOL]         } [EOL]         buffer.append(ch); [EOL]         lastChar = ch; [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public static String squeeze(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return str; [EOL]     } [EOL]     final CharSet chars = CharSet.getInstance(set); [EOL]     final StringBuilder buffer = new StringBuilder(str.length()); [EOL]     final char[] chrs = str.toCharArray(); [EOL]     final int sz = chrs.length; [EOL]     char lastChar = ' '; [EOL]     char ch = ' '; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         ch = chrs[i]; [EOL]         if (ch == lastChar && i != 0 && chars.contains(ch)) { [EOL]             continue; [EOL]         } [EOL]         buffer.append(ch); [EOL]         lastChar = ch; [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public static String squeeze(final String str, final String... set) { [EOL]     if (StringUtils.isEmpty(str) || deepEmpty(set)) { [EOL]         return str; [EOL]     } [EOL]     final CharSet chars = CharSet.getInstance(set); [EOL]     final StringBuilder buffer = new StringBuilder(str.length()); [EOL]     final char[] chrs = str.toCharArray(); [EOL]     final int sz = chrs.length; [EOL]     char lastChar = ' '; [EOL]     char ch = ' '; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         ch = chrs[i]; [EOL]         if (ch == lastChar && i != 0 && chars.contains(ch)) { [EOL]             continue; [EOL]         } [EOL]         buffer.append(ch); [EOL]         lastChar = ch; [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public static String keep(final String str, final String... set) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (str.length() == 0 || deepEmpty(set)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     return modify(str, set, true); [EOL] }
methods/lang3/StringEscapeUtils.java
public static final String escapeCsv(final String input) { [EOL]     return ESCAPE_CSV.translate(input); [EOL] }
public static final String unescapeCsv(final String input) { [EOL]     return UNESCAPE_CSV.translate(input); [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (index != 0) { [EOL]         throw new IllegalStateException("CsvUnescaper should never reach the [1] index"); [EOL]     } [EOL]     if (input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE) { [EOL]         out.write(input.toString()); [EOL]         return input.length(); [EOL]     } [EOL]     final String quoteless = input.subSequence(1, input.length() - 1).toString(); [EOL]     if (StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS)) { [EOL]         out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR)); [EOL]     } else { [EOL]         out.write(input.toString()); [EOL]     } [EOL]     return input.length(); [EOL] }
public static final String escapeXml(final String input) { [EOL]     return ESCAPE_XML.translate(input); [EOL] }
public static final String unescapeXml(final String input) { [EOL]     return UNESCAPE_XML.translate(input); [EOL] }
public static final String escapeXml(final String input) { [EOL]     return ESCAPE_XML.translate(input); [EOL] }
public static final String unescapeXml(final String input) { [EOL]     return UNESCAPE_XML.translate(input); [EOL] }
public static final String escapeJson(final String input) { [EOL]     return ESCAPE_JSON.translate(input); [EOL] }
public static final String unescapeJson(final String input) { [EOL]     return UNESCAPE_JSON.translate(input); [EOL] }
public static final String escapeJson(final String input) { [EOL]     return ESCAPE_JSON.translate(input); [EOL] }
public static final String unescapeJson(final String input) { [EOL]     return UNESCAPE_JSON.translate(input); [EOL] }
public static final String escapeJava(final String input) { [EOL]     return ESCAPE_JAVA.translate(input); [EOL] }
public static final String unescapeJava(final String input) { [EOL]     return UNESCAPE_JAVA.translate(input); [EOL] }
public static final String escapeJava(final String input) { [EOL]     return ESCAPE_JAVA.translate(input); [EOL] }
public static final String unescapeJava(final String input) { [EOL]     return UNESCAPE_JAVA.translate(input); [EOL] }
public static final String escapeHtml4(final String input) { [EOL]     return ESCAPE_HTML4.translate(input); [EOL] }
public static final String unescapeHtml4(final String input) { [EOL]     return UNESCAPE_HTML4.translate(input); [EOL] }
public static final String escapeHtml4(final String input) { [EOL]     return ESCAPE_HTML4.translate(input); [EOL] }
public static final String unescapeHtml4(final String input) { [EOL]     return UNESCAPE_HTML4.translate(input); [EOL] }
public static final String escapeHtml3(final String input) { [EOL]     return ESCAPE_HTML3.translate(input); [EOL] }
public static final String unescapeHtml3(final String input) { [EOL]     return UNESCAPE_HTML3.translate(input); [EOL] }
public static final String escapeHtml3(final String input) { [EOL]     return ESCAPE_HTML3.translate(input); [EOL] }
public static final String unescapeHtml3(final String input) { [EOL]     return UNESCAPE_HTML3.translate(input); [EOL] }
public static final String escapeEcmaScript(final String input) { [EOL]     return ESCAPE_ECMASCRIPT.translate(input); [EOL] }
public static final String unescapeEcmaScript(final String input) { [EOL]     return UNESCAPE_ECMASCRIPT.translate(input); [EOL] }
public static final String escapeEcmaScript(final String input) { [EOL]     return ESCAPE_ECMASCRIPT.translate(input); [EOL] }
public static final String unescapeEcmaScript(final String input) { [EOL]     return UNESCAPE_ECMASCRIPT.translate(input); [EOL] }
public static final String escapeCsv(final String input) { [EOL]     return ESCAPE_CSV.translate(input); [EOL] }
public static final String unescapeCsv(final String input) { [EOL]     return UNESCAPE_CSV.translate(input); [EOL] }
public static final String escapeCsv(final String input) { [EOL]     return ESCAPE_CSV.translate(input); [EOL] }
public static final String unescapeCsv(final String input) { [EOL]     return UNESCAPE_CSV.translate(input); [EOL] }
public static final String escapeXml(final String input) { [EOL]     return ESCAPE_XML.translate(input); [EOL] }
public static final String escapeXml(final String input) { [EOL]     return ESCAPE_XML.translate(input); [EOL] }
public static final String escapeJson(final String input) { [EOL]     return ESCAPE_JSON.translate(input); [EOL] }
public static final String escapeJson(final String input) { [EOL]     return ESCAPE_JSON.translate(input); [EOL] }
public static final String escapeJava(final String input) { [EOL]     return ESCAPE_JAVA.translate(input); [EOL] }
public static final String escapeJava(final String input) { [EOL]     return ESCAPE_JAVA.translate(input); [EOL] }
public static final String escapeHtml4(final String input) { [EOL]     return ESCAPE_HTML4.translate(input); [EOL] }
public static final String escapeHtml4(final String input) { [EOL]     return ESCAPE_HTML4.translate(input); [EOL] }
public static final String escapeHtml3(final String input) { [EOL]     return ESCAPE_HTML3.translate(input); [EOL] }
public static final String escapeHtml3(final String input) { [EOL]     return ESCAPE_HTML3.translate(input); [EOL] }
public static final String escapeEcmaScript(final String input) { [EOL]     return ESCAPE_ECMASCRIPT.translate(input); [EOL] }
public static final String escapeEcmaScript(final String input) { [EOL]     return ESCAPE_ECMASCRIPT.translate(input); [EOL] }
public static final String escapeCsv(final String input) { [EOL]     return ESCAPE_CSV.translate(input); [EOL] }
public static final String escapeCsv(final String input) { [EOL]     return ESCAPE_CSV.translate(input); [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (index != 0) { [EOL]         throw new IllegalStateException("CsvUnescaper should never reach the [1] index"); [EOL]     } [EOL]     if (input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE) { [EOL]         out.write(input.toString()); [EOL]         return input.length(); [EOL]     } [EOL]     final String quoteless = input.subSequence(1, input.length() - 1).toString(); [EOL]     if (StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS)) { [EOL]         out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR)); [EOL]     } else { [EOL]         out.write(input.toString()); [EOL]     } [EOL]     return input.length(); [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (index != 0) { [EOL]         throw new IllegalStateException("CsvUnescaper should never reach the [1] index"); [EOL]     } [EOL]     if (input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE) { [EOL]         out.write(input.toString()); [EOL]         return input.length(); [EOL]     } [EOL]     final String quoteless = input.subSequence(1, input.length() - 1).toString(); [EOL]     if (StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS)) { [EOL]         out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR)); [EOL]     } else { [EOL]         out.write(input.toString()); [EOL]     } [EOL]     return input.length(); [EOL] }
public static final String escapeCsv(final String input) { [EOL]     return ESCAPE_CSV.translate(input); [EOL] }
public static final String escapeCsv(final String input) { [EOL]     return ESCAPE_CSV.translate(input); [EOL] }
public static final String escapeEcmaScript(final String input) { [EOL]     return ESCAPE_ECMASCRIPT.translate(input); [EOL] }
public static final String escapeJava(final String input) { [EOL]     return ESCAPE_JAVA.translate(input); [EOL] }
public static final String escapeXml(final String input) { [EOL]     return ESCAPE_XML.translate(input); [EOL] }
public static final String unescapeXml(final String input) { [EOL]     return UNESCAPE_XML.translate(input); [EOL] }
public static final String escapeJson(final String input) { [EOL]     return ESCAPE_JSON.translate(input); [EOL] }
public static final String escapeXml(final String input) { [EOL]     return ESCAPE_XML.translate(input); [EOL] }
public static final String escapeHtml4(final String input) { [EOL]     return ESCAPE_HTML4.translate(input); [EOL] }
public static final String unescapeHtml4(final String input) { [EOL]     return UNESCAPE_HTML4.translate(input); [EOL] }
public static final String escapeHtml3(final String input) { [EOL]     return ESCAPE_HTML3.translate(input); [EOL] }
public static final String unescapeHtml3(final String input) { [EOL]     return UNESCAPE_HTML3.translate(input); [EOL] }
public static final String escapeJava(final String input) { [EOL]     return ESCAPE_JAVA.translate(input); [EOL] }
public static final String unescapeJava(final String input) { [EOL]     return UNESCAPE_JAVA.translate(input); [EOL] }
public static final String escapeHtml4(final String input) { [EOL]     return ESCAPE_HTML4.translate(input); [EOL] }
public static final String escapeCsv(final String input) { [EOL]     return ESCAPE_CSV.translate(input); [EOL] }
public static final String unescapeCsv(final String input) { [EOL]     return UNESCAPE_CSV.translate(input); [EOL] }
public static final String escapeJson(final String input) { [EOL]     return ESCAPE_JSON.translate(input); [EOL] }
public static final String unescapeJson(final String input) { [EOL]     return UNESCAPE_JSON.translate(input); [EOL] }
methods/lang3/SerializationException.java
methods/lang3/SystemUtils.java
static boolean isOSMatch(final String osName, final String osVersion, final String osNamePrefix, final String osVersionPrefix) { [EOL]     if (osName == null || osVersion == null) { [EOL]         return false; [EOL]     } [EOL]     return osName.startsWith(osNamePrefix) && osVersion.startsWith(osVersionPrefix); [EOL] }
static boolean isJavaVersionMatch(final String version, final String versionPrefix) { [EOL]     if (version == null) { [EOL]         return false; [EOL]     } [EOL]     return version.startsWith(versionPrefix); [EOL] }
public static File getUserHome() { [EOL]     return new File(System.getProperty(USER_HOME_KEY)); [EOL] }
public static File getUserDir() { [EOL]     return new File(System.getProperty(USER_DIR_KEY)); [EOL] }
public static File getJavaIoTmpDir() { [EOL]     return new File(System.getProperty(JAVA_IO_TMPDIR_KEY)); [EOL] }
public static File getJavaHome() { [EOL]     return new File(System.getProperty(JAVA_HOME_KEY)); [EOL] }
public static File getJavaHome() { [EOL]     return new File(System.getProperty(JAVA_HOME_KEY)); [EOL] }
static boolean isOSNameMatch(final String osName, final String osNamePrefix) { [EOL]     if (osName == null) { [EOL]         return false; [EOL]     } [EOL]     return osName.startsWith(osNamePrefix); [EOL] }
static boolean isOSNameMatch(final String osName, final String osNamePrefix) { [EOL]     if (osName == null) { [EOL]         return false; [EOL]     } [EOL]     return osName.startsWith(osNamePrefix); [EOL] }
static boolean isOSMatch(final String osName, final String osVersion, final String osNamePrefix, final String osVersionPrefix) { [EOL]     if (osName == null || osVersion == null) { [EOL]         return false; [EOL]     } [EOL]     return osName.startsWith(osNamePrefix) && osVersion.startsWith(osVersionPrefix); [EOL] }
static boolean isOSMatch(final String osName, final String osVersion, final String osNamePrefix, final String osVersionPrefix) { [EOL]     if (osName == null || osVersion == null) { [EOL]         return false; [EOL]     } [EOL]     return osName.startsWith(osNamePrefix) && osVersion.startsWith(osVersionPrefix); [EOL] }
static boolean isOSMatch(final String osName, final String osVersion, final String osNamePrefix, final String osVersionPrefix) { [EOL]     if (osName == null || osVersion == null) { [EOL]         return false; [EOL]     } [EOL]     return osName.startsWith(osNamePrefix) && osVersion.startsWith(osVersionPrefix); [EOL] }
static boolean isOSMatch(final String osName, final String osVersion, final String osNamePrefix, final String osVersionPrefix) { [EOL]     if (osName == null || osVersion == null) { [EOL]         return false; [EOL]     } [EOL]     return osName.startsWith(osNamePrefix) && osVersion.startsWith(osVersionPrefix); [EOL] }
static boolean isOSMatch(final String osName, final String osVersion, final String osNamePrefix, final String osVersionPrefix) { [EOL]     if (osName == null || osVersion == null) { [EOL]         return false; [EOL]     } [EOL]     return osName.startsWith(osNamePrefix) && osVersion.startsWith(osVersionPrefix); [EOL] }
static boolean isJavaVersionMatch(final String version, final String versionPrefix) { [EOL]     if (version == null) { [EOL]         return false; [EOL]     } [EOL]     return version.startsWith(versionPrefix); [EOL] }
public static boolean isJavaAwtHeadless() { [EOL]     return JAVA_AWT_HEADLESS != null ? JAVA_AWT_HEADLESS.equals(Boolean.TRUE.toString()) : false; [EOL] }
public static File getJavaIoTmpDir() { [EOL]     return new File(System.getProperty(JAVA_IO_TMPDIR_KEY)); [EOL] }
public static File getUserHome() { [EOL]     return new File(System.getProperty(USER_HOME_KEY)); [EOL] }
public static File getUserDir() { [EOL]     return new File(System.getProperty(USER_DIR_KEY)); [EOL] }
public static File getJavaHome() { [EOL]     return new File(System.getProperty(JAVA_HOME_KEY)); [EOL] }
public static boolean isJavaVersionAtLeast(final JavaVersion requiredVersion) { [EOL]     return JAVA_SPECIFICATION_VERSION_AS_ENUM.atLeast(requiredVersion); [EOL] }
methods/lang3/BooleanUtils.java
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static Integer toIntegerObject(final Boolean bool, final Integer trueValue, final Integer falseValue, final Integer nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static Integer toIntegerObject(final Boolean bool, final Integer trueValue, final Integer falseValue, final Integer nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static String toStringYesNo(final boolean bool) { [EOL]     return toString(bool, "yes", "no"); [EOL] }
public static String toString(final boolean bool, final String trueString, final String falseString) { [EOL]     return bool ? trueString : falseString; [EOL] }
public static String toStringTrueFalse(final boolean bool) { [EOL]     return toString(bool, "true", "false"); [EOL] }
public static String toString(final boolean bool, final String trueString, final String falseString) { [EOL]     return bool ? trueString : falseString; [EOL] }
public static String toString(final boolean bool, final String trueString, final String falseString) { [EOL]     return bool ? trueString : falseString; [EOL] }
public static String toString(final boolean bool, final String trueString, final String falseString) { [EOL]     return bool ? trueString : falseString; [EOL] }
public static String toString(final boolean bool, final String trueString, final String falseString) { [EOL]     return bool ? trueString : falseString; [EOL] }
public static String toString(final boolean bool, final String trueString, final String falseString) { [EOL]     return bool ? trueString : falseString; [EOL] }
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static Integer toIntegerObject(final Boolean bool, final Integer trueValue, final Integer falseValue, final Integer nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static Integer toIntegerObject(final Boolean bool, final Integer trueValue, final Integer falseValue, final Integer nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static Integer toIntegerObject(final Boolean bool, final Integer trueValue, final Integer falseValue, final Integer nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static boolean toBooleanDefaultIfNull(final Boolean bool, final boolean valueIfNull) { [EOL]     if (bool == null) { [EOL]         return valueIfNull; [EOL]     } [EOL]     return bool.booleanValue(); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static boolean isTrue(final Boolean bool) { [EOL]     return Boolean.TRUE.equals(bool); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static Boolean or(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return or(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean xor(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return xor(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean or(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return or(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean and(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return and(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean and(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return and(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static String toString(final boolean bool, final String trueString, final String falseString) { [EOL]     return bool ? trueString : falseString; [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static String toString(final boolean bool, final String trueString, final String falseString) { [EOL]     return bool ? trueString : falseString; [EOL] }
public static String toString(final boolean bool, final String trueString, final String falseString) { [EOL]     return bool ? trueString : falseString; [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static boolean isFalse(final Boolean bool) { [EOL]     return Boolean.FALSE.equals(bool); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static Boolean or(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return or(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean xor(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return xor(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean or(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return or(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean xor(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return xor(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean or(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return or(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean xor(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return xor(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static Boolean or(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return or(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean xor(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return xor(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean or(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return or(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static Boolean or(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return or(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static Boolean and(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return and(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static Boolean and(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return and(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static String toStringOnOff(final boolean bool) { [EOL]     return toString(bool, "on", "off"); [EOL] }
public static String toString(final boolean bool, final String trueString, final String falseString) { [EOL]     return bool ? trueString : falseString; [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static Integer toIntegerObject(final Boolean bool, final Integer trueValue, final Integer falseValue, final Integer nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static Integer toIntegerObject(final Boolean bool, final Integer trueValue, final Integer falseValue, final Integer nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static Integer toIntegerObject(final Boolean bool, final Integer trueValue, final Integer falseValue, final Integer nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static Integer toIntegerObject(final Boolean bool, final Integer trueValue, final Integer falseValue, final Integer nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static boolean isFalse(final Boolean bool) { [EOL]     return Boolean.FALSE.equals(bool); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static Integer toIntegerObject(final Boolean bool, final Integer trueValue, final Integer falseValue, final Integer nullValue) { [EOL]     if (bool == null) { [EOL]         return nullValue; [EOL]     } [EOL]     return bool.booleanValue() ? trueValue : falseValue; [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static Boolean or(final Boolean... array) { [EOL]     if (array == null) { [EOL]         throw new IllegalArgumentException("The Array must not be null"); [EOL]     } [EOL]     if (array.length == 0) { [EOL]         throw new IllegalArgumentException("Array is empty"); [EOL]     } [EOL]     try { [EOL]         final boolean[] primitive = ArrayUtils.toPrimitive(array); [EOL]         return or(primitive) ? Boolean.TRUE : Boolean.FALSE; [EOL]     } catch (final NullPointerException ex) { [EOL]         throw new IllegalArgumentException("The array must not contain any null elements"); [EOL]     } [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static boolean toBooleanDefaultIfNull(final Boolean bool, final boolean valueIfNull) { [EOL]     if (bool == null) { [EOL]         return valueIfNull; [EOL]     } [EOL]     return bool.booleanValue(); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static boolean isNotFalse(final Boolean bool) { [EOL]     return !isFalse(bool); [EOL] }
public static boolean isNotTrue(final Boolean bool) { [EOL]     return !isTrue(bool); [EOL] }
public static boolean isNotTrue(final Boolean bool) { [EOL]     return !isTrue(bool); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static Boolean negate(final Boolean bool) { [EOL]     if (bool == null) { [EOL]         return null; [EOL]     } [EOL]     return bool.booleanValue() ? Boolean.FALSE : Boolean.TRUE; [EOL] }
public static Boolean negate(final Boolean bool) { [EOL]     if (bool == null) { [EOL]         return null; [EOL]     } [EOL]     return bool.booleanValue() ? Boolean.FALSE : Boolean.TRUE; [EOL] }
public static boolean isNotFalse(final Boolean bool) { [EOL]     return !isFalse(bool); [EOL] }
public static boolean isTrue(final Boolean bool) { [EOL]     return Boolean.TRUE.equals(bool); [EOL] }
public static boolean toBoolean(final String str, final String trueString, final String falseString) { [EOL]     if (str == trueString) { [EOL]         return true; [EOL]     } else if (str == falseString) { [EOL]         return false; [EOL]     } else if (str != null) { [EOL]         if (str.equals(trueString)) { [EOL]             return true; [EOL]         } else if (str.equals(falseString)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match either specified value"); [EOL] }
public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) { [EOL]     if (str == null) { [EOL]         if (trueString == null) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (falseString == null) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (nullString == null) { [EOL]             return null; [EOL]         } [EOL]     } else if (str.equals(trueString)) { [EOL]         return Boolean.TRUE; [EOL]     } else if (str.equals(falseString)) { [EOL]         return Boolean.FALSE; [EOL]     } else if (str.equals(nullString)) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("The String did not match any specified value"); [EOL] }
public static String toStringYesNo(final boolean bool) { [EOL]     return toString(bool, "yes", "no"); [EOL] }
public static String toString(final boolean bool, final String trueString, final String falseString) { [EOL]     return bool ? trueString : falseString; [EOL] }
public static String toStringTrueFalse(final boolean bool) { [EOL]     return toString(bool, "true", "false"); [EOL] }
public static String toString(final boolean bool, final String trueString, final String falseString) { [EOL]     return bool ? trueString : falseString; [EOL] }
public static String toStringOnOff(final boolean bool) { [EOL]     return toString(bool, "on", "off"); [EOL] }
public static String toString(final boolean bool, final String trueString, final String falseString) { [EOL]     return bool ? trueString : falseString; [EOL] }
methods/lang3/Conversion.java
public static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = (int) (0xF & (src >> shift)); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] }
public static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = (int) (0xF & (src >> shift)); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] }
public static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) { [EOL]     if (0 == nBytes) { [EOL]         return dst; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + srcPos; [EOL]         dst[dstPos + i] = (byte) (0xff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] }
public static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts) { [EOL]     if (0 == nInts) { [EOL]         return dst; [EOL]     } [EOL]     if ((nInts - 1) * 32 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("(nInts-1)*32+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nInts; i++) { [EOL]         shift = i * 32 + srcPos; [EOL]         dst[dstPos + i] = (int) (0xffffffff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] }
public static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final int bits = (src[i + srcPos] ? 1 : 0) << shift; [EOL]         final int mask = 0x1 << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final long bits = (src[i + srcPos] ? 1L : 0) << shift; [EOL]         final long mask = 0x1L << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) { [EOL]     if (0 == nBytes) { [EOL]         return dst; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + srcPos; [EOL]         dst[dstPos + i] = (byte) (0xff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] }
public static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) { [EOL]     if (0 == nBytes) { [EOL]         return dst; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + srcPos >= 16) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 16"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + srcPos; [EOL]         dst[dstPos + i] = (byte) (0xff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] }
public static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nShorts) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nShorts - 1) * 16 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("(nShorts-1)*16+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nShorts; i++) { [EOL]         shift = i * 16 + dstPos; [EOL]         final long bits = (0xffffL & src[i + srcPos]) << shift; [EOL]         final long mask = 0xffffL << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nShorts) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nShorts - 1) * 16 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("(nShorts-1)*16+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nShorts; i++) { [EOL]         shift = i * 16 + dstPos; [EOL]         final long bits = (0xffffL & src[i + srcPos]) << shift; [EOL]         final long mask = 0xffffL << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nShorts) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nShorts - 1) * 16 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("(nShorts-1)*16+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nShorts; i++) { [EOL]         shift = i * 16 + dstPos; [EOL]         final int bits = (0xffff & src[i + srcPos]) << shift; [EOL]         final int mask = 0xffff << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts) { [EOL]     if (0 == nInts) { [EOL]         return dst; [EOL]     } [EOL]     if ((nInts - 1) * 32 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("(nInts-1)*32+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nInts; i++) { [EOL]         shift = i * 32 + srcPos; [EOL]         dst[dstPos + i] = (int) (0xffffffff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] }
public static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = (int) (0xF & (src >> shift)); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] }
public static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) { [EOL]     if (0 == nBytes) { [EOL]         return dst; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + srcPos; [EOL]         dst[dstPos + i] = (byte) (0xff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] }
public static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts) { [EOL]     if (0 == nShorts) { [EOL]         return dst; [EOL]     } [EOL]     if ((nShorts - 1) * 16 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("(nShorts-1)*16+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nShorts; i++) { [EOL]         shift = i * 16 + srcPos; [EOL]         dst[dstPos + i] = (short) (0xffff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] }
public static char intToHexDigit(final int nibble) { [EOL]     final char c = Character.forDigit(nibble, 16); [EOL]     if (c == Character.MIN_VALUE) { [EOL]         throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL]     return c; [EOL] }
public static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] }
public static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) { [EOL]     if (0 == nBytes) { [EOL]         return dst; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + srcPos; [EOL]         dst[dstPos + i] = (byte) (0xff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] }
public static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) { [EOL]     if (0 == nBools) { [EOL]         return dst; [EOL]     } [EOL]     if (nBools - 1 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + srcPos; [EOL]         dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [EOL]     } [EOL]     return dst; [EOL] }
public static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nInts) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nInts - 1) * 32 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("(nInts-1)*32+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nInts; i++) { [EOL]         shift = i * 32 + dstPos; [EOL]         final long bits = ((0xffffffffL & src[i + srcPos]) << shift); [EOL]         final long mask = 0xffffffffL << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex) { [EOL]     if (0 == nHex) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHex - 1) * 4 + dstPos >= 16) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 16"); [EOL]     } [EOL]     short out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nHex; i++) { [EOL]         shift = i * 4 + dstPos; [EOL]         final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift; [EOL]         final int mask = 0xf << shift; [EOL]         out = (short) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] }
public static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex) { [EOL]     if (0 == nHex) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHex - 1) * 4 + dstPos >= 16) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 16"); [EOL]     } [EOL]     short out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nHex; i++) { [EOL]         shift = i * 4 + dstPos; [EOL]         final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift; [EOL]         final int mask = 0xf << shift; [EOL]         out = (short) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] }
public static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex) { [EOL]     if (0 == nHex) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHex - 1) * 4 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nHex; i++) { [EOL]         shift = i * 4 + dstPos; [EOL]         final long bits = (0xfL & hexDigitToInt(src.charAt(i + srcPos))) << shift; [EOL]         final long mask = 0xfL << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex) { [EOL]     if (0 == nHex) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHex - 1) * 4 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nHex; i++) { [EOL]         shift = i * 4 + dstPos; [EOL]         final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift; [EOL]         final int mask = 0xf << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex) { [EOL]     if (0 == nHex) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHex - 1) * 4 + dstPos >= 8) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 8"); [EOL]     } [EOL]     byte out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nHex; i++) { [EOL]         shift = i * 4 + dstPos; [EOL]         final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift; [EOL]         final int mask = 0xf << shift; [EOL]         out = (byte) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] }
public static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBytes) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + dstPos; [EOL]         final long bits = (0xffL & src[i + srcPos]) << shift; [EOL]         final long mask = 0xffL << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBytes) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + dstPos; [EOL]         final int bits = (0xff & src[i + srcPos]) << shift; [EOL]         final int mask = 0xff << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBytes) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + dstPos; [EOL]         final int bits = (0xff & src[i + srcPos]) << shift; [EOL]         final int mask = 0xff << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final long bits = (src[i + srcPos] ? 1L : 0) << shift; [EOL]         final long mask = 0x1L << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final int bits = (src[i + srcPos] ? 1 : 0) << shift; [EOL]         final int mask = 0x1 << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) { [EOL]     if (src.length > 8) { [EOL]         throw new IllegalArgumentException("src.length>8: src.length=" + src.length); [EOL]     } [EOL]     if (src.length - srcPos < 4) { [EOL]         throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos); [EOL]     } [EOL]     if (src[srcPos + 3]) { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return '7'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return '3'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return '5'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '1'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'e'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'a'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'c'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '8'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) { [EOL]     if (src.length > 8) { [EOL]         throw new IllegalArgumentException("src.length>8: src.length=" + src.length); [EOL]     } [EOL]     if (src.length - srcPos < 4) { [EOL]         throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos); [EOL]     } [EOL]     if (src[srcPos + 3]) { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return '7'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return '3'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return '5'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '1'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'e'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'a'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'c'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '8'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) { [EOL]     if (src.length > 8) { [EOL]         throw new IllegalArgumentException("src.length>8: src.length=" + src.length); [EOL]     } [EOL]     if (src.length - srcPos < 4) { [EOL]         throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos); [EOL]     } [EOL]     if (src[srcPos + 3]) { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return '7'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return '3'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return '5'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '1'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'e'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'a'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'c'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '8'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes) { [EOL]     if (0 == nBytes) { [EOL]         return dst; [EOL]     } [EOL]     if (nBytes > 16) { [EOL]         throw new IllegalArgumentException("nBytes is greather than 16"); [EOL]     } [EOL]     longToByteArray(src.getMostSignificantBits(), 0, dst, dstPos, nBytes > 8 ? 8 : nBytes); [EOL]     if (nBytes >= 8) { [EOL]         longToByteArray(src.getLeastSignificantBits(), 0, dst, dstPos + 8, nBytes - 8); [EOL]     } [EOL]     return dst; [EOL] }
public static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) { [EOL]     if (0 == nBools) { [EOL]         return dst; [EOL]     } [EOL]     if (nBools - 1 + srcPos >= 8) { [EOL]         throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 8"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + srcPos; [EOL]         dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [EOL]     } [EOL]     return dst; [EOL] }
public static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) { [EOL]     if (0 == nBools) { [EOL]         return dst; [EOL]     } [EOL]     if (nBools - 1 + srcPos >= 8) { [EOL]         throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 8"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + srcPos; [EOL]         dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [EOL]     } [EOL]     return dst; [EOL] }
public static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) { [EOL]     if (0 == nBools) { [EOL]         return dst; [EOL]     } [EOL]     if (nBools - 1 + srcPos >= 16) { [EOL]         throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 16"); [EOL]     } [EOL]     int shift = 0; [EOL]     assert ((nBools - 1) * 1 < 16 - srcPos); [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + srcPos; [EOL]         dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [EOL]     } [EOL]     return dst; [EOL] }
public static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) { [EOL]     if (0 == nBools) { [EOL]         return dst; [EOL]     } [EOL]     if (nBools - 1 + srcPos >= 16) { [EOL]         throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 16"); [EOL]     } [EOL]     int shift = 0; [EOL]     assert ((nBools - 1) * 1 < 16 - srcPos); [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + srcPos; [EOL]         dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [EOL]     } [EOL]     return dst; [EOL] }
public static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) { [EOL]     if (0 == nBools) { [EOL]         return dst; [EOL]     } [EOL]     if (nBools - 1 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + srcPos; [EOL]         dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [EOL]     } [EOL]     return dst; [EOL] }
public static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) { [EOL]     if (0 == nBools) { [EOL]         return dst; [EOL]     } [EOL]     if (nBools - 1 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + srcPos; [EOL]         dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [EOL]     } [EOL]     return dst; [EOL] }
public static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) { [EOL]     if (0 == nBools) { [EOL]         return dst; [EOL]     } [EOL]     if (nBools - 1 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + srcPos; [EOL]         dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [EOL]     } [EOL]     return dst; [EOL] }
public static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) { [EOL]     if (0 == nBools) { [EOL]         return dst; [EOL]     } [EOL]     if (nBools - 1 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + srcPos; [EOL]         dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [EOL]     } [EOL]     return dst; [EOL] }
public static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 8) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 8"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] }
public static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 8) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 8"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] }
public static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 8) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 8"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] }
public static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 16) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 16"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] }
public static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 16) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 16"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] }
public static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 16) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 16"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] }
public static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 16) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 16"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] }
public static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] }
public static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] }
public static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) { [EOL]     if (0 == nBytes) { [EOL]         return dst; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + srcPos >= 16) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 16"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + srcPos; [EOL]         dst[dstPos + i] = (byte) (0xff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] }
public static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) { [EOL]     if (0 == nBytes) { [EOL]         return dst; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + srcPos >= 16) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 16"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + srcPos; [EOL]         dst[dstPos + i] = (byte) (0xff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] }
public static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) { [EOL]     if (0 == nBytes) { [EOL]         return dst; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + srcPos; [EOL]         dst[dstPos + i] = (byte) (0xff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] }
public static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) { [EOL]     if (0 == nBytes) { [EOL]         return dst; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + srcPos; [EOL]         dst[dstPos + i] = (byte) (0xff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] }
public static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes) { [EOL]     if (0 == nBytes) { [EOL]         return dst; [EOL]     } [EOL]     if (nBytes > 16) { [EOL]         throw new IllegalArgumentException("nBytes is greather than 16"); [EOL]     } [EOL]     longToByteArray(src.getMostSignificantBits(), 0, dst, dstPos, nBytes > 8 ? 8 : nBytes); [EOL]     if (nBytes >= 8) { [EOL]         longToByteArray(src.getLeastSignificantBits(), 0, dst, dstPos + 8, nBytes - 8); [EOL]     } [EOL]     return dst; [EOL] }
public static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts) { [EOL]     if (0 == nShorts) { [EOL]         return dst; [EOL]     } [EOL]     if ((nShorts - 1) * 16 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("(nShorts-1)*16+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nShorts; i++) { [EOL]         shift = i * 16 + srcPos; [EOL]         dst[dstPos + i] = (short) (0xffff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] }
public static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts) { [EOL]     if (0 == nShorts) { [EOL]         return dst; [EOL]     } [EOL]     if ((nShorts - 1) * 16 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("(nShorts-1)*16+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nShorts; i++) { [EOL]         shift = i * 16 + srcPos; [EOL]         dst[dstPos + i] = (short) (0xffff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] }
public static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts) { [EOL]     if (0 == nShorts) { [EOL]         return dst; [EOL]     } [EOL]     if ((nShorts - 1) * 16 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("(nShorts-1)*16+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nShorts; i++) { [EOL]         shift = i * 16 + srcPos; [EOL]         dst[dstPos + i] = (short) (0xffff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] }
public static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts) { [EOL]     if (0 == nInts) { [EOL]         return dst; [EOL]     } [EOL]     if ((nInts - 1) * 32 + srcPos >= 64) { [EOL]         throw new IllegalArgumentException("(nInts-1)*32+srcPos is greather or equal to than 64"); [EOL]     } [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nInts; i++) { [EOL]         shift = i * 32 + srcPos; [EOL]         dst[dstPos + i] = (int) (0xffffffff & (src >> shift)); [EOL]     } [EOL]     return dst; [EOL] }
public static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 8) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 8"); [EOL]     } [EOL]     byte out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final int bits = (src[i + srcPos] ? 1 : 0) << shift; [EOL]         final int mask = 0x1 << shift; [EOL]         out = (byte) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] }
public static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 8) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 8"); [EOL]     } [EOL]     byte out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final int bits = (src[i + srcPos] ? 1 : 0) << shift; [EOL]         final int mask = 0x1 << shift; [EOL]         out = (byte) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] }
public static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 8) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 8"); [EOL]     } [EOL]     byte out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final int bits = (src[i + srcPos] ? 1 : 0) << shift; [EOL]         final int mask = 0x1 << shift; [EOL]         out = (byte) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] }
public static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 8) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 8"); [EOL]     } [EOL]     byte out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final int bits = (src[i + srcPos] ? 1 : 0) << shift; [EOL]         final int mask = 0x1 << shift; [EOL]         out = (byte) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] }
public static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 8) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 8"); [EOL]     } [EOL]     byte out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final int bits = (src[i + srcPos] ? 1 : 0) << shift; [EOL]         final int mask = 0x1 << shift; [EOL]         out = (byte) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] }
public static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 16) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 16"); [EOL]     } [EOL]     short out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final int bits = (src[i + srcPos] ? 1 : 0) << shift; [EOL]         final int mask = 0x1 << shift; [EOL]         out = (short) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] }
public static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 16) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 16"); [EOL]     } [EOL]     short out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final int bits = (src[i + srcPos] ? 1 : 0) << shift; [EOL]         final int mask = 0x1 << shift; [EOL]         out = (short) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] }
public static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 16) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 16"); [EOL]     } [EOL]     short out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final int bits = (src[i + srcPos] ? 1 : 0) << shift; [EOL]         final int mask = 0x1 << shift; [EOL]         out = (short) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] }
public static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools) { [EOL]     if (0 == nBools) { [EOL]         return dst; [EOL]     } [EOL]     if (nBools - 1 + srcPos >= 16) { [EOL]         throw new IllegalArgumentException("nBools-1+srcPos is greather or equal to than 16"); [EOL]     } [EOL]     int shift = 0; [EOL]     assert ((nBools - 1) * 1 < 16 - srcPos); [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + srcPos; [EOL]         dst[dstPos + i] = ((0x1 & (src >> shift)) != 0); [EOL]     } [EOL]     return dst; [EOL] }
public static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 16) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 16"); [EOL]     } [EOL]     short out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final int bits = (src[i + srcPos] ? 1 : 0) << shift; [EOL]         final int mask = 0x1 << shift; [EOL]         out = (short) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] }
public static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final int bits = (src[i + srcPos] ? 1 : 0) << shift; [EOL]         final int mask = 0x1 << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final int bits = (src[i + srcPos] ? 1 : 0) << shift; [EOL]         final int mask = 0x1 << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final long bits = (src[i + srcPos] ? 1L : 0) << shift; [EOL]         final long mask = 0x1L << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex) { [EOL]     if (0 == nHex) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHex - 1) * 4 + dstPos >= 8) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 8"); [EOL]     } [EOL]     byte out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nHex; i++) { [EOL]         shift = i * 4 + dstPos; [EOL]         final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift; [EOL]         final int mask = 0xf << shift; [EOL]         out = (byte) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] }
public static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex) { [EOL]     if (0 == nHex) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHex - 1) * 4 + dstPos >= 8) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 8"); [EOL]     } [EOL]     byte out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nHex; i++) { [EOL]         shift = i * 4 + dstPos; [EOL]         final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift; [EOL]         final int mask = 0xf << shift; [EOL]         out = (byte) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] }
public static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex) { [EOL]     if (0 == nHex) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHex - 1) * 4 + dstPos >= 16) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 16"); [EOL]     } [EOL]     short out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nHex; i++) { [EOL]         shift = i * 4 + dstPos; [EOL]         final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift; [EOL]         final int mask = 0xf << shift; [EOL]         out = (short) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] }
public static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex) { [EOL]     if (0 == nHex) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHex - 1) * 4 + dstPos >= 16) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 16"); [EOL]     } [EOL]     short out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nHex; i++) { [EOL]         shift = i * 4 + dstPos; [EOL]         final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift; [EOL]         final int mask = 0xf << shift; [EOL]         out = (short) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] }
public static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex) { [EOL]     if (0 == nHex) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHex - 1) * 4 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nHex; i++) { [EOL]         shift = i * 4 + dstPos; [EOL]         final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift; [EOL]         final int mask = 0xf << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex) { [EOL]     if (0 == nHex) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHex - 1) * 4 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nHex; i++) { [EOL]         shift = i * 4 + dstPos; [EOL]         final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift; [EOL]         final int mask = 0xf << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex) { [EOL]     if (0 == nHex) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHex - 1) * 4 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nHex; i++) { [EOL]         shift = i * 4 + dstPos; [EOL]         final long bits = (0xfL & hexDigitToInt(src.charAt(i + srcPos))) << shift; [EOL]         final long mask = 0xfL << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex) { [EOL]     if (0 == nHex) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHex - 1) * 4 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nHex; i++) { [EOL]         shift = i * 4 + dstPos; [EOL]         final long bits = (0xfL & hexDigitToInt(src.charAt(i + srcPos))) << shift; [EOL]         final long mask = 0xfL << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBytes) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + dstPos >= 16) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 16"); [EOL]     } [EOL]     short out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + dstPos; [EOL]         final int bits = (0xff & src[i + srcPos]) << shift; [EOL]         final int mask = 0xff << shift; [EOL]         out = (short) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] }
public static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBytes) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + dstPos >= 16) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 16"); [EOL]     } [EOL]     short out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + dstPos; [EOL]         final int bits = (0xff & src[i + srcPos]) << shift; [EOL]         final int mask = 0xff << shift; [EOL]         out = (short) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] }
public static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBytes) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + dstPos >= 16) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 16"); [EOL]     } [EOL]     short out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + dstPos; [EOL]         final int bits = (0xff & src[i + srcPos]) << shift; [EOL]         final int mask = 0xff << shift; [EOL]         out = (short) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] }
public static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBytes) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + dstPos >= 16) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 16"); [EOL]     } [EOL]     short out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + dstPos; [EOL]         final int bits = (0xff & src[i + srcPos]) << shift; [EOL]         final int mask = 0xff << shift; [EOL]         out = (short) ((out & ~mask) | bits); [EOL]     } [EOL]     return out; [EOL] }
public static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBytes) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + dstPos; [EOL]         final int bits = (0xff & src[i + srcPos]) << shift; [EOL]         final int mask = 0xff << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBytes) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + dstPos; [EOL]         final int bits = (0xff & src[i + srcPos]) << shift; [EOL]         final int mask = 0xff << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBytes) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + dstPos; [EOL]         final int bits = (0xff & src[i + srcPos]) << shift; [EOL]         final int mask = 0xff << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBytes) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + dstPos; [EOL]         final long bits = (0xffL & src[i + srcPos]) << shift; [EOL]         final long mask = 0xffL << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBytes) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nBytes - 1) * 8 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("(nBytes-1)*8+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBytes; i++) { [EOL]         shift = i * 8 + dstPos; [EOL]         final long bits = (0xffL & src[i + srcPos]) << shift; [EOL]         final long mask = 0xffL << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nShorts) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nShorts - 1) * 16 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("(nShorts-1)*16+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nShorts; i++) { [EOL]         shift = i * 16 + dstPos; [EOL]         final int bits = (0xffff & src[i + srcPos]) << shift; [EOL]         final int mask = 0xffff << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nShorts) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nShorts - 1) * 16 + dstPos >= 32) { [EOL]         throw new IllegalArgumentException("(nShorts-1)*16+dstPos is greather or equal to than 32"); [EOL]     } [EOL]     int out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nShorts; i++) { [EOL]         shift = i * 16 + dstPos; [EOL]         final int bits = (0xffff & src[i + srcPos]) << shift; [EOL]         final int mask = 0xffff << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nShorts) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nShorts - 1) * 16 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("(nShorts-1)*16+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nShorts; i++) { [EOL]         shift = i * 16 + dstPos; [EOL]         final long bits = (0xffffL & src[i + srcPos]) << shift; [EOL]         final long mask = 0xffffL << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nInts) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nInts - 1) * 32 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("(nInts-1)*32+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nInts; i++) { [EOL]         shift = i * 32 + dstPos; [EOL]         final long bits = ((0xffffffffL & src[i + srcPos]) << shift); [EOL]         final long mask = 0xffffffffL << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nInts) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nInts - 1) * 32 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("(nInts-1)*32+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nInts; i++) { [EOL]         shift = i * 32 + dstPos; [EOL]         final long bits = ((0xffffffffL & src[i + srcPos]) << shift); [EOL]         final long mask = 0xffffffffL << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static char intToHexDigit(final int nibble) { [EOL]     final char c = Character.forDigit(nibble, 16); [EOL]     if (c == Character.MIN_VALUE) { [EOL]         throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL]     return c; [EOL] }
public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] }
public static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] }
public static char intToHexDigit(final int nibble) { [EOL]     final char c = Character.forDigit(nibble, 16); [EOL]     if (c == Character.MIN_VALUE) { [EOL]         throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL]     return c; [EOL] }
public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] }
public static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] }
public static char intToHexDigit(final int nibble) { [EOL]     final char c = Character.forDigit(nibble, 16); [EOL]     if (c == Character.MIN_VALUE) { [EOL]         throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL]     return c; [EOL] }
public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] }
public static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] }
public static char intToHexDigit(final int nibble) { [EOL]     final char c = Character.forDigit(nibble, 16); [EOL]     if (c == Character.MIN_VALUE) { [EOL]         throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL]     return c; [EOL] }
public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] }
public static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] }
public static char intToHexDigit(final int nibble) { [EOL]     final char c = Character.forDigit(nibble, 16); [EOL]     if (c == Character.MIN_VALUE) { [EOL]         throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL]     return c; [EOL] }
public static char intToHexDigitMsb0(final int nibble) { [EOL]     switch(nibble) { [EOL]         case 0x0: [EOL]             return '0'; [EOL]         case 0x1: [EOL]             return '8'; [EOL]         case 0x2: [EOL]             return '4'; [EOL]         case 0x3: [EOL]             return 'c'; [EOL]         case 0x4: [EOL]             return '2'; [EOL]         case 0x5: [EOL]             return 'a'; [EOL]         case 0x6: [EOL]             return '6'; [EOL]         case 0x7: [EOL]             return 'e'; [EOL]         case 0x8: [EOL]             return '1'; [EOL]         case 0x9: [EOL]             return '9'; [EOL]         case 0xA: [EOL]             return '5'; [EOL]         case 0xB: [EOL]             return 'd'; [EOL]         case 0xC: [EOL]             return '3'; [EOL]         case 0xD: [EOL]             return 'b'; [EOL]         case 0xE: [EOL]             return '7'; [EOL]         case 0xF: [EOL]             return 'f'; [EOL]         default: [EOL]             throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL] }
public static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] }
public static char intToHexDigit(final int nibble) { [EOL]     final char c = Character.forDigit(nibble, 16); [EOL]     if (c == Character.MIN_VALUE) { [EOL]         throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble); [EOL]     } [EOL]     return c; [EOL] }
public static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) { [EOL]     if (0 == nHexs) { [EOL]         return dstInit; [EOL]     } [EOL]     if ((nHexs - 1) * 4 + srcPos >= 32) { [EOL]         throw new IllegalArgumentException("(nHexs-1)*4+srcPos is greather or equal to than 32"); [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(dstInit); [EOL]     int shift = 0; [EOL]     int append = sb.length(); [EOL]     for (int i = 0; i < nHexs; i++) { [EOL]         shift = i * 4 + srcPos; [EOL]         final int bits = 0xF & (src >> shift); [EOL]         if (dstPos + i == append) { [EOL]             ++append; [EOL]             sb.append(intToHexDigit(bits)); [EOL]         } else { [EOL]             sb.setCharAt(dstPos + i, intToHexDigit(bits)); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] }
public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     final int beSrcPos = src.length - 1 - srcPos; [EOL]     final int srcLen = Math.min(4, beSrcPos + 1); [EOL]     final boolean[] paddedSrc = new boolean[4]; [EOL]     System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen); [EOL]     src = paddedSrc; [EOL]     srcPos = 0; [EOL]     if (src[srcPos]) { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     final int beSrcPos = src.length - 1 - srcPos; [EOL]     final int srcLen = Math.min(4, beSrcPos + 1); [EOL]     final boolean[] paddedSrc = new boolean[4]; [EOL]     System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen); [EOL]     src = paddedSrc; [EOL]     srcPos = 0; [EOL]     if (src[srcPos]) { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     final int beSrcPos = src.length - 1 - srcPos; [EOL]     final int srcLen = Math.min(4, beSrcPos + 1); [EOL]     final boolean[] paddedSrc = new boolean[4]; [EOL]     System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen); [EOL]     src = paddedSrc; [EOL]     srcPos = 0; [EOL]     if (src[srcPos]) { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     final int beSrcPos = src.length - 1 - srcPos; [EOL]     final int srcLen = Math.min(4, beSrcPos + 1); [EOL]     final boolean[] paddedSrc = new boolean[4]; [EOL]     System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen); [EOL]     src = paddedSrc; [EOL]     srcPos = 0; [EOL]     if (src[srcPos]) { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     final int beSrcPos = src.length - 1 - srcPos; [EOL]     final int srcLen = Math.min(4, beSrcPos + 1); [EOL]     final boolean[] paddedSrc = new boolean[4]; [EOL]     System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen); [EOL]     src = paddedSrc; [EOL]     srcPos = 0; [EOL]     if (src[srcPos]) { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     final int beSrcPos = src.length - 1 - srcPos; [EOL]     final int srcLen = Math.min(4, beSrcPos + 1); [EOL]     final boolean[] paddedSrc = new boolean[4]; [EOL]     System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen); [EOL]     src = paddedSrc; [EOL]     srcPos = 0; [EOL]     if (src[srcPos]) { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     final int beSrcPos = src.length - 1 - srcPos; [EOL]     final int srcLen = Math.min(4, beSrcPos + 1); [EOL]     final boolean[] paddedSrc = new boolean[4]; [EOL]     System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen); [EOL]     src = paddedSrc; [EOL]     srcPos = 0; [EOL]     if (src[srcPos]) { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     final int beSrcPos = src.length - 1 - srcPos; [EOL]     final int srcLen = Math.min(4, beSrcPos + 1); [EOL]     final boolean[] paddedSrc = new boolean[4]; [EOL]     System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen); [EOL]     src = paddedSrc; [EOL]     srcPos = 0; [EOL]     if (src[srcPos]) { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     final int beSrcPos = src.length - 1 - srcPos; [EOL]     final int srcLen = Math.min(4, beSrcPos + 1); [EOL]     final boolean[] paddedSrc = new boolean[4]; [EOL]     System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen); [EOL]     src = paddedSrc; [EOL]     srcPos = 0; [EOL]     if (src[srcPos]) { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     final int beSrcPos = src.length - 1 - srcPos; [EOL]     final int srcLen = Math.min(4, beSrcPos + 1); [EOL]     final boolean[] paddedSrc = new boolean[4]; [EOL]     System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen); [EOL]     src = paddedSrc; [EOL]     srcPos = 0; [EOL]     if (src[srcPos]) { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     final int beSrcPos = src.length - 1 - srcPos; [EOL]     final int srcLen = Math.min(4, beSrcPos + 1); [EOL]     final boolean[] paddedSrc = new boolean[4]; [EOL]     System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen); [EOL]     src = paddedSrc; [EOL]     srcPos = 0; [EOL]     if (src[srcPos]) { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) { [EOL]     if (src.length > 8) { [EOL]         throw new IllegalArgumentException("src.length>8: src.length=" + src.length); [EOL]     } [EOL]     if (src.length - srcPos < 4) { [EOL]         throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos); [EOL]     } [EOL]     if (src[srcPos + 3]) { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return '7'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return '3'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return '5'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '1'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'e'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'a'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'c'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '8'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) { [EOL]     if (src.length > 8) { [EOL]         throw new IllegalArgumentException("src.length>8: src.length=" + src.length); [EOL]     } [EOL]     if (src.length - srcPos < 4) { [EOL]         throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos); [EOL]     } [EOL]     if (src[srcPos + 3]) { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return '7'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return '3'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return '5'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '1'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'e'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'a'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'c'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '8'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) { [EOL]     if (src.length > 8) { [EOL]         throw new IllegalArgumentException("src.length>8: src.length=" + src.length); [EOL]     } [EOL]     if (src.length - srcPos < 4) { [EOL]         throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos); [EOL]     } [EOL]     if (src[srcPos + 3]) { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return '7'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return '3'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return '5'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '1'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'e'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'a'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'c'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '8'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) { [EOL]     if (src.length > 8) { [EOL]         throw new IllegalArgumentException("src.length>8: src.length=" + src.length); [EOL]     } [EOL]     if (src.length - srcPos < 4) { [EOL]         throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos); [EOL]     } [EOL]     if (src[srcPos + 3]) { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return '7'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return '3'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return '5'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '1'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'e'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'a'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'c'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '8'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) { [EOL]     if (src.length > 8) { [EOL]         throw new IllegalArgumentException("src.length>8: src.length=" + src.length); [EOL]     } [EOL]     if (src.length - srcPos < 4) { [EOL]         throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos); [EOL]     } [EOL]     if (src[srcPos + 3]) { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return '7'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return '3'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return '5'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '1'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'e'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'a'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'c'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '8'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) { [EOL]     if (src.length > 8) { [EOL]         throw new IllegalArgumentException("src.length>8: src.length=" + src.length); [EOL]     } [EOL]     if (src.length - srcPos < 4) { [EOL]         throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos); [EOL]     } [EOL]     if (src[srcPos + 3]) { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return '7'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return '3'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return '5'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '1'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'e'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'a'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'c'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '8'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     final int beSrcPos = src.length - 1 - srcPos; [EOL]     final int srcLen = Math.min(4, beSrcPos + 1); [EOL]     final boolean[] paddedSrc = new boolean[4]; [EOL]     System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen); [EOL]     src = paddedSrc; [EOL]     srcPos = 0; [EOL]     if (src[srcPos]) { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools) { [EOL]     if ((src.length == 0 && srcPos == 0) || 0 == nBools) { [EOL]         return dstInit; [EOL]     } [EOL]     if (nBools - 1 + dstPos >= 64) { [EOL]         throw new IllegalArgumentException("nBools-1+dstPos is greather or equal to than 64"); [EOL]     } [EOL]     long out = dstInit; [EOL]     int shift = 0; [EOL]     for (int i = 0; i < nBools; i++) { [EOL]         shift = i * 1 + dstPos; [EOL]         final long bits = (src[i + srcPos] ? 1L : 0) << shift; [EOL]         final long mask = 0x1L << shift; [EOL]         out = (out & ~mask) | bits; [EOL]     } [EOL]     return out; [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '2': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '3': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case '4': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '5': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case '8': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitMsb0ToInt(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return 0x0; [EOL]         case '1': [EOL]             return 0x8; [EOL]         case '2': [EOL]             return 0x4; [EOL]         case '3': [EOL]             return 0xC; [EOL]         case '4': [EOL]             return 0x2; [EOL]         case '5': [EOL]             return 0xA; [EOL]         case '6': [EOL]             return 0x6; [EOL]         case '7': [EOL]             return 0xE; [EOL]         case '8': [EOL]             return 0x1; [EOL]         case '9': [EOL]             return 0x9; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return 0x5; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return 0xD; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return 0x3; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return 0xB; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return 0x7; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return 0xF; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static int hexDigitToInt(final char hexDigit) { [EOL]     final int digit = Character.digit(hexDigit, 16); [EOL]     if (digit < 0) { [EOL]         throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL]     return digit; [EOL] }
public static boolean[] hexDigitToBinary(final char hexDigit) { [EOL]     switch(hexDigit) { [EOL]         case '0': [EOL]             return new boolean[] { false, false, false, false }; [EOL]         case '1': [EOL]             return new boolean[] { true, false, false, false }; [EOL]         case '2': [EOL]             return new boolean[] { false, true, false, false }; [EOL]         case '3': [EOL]             return new boolean[] { true, true, false, false }; [EOL]         case '4': [EOL]             return new boolean[] { false, false, true, false }; [EOL]         case '5': [EOL]             return new boolean[] { true, false, true, false }; [EOL]         case '6': [EOL]             return new boolean[] { false, true, true, false }; [EOL]         case '7': [EOL]             return new boolean[] { true, true, true, false }; [EOL]         case '8': [EOL]             return new boolean[] { false, false, false, true }; [EOL]         case '9': [EOL]             return new boolean[] { true, false, false, true }; [EOL]         case 'a': [EOL]         case 'A': [EOL]             return new boolean[] { false, true, false, true }; [EOL]         case 'b': [EOL]         case 'B': [EOL]             return new boolean[] { true, true, false, true }; [EOL]         case 'c': [EOL]         case 'C': [EOL]             return new boolean[] { false, false, true, true }; [EOL]         case 'd': [EOL]         case 'D': [EOL]             return new boolean[] { true, false, true, true }; [EOL]         case 'e': [EOL]         case 'E': [EOL]             return new boolean[] { false, true, true, true }; [EOL]         case 'f': [EOL]         case 'F': [EOL]             return new boolean[] { true, true, true, true }; [EOL]         default: [EOL]             throw new IllegalArgumentException("Cannot interpret '" + hexDigit + "' as a hexadecimal digit"); [EOL]     } [EOL] }
public static char binaryToHexDigit(final boolean[] src, final int srcPos) { [EOL]     if (src.length == 0) { [EOL]         throw new IllegalArgumentException("Cannot convert an empty array."); [EOL]     } [EOL]     if (src.length > srcPos + 3 && src[srcPos + 3]) { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return 'e'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return 'c'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return 'a'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '8'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src.length > srcPos + 2 && src[srcPos + 2]) { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '7'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '5'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src.length > srcPos + 1 && src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return '3'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '1'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) { [EOL]     if (src.length > 8) { [EOL]         throw new IllegalArgumentException("src.length>8: src.length=" + src.length); [EOL]     } [EOL]     if (src.length - srcPos < 4) { [EOL]         throw new IllegalArgumentException("src.length-srcPos<4: src.length=" + src.length + ", srcPos=" + srcPos); [EOL]     } [EOL]     if (src[srcPos + 3]) { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'f'; [EOL]                 } else { [EOL]                     return '7'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'b'; [EOL]                 } else { [EOL]                     return '3'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'd'; [EOL]                 } else { [EOL]                     return '5'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '9'; [EOL]                 } else { [EOL]                     return '1'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (src[srcPos + 2]) { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'e'; [EOL]                 } else { [EOL]                     return '6'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return 'a'; [EOL]                 } else { [EOL]                     return '2'; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (src[srcPos + 1]) { [EOL]                 if (src[srcPos]) { [EOL]                     return 'c'; [EOL]                 } else { [EOL]                     return '4'; [EOL]                 } [EOL]             } else { [EOL]                 if (src[srcPos]) { [EOL]                     return '8'; [EOL]                 } else { [EOL]                     return '0'; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
methods/lang3/CharSet.java
public static CharSet getInstance(final String... setStrs) { [EOL]     if (setStrs == null) { [EOL]         return null; [EOL]     } [EOL]     if (setStrs.length == 1) { [EOL]         final CharSet common = COMMON.get(setStrs[0]); [EOL]         if (common != null) { [EOL]             return common; [EOL]         } [EOL]     } [EOL]     return new CharSet(setStrs); [EOL] }

public static CharSet getInstance(final String... setStrs) { [EOL]     if (setStrs == null) { [EOL]         return null; [EOL]     } [EOL]     if (setStrs.length == 1) { [EOL]         final CharSet common = COMMON.get(setStrs[0]); [EOL]         if (common != null) { [EOL]             return common; [EOL]         } [EOL]     } [EOL]     return new CharSet(setStrs); [EOL] }
CharRange[] getCharRanges() { [EOL]     return set.toArray(new CharRange[set.size()]); [EOL] }

public static CharSet getInstance(final String... setStrs) { [EOL]     if (setStrs == null) { [EOL]         return null; [EOL]     } [EOL]     if (setStrs.length == 1) { [EOL]         final CharSet common = COMMON.get(setStrs[0]); [EOL]         if (common != null) { [EOL]             return common; [EOL]         } [EOL]     } [EOL]     return new CharSet(setStrs); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof CharSet == false) { [EOL]         return false; [EOL]     } [EOL]     final CharSet other = (CharSet) obj; [EOL]     return set.equals(other.set); [EOL] }

@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof CharSet == false) { [EOL]         return false; [EOL]     } [EOL]     final CharSet other = (CharSet) obj; [EOL]     return set.equals(other.set); [EOL] }

public static CharSet getInstance(final String... setStrs) { [EOL]     if (setStrs == null) { [EOL]         return null; [EOL]     } [EOL]     if (setStrs.length == 1) { [EOL]         final CharSet common = COMMON.get(setStrs[0]); [EOL]         if (common != null) { [EOL]             return common; [EOL]         } [EOL]     } [EOL]     return new CharSet(setStrs); [EOL] }
public boolean contains(final char ch) { [EOL]     for (final CharRange range : set) { [EOL]         if (range.contains(ch)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }

public static CharSet getInstance(final String... setStrs) { [EOL]     if (setStrs == null) { [EOL]         return null; [EOL]     } [EOL]     if (setStrs.length == 1) { [EOL]         final CharSet common = COMMON.get(setStrs[0]); [EOL]         if (common != null) { [EOL]             return common; [EOL]         } [EOL]     } [EOL]     return new CharSet(setStrs); [EOL] }

public static CharSet getInstance(final String... setStrs) { [EOL]     if (setStrs == null) { [EOL]         return null; [EOL]     } [EOL]     if (setStrs.length == 1) { [EOL]         final CharSet common = COMMON.get(setStrs[0]); [EOL]         if (common != null) { [EOL]             return common; [EOL]         } [EOL]     } [EOL]     return new CharSet(setStrs); [EOL] }

public static CharSet getInstance(final String... setStrs) { [EOL]     if (setStrs == null) { [EOL]         return null; [EOL]     } [EOL]     if (setStrs.length == 1) { [EOL]         final CharSet common = COMMON.get(setStrs[0]); [EOL]         if (common != null) { [EOL]             return common; [EOL]         } [EOL]     } [EOL]     return new CharSet(setStrs); [EOL] }

public static CharSet getInstance(final String... setStrs) { [EOL]     if (setStrs == null) { [EOL]         return null; [EOL]     } [EOL]     if (setStrs.length == 1) { [EOL]         final CharSet common = COMMON.get(setStrs[0]); [EOL]         if (common != null) { [EOL]             return common; [EOL]         } [EOL]     } [EOL]     return new CharSet(setStrs); [EOL] }

public static CharSet getInstance(final String... setStrs) { [EOL]     if (setStrs == null) { [EOL]         return null; [EOL]     } [EOL]     if (setStrs.length == 1) { [EOL]         final CharSet common = COMMON.get(setStrs[0]); [EOL]         if (common != null) { [EOL]             return common; [EOL]         } [EOL]     } [EOL]     return new CharSet(setStrs); [EOL] }
CharRange[] getCharRanges() { [EOL]     return set.toArray(new CharRange[set.size()]); [EOL] }

@Override [EOL] public String toString() { [EOL]     return set.toString(); [EOL] }

methods/lang3/BitField.java
public boolean isAllSet(final int holder) { [EOL]     return (holder & _mask) == _mask; [EOL] }
public boolean isSet(final int holder) { [EOL]     return (holder & _mask) != 0; [EOL] }
public boolean isSet(final int holder) { [EOL]     return (holder & _mask) != 0; [EOL] }
public int setValue(final int holder, final int value) { [EOL]     return (holder & ~_mask) | ((value << _shift_count) & _mask); [EOL] }
public int set(final int holder) { [EOL]     return holder | _mask; [EOL] }
public int setValue(final int holder, final int value) { [EOL]     return (holder & ~_mask) | ((value << _shift_count) & _mask); [EOL] }
public int set(final int holder) { [EOL]     return holder | _mask; [EOL] }
public short setShortValue(final short holder, final short value) { [EOL]     return (short) setValue(holder, value); [EOL] }
public int set(final int holder) { [EOL]     return holder | _mask; [EOL] }
public short setShort(final short holder) { [EOL]     return (short) set(holder); [EOL] }
public short setShortValue(final short holder, final short value) { [EOL]     return (short) setValue(holder, value); [EOL] }
public int set(final int holder) { [EOL]     return holder | _mask; [EOL] }
public short setShort(final short holder) { [EOL]     return (short) set(holder); [EOL] }
public int set(final int holder) { [EOL]     return holder | _mask; [EOL] }
public short setShort(final short holder) { [EOL]     return (short) set(holder); [EOL] }
public short setShortBoolean(final short holder, final boolean flag) { [EOL]     return flag ? setShort(holder) : clearShort(holder); [EOL] }
public int set(final int holder) { [EOL]     return holder | _mask; [EOL] }
public short setShort(final short holder) { [EOL]     return (short) set(holder); [EOL] }
public int set(final int holder) { [EOL]     return holder | _mask; [EOL] }
public short setShort(final short holder) { [EOL]     return (short) set(holder); [EOL] }
public int set(final int holder) { [EOL]     return holder | _mask; [EOL] }
public byte setByte(final byte holder) { [EOL]     return (byte) set(holder); [EOL] }
public byte setByteBoolean(final byte holder, final boolean flag) { [EOL]     return flag ? setByte(holder) : clearByte(holder); [EOL] }
public int set(final int holder) { [EOL]     return holder | _mask; [EOL] }
public byte setByte(final byte holder) { [EOL]     return (byte) set(holder); [EOL] }
public int set(final int holder) { [EOL]     return holder | _mask; [EOL] }
public byte setByte(final byte holder) { [EOL]     return (byte) set(holder); [EOL] }
public int set(final int holder) { [EOL]     return holder | _mask; [EOL] }
public int setBoolean(final int holder, final boolean flag) { [EOL]     return flag ? set(holder) : clear(holder); [EOL] }
public int set(final int holder) { [EOL]     return holder | _mask; [EOL] }
public int set(final int holder) { [EOL]     return holder | _mask; [EOL] }
public int getValue(final int holder) { [EOL]     return getRawValue(holder) >> _shift_count; [EOL] }
public int getValue(final int holder) { [EOL]     return getRawValue(holder) >> _shift_count; [EOL] }
public short getShortValue(final short holder) { [EOL]     return (short) getValue(holder); [EOL] }
public short getShortValue(final short holder) { [EOL]     return (short) getValue(holder); [EOL] }
public short getShortRawValue(final short holder) { [EOL]     return (short) getRawValue(holder); [EOL] }
public short getShortRawValue(final short holder) { [EOL]     return (short) getRawValue(holder); [EOL] }
public int getRawValue(final int holder) { [EOL]     return holder & _mask; [EOL] }
public int getRawValue(final int holder) { [EOL]     return holder & _mask; [EOL] }
public int clear(final int holder) { [EOL]     return holder & ~_mask; [EOL] }
public short clearShort(final short holder) { [EOL]     return (short) clear(holder); [EOL] }
public int clear(final int holder) { [EOL]     return holder & ~_mask; [EOL] }
public short clearShort(final short holder) { [EOL]     return (short) clear(holder); [EOL] }
public int clear(final int holder) { [EOL]     return holder & ~_mask; [EOL] }
public byte clearByte(final byte holder) { [EOL]     return (byte) clear(holder); [EOL] }
public int clear(final int holder) { [EOL]     return holder & ~_mask; [EOL] }
public byte clearByte(final byte holder) { [EOL]     return (byte) clear(holder); [EOL] }
public int clear(final int holder) { [EOL]     return holder & ~_mask; [EOL] }
public int clear(final int holder) { [EOL]     return holder & ~_mask; [EOL] }
public int clear(final int holder) { [EOL]     return holder & ~_mask; [EOL] }
public byte clearByte(final byte holder) { [EOL]     return (byte) clear(holder); [EOL] }
public int set(final int holder) { [EOL]     return holder | _mask; [EOL] }
public short setShort(final short holder) { [EOL]     return (short) set(holder); [EOL] }
public int clear(final int holder) { [EOL]     return holder & ~_mask; [EOL] }
public int set(final int holder) { [EOL]     return holder | _mask; [EOL] }
public byte setByte(final byte holder) { [EOL]     return (byte) set(holder); [EOL] }
public int getValue(final int holder) { [EOL]     return getRawValue(holder) >> _shift_count; [EOL] }
public int set(final int holder) { [EOL]     return holder | _mask; [EOL] }
public int setValue(final int holder, final int value) { [EOL]     return (holder & ~_mask) | ((value << _shift_count) & _mask); [EOL] }
public int set(final int holder) { [EOL]     return holder | _mask; [EOL] }
public int clear(final int holder) { [EOL]     return holder & ~_mask; [EOL] }
public short clearShort(final short holder) { [EOL]     return (short) clear(holder); [EOL] }
public int getRawValue(final int holder) { [EOL]     return holder & _mask; [EOL] }
public int set(final int holder) { [EOL]     return holder | _mask; [EOL] }
public int setBoolean(final int holder, final boolean flag) { [EOL]     return flag ? set(holder) : clear(holder); [EOL] }
public int set(final int holder) { [EOL]     return holder | _mask; [EOL] }
public int setBoolean(final int holder, final boolean flag) { [EOL]     return flag ? set(holder) : clear(holder); [EOL] }
public boolean isAllSet(final int holder) { [EOL]     return (holder & _mask) == _mask; [EOL] }
public boolean isAllSet(final int holder) { [EOL]     return (holder & _mask) == _mask; [EOL] }
public boolean isSet(final int holder) { [EOL]     return (holder & _mask) != 0; [EOL] }
public short getShortRawValue(final short holder) { [EOL]     return (short) getRawValue(holder); [EOL] }
public int set(final int holder) { [EOL]     return holder | _mask; [EOL] }
public short setShort(final short holder) { [EOL]     return (short) set(holder); [EOL] }
public short setShortBoolean(final short holder, final boolean flag) { [EOL]     return flag ? setShort(holder) : clearShort(holder); [EOL] }
public int set(final int holder) { [EOL]     return holder | _mask; [EOL] }
public byte setByte(final byte holder) { [EOL]     return (byte) set(holder); [EOL] }
public byte setByteBoolean(final byte holder, final boolean flag) { [EOL]     return flag ? setByte(holder) : clearByte(holder); [EOL] }
public short getShortValue(final short holder) { [EOL]     return (short) getValue(holder); [EOL] }
public short setShortValue(final short holder, final short value) { [EOL]     return (short) setValue(holder, value); [EOL] }
public int set(final int holder) { [EOL]     return holder | _mask; [EOL] }
public short setShort(final short holder) { [EOL]     return (short) set(holder); [EOL] }
public int set(final int holder) { [EOL]     return holder | _mask; [EOL] }
public short setShort(final short holder) { [EOL]     return (short) set(holder); [EOL] }
public short setShortBoolean(final short holder, final boolean flag) { [EOL]     return flag ? setShort(holder) : clearShort(holder); [EOL] }
public int set(final int holder) { [EOL]     return holder | _mask; [EOL] }
public byte setByte(final byte holder) { [EOL]     return (byte) set(holder); [EOL] }
public byte setByteBoolean(final byte holder, final boolean flag) { [EOL]     return flag ? setByte(holder) : clearByte(holder); [EOL] }
methods/lang3/JavaVersion.java
static JavaVersion get(final String nom) { [EOL]     if ("0.9".equals(nom)) { [EOL]         return JAVA_0_9; [EOL]     } else if ("1.1".equals(nom)) { [EOL]         return JAVA_1_1; [EOL]     } else if ("1.2".equals(nom)) { [EOL]         return JAVA_1_2; [EOL]     } else if ("1.3".equals(nom)) { [EOL]         return JAVA_1_3; [EOL]     } else if ("1.4".equals(nom)) { [EOL]         return JAVA_1_4; [EOL]     } else if ("1.5".equals(nom)) { [EOL]         return JAVA_1_5; [EOL]     } else if ("1.6".equals(nom)) { [EOL]         return JAVA_1_6; [EOL]     } else if ("1.7".equals(nom)) { [EOL]         return JAVA_1_7; [EOL]     } else if ("1.8".equals(nom)) { [EOL]         return JAVA_1_8; [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] }
static JavaVersion getJavaVersion(final String nom) { [EOL]     return get(nom); [EOL] }
static JavaVersion get(final String nom) { [EOL]     if ("0.9".equals(nom)) { [EOL]         return JAVA_0_9; [EOL]     } else if ("1.1".equals(nom)) { [EOL]         return JAVA_1_1; [EOL]     } else if ("1.2".equals(nom)) { [EOL]         return JAVA_1_2; [EOL]     } else if ("1.3".equals(nom)) { [EOL]         return JAVA_1_3; [EOL]     } else if ("1.4".equals(nom)) { [EOL]         return JAVA_1_4; [EOL]     } else if ("1.5".equals(nom)) { [EOL]         return JAVA_1_5; [EOL]     } else if ("1.6".equals(nom)) { [EOL]         return JAVA_1_6; [EOL]     } else if ("1.7".equals(nom)) { [EOL]         return JAVA_1_7; [EOL]     } else if ("1.8".equals(nom)) { [EOL]         return JAVA_1_8; [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] }
static JavaVersion getJavaVersion(final String nom) { [EOL]     return get(nom); [EOL] }
static JavaVersion get(final String nom) { [EOL]     if ("0.9".equals(nom)) { [EOL]         return JAVA_0_9; [EOL]     } else if ("1.1".equals(nom)) { [EOL]         return JAVA_1_1; [EOL]     } else if ("1.2".equals(nom)) { [EOL]         return JAVA_1_2; [EOL]     } else if ("1.3".equals(nom)) { [EOL]         return JAVA_1_3; [EOL]     } else if ("1.4".equals(nom)) { [EOL]         return JAVA_1_4; [EOL]     } else if ("1.5".equals(nom)) { [EOL]         return JAVA_1_5; [EOL]     } else if ("1.6".equals(nom)) { [EOL]         return JAVA_1_6; [EOL]     } else if ("1.7".equals(nom)) { [EOL]         return JAVA_1_7; [EOL]     } else if ("1.8".equals(nom)) { [EOL]         return JAVA_1_8; [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] }
static JavaVersion getJavaVersion(final String nom) { [EOL]     return get(nom); [EOL] }
static JavaVersion get(final String nom) { [EOL]     if ("0.9".equals(nom)) { [EOL]         return JAVA_0_9; [EOL]     } else if ("1.1".equals(nom)) { [EOL]         return JAVA_1_1; [EOL]     } else if ("1.2".equals(nom)) { [EOL]         return JAVA_1_2; [EOL]     } else if ("1.3".equals(nom)) { [EOL]         return JAVA_1_3; [EOL]     } else if ("1.4".equals(nom)) { [EOL]         return JAVA_1_4; [EOL]     } else if ("1.5".equals(nom)) { [EOL]         return JAVA_1_5; [EOL]     } else if ("1.6".equals(nom)) { [EOL]         return JAVA_1_6; [EOL]     } else if ("1.7".equals(nom)) { [EOL]         return JAVA_1_7; [EOL]     } else if ("1.8".equals(nom)) { [EOL]         return JAVA_1_8; [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] }
static JavaVersion getJavaVersion(final String nom) { [EOL]     return get(nom); [EOL] }
static JavaVersion get(final String nom) { [EOL]     if ("0.9".equals(nom)) { [EOL]         return JAVA_0_9; [EOL]     } else if ("1.1".equals(nom)) { [EOL]         return JAVA_1_1; [EOL]     } else if ("1.2".equals(nom)) { [EOL]         return JAVA_1_2; [EOL]     } else if ("1.3".equals(nom)) { [EOL]         return JAVA_1_3; [EOL]     } else if ("1.4".equals(nom)) { [EOL]         return JAVA_1_4; [EOL]     } else if ("1.5".equals(nom)) { [EOL]         return JAVA_1_5; [EOL]     } else if ("1.6".equals(nom)) { [EOL]         return JAVA_1_6; [EOL]     } else if ("1.7".equals(nom)) { [EOL]         return JAVA_1_7; [EOL]     } else if ("1.8".equals(nom)) { [EOL]         return JAVA_1_8; [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] }
static JavaVersion get(final String nom) { [EOL]     if ("0.9".equals(nom)) { [EOL]         return JAVA_0_9; [EOL]     } else if ("1.1".equals(nom)) { [EOL]         return JAVA_1_1; [EOL]     } else if ("1.2".equals(nom)) { [EOL]         return JAVA_1_2; [EOL]     } else if ("1.3".equals(nom)) { [EOL]         return JAVA_1_3; [EOL]     } else if ("1.4".equals(nom)) { [EOL]         return JAVA_1_4; [EOL]     } else if ("1.5".equals(nom)) { [EOL]         return JAVA_1_5; [EOL]     } else if ("1.6".equals(nom)) { [EOL]         return JAVA_1_6; [EOL]     } else if ("1.7".equals(nom)) { [EOL]         return JAVA_1_7; [EOL]     } else if ("1.8".equals(nom)) { [EOL]         return JAVA_1_8; [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] }
static JavaVersion get(final String nom) { [EOL]     if ("0.9".equals(nom)) { [EOL]         return JAVA_0_9; [EOL]     } else if ("1.1".equals(nom)) { [EOL]         return JAVA_1_1; [EOL]     } else if ("1.2".equals(nom)) { [EOL]         return JAVA_1_2; [EOL]     } else if ("1.3".equals(nom)) { [EOL]         return JAVA_1_3; [EOL]     } else if ("1.4".equals(nom)) { [EOL]         return JAVA_1_4; [EOL]     } else if ("1.5".equals(nom)) { [EOL]         return JAVA_1_5; [EOL]     } else if ("1.6".equals(nom)) { [EOL]         return JAVA_1_6; [EOL]     } else if ("1.7".equals(nom)) { [EOL]         return JAVA_1_7; [EOL]     } else if ("1.8".equals(nom)) { [EOL]         return JAVA_1_8; [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] }
public boolean atLeast(final JavaVersion requiredVersion) { [EOL]     return this.value >= requiredVersion.value; [EOL] }
public boolean atLeast(final JavaVersion requiredVersion) { [EOL]     return this.value >= requiredVersion.value; [EOL] }
@Override [EOL] public String toString() { [EOL]     return name; [EOL] }
static JavaVersion getJavaVersion(final String nom) { [EOL]     return get(nom); [EOL] }
static JavaVersion get(final String nom) { [EOL]     if ("0.9".equals(nom)) { [EOL]         return JAVA_0_9; [EOL]     } else if ("1.1".equals(nom)) { [EOL]         return JAVA_1_1; [EOL]     } else if ("1.2".equals(nom)) { [EOL]         return JAVA_1_2; [EOL]     } else if ("1.3".equals(nom)) { [EOL]         return JAVA_1_3; [EOL]     } else if ("1.4".equals(nom)) { [EOL]         return JAVA_1_4; [EOL]     } else if ("1.5".equals(nom)) { [EOL]         return JAVA_1_5; [EOL]     } else if ("1.6".equals(nom)) { [EOL]         return JAVA_1_6; [EOL]     } else if ("1.7".equals(nom)) { [EOL]         return JAVA_1_7; [EOL]     } else if ("1.8".equals(nom)) { [EOL]         return JAVA_1_8; [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] }
methods/lang3/EnumUtils.java
public static <E extends Enum<E>> boolean isValidEnum(final Class<E> enumClass, final String enumName) { [EOL]     if (enumName == null) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         Enum.valueOf(enumClass, enumName); [EOL]         return true; [EOL]     } catch (final IllegalArgumentException ex) { [EOL]         return false; [EOL]     } [EOL] }
public static <E extends Enum<E>> List<E> getEnumList(final Class<E> enumClass) { [EOL]     return new ArrayList<E>(Arrays.asList(enumClass.getEnumConstants())); [EOL] }
public static <E extends Enum<E>> E getEnum(final Class<E> enumClass, final String enumName) { [EOL]     if (enumName == null) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         return Enum.valueOf(enumClass, enumName); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]         return null; [EOL]     } [EOL] }
public static <E extends Enum<E>> E getEnum(final Class<E> enumClass, final String enumName) { [EOL]     if (enumName == null) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         return Enum.valueOf(enumClass, enumName); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]         return null; [EOL]     } [EOL] }
public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final E... values) { [EOL]     Validate.noNullElements(values); [EOL]     return generateBitVector(enumClass, Arrays.<E>asList(values)); [EOL] }
public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final E... values) { [EOL]     Validate.noNullElements(values); [EOL]     return generateBitVector(enumClass, Arrays.<E>asList(values)); [EOL] }
public static <E extends Enum<E>> EnumSet<E> processBitVector(final Class<E> enumClass, final long value) { [EOL]     checkBitVectorable(enumClass).getEnumConstants(); [EOL]     return processBitVectors(enumClass, value); [EOL] }
public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values) { [EOL]     final EnumSet<E> results = EnumSet.noneOf(asEnum(enumClass)); [EOL]     values = ArrayUtils.clone(Validate.notNull(values)); [EOL]     ArrayUtils.reverse(values); [EOL]     for (final E constant : enumClass.getEnumConstants()) { [EOL]         final int block = constant.ordinal() / Long.SIZE; [EOL]         if (block < values.length && (values[block] & 1 << (constant.ordinal() % Long.SIZE)) != 0) { [EOL]             results.add(constant); [EOL]         } [EOL]     } [EOL]     return results; [EOL] }
public static <E extends Enum<E>> EnumSet<E> processBitVector(final Class<E> enumClass, final long value) { [EOL]     checkBitVectorable(enumClass).getEnumConstants(); [EOL]     return processBitVectors(enumClass, value); [EOL] }
public static <E extends Enum<E>> EnumSet<E> processBitVector(final Class<E> enumClass, final long value) { [EOL]     checkBitVectorable(enumClass).getEnumConstants(); [EOL]     return processBitVectors(enumClass, value); [EOL] }
public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values) { [EOL]     final EnumSet<E> results = EnumSet.noneOf(asEnum(enumClass)); [EOL]     values = ArrayUtils.clone(Validate.notNull(values)); [EOL]     ArrayUtils.reverse(values); [EOL]     for (final E constant : enumClass.getEnumConstants()) { [EOL]         final int block = constant.ordinal() / Long.SIZE; [EOL]         if (block < values.length && (values[block] & 1 << (constant.ordinal() % Long.SIZE)) != 0) { [EOL]             results.add(constant); [EOL]         } [EOL]     } [EOL]     return results; [EOL] }
public static <E extends Enum<E>> boolean isValidEnum(final Class<E> enumClass, final String enumName) { [EOL]     if (enumName == null) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         Enum.valueOf(enumClass, enumName); [EOL]         return true; [EOL]     } catch (final IllegalArgumentException ex) { [EOL]         return false; [EOL]     } [EOL] }
public static <E extends Enum<E>> boolean isValidEnum(final Class<E> enumClass, final String enumName) { [EOL]     if (enumName == null) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         Enum.valueOf(enumClass, enumName); [EOL]         return true; [EOL]     } catch (final IllegalArgumentException ex) { [EOL]         return false; [EOL]     } [EOL] }
public static <E extends Enum<E>> Map<String, E> getEnumMap(final Class<E> enumClass) { [EOL]     final Map<String, E> map = new LinkedHashMap<String, E>(); [EOL]     for (final E e : enumClass.getEnumConstants()) { [EOL]         map.put(e.name(), e); [EOL]     } [EOL]     return map; [EOL] }
public static <E extends Enum<E>> E getEnum(final Class<E> enumClass, final String enumName) { [EOL]     if (enumName == null) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         return Enum.valueOf(enumClass, enumName); [EOL]     } catch (final IllegalArgumentException ex) { [EOL]         return null; [EOL]     } [EOL] }
public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final E... values) { [EOL]     Validate.noNullElements(values); [EOL]     return generateBitVector(enumClass, Arrays.<E>asList(values)); [EOL] }
methods/lang3/ClassUtils.java
public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] }
public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] }
public static Class<?>[] primitivesToWrappers(final Class<?>... classes) { [EOL]     if (classes == null) { [EOL]         return null; [EOL]     } [EOL]     if (classes.length == 0) { [EOL]         return classes; [EOL]     } [EOL]     final Class<?>[] convertedClasses = new Class[classes.length]; [EOL]     for (int i = 0; i < classes.length; i++) { [EOL]         convertedClasses[i] = primitiveToWrapper(classes[i]); [EOL]     } [EOL]     return convertedClasses; [EOL] }
public static String getPackageCanonicalName(final String canonicalName) { [EOL]     return ClassUtils.getPackageName(getCanonicalName(canonicalName)); [EOL] }
public static String getShortClassName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     final StringBuilder arrayPrefix = new StringBuilder(); [EOL]     if (className.startsWith("[")) { [EOL]         while (className.charAt(0) == '[') { [EOL]             className = className.substring(1); [EOL]             arrayPrefix.append("[]"); [EOL]         } [EOL]         if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]             className = className.substring(1, className.length() - 1); [EOL]         } [EOL]         if (reverseAbbreviationMap.containsKey(className)) { [EOL]             className = reverseAbbreviationMap.get(className); [EOL]         } [EOL]     } [EOL]     final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); [EOL]     String out = className.substring(lastDotIdx + 1); [EOL]     if (innerIdx != -1) { [EOL]         out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); [EOL]     } [EOL]     return out + arrayPrefix; [EOL] }
public static Class<?> wrapperToPrimitive(final Class<?> cls) { [EOL]     return wrapperPrimitiveMap.get(cls); [EOL] }
public static String getSimpleName(final Object object, final String valueIfNull) { [EOL]     if (object == null) { [EOL]         return valueIfNull; [EOL]     } [EOL]     return getSimpleName(object.getClass()); [EOL] }
public static String getSimpleName(final Object object, final String valueIfNull) { [EOL]     if (object == null) { [EOL]         return valueIfNull; [EOL]     } [EOL]     return getSimpleName(object.getClass()); [EOL] }
public static String getPackageName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     while (className.charAt(0) == '[') { [EOL]         className = className.substring(1); [EOL]     } [EOL]     if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]         className = className.substring(1); [EOL]     } [EOL]     final int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     if (i == -1) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     return className.substring(0, i); [EOL] }
public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException { [EOL]     final ClassLoader contextCL = Thread.currentThread().getContextClassLoader(); [EOL]     final ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL; [EOL]     return getClass(loader, className, initialize); [EOL] }
public static String getPackageCanonicalName(final String canonicalName) { [EOL]     return ClassUtils.getPackageName(getCanonicalName(canonicalName)); [EOL] }
public static String getPackageCanonicalName(final String canonicalName) { [EOL]     return ClassUtils.getPackageName(getCanonicalName(canonicalName)); [EOL] }
public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException { [EOL]     final ClassLoader contextCL = Thread.currentThread().getContextClassLoader(); [EOL]     final ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL; [EOL]     return getClass(loader, className, initialize); [EOL] }
public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException { [EOL]     final ClassLoader contextCL = Thread.currentThread().getContextClassLoader(); [EOL]     final ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL; [EOL]     return getClass(loader, className, initialize); [EOL] }
public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException { [EOL]     final ClassLoader contextCL = Thread.currentThread().getContextClassLoader(); [EOL]     final ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL; [EOL]     return getClass(loader, className, initialize); [EOL] }
public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException { [EOL]     final ClassLoader contextCL = Thread.currentThread().getContextClassLoader(); [EOL]     final ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL; [EOL]     return getClass(loader, className, initialize); [EOL] }
public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException { [EOL]     final ClassLoader contextCL = Thread.currentThread().getContextClassLoader(); [EOL]     final ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL; [EOL]     return getClass(loader, className, initialize); [EOL] }
public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException { [EOL]     final ClassLoader contextCL = Thread.currentThread().getContextClassLoader(); [EOL]     final ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL; [EOL]     return getClass(loader, className, initialize); [EOL] }
public static List<Class<?>> getAllSuperclasses(final Class<?> cls) { [EOL]     if (cls == null) { [EOL]         return null; [EOL]     } [EOL]     final List<Class<?>> classes = new ArrayList<Class<?>>(); [EOL]     Class<?> superclass = cls.getSuperclass(); [EOL]     while (superclass != null) { [EOL]         classes.add(superclass); [EOL]         superclass = superclass.getSuperclass(); [EOL]     } [EOL]     return classes; [EOL] }
private static void getAllInterfaces(Class<?> cls, final HashSet<Class<?>> interfacesFound) { [EOL]     while (cls != null) { [EOL]         final Class<?>[] interfaces = cls.getInterfaces(); [EOL]         for (final Class<?> i : interfaces) { [EOL]             if (interfacesFound.add(i)) { [EOL]                 getAllInterfaces(i, interfacesFound); [EOL]             } [EOL]         } [EOL]         cls = cls.getSuperclass(); [EOL]     } [EOL] }
public static List<String> convertClassesToClassNames(final List<Class<?>> classes) { [EOL]     if (classes == null) { [EOL]         return null; [EOL]     } [EOL]     final List<String> classNames = new ArrayList<String>(classes.size()); [EOL]     for (final Class<?> cls : classes) { [EOL]         if (cls == null) { [EOL]             classNames.add(null); [EOL]         } else { [EOL]             classNames.add(cls.getName()); [EOL]         } [EOL]     } [EOL]     return classNames; [EOL] }
public static Class<?> primitiveToWrapper(final Class<?> cls) { [EOL]     Class<?> convertedClass = cls; [EOL]     if (cls != null && cls.isPrimitive()) { [EOL]         convertedClass = primitiveWrapperMap.get(cls); [EOL]     } [EOL]     return convertedClass; [EOL] }
public static Class<?> wrapperToPrimitive(final Class<?> cls) { [EOL]     return wrapperPrimitiveMap.get(cls); [EOL] }
public static Class<?> primitiveToWrapper(final Class<?> cls) { [EOL]     Class<?> convertedClass = cls; [EOL]     if (cls != null && cls.isPrimitive()) { [EOL]         convertedClass = primitiveWrapperMap.get(cls); [EOL]     } [EOL]     return convertedClass; [EOL] }
public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] }
public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] }
public static boolean isPrimitiveWrapper(final Class<?> type) { [EOL]     return wrapperPrimitiveMap.containsKey(type); [EOL] }
public static boolean isPrimitiveWrapper(final Class<?> type) { [EOL]     return wrapperPrimitiveMap.containsKey(type); [EOL] }
public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] }
public static String getPackageName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     while (className.charAt(0) == '[') { [EOL]         className = className.substring(1); [EOL]     } [EOL]     if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]         className = className.substring(1); [EOL]     } [EOL]     final int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     if (i == -1) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     return className.substring(0, i); [EOL] }
public static String getPackageName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     while (className.charAt(0) == '[') { [EOL]         className = className.substring(1); [EOL]     } [EOL]     if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]         className = className.substring(1); [EOL]     } [EOL]     final int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     if (i == -1) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     return className.substring(0, i); [EOL] }
public static String getShortClassName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     final StringBuilder arrayPrefix = new StringBuilder(); [EOL]     if (className.startsWith("[")) { [EOL]         while (className.charAt(0) == '[') { [EOL]             className = className.substring(1); [EOL]             arrayPrefix.append("[]"); [EOL]         } [EOL]         if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]             className = className.substring(1, className.length() - 1); [EOL]         } [EOL]         if (reverseAbbreviationMap.containsKey(className)) { [EOL]             className = reverseAbbreviationMap.get(className); [EOL]         } [EOL]     } [EOL]     final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); [EOL]     String out = className.substring(lastDotIdx + 1); [EOL]     if (innerIdx != -1) { [EOL]         out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); [EOL]     } [EOL]     return out + arrayPrefix; [EOL] }
public static String getShortClassName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     final StringBuilder arrayPrefix = new StringBuilder(); [EOL]     if (className.startsWith("[")) { [EOL]         while (className.charAt(0) == '[') { [EOL]             className = className.substring(1); [EOL]             arrayPrefix.append("[]"); [EOL]         } [EOL]         if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]             className = className.substring(1, className.length() - 1); [EOL]         } [EOL]         if (reverseAbbreviationMap.containsKey(className)) { [EOL]             className = reverseAbbreviationMap.get(className); [EOL]         } [EOL]     } [EOL]     final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); [EOL]     String out = className.substring(lastDotIdx + 1); [EOL]     if (innerIdx != -1) { [EOL]         out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); [EOL]     } [EOL]     return out + arrayPrefix; [EOL] }
public static String getShortClassName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     final StringBuilder arrayPrefix = new StringBuilder(); [EOL]     if (className.startsWith("[")) { [EOL]         while (className.charAt(0) == '[') { [EOL]             className = className.substring(1); [EOL]             arrayPrefix.append("[]"); [EOL]         } [EOL]         if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]             className = className.substring(1, className.length() - 1); [EOL]         } [EOL]         if (reverseAbbreviationMap.containsKey(className)) { [EOL]             className = reverseAbbreviationMap.get(className); [EOL]         } [EOL]     } [EOL]     final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); [EOL]     String out = className.substring(lastDotIdx + 1); [EOL]     if (innerIdx != -1) { [EOL]         out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); [EOL]     } [EOL]     return out + arrayPrefix; [EOL] }
public static String getShortClassName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     final StringBuilder arrayPrefix = new StringBuilder(); [EOL]     if (className.startsWith("[")) { [EOL]         while (className.charAt(0) == '[') { [EOL]             className = className.substring(1); [EOL]             arrayPrefix.append("[]"); [EOL]         } [EOL]         if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]             className = className.substring(1, className.length() - 1); [EOL]         } [EOL]         if (reverseAbbreviationMap.containsKey(className)) { [EOL]             className = reverseAbbreviationMap.get(className); [EOL]         } [EOL]     } [EOL]     final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); [EOL]     String out = className.substring(lastDotIdx + 1); [EOL]     if (innerIdx != -1) { [EOL]         out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); [EOL]     } [EOL]     return out + arrayPrefix; [EOL] }
public static String getShortCanonicalName(final String canonicalName) { [EOL]     return ClassUtils.getShortClassName(getCanonicalName(canonicalName)); [EOL] }
public static String getPackageCanonicalName(final String canonicalName) { [EOL]     return ClassUtils.getPackageName(getCanonicalName(canonicalName)); [EOL] }
public static String getPackageCanonicalName(final String canonicalName) { [EOL]     return ClassUtils.getPackageName(getCanonicalName(canonicalName)); [EOL] }
public static String getPackageCanonicalName(final String canonicalName) { [EOL]     return ClassUtils.getPackageName(getCanonicalName(canonicalName)); [EOL] }
public static String getPackageCanonicalName(final String canonicalName) { [EOL]     return ClassUtils.getPackageName(getCanonicalName(canonicalName)); [EOL] }
public static String getShortCanonicalName(final String canonicalName) { [EOL]     return ClassUtils.getShortClassName(getCanonicalName(canonicalName)); [EOL] }
public static String getShortCanonicalName(final String canonicalName) { [EOL]     return ClassUtils.getShortClassName(getCanonicalName(canonicalName)); [EOL] }
public static Class<?>[] toClass(final Object... array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Class<?>[] classes = new Class[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         classes[i] = array[i] == null ? null : array[i].getClass(); [EOL]     } [EOL]     return classes; [EOL] }
public static Class<?>[] toClass(final Object... array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Class<?>[] classes = new Class[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         classes[i] = array[i] == null ? null : array[i].getClass(); [EOL]     } [EOL]     return classes; [EOL] }
public static Class<?>[] toClass(final Object... array) { [EOL]     if (array == null) { [EOL]         return null; [EOL]     } else if (array.length == 0) { [EOL]         return ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Class<?>[] classes = new Class[array.length]; [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         classes[i] = array[i] == null ? null : array[i].getClass(); [EOL]     } [EOL]     return classes; [EOL] }
public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException { [EOL]     final ClassLoader contextCL = Thread.currentThread().getContextClassLoader(); [EOL]     final ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL; [EOL]     return getClass(loader, className, initialize); [EOL] }
public static boolean isInnerClass(final Class<?> cls) { [EOL]     return cls != null && cls.getEnclosingClass() != null; [EOL] }
public static boolean isInnerClass(final Class<?> cls) { [EOL]     return cls != null && cls.getEnclosingClass() != null; [EOL] }
public static Class<?>[] wrappersToPrimitives(final Class<?>... classes) { [EOL]     if (classes == null) { [EOL]         return null; [EOL]     } [EOL]     if (classes.length == 0) { [EOL]         return classes; [EOL]     } [EOL]     final Class<?>[] convertedClasses = new Class[classes.length]; [EOL]     for (int i = 0; i < classes.length; i++) { [EOL]         convertedClasses[i] = wrapperToPrimitive(classes[i]); [EOL]     } [EOL]     return convertedClasses; [EOL] }
public static Class<?>[] wrappersToPrimitives(final Class<?>... classes) { [EOL]     if (classes == null) { [EOL]         return null; [EOL]     } [EOL]     if (classes.length == 0) { [EOL]         return classes; [EOL]     } [EOL]     final Class<?>[] convertedClasses = new Class[classes.length]; [EOL]     for (int i = 0; i < classes.length; i++) { [EOL]         convertedClasses[i] = wrapperToPrimitive(classes[i]); [EOL]     } [EOL]     return convertedClasses; [EOL] }
public static Class<?>[] primitivesToWrappers(final Class<?>... classes) { [EOL]     if (classes == null) { [EOL]         return null; [EOL]     } [EOL]     if (classes.length == 0) { [EOL]         return classes; [EOL]     } [EOL]     final Class<?>[] convertedClasses = new Class[classes.length]; [EOL]     for (int i = 0; i < classes.length; i++) { [EOL]         convertedClasses[i] = primitiveToWrapper(classes[i]); [EOL]     } [EOL]     return convertedClasses; [EOL] }
public static Class<?>[] primitivesToWrappers(final Class<?>... classes) { [EOL]     if (classes == null) { [EOL]         return null; [EOL]     } [EOL]     if (classes.length == 0) { [EOL]         return classes; [EOL]     } [EOL]     final Class<?>[] convertedClasses = new Class[classes.length]; [EOL]     for (int i = 0; i < classes.length; i++) { [EOL]         convertedClasses[i] = primitiveToWrapper(classes[i]); [EOL]     } [EOL]     return convertedClasses; [EOL] }
public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] }
public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] }
public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException { [EOL]     final ClassLoader contextCL = Thread.currentThread().getContextClassLoader(); [EOL]     final ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL; [EOL]     return getClass(loader, className, initialize); [EOL] }
public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] }
public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] }
public static boolean isPrimitiveOrWrapper(final Class<?> type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     return type.isPrimitive() || isPrimitiveWrapper(type); [EOL] }
public static boolean isPrimitiveOrWrapper(final Class<?> type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     return type.isPrimitive() || isPrimitiveWrapper(type); [EOL] }
public static boolean isPrimitiveOrWrapper(final Class<?> type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     return type.isPrimitive() || isPrimitiveWrapper(type); [EOL] }
public static boolean isPrimitiveOrWrapper(final Class<?> type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     return type.isPrimitive() || isPrimitiveWrapper(type); [EOL] }
public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] }
public static List<String> convertClassesToClassNames(final List<Class<?>> classes) { [EOL]     if (classes == null) { [EOL]         return null; [EOL]     } [EOL]     final List<String> classNames = new ArrayList<String>(classes.size()); [EOL]     for (final Class<?> cls : classes) { [EOL]         if (cls == null) { [EOL]             classNames.add(null); [EOL]         } else { [EOL]             classNames.add(cls.getName()); [EOL]         } [EOL]     } [EOL]     return classNames; [EOL] }
public static List<Class<?>> convertClassNamesToClasses(final List<String> classNames) { [EOL]     if (classNames == null) { [EOL]         return null; [EOL]     } [EOL]     final List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size()); [EOL]     for (final String className : classNames) { [EOL]         try { [EOL]             classes.add(Class.forName(className)); [EOL]         } catch (final Exception ex) { [EOL]             classes.add(null); [EOL]         } [EOL]     } [EOL]     return classes; [EOL] }
public static List<Class<?>> convertClassNamesToClasses(final List<String> classNames) { [EOL]     if (classNames == null) { [EOL]         return null; [EOL]     } [EOL]     final List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size()); [EOL]     for (final String className : classNames) { [EOL]         try { [EOL]             classes.add(Class.forName(className)); [EOL]         } catch (final Exception ex) { [EOL]             classes.add(null); [EOL]         } [EOL]     } [EOL]     return classes; [EOL] }
public static List<Class<?>> convertClassNamesToClasses(final List<String> classNames) { [EOL]     if (classNames == null) { [EOL]         return null; [EOL]     } [EOL]     final List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size()); [EOL]     for (final String className : classNames) { [EOL]         try { [EOL]             classes.add(Class.forName(className)); [EOL]         } catch (final Exception ex) { [EOL]             classes.add(null); [EOL]         } [EOL]     } [EOL]     return classes; [EOL] }
private static void getAllInterfaces(Class<?> cls, final HashSet<Class<?>> interfacesFound) { [EOL]     while (cls != null) { [EOL]         final Class<?>[] interfaces = cls.getInterfaces(); [EOL]         for (final Class<?> i : interfaces) { [EOL]             if (interfacesFound.add(i)) { [EOL]                 getAllInterfaces(i, interfacesFound); [EOL]             } [EOL]         } [EOL]         cls = cls.getSuperclass(); [EOL]     } [EOL] }
public static String getPackageName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     while (className.charAt(0) == '[') { [EOL]         className = className.substring(1); [EOL]     } [EOL]     if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]         className = className.substring(1); [EOL]     } [EOL]     final int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     if (i == -1) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     return className.substring(0, i); [EOL] }
public static String getPackageName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     while (className.charAt(0) == '[') { [EOL]         className = className.substring(1); [EOL]     } [EOL]     if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]         className = className.substring(1); [EOL]     } [EOL]     final int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     if (i == -1) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     return className.substring(0, i); [EOL] }
public static String getPackageName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     while (className.charAt(0) == '[') { [EOL]         className = className.substring(1); [EOL]     } [EOL]     if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]         className = className.substring(1); [EOL]     } [EOL]     final int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     if (i == -1) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     return className.substring(0, i); [EOL] }
public static String getPackageName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     while (className.charAt(0) == '[') { [EOL]         className = className.substring(1); [EOL]     } [EOL]     if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]         className = className.substring(1); [EOL]     } [EOL]     final int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     if (i == -1) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     return className.substring(0, i); [EOL] }
public static String getSimpleName(final Object object, final String valueIfNull) { [EOL]     if (object == null) { [EOL]         return valueIfNull; [EOL]     } [EOL]     return getSimpleName(object.getClass()); [EOL] }
public static String getSimpleName(final Object object, final String valueIfNull) { [EOL]     if (object == null) { [EOL]         return valueIfNull; [EOL]     } [EOL]     return getSimpleName(object.getClass()); [EOL] }
public static String getSimpleName(final Object object, final String valueIfNull) { [EOL]     if (object == null) { [EOL]         return valueIfNull; [EOL]     } [EOL]     return getSimpleName(object.getClass()); [EOL] }
public static String getSimpleName(final Object object, final String valueIfNull) { [EOL]     if (object == null) { [EOL]         return valueIfNull; [EOL]     } [EOL]     return getSimpleName(object.getClass()); [EOL] }
public static String getShortClassName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     final StringBuilder arrayPrefix = new StringBuilder(); [EOL]     if (className.startsWith("[")) { [EOL]         while (className.charAt(0) == '[') { [EOL]             className = className.substring(1); [EOL]             arrayPrefix.append("[]"); [EOL]         } [EOL]         if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]             className = className.substring(1, className.length() - 1); [EOL]         } [EOL]         if (reverseAbbreviationMap.containsKey(className)) { [EOL]             className = reverseAbbreviationMap.get(className); [EOL]         } [EOL]     } [EOL]     final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); [EOL]     String out = className.substring(lastDotIdx + 1); [EOL]     if (innerIdx != -1) { [EOL]         out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); [EOL]     } [EOL]     return out + arrayPrefix; [EOL] }
public static String getShortClassName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     final StringBuilder arrayPrefix = new StringBuilder(); [EOL]     if (className.startsWith("[")) { [EOL]         while (className.charAt(0) == '[') { [EOL]             className = className.substring(1); [EOL]             arrayPrefix.append("[]"); [EOL]         } [EOL]         if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]             className = className.substring(1, className.length() - 1); [EOL]         } [EOL]         if (reverseAbbreviationMap.containsKey(className)) { [EOL]             className = reverseAbbreviationMap.get(className); [EOL]         } [EOL]     } [EOL]     final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); [EOL]     String out = className.substring(lastDotIdx + 1); [EOL]     if (innerIdx != -1) { [EOL]         out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); [EOL]     } [EOL]     return out + arrayPrefix; [EOL] }
public static String getShortCanonicalName(final String canonicalName) { [EOL]     return ClassUtils.getShortClassName(getCanonicalName(canonicalName)); [EOL] }
public static String getShortClassName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     final StringBuilder arrayPrefix = new StringBuilder(); [EOL]     if (className.startsWith("[")) { [EOL]         while (className.charAt(0) == '[') { [EOL]             className = className.substring(1); [EOL]             arrayPrefix.append("[]"); [EOL]         } [EOL]         if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]             className = className.substring(1, className.length() - 1); [EOL]         } [EOL]         if (reverseAbbreviationMap.containsKey(className)) { [EOL]             className = reverseAbbreviationMap.get(className); [EOL]         } [EOL]     } [EOL]     final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); [EOL]     String out = className.substring(lastDotIdx + 1); [EOL]     if (innerIdx != -1) { [EOL]         out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); [EOL]     } [EOL]     return out + arrayPrefix; [EOL] }
public static String getShortClassName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     final StringBuilder arrayPrefix = new StringBuilder(); [EOL]     if (className.startsWith("[")) { [EOL]         while (className.charAt(0) == '[') { [EOL]             className = className.substring(1); [EOL]             arrayPrefix.append("[]"); [EOL]         } [EOL]         if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]             className = className.substring(1, className.length() - 1); [EOL]         } [EOL]         if (reverseAbbreviationMap.containsKey(className)) { [EOL]             className = reverseAbbreviationMap.get(className); [EOL]         } [EOL]     } [EOL]     final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); [EOL]     String out = className.substring(lastDotIdx + 1); [EOL]     if (innerIdx != -1) { [EOL]         out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); [EOL]     } [EOL]     return out + arrayPrefix; [EOL] }
public static String getShortClassName(String className) { [EOL]     if (StringUtils.isEmpty(className)) { [EOL]         return StringUtils.EMPTY; [EOL]     } [EOL]     final StringBuilder arrayPrefix = new StringBuilder(); [EOL]     if (className.startsWith("[")) { [EOL]         while (className.charAt(0) == '[') { [EOL]             className = className.substring(1); [EOL]             arrayPrefix.append("[]"); [EOL]         } [EOL]         if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') { [EOL]             className = className.substring(1, className.length() - 1); [EOL]         } [EOL]         if (reverseAbbreviationMap.containsKey(className)) { [EOL]             className = reverseAbbreviationMap.get(className); [EOL]         } [EOL]     } [EOL]     final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); [EOL]     final int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); [EOL]     String out = className.substring(lastDotIdx + 1); [EOL]     if (innerIdx != -1) { [EOL]         out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); [EOL]     } [EOL]     return out + arrayPrefix; [EOL] }
public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] }
public static String getShortCanonicalName(final String canonicalName) { [EOL]     return ClassUtils.getShortClassName(getCanonicalName(canonicalName)); [EOL] }
public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) { [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (cls == null) { [EOL]         return !toClass.isPrimitive(); [EOL]     } [EOL]     if (autoboxing) { [EOL]         if (cls.isPrimitive() && !toClass.isPrimitive()) { [EOL]             cls = primitiveToWrapper(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (toClass.isPrimitive() && !cls.isPrimitive()) { [EOL]             cls = wrapperToPrimitive(cls); [EOL]             if (cls == null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (cls.equals(toClass)) { [EOL]         return true; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive() == false) { [EOL]             return false; [EOL]         } [EOL]         if (Integer.TYPE.equals(cls)) { [EOL]             return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Long.TYPE.equals(cls)) { [EOL]             return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Boolean.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Double.TYPE.equals(cls)) { [EOL]             return false; [EOL]         } [EOL]         if (Float.TYPE.equals(cls)) { [EOL]             return Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Character.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Short.TYPE.equals(cls)) { [EOL]             return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         if (Byte.TYPE.equals(cls)) { [EOL]             return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return toClass.isAssignableFrom(cls); [EOL] }
methods/lang3/Range.java
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public Range<T> intersectionWith(final Range<T> other) { [EOL]     if (!this.isOverlappedBy(other)) { [EOL]         throw new IllegalArgumentException(String.format("Cannot calculate intersection with non-overlapping range %s", other)); [EOL]     } [EOL]     if (this.equals(other)) { [EOL]         return this; [EOL]     } [EOL]     final T min = getComparator().compare(minimum, other.minimum) < 0 ? other.minimum : minimum; [EOL]     final T max = getComparator().compare(maximum, other.maximum) < 0 ? maximum : other.maximum; [EOL]     return between(min, max, getComparator()); [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) { [EOL]     return new Range<T>(fromInclusive, toInclusive, comparator); [EOL] }
public boolean isBefore(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, maximum) > 0; [EOL] }
public boolean isBeforeRange(final Range<T> otherRange) { [EOL]     if (otherRange == null) { [EOL]         return false; [EOL]     } [EOL]     return isBefore(otherRange.minimum); [EOL] }
@Override [EOL] public int compare(final Object obj1, final Object obj2) { [EOL]     return ((Comparable) obj1).compareTo(obj2); [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) { [EOL]     return new Range<T>(fromInclusive, toInclusive, comparator); [EOL] }
public boolean isBefore(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, maximum) > 0; [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) { [EOL]     return new Range<T>(fromInclusive, toInclusive, comparator); [EOL] }
public boolean isEndedBy(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, maximum) == 0; [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public boolean isStartedBy(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, minimum) == 0; [EOL] }
@Override [EOL] public int compare(final Object obj1, final Object obj2) { [EOL]     return ((Comparable) obj1).compareTo(obj2); [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public String toString(final String format) { [EOL]     return String.format(format, minimum, maximum, comparator); [EOL] }
@Override [EOL] public int compare(final Object obj1, final Object obj2) { [EOL]     return ((Comparable) obj1).compareTo(obj2); [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) { [EOL]     return new Range<T>(fromInclusive, toInclusive, comparator); [EOL] }
public String toString(final String format) { [EOL]     return String.format(format, minimum, maximum, comparator); [EOL] }
@Override [EOL] public int compare(final Object obj1, final Object obj2) { [EOL]     return ((Comparable) obj1).compareTo(obj2); [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public boolean isBefore(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, maximum) > 0; [EOL] }
public boolean isBeforeRange(final Range<T> otherRange) { [EOL]     if (otherRange == null) { [EOL]         return false; [EOL]     } [EOL]     return isBefore(otherRange.minimum); [EOL] }
@Override [EOL] public int compare(final Object obj1, final Object obj2) { [EOL]     return ((Comparable) obj1).compareTo(obj2); [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) { [EOL]     return new Range<T>(fromInclusive, toInclusive, comparator); [EOL] }
public boolean isAfter(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, minimum) < 0; [EOL] }
public boolean isAfterRange(final Range<T> otherRange) { [EOL]     if (otherRange == null) { [EOL]         return false; [EOL]     } [EOL]     return isAfter(otherRange.maximum); [EOL] }
@Override [EOL] public int compare(final Object obj1, final Object obj2) { [EOL]     return ((Comparable) obj1).compareTo(obj2); [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public Range<T> intersectionWith(final Range<T> other) { [EOL]     if (!this.isOverlappedBy(other)) { [EOL]         throw new IllegalArgumentException(String.format("Cannot calculate intersection with non-overlapping range %s", other)); [EOL]     } [EOL]     if (this.equals(other)) { [EOL]         return this; [EOL]     } [EOL]     final T min = getComparator().compare(minimum, other.minimum) < 0 ? other.minimum : minimum; [EOL]     final T max = getComparator().compare(maximum, other.maximum) < 0 ? maximum : other.maximum; [EOL]     return between(min, max, getComparator()); [EOL] }
@Override [EOL] public int compare(final Object obj1, final Object obj2) { [EOL]     return ((Comparable) obj1).compareTo(obj2); [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } else if (obj == null || obj.getClass() != getClass()) { [EOL]         return false; [EOL]     } else { [EOL]         @SuppressWarnings("unchecked") [EOL]         final Range<T> range = (Range<T>) obj; [EOL]         return minimum.equals(range.minimum) && maximum.equals(range.maximum); [EOL]     } [EOL] }
@Override [EOL] public int compare(final Object obj1, final Object obj2) { [EOL]     return ((Comparable) obj1).compareTo(obj2); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } else if (obj == null || obj.getClass() != getClass()) { [EOL]         return false; [EOL]     } else { [EOL]         @SuppressWarnings("unchecked") [EOL]         final Range<T> range = (Range<T>) obj; [EOL]         return minimum.equals(range.minimum) && maximum.equals(range.maximum); [EOL]     } [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) { [EOL]     return new Range<T>(fromInclusive, toInclusive, comparator); [EOL] }
public Comparator<T> getComparator() { [EOL]     return comparator; [EOL] }
public boolean isOverlappedBy(final Range<T> otherRange) { [EOL]     if (otherRange == null) { [EOL]         return false; [EOL]     } [EOL]     return otherRange.contains(minimum) || otherRange.contains(maximum) || contains(otherRange.minimum); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } else if (obj == null || obj.getClass() != getClass()) { [EOL]         return false; [EOL]     } else { [EOL]         @SuppressWarnings("unchecked") [EOL]         final Range<T> range = (Range<T>) obj; [EOL]         return minimum.equals(range.minimum) && maximum.equals(range.maximum); [EOL]     } [EOL] }
public String toString(final String format) { [EOL]     return String.format(format, minimum, maximum, comparator); [EOL] }
@Override [EOL] public int compare(final Object obj1, final Object obj2) { [EOL]     return ((Comparable) obj1).compareTo(obj2); [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public boolean isOverlappedBy(final Range<T> otherRange) { [EOL]     if (otherRange == null) { [EOL]         return false; [EOL]     } [EOL]     return otherRange.contains(minimum) || otherRange.contains(maximum) || contains(otherRange.minimum); [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public boolean isOverlappedBy(final Range<T> otherRange) { [EOL]     if (otherRange == null) { [EOL]         return false; [EOL]     } [EOL]     return otherRange.contains(minimum) || otherRange.contains(maximum) || contains(otherRange.minimum); [EOL] }
@Override [EOL] public int compare(final Object obj1, final Object obj2) { [EOL]     return ((Comparable) obj1).compareTo(obj2); [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public boolean isBefore(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, maximum) > 0; [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) { [EOL]     return new Range<T>(fromInclusive, toInclusive, comparator); [EOL] }
public Comparator<T> getComparator() { [EOL]     return comparator; [EOL] }
public boolean isAfter(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, minimum) < 0; [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public boolean isAfter(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, minimum) < 0; [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public boolean contains(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, minimum) > -1 && comparator.compare(element, maximum) < 1; [EOL] }
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) { [EOL]     return new Range<T>(fromInclusive, toInclusive, comparator); [EOL] }
public boolean contains(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, minimum) > -1 && comparator.compare(element, maximum) < 1; [EOL] }
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) { [EOL]     return new Range<T>(fromInclusive, toInclusive, comparator); [EOL] }
public boolean contains(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, minimum) > -1 && comparator.compare(element, maximum) < 1; [EOL] }
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) { [EOL]     return new Range<T>(fromInclusive, toInclusive, comparator); [EOL] }
public String toString(final String format) { [EOL]     return String.format(format, minimum, maximum, comparator); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } else if (obj == null || obj.getClass() != getClass()) { [EOL]         return false; [EOL]     } else { [EOL]         @SuppressWarnings("unchecked") [EOL]         final Range<T> range = (Range<T>) obj; [EOL]         return minimum.equals(range.minimum) && maximum.equals(range.maximum); [EOL]     } [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } else if (obj == null || obj.getClass() != getClass()) { [EOL]         return false; [EOL]     } else { [EOL]         @SuppressWarnings("unchecked") [EOL]         final Range<T> range = (Range<T>) obj; [EOL]         return minimum.equals(range.minimum) && maximum.equals(range.maximum); [EOL]     } [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } else if (obj == null || obj.getClass() != getClass()) { [EOL]         return false; [EOL]     } else { [EOL]         @SuppressWarnings("unchecked") [EOL]         final Range<T> range = (Range<T>) obj; [EOL]         return minimum.equals(range.minimum) && maximum.equals(range.maximum); [EOL]     } [EOL] }
@Override [EOL] public int compare(final Object obj1, final Object obj2) { [EOL]     return ((Comparable) obj1).compareTo(obj2); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } else if (obj == null || obj.getClass() != getClass()) { [EOL]         return false; [EOL]     } else { [EOL]         @SuppressWarnings("unchecked") [EOL]         final Range<T> range = (Range<T>) obj; [EOL]         return minimum.equals(range.minimum) && maximum.equals(range.maximum); [EOL]     } [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public boolean isBefore(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, maximum) > 0; [EOL] }
public boolean isBeforeRange(final Range<T> otherRange) { [EOL]     if (otherRange == null) { [EOL]         return false; [EOL]     } [EOL]     return isBefore(otherRange.minimum); [EOL] }
@Override [EOL] public int compare(final Object obj1, final Object obj2) { [EOL]     return ((Comparable) obj1).compareTo(obj2); [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) { [EOL]     return new Range<T>(fromInclusive, toInclusive, comparator); [EOL] }
public boolean isOverlappedBy(final Range<T> otherRange) { [EOL]     if (otherRange == null) { [EOL]         return false; [EOL]     } [EOL]     return otherRange.contains(minimum) || otherRange.contains(maximum) || contains(otherRange.minimum); [EOL] }
@Override [EOL] public int compare(final Object obj1, final Object obj2) { [EOL]     return ((Comparable) obj1).compareTo(obj2); [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public boolean isAfter(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, minimum) < 0; [EOL] }
public boolean isAfterRange(final Range<T> otherRange) { [EOL]     if (otherRange == null) { [EOL]         return false; [EOL]     } [EOL]     return isAfter(otherRange.maximum); [EOL] }
@Override [EOL] public int compare(final Object obj1, final Object obj2) { [EOL]     return ((Comparable) obj1).compareTo(obj2); [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public boolean isAfter(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, minimum) < 0; [EOL] }
public boolean isAfterRange(final Range<T> otherRange) { [EOL]     if (otherRange == null) { [EOL]         return false; [EOL]     } [EOL]     return isAfter(otherRange.maximum); [EOL] }
@Override [EOL] public int compare(final Object obj1, final Object obj2) { [EOL]     return ((Comparable) obj1).compareTo(obj2); [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public boolean contains(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, minimum) > -1 && comparator.compare(element, maximum) < 1; [EOL] }
public boolean containsRange(final Range<T> otherRange) { [EOL]     if (otherRange == null) { [EOL]         return false; [EOL]     } [EOL]     return contains(otherRange.minimum) && contains(otherRange.maximum); [EOL] }
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) { [EOL]     return new Range<T>(fromInclusive, toInclusive, comparator); [EOL] }
public boolean contains(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, minimum) > -1 && comparator.compare(element, maximum) < 1; [EOL] }
public boolean containsRange(final Range<T> otherRange) { [EOL]     if (otherRange == null) { [EOL]         return false; [EOL]     } [EOL]     return contains(otherRange.minimum) && contains(otherRange.maximum); [EOL] }
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) { [EOL]     return new Range<T>(fromInclusive, toInclusive, comparator); [EOL] }
public int elementCompareTo(final T element) { [EOL]     if (element == null) { [EOL]         throw new NullPointerException("Element is null"); [EOL]     } [EOL]     if (isAfter(element)) { [EOL]         return -1; [EOL]     } else if (isBefore(element)) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] }
@Override [EOL] public int compare(final Object obj1, final Object obj2) { [EOL]     return ((Comparable) obj1).compareTo(obj2); [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public boolean isBefore(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, maximum) > 0; [EOL] }
@Override [EOL] public int compare(final Object obj1, final Object obj2) { [EOL]     return ((Comparable) obj1).compareTo(obj2); [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) { [EOL]     return new Range<T>(fromInclusive, toInclusive, comparator); [EOL] }
public boolean isEndedBy(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, maximum) == 0; [EOL] }
@Override [EOL] public int compare(final Object obj1, final Object obj2) { [EOL]     return ((Comparable) obj1).compareTo(obj2); [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) { [EOL]     return new Range<T>(fromInclusive, toInclusive, comparator); [EOL] }
public boolean isEndedBy(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, maximum) == 0; [EOL] }
@Override [EOL] public int compare(final Object obj1, final Object obj2) { [EOL]     return ((Comparable) obj1).compareTo(obj2); [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) { [EOL]     return new Range<T>(fromInclusive, toInclusive, comparator); [EOL] }
public boolean isEndedBy(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, maximum) == 0; [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) { [EOL]     return new Range<T>(fromInclusive, toInclusive, comparator); [EOL] }
public boolean isStartedBy(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, minimum) == 0; [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public boolean isStartedBy(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, minimum) == 0; [EOL] }
@Override [EOL] public int compare(final Object obj1, final Object obj2) { [EOL]     return ((Comparable) obj1).compareTo(obj2); [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) { [EOL]     return new Range<T>(fromInclusive, toInclusive, comparator); [EOL] }
public boolean isStartedBy(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, minimum) == 0; [EOL] }
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) { [EOL]     return new Range<T>(fromInclusive, toInclusive, comparator); [EOL] }
public Comparator<T> getComparator() { [EOL]     return comparator; [EOL] }
public int elementCompareTo(final T element) { [EOL]     if (element == null) { [EOL]         throw new NullPointerException("Element is null"); [EOL]     } [EOL]     if (isAfter(element)) { [EOL]         return -1; [EOL]     } else if (isBefore(element)) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) { [EOL]     return new Range<T>(fromInclusive, toInclusive, comparator); [EOL] }
public boolean isAfter(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, minimum) < 0; [EOL] }
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) { [EOL]     return new Range<T>(fromInclusive, toInclusive, comparator); [EOL] }
public int elementCompareTo(final T element) { [EOL]     if (element == null) { [EOL]         throw new NullPointerException("Element is null"); [EOL]     } [EOL]     if (isAfter(element)) { [EOL]         return -1; [EOL]     } else if (isBefore(element)) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public Comparator<T> getComparator() { [EOL]     return comparator; [EOL] }
public boolean contains(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, minimum) > -1 && comparator.compare(element, maximum) < 1; [EOL] }
public boolean containsRange(final Range<T> otherRange) { [EOL]     if (otherRange == null) { [EOL]         return false; [EOL]     } [EOL]     return contains(otherRange.minimum) && contains(otherRange.maximum); [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) { [EOL]     return new Range<T>(fromInclusive, toInclusive, comparator); [EOL] }
public boolean isOverlappedBy(final Range<T> otherRange) { [EOL]     if (otherRange == null) { [EOL]         return false; [EOL]     } [EOL]     return otherRange.contains(minimum) || otherRange.contains(maximum) || contains(otherRange.minimum); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } else if (obj == null || obj.getClass() != getClass()) { [EOL]         return false; [EOL]     } else { [EOL]         @SuppressWarnings("unchecked") [EOL]         final Range<T> range = (Range<T>) obj; [EOL]         return minimum.equals(range.minimum) && maximum.equals(range.maximum); [EOL]     } [EOL] }
@Override [EOL] public int compare(final Object obj1, final Object obj2) { [EOL]     return ((Comparable) obj1).compareTo(obj2); [EOL] }
public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) { [EOL]     return new Range<T>(fromInclusive, toInclusive, comparator); [EOL] }
public boolean contains(final T element) { [EOL]     if (element == null) { [EOL]         return false; [EOL]     } [EOL]     return comparator.compare(element, minimum) > -1 && comparator.compare(element, maximum) < 1; [EOL] }
@Override [EOL] public int compare(final Object obj1, final Object obj2) { [EOL]     return ((Comparable) obj1).compareTo(obj2); [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public boolean isNaturalOrdering() { [EOL]     return comparator == ComparableComparator.INSTANCE; [EOL] }
@Override [EOL] public int compare(final Object obj1, final Object obj2) { [EOL]     return ((Comparable) obj1).compareTo(obj2); [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public T getMinimum() { [EOL]     return minimum; [EOL] }
@Override [EOL] public int compare(final Object obj1, final Object obj2) { [EOL]     return ((Comparable) obj1).compareTo(obj2); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } else if (obj == null || obj.getClass() != getClass()) { [EOL]         return false; [EOL]     } else { [EOL]         @SuppressWarnings("unchecked") [EOL]         final Range<T> range = (Range<T>) obj; [EOL]         return minimum.equals(range.minimum) && maximum.equals(range.maximum); [EOL]     } [EOL] }
public static <T> Range<T> is(final T element, final Comparator<T> comparator) { [EOL]     return between(element, element, comparator); [EOL] }
public boolean isNaturalOrdering() { [EOL]     return comparator == ComparableComparator.INSTANCE; [EOL] }
methods/lang3/StringUtils.java
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static String[] split(final String str, final String separatorChars, final int max) { [EOL]     return splitWorker(str, separatorChars, max, false); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static String substring(final String str, int start, int end) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (end < 0) { [EOL]         end = str.length() + end; [EOL]     } [EOL]     if (start < 0) { [EOL]         start = str.length() + start; [EOL]     } [EOL]     if (end > str.length()) { [EOL]         end = str.length(); [EOL]     } [EOL]     if (start > end) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (start < 0) { [EOL]         start = 0; [EOL]     } [EOL]     if (end < 0) { [EOL]         end = 0; [EOL]     } [EOL]     return str.substring(start, end); [EOL] }
public static String[] substringsBetween(final String str, final String open, final String close) { [EOL]     if (str == null || isEmpty(open) || isEmpty(close)) { [EOL]         return null; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     if (strLen == 0) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final int closeLen = close.length(); [EOL]     final int openLen = open.length(); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     int pos = 0; [EOL]     while (pos < strLen - closeLen) { [EOL]         int start = str.indexOf(open, pos); [EOL]         if (start < 0) { [EOL]             break; [EOL]         } [EOL]         start += openLen; [EOL]         final int end = str.indexOf(close, start); [EOL]         if (end < 0) { [EOL]             break; [EOL]         } [EOL]         list.add(str.substring(start, end)); [EOL]         pos = end + closeLen; [EOL]     } [EOL]     if (list.isEmpty()) { [EOL]         return null; [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) { [EOL]     if (s == null || t == null) { [EOL]         throw new IllegalArgumentException("Strings must not be null"); [EOL]     } [EOL]     if (threshold < 0) { [EOL]         throw new IllegalArgumentException("Threshold must not be negative"); [EOL]     } [EOL]     int n = s.length(); [EOL]     int m = t.length(); [EOL]     if (n == 0) { [EOL]         return m <= threshold ? m : -1; [EOL]     } else if (m == 0) { [EOL]         return n <= threshold ? n : -1; [EOL]     } [EOL]     if (n > m) { [EOL]         final CharSequence tmp = s; [EOL]         s = t; [EOL]         t = tmp; [EOL]         n = m; [EOL]         m = t.length(); [EOL]     } [EOL]     int[] p = new int[n + 1]; [EOL]     int[] d = new int[n + 1]; [EOL]     int[] _d; [EOL]     final int boundary = Math.min(n, threshold) + 1; [EOL]     for (int i = 0; i < boundary; i++) { [EOL]         p[i] = i; [EOL]     } [EOL]     Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE); [EOL]     Arrays.fill(d, Integer.MAX_VALUE); [EOL]     for (int j = 1; j <= m; j++) { [EOL]         final char t_j = t.charAt(j - 1); [EOL]         d[0] = j; [EOL]         final int min = Math.max(1, j - threshold); [EOL]         final int max = Math.min(n, j + threshold); [EOL]         if (min > max) { [EOL]             return -1; [EOL]         } [EOL]         if (min > 1) { [EOL]             d[min - 1] = Integer.MAX_VALUE; [EOL]         } [EOL]         for (int i = min; i <= max; i++) { [EOL]             if (s.charAt(i - 1) == t_j) { [EOL]                 d[i] = p[i - 1]; [EOL]             } else { [EOL]                 d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]); [EOL]             } [EOL]         } [EOL]         _d = p; [EOL]         p = d; [EOL]         d = _d; [EOL]     } [EOL]     if (p[n] <= threshold) { [EOL]         return p[n]; [EOL]     } else { [EOL]         return -1; [EOL]     } [EOL] }
private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) { [EOL]     if (str == null || suffix == null) { [EOL]         return str == null && suffix == null; [EOL]     } [EOL]     if (suffix.length() > str.length()) { [EOL]         return false; [EOL]     } [EOL]     final int strOffset = str.length() - suffix.length(); [EOL]     return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length()); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String[] split(final String str, final String separatorChars, final int max) { [EOL]     return splitWorker(str, separatorChars, max, false); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String substring(final String str, int start, int end) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (end < 0) { [EOL]         end = str.length() + end; [EOL]     } [EOL]     if (start < 0) { [EOL]         start = str.length() + start; [EOL]     } [EOL]     if (end > str.length()) { [EOL]         end = str.length(); [EOL]     } [EOL]     if (start > end) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (start < 0) { [EOL]         start = 0; [EOL]     } [EOL]     if (end < 0) { [EOL]         end = 0; [EOL]     } [EOL]     return str.substring(start, end); [EOL] }
public static String substringBetween(final String str, final String open, final String close) { [EOL]     if (str == null || open == null || close == null) { [EOL]         return null; [EOL]     } [EOL]     final int start = str.indexOf(open); [EOL]     if (start != INDEX_NOT_FOUND) { [EOL]         final int end = str.indexOf(close, start + open.length()); [EOL]         if (end != INDEX_NOT_FOUND) { [EOL]             return str.substring(start + open.length(), end); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean isEmpty(final CharSequence cs) { [EOL]     return cs == null || cs.length() == 0; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return false; [EOL]     } [EOL]     return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0; [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String replace(final String text, final String searchString, final String replacement, int max) { [EOL]     if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) { [EOL]         return text; [EOL]     } [EOL]     int start = 0; [EOL]     int end = text.indexOf(searchString, start); [EOL]     if (end == INDEX_NOT_FOUND) { [EOL]         return text; [EOL]     } [EOL]     final int replLength = searchString.length(); [EOL]     int increase = replacement.length() - replLength; [EOL]     increase = increase < 0 ? 0 : increase; [EOL]     increase *= max < 0 ? 16 : max > 64 ? 64 : max; [EOL]     final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL]     while (end != INDEX_NOT_FOUND) { [EOL]         buf.append(text.substring(start, end)).append(replacement); [EOL]         start = end + replLength; [EOL]         if (--max == 0) { [EOL]             break; [EOL]         } [EOL]         end = text.indexOf(searchString, start); [EOL]     } [EOL]     buf.append(text.substring(start)); [EOL]     return buf.toString(); [EOL] }
private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) { [EOL]     if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { [EOL]         return text; [EOL]     } [EOL]     if (timeToLive < 0) { [EOL]         throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another"); [EOL]     } [EOL]     final int searchLength = searchList.length; [EOL]     final int replacementLength = replacementList.length; [EOL]     if (searchLength != replacementLength) { [EOL]         throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength); [EOL]     } [EOL]     final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; [EOL]     int textIndex = -1; [EOL]     int replaceIndex = -1; [EOL]     int tempIndex = -1; [EOL]     for (int i = 0; i < searchLength; i++) { [EOL]         if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         tempIndex = text.indexOf(searchList[i]); [EOL]         if (tempIndex == -1) { [EOL]             noMoreMatchesForReplIndex[i] = true; [EOL]         } else { [EOL]             if (textIndex == -1 || tempIndex < textIndex) { [EOL]                 textIndex = tempIndex; [EOL]                 replaceIndex = i; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (textIndex == -1) { [EOL]         return text; [EOL]     } [EOL]     int start = 0; [EOL]     int increase = 0; [EOL]     for (int i = 0; i < searchList.length; i++) { [EOL]         if (searchList[i] == null || replacementList[i] == null) { [EOL]             continue; [EOL]         } [EOL]         final int greater = replacementList[i].length() - searchList[i].length(); [EOL]         if (greater > 0) { [EOL]             increase += 3 * greater; [EOL]         } [EOL]     } [EOL]     increase = Math.min(increase, text.length() / 5); [EOL]     final StringBuilder buf = new StringBuilder(text.length() + increase); [EOL]     while (textIndex != -1) { [EOL]         for (int i = start; i < textIndex; i++) { [EOL]             buf.append(text.charAt(i)); [EOL]         } [EOL]         buf.append(replacementList[replaceIndex]); [EOL]         start = textIndex + searchList[replaceIndex].length(); [EOL]         textIndex = -1; [EOL]         replaceIndex = -1; [EOL]         tempIndex = -1; [EOL]         for (int i = 0; i < searchLength; i++) { [EOL]             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { [EOL]                 continue; [EOL]             } [EOL]             tempIndex = text.indexOf(searchList[i], start); [EOL]             if (tempIndex == -1) { [EOL]                 noMoreMatchesForReplIndex[i] = true; [EOL]             } else { [EOL]                 if (textIndex == -1 || tempIndex < textIndex) { [EOL]                     textIndex = tempIndex; [EOL]                     replaceIndex = i; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     final int textLength = text.length(); [EOL]     for (int i = start; i < textLength; i++) { [EOL]         buf.append(text.charAt(i)); [EOL]     } [EOL]     final String result = buf.toString(); [EOL]     if (!repeat) { [EOL]         return result; [EOL]     } [EOL]     return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); [EOL] }
public static String replaceEachRepeatedly(final String text, final String[] searchList, final String[] replacementList) { [EOL]     final int timeToLive = searchList == null ? 0 : searchList.length; [EOL]     return replaceEach(text, searchList, replacementList, true, timeToLive); [EOL] }
public static boolean isAlpha(final CharSequence cs) { [EOL]     if (cs == null || cs.length() == 0) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLetter(cs.charAt(i)) == false) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isAlphaSpace(final CharSequence cs) { [EOL]     if (cs == null) { [EOL]         return false; [EOL]     } [EOL]     final int sz = cs.length(); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (Character.isLetter(cs.charAt(i)) == false && cs.charAt(i) != ' ') { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException { [EOL]     return charsetName == null ? new String(bytes) : new String(bytes, charsetName); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static int length(final CharSequence cs) { [EOL]     return cs == null ? 0 : cs.length(); [EOL] }
public static boolean equals(final CharSequence cs1, final CharSequence cs2) { [EOL]     if (cs1 == cs2) { [EOL]         return true; [EOL]     } [EOL]     if (cs1 == null || cs2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (cs1 instanceof String && cs2 instanceof String) { [EOL]         return cs1.equals(cs2); [EOL]     } [EOL]     return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); [EOL] }
public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) { [EOL]     if (seq == null || searchSeq == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos); [EOL] }
public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) { [EOL]     if (str == null || searchStr == null) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (startPos > str.length() - searchStr.length()) { [EOL]         startPos = str.length() - searchStr.length(); [EOL]     } [EOL]     if (startPos < 0) { [EOL]         return INDEX_NOT_FOUND; [EOL]     } [EOL]     if (searchStr.length() == 0) { [EOL]         return startPos; [EOL]     } [EOL]     for (int i = startPos; i >= 0; i--) { [EOL]         if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return INDEX_NOT_FOUND; [EOL] }
public static String substring(final String str, int start, int end) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (end < 0) { [EOL]         end = str.length() + end; [EOL]     } [EOL]     if (start < 0) { [EOL]         start = str.length() + start; [EOL]     } [EOL]     if (end > str.length()) { [EOL]         end = str.length(); [EOL]     } [EOL]     if (start > end) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (start < 0) { [EOL]         start = 0; [EOL]     } [EOL]     if (end < 0) { [EOL]         end = 0; [EOL]     } [EOL]     return str.substring(start, end); [EOL] }
public static String left(final String str, final int len) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (len < 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (str.length() <= len) { [EOL]         return str; [EOL]     } [EOL]     return str.substring(0, len); [EOL] }
public static String right(final String str, final int len) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (len < 0) { [EOL]         return EMPTY; [EOL]     } [EOL]     if (str.length() <= len) { [EOL]         return str; [EOL]     } [EOL]     return str.substring(str.length() - len); [EOL] }
public static String substringBetween(final String str, final String open, final String close) { [EOL]     if (str == null || open == null || close == null) { [EOL]         return null; [EOL]     } [EOL]     final int start = str.indexOf(open); [EOL]     if (start != INDEX_NOT_FOUND) { [EOL]         final int end = str.indexOf(close, start + open.length()); [EOL]         if (end != INDEX_NOT_FOUND) { [EOL]             return str.substring(start + open.length(), end); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public static String[] split(final String str, final String separatorChars, final int max) { [EOL]     return splitWorker(str, separatorChars, max, false); [EOL] }
public static String[] splitByWholeSeparator(final String str, final String separator, final int max) { [EOL]     return splitByWholeSeparatorWorker(str, separator, max, false); [EOL] }
public static String join(final Iterable<?> iterable, final String separator) { [EOL]     if (iterable == null) { [EOL]         return null; [EOL]     } [EOL]     return join(iterable.iterator(), separator); [EOL] }
@Deprecated [EOL] public static String chomp(final String str, final String separator) { [EOL]     return removeEnd(str, separator); [EOL] }
public static String repeat(final char ch, final int repeat) { [EOL]     final char[] buf = new char[repeat]; [EOL]     for (int i = repeat - 1; i >= 0; i--) { [EOL]         buf[i] = ch; [EOL]     } [EOL]     return new String(buf); [EOL] }
public static String rightPad(final String str, final int size, String padStr) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int padLen = padStr.length(); [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (padLen == 1 && pads <= PAD_LIMIT) { [EOL]         return rightPad(str, size, padStr.charAt(0)); [EOL]     } [EOL]     if (pads == padLen) { [EOL]         return str.concat(padStr); [EOL]     } else if (pads < padLen) { [EOL]         return str.concat(padStr.substring(0, pads)); [EOL]     } else { [EOL]         final char[] padding = new char[pads]; [EOL]         final char[] padChars = padStr.toCharArray(); [EOL]         for (int i = 0; i < pads; i++) { [EOL]             padding[i] = padChars[i % padLen]; [EOL]         } [EOL]         return str.concat(new String(padding)); [EOL]     } [EOL] }
public static String leftPad(final String str, final int size, String padStr) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int padLen = padStr.length(); [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (padLen == 1 && pads <= PAD_LIMIT) { [EOL]         return leftPad(str, size, padStr.charAt(0)); [EOL]     } [EOL]     if (pads == padLen) { [EOL]         return padStr.concat(str); [EOL]     } else if (pads < padLen) { [EOL]         return padStr.substring(0, pads).concat(str); [EOL]     } else { [EOL]         final char[] padding = new char[pads]; [EOL]         final char[] padChars = padStr.toCharArray(); [EOL]         for (int i = 0; i < pads; i++) { [EOL]             padding[i] = padChars[i % padLen]; [EOL]         } [EOL]         return new String(padding).concat(str); [EOL]     } [EOL] }
public static String center(String str, final int size, String padStr) { [EOL]     if (str == null || size <= 0) { [EOL]         return str; [EOL]     } [EOL]     if (isEmpty(padStr)) { [EOL]         padStr = SPACE; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     final int pads = size - strLen; [EOL]     if (pads <= 0) { [EOL]         return str; [EOL]     } [EOL]     str = leftPad(str, strLen + pads / 2, padStr); [EOL]     str = rightPad(str, size, padStr); [EOL]     return str; [EOL] }
public static String capitalize(final String str) { [EOL]     int strLen; [EOL]     if (str == null || (strLen = str.length()) == 0) { [EOL]         return str; [EOL]     } [EOL]     return new StringBuilder(strLen).append(Character.toTitleCase(str.charAt(0))).append(str.substring(1)).toString(); [EOL] }
public static String uncapitalize(final String str) { [EOL]     int strLen; [EOL]     if (str == null || (strLen = str.length()) == 0) { [EOL]         return str; [EOL]     } [EOL]     return new StringBuilder(strLen).append(Character.toLowerCase(str.charAt(0))).append(str.substring(1)).toString(); [EOL] }
methods/lang3/CharRange.java
public static CharRange is(final char ch) { [EOL]     return new CharRange(ch, ch, false); [EOL] }
public char getStart() { [EOL]     return this.start; [EOL] }
public char getEnd() { [EOL]     return this.end; [EOL] }
public boolean isNegated() { [EOL]     return negated; [EOL] }
public static CharRange is(final char ch) { [EOL]     return new CharRange(ch, ch, false); [EOL] }
public char getStart() { [EOL]     return this.start; [EOL] }
public char getEnd() { [EOL]     return this.end; [EOL] }
public boolean isNegated() { [EOL]     return negated; [EOL] }
public static CharRange is(final char ch) { [EOL]     return new CharRange(ch, ch, false); [EOL] }
public char getStart() { [EOL]     return this.start; [EOL] }
public char getEnd() { [EOL]     return this.end; [EOL] }
public boolean isNegated() { [EOL]     return negated; [EOL] }
public static CharRange is(final char ch) { [EOL]     return new CharRange(ch, ch, false); [EOL] }
public char getStart() { [EOL]     return this.start; [EOL] }
public char getEnd() { [EOL]     return this.end; [EOL] }
public boolean isNegated() { [EOL]     return negated; [EOL] }
public static CharRange is(final char ch) { [EOL]     return new CharRange(ch, ch, false); [EOL] }
public char getStart() { [EOL]     return this.start; [EOL] }
public char getEnd() { [EOL]     return this.end; [EOL] }
public boolean isNegated() { [EOL]     return negated; [EOL] }
public static CharRange is(final char ch) { [EOL]     return new CharRange(ch, ch, false); [EOL] }
public char getStart() { [EOL]     return this.start; [EOL] }
public char getEnd() { [EOL]     return this.end; [EOL] }
public boolean isNegated() { [EOL]     return negated; [EOL] }
public static CharRange is(final char ch) { [EOL]     return new CharRange(ch, ch, false); [EOL] }
public char getStart() { [EOL]     return this.start; [EOL] }
public char getEnd() { [EOL]     return this.end; [EOL] }
public boolean isNegated() { [EOL]     return negated; [EOL] }
public static CharRange is(final char ch) { [EOL]     return new CharRange(ch, ch, false); [EOL] }
public char getStart() { [EOL]     return this.start; [EOL] }
public char getEnd() { [EOL]     return this.end; [EOL] }
public boolean isNegated() { [EOL]     return negated; [EOL] }
public static CharRange is(final char ch) { [EOL]     return new CharRange(ch, ch, false); [EOL] }
public char getStart() { [EOL]     return this.start; [EOL] }
public char getEnd() { [EOL]     return this.end; [EOL] }
public boolean isNegated() { [EOL]     return negated; [EOL] }
public static CharRange is(final char ch) { [EOL]     return new CharRange(ch, ch, false); [EOL] }
public char getStart() { [EOL]     return this.start; [EOL] }
public char getEnd() { [EOL]     return this.end; [EOL] }
public boolean isNegated() { [EOL]     return negated; [EOL] }
public static CharRange is(final char ch) { [EOL]     return new CharRange(ch, ch, false); [EOL] }
public char getStart() { [EOL]     return this.start; [EOL] }
public char getEnd() { [EOL]     return this.end; [EOL] }
public boolean isNegated() { [EOL]     return negated; [EOL] }
public static CharRange is(final char ch) { [EOL]     return new CharRange(ch, ch, false); [EOL] }
public char getStart() { [EOL]     return this.start; [EOL] }
public char getEnd() { [EOL]     return this.end; [EOL] }
public boolean isNegated() { [EOL]     return negated; [EOL] }
public char getStart() { [EOL]     return this.start; [EOL] }
public char getEnd() { [EOL]     return this.end; [EOL] }
public char getStart() { [EOL]     return this.start; [EOL] }
public char getEnd() { [EOL]     return this.end; [EOL] }
public static CharRange is(final char ch) { [EOL]     return new CharRange(ch, ch, false); [EOL] }
public char getStart() { [EOL]     return this.start; [EOL] }
public char getEnd() { [EOL]     return this.end; [EOL] }
public boolean isNegated() { [EOL]     return negated; [EOL] }
public static CharRange is(final char ch) { [EOL]     return new CharRange(ch, ch, false); [EOL] }
public char getStart() { [EOL]     return this.start; [EOL] }
public char getEnd() { [EOL]     return this.end; [EOL] }
public boolean isNegated() { [EOL]     return negated; [EOL] }
public static CharRange is(final char ch) { [EOL]     return new CharRange(ch, ch, false); [EOL] }
public char getStart() { [EOL]     return this.start; [EOL] }
public char getEnd() { [EOL]     return this.end; [EOL] }
public boolean isNegated() { [EOL]     return negated; [EOL] }
public static CharRange is(final char ch) { [EOL]     return new CharRange(ch, ch, false); [EOL] }
public char getStart() { [EOL]     return this.start; [EOL] }
public char getEnd() { [EOL]     return this.end; [EOL] }
public boolean isNegated() { [EOL]     return negated; [EOL] }
public char getStart() { [EOL]     return this.start; [EOL] }
public char getEnd() { [EOL]     return this.end; [EOL] }
public char getStart() { [EOL]     return this.start; [EOL] }
public char getEnd() { [EOL]     return this.end; [EOL] }
public char getStart() { [EOL]     return this.start; [EOL] }
public char getEnd() { [EOL]     return this.end; [EOL] }
public static CharRange is(final char ch) { [EOL]     return new CharRange(ch, ch, false); [EOL] }
public char getStart() { [EOL]     return this.start; [EOL] }
public boolean isNegated() { [EOL]     return negated; [EOL] }
public char getStart() { [EOL]     return this.start; [EOL] }
public char getEnd() { [EOL]     return this.end; [EOL] }
public static CharRange is(final char ch) { [EOL]     return new CharRange(ch, ch, false); [EOL] }
public char getEnd() { [EOL]     return this.end; [EOL] }
public boolean isNegated() { [EOL]     return negated; [EOL] }
methods/lang3/event/EventListenerSupport.java
methods/lang3/event/EventUtils.java
methods/lang3/reflect/MethodUtils.java
public static Object invokeMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Method method = getMatchingAccessibleMethod(object.getClass(), methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         throw new NoSuchMethodException("No such accessible method: " + methodName + "() on object: " + object.getClass().getName()); [EOL]     } [EOL]     return method.invoke(object, args); [EOL] }
public static Object invokeExactMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Method method = getAccessibleMethod(object.getClass(), methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         throw new NoSuchMethodException("No such accessible method: " + methodName + "() on object: " + object.getClass().getName()); [EOL]     } [EOL]     return method.invoke(object, args); [EOL] }
public static Method getAccessibleMethod(Method method) { [EOL]     if (!MemberUtils.isAccessible(method)) { [EOL]         return null; [EOL]     } [EOL]     final Class<?> cls = method.getDeclaringClass(); [EOL]     if (Modifier.isPublic(cls.getModifiers())) { [EOL]         return method; [EOL]     } [EOL]     final String methodName = method.getName(); [EOL]     final Class<?>[] parameterTypes = method.getParameterTypes(); [EOL]     method = getAccessibleMethodFromInterfaceNest(cls, methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         method = getAccessibleMethodFromSuperclass(cls, methodName, parameterTypes); [EOL]     } [EOL]     return method; [EOL] }
public static Method getAccessibleMethod(Method method) { [EOL]     if (!MemberUtils.isAccessible(method)) { [EOL]         return null; [EOL]     } [EOL]     final Class<?> cls = method.getDeclaringClass(); [EOL]     if (Modifier.isPublic(cls.getModifiers())) { [EOL]         return method; [EOL]     } [EOL]     final String methodName = method.getName(); [EOL]     final Class<?>[] parameterTypes = method.getParameterTypes(); [EOL]     method = getAccessibleMethodFromInterfaceNest(cls, methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         method = getAccessibleMethodFromSuperclass(cls, methodName, parameterTypes); [EOL]     } [EOL]     return method; [EOL] }
public static Method getMatchingAccessibleMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     try { [EOL]         final Method method = cls.getMethod(methodName, parameterTypes); [EOL]         MemberUtils.setAccessibleWorkaround(method); [EOL]         return method; [EOL]     } catch (final NoSuchMethodException e) { [EOL]     } [EOL]     Method bestMatch = null; [EOL]     final Method[] methods = cls.getMethods(); [EOL]     for (final Method method : methods) { [EOL]         if (method.getName().equals(methodName) && ClassUtils.isAssignable(parameterTypes, method.getParameterTypes(), true)) { [EOL]             final Method accessibleMethod = getAccessibleMethod(method); [EOL]             if (accessibleMethod != null && (bestMatch == null || MemberUtils.compareParameterTypes(accessibleMethod.getParameterTypes(), bestMatch.getParameterTypes(), parameterTypes) < 0)) { [EOL]                 bestMatch = accessibleMethod; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (bestMatch != null) { [EOL]         MemberUtils.setAccessibleWorkaround(bestMatch); [EOL]     } [EOL]     return bestMatch; [EOL] }
public static Method getAccessibleMethod(Method method) { [EOL]     if (!MemberUtils.isAccessible(method)) { [EOL]         return null; [EOL]     } [EOL]     final Class<?> cls = method.getDeclaringClass(); [EOL]     if (Modifier.isPublic(cls.getModifiers())) { [EOL]         return method; [EOL]     } [EOL]     final String methodName = method.getName(); [EOL]     final Class<?>[] parameterTypes = method.getParameterTypes(); [EOL]     method = getAccessibleMethodFromInterfaceNest(cls, methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         method = getAccessibleMethodFromSuperclass(cls, methodName, parameterTypes); [EOL]     } [EOL]     return method; [EOL] }
public static Method getMatchingAccessibleMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { [EOL]     try { [EOL]         final Method method = cls.getMethod(methodName, parameterTypes); [EOL]         MemberUtils.setAccessibleWorkaround(method); [EOL]         return method; [EOL]     } catch (final NoSuchMethodException e) { [EOL]     } [EOL]     Method bestMatch = null; [EOL]     final Method[] methods = cls.getMethods(); [EOL]     for (final Method method : methods) { [EOL]         if (method.getName().equals(methodName) && ClassUtils.isAssignable(parameterTypes, method.getParameterTypes(), true)) { [EOL]             final Method accessibleMethod = getAccessibleMethod(method); [EOL]             if (accessibleMethod != null && (bestMatch == null || MemberUtils.compareParameterTypes(accessibleMethod.getParameterTypes(), bestMatch.getParameterTypes(), parameterTypes) < 0)) { [EOL]                 bestMatch = accessibleMethod; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (bestMatch != null) { [EOL]         MemberUtils.setAccessibleWorkaround(bestMatch); [EOL]     } [EOL]     return bestMatch; [EOL] }
public static Method getAccessibleMethod(Method method) { [EOL]     if (!MemberUtils.isAccessible(method)) { [EOL]         return null; [EOL]     } [EOL]     final Class<?> cls = method.getDeclaringClass(); [EOL]     if (Modifier.isPublic(cls.getModifiers())) { [EOL]         return method; [EOL]     } [EOL]     final String methodName = method.getName(); [EOL]     final Class<?>[] parameterTypes = method.getParameterTypes(); [EOL]     method = getAccessibleMethodFromInterfaceNest(cls, methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         method = getAccessibleMethodFromSuperclass(cls, methodName, parameterTypes); [EOL]     } [EOL]     return method; [EOL] }
public static Object invokeExactMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Method method = getAccessibleMethod(object.getClass(), methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         throw new NoSuchMethodException("No such accessible method: " + methodName + "() on object: " + object.getClass().getName()); [EOL]     } [EOL]     return method.invoke(object, args); [EOL] }
public static Object invokeMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Method method = getMatchingAccessibleMethod(object.getClass(), methodName, parameterTypes); [EOL]     if (method == null) { [EOL]         throw new NoSuchMethodException("No such accessible method: " + methodName + "() on object: " + object.getClass().getName()); [EOL]     } [EOL]     return method.invoke(object, args); [EOL] }
methods/lang3/reflect/MemberUtils.java
static int compareParameterTypes(final Class<?>[] left, final Class<?>[] right, final Class<?>[] actual) { [EOL]     final float leftCost = getTotalTransformationCost(actual, left); [EOL]     final float rightCost = getTotalTransformationCost(actual, right); [EOL]     return leftCost < rightCost ? -1 : rightCost < leftCost ? 1 : 0; [EOL] }
static int compareParameterTypes(final Class<?>[] left, final Class<?>[] right, final Class<?>[] actual) { [EOL]     final float leftCost = getTotalTransformationCost(actual, left); [EOL]     final float rightCost = getTotalTransformationCost(actual, right); [EOL]     return leftCost < rightCost ? -1 : rightCost < leftCost ? 1 : 0; [EOL] }
static int compareParameterTypes(final Class<?>[] left, final Class<?>[] right, final Class<?>[] actual) { [EOL]     final float leftCost = getTotalTransformationCost(actual, left); [EOL]     final float rightCost = getTotalTransformationCost(actual, right); [EOL]     return leftCost < rightCost ? -1 : rightCost < leftCost ? 1 : 0; [EOL] }
static boolean isAccessible(final Member m) { [EOL]     return m != null && Modifier.isPublic(m.getModifiers()) && !m.isSynthetic(); [EOL] }
static boolean isAccessible(final Member m) { [EOL]     return m != null && Modifier.isPublic(m.getModifiers()) && !m.isSynthetic(); [EOL] }
static boolean isAccessible(final Member m) { [EOL]     return m != null && Modifier.isPublic(m.getModifiers()) && !m.isSynthetic(); [EOL] }
static boolean isAccessible(final Member m) { [EOL]     return m != null && Modifier.isPublic(m.getModifiers()) && !m.isSynthetic(); [EOL] }
static boolean isPackageAccess(final int modifiers) { [EOL]     return (modifiers & ACCESS_TEST) == 0; [EOL] }
static boolean isPackageAccess(final int modifiers) { [EOL]     return (modifiers & ACCESS_TEST) == 0; [EOL] }
methods/lang3/reflect/TypeUtils.java
public static Type[] normalizeUpperBounds(final Type[] bounds) { [EOL]     if (bounds.length < 2) { [EOL]         return bounds; [EOL]     } [EOL]     final Set<Type> types = new HashSet<Type>(bounds.length); [EOL]     for (final Type type1 : bounds) { [EOL]         boolean subtypeFound = false; [EOL]         for (final Type type2 : bounds) { [EOL]             if (type1 != type2 && isAssignable(type2, type1, null)) { [EOL]                 subtypeFound = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (!subtypeFound) { [EOL]             types.add(type1); [EOL]         } [EOL]     } [EOL]     return types.toArray(new Type[types.size()]); [EOL] }
public static Type[] normalizeUpperBounds(final Type[] bounds) { [EOL]     if (bounds.length < 2) { [EOL]         return bounds; [EOL]     } [EOL]     final Set<Type> types = new HashSet<Type>(bounds.length); [EOL]     for (final Type type1 : bounds) { [EOL]         boolean subtypeFound = false; [EOL]         for (final Type type2 : bounds) { [EOL]             if (type1 != type2 && isAssignable(type2, type1, null)) { [EOL]                 subtypeFound = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (!subtypeFound) { [EOL]             types.add(type1); [EOL]         } [EOL]     } [EOL]     return types.toArray(new Type[types.size()]); [EOL] }
public static Type[] normalizeUpperBounds(final Type[] bounds) { [EOL]     if (bounds.length < 2) { [EOL]         return bounds; [EOL]     } [EOL]     final Set<Type> types = new HashSet<Type>(bounds.length); [EOL]     for (final Type type1 : bounds) { [EOL]         boolean subtypeFound = false; [EOL]         for (final Type type2 : bounds) { [EOL]             if (type1 != type2 && isAssignable(type2, type1, null)) { [EOL]                 subtypeFound = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (!subtypeFound) { [EOL]             types.add(type1); [EOL]         } [EOL]     } [EOL]     return types.toArray(new Type[types.size()]); [EOL] }
public static Type getArrayComponentType(final Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> clazz = (Class<?>) type; [EOL]         return clazz.isArray() ? clazz.getComponentType() : null; [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return ((GenericArrayType) type).getGenericComponentType(); [EOL]     } [EOL]     return null; [EOL] }
public static boolean isArrayType(final Type type) { [EOL]     return type instanceof GenericArrayType || type instanceof Class<?> && ((Class<?>) type).isArray(); [EOL] }
public static boolean isArrayType(final Type type) { [EOL]     return type instanceof GenericArrayType || type instanceof Class<?> && ((Class<?>) type).isArray(); [EOL] }
public static Type[] getImplicitLowerBounds(final WildcardType wildcardType) { [EOL]     final Type[] bounds = wildcardType.getLowerBounds(); [EOL]     return bounds.length == 0 ? new Type[] { null } : bounds; [EOL] }
public static Type[] getImplicitLowerBounds(final WildcardType wildcardType) { [EOL]     final Type[] bounds = wildcardType.getLowerBounds(); [EOL]     return bounds.length == 0 ? new Type[] { null } : bounds; [EOL] }
public static Type[] getImplicitUpperBounds(final WildcardType wildcardType) { [EOL]     final Type[] bounds = wildcardType.getUpperBounds(); [EOL]     return bounds.length == 0 ? new Type[] { Object.class } : normalizeUpperBounds(bounds); [EOL] }
public static boolean isInstance(final Object value, final Type type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     return value == null ? !(type instanceof Class<?>) || !((Class<?>) type).isPrimitive() : isAssignable(value.getClass(), type, null); [EOL] }
public static boolean isInstance(final Object value, final Type type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     return value == null ? !(type instanceof Class<?>) || !((Class<?>) type).isPrimitive() : isAssignable(value.getClass(), type, null); [EOL] }
public static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls, final ParameterizedType superType) { [EOL]     final Class<?> superClass = getRawType(superType); [EOL]     if (!isAssignable(cls, superClass)) { [EOL]         return null; [EOL]     } [EOL]     if (cls.equals(superClass)) { [EOL]         return getTypeArguments(superType, superClass, null); [EOL]     } [EOL]     final Type midType = getClosestParentType(cls, superClass); [EOL]     if (midType instanceof Class<?>) { [EOL]         return determineTypeArguments((Class<?>) midType, superType); [EOL]     } [EOL]     final ParameterizedType midParameterizedType = (ParameterizedType) midType; [EOL]     final Class<?> midClass = getRawType(midParameterizedType); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = determineTypeArguments(midClass, superType); [EOL]     mapTypeVariablesToArguments(cls, midParameterizedType, typeVarAssigns); [EOL]     return typeVarAssigns; [EOL] }
public static Class<?> getRawType(final Type type, final Type assigningType) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getRawType((ParameterizedType) type); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         if (assigningType == null) { [EOL]             return null; [EOL]         } [EOL]         final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration(); [EOL]         if (!(genericDeclaration instanceof Class<?>)) { [EOL]             return null; [EOL]         } [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration); [EOL]         if (typeVarAssigns == null) { [EOL]             return null; [EOL]         } [EOL]         final Type typeArgument = typeVarAssigns.get(type); [EOL]         if (typeArgument == null) { [EOL]             return null; [EOL]         } [EOL]         return getRawType(typeArgument, assigningType); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType); [EOL]         return Array.newInstance(rawComponentType, 0).getClass(); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("unknown type: " + type); [EOL] }
private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL]     if (!isAssignable(cls, toClass)) { [EOL]         return null; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive()) { [EOL]             return new HashMap<TypeVariable<?>, Type>(); [EOL]         } [EOL]         cls = ClassUtils.primitiveToWrapper(cls); [EOL]     } [EOL]     final HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns); [EOL]     if (toClass.equals(cls)) { [EOL]         return typeVarAssigns; [EOL]     } [EOL]     return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns); [EOL] }
public static Class<?> getRawType(final Type type, final Type assigningType) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getRawType((ParameterizedType) type); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         if (assigningType == null) { [EOL]             return null; [EOL]         } [EOL]         final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration(); [EOL]         if (!(genericDeclaration instanceof Class<?>)) { [EOL]             return null; [EOL]         } [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration); [EOL]         if (typeVarAssigns == null) { [EOL]             return null; [EOL]         } [EOL]         final Type typeArgument = typeVarAssigns.get(type); [EOL]         if (typeArgument == null) { [EOL]             return null; [EOL]         } [EOL]         return getRawType(typeArgument, assigningType); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType); [EOL]         return Array.newInstance(rawComponentType, 0).getClass(); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("unknown type: " + type); [EOL] }
private static boolean isAssignable(final Type type, final TypeVariable<?> toTypeVariable, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toTypeVariable == null) { [EOL]         return false; [EOL]     } [EOL]     if (toTypeVariable.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         final Type[] bounds = getImplicitBounds((TypeVariable<?>) type); [EOL]         for (final Type bound : bounds) { [EOL]             if (isAssignable(bound, toTypeVariable, typeVarAssigns)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (type instanceof Class<?> || type instanceof ParameterizedType || type instanceof GenericArrayType || type instanceof WildcardType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] }
public static Type[] getImplicitUpperBounds(final WildcardType wildcardType) { [EOL]     final Type[] bounds = wildcardType.getUpperBounds(); [EOL]     return bounds.length == 0 ? new Type[] { Object.class } : normalizeUpperBounds(bounds); [EOL] }
public static Class<?> getRawType(final Type type, final Type assigningType) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getRawType((ParameterizedType) type); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         if (assigningType == null) { [EOL]             return null; [EOL]         } [EOL]         final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration(); [EOL]         if (!(genericDeclaration instanceof Class<?>)) { [EOL]             return null; [EOL]         } [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration); [EOL]         if (typeVarAssigns == null) { [EOL]             return null; [EOL]         } [EOL]         final Type typeArgument = typeVarAssigns.get(type); [EOL]         if (typeArgument == null) { [EOL]             return null; [EOL]         } [EOL]         return getRawType(typeArgument, assigningType); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType); [EOL]         return Array.newInstance(rawComponentType, 0).getClass(); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("unknown type: " + type); [EOL] }
private static boolean isAssignable(final Type type, final TypeVariable<?> toTypeVariable, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toTypeVariable == null) { [EOL]         return false; [EOL]     } [EOL]     if (toTypeVariable.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         final Type[] bounds = getImplicitBounds((TypeVariable<?>) type); [EOL]         for (final Type bound : bounds) { [EOL]             if (isAssignable(bound, toTypeVariable, typeVarAssigns)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (type instanceof Class<?> || type instanceof ParameterizedType || type instanceof GenericArrayType || type instanceof WildcardType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] }
public static Type[] getImplicitUpperBounds(final WildcardType wildcardType) { [EOL]     final Type[] bounds = wildcardType.getUpperBounds(); [EOL]     return bounds.length == 0 ? new Type[] { Object.class } : normalizeUpperBounds(bounds); [EOL] }
methods/lang3/reflect/ConstructorUtils.java
public static <T> Constructor<T> getMatchingAccessibleConstructor(final Class<T> cls, final Class<?>... parameterTypes) { [EOL]     try { [EOL]         final Constructor<T> ctor = cls.getConstructor(parameterTypes); [EOL]         MemberUtils.setAccessibleWorkaround(ctor); [EOL]         return ctor; [EOL]     } catch (final NoSuchMethodException e) { [EOL]     } [EOL]     Constructor<T> result = null; [EOL]     final Constructor<?>[] ctors = cls.getConstructors(); [EOL]     for (Constructor<?> ctor : ctors) { [EOL]         if (ClassUtils.isAssignable(parameterTypes, ctor.getParameterTypes(), true)) { [EOL]             ctor = getAccessibleConstructor(ctor); [EOL]             if (ctor != null) { [EOL]                 MemberUtils.setAccessibleWorkaround(ctor); [EOL]                 if (result == null || MemberUtils.compareParameterTypes(ctor.getParameterTypes(), result.getParameterTypes(), parameterTypes) < 0) { [EOL]                     @SuppressWarnings("unchecked") [EOL]                     final Constructor<T> constructor = (Constructor<T>) ctor; [EOL]                     result = constructor; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public static <T> Constructor<T> getAccessibleConstructor(final Constructor<T> ctor) { [EOL]     return MemberUtils.isAccessible(ctor) && Modifier.isPublic(ctor.getDeclaringClass().getModifiers()) ? ctor : null; [EOL] }
public static <T> Constructor<T> getMatchingAccessibleConstructor(final Class<T> cls, final Class<?>... parameterTypes) { [EOL]     try { [EOL]         final Constructor<T> ctor = cls.getConstructor(parameterTypes); [EOL]         MemberUtils.setAccessibleWorkaround(ctor); [EOL]         return ctor; [EOL]     } catch (final NoSuchMethodException e) { [EOL]     } [EOL]     Constructor<T> result = null; [EOL]     final Constructor<?>[] ctors = cls.getConstructors(); [EOL]     for (Constructor<?> ctor : ctors) { [EOL]         if (ClassUtils.isAssignable(parameterTypes, ctor.getParameterTypes(), true)) { [EOL]             ctor = getAccessibleConstructor(ctor); [EOL]             if (ctor != null) { [EOL]                 MemberUtils.setAccessibleWorkaround(ctor); [EOL]                 if (result == null || MemberUtils.compareParameterTypes(ctor.getParameterTypes(), result.getParameterTypes(), parameterTypes) < 0) { [EOL]                     @SuppressWarnings("unchecked") [EOL]                     final Constructor<T> constructor = (Constructor<T>) ctor; [EOL]                     result = constructor; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public static <T> Constructor<T> getAccessibleConstructor(final Constructor<T> ctor) { [EOL]     return MemberUtils.isAccessible(ctor) && Modifier.isPublic(ctor.getDeclaringClass().getModifiers()) ? ctor : null; [EOL] }
public static <T> Constructor<T> getAccessibleConstructor(final Constructor<T> ctor) { [EOL]     return MemberUtils.isAccessible(ctor) && Modifier.isPublic(ctor.getDeclaringClass().getModifiers()) ? ctor : null; [EOL] }
public static <T> Constructor<T> getAccessibleConstructor(final Constructor<T> ctor) { [EOL]     return MemberUtils.isAccessible(ctor) && Modifier.isPublic(ctor.getDeclaringClass().getModifiers()) ? ctor : null; [EOL] }
public static <T> Constructor<T> getMatchingAccessibleConstructor(final Class<T> cls, final Class<?>... parameterTypes) { [EOL]     try { [EOL]         final Constructor<T> ctor = cls.getConstructor(parameterTypes); [EOL]         MemberUtils.setAccessibleWorkaround(ctor); [EOL]         return ctor; [EOL]     } catch (final NoSuchMethodException e) { [EOL]     } [EOL]     Constructor<T> result = null; [EOL]     final Constructor<?>[] ctors = cls.getConstructors(); [EOL]     for (Constructor<?> ctor : ctors) { [EOL]         if (ClassUtils.isAssignable(parameterTypes, ctor.getParameterTypes(), true)) { [EOL]             ctor = getAccessibleConstructor(ctor); [EOL]             if (ctor != null) { [EOL]                 MemberUtils.setAccessibleWorkaround(ctor); [EOL]                 if (result == null || MemberUtils.compareParameterTypes(ctor.getParameterTypes(), result.getParameterTypes(), parameterTypes) < 0) { [EOL]                     @SuppressWarnings("unchecked") [EOL]                     final Constructor<T> constructor = (Constructor<T>) ctor; [EOL]                     result = constructor; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
public static <T> T invokeExactConstructor(final Class<T> cls, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Constructor<T> ctor = getAccessibleConstructor(cls, parameterTypes); [EOL]     if (ctor == null) { [EOL]         throw new NoSuchMethodException("No such accessible constructor on object: " + cls.getName()); [EOL]     } [EOL]     return ctor.newInstance(args); [EOL] }
public static <T> Constructor<T> getAccessibleConstructor(final Constructor<T> ctor) { [EOL]     return MemberUtils.isAccessible(ctor) && Modifier.isPublic(ctor.getDeclaringClass().getModifiers()) ? ctor : null; [EOL] }
public static <T> T invokeExactConstructor(final Class<T> cls, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     final Constructor<T> ctor = getAccessibleConstructor(cls, parameterTypes); [EOL]     if (ctor == null) { [EOL]         throw new NoSuchMethodException("No such accessible constructor on object: " + cls.getName()); [EOL]     } [EOL]     return ctor.newInstance(args); [EOL] }
public static <T> T invokeConstructor(final Class<T> cls, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Constructor<T> ctor = getMatchingAccessibleConstructor(cls, parameterTypes); [EOL]     if (ctor == null) { [EOL]         throw new NoSuchMethodException("No such accessible constructor on object: " + cls.getName()); [EOL]     } [EOL]     return ctor.newInstance(args); [EOL] }
public static <T> T invokeConstructor(final Class<T> cls, Object[] args, Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { [EOL]     if (parameterTypes == null) { [EOL]         parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY; [EOL]     } [EOL]     if (args == null) { [EOL]         args = ArrayUtils.EMPTY_OBJECT_ARRAY; [EOL]     } [EOL]     final Constructor<T> ctor = getMatchingAccessibleConstructor(cls, parameterTypes); [EOL]     if (ctor == null) { [EOL]         throw new NoSuchMethodException("No such accessible constructor on object: " + cls.getName()); [EOL]     } [EOL]     return ctor.newInstance(args); [EOL] }
methods/lang3/reflect/FieldUtils.java
public static Field[] getAllFields(Class<?> cls) { [EOL]     final List<Field> allFieldsList = getAllFieldsList(cls); [EOL]     return allFieldsList.toArray(new Field[allFieldsList.size()]); [EOL] }
public static List<Field> getAllFieldsList(Class<?> cls) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     List<Field> allFields = new ArrayList<Field>(); [EOL]     Class<?> currentClass = cls; [EOL]     while (currentClass != null) { [EOL]         final Field[] declaredFields = currentClass.getDeclaredFields(); [EOL]         for (Field field : declaredFields) { [EOL]             allFields.add(field); [EOL]         } [EOL]         currentClass = currentClass.getSuperclass(); [EOL]     } [EOL]     return allFields; [EOL] }
public static Field[] getAllFields(Class<?> cls) { [EOL]     final List<Field> allFieldsList = getAllFieldsList(cls); [EOL]     return allFieldsList.toArray(new Field[allFieldsList.size()]); [EOL] }
public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     try { [EOL]         final Field field = cls.getDeclaredField(fieldName); [EOL]         if (!MemberUtils.isAccessible(field)) { [EOL]             if (forceAccess) { [EOL]                 field.setAccessible(true); [EOL]             } else { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return field; [EOL]     } catch (final NoSuchFieldException e) { [EOL]     } [EOL]     return null; [EOL] }
public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] }
public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) { [EOL]         try { [EOL]             final Field field = acls.getDeclaredField(fieldName); [EOL]             if (!Modifier.isPublic(field.getModifiers())) { [EOL]                 if (forceAccess) { [EOL]                     field.setAccessible(true); [EOL]                 } else { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             return field; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     Field match = null; [EOL]     for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) { [EOL]         try { [EOL]             final Field test = ((Class<?>) class1).getField(fieldName); [EOL]             if (match != null) { [EOL]                 throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls + "; a matching field exists on two or more implemented interfaces."); [EOL]             } [EOL]             match = test; [EOL]         } catch (final NoSuchFieldException ex) { [EOL]         } [EOL]     } [EOL]     return match; [EOL] }
public static Field[] getAllFields(Class<?> cls) { [EOL]     final List<Field> allFieldsList = getAllFieldsList(cls); [EOL]     return allFieldsList.toArray(new Field[allFieldsList.size()]); [EOL] }
public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) { [EOL]     if (cls == null) { [EOL]         throw new IllegalArgumentException("The class must not be null"); [EOL]     } [EOL]     if (fieldName == null) { [EOL]         throw new IllegalArgumentException("The field name must not be null"); [EOL]     } [EOL]     try { [EOL]         final Field field = cls.getDeclaredField(fieldName); [EOL]         if (!MemberUtils.isAccessible(field)) { [EOL]             if (forceAccess) { [EOL]                 field.setAccessible(true); [EOL]             } else { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return field; [EOL]     } catch (final NoSuchFieldException e) { [EOL]     } [EOL]     return null; [EOL] }
methods/lang3/math/Fraction.java
@Override [EOL] public int compareTo(final Fraction other) { [EOL]     if (this == other) { [EOL]         return 0; [EOL]     } [EOL]     if (numerator == other.numerator && denominator == other.denominator) { [EOL]         return 0; [EOL]     } [EOL]     final long first = (long) numerator * (long) other.denominator; [EOL]     final long second = (long) other.numerator * (long) denominator; [EOL]     if (first == second) { [EOL]         return 0; [EOL]     } else if (first < second) { [EOL]         return -1; [EOL]     } else { [EOL]         return 1; [EOL]     } [EOL] }

public int getNumerator() { [EOL]     return numerator; [EOL] }
public int getDenominator() { [EOL]     return denominator; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) numerator / (float) denominator; [EOL] }
public int getNumerator() { [EOL]     return numerator; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return (double) numerator / (double) denominator; [EOL] }
public int getNumerator() { [EOL]     return numerator; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) numerator / (float) denominator; [EOL] }
public int getNumerator() { [EOL]     return numerator; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return (double) numerator / (double) denominator; [EOL] }
public static Fraction getFraction(String str) { [EOL]     if (str == null) { [EOL]         throw new IllegalArgumentException("The string must not be null"); [EOL]     } [EOL]     int pos = str.indexOf('.'); [EOL]     if (pos >= 0) { [EOL]         return getFraction(Double.parseDouble(str)); [EOL]     } [EOL]     pos = str.indexOf(' '); [EOL]     if (pos > 0) { [EOL]         final int whole = Integer.parseInt(str.substring(0, pos)); [EOL]         str = str.substring(pos + 1); [EOL]         pos = str.indexOf('/'); [EOL]         if (pos < 0) { [EOL]             throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z"); [EOL]         } else { [EOL]             final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]             final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]             return getFraction(whole, numer, denom); [EOL]         } [EOL]     } [EOL]     pos = str.indexOf('/'); [EOL]     if (pos < 0) { [EOL]         return getFraction(Integer.parseInt(str), 1); [EOL]     } else { [EOL]         final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]         final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]         return getFraction(numer, denom); [EOL]     } [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return (double) numerator / (double) denominator; [EOL] }
public Fraction subtract(final Fraction fraction) { [EOL]     return addSub(fraction, false); [EOL] }

public int getDenominator() { [EOL]     return denominator; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return (double) numerator / (double) denominator; [EOL] }
public static Fraction getReducedFraction(int numerator, int denominator) { [EOL]     if (denominator == 0) { [EOL]         throw new ArithmeticException("The denominator must not be zero"); [EOL]     } [EOL]     if (numerator == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) { [EOL]         numerator /= 2; [EOL]         denominator /= 2; [EOL]     } [EOL]     if (denominator < 0) { [EOL]         if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) { [EOL]             throw new ArithmeticException("overflow: can't negate"); [EOL]         } [EOL]         numerator = -numerator; [EOL]         denominator = -denominator; [EOL]     } [EOL]     final int gcd = greatestCommonDivisor(numerator, denominator); [EOL]     numerator /= gcd; [EOL]     denominator /= gcd; [EOL]     return new Fraction(numerator, denominator); [EOL] }
public Fraction pow(final int power) { [EOL]     if (power == 1) { [EOL]         return this; [EOL]     } else if (power == 0) { [EOL]         return ONE; [EOL]     } else if (power < 0) { [EOL]         if (power == Integer.MIN_VALUE) { [EOL]             return this.invert().pow(2).pow(-(power / 2)); [EOL]         } [EOL]         return this.invert().pow(-power); [EOL]     } else { [EOL]         final Fraction f = this.multiplyBy(this); [EOL]         if (power % 2 == 0) { [EOL]             return f.pow(power / 2); [EOL]         } else { [EOL]             return f.pow(power / 2).multiplyBy(this); [EOL]         } [EOL]     } [EOL] }

public int getNumerator() { [EOL]     return numerator; [EOL] }
public int getDenominator() { [EOL]     return denominator; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return (double) numerator / (double) denominator; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return (double) numerator / (double) denominator; [EOL] }
public Fraction negate() { [EOL]     if (numerator == Integer.MIN_VALUE) { [EOL]         throw new ArithmeticException("overflow: too large to negate"); [EOL]     } [EOL]     return new Fraction(-numerator, denominator); [EOL] }

@Override [EOL] public long longValue() { [EOL]     return (long) numerator / denominator; [EOL] }
public Fraction multiplyBy(final Fraction fraction) { [EOL]     if (fraction == null) { [EOL]         throw new IllegalArgumentException("The fraction must not be null"); [EOL]     } [EOL]     if (numerator == 0 || fraction.numerator == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     final int d1 = greatestCommonDivisor(numerator, fraction.denominator); [EOL]     final int d2 = greatestCommonDivisor(fraction.numerator, denominator); [EOL]     return getReducedFraction(mulAndCheck(numerator / d1, fraction.numerator / d2), mulPosAndCheck(denominator / d2, fraction.denominator / d1)); [EOL] }

@Override [EOL] public double doubleValue() { [EOL]     return (double) numerator / (double) denominator; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Fraction == false) { [EOL]         return false; [EOL]     } [EOL]     final Fraction other = (Fraction) obj; [EOL]     return getNumerator() == other.getNumerator() && getDenominator() == other.getDenominator(); [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) numerator / denominator; [EOL] }

public int getDenominator() { [EOL]     return denominator; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) numerator / (float) denominator; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return numerator / denominator; [EOL] }

public int getDenominator() { [EOL]     return denominator; [EOL] }
public int getProperWhole() { [EOL]     return numerator / denominator; [EOL] }

public int getDenominator() { [EOL]     return denominator; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) numerator / (float) denominator; [EOL] }
public int getProperNumerator() { [EOL]     return Math.abs(numerator % denominator); [EOL] }

public int getNumerator() { [EOL]     return numerator; [EOL] }

@Override [EOL] public double doubleValue() { [EOL]     return (double) numerator / (double) denominator; [EOL] }
public int getDenominator() { [EOL]     return denominator; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) numerator / (float) denominator; [EOL] }
public int getNumerator() { [EOL]     return numerator; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) numerator / (float) denominator; [EOL] }
public int getDenominator() { [EOL]     return denominator; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) numerator / (float) denominator; [EOL] }
public static Fraction getFraction(String str) { [EOL]     if (str == null) { [EOL]         throw new IllegalArgumentException("The string must not be null"); [EOL]     } [EOL]     int pos = str.indexOf('.'); [EOL]     if (pos >= 0) { [EOL]         return getFraction(Double.parseDouble(str)); [EOL]     } [EOL]     pos = str.indexOf(' '); [EOL]     if (pos > 0) { [EOL]         final int whole = Integer.parseInt(str.substring(0, pos)); [EOL]         str = str.substring(pos + 1); [EOL]         pos = str.indexOf('/'); [EOL]         if (pos < 0) { [EOL]             throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z"); [EOL]         } else { [EOL]             final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]             final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]             return getFraction(whole, numer, denom); [EOL]         } [EOL]     } [EOL]     pos = str.indexOf('/'); [EOL]     if (pos < 0) { [EOL]         return getFraction(Integer.parseInt(str), 1); [EOL]     } else { [EOL]         final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]         final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]         return getFraction(numer, denom); [EOL]     } [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) numerator / (float) denominator; [EOL] }

@Override [EOL] public float floatValue() { [EOL]     return (float) numerator / (float) denominator; [EOL] }
public Fraction negate() { [EOL]     if (numerator == Integer.MIN_VALUE) { [EOL]         throw new ArithmeticException("overflow: too large to negate"); [EOL]     } [EOL]     return new Fraction(-numerator, denominator); [EOL] }

@Override [EOL] public double doubleValue() { [EOL]     return (double) numerator / (double) denominator; [EOL] }

@Override [EOL] public double doubleValue() { [EOL]     return (double) numerator / (double) denominator; [EOL] }
public Fraction negate() { [EOL]     if (numerator == Integer.MIN_VALUE) { [EOL]         throw new ArithmeticException("overflow: too large to negate"); [EOL]     } [EOL]     return new Fraction(-numerator, denominator); [EOL] }

public int getDenominator() { [EOL]     return denominator; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) numerator / (float) denominator; [EOL] }
public int getDenominator() { [EOL]     return denominator; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) numerator / (float) denominator; [EOL] }
public static Fraction getFraction(String str) { [EOL]     if (str == null) { [EOL]         throw new IllegalArgumentException("The string must not be null"); [EOL]     } [EOL]     int pos = str.indexOf('.'); [EOL]     if (pos >= 0) { [EOL]         return getFraction(Double.parseDouble(str)); [EOL]     } [EOL]     pos = str.indexOf(' '); [EOL]     if (pos > 0) { [EOL]         final int whole = Integer.parseInt(str.substring(0, pos)); [EOL]         str = str.substring(pos + 1); [EOL]         pos = str.indexOf('/'); [EOL]         if (pos < 0) { [EOL]             throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z"); [EOL]         } else { [EOL]             final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]             final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]             return getFraction(whole, numer, denom); [EOL]         } [EOL]     } [EOL]     pos = str.indexOf('/'); [EOL]     if (pos < 0) { [EOL]         return getFraction(Integer.parseInt(str), 1); [EOL]     } else { [EOL]         final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]         final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]         return getFraction(numer, denom); [EOL]     } [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) numerator / (float) denominator; [EOL] }
public Fraction add(final Fraction fraction) { [EOL]     return addSub(fraction, true); [EOL] }

public Fraction abs() { [EOL]     if (numerator >= 0) { [EOL]         return this; [EOL]     } [EOL]     return negate(); [EOL] }

public int getNumerator() { [EOL]     return numerator; [EOL] }
public int getDenominator() { [EOL]     return denominator; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return (double) numerator / (double) denominator; [EOL] }
public int getNumerator() { [EOL]     return numerator; [EOL] }
public int getDenominator() { [EOL]     return denominator; [EOL] }
public int getDenominator() { [EOL]     return denominator; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) numerator / (float) denominator; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return (double) numerator / (double) denominator; [EOL] }
public int getNumerator() { [EOL]     return numerator; [EOL] }
public Fraction multiplyBy(final Fraction fraction) { [EOL]     if (fraction == null) { [EOL]         throw new IllegalArgumentException("The fraction must not be null"); [EOL]     } [EOL]     if (numerator == 0 || fraction.numerator == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     final int d1 = greatestCommonDivisor(numerator, fraction.denominator); [EOL]     final int d2 = greatestCommonDivisor(fraction.numerator, denominator); [EOL]     return getReducedFraction(mulAndCheck(numerator / d1, fraction.numerator / d2), mulPosAndCheck(denominator / d2, fraction.denominator / d1)); [EOL] }

public Fraction pow(final int power) { [EOL]     if (power == 1) { [EOL]         return this; [EOL]     } else if (power == 0) { [EOL]         return ONE; [EOL]     } else if (power < 0) { [EOL]         if (power == Integer.MIN_VALUE) { [EOL]             return this.invert().pow(2).pow(-(power / 2)); [EOL]         } [EOL]         return this.invert().pow(-power); [EOL]     } else { [EOL]         final Fraction f = this.multiplyBy(this); [EOL]         if (power % 2 == 0) { [EOL]             return f.pow(power / 2); [EOL]         } else { [EOL]             return f.pow(power / 2).multiplyBy(this); [EOL]         } [EOL]     } [EOL] }

public int getProperNumerator() { [EOL]     return Math.abs(numerator % denominator); [EOL] }

public int getNumerator() { [EOL]     return numerator; [EOL] }

public int getProperWhole() { [EOL]     return numerator / denominator; [EOL] }

@Override [EOL] public float floatValue() { [EOL]     return (float) numerator / (float) denominator; [EOL] }
public int getDenominator() { [EOL]     return denominator; [EOL] }
public int getNumerator() { [EOL]     return numerator; [EOL] }
public int getNumerator() { [EOL]     return numerator; [EOL] }
public int getDenominator() { [EOL]     return denominator; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return (double) numerator / (double) denominator; [EOL] }
@Override [EOL] public int compareTo(final Fraction other) { [EOL]     if (this == other) { [EOL]         return 0; [EOL]     } [EOL]     if (numerator == other.numerator && denominator == other.denominator) { [EOL]         return 0; [EOL]     } [EOL]     final long first = (long) numerator * (long) other.denominator; [EOL]     final long second = (long) other.numerator * (long) denominator; [EOL]     if (first == second) { [EOL]         return 0; [EOL]     } else if (first < second) { [EOL]         return -1; [EOL]     } else { [EOL]         return 1; [EOL]     } [EOL] }

public int getProperNumerator() { [EOL]     return Math.abs(numerator % denominator); [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return (double) numerator / (double) denominator; [EOL] }
public int getNumerator() { [EOL]     return numerator; [EOL] }
@Override [EOL] public int compareTo(final Fraction other) { [EOL]     if (this == other) { [EOL]         return 0; [EOL]     } [EOL]     if (numerator == other.numerator && denominator == other.denominator) { [EOL]         return 0; [EOL]     } [EOL]     final long first = (long) numerator * (long) other.denominator; [EOL]     final long second = (long) other.numerator * (long) denominator; [EOL]     if (first == second) { [EOL]         return 0; [EOL]     } else if (first < second) { [EOL]         return -1; [EOL]     } else { [EOL]         return 1; [EOL]     } [EOL] }

public int getNumerator() { [EOL]     return numerator; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Fraction == false) { [EOL]         return false; [EOL]     } [EOL]     final Fraction other = (Fraction) obj; [EOL]     return getNumerator() == other.getNumerator() && getDenominator() == other.getDenominator(); [EOL] }

public int getDenominator() { [EOL]     return denominator; [EOL] }
public int getProperNumerator() { [EOL]     return Math.abs(numerator % denominator); [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) numerator / (float) denominator; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) numerator / (float) denominator; [EOL] }
public Fraction divideBy(final Fraction fraction) { [EOL]     if (fraction == null) { [EOL]         throw new IllegalArgumentException("The fraction must not be null"); [EOL]     } [EOL]     if (fraction.numerator == 0) { [EOL]         throw new ArithmeticException("The fraction to divide by must not be zero"); [EOL]     } [EOL]     return multiplyBy(fraction.invert()); [EOL] }

public int getNumerator() { [EOL]     return numerator; [EOL] }
public int getDenominator() { [EOL]     return denominator; [EOL] }
public int getDenominator() { [EOL]     return denominator; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return (double) numerator / (double) denominator; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Fraction == false) { [EOL]         return false; [EOL]     } [EOL]     final Fraction other = (Fraction) obj; [EOL]     return getNumerator() == other.getNumerator() && getDenominator() == other.getDenominator(); [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) numerator / (float) denominator; [EOL] }
public Fraction pow(final int power) { [EOL]     if (power == 1) { [EOL]         return this; [EOL]     } else if (power == 0) { [EOL]         return ONE; [EOL]     } else if (power < 0) { [EOL]         if (power == Integer.MIN_VALUE) { [EOL]             return this.invert().pow(2).pow(-(power / 2)); [EOL]         } [EOL]         return this.invert().pow(-power); [EOL]     } else { [EOL]         final Fraction f = this.multiplyBy(this); [EOL]         if (power % 2 == 0) { [EOL]             return f.pow(power / 2); [EOL]         } else { [EOL]             return f.pow(power / 2).multiplyBy(this); [EOL]         } [EOL]     } [EOL] }

public int getProperWhole() { [EOL]     return numerator / denominator; [EOL] }
public Fraction pow(final int power) { [EOL]     if (power == 1) { [EOL]         return this; [EOL]     } else if (power == 0) { [EOL]         return ONE; [EOL]     } else if (power < 0) { [EOL]         if (power == Integer.MIN_VALUE) { [EOL]             return this.invert().pow(2).pow(-(power / 2)); [EOL]         } [EOL]         return this.invert().pow(-power); [EOL]     } else { [EOL]         final Fraction f = this.multiplyBy(this); [EOL]         if (power % 2 == 0) { [EOL]             return f.pow(power / 2); [EOL]         } else { [EOL]             return f.pow(power / 2).multiplyBy(this); [EOL]         } [EOL]     } [EOL] }

public int getNumerator() { [EOL]     return numerator; [EOL] }
public int getProperWhole() { [EOL]     return numerator / denominator; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return (double) numerator / (double) denominator; [EOL] }
public int getDenominator() { [EOL]     return denominator; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return (double) numerator / (double) denominator; [EOL] }
public int getNumerator() { [EOL]     return numerator; [EOL] }
public int getNumerator() { [EOL]     return numerator; [EOL] }
public int getDenominator() { [EOL]     return denominator; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) numerator / (float) denominator; [EOL] }
public int getDenominator() { [EOL]     return denominator; [EOL] }
public static Fraction getFraction(String str) { [EOL]     if (str == null) { [EOL]         throw new IllegalArgumentException("The string must not be null"); [EOL]     } [EOL]     int pos = str.indexOf('.'); [EOL]     if (pos >= 0) { [EOL]         return getFraction(Double.parseDouble(str)); [EOL]     } [EOL]     pos = str.indexOf(' '); [EOL]     if (pos > 0) { [EOL]         final int whole = Integer.parseInt(str.substring(0, pos)); [EOL]         str = str.substring(pos + 1); [EOL]         pos = str.indexOf('/'); [EOL]         if (pos < 0) { [EOL]             throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z"); [EOL]         } else { [EOL]             final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]             final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]             return getFraction(whole, numer, denom); [EOL]         } [EOL]     } [EOL]     pos = str.indexOf('/'); [EOL]     if (pos < 0) { [EOL]         return getFraction(Integer.parseInt(str), 1); [EOL]     } else { [EOL]         final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]         final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]         return getFraction(numer, denom); [EOL]     } [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return (double) numerator / (double) denominator; [EOL] }

public static Fraction getFraction(String str) { [EOL]     if (str == null) { [EOL]         throw new IllegalArgumentException("The string must not be null"); [EOL]     } [EOL]     int pos = str.indexOf('.'); [EOL]     if (pos >= 0) { [EOL]         return getFraction(Double.parseDouble(str)); [EOL]     } [EOL]     pos = str.indexOf(' '); [EOL]     if (pos > 0) { [EOL]         final int whole = Integer.parseInt(str.substring(0, pos)); [EOL]         str = str.substring(pos + 1); [EOL]         pos = str.indexOf('/'); [EOL]         if (pos < 0) { [EOL]             throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z"); [EOL]         } else { [EOL]             final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]             final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]             return getFraction(whole, numer, denom); [EOL]         } [EOL]     } [EOL]     pos = str.indexOf('/'); [EOL]     if (pos < 0) { [EOL]         return getFraction(Integer.parseInt(str), 1); [EOL]     } else { [EOL]         final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]         final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]         return getFraction(numer, denom); [EOL]     } [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return (double) numerator / (double) denominator; [EOL] }

public int getDenominator() { [EOL]     return denominator; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return (double) numerator / (double) denominator; [EOL] }
public static Fraction getFraction(String str) { [EOL]     if (str == null) { [EOL]         throw new IllegalArgumentException("The string must not be null"); [EOL]     } [EOL]     int pos = str.indexOf('.'); [EOL]     if (pos >= 0) { [EOL]         return getFraction(Double.parseDouble(str)); [EOL]     } [EOL]     pos = str.indexOf(' '); [EOL]     if (pos > 0) { [EOL]         final int whole = Integer.parseInt(str.substring(0, pos)); [EOL]         str = str.substring(pos + 1); [EOL]         pos = str.indexOf('/'); [EOL]         if (pos < 0) { [EOL]             throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z"); [EOL]         } else { [EOL]             final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]             final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]             return getFraction(whole, numer, denom); [EOL]         } [EOL]     } [EOL]     pos = str.indexOf('/'); [EOL]     if (pos < 0) { [EOL]         return getFraction(Integer.parseInt(str), 1); [EOL]     } else { [EOL]         final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]         final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]         return getFraction(numer, denom); [EOL]     } [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) numerator / (float) denominator; [EOL] }

public int getNumerator() { [EOL]     return numerator; [EOL] }
public int getDenominator() { [EOL]     return denominator; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Fraction == false) { [EOL]         return false; [EOL]     } [EOL]     final Fraction other = (Fraction) obj; [EOL]     return getNumerator() == other.getNumerator() && getDenominator() == other.getDenominator(); [EOL] }
public int getDenominator() { [EOL]     return denominator; [EOL] }
public static Fraction getFraction(String str) { [EOL]     if (str == null) { [EOL]         throw new IllegalArgumentException("The string must not be null"); [EOL]     } [EOL]     int pos = str.indexOf('.'); [EOL]     if (pos >= 0) { [EOL]         return getFraction(Double.parseDouble(str)); [EOL]     } [EOL]     pos = str.indexOf(' '); [EOL]     if (pos > 0) { [EOL]         final int whole = Integer.parseInt(str.substring(0, pos)); [EOL]         str = str.substring(pos + 1); [EOL]         pos = str.indexOf('/'); [EOL]         if (pos < 0) { [EOL]             throw new NumberFormatException("The fraction could not be parsed as the format X Y/Z"); [EOL]         } else { [EOL]             final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]             final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]             return getFraction(whole, numer, denom); [EOL]         } [EOL]     } [EOL]     pos = str.indexOf('/'); [EOL]     if (pos < 0) { [EOL]         return getFraction(Integer.parseInt(str), 1); [EOL]     } else { [EOL]         final int numer = Integer.parseInt(str.substring(0, pos)); [EOL]         final int denom = Integer.parseInt(str.substring(pos + 1)); [EOL]         return getFraction(numer, denom); [EOL]     } [EOL] }
public String toProperString() { [EOL]     if (toProperString == null) { [EOL]         if (numerator == 0) { [EOL]             toProperString = "0"; [EOL]         } else if (numerator == denominator) { [EOL]             toProperString = "1"; [EOL]         } else if (numerator == -1 * denominator) { [EOL]             toProperString = "-1"; [EOL]         } else if ((numerator > 0 ? -numerator : numerator) < -denominator) { [EOL]             final int properNumerator = getProperNumerator(); [EOL]             if (properNumerator == 0) { [EOL]                 toProperString = Integer.toString(getProperWhole()); [EOL]             } else { [EOL]                 toProperString = new StringBuilder(32).append(getProperWhole()).append(' ').append(properNumerator).append('/').append(getDenominator()).toString(); [EOL]             } [EOL]         } else { [EOL]             toProperString = new StringBuilder(32).append(getNumerator()).append('/').append(getDenominator()).toString(); [EOL]         } [EOL]     } [EOL]     return toProperString; [EOL] }

public int getNumerator() { [EOL]     return numerator; [EOL] }
public int getDenominator() { [EOL]     return denominator; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return numerator / denominator; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) numerator / (float) denominator; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Fraction == false) { [EOL]         return false; [EOL]     } [EOL]     final Fraction other = (Fraction) obj; [EOL]     return getNumerator() == other.getNumerator() && getDenominator() == other.getDenominator(); [EOL] }
public int getNumerator() { [EOL]     return numerator; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) numerator / (float) denominator; [EOL] }
methods/lang3/math/NumberUtils.java
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static short toShort(final String str, final short defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Short.parseShort(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static long toLong(final String str, final long defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Long.parseLong(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static long toLong(final String str, final long defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Long.parseLong(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static int toInt(final String str, final int defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Integer.parseInt(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static int toInt(final String str, final int defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Integer.parseInt(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static int toInt(final String str, final int defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Integer.parseInt(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static float toFloat(final String str, final float defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Float.parseFloat(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static double toDouble(final String str, final double defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Double.parseDouble(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static double toDouble(final String str, final double defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Double.parseDouble(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static double toDouble(final String str, final double defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Double.parseDouble(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static byte toByte(final String str, final byte defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Byte.parseByte(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static byte toByte(final String str, final byte defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Byte.parseByte(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         final Float f = createFloat(str); [EOL]         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]             return f; [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         final Double d = createDouble(str); [EOL]         if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]             return d; [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] }
public static Long createLong(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return Long.decode(str); [EOL] }
public static Integer createInteger(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return Integer.decode(str); [EOL] }
public static Integer createInteger(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return Integer.decode(str); [EOL] }
public static Float createFloat(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return Float.valueOf(str); [EOL] }
public static BigDecimal createBigDecimal(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     if (str.trim().startsWith("--")) { [EOL]         throw new NumberFormatException(str + " is not a valid number."); [EOL]     } [EOL]     return new BigDecimal(str); [EOL] }
public static boolean isDigits(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < str.length(); i++) { [EOL]         if (!Character.isDigit(str.charAt(i))) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static Long createLong(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return Long.decode(str); [EOL] }
public static Float createFloat(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return Float.valueOf(str); [EOL] }
public static short toShort(final String str, final short defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Short.parseShort(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static short toShort(final String str, final short defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Short.parseShort(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static byte toByte(final String str, final byte defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Byte.parseByte(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static byte toByte(final String str, final byte defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Byte.parseByte(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static double toDouble(final String str, final double defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Double.parseDouble(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static float toFloat(final String str, final float defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Float.parseFloat(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static float toFloat(final String str, final float defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Float.parseFloat(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static long toLong(final String str, final long defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Long.parseLong(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static int toInt(final String str, final int defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Integer.parseInt(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static int toInt(final String str, final int defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Integer.parseInt(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] }
public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] }
public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] }
public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] }
public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] }
public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] }
public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] }
public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] }
public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] }
public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] }
public static boolean isNumber(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     final char[] chars = str.toCharArray(); [EOL]     int sz = chars.length; [EOL]     boolean hasExp = false; [EOL]     boolean hasDecPoint = false; [EOL]     boolean allowSigns = false; [EOL]     boolean foundDigit = false; [EOL]     final int start = (chars[0] == '-') ? 1 : 0; [EOL]     if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') { [EOL]         int i = start + 2; [EOL]         if (i == sz) { [EOL]             return false; [EOL]         } [EOL]         for (; i < chars.length; i++) { [EOL]             if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     sz--; [EOL]     int i = start; [EOL]     while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             foundDigit = true; [EOL]             allowSigns = false; [EOL]         } else if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             hasDecPoint = true; [EOL]         } else if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             if (hasExp) { [EOL]                 return false; [EOL]             } [EOL]             if (!foundDigit) { [EOL]                 return false; [EOL]             } [EOL]             hasExp = true; [EOL]             allowSigns = true; [EOL]         } else if (chars[i] == '+' || chars[i] == '-') { [EOL]             if (!allowSigns) { [EOL]                 return false; [EOL]             } [EOL]             allowSigns = false; [EOL]             foundDigit = false; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]         i++; [EOL]     } [EOL]     if (i < chars.length) { [EOL]         if (chars[i] >= '0' && chars[i] <= '9') { [EOL]             return true; [EOL]         } [EOL]         if (chars[i] == 'e' || chars[i] == 'E') { [EOL]             return false; [EOL]         } [EOL]         if (chars[i] == '.') { [EOL]             if (hasDecPoint || hasExp) { [EOL]                 return false; [EOL]             } [EOL]             return foundDigit; [EOL]         } [EOL]         if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { [EOL]             return foundDigit; [EOL]         } [EOL]         if (chars[i] == 'l' || chars[i] == 'L') { [EOL]             return foundDigit && !hasExp && !hasDecPoint; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     return !allowSigns && foundDigit; [EOL] }
public static boolean isDigits(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < str.length(); i++) { [EOL]         if (!Character.isDigit(str.charAt(i))) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean isDigits(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return false; [EOL]     } [EOL]     for (int i = 0; i < str.length(); i++) { [EOL]         if (!Character.isDigit(str.charAt(i))) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static BigDecimal createBigDecimal(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     if (str.trim().startsWith("--")) { [EOL]         throw new NumberFormatException(str + " is not a valid number."); [EOL]     } [EOL]     return new BigDecimal(str); [EOL] }
public static BigInteger createBigInteger(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     int pos = 0; [EOL]     int radix = 10; [EOL]     boolean negate = false; [EOL]     if (str.startsWith("-")) { [EOL]         negate = true; [EOL]         pos = 1; [EOL]     } [EOL]     if (str.startsWith("0x", pos) || str.startsWith("0x", pos)) { [EOL]         radix = 16; [EOL]         pos += 2; [EOL]     } else if (str.startsWith("#", pos)) { [EOL]         radix = 16; [EOL]         pos++; [EOL]     } else if (str.startsWith("0", pos) && str.length() > pos + 1) { [EOL]         radix = 8; [EOL]         pos++; [EOL]     } [EOL]     final BigInteger value = new BigInteger(str.substring(pos), radix); [EOL]     return negate ? value.negate() : value; [EOL] }
public static BigInteger createBigInteger(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     int pos = 0; [EOL]     int radix = 10; [EOL]     boolean negate = false; [EOL]     if (str.startsWith("-")) { [EOL]         negate = true; [EOL]         pos = 1; [EOL]     } [EOL]     if (str.startsWith("0x", pos) || str.startsWith("0x", pos)) { [EOL]         radix = 16; [EOL]         pos += 2; [EOL]     } else if (str.startsWith("#", pos)) { [EOL]         radix = 16; [EOL]         pos++; [EOL]     } else if (str.startsWith("0", pos) && str.length() > pos + 1) { [EOL]         radix = 8; [EOL]         pos++; [EOL]     } [EOL]     final BigInteger value = new BigInteger(str.substring(pos), radix); [EOL]     return negate ? value.negate() : value; [EOL] }
public static BigInteger createBigInteger(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     int pos = 0; [EOL]     int radix = 10; [EOL]     boolean negate = false; [EOL]     if (str.startsWith("-")) { [EOL]         negate = true; [EOL]         pos = 1; [EOL]     } [EOL]     if (str.startsWith("0x", pos) || str.startsWith("0x", pos)) { [EOL]         radix = 16; [EOL]         pos += 2; [EOL]     } else if (str.startsWith("#", pos)) { [EOL]         radix = 16; [EOL]         pos++; [EOL]     } else if (str.startsWith("0", pos) && str.length() > pos + 1) { [EOL]         radix = 8; [EOL]         pos++; [EOL]     } [EOL]     final BigInteger value = new BigInteger(str.substring(pos), radix); [EOL]     return negate ? value.negate() : value; [EOL] }
public static BigInteger createBigInteger(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     int pos = 0; [EOL]     int radix = 10; [EOL]     boolean negate = false; [EOL]     if (str.startsWith("-")) { [EOL]         negate = true; [EOL]         pos = 1; [EOL]     } [EOL]     if (str.startsWith("0x", pos) || str.startsWith("0x", pos)) { [EOL]         radix = 16; [EOL]         pos += 2; [EOL]     } else if (str.startsWith("#", pos)) { [EOL]         radix = 16; [EOL]         pos++; [EOL]     } else if (str.startsWith("0", pos) && str.length() > pos + 1) { [EOL]         radix = 8; [EOL]         pos++; [EOL]     } [EOL]     final BigInteger value = new BigInteger(str.substring(pos), radix); [EOL]     return negate ? value.negate() : value; [EOL] }
public static Long createLong(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return Long.decode(str); [EOL] }
public static Integer createInteger(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return Integer.decode(str); [EOL] }
public static Double createDouble(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return Double.valueOf(str); [EOL] }
public static Float createFloat(final String str) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     return Float.valueOf(str); [EOL] }
public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         final Float f = createFloat(str); [EOL]         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]             return f; [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         final Double d = createDouble(str); [EOL]         if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]             return d; [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] }
public static Number createNumber(final String str) throws NumberFormatException { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (StringUtils.isBlank(str)) { [EOL]         throw new NumberFormatException("A blank string is not a valid number"); [EOL]     } [EOL]     final String[] hex_prefixes = { "0x", "0X", "-0x", "-0X", "#", "-#" }; [EOL]     int pfxLen = 0; [EOL]     for (final String pfx : hex_prefixes) { [EOL]         if (str.startsWith(pfx)) { [EOL]             pfxLen += pfx.length(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (pfxLen > 0) { [EOL]         final int hexDigits = str.length() - pfxLen; [EOL]         if (hexDigits > 16) { [EOL]             return createBigInteger(str); [EOL]         } [EOL]         if (hexDigits > 8) { [EOL]             return createLong(str); [EOL]         } [EOL]         return createInteger(str); [EOL]     } [EOL]     final char lastChar = str.charAt(str.length() - 1); [EOL]     String mant; [EOL]     String dec; [EOL]     String exp; [EOL]     final int decPos = str.indexOf('.'); [EOL]     final int expPos = str.indexOf('e') + str.indexOf('E') + 1; [EOL]     int numDecimals = 0; [EOL]     if (decPos > -1) { [EOL]         if (expPos > -1) { [EOL]             if (expPos < decPos || expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             dec = str.substring(decPos + 1, expPos); [EOL]         } else { [EOL]             dec = str.substring(decPos + 1); [EOL]         } [EOL]         mant = str.substring(0, decPos); [EOL]         numDecimals = dec.length(); [EOL]     } else { [EOL]         if (expPos > -1) { [EOL]             if (expPos > str.length()) { [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             } [EOL]             mant = str.substring(0, expPos); [EOL]         } else { [EOL]             mant = str; [EOL]         } [EOL]         dec = null; [EOL]     } [EOL]     if (!Character.isDigit(lastChar) && lastChar != '.') { [EOL]         if (expPos > -1 && expPos < str.length() - 1) { [EOL]             exp = str.substring(expPos + 1, str.length() - 1); [EOL]         } else { [EOL]             exp = null; [EOL]         } [EOL]         final String numeric = str.substring(0, str.length() - 1); [EOL]         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]         switch(lastChar) { [EOL]             case 'l': [EOL]             case 'L': [EOL]                 if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { [EOL]                     try { [EOL]                         return createLong(numeric); [EOL]                     } catch (final NumberFormatException nfe) { [EOL]                     } [EOL]                     return createBigInteger(numeric); [EOL]                 } [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]             case 'f': [EOL]             case 'F': [EOL]                 try { [EOL]                     final Float f = NumberUtils.createFloat(numeric); [EOL]                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]                         return f; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]             case 'd': [EOL]             case 'D': [EOL]                 try { [EOL]                     final Double d = NumberUtils.createDouble(numeric); [EOL]                     if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { [EOL]                         return d; [EOL]                     } [EOL]                 } catch (final NumberFormatException nfe) { [EOL]                 } [EOL]                 try { [EOL]                     return createBigDecimal(numeric); [EOL]                 } catch (final NumberFormatException e) { [EOL]                 } [EOL]             default: [EOL]                 throw new NumberFormatException(str + " is not a valid number."); [EOL]         } [EOL]     } [EOL]     if (expPos > -1 && expPos < str.length() - 1) { [EOL]         exp = str.substring(expPos + 1, str.length()); [EOL]     } else { [EOL]         exp = null; [EOL]     } [EOL]     if (dec == null && exp == null) { [EOL]         try { [EOL]             return createInteger(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         try { [EOL]             return createLong(str); [EOL]         } catch (final NumberFormatException nfe) { [EOL]         } [EOL]         return createBigInteger(str); [EOL]     } [EOL]     final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); [EOL]     try { [EOL]         final Float f = createFloat(str); [EOL]         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { [EOL]             return f; [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     try { [EOL]         final Double d = createDouble(str); [EOL]         if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { [EOL]             return d; [EOL]         } [EOL]     } catch (final NumberFormatException nfe) { [EOL]     } [EOL]     return createBigDecimal(str); [EOL] }
public static short toShort(final String str, final short defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Short.parseShort(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static byte toByte(final String str, final byte defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Byte.parseByte(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static double toDouble(final String str, final double defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Double.parseDouble(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static float toFloat(final String str, final float defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Float.parseFloat(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static long toLong(final String str, final long defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Long.parseLong(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static int toInt(final String str, final int defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Integer.parseInt(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static short toShort(final String str, final short defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Short.parseShort(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static float toFloat(final String str, final float defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Float.parseFloat(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static long toLong(final String str, final long defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Long.parseLong(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static double toDouble(final String str, final double defaultValue) { [EOL]     if (str == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return Double.parseDouble(str); [EOL]     } catch (final NumberFormatException nfe) { [EOL]         return defaultValue; [EOL]     } [EOL] }
public static float min(final float a, final float b, final float c) { [EOL]     return Math.min(Math.min(a, b), c); [EOL] }
public static float max(final float a, final float b, final float c) { [EOL]     return Math.max(Math.max(a, b), c); [EOL] }
methods/lang3/math/IEEE754rUtils.java
public static float min(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.min(a, b); [EOL]     } [EOL] }
public static float min(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.min(a, b); [EOL]     } [EOL] }
public static float min(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.min(a, b); [EOL]     } [EOL] }
public static float min(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.min(a, b); [EOL]     } [EOL] }
public static float min(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.min(a, b); [EOL]     } [EOL] }
public static float min(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.min(a, b); [EOL]     } [EOL] }
public static float min(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.min(a, b); [EOL]     } [EOL] }
public static float min(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.min(a, b); [EOL]     } [EOL] }
public static float min(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.min(a, b); [EOL]     } [EOL] }
public static float min(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.min(a, b); [EOL]     } [EOL] }
public static float min(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.min(a, b); [EOL]     } [EOL] }
public static float min(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.min(a, b); [EOL]     } [EOL] }
public static float min(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.min(a, b); [EOL]     } [EOL] }
public static float max(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.max(a, b); [EOL]     } [EOL] }
public static float max(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.max(a, b); [EOL]     } [EOL] }
public static float max(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.max(a, b); [EOL]     } [EOL] }
public static float max(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.max(a, b); [EOL]     } [EOL] }
public static float max(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.max(a, b); [EOL]     } [EOL] }
public static float max(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.max(a, b); [EOL]     } [EOL] }
public static float max(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.max(a, b); [EOL]     } [EOL] }
public static float max(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.max(a, b); [EOL]     } [EOL] }
public static float max(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.max(a, b); [EOL]     } [EOL] }
public static float max(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.max(a, b); [EOL]     } [EOL] }
public static float max(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.max(a, b); [EOL]     } [EOL] }
public static float max(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.max(a, b); [EOL]     } [EOL] }
public static float max(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.max(a, b); [EOL]     } [EOL] }
public static float max(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.max(a, b); [EOL]     } [EOL] }
public static float min(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.min(a, b); [EOL]     } [EOL] }
public static float min(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.min(a, b); [EOL]     } [EOL] }
public static float max(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.max(a, b); [EOL]     } [EOL] }
public static float max(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.max(a, b); [EOL]     } [EOL] }
public static float min(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.min(a, b); [EOL]     } [EOL] }
public static float min(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.min(a, b); [EOL]     } [EOL] }
public static float min(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.min(a, b); [EOL]     } [EOL] }
public static float max(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.max(a, b); [EOL]     } [EOL] }
public static float max(final float a, final float b) { [EOL]     if (Float.isNaN(a)) { [EOL]         return b; [EOL]     } else if (Float.isNaN(b)) { [EOL]         return a; [EOL]     } else { [EOL]         return Math.max(a, b); [EOL]     } [EOL] }
methods/lang3/exception/ContextedException.java
public String getRawMessage() { [EOL]     return super.getMessage(); [EOL] }
public String getRawMessage() { [EOL]     return super.getMessage(); [EOL] }
@Override [EOL] public String getMessage() { [EOL]     return getFormattedExceptionMessage(super.getMessage()); [EOL] }
@Override [EOL] public String getFormattedExceptionMessage(final String baseMessage) { [EOL]     return exceptionContext.getFormattedExceptionMessage(baseMessage); [EOL] }
@Override [EOL] public ContextedException setContextValue(final String label, final Object value) { [EOL]     exceptionContext.setContextValue(label, value); [EOL]     return this; [EOL] }
@Override [EOL] public List<Object> getContextValues(final String label) { [EOL]     return this.exceptionContext.getContextValues(label); [EOL] }
@Override [EOL] public ContextedException addContextValue(final String label, final Object value) { [EOL]     exceptionContext.addContextValue(label, value); [EOL]     return this; [EOL] }
@Override [EOL] public Set<String> getContextLabels() { [EOL]     return exceptionContext.getContextLabels(); [EOL] }
@Override [EOL] public ContextedException setContextValue(final String label, final Object value) { [EOL]     exceptionContext.setContextValue(label, value); [EOL]     return this; [EOL] }
@Override [EOL] public List<Pair<String, Object>> getContextEntries() { [EOL]     return this.exceptionContext.getContextEntries(); [EOL] }
@Override [EOL] public String getFormattedExceptionMessage(final String baseMessage) { [EOL]     return exceptionContext.getFormattedExceptionMessage(baseMessage); [EOL] }
@Override [EOL] public List<Object> getContextValues(final String label) { [EOL]     return this.exceptionContext.getContextValues(label); [EOL] }
@Override [EOL] public List<Pair<String, Object>> getContextEntries() { [EOL]     return this.exceptionContext.getContextEntries(); [EOL] }
@Override [EOL] public ContextedException addContextValue(final String label, final Object value) { [EOL]     exceptionContext.addContextValue(label, value); [EOL]     return this; [EOL] }
@Override [EOL] public Object getFirstContextValue(final String label) { [EOL]     return this.exceptionContext.getFirstContextValue(label); [EOL] }
public String getRawMessage() { [EOL]     return super.getMessage(); [EOL] }
@Override [EOL] public Object getFirstContextValue(final String label) { [EOL]     return this.exceptionContext.getFirstContextValue(label); [EOL] }
@Override [EOL] public Set<String> getContextLabels() { [EOL]     return exceptionContext.getContextLabels(); [EOL] }
@Override [EOL] public String getMessage() { [EOL]     return getFormattedExceptionMessage(super.getMessage()); [EOL] }
methods/lang3/exception/ExceptionUtils.java
public static Throwable getRootCause(final Throwable throwable) { [EOL]     final List<Throwable> list = getThrowableList(throwable); [EOL]     return list.size() < 2 ? null : (Throwable) list.get(list.size() - 1); [EOL] }
public static Throwable getRootCause(final Throwable throwable) { [EOL]     final List<Throwable> list = getThrowableList(throwable); [EOL]     return list.size() < 2 ? null : (Throwable) list.get(list.size() - 1); [EOL] }
public static String[] getRootCauseStackTrace(final Throwable throwable) { [EOL]     if (throwable == null) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final Throwable[] throwables = getThrowables(throwable); [EOL]     final int count = throwables.length; [EOL]     final List<String> frames = new ArrayList<String>(); [EOL]     List<String> nextTrace = getStackFrameList(throwables[count - 1]); [EOL]     for (int i = count; --i >= 0; ) { [EOL]         final List<String> trace = nextTrace; [EOL]         if (i != 0) { [EOL]             nextTrace = getStackFrameList(throwables[i - 1]); [EOL]             removeCommonFrames(trace, nextTrace); [EOL]         } [EOL]         if (i == count - 1) { [EOL]             frames.add(throwables[i].toString()); [EOL]         } else { [EOL]             frames.add(WRAPPED_MARKER + throwables[i].toString()); [EOL]         } [EOL]         for (int j = 0; j < trace.size(); j++) { [EOL]             frames.add(trace.get(j)); [EOL]         } [EOL]     } [EOL]     return frames.toArray(new String[frames.size()]); [EOL] }
public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex) { [EOL]     return indexOf(throwable, type, fromIndex, true); [EOL] }
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex) { [EOL]     return indexOf(throwable, type, fromIndex, true); [EOL] }
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public static Throwable getRootCause(final Throwable throwable) { [EOL]     final List<Throwable> list = getThrowableList(throwable); [EOL]     return list.size() < 2 ? null : (Throwable) list.get(list.size() - 1); [EOL] }
public static String getRootCauseMessage(final Throwable th) { [EOL]     Throwable root = ExceptionUtils.getRootCause(th); [EOL]     root = root == null ? th : root; [EOL]     return getMessage(root); [EOL] }
public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex) { [EOL]     return indexOf(throwable, type, fromIndex, true); [EOL] }
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex) { [EOL]     return indexOf(throwable, clazz, fromIndex, false); [EOL] }
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public static Throwable[] getThrowables(final Throwable throwable) { [EOL]     final List<Throwable> list = getThrowableList(throwable); [EOL]     return list.toArray(new Throwable[list.size()]); [EOL] }
public static int getThrowableCount(final Throwable throwable) { [EOL]     return getThrowableList(throwable).size(); [EOL] }
static String[] getStackFrames(final String stackTrace) { [EOL]     final String linebreak = SystemUtils.LINE_SEPARATOR; [EOL]     final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     while (frames.hasMoreTokens()) { [EOL]         list.add(frames.nextToken()); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
static List<String> getStackFrameList(final Throwable t) { [EOL]     final String stackTrace = getStackTrace(t); [EOL]     final String linebreak = SystemUtils.LINE_SEPARATOR; [EOL]     final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     boolean traceStarted = false; [EOL]     while (frames.hasMoreTokens()) { [EOL]         final String token = frames.nextToken(); [EOL]         final int at = token.indexOf("at"); [EOL]         if (at != -1 && token.substring(0, at).trim().isEmpty()) { [EOL]             traceStarted = true; [EOL]             list.add(token); [EOL]         } else if (traceStarted) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return list; [EOL] }
static List<String> getStackFrameList(final Throwable t) { [EOL]     final String stackTrace = getStackTrace(t); [EOL]     final String linebreak = SystemUtils.LINE_SEPARATOR; [EOL]     final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     boolean traceStarted = false; [EOL]     while (frames.hasMoreTokens()) { [EOL]         final String token = frames.nextToken(); [EOL]         final int at = token.indexOf("at"); [EOL]         if (at != -1 && token.substring(0, at).trim().isEmpty()) { [EOL]             traceStarted = true; [EOL]             list.add(token); [EOL]         } else if (traceStarted) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return list; [EOL] }
public static String getMessage(final Throwable th) { [EOL]     if (th == null) { [EOL]         return ""; [EOL]     } [EOL]     final String clsName = ClassUtils.getShortClassName(th, null); [EOL]     final String msg = th.getMessage(); [EOL]     return clsName + ": " + StringUtils.defaultString(msg); [EOL] }
public static String getMessage(final Throwable th) { [EOL]     if (th == null) { [EOL]         return ""; [EOL]     } [EOL]     final String clsName = ClassUtils.getShortClassName(th, null); [EOL]     final String msg = th.getMessage(); [EOL]     return clsName + ": " + StringUtils.defaultString(msg); [EOL] }
static String[] getStackFrames(final String stackTrace) { [EOL]     final String linebreak = SystemUtils.LINE_SEPARATOR; [EOL]     final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     while (frames.hasMoreTokens()) { [EOL]         list.add(frames.nextToken()); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
public static Throwable getRootCause(final Throwable throwable) { [EOL]     final List<Throwable> list = getThrowableList(throwable); [EOL]     return list.size() < 2 ? null : (Throwable) list.get(list.size() - 1); [EOL] }
public static String[] getRootCauseStackTrace(final Throwable throwable) { [EOL]     if (throwable == null) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final Throwable[] throwables = getThrowables(throwable); [EOL]     final int count = throwables.length; [EOL]     final List<String> frames = new ArrayList<String>(); [EOL]     List<String> nextTrace = getStackFrameList(throwables[count - 1]); [EOL]     for (int i = count; --i >= 0; ) { [EOL]         final List<String> trace = nextTrace; [EOL]         if (i != 0) { [EOL]             nextTrace = getStackFrameList(throwables[i - 1]); [EOL]             removeCommonFrames(trace, nextTrace); [EOL]         } [EOL]         if (i == count - 1) { [EOL]             frames.add(throwables[i].toString()); [EOL]         } else { [EOL]             frames.add(WRAPPED_MARKER + throwables[i].toString()); [EOL]         } [EOL]         for (int j = 0; j < trace.size(); j++) { [EOL]             frames.add(trace.get(j)); [EOL]         } [EOL]     } [EOL]     return frames.toArray(new String[frames.size()]); [EOL] }
public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer) { [EOL]     if (throwable == null) { [EOL]         return; [EOL]     } [EOL]     if (writer == null) { [EOL]         throw new IllegalArgumentException("The PrintWriter must not be null"); [EOL]     } [EOL]     final String[] trace = getRootCauseStackTrace(throwable); [EOL]     for (final String element : trace) { [EOL]         writer.println(element); [EOL]     } [EOL]     writer.flush(); [EOL] }
public static String getMessage(final Throwable th) { [EOL]     if (th == null) { [EOL]         return ""; [EOL]     } [EOL]     final String clsName = ClassUtils.getShortClassName(th, null); [EOL]     final String msg = th.getMessage(); [EOL]     return clsName + ": " + StringUtils.defaultString(msg); [EOL] }
public static List<Throwable> getThrowableList(Throwable throwable) { [EOL]     final List<Throwable> list = new ArrayList<Throwable>(); [EOL]     while (throwable != null && list.contains(throwable) == false) { [EOL]         list.add(throwable); [EOL]         throwable = ExceptionUtils.getCause(throwable); [EOL]     } [EOL]     return list; [EOL] }
public static List<Throwable> getThrowableList(Throwable throwable) { [EOL]     final List<Throwable> list = new ArrayList<Throwable>(); [EOL]     while (throwable != null && list.contains(throwable) == false) { [EOL]         list.add(throwable); [EOL]         throwable = ExceptionUtils.getCause(throwable); [EOL]     } [EOL]     return list; [EOL] }
public static List<Throwable> getThrowableList(Throwable throwable) { [EOL]     final List<Throwable> list = new ArrayList<Throwable>(); [EOL]     while (throwable != null && list.contains(throwable) == false) { [EOL]         list.add(throwable); [EOL]         throwable = ExceptionUtils.getCause(throwable); [EOL]     } [EOL]     return list; [EOL] }
public static Throwable getRootCause(final Throwable throwable) { [EOL]     final List<Throwable> list = getThrowableList(throwable); [EOL]     return list.size() < 2 ? null : (Throwable) list.get(list.size() - 1); [EOL] }
@Deprecated [EOL] public static Throwable getCause(final Throwable throwable, String[] methodNames) { [EOL]     if (throwable == null) { [EOL]         return null; [EOL]     } [EOL]     if (methodNames == null) { [EOL]         methodNames = CAUSE_METHOD_NAMES; [EOL]     } [EOL]     for (final String methodName : methodNames) { [EOL]         if (methodName != null) { [EOL]             final Throwable cause = getCauseUsingMethodName(throwable, methodName); [EOL]             if (cause != null) { [EOL]                 return cause; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public static Throwable[] getThrowables(final Throwable throwable) { [EOL]     final List<Throwable> list = getThrowableList(throwable); [EOL]     return list.toArray(new Throwable[list.size()]); [EOL] }
public static Throwable getRootCause(final Throwable throwable) { [EOL]     final List<Throwable> list = getThrowableList(throwable); [EOL]     return list.size() < 2 ? null : (Throwable) list.get(list.size() - 1); [EOL] }
public static String getRootCauseMessage(final Throwable th) { [EOL]     Throwable root = ExceptionUtils.getRootCause(th); [EOL]     root = root == null ? th : root; [EOL]     return getMessage(root); [EOL] }
public static Throwable getRootCause(final Throwable throwable) { [EOL]     final List<Throwable> list = getThrowableList(throwable); [EOL]     return list.size() < 2 ? null : (Throwable) list.get(list.size() - 1); [EOL] }
public static String getRootCauseMessage(final Throwable th) { [EOL]     Throwable root = ExceptionUtils.getRootCause(th); [EOL]     root = root == null ? th : root; [EOL]     return getMessage(root); [EOL] }
static String[] getStackFrames(final String stackTrace) { [EOL]     final String linebreak = SystemUtils.LINE_SEPARATOR; [EOL]     final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     while (frames.hasMoreTokens()) { [EOL]         list.add(frames.nextToken()); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
static String[] getStackFrames(final String stackTrace) { [EOL]     final String linebreak = SystemUtils.LINE_SEPARATOR; [EOL]     final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak); [EOL]     final List<String> list = new ArrayList<String>(); [EOL]     while (frames.hasMoreTokens()) { [EOL]         list.add(frames.nextToken()); [EOL]     } [EOL]     return list.toArray(new String[list.size()]); [EOL] }
public static Throwable getRootCause(final Throwable throwable) { [EOL]     final List<Throwable> list = getThrowableList(throwable); [EOL]     return list.size() < 2 ? null : (Throwable) list.get(list.size() - 1); [EOL] }
public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames) { [EOL]     if (causeFrames == null || wrapperFrames == null) { [EOL]         throw new IllegalArgumentException("The List must not be null"); [EOL]     } [EOL]     int causeFrameIndex = causeFrames.size() - 1; [EOL]     int wrapperFrameIndex = wrapperFrames.size() - 1; [EOL]     while (causeFrameIndex >= 0 && wrapperFrameIndex >= 0) { [EOL]         final String causeFrame = causeFrames.get(causeFrameIndex); [EOL]         final String wrapperFrame = wrapperFrames.get(wrapperFrameIndex); [EOL]         if (causeFrame.equals(wrapperFrame)) { [EOL]             causeFrames.remove(causeFrameIndex); [EOL]         } [EOL]         causeFrameIndex--; [EOL]         wrapperFrameIndex--; [EOL]     } [EOL] }
public static Throwable getRootCause(final Throwable throwable) { [EOL]     final List<Throwable> list = getThrowableList(throwable); [EOL]     return list.size() < 2 ? null : (Throwable) list.get(list.size() - 1); [EOL] }
public static String[] getRootCauseStackTrace(final Throwable throwable) { [EOL]     if (throwable == null) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final Throwable[] throwables = getThrowables(throwable); [EOL]     final int count = throwables.length; [EOL]     final List<String> frames = new ArrayList<String>(); [EOL]     List<String> nextTrace = getStackFrameList(throwables[count - 1]); [EOL]     for (int i = count; --i >= 0; ) { [EOL]         final List<String> trace = nextTrace; [EOL]         if (i != 0) { [EOL]             nextTrace = getStackFrameList(throwables[i - 1]); [EOL]             removeCommonFrames(trace, nextTrace); [EOL]         } [EOL]         if (i == count - 1) { [EOL]             frames.add(throwables[i].toString()); [EOL]         } else { [EOL]             frames.add(WRAPPED_MARKER + throwables[i].toString()); [EOL]         } [EOL]         for (int j = 0; j < trace.size(); j++) { [EOL]             frames.add(trace.get(j)); [EOL]         } [EOL]     } [EOL]     return frames.toArray(new String[frames.size()]); [EOL] }
public static Throwable getRootCause(final Throwable throwable) { [EOL]     final List<Throwable> list = getThrowableList(throwable); [EOL]     return list.size() < 2 ? null : (Throwable) list.get(list.size() - 1); [EOL] }
public static String[] getRootCauseStackTrace(final Throwable throwable) { [EOL]     if (throwable == null) { [EOL]         return ArrayUtils.EMPTY_STRING_ARRAY; [EOL]     } [EOL]     final Throwable[] throwables = getThrowables(throwable); [EOL]     final int count = throwables.length; [EOL]     final List<String> frames = new ArrayList<String>(); [EOL]     List<String> nextTrace = getStackFrameList(throwables[count - 1]); [EOL]     for (int i = count; --i >= 0; ) { [EOL]         final List<String> trace = nextTrace; [EOL]         if (i != 0) { [EOL]             nextTrace = getStackFrameList(throwables[i - 1]); [EOL]             removeCommonFrames(trace, nextTrace); [EOL]         } [EOL]         if (i == count - 1) { [EOL]             frames.add(throwables[i].toString()); [EOL]         } else { [EOL]             frames.add(WRAPPED_MARKER + throwables[i].toString()); [EOL]         } [EOL]         for (int j = 0; j < trace.size(); j++) { [EOL]             frames.add(trace.get(j)); [EOL]         } [EOL]     } [EOL]     return frames.toArray(new String[frames.size()]); [EOL] }
public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer) { [EOL]     if (throwable == null) { [EOL]         return; [EOL]     } [EOL]     if (writer == null) { [EOL]         throw new IllegalArgumentException("The PrintWriter must not be null"); [EOL]     } [EOL]     final String[] trace = getRootCauseStackTrace(throwable); [EOL]     for (final String element : trace) { [EOL]         writer.println(element); [EOL]     } [EOL]     writer.flush(); [EOL] }
public static String getMessage(final Throwable th) { [EOL]     if (th == null) { [EOL]         return ""; [EOL]     } [EOL]     final String clsName = ClassUtils.getShortClassName(th, null); [EOL]     final String msg = th.getMessage(); [EOL]     return clsName + ": " + StringUtils.defaultString(msg); [EOL] }
public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex) { [EOL]     return indexOf(throwable, clazz, fromIndex, false); [EOL] }
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex) { [EOL]     return indexOf(throwable, type, fromIndex, true); [EOL] }
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex) { [EOL]     return indexOf(throwable, clazz, fromIndex, false); [EOL] }
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex) { [EOL]     return indexOf(throwable, clazz, fromIndex, false); [EOL] }
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public static Throwable getRootCause(final Throwable throwable) { [EOL]     final List<Throwable> list = getThrowableList(throwable); [EOL]     return list.size() < 2 ? null : (Throwable) list.get(list.size() - 1); [EOL] }
public static String getRootCauseMessage(final Throwable th) { [EOL]     Throwable root = ExceptionUtils.getRootCause(th); [EOL]     root = root == null ? th : root; [EOL]     return getMessage(root); [EOL] }
public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer) { [EOL]     if (throwable == null) { [EOL]         return; [EOL]     } [EOL]     if (writer == null) { [EOL]         throw new IllegalArgumentException("The PrintWriter must not be null"); [EOL]     } [EOL]     final String[] trace = getRootCauseStackTrace(throwable); [EOL]     for (final String element : trace) { [EOL]         writer.println(element); [EOL]     } [EOL]     writer.flush(); [EOL] }
public static String getMessage(final Throwable th) { [EOL]     if (th == null) { [EOL]         return ""; [EOL]     } [EOL]     final String clsName = ClassUtils.getShortClassName(th, null); [EOL]     final String msg = th.getMessage(); [EOL]     return clsName + ": " + StringUtils.defaultString(msg); [EOL] }
@Deprecated [EOL] public static Throwable getCause(final Throwable throwable, String[] methodNames) { [EOL]     if (throwable == null) { [EOL]         return null; [EOL]     } [EOL]     if (methodNames == null) { [EOL]         methodNames = CAUSE_METHOD_NAMES; [EOL]     } [EOL]     for (final String methodName : methodNames) { [EOL]         if (methodName != null) { [EOL]             final Throwable cause = getCauseUsingMethodName(throwable, methodName); [EOL]             if (cause != null) { [EOL]                 return cause; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Deprecated [EOL] public static Throwable getCause(final Throwable throwable, String[] methodNames) { [EOL]     if (throwable == null) { [EOL]         return null; [EOL]     } [EOL]     if (methodNames == null) { [EOL]         methodNames = CAUSE_METHOD_NAMES; [EOL]     } [EOL]     for (final String methodName : methodNames) { [EOL]         if (methodName != null) { [EOL]             final Throwable cause = getCauseUsingMethodName(throwable, methodName); [EOL]             if (cause != null) { [EOL]                 return cause; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Deprecated [EOL] public static String[] getDefaultCauseMethodNames() { [EOL]     return ArrayUtils.clone(CAUSE_METHOD_NAMES); [EOL] }
public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex) { [EOL]     return indexOf(throwable, type, fromIndex, true); [EOL] }
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex) { [EOL]     return indexOf(throwable, clazz, fromIndex, false); [EOL] }
private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) { [EOL]     if (throwable == null || type == null) { [EOL]         return -1; [EOL]     } [EOL]     if (fromIndex < 0) { [EOL]         fromIndex = 0; [EOL]     } [EOL]     final Throwable[] throwables = ExceptionUtils.getThrowables(throwable); [EOL]     if (fromIndex >= throwables.length) { [EOL]         return -1; [EOL]     } [EOL]     if (subclass) { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.isAssignableFrom(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int i = fromIndex; i < throwables.length; i++) { [EOL]             if (type.equals(throwables[i].getClass())) { [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public static int getThrowableCount(final Throwable throwable) { [EOL]     return getThrowableList(throwable).size(); [EOL] }
@Deprecated [EOL] public static Throwable getCause(final Throwable throwable, String[] methodNames) { [EOL]     if (throwable == null) { [EOL]         return null; [EOL]     } [EOL]     if (methodNames == null) { [EOL]         methodNames = CAUSE_METHOD_NAMES; [EOL]     } [EOL]     for (final String methodName : methodNames) { [EOL]         if (methodName != null) { [EOL]             final Throwable cause = getCauseUsingMethodName(throwable, methodName); [EOL]             if (cause != null) { [EOL]                 return cause; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
methods/lang3/exception/DefaultExceptionContext.java
@Override [EOL] public DefaultExceptionContext setContextValue(final String label, final Object value) { [EOL]     for (final Iterator<Pair<String, Object>> iter = contextValues.iterator(); iter.hasNext(); ) { [EOL]         final Pair<String, Object> p = iter.next(); [EOL]         if (StringUtils.equals(label, p.getKey())) { [EOL]             iter.remove(); [EOL]         } [EOL]     } [EOL]     addContextValue(label, value); [EOL]     return this; [EOL] }
@Override [EOL] public Object getFirstContextValue(final String label) { [EOL]     for (final Pair<String, Object> pair : contextValues) { [EOL]         if (StringUtils.equals(label, pair.getKey())) { [EOL]             return pair.getValue(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public DefaultExceptionContext setContextValue(final String label, final Object value) { [EOL]     for (final Iterator<Pair<String, Object>> iter = contextValues.iterator(); iter.hasNext(); ) { [EOL]         final Pair<String, Object> p = iter.next(); [EOL]         if (StringUtils.equals(label, p.getKey())) { [EOL]             iter.remove(); [EOL]         } [EOL]     } [EOL]     addContextValue(label, value); [EOL]     return this; [EOL] }
@Override [EOL] public List<Pair<String, Object>> getContextEntries() { [EOL]     return contextValues; [EOL] }
@Override [EOL] public DefaultExceptionContext addContextValue(final String label, final Object value) { [EOL]     contextValues.add(new ImmutablePair<String, Object>(label, value)); [EOL]     return this; [EOL] }
@Override [EOL] public String getFormattedExceptionMessage(final String baseMessage) { [EOL]     final StringBuilder buffer = new StringBuilder(256); [EOL]     if (baseMessage != null) { [EOL]         buffer.append(baseMessage); [EOL]     } [EOL]     if (contextValues.size() > 0) { [EOL]         if (buffer.length() > 0) { [EOL]             buffer.append('\n'); [EOL]         } [EOL]         buffer.append("Exception Context:\n"); [EOL]         int i = 0; [EOL]         for (final Pair<String, Object> pair : contextValues) { [EOL]             buffer.append("\t["); [EOL]             buffer.append(++i); [EOL]             buffer.append(':'); [EOL]             buffer.append(pair.getKey()); [EOL]             buffer.append("="); [EOL]             final Object value = pair.getValue(); [EOL]             if (value == null) { [EOL]                 buffer.append("null"); [EOL]             } else { [EOL]                 String valueStr; [EOL]                 try { [EOL]                     valueStr = value.toString(); [EOL]                 } catch (final Exception e) { [EOL]                     valueStr = "Exception thrown on toString(): " + ExceptionUtils.getStackTrace(e); [EOL]                 } [EOL]                 buffer.append(valueStr); [EOL]             } [EOL]             buffer.append("]\n"); [EOL]         } [EOL]         buffer.append("---------------------------------"); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
@Override [EOL] public DefaultExceptionContext setContextValue(final String label, final Object value) { [EOL]     for (final Iterator<Pair<String, Object>> iter = contextValues.iterator(); iter.hasNext(); ) { [EOL]         final Pair<String, Object> p = iter.next(); [EOL]         if (StringUtils.equals(label, p.getKey())) { [EOL]             iter.remove(); [EOL]         } [EOL]     } [EOL]     addContextValue(label, value); [EOL]     return this; [EOL] }
@Override [EOL] public String getFormattedExceptionMessage(final String baseMessage) { [EOL]     final StringBuilder buffer = new StringBuilder(256); [EOL]     if (baseMessage != null) { [EOL]         buffer.append(baseMessage); [EOL]     } [EOL]     if (contextValues.size() > 0) { [EOL]         if (buffer.length() > 0) { [EOL]             buffer.append('\n'); [EOL]         } [EOL]         buffer.append("Exception Context:\n"); [EOL]         int i = 0; [EOL]         for (final Pair<String, Object> pair : contextValues) { [EOL]             buffer.append("\t["); [EOL]             buffer.append(++i); [EOL]             buffer.append(':'); [EOL]             buffer.append(pair.getKey()); [EOL]             buffer.append("="); [EOL]             final Object value = pair.getValue(); [EOL]             if (value == null) { [EOL]                 buffer.append("null"); [EOL]             } else { [EOL]                 String valueStr; [EOL]                 try { [EOL]                     valueStr = value.toString(); [EOL]                 } catch (final Exception e) { [EOL]                     valueStr = "Exception thrown on toString(): " + ExceptionUtils.getStackTrace(e); [EOL]                 } [EOL]                 buffer.append(valueStr); [EOL]             } [EOL]             buffer.append("]\n"); [EOL]         } [EOL]         buffer.append("---------------------------------"); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
@Override [EOL] public String getFormattedExceptionMessage(final String baseMessage) { [EOL]     final StringBuilder buffer = new StringBuilder(256); [EOL]     if (baseMessage != null) { [EOL]         buffer.append(baseMessage); [EOL]     } [EOL]     if (contextValues.size() > 0) { [EOL]         if (buffer.length() > 0) { [EOL]             buffer.append('\n'); [EOL]         } [EOL]         buffer.append("Exception Context:\n"); [EOL]         int i = 0; [EOL]         for (final Pair<String, Object> pair : contextValues) { [EOL]             buffer.append("\t["); [EOL]             buffer.append(++i); [EOL]             buffer.append(':'); [EOL]             buffer.append(pair.getKey()); [EOL]             buffer.append("="); [EOL]             final Object value = pair.getValue(); [EOL]             if (value == null) { [EOL]                 buffer.append("null"); [EOL]             } else { [EOL]                 String valueStr; [EOL]                 try { [EOL]                     valueStr = value.toString(); [EOL]                 } catch (final Exception e) { [EOL]                     valueStr = "Exception thrown on toString(): " + ExceptionUtils.getStackTrace(e); [EOL]                 } [EOL]                 buffer.append(valueStr); [EOL]             } [EOL]             buffer.append("]\n"); [EOL]         } [EOL]         buffer.append("---------------------------------"); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
@Override [EOL] public String getFormattedExceptionMessage(final String baseMessage) { [EOL]     final StringBuilder buffer = new StringBuilder(256); [EOL]     if (baseMessage != null) { [EOL]         buffer.append(baseMessage); [EOL]     } [EOL]     if (contextValues.size() > 0) { [EOL]         if (buffer.length() > 0) { [EOL]             buffer.append('\n'); [EOL]         } [EOL]         buffer.append("Exception Context:\n"); [EOL]         int i = 0; [EOL]         for (final Pair<String, Object> pair : contextValues) { [EOL]             buffer.append("\t["); [EOL]             buffer.append(++i); [EOL]             buffer.append(':'); [EOL]             buffer.append(pair.getKey()); [EOL]             buffer.append("="); [EOL]             final Object value = pair.getValue(); [EOL]             if (value == null) { [EOL]                 buffer.append("null"); [EOL]             } else { [EOL]                 String valueStr; [EOL]                 try { [EOL]                     valueStr = value.toString(); [EOL]                 } catch (final Exception e) { [EOL]                     valueStr = "Exception thrown on toString(): " + ExceptionUtils.getStackTrace(e); [EOL]                 } [EOL]                 buffer.append(valueStr); [EOL]             } [EOL]             buffer.append("]\n"); [EOL]         } [EOL]         buffer.append("---------------------------------"); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
@Override [EOL] public DefaultExceptionContext setContextValue(final String label, final Object value) { [EOL]     for (final Iterator<Pair<String, Object>> iter = contextValues.iterator(); iter.hasNext(); ) { [EOL]         final Pair<String, Object> p = iter.next(); [EOL]         if (StringUtils.equals(label, p.getKey())) { [EOL]             iter.remove(); [EOL]         } [EOL]     } [EOL]     addContextValue(label, value); [EOL]     return this; [EOL] }
@Override [EOL] public Set<String> getContextLabels() { [EOL]     final Set<String> labels = new HashSet<String>(); [EOL]     for (final Pair<String, Object> pair : contextValues) { [EOL]         labels.add(pair.getKey()); [EOL]     } [EOL]     return labels; [EOL] }
@Override [EOL] public Set<String> getContextLabels() { [EOL]     final Set<String> labels = new HashSet<String>(); [EOL]     for (final Pair<String, Object> pair : contextValues) { [EOL]         labels.add(pair.getKey()); [EOL]     } [EOL]     return labels; [EOL] }
@Override [EOL] public DefaultExceptionContext addContextValue(final String label, final Object value) { [EOL]     contextValues.add(new ImmutablePair<String, Object>(label, value)); [EOL]     return this; [EOL] }
@Override [EOL] public Object getFirstContextValue(final String label) { [EOL]     for (final Pair<String, Object> pair : contextValues) { [EOL]         if (StringUtils.equals(label, pair.getKey())) { [EOL]             return pair.getValue(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public DefaultExceptionContext addContextValue(final String label, final Object value) { [EOL]     contextValues.add(new ImmutablePair<String, Object>(label, value)); [EOL]     return this; [EOL] }
@Override [EOL] public List<Object> getContextValues(final String label) { [EOL]     final List<Object> values = new ArrayList<Object>(); [EOL]     for (final Pair<String, Object> pair : contextValues) { [EOL]         if (StringUtils.equals(label, pair.getKey())) { [EOL]             values.add(pair.getValue()); [EOL]         } [EOL]     } [EOL]     return values; [EOL] }
@Override [EOL] public DefaultExceptionContext setContextValue(final String label, final Object value) { [EOL]     for (final Iterator<Pair<String, Object>> iter = contextValues.iterator(); iter.hasNext(); ) { [EOL]         final Pair<String, Object> p = iter.next(); [EOL]         if (StringUtils.equals(label, p.getKey())) { [EOL]             iter.remove(); [EOL]         } [EOL]     } [EOL]     addContextValue(label, value); [EOL]     return this; [EOL] }
@Override [EOL] public List<Object> getContextValues(final String label) { [EOL]     final List<Object> values = new ArrayList<Object>(); [EOL]     for (final Pair<String, Object> pair : contextValues) { [EOL]         if (StringUtils.equals(label, pair.getKey())) { [EOL]             values.add(pair.getValue()); [EOL]         } [EOL]     } [EOL]     return values; [EOL] }
@Override [EOL] public DefaultExceptionContext addContextValue(final String label, final Object value) { [EOL]     contextValues.add(new ImmutablePair<String, Object>(label, value)); [EOL]     return this; [EOL] }
@Override [EOL] public DefaultExceptionContext setContextValue(final String label, final Object value) { [EOL]     for (final Iterator<Pair<String, Object>> iter = contextValues.iterator(); iter.hasNext(); ) { [EOL]         final Pair<String, Object> p = iter.next(); [EOL]         if (StringUtils.equals(label, p.getKey())) { [EOL]             iter.remove(); [EOL]         } [EOL]     } [EOL]     addContextValue(label, value); [EOL]     return this; [EOL] }
@Override [EOL] public DefaultExceptionContext setContextValue(final String label, final Object value) { [EOL]     for (final Iterator<Pair<String, Object>> iter = contextValues.iterator(); iter.hasNext(); ) { [EOL]         final Pair<String, Object> p = iter.next(); [EOL]         if (StringUtils.equals(label, p.getKey())) { [EOL]             iter.remove(); [EOL]         } [EOL]     } [EOL]     addContextValue(label, value); [EOL]     return this; [EOL] }
@Override [EOL] public List<Pair<String, Object>> getContextEntries() { [EOL]     return contextValues; [EOL] }
methods/lang3/exception/CloneFailedException.java
methods/lang3/exception/ContextedRuntimeException.java
public String getRawMessage() { [EOL]     return super.getMessage(); [EOL] }
public String getRawMessage() { [EOL]     return super.getMessage(); [EOL] }
@Override [EOL] public String getMessage() { [EOL]     return getFormattedExceptionMessage(super.getMessage()); [EOL] }
@Override [EOL] public String getFormattedExceptionMessage(final String baseMessage) { [EOL]     return exceptionContext.getFormattedExceptionMessage(baseMessage); [EOL] }
@Override [EOL] public ContextedRuntimeException addContextValue(final String label, final Object value) { [EOL]     exceptionContext.addContextValue(label, value); [EOL]     return this; [EOL] }
@Override [EOL] public Object getFirstContextValue(final String label) { [EOL]     return this.exceptionContext.getFirstContextValue(label); [EOL] }
@Override [EOL] public ContextedRuntimeException setContextValue(final String label, final Object value) { [EOL]     exceptionContext.setContextValue(label, value); [EOL]     return this; [EOL] }
@Override [EOL] public List<Object> getContextValues(final String label) { [EOL]     return this.exceptionContext.getContextValues(label); [EOL] }
@Override [EOL] public ContextedRuntimeException addContextValue(final String label, final Object value) { [EOL]     exceptionContext.addContextValue(label, value); [EOL]     return this; [EOL] }
@Override [EOL] public Set<String> getContextLabels() { [EOL]     return exceptionContext.getContextLabels(); [EOL] }
@Override [EOL] public ContextedRuntimeException addContextValue(final String label, final Object value) { [EOL]     exceptionContext.addContextValue(label, value); [EOL]     return this; [EOL] }
@Override [EOL] public List<Pair<String, Object>> getContextEntries() { [EOL]     return this.exceptionContext.getContextEntries(); [EOL] }
@Override [EOL] public Set<String> getContextLabels() { [EOL]     return exceptionContext.getContextLabels(); [EOL] }
@Override [EOL] public String getMessage() { [EOL]     return getFormattedExceptionMessage(super.getMessage()); [EOL] }
@Override [EOL] public List<Pair<String, Object>> getContextEntries() { [EOL]     return this.exceptionContext.getContextEntries(); [EOL] }
@Override [EOL] public List<Object> getContextValues(final String label) { [EOL]     return this.exceptionContext.getContextValues(label); [EOL] }
@Override [EOL] public String getFormattedExceptionMessage(final String baseMessage) { [EOL]     return exceptionContext.getFormattedExceptionMessage(baseMessage); [EOL] }
public String getRawMessage() { [EOL]     return super.getMessage(); [EOL] }
@Override [EOL] public Object getFirstContextValue(final String label) { [EOL]     return this.exceptionContext.getFirstContextValue(label); [EOL] }
methods/lang3/concurrent/BackgroundInitializer.java
public final synchronized ExecutorService getExternalExecutor() { [EOL]     return externalExecutor; [EOL] }
@Override [EOL] public T get() throws ConcurrentException { [EOL]     try { [EOL]         return getFuture().get(); [EOL]     } catch (final ExecutionException execex) { [EOL]         ConcurrentUtils.handleCause(execex); [EOL]         return null; [EOL]     } catch (final InterruptedException iex) { [EOL]         Thread.currentThread().interrupt(); [EOL]         throw new ConcurrentException(iex); [EOL]     } [EOL] }
protected int getTaskCount() { [EOL]     return 1; [EOL] }
protected abstract T initialize() throws Exception;
@Override [EOL] public T call() throws Exception { [EOL]     try { [EOL]         return initialize(); [EOL]     } finally { [EOL]         if (execFinally != null) { [EOL]             execFinally.shutdown(); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public T get() throws ConcurrentException { [EOL]     try { [EOL]         return getFuture().get(); [EOL]     } catch (final ExecutionException execex) { [EOL]         ConcurrentUtils.handleCause(execex); [EOL]         return null; [EOL]     } catch (final InterruptedException iex) { [EOL]         Thread.currentThread().interrupt(); [EOL]         throw new ConcurrentException(iex); [EOL]     } [EOL] }
protected synchronized final ExecutorService getActiveExecutor() { [EOL]     return executor; [EOL] }
@Override [EOL] public T call() throws Exception { [EOL]     try { [EOL]         return initialize(); [EOL]     } finally { [EOL]         if (execFinally != null) { [EOL]             execFinally.shutdown(); [EOL]         } [EOL]     } [EOL] }
public synchronized boolean isStarted() { [EOL]     return future != null; [EOL] }
public synchronized boolean start() { [EOL]     if (!isStarted()) { [EOL]         ExecutorService tempExec; [EOL]         executor = getExternalExecutor(); [EOL]         if (executor == null) { [EOL]             executor = tempExec = createExecutor(); [EOL]         } else { [EOL]             tempExec = null; [EOL]         } [EOL]         future = executor.submit(createTask(tempExec)); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public T get() throws ConcurrentException { [EOL]     try { [EOL]         return getFuture().get(); [EOL]     } catch (final ExecutionException execex) { [EOL]         ConcurrentUtils.handleCause(execex); [EOL]         return null; [EOL]     } catch (final InterruptedException iex) { [EOL]         Thread.currentThread().interrupt(); [EOL]         throw new ConcurrentException(iex); [EOL]     } [EOL] }
protected synchronized final ExecutorService getActiveExecutor() { [EOL]     return executor; [EOL] }
@Override [EOL] public T call() throws Exception { [EOL]     try { [EOL]         return initialize(); [EOL]     } finally { [EOL]         if (execFinally != null) { [EOL]             execFinally.shutdown(); [EOL]         } [EOL]     } [EOL] }
public synchronized boolean isStarted() { [EOL]     return future != null; [EOL] }
@Override [EOL] public T call() throws Exception { [EOL]     try { [EOL]         return initialize(); [EOL]     } finally { [EOL]         if (execFinally != null) { [EOL]             execFinally.shutdown(); [EOL]         } [EOL]     } [EOL] }
methods/lang3/concurrent/LazyInitializer.java
methods/lang3/concurrent/TimedSemaphore.java
public final synchronized int getLimit() { [EOL]     return limit; [EOL] }
public synchronized boolean isShutdown() { [EOL]     return shutdown; [EOL] }
public synchronized int getLastAcquiresPerPeriod() { [EOL]     return lastCallsPerPeriod; [EOL] }
public synchronized int getAcquireCount() { [EOL]     return acquireCount; [EOL] }
public synchronized int getAvailablePermits() { [EOL]     return getLimit() - getAcquireCount(); [EOL] }
public synchronized double getAverageCallsPerPeriod() { [EOL]     return periodCount == 0 ? 0 : (double) totalAcquireCount / (double) periodCount; [EOL] }
public long getPeriod() { [EOL]     return period; [EOL] }
public TimeUnit getUnit() { [EOL]     return unit; [EOL] }
public final synchronized int getLimit() { [EOL]     return limit; [EOL] }
public synchronized boolean isShutdown() { [EOL]     return shutdown; [EOL] }
public synchronized int getLastAcquiresPerPeriod() { [EOL]     return lastCallsPerPeriod; [EOL] }
public synchronized int getAcquireCount() { [EOL]     return acquireCount; [EOL] }
public synchronized int getAvailablePermits() { [EOL]     return getLimit() - getAcquireCount(); [EOL] }
public synchronized double getAverageCallsPerPeriod() { [EOL]     return periodCount == 0 ? 0 : (double) totalAcquireCount / (double) periodCount; [EOL] }
public long getPeriod() { [EOL]     return period; [EOL] }
public TimeUnit getUnit() { [EOL]     return unit; [EOL] }
public final synchronized int getLimit() { [EOL]     return limit; [EOL] }
public synchronized boolean isShutdown() { [EOL]     return shutdown; [EOL] }
public synchronized int getLastAcquiresPerPeriod() { [EOL]     return lastCallsPerPeriod; [EOL] }
public synchronized int getAcquireCount() { [EOL]     return acquireCount; [EOL] }
public synchronized int getAvailablePermits() { [EOL]     return getLimit() - getAcquireCount(); [EOL] }
public synchronized double getAverageCallsPerPeriod() { [EOL]     return periodCount == 0 ? 0 : (double) totalAcquireCount / (double) periodCount; [EOL] }
public long getPeriod() { [EOL]     return period; [EOL] }
public TimeUnit getUnit() { [EOL]     return unit; [EOL] }
public final synchronized int getLimit() { [EOL]     return limit; [EOL] }
public synchronized void shutdown() { [EOL]     if (!shutdown) { [EOL]         if (ownExecutor) { [EOL]             getExecutorService().shutdownNow(); [EOL]         } [EOL]         if (task != null) { [EOL]             task.cancel(false); [EOL]         } [EOL]         shutdown = true; [EOL]     } [EOL] }
public synchronized boolean isShutdown() { [EOL]     return shutdown; [EOL] }
public synchronized int getLastAcquiresPerPeriod() { [EOL]     return lastCallsPerPeriod; [EOL] }
public synchronized int getAvailablePermits() { [EOL]     return getLimit() - getAcquireCount(); [EOL] }
public TimeUnit getUnit() { [EOL]     return unit; [EOL] }
protected ScheduledExecutorService getExecutorService() { [EOL]     return executorService; [EOL] }
public synchronized int getAvailablePermits() { [EOL]     return getLimit() - getAcquireCount(); [EOL] }
public long getPeriod() { [EOL]     return period; [EOL] }
methods/lang3/concurrent/MultiBackgroundInitializer.java
methods/lang3/concurrent/ConstantInitializer.java
public final T getObject() { [EOL]     return object; [EOL] }
@Override [EOL] public T get() throws ConcurrentException { [EOL]     return getObject(); [EOL] }
@Override [EOL] public T get() throws ConcurrentException { [EOL]     return getObject(); [EOL] }
public final T getObject() { [EOL]     return object; [EOL] }
@Override [EOL] public T get() throws ConcurrentException { [EOL]     return getObject(); [EOL] }
@Override [EOL] public T get() throws ConcurrentException { [EOL]     return getObject(); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (!(obj instanceof ConstantInitializer<?>)) { [EOL]         return false; [EOL]     } [EOL]     final ConstantInitializer<?> c = (ConstantInitializer<?>) obj; [EOL]     return ObjectUtils.equals(getObject(), c.getObject()); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (!(obj instanceof ConstantInitializer<?>)) { [EOL]         return false; [EOL]     } [EOL]     final ConstantInitializer<?> c = (ConstantInitializer<?>) obj; [EOL]     return ObjectUtils.equals(getObject(), c.getObject()); [EOL] }
@Override [EOL] public T get() throws ConcurrentException { [EOL]     return getObject(); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (!(obj instanceof ConstantInitializer<?>)) { [EOL]         return false; [EOL]     } [EOL]     final ConstantInitializer<?> c = (ConstantInitializer<?>) obj; [EOL]     return ObjectUtils.equals(getObject(), c.getObject()); [EOL] }
@Override [EOL] public String toString() { [EOL]     return String.format(FMT_TO_STRING, Integer.valueOf(System.identityHashCode(this)), String.valueOf(getObject())); [EOL] }
methods/lang3/concurrent/AtomicSafeInitializer.java
methods/lang3/concurrent/ConcurrentRuntimeException.java
methods/lang3/concurrent/CallableBackgroundInitializer.java
@Override [EOL] protected T initialize() throws Exception { [EOL]     return callable.call(); [EOL] }
@Override [EOL] protected T initialize() throws Exception { [EOL]     return callable.call(); [EOL] }
methods/lang3/concurrent/BasicThreadFactory.java
@Override [EOL] public Thread newThread(final Runnable r) { [EOL]     final Thread t = getWrappedFactory().newThread(r); [EOL]     initializeThread(t); [EOL]     return t; [EOL] }
public Builder daemon(final boolean f) { [EOL]     daemonFlag = Boolean.valueOf(f); [EOL]     return this; [EOL] }
@Override [EOL] public BasicThreadFactory build() { [EOL]     final BasicThreadFactory factory = new BasicThreadFactory(this); [EOL]     reset(); [EOL]     return factory; [EOL] }
public final Thread.UncaughtExceptionHandler getUncaughtExceptionHandler() { [EOL]     return uncaughtExceptionHandler; [EOL] }
public Builder uncaughtExceptionHandler(final Thread.UncaughtExceptionHandler handler) { [EOL]     if (handler == null) { [EOL]         throw new NullPointerException("Uncaught exception handler must not be null!"); [EOL]     } [EOL]     exceptionHandler = handler; [EOL]     return this; [EOL] }
@Override [EOL] public BasicThreadFactory build() { [EOL]     final BasicThreadFactory factory = new BasicThreadFactory(this); [EOL]     reset(); [EOL]     return factory; [EOL] }
public long getThreadCount() { [EOL]     return threadCounter.get(); [EOL] }
@Override [EOL] public Thread newThread(final Runnable r) { [EOL]     final Thread t = getWrappedFactory().newThread(r); [EOL]     initializeThread(t); [EOL]     return t; [EOL] }
public Builder namingPattern(final String pattern) { [EOL]     if (pattern == null) { [EOL]         throw new NullPointerException("Naming pattern must not be null!"); [EOL]     } [EOL]     namingPattern = pattern; [EOL]     return this; [EOL] }
@Override [EOL] public BasicThreadFactory build() { [EOL]     final BasicThreadFactory factory = new BasicThreadFactory(this); [EOL]     reset(); [EOL]     return factory; [EOL] }
public final Integer getPriority() { [EOL]     return priority; [EOL] }
public Builder priority(final int prio) { [EOL]     priority = Integer.valueOf(prio); [EOL]     return this; [EOL] }
@Override [EOL] public BasicThreadFactory build() { [EOL]     final BasicThreadFactory factory = new BasicThreadFactory(this); [EOL]     reset(); [EOL]     return factory; [EOL] }
public final Integer getPriority() { [EOL]     return priority; [EOL] }
public Builder priority(final int prio) { [EOL]     priority = Integer.valueOf(prio); [EOL]     return this; [EOL] }
@Override [EOL] public BasicThreadFactory build() { [EOL]     final BasicThreadFactory factory = new BasicThreadFactory(this); [EOL]     reset(); [EOL]     return factory; [EOL] }
public final Integer getPriority() { [EOL]     return priority; [EOL] }
public Builder priority(final int prio) { [EOL]     priority = Integer.valueOf(prio); [EOL]     return this; [EOL] }
@Override [EOL] public BasicThreadFactory build() { [EOL]     final BasicThreadFactory factory = new BasicThreadFactory(this); [EOL]     reset(); [EOL]     return factory; [EOL] }
public final String getNamingPattern() { [EOL]     return namingPattern; [EOL] }
public Builder namingPattern(final String pattern) { [EOL]     if (pattern == null) { [EOL]         throw new NullPointerException("Naming pattern must not be null!"); [EOL]     } [EOL]     namingPattern = pattern; [EOL]     return this; [EOL] }
@Override [EOL] public BasicThreadFactory build() { [EOL]     final BasicThreadFactory factory = new BasicThreadFactory(this); [EOL]     reset(); [EOL]     return factory; [EOL] }
public final String getNamingPattern() { [EOL]     return namingPattern; [EOL] }
public Builder namingPattern(final String pattern) { [EOL]     if (pattern == null) { [EOL]         throw new NullPointerException("Naming pattern must not be null!"); [EOL]     } [EOL]     namingPattern = pattern; [EOL]     return this; [EOL] }
@Override [EOL] public BasicThreadFactory build() { [EOL]     final BasicThreadFactory factory = new BasicThreadFactory(this); [EOL]     reset(); [EOL]     return factory; [EOL] }
public final Boolean getDaemonFlag() { [EOL]     return daemonFlag; [EOL] }
public Builder daemon(final boolean f) { [EOL]     daemonFlag = Boolean.valueOf(f); [EOL]     return this; [EOL] }
@Override [EOL] public BasicThreadFactory build() { [EOL]     final BasicThreadFactory factory = new BasicThreadFactory(this); [EOL]     reset(); [EOL]     return factory; [EOL] }
public final Boolean getDaemonFlag() { [EOL]     return daemonFlag; [EOL] }
public Builder daemon(final boolean f) { [EOL]     daemonFlag = Boolean.valueOf(f); [EOL]     return this; [EOL] }
@Override [EOL] public BasicThreadFactory build() { [EOL]     final BasicThreadFactory factory = new BasicThreadFactory(this); [EOL]     reset(); [EOL]     return factory; [EOL] }
public final Boolean getDaemonFlag() { [EOL]     return daemonFlag; [EOL] }
@Override [EOL] public BasicThreadFactory build() { [EOL]     final BasicThreadFactory factory = new BasicThreadFactory(this); [EOL]     reset(); [EOL]     return factory; [EOL] }
public final ThreadFactory getWrappedFactory() { [EOL]     return wrappedFactory; [EOL] }
@Override [EOL] public BasicThreadFactory build() { [EOL]     final BasicThreadFactory factory = new BasicThreadFactory(this); [EOL]     reset(); [EOL]     return factory; [EOL] }
public final String getNamingPattern() { [EOL]     return namingPattern; [EOL] }
@Override [EOL] public BasicThreadFactory build() { [EOL]     final BasicThreadFactory factory = new BasicThreadFactory(this); [EOL]     reset(); [EOL]     return factory; [EOL] }
public final Integer getPriority() { [EOL]     return priority; [EOL] }
@Override [EOL] public BasicThreadFactory build() { [EOL]     final BasicThreadFactory factory = new BasicThreadFactory(this); [EOL]     reset(); [EOL]     return factory; [EOL] }
public final Thread.UncaughtExceptionHandler getUncaughtExceptionHandler() { [EOL]     return uncaughtExceptionHandler; [EOL] }
@Override [EOL] public BasicThreadFactory build() { [EOL]     final BasicThreadFactory factory = new BasicThreadFactory(this); [EOL]     reset(); [EOL]     return factory; [EOL] }
public final Integer getPriority() { [EOL]     return priority; [EOL] }
@Override [EOL] public Thread newThread(final Runnable r) { [EOL]     final Thread t = getWrappedFactory().newThread(r); [EOL]     initializeThread(t); [EOL]     return t; [EOL] }
public Builder priority(final int prio) { [EOL]     priority = Integer.valueOf(prio); [EOL]     return this; [EOL] }
@Override [EOL] public BasicThreadFactory build() { [EOL]     final BasicThreadFactory factory = new BasicThreadFactory(this); [EOL]     reset(); [EOL]     return factory; [EOL] }
@Override [EOL] public Thread newThread(final Runnable r) { [EOL]     final Thread t = getWrappedFactory().newThread(r); [EOL]     initializeThread(t); [EOL]     return t; [EOL] }
public Builder uncaughtExceptionHandler(final Thread.UncaughtExceptionHandler handler) { [EOL]     if (handler == null) { [EOL]         throw new NullPointerException("Uncaught exception handler must not be null!"); [EOL]     } [EOL]     exceptionHandler = handler; [EOL]     return this; [EOL] }
@Override [EOL] public BasicThreadFactory build() { [EOL]     final BasicThreadFactory factory = new BasicThreadFactory(this); [EOL]     reset(); [EOL]     return factory; [EOL] }
public long getThreadCount() { [EOL]     return threadCounter.get(); [EOL] }
public Builder wrappedFactory(final ThreadFactory factory) { [EOL]     if (factory == null) { [EOL]         throw new NullPointerException("Wrapped ThreadFactory must not be null!"); [EOL]     } [EOL]     wrappedFactory = factory; [EOL]     return this; [EOL] }
@Override [EOL] public BasicThreadFactory build() { [EOL]     final BasicThreadFactory factory = new BasicThreadFactory(this); [EOL]     reset(); [EOL]     return factory; [EOL] }
public long getThreadCount() { [EOL]     return threadCounter.get(); [EOL] }
@Override [EOL] public BasicThreadFactory build() { [EOL]     final BasicThreadFactory factory = new BasicThreadFactory(this); [EOL]     reset(); [EOL]     return factory; [EOL] }
methods/lang3/concurrent/ConcurrentUtils.java
static Throwable checkedException(final Throwable ex) { [EOL]     if (ex != null && !(ex instanceof RuntimeException) && !(ex instanceof Error)) { [EOL]         return ex; [EOL]     } else { [EOL]         throw new IllegalArgumentException("Not a checked exception: " + ex); [EOL]     } [EOL] }
@Override [EOL] public T get(final long timeout, final TimeUnit unit) { [EOL]     return value; [EOL] }
public static ConcurrentException extractCause(final ExecutionException ex) { [EOL]     if (ex == null || ex.getCause() == null) { [EOL]         return null; [EOL]     } [EOL]     throwCause(ex); [EOL]     return new ConcurrentException(ex.getMessage(), ex.getCause()); [EOL] }
@Override [EOL] public boolean isCancelled() { [EOL]     return false; [EOL] }
public static void handleCause(final ExecutionException ex) throws ConcurrentException { [EOL]     final ConcurrentException cex = extractCause(ex); [EOL]     if (cex != null) { [EOL]         throw cex; [EOL]     } [EOL] }
public static void handleCauseUnchecked(final ExecutionException ex) { [EOL]     final ConcurrentRuntimeException crex = extractCauseUnchecked(ex); [EOL]     if (crex != null) { [EOL]         throw crex; [EOL]     } [EOL] }
@Override [EOL] public T get(final long timeout, final TimeUnit unit) { [EOL]     return value; [EOL] }
@Override [EOL] public boolean cancel(final boolean mayInterruptIfRunning) { [EOL]     return false; [EOL] }
@Override [EOL] public boolean isDone() { [EOL]     return true; [EOL] }
@Override [EOL] public T get(final long timeout, final TimeUnit unit) { [EOL]     return value; [EOL] }
public static <T> T initialize(final ConcurrentInitializer<T> initializer) throws ConcurrentException { [EOL]     return initializer != null ? initializer.get() : null; [EOL] }
@Override [EOL] public T get(final long timeout, final TimeUnit unit) { [EOL]     return value; [EOL] }
public static <K, V> V putIfAbsent(final ConcurrentMap<K, V> map, final K key, final V value) { [EOL]     if (map == null) { [EOL]         return null; [EOL]     } [EOL]     final V result = map.putIfAbsent(key, value); [EOL]     return result != null ? result : value; [EOL] }
public static <K, V> V createIfAbsent(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) throws ConcurrentException { [EOL]     if (map == null || init == null) { [EOL]         return null; [EOL]     } [EOL]     final V value = map.get(key); [EOL]     if (value == null) { [EOL]         return putIfAbsent(map, key, init.get()); [EOL]     } [EOL]     return value; [EOL] }
public static <K, V> V createIfAbsentUnchecked(final ConcurrentMap<K, V> map, final K key, final ConcurrentInitializer<V> init) { [EOL]     try { [EOL]         return createIfAbsent(map, key, init); [EOL]     } catch (final ConcurrentException cex) { [EOL]         throw new ConcurrentRuntimeException(cex.getCause()); [EOL]     } [EOL] }
methods/lang3/concurrent/ConcurrentException.java
methods/lang3/concurrent/AtomicInitializer.java
methods/lang3/text/StrBuilder.java
@Override [EOL] public int length() { [EOL]     return size; [EOL] }
public int capacity() { [EOL]     return buffer.length; [EOL] }
public int capacity() { [EOL]     return buffer.length; [EOL] }
public StrBuilder append(final double value) { [EOL]     return append(String.valueOf(value)); [EOL] }
public StrBuilder appendln(final double value) { [EOL]     return append(value).appendNewLine(); [EOL] }
public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) { [EOL]     return appendFixedWidthPadLeft(String.valueOf(value), width, padChar); [EOL] }
public String midString(int index, final int length) { [EOL]     if (index < 0) { [EOL]         index = 0; [EOL]     } [EOL]     if (length <= 0 || index >= size) { [EOL]         return ""; [EOL]     } [EOL]     if (size <= index + length) { [EOL]         return new String(buffer, index, size - index); [EOL]     } else { [EOL]         return new String(buffer, index, length); [EOL]     } [EOL] }
public int lastIndexOf(final StrMatcher matcher, int startIndex) { [EOL]     startIndex = (startIndex >= size ? size - 1 : startIndex); [EOL]     if (matcher == null || startIndex < 0) { [EOL]         return -1; [EOL]     } [EOL]     final char[] buf = buffer; [EOL]     final int endIndex = startIndex + 1; [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (matcher.isMatch(buf, i, 0, endIndex) > 0) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
@Override [EOL] public String build() { [EOL]     return toString(); [EOL] }
public int size() { [EOL]     return size; [EOL] }
public StrBuilder append(final double value) { [EOL]     return append(String.valueOf(value)); [EOL] }
public StrBuilder delete(final int startIndex, int endIndex) { [EOL]     endIndex = validateRange(startIndex, endIndex); [EOL]     final int len = endIndex - startIndex; [EOL]     if (len > 0) { [EOL]         deleteImpl(startIndex, endIndex, len); [EOL]     } [EOL]     return this; [EOL] }
public int lastIndexOf(final StrMatcher matcher, int startIndex) { [EOL]     startIndex = (startIndex >= size ? size - 1 : startIndex); [EOL]     if (matcher == null || startIndex < 0) { [EOL]         return -1; [EOL]     } [EOL]     final char[] buf = buffer; [EOL]     final int endIndex = startIndex + 1; [EOL]     for (int i = startIndex; i >= 0; i--) { [EOL]         if (matcher.isMatch(buf, i, 0, endIndex) > 0) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public boolean equalsIgnoreCase(final StrBuilder other) { [EOL]     if (this == other) { [EOL]         return true; [EOL]     } [EOL]     if (this.size != other.size) { [EOL]         return false; [EOL]     } [EOL]     final char[] thisBuf = this.buffer; [EOL]     final char[] otherBuf = other.buffer; [EOL]     for (int i = size - 1; i >= 0; i--) { [EOL]         final char c1 = thisBuf[i]; [EOL]         final char c2 = otherBuf[i]; [EOL]         if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof StrBuilder) { [EOL]         return equals((StrBuilder) obj); [EOL]     } [EOL]     return false; [EOL] }
public int size() { [EOL]     return size; [EOL] }
public boolean isEmpty() { [EOL]     return size == 0; [EOL] }
methods/lang3/text/StrTokenizer.java
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
public int size() { [EOL]     checkTokenized(); [EOL]     return tokens.length; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
public int size() { [EOL]     checkTokenized(); [EOL]     return tokens.length; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
public int size() { [EOL]     checkTokenized(); [EOL]     return tokens.length; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
@Override [EOL] public void set(final String obj) { [EOL]     throw new UnsupportedOperationException("set() is unsupported"); [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
public int size() { [EOL]     checkTokenized(); [EOL]     return tokens.length; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
@Override [EOL] public void add(final String obj) { [EOL]     throw new UnsupportedOperationException("add() is unsupported"); [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
protected List<String> tokenize(final char[] chars, final int offset, final int count) { [EOL]     if (chars == null || count == 0) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder(); [EOL]     final List<String> tokens = new ArrayList<String>(); [EOL]     int pos = offset; [EOL]     while (pos >= 0 && pos < count) { [EOL]         pos = readNextToken(chars, pos, count, buf, tokens); [EOL]         if (pos >= count) { [EOL]             addToken(tokens, ""); [EOL]         } [EOL]     } [EOL]     return tokens; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
public static StrTokenizer getCSVInstance(final char[] input) { [EOL]     final StrTokenizer tok = getCSVClone(); [EOL]     tok.reset(input); [EOL]     return tok; [EOL] }
public String previousToken() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public void set(final String obj) { [EOL]     throw new UnsupportedOperationException("set() is unsupported"); [EOL] }
public StrTokenizer setDelimiterChar(final char delim) { [EOL]     return setDelimiterMatcher(StrMatcher.charMatcher(delim)); [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
public static StrTokenizer getTSVInstance(final char[] input) { [EOL]     final StrTokenizer tok = getTSVClone(); [EOL]     tok.reset(input); [EOL]     return tok; [EOL] }
public String[] getTokenArray() { [EOL]     checkTokenized(); [EOL]     return tokens.clone(); [EOL] }
public int size() { [EOL]     checkTokenized(); [EOL]     return tokens.length; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
public boolean isIgnoreEmptyTokens() { [EOL]     return ignoreEmptyTokens; [EOL] }
public static StrTokenizer getTSVInstance(final char[] input) { [EOL]     final StrTokenizer tok = getTSVClone(); [EOL]     tok.reset(input); [EOL]     return tok; [EOL] }
@Override [EOL] public String previous() { [EOL]     if (hasPrevious()) { [EOL]         return tokens[--tokenPos]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int previousIndex() { [EOL]     return tokenPos - 1; [EOL] }
public static StrTokenizer getCSVInstance(final char[] input) { [EOL]     final StrTokenizer tok = getCSVClone(); [EOL]     tok.reset(input); [EOL]     return tok; [EOL] }
@Override [EOL] public String next() { [EOL]     if (hasNext()) { [EOL]         return tokens[tokenPos++]; [EOL]     } [EOL]     throw new NoSuchElementException(); [EOL] }
@Override [EOL] public int nextIndex() { [EOL]     return tokenPos; [EOL] }
public int size() { [EOL]     checkTokenized(); [EOL]     return tokens.length; [EOL] }
public boolean isEmptyTokenAsNull() { [EOL]     return this.emptyAsNull; [EOL] }
methods/lang3/text/StrSubstitutor.java
public String replace(final Object source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder().append(source); [EOL]     substitute(buf, 0, buf.length()); [EOL]     return buf.toString(); [EOL] }
public StrSubstitutor setVariablePrefix(final String prefix) { [EOL]     if (prefix == null) { [EOL]         throw new IllegalArgumentException("Variable prefix must not be null!"); [EOL]     } [EOL]     return setVariablePrefixMatcher(StrMatcher.stringMatcher(prefix)); [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher) { [EOL]     if (suffixMatcher == null) { [EOL]         throw new IllegalArgumentException("Variable suffix matcher must not be null!"); [EOL]     } [EOL]     this.suffixMatcher = suffixMatcher; [EOL]     return this; [EOL] }
public StrSubstitutor setVariableSuffix(final String suffix) { [EOL]     if (suffix == null) { [EOL]         throw new IllegalArgumentException("Variable suffix must not be null!"); [EOL]     } [EOL]     return setVariableSuffixMatcher(StrMatcher.stringMatcher(suffix)); [EOL] }
public boolean isEnableSubstitutionInVariables() { [EOL]     return enableSubstitutionInVariables; [EOL] }
public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables) { [EOL]     this.enableSubstitutionInVariables = enableSubstitutionInVariables; [EOL] }
public StrSubstitutor setVariableSuffix(final String suffix) { [EOL]     if (suffix == null) { [EOL]         throw new IllegalArgumentException("Variable suffix must not be null!"); [EOL]     } [EOL]     return setVariableSuffixMatcher(StrMatcher.stringMatcher(suffix)); [EOL] }
public boolean isEnableSubstitutionInVariables() { [EOL]     return enableSubstitutionInVariables; [EOL] }
public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables) { [EOL]     this.enableSubstitutionInVariables = enableSubstitutionInVariables; [EOL] }
public StrSubstitutor setVariableSuffix(final String suffix) { [EOL]     if (suffix == null) { [EOL]         throw new IllegalArgumentException("Variable suffix must not be null!"); [EOL]     } [EOL]     return setVariableSuffixMatcher(StrMatcher.stringMatcher(suffix)); [EOL] }
public boolean isEnableSubstitutionInVariables() { [EOL]     return enableSubstitutionInVariables; [EOL] }
public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables) { [EOL]     this.enableSubstitutionInVariables = enableSubstitutionInVariables; [EOL] }
public StrSubstitutor setVariablePrefix(final String prefix) { [EOL]     if (prefix == null) { [EOL]         throw new IllegalArgumentException("Variable prefix must not be null!"); [EOL]     } [EOL]     return setVariablePrefixMatcher(StrMatcher.stringMatcher(prefix)); [EOL] }
public boolean isEnableSubstitutionInVariables() { [EOL]     return enableSubstitutionInVariables; [EOL] }
public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables) { [EOL]     this.enableSubstitutionInVariables = enableSubstitutionInVariables; [EOL] }
public StrSubstitutor setVariablePrefix(final String prefix) { [EOL]     if (prefix == null) { [EOL]         throw new IllegalArgumentException("Variable prefix must not be null!"); [EOL]     } [EOL]     return setVariablePrefixMatcher(StrMatcher.stringMatcher(prefix)); [EOL] }
public boolean isEnableSubstitutionInVariables() { [EOL]     return enableSubstitutionInVariables; [EOL] }
public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables) { [EOL]     this.enableSubstitutionInVariables = enableSubstitutionInVariables; [EOL] }
protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos) { [EOL]     final StrLookup<?> resolver = getVariableResolver(); [EOL]     if (resolver == null) { [EOL]         return null; [EOL]     } [EOL]     return resolver.lookup(variableName); [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public String replace(final Object source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder().append(source); [EOL]     substitute(buf, 0, buf.length()); [EOL]     return buf.toString(); [EOL] }
public static String replaceSystemProperties(final Object source) { [EOL]     return new StrSubstitutor(StrLookup.systemPropertiesLookup()).replace(source); [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public String replace(final Object source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder().append(source); [EOL]     substitute(buf, 0, buf.length()); [EOL]     return buf.toString(); [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public String replace(final Object source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder().append(source); [EOL]     substitute(buf, 0, buf.length()); [EOL]     return buf.toString(); [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public String replace(final Object source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder().append(source); [EOL]     substitute(buf, 0, buf.length()); [EOL]     return buf.toString(); [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public String replace(final Object source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder().append(source); [EOL]     substitute(buf, 0, buf.length()); [EOL]     return buf.toString(); [EOL] }
public String replace(final Object source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder().append(source); [EOL]     substitute(buf, 0, buf.length()); [EOL]     return buf.toString(); [EOL] }
public boolean isEnableSubstitutionInVariables() { [EOL]     return enableSubstitutionInVariables; [EOL] }
public void setEnableSubstitutionInVariables(final boolean enableSubstitutionInVariables) { [EOL]     this.enableSubstitutionInVariables = enableSubstitutionInVariables; [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public StrLookup<?> getVariableResolver() { [EOL]     return this.variableResolver; [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public void setEscapeChar(final char escapeCharacter) { [EOL]     this.escapeChar = escapeCharacter; [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public StrSubstitutor setVariableSuffix(final String suffix) { [EOL]     if (suffix == null) { [EOL]         throw new IllegalArgumentException("Variable suffix must not be null!"); [EOL]     } [EOL]     return setVariableSuffixMatcher(StrMatcher.stringMatcher(suffix)); [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public StrSubstitutor setVariablePrefix(final String prefix) { [EOL]     if (prefix == null) { [EOL]         throw new IllegalArgumentException("Variable prefix must not be null!"); [EOL]     } [EOL]     return setVariablePrefixMatcher(StrMatcher.stringMatcher(prefix)); [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher) { [EOL]     if (prefixMatcher == null) { [EOL]         throw new IllegalArgumentException("Variable prefix matcher must not be null!"); [EOL]     } [EOL]     this.prefixMatcher = prefixMatcher; [EOL]     return this; [EOL] }
public StrSubstitutor setVariablePrefix(final String prefix) { [EOL]     if (prefix == null) { [EOL]         throw new IllegalArgumentException("Variable prefix must not be null!"); [EOL]     } [EOL]     return setVariablePrefixMatcher(StrMatcher.stringMatcher(prefix)); [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public StrMatcher getVariableSuffixMatcher() { [EOL]     return suffixMatcher; [EOL] }
public String replace(final Object source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder().append(source); [EOL]     substitute(buf, 0, buf.length()); [EOL]     return buf.toString(); [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public StrMatcher getVariablePrefixMatcher() { [EOL]     return prefixMatcher; [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public boolean isEnableSubstitutionInVariables() { [EOL]     return enableSubstitutionInVariables; [EOL] }

protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos) { [EOL]     final StrLookup<?> resolver = getVariableResolver(); [EOL]     if (resolver == null) { [EOL]         return null; [EOL]     } [EOL]     return resolver.lookup(variableName); [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public String replace(final Object source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder().append(source); [EOL]     substitute(buf, 0, buf.length()); [EOL]     return buf.toString(); [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public String replace(final Object source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder().append(source); [EOL]     substitute(buf, 0, buf.length()); [EOL]     return buf.toString(); [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public String replace(final Object source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder().append(source); [EOL]     substitute(buf, 0, buf.length()); [EOL]     return buf.toString(); [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public String replace(final Object source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder().append(source); [EOL]     substitute(buf, 0, buf.length()); [EOL]     return buf.toString(); [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public String replace(final Object source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder().append(source); [EOL]     substitute(buf, 0, buf.length()); [EOL]     return buf.toString(); [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public String replace(final Object source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder().append(source); [EOL]     substitute(buf, 0, buf.length()); [EOL]     return buf.toString(); [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public StrSubstitutor setVariableSuffix(final String suffix) { [EOL]     if (suffix == null) { [EOL]         throw new IllegalArgumentException("Variable suffix must not be null!"); [EOL]     } [EOL]     return setVariableSuffixMatcher(StrMatcher.stringMatcher(suffix)); [EOL] }

public String replace(final Object source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder().append(source); [EOL]     substitute(buf, 0, buf.length()); [EOL]     return buf.toString(); [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public char getEscapeChar() { [EOL]     return this.escapeChar; [EOL] }
public String replace(final Object source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder().append(source); [EOL]     substitute(buf, 0, buf.length()); [EOL]     return buf.toString(); [EOL] }
public static String replaceSystemProperties(final Object source) { [EOL]     return new StrSubstitutor(StrLookup.systemPropertiesLookup()).replace(source); [EOL] }
public String replace(final Object source) { [EOL]     if (source == null) { [EOL]         return null; [EOL]     } [EOL]     final StrBuilder buf = new StrBuilder().append(source); [EOL]     substitute(buf, 0, buf.length()); [EOL]     return buf.toString(); [EOL] }
methods/lang3/text/StrLookup.java
@Override [EOL] public String lookup(final String key) { [EOL]     if (map == null) { [EOL]         return null; [EOL]     } [EOL]     final Object obj = map.get(key); [EOL]     if (obj == null) { [EOL]         return null; [EOL]     } [EOL]     return obj.toString(); [EOL] }
@Override [EOL] public String lookup(final String key) { [EOL]     if (map == null) { [EOL]         return null; [EOL]     } [EOL]     final Object obj = map.get(key); [EOL]     if (obj == null) { [EOL]         return null; [EOL]     } [EOL]     return obj.toString(); [EOL] }
public static StrLookup<?> noneLookup() { [EOL]     return NONE_LOOKUP; [EOL] }
public static <V> StrLookup<V> mapLookup(final Map<String, V> map) { [EOL]     return new MapStrLookup<V>(map); [EOL] }
@Override [EOL] public String lookup(final String key) { [EOL]     if (map == null) { [EOL]         return null; [EOL]     } [EOL]     final Object obj = map.get(key); [EOL]     if (obj == null) { [EOL]         return null; [EOL]     } [EOL]     return obj.toString(); [EOL] }
methods/lang3/text/FormattableUtils.java
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) { [EOL]     Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision)); [EOL]     final StringBuilder buf = new StringBuilder(seq); [EOL]     if (precision >= 0 && precision < seq.length()) { [EOL]         final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY); [EOL]         buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString()); [EOL]     } [EOL]     final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY; [EOL]     for (int i = buf.length(); i < width; i++) { [EOL]         buf.insert(leftJustify ? i : 0, padChar); [EOL]     } [EOL]     formatter.format(buf.toString()); [EOL]     return formatter; [EOL] }
public static String toString(final Formattable formattable) { [EOL]     return String.format(SIMPLEST_FORMAT, formattable); [EOL] }
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) { [EOL]     Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision)); [EOL]     final StringBuilder buf = new StringBuilder(seq); [EOL]     if (precision >= 0 && precision < seq.length()) { [EOL]         final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY); [EOL]         buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString()); [EOL]     } [EOL]     final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY; [EOL]     for (int i = buf.length(); i < width; i++) { [EOL]         buf.insert(leftJustify ? i : 0, padChar); [EOL]     } [EOL]     formatter.format(buf.toString()); [EOL]     return formatter; [EOL] }
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) { [EOL]     Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision)); [EOL]     final StringBuilder buf = new StringBuilder(seq); [EOL]     if (precision >= 0 && precision < seq.length()) { [EOL]         final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY); [EOL]         buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString()); [EOL]     } [EOL]     final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY; [EOL]     for (int i = buf.length(); i < width; i++) { [EOL]         buf.insert(leftJustify ? i : 0, padChar); [EOL]     } [EOL]     formatter.format(buf.toString()); [EOL]     return formatter; [EOL] }
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) { [EOL]     Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision)); [EOL]     final StringBuilder buf = new StringBuilder(seq); [EOL]     if (precision >= 0 && precision < seq.length()) { [EOL]         final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY); [EOL]         buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString()); [EOL]     } [EOL]     final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY; [EOL]     for (int i = buf.length(); i < width; i++) { [EOL]         buf.insert(leftJustify ? i : 0, padChar); [EOL]     } [EOL]     formatter.format(buf.toString()); [EOL]     return formatter; [EOL] }
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) { [EOL]     Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision)); [EOL]     final StringBuilder buf = new StringBuilder(seq); [EOL]     if (precision >= 0 && precision < seq.length()) { [EOL]         final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY); [EOL]         buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString()); [EOL]     } [EOL]     final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY; [EOL]     for (int i = buf.length(); i < width; i++) { [EOL]         buf.insert(leftJustify ? i : 0, padChar); [EOL]     } [EOL]     formatter.format(buf.toString()); [EOL]     return formatter; [EOL] }
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) { [EOL]     Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision)); [EOL]     final StringBuilder buf = new StringBuilder(seq); [EOL]     if (precision >= 0 && precision < seq.length()) { [EOL]         final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY); [EOL]         buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString()); [EOL]     } [EOL]     final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY; [EOL]     for (int i = buf.length(); i < width; i++) { [EOL]         buf.insert(leftJustify ? i : 0, padChar); [EOL]     } [EOL]     formatter.format(buf.toString()); [EOL]     return formatter; [EOL] }
public static String toString(final Formattable formattable) { [EOL]     return String.format(SIMPLEST_FORMAT, formattable); [EOL] }
public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width, final int precision, final char padChar, final CharSequence ellipsis) { [EOL]     Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision, "Specified ellipsis '%1$s' exceeds precision of %2$s", ellipsis, Integer.valueOf(precision)); [EOL]     final StringBuilder buf = new StringBuilder(seq); [EOL]     if (precision >= 0 && precision < seq.length()) { [EOL]         final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY); [EOL]         buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString()); [EOL]     } [EOL]     final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY; [EOL]     for (int i = buf.length(); i < width; i++) { [EOL]         buf.insert(leftJustify ? i : 0, padChar); [EOL]     } [EOL]     formatter.format(buf.toString()); [EOL]     return formatter; [EOL] }
methods/lang3/text/ExtendedMessageFormat.java
@Override [EOL] public String toPattern() { [EOL]     return toPattern; [EOL] }
@Override [EOL] public String toPattern() { [EOL]     return toPattern; [EOL] }
@Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null) { [EOL]         return false; [EOL]     } [EOL]     if (!super.equals(obj)) { [EOL]         return false; [EOL]     } [EOL]     if (ObjectUtils.notEqual(getClass(), obj.getClass())) { [EOL]         return false; [EOL]     } [EOL]     final ExtendedMessageFormat rhs = (ExtendedMessageFormat) obj; [EOL]     if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) { [EOL]         return false; [EOL]     } [EOL]     if (ObjectUtils.notEqual(registry, rhs.registry)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public String toPattern() { [EOL]     return toPattern; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null) { [EOL]         return false; [EOL]     } [EOL]     if (!super.equals(obj)) { [EOL]         return false; [EOL]     } [EOL]     if (ObjectUtils.notEqual(getClass(), obj.getClass())) { [EOL]         return false; [EOL]     } [EOL]     final ExtendedMessageFormat rhs = (ExtendedMessageFormat) obj; [EOL]     if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) { [EOL]         return false; [EOL]     } [EOL]     if (ObjectUtils.notEqual(registry, rhs.registry)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
@Override [EOL] public String toPattern() { [EOL]     return toPattern; [EOL] }
@Override [EOL] public String toPattern() { [EOL]     return toPattern; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     int result = super.hashCode(); [EOL]     result = HASH_SEED * result + ObjectUtils.hashCode(registry); [EOL]     result = HASH_SEED * result + ObjectUtils.hashCode(toPattern); [EOL]     return result; [EOL] }
@Override [EOL] public String toPattern() { [EOL]     return toPattern; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null) { [EOL]         return false; [EOL]     } [EOL]     if (!super.equals(obj)) { [EOL]         return false; [EOL]     } [EOL]     if (ObjectUtils.notEqual(getClass(), obj.getClass())) { [EOL]         return false; [EOL]     } [EOL]     final ExtendedMessageFormat rhs = (ExtendedMessageFormat) obj; [EOL]     if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) { [EOL]         return false; [EOL]     } [EOL]     if (ObjectUtils.notEqual(registry, rhs.registry)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
methods/lang3/text/WordUtils.java
public static String initials(final String str, final char... delimiters) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     if (delimiters != null && delimiters.length == 0) { [EOL]         return ""; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     final char[] buf = new char[strLen / 2 + 1]; [EOL]     int count = 0; [EOL]     boolean lastWasGap = true; [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         final char ch = str.charAt(i); [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             lastWasGap = true; [EOL]         } else if (lastWasGap) { [EOL]             buf[count++] = ch; [EOL]             lastWasGap = false; [EOL]         } else { [EOL]             continue; [EOL]         } [EOL]     } [EOL]     return new String(buf, 0, count); [EOL] }
public static String initials(final String str, final char... delimiters) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     if (delimiters != null && delimiters.length == 0) { [EOL]         return ""; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     final char[] buf = new char[strLen / 2 + 1]; [EOL]     int count = 0; [EOL]     boolean lastWasGap = true; [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         final char ch = str.charAt(i); [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             lastWasGap = true; [EOL]         } else if (lastWasGap) { [EOL]             buf[count++] = ch; [EOL]             lastWasGap = false; [EOL]         } else { [EOL]             continue; [EOL]         } [EOL]     } [EOL]     return new String(buf, 0, count); [EOL] }
public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (newLineStr == null) { [EOL]         newLineStr = SystemUtils.LINE_SEPARATOR; [EOL]     } [EOL]     if (wrapLength < 1) { [EOL]         wrapLength = 1; [EOL]     } [EOL]     final int inputLineLength = str.length(); [EOL]     int offset = 0; [EOL]     final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32); [EOL]     while (inputLineLength - offset > wrapLength) { [EOL]         if (str.charAt(offset) == ' ') { [EOL]             offset++; [EOL]             continue; [EOL]         } [EOL]         int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset); [EOL]         if (spaceToWrapAt >= offset) { [EOL]             wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]             wrappedLine.append(newLineStr); [EOL]             offset = spaceToWrapAt + 1; [EOL]         } else { [EOL]             if (wrapLongWords) { [EOL]                 wrappedLine.append(str.substring(offset, wrapLength + offset)); [EOL]                 wrappedLine.append(newLineStr); [EOL]                 offset += wrapLength; [EOL]             } else { [EOL]                 spaceToWrapAt = str.indexOf(' ', wrapLength + offset); [EOL]                 if (spaceToWrapAt >= 0) { [EOL]                     wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]                     wrappedLine.append(newLineStr); [EOL]                     offset = spaceToWrapAt + 1; [EOL]                 } else { [EOL]                     wrappedLine.append(str.substring(offset)); [EOL]                     offset = inputLineLength; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     wrappedLine.append(str.substring(offset)); [EOL]     return wrappedLine.toString(); [EOL] }
public static String capitalize(final String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean capitalizeNext = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             capitalizeNext = true; [EOL]         } else if (capitalizeNext) { [EOL]             buffer[i] = Character.toTitleCase(ch); [EOL]             capitalizeNext = false; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String uncapitalize(final String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean uncapitalizeNext = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             uncapitalizeNext = true; [EOL]         } else if (uncapitalizeNext) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]             uncapitalizeNext = false; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String capitalize(final String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean capitalizeNext = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             capitalizeNext = true; [EOL]         } else if (capitalizeNext) { [EOL]             buffer[i] = Character.toTitleCase(ch); [EOL]             capitalizeNext = false; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String uncapitalize(final String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean uncapitalizeNext = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             uncapitalizeNext = true; [EOL]         } else if (uncapitalizeNext) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]             uncapitalizeNext = false; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String capitalize(final String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean capitalizeNext = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             capitalizeNext = true; [EOL]         } else if (capitalizeNext) { [EOL]             buffer[i] = Character.toTitleCase(ch); [EOL]             capitalizeNext = false; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String uncapitalize(final String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean uncapitalizeNext = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             uncapitalizeNext = true; [EOL]         } else if (uncapitalizeNext) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]             uncapitalizeNext = false; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String capitalize(final String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean capitalizeNext = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             capitalizeNext = true; [EOL]         } else if (capitalizeNext) { [EOL]             buffer[i] = Character.toTitleCase(ch); [EOL]             capitalizeNext = false; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String capitalizeFully(String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     str = str.toLowerCase(); [EOL]     return capitalize(str, delimiters); [EOL] }
public static String capitalize(final String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean capitalizeNext = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             capitalizeNext = true; [EOL]         } else if (capitalizeNext) { [EOL]             buffer[i] = Character.toTitleCase(ch); [EOL]             capitalizeNext = false; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String capitalize(final String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean capitalizeNext = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             capitalizeNext = true; [EOL]         } else if (capitalizeNext) { [EOL]             buffer[i] = Character.toTitleCase(ch); [EOL]             capitalizeNext = false; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String capitalize(final String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean capitalizeNext = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             capitalizeNext = true; [EOL]         } else if (capitalizeNext) { [EOL]             buffer[i] = Character.toTitleCase(ch); [EOL]             capitalizeNext = false; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (newLineStr == null) { [EOL]         newLineStr = SystemUtils.LINE_SEPARATOR; [EOL]     } [EOL]     if (wrapLength < 1) { [EOL]         wrapLength = 1; [EOL]     } [EOL]     final int inputLineLength = str.length(); [EOL]     int offset = 0; [EOL]     final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32); [EOL]     while (inputLineLength - offset > wrapLength) { [EOL]         if (str.charAt(offset) == ' ') { [EOL]             offset++; [EOL]             continue; [EOL]         } [EOL]         int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset); [EOL]         if (spaceToWrapAt >= offset) { [EOL]             wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]             wrappedLine.append(newLineStr); [EOL]             offset = spaceToWrapAt + 1; [EOL]         } else { [EOL]             if (wrapLongWords) { [EOL]                 wrappedLine.append(str.substring(offset, wrapLength + offset)); [EOL]                 wrappedLine.append(newLineStr); [EOL]                 offset += wrapLength; [EOL]             } else { [EOL]                 spaceToWrapAt = str.indexOf(' ', wrapLength + offset); [EOL]                 if (spaceToWrapAt >= 0) { [EOL]                     wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]                     wrappedLine.append(newLineStr); [EOL]                     offset = spaceToWrapAt + 1; [EOL]                 } else { [EOL]                     wrappedLine.append(str.substring(offset)); [EOL]                     offset = inputLineLength; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     wrappedLine.append(str.substring(offset)); [EOL]     return wrappedLine.toString(); [EOL] }
public static String initials(final String str, final char... delimiters) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     if (delimiters != null && delimiters.length == 0) { [EOL]         return ""; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     final char[] buf = new char[strLen / 2 + 1]; [EOL]     int count = 0; [EOL]     boolean lastWasGap = true; [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         final char ch = str.charAt(i); [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             lastWasGap = true; [EOL]         } else if (lastWasGap) { [EOL]             buf[count++] = ch; [EOL]             lastWasGap = false; [EOL]         } else { [EOL]             continue; [EOL]         } [EOL]     } [EOL]     return new String(buf, 0, count); [EOL] }
public static String initials(final String str, final char... delimiters) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     if (delimiters != null && delimiters.length == 0) { [EOL]         return ""; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     final char[] buf = new char[strLen / 2 + 1]; [EOL]     int count = 0; [EOL]     boolean lastWasGap = true; [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         final char ch = str.charAt(i); [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             lastWasGap = true; [EOL]         } else if (lastWasGap) { [EOL]             buf[count++] = ch; [EOL]             lastWasGap = false; [EOL]         } else { [EOL]             continue; [EOL]         } [EOL]     } [EOL]     return new String(buf, 0, count); [EOL] }
public static String swapCase(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean whitespace = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (Character.isUpperCase(ch)) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]             whitespace = false; [EOL]         } else if (Character.isTitleCase(ch)) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]             whitespace = false; [EOL]         } else if (Character.isLowerCase(ch)) { [EOL]             if (whitespace) { [EOL]                 buffer[i] = Character.toTitleCase(ch); [EOL]                 whitespace = false; [EOL]             } else { [EOL]                 buffer[i] = Character.toUpperCase(ch); [EOL]             } [EOL]         } else { [EOL]             whitespace = Character.isWhitespace(ch); [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String swapCase(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean whitespace = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (Character.isUpperCase(ch)) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]             whitespace = false; [EOL]         } else if (Character.isTitleCase(ch)) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]             whitespace = false; [EOL]         } else if (Character.isLowerCase(ch)) { [EOL]             if (whitespace) { [EOL]                 buffer[i] = Character.toTitleCase(ch); [EOL]                 whitespace = false; [EOL]             } else { [EOL]                 buffer[i] = Character.toUpperCase(ch); [EOL]             } [EOL]         } else { [EOL]             whitespace = Character.isWhitespace(ch); [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String capitalize(final String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean capitalizeNext = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             capitalizeNext = true; [EOL]         } else if (capitalizeNext) { [EOL]             buffer[i] = Character.toTitleCase(ch); [EOL]             capitalizeNext = false; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String uncapitalize(final String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean uncapitalizeNext = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             uncapitalizeNext = true; [EOL]         } else if (uncapitalizeNext) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]             uncapitalizeNext = false; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String capitalize(final String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean capitalizeNext = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             capitalizeNext = true; [EOL]         } else if (capitalizeNext) { [EOL]             buffer[i] = Character.toTitleCase(ch); [EOL]             capitalizeNext = false; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String uncapitalize(final String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean uncapitalizeNext = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             uncapitalizeNext = true; [EOL]         } else if (uncapitalizeNext) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]             uncapitalizeNext = false; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String capitalize(final String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean capitalizeNext = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             capitalizeNext = true; [EOL]         } else if (capitalizeNext) { [EOL]             buffer[i] = Character.toTitleCase(ch); [EOL]             capitalizeNext = false; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String capitalizeFully(String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     str = str.toLowerCase(); [EOL]     return capitalize(str, delimiters); [EOL] }
public static String capitalize(final String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean capitalizeNext = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             capitalizeNext = true; [EOL]         } else if (capitalizeNext) { [EOL]             buffer[i] = Character.toTitleCase(ch); [EOL]             capitalizeNext = false; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String capitalizeFully(String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     str = str.toLowerCase(); [EOL]     return capitalize(str, delimiters); [EOL] }
public static String capitalize(final String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean capitalizeNext = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             capitalizeNext = true; [EOL]         } else if (capitalizeNext) { [EOL]             buffer[i] = Character.toTitleCase(ch); [EOL]             capitalizeNext = false; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String capitalize(final String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean capitalizeNext = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             capitalizeNext = true; [EOL]         } else if (capitalizeNext) { [EOL]             buffer[i] = Character.toTitleCase(ch); [EOL]             capitalizeNext = false; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (newLineStr == null) { [EOL]         newLineStr = SystemUtils.LINE_SEPARATOR; [EOL]     } [EOL]     if (wrapLength < 1) { [EOL]         wrapLength = 1; [EOL]     } [EOL]     final int inputLineLength = str.length(); [EOL]     int offset = 0; [EOL]     final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32); [EOL]     while (inputLineLength - offset > wrapLength) { [EOL]         if (str.charAt(offset) == ' ') { [EOL]             offset++; [EOL]             continue; [EOL]         } [EOL]         int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset); [EOL]         if (spaceToWrapAt >= offset) { [EOL]             wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]             wrappedLine.append(newLineStr); [EOL]             offset = spaceToWrapAt + 1; [EOL]         } else { [EOL]             if (wrapLongWords) { [EOL]                 wrappedLine.append(str.substring(offset, wrapLength + offset)); [EOL]                 wrappedLine.append(newLineStr); [EOL]                 offset += wrapLength; [EOL]             } else { [EOL]                 spaceToWrapAt = str.indexOf(' ', wrapLength + offset); [EOL]                 if (spaceToWrapAt >= 0) { [EOL]                     wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]                     wrappedLine.append(newLineStr); [EOL]                     offset = spaceToWrapAt + 1; [EOL]                 } else { [EOL]                     wrappedLine.append(str.substring(offset)); [EOL]                     offset = inputLineLength; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     wrappedLine.append(str.substring(offset)); [EOL]     return wrappedLine.toString(); [EOL] }
public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (newLineStr == null) { [EOL]         newLineStr = SystemUtils.LINE_SEPARATOR; [EOL]     } [EOL]     if (wrapLength < 1) { [EOL]         wrapLength = 1; [EOL]     } [EOL]     final int inputLineLength = str.length(); [EOL]     int offset = 0; [EOL]     final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32); [EOL]     while (inputLineLength - offset > wrapLength) { [EOL]         if (str.charAt(offset) == ' ') { [EOL]             offset++; [EOL]             continue; [EOL]         } [EOL]         int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset); [EOL]         if (spaceToWrapAt >= offset) { [EOL]             wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]             wrappedLine.append(newLineStr); [EOL]             offset = spaceToWrapAt + 1; [EOL]         } else { [EOL]             if (wrapLongWords) { [EOL]                 wrappedLine.append(str.substring(offset, wrapLength + offset)); [EOL]                 wrappedLine.append(newLineStr); [EOL]                 offset += wrapLength; [EOL]             } else { [EOL]                 spaceToWrapAt = str.indexOf(' ', wrapLength + offset); [EOL]                 if (spaceToWrapAt >= 0) { [EOL]                     wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]                     wrappedLine.append(newLineStr); [EOL]                     offset = spaceToWrapAt + 1; [EOL]                 } else { [EOL]                     wrappedLine.append(str.substring(offset)); [EOL]                     offset = inputLineLength; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     wrappedLine.append(str.substring(offset)); [EOL]     return wrappedLine.toString(); [EOL] }
public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (newLineStr == null) { [EOL]         newLineStr = SystemUtils.LINE_SEPARATOR; [EOL]     } [EOL]     if (wrapLength < 1) { [EOL]         wrapLength = 1; [EOL]     } [EOL]     final int inputLineLength = str.length(); [EOL]     int offset = 0; [EOL]     final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32); [EOL]     while (inputLineLength - offset > wrapLength) { [EOL]         if (str.charAt(offset) == ' ') { [EOL]             offset++; [EOL]             continue; [EOL]         } [EOL]         int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset); [EOL]         if (spaceToWrapAt >= offset) { [EOL]             wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]             wrappedLine.append(newLineStr); [EOL]             offset = spaceToWrapAt + 1; [EOL]         } else { [EOL]             if (wrapLongWords) { [EOL]                 wrappedLine.append(str.substring(offset, wrapLength + offset)); [EOL]                 wrappedLine.append(newLineStr); [EOL]                 offset += wrapLength; [EOL]             } else { [EOL]                 spaceToWrapAt = str.indexOf(' ', wrapLength + offset); [EOL]                 if (spaceToWrapAt >= 0) { [EOL]                     wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]                     wrappedLine.append(newLineStr); [EOL]                     offset = spaceToWrapAt + 1; [EOL]                 } else { [EOL]                     wrappedLine.append(str.substring(offset)); [EOL]                     offset = inputLineLength; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     wrappedLine.append(str.substring(offset)); [EOL]     return wrappedLine.toString(); [EOL] }
public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (newLineStr == null) { [EOL]         newLineStr = SystemUtils.LINE_SEPARATOR; [EOL]     } [EOL]     if (wrapLength < 1) { [EOL]         wrapLength = 1; [EOL]     } [EOL]     final int inputLineLength = str.length(); [EOL]     int offset = 0; [EOL]     final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32); [EOL]     while (inputLineLength - offset > wrapLength) { [EOL]         if (str.charAt(offset) == ' ') { [EOL]             offset++; [EOL]             continue; [EOL]         } [EOL]         int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset); [EOL]         if (spaceToWrapAt >= offset) { [EOL]             wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]             wrappedLine.append(newLineStr); [EOL]             offset = spaceToWrapAt + 1; [EOL]         } else { [EOL]             if (wrapLongWords) { [EOL]                 wrappedLine.append(str.substring(offset, wrapLength + offset)); [EOL]                 wrappedLine.append(newLineStr); [EOL]                 offset += wrapLength; [EOL]             } else { [EOL]                 spaceToWrapAt = str.indexOf(' ', wrapLength + offset); [EOL]                 if (spaceToWrapAt >= 0) { [EOL]                     wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]                     wrappedLine.append(newLineStr); [EOL]                     offset = spaceToWrapAt + 1; [EOL]                 } else { [EOL]                     wrappedLine.append(str.substring(offset)); [EOL]                     offset = inputLineLength; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     wrappedLine.append(str.substring(offset)); [EOL]     return wrappedLine.toString(); [EOL] }
public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (newLineStr == null) { [EOL]         newLineStr = SystemUtils.LINE_SEPARATOR; [EOL]     } [EOL]     if (wrapLength < 1) { [EOL]         wrapLength = 1; [EOL]     } [EOL]     final int inputLineLength = str.length(); [EOL]     int offset = 0; [EOL]     final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32); [EOL]     while (inputLineLength - offset > wrapLength) { [EOL]         if (str.charAt(offset) == ' ') { [EOL]             offset++; [EOL]             continue; [EOL]         } [EOL]         int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset); [EOL]         if (spaceToWrapAt >= offset) { [EOL]             wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]             wrappedLine.append(newLineStr); [EOL]             offset = spaceToWrapAt + 1; [EOL]         } else { [EOL]             if (wrapLongWords) { [EOL]                 wrappedLine.append(str.substring(offset, wrapLength + offset)); [EOL]                 wrappedLine.append(newLineStr); [EOL]                 offset += wrapLength; [EOL]             } else { [EOL]                 spaceToWrapAt = str.indexOf(' ', wrapLength + offset); [EOL]                 if (spaceToWrapAt >= 0) { [EOL]                     wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]                     wrappedLine.append(newLineStr); [EOL]                     offset = spaceToWrapAt + 1; [EOL]                 } else { [EOL]                     wrappedLine.append(str.substring(offset)); [EOL]                     offset = inputLineLength; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     wrappedLine.append(str.substring(offset)); [EOL]     return wrappedLine.toString(); [EOL] }
public static String initials(final String str, final char... delimiters) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return str; [EOL]     } [EOL]     if (delimiters != null && delimiters.length == 0) { [EOL]         return ""; [EOL]     } [EOL]     final int strLen = str.length(); [EOL]     final char[] buf = new char[strLen / 2 + 1]; [EOL]     int count = 0; [EOL]     boolean lastWasGap = true; [EOL]     for (int i = 0; i < strLen; i++) { [EOL]         final char ch = str.charAt(i); [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             lastWasGap = true; [EOL]         } else if (lastWasGap) { [EOL]             buf[count++] = ch; [EOL]             lastWasGap = false; [EOL]         } else { [EOL]             continue; [EOL]         } [EOL]     } [EOL]     return new String(buf, 0, count); [EOL] }
public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) { [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     if (newLineStr == null) { [EOL]         newLineStr = SystemUtils.LINE_SEPARATOR; [EOL]     } [EOL]     if (wrapLength < 1) { [EOL]         wrapLength = 1; [EOL]     } [EOL]     final int inputLineLength = str.length(); [EOL]     int offset = 0; [EOL]     final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32); [EOL]     while (inputLineLength - offset > wrapLength) { [EOL]         if (str.charAt(offset) == ' ') { [EOL]             offset++; [EOL]             continue; [EOL]         } [EOL]         int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset); [EOL]         if (spaceToWrapAt >= offset) { [EOL]             wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]             wrappedLine.append(newLineStr); [EOL]             offset = spaceToWrapAt + 1; [EOL]         } else { [EOL]             if (wrapLongWords) { [EOL]                 wrappedLine.append(str.substring(offset, wrapLength + offset)); [EOL]                 wrappedLine.append(newLineStr); [EOL]                 offset += wrapLength; [EOL]             } else { [EOL]                 spaceToWrapAt = str.indexOf(' ', wrapLength + offset); [EOL]                 if (spaceToWrapAt >= 0) { [EOL]                     wrappedLine.append(str.substring(offset, spaceToWrapAt)); [EOL]                     wrappedLine.append(newLineStr); [EOL]                     offset = spaceToWrapAt + 1; [EOL]                 } else { [EOL]                     wrappedLine.append(str.substring(offset)); [EOL]                     offset = inputLineLength; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     wrappedLine.append(str.substring(offset)); [EOL]     return wrappedLine.toString(); [EOL] }
public static String capitalize(final String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean capitalizeNext = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             capitalizeNext = true; [EOL]         } else if (capitalizeNext) { [EOL]             buffer[i] = Character.toTitleCase(ch); [EOL]             capitalizeNext = false; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String uncapitalize(final String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean uncapitalizeNext = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             uncapitalizeNext = true; [EOL]         } else if (uncapitalizeNext) { [EOL]             buffer[i] = Character.toLowerCase(ch); [EOL]             uncapitalizeNext = false; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String capitalize(final String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean capitalizeNext = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             capitalizeNext = true; [EOL]         } else if (capitalizeNext) { [EOL]             buffer[i] = Character.toTitleCase(ch); [EOL]             capitalizeNext = false; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
public static String capitalizeFully(String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     str = str.toLowerCase(); [EOL]     return capitalize(str, delimiters); [EOL] }
public static String capitalize(final String str, final char... delimiters) { [EOL]     final int delimLen = delimiters == null ? -1 : delimiters.length; [EOL]     if (StringUtils.isEmpty(str) || delimLen == 0) { [EOL]         return str; [EOL]     } [EOL]     final char[] buffer = str.toCharArray(); [EOL]     boolean capitalizeNext = true; [EOL]     for (int i = 0; i < buffer.length; i++) { [EOL]         final char ch = buffer[i]; [EOL]         if (isDelimiter(ch, delimiters)) { [EOL]             capitalizeNext = true; [EOL]         } else if (capitalizeNext) { [EOL]             buffer[i] = Character.toTitleCase(ch); [EOL]             capitalizeNext = false; [EOL]         } [EOL]     } [EOL]     return new String(buffer); [EOL] }
methods/lang3/text/StrMatcher.java
@Override [EOL] public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) { [EOL]     return buffer[pos] <= 32 ? 1 : 0; [EOL] }
public static StrMatcher stringMatcher(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return NONE_MATCHER; [EOL]     } [EOL]     return new StringMatcher(str); [EOL] }
@Override [EOL] public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) { [EOL]     return buffer[pos] <= 32 ? 1 : 0; [EOL] }
public static StrMatcher stringMatcher(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return NONE_MATCHER; [EOL]     } [EOL]     return new StringMatcher(str); [EOL] }
@Override [EOL] public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) { [EOL]     return buffer[pos] <= 32 ? 1 : 0; [EOL] }
public static StrMatcher singleQuoteMatcher() { [EOL]     return SINGLE_QUOTE_MATCHER; [EOL] }
@Override [EOL] public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) { [EOL]     return buffer[pos] <= 32 ? 1 : 0; [EOL] }
@Override [EOL] public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) { [EOL]     return buffer[pos] <= 32 ? 1 : 0; [EOL] }
public static StrMatcher trimMatcher() { [EOL]     return TRIM_MATCHER; [EOL] }
@Override [EOL] public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) { [EOL]     return buffer[pos] <= 32 ? 1 : 0; [EOL] }
@Override [EOL] public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) { [EOL]     return buffer[pos] <= 32 ? 1 : 0; [EOL] }
@Override [EOL] public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) { [EOL]     return buffer[pos] <= 32 ? 1 : 0; [EOL] }
@Override [EOL] public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) { [EOL]     return buffer[pos] <= 32 ? 1 : 0; [EOL] }

public static StrMatcher spaceMatcher() { [EOL]     return SPACE_MATCHER; [EOL] }
@Override [EOL] public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) { [EOL]     return buffer[pos] <= 32 ? 1 : 0; [EOL] }
@Override [EOL] public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) { [EOL]     return buffer[pos] <= 32 ? 1 : 0; [EOL] }
public static StrMatcher stringMatcher(final String str) { [EOL]     if (StringUtils.isEmpty(str)) { [EOL]         return NONE_MATCHER; [EOL]     } [EOL]     return new StringMatcher(str); [EOL] }
public static StrMatcher charSetMatcher(final String chars) { [EOL]     if (StringUtils.isEmpty(chars)) { [EOL]         return NONE_MATCHER; [EOL]     } [EOL]     if (chars.length() == 1) { [EOL]         return new CharMatcher(chars.charAt(0)); [EOL]     } [EOL]     return new CharSetMatcher(chars.toCharArray()); [EOL] }
public static StrMatcher charSetMatcher(final String chars) { [EOL]     if (StringUtils.isEmpty(chars)) { [EOL]         return NONE_MATCHER; [EOL]     } [EOL]     if (chars.length() == 1) { [EOL]         return new CharMatcher(chars.charAt(0)); [EOL]     } [EOL]     return new CharSetMatcher(chars.toCharArray()); [EOL] }
public static StrMatcher charSetMatcher(final String chars) { [EOL]     if (StringUtils.isEmpty(chars)) { [EOL]         return NONE_MATCHER; [EOL]     } [EOL]     if (chars.length() == 1) { [EOL]         return new CharMatcher(chars.charAt(0)); [EOL]     } [EOL]     return new CharSetMatcher(chars.toCharArray()); [EOL] }
public static StrMatcher charSetMatcher(final String chars) { [EOL]     if (StringUtils.isEmpty(chars)) { [EOL]         return NONE_MATCHER; [EOL]     } [EOL]     if (chars.length() == 1) { [EOL]         return new CharMatcher(chars.charAt(0)); [EOL]     } [EOL]     return new CharSetMatcher(chars.toCharArray()); [EOL] }
public static StrMatcher charSetMatcher(final String chars) { [EOL]     if (StringUtils.isEmpty(chars)) { [EOL]         return NONE_MATCHER; [EOL]     } [EOL]     if (chars.length() == 1) { [EOL]         return new CharMatcher(chars.charAt(0)); [EOL]     } [EOL]     return new CharSetMatcher(chars.toCharArray()); [EOL] }
public static StrMatcher charSetMatcher(final String chars) { [EOL]     if (StringUtils.isEmpty(chars)) { [EOL]         return NONE_MATCHER; [EOL]     } [EOL]     if (chars.length() == 1) { [EOL]         return new CharMatcher(chars.charAt(0)); [EOL]     } [EOL]     return new CharSetMatcher(chars.toCharArray()); [EOL] }
public static StrMatcher doubleQuoteMatcher() { [EOL]     return DOUBLE_QUOTE_MATCHER; [EOL] }
public static StrMatcher splitMatcher() { [EOL]     return SPLIT_MATCHER; [EOL] }
public static StrMatcher quoteMatcher() { [EOL]     return QUOTE_MATCHER; [EOL] }
@Override [EOL] public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) { [EOL]     return buffer[pos] <= 32 ? 1 : 0; [EOL] }
public static StrMatcher commaMatcher() { [EOL]     return COMMA_MATCHER; [EOL] }
public static StrMatcher trimMatcher() { [EOL]     return TRIM_MATCHER; [EOL] }
@Override [EOL] public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) { [EOL]     return buffer[pos] <= 32 ? 1 : 0; [EOL] }
public static StrMatcher noneMatcher() { [EOL]     return NONE_MATCHER; [EOL] }
@Override [EOL] public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) { [EOL]     return buffer[pos] <= 32 ? 1 : 0; [EOL] }
public static StrMatcher charSetMatcher(final String chars) { [EOL]     if (StringUtils.isEmpty(chars)) { [EOL]         return NONE_MATCHER; [EOL]     } [EOL]     if (chars.length() == 1) { [EOL]         return new CharMatcher(chars.charAt(0)); [EOL]     } [EOL]     return new CharSetMatcher(chars.toCharArray()); [EOL] }
methods/lang3/text/translate/LookupTranslator.java
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     int max = longest; [EOL]     if (index + longest > input.length()) { [EOL]         max = input.length() - index; [EOL]     } [EOL]     for (int i = max; i >= shortest; i--) { [EOL]         final CharSequence subSeq = input.subSequence(index, index + i); [EOL]         final CharSequence result = lookupMap.get(subSeq.toString()); [EOL]         if (result != null) { [EOL]             out.write(result.toString()); [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     int max = longest; [EOL]     if (index + longest > input.length()) { [EOL]         max = input.length() - index; [EOL]     } [EOL]     for (int i = max; i >= shortest; i--) { [EOL]         final CharSequence subSeq = input.subSequence(index, index + i); [EOL]         final CharSequence result = lookupMap.get(subSeq.toString()); [EOL]         if (result != null) { [EOL]             out.write(result.toString()); [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     int max = longest; [EOL]     if (index + longest > input.length()) { [EOL]         max = input.length() - index; [EOL]     } [EOL]     for (int i = max; i >= shortest; i--) { [EOL]         final CharSequence subSeq = input.subSequence(index, index + i); [EOL]         final CharSequence result = lookupMap.get(subSeq.toString()); [EOL]         if (result != null) { [EOL]             out.write(result.toString()); [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     int max = longest; [EOL]     if (index + longest > input.length()) { [EOL]         max = input.length() - index; [EOL]     } [EOL]     for (int i = max; i >= shortest; i--) { [EOL]         final CharSequence subSeq = input.subSequence(index, index + i); [EOL]         final CharSequence result = lookupMap.get(subSeq.toString()); [EOL]         if (result != null) { [EOL]             out.write(result.toString()); [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
methods/lang3/text/translate/OctalUnescaper.java
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1))) { [EOL]         final int start = index + 1; [EOL]         int end = index + 2; [EOL]         while (end < input.length() && Character.isDigit(input.charAt(end))) { [EOL]             end++; [EOL]             if (Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) { [EOL]                 end--; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         out.write(Integer.parseInt(input.subSequence(start, end).toString(), 8)); [EOL]         return 1 + end - start; [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1))) { [EOL]         final int start = index + 1; [EOL]         int end = index + 2; [EOL]         while (end < input.length() && Character.isDigit(input.charAt(end))) { [EOL]             end++; [EOL]             if (Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) { [EOL]                 end--; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         out.write(Integer.parseInt(input.subSequence(start, end).toString(), 8)); [EOL]         return 1 + end - start; [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1))) { [EOL]         final int start = index + 1; [EOL]         int end = index + 2; [EOL]         while (end < input.length() && Character.isDigit(input.charAt(end))) { [EOL]             end++; [EOL]             if (Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) { [EOL]                 end--; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         out.write(Integer.parseInt(input.subSequence(start, end).toString(), 8)); [EOL]         return 1 + end - start; [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1))) { [EOL]         final int start = index + 1; [EOL]         int end = index + 2; [EOL]         while (end < input.length() && Character.isDigit(input.charAt(end))) { [EOL]             end++; [EOL]             if (Integer.parseInt(input.subSequence(start, end).toString(), 10) > OCTAL_MAX) { [EOL]                 end--; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         out.write(Integer.parseInt(input.subSequence(start, end).toString(), 8)); [EOL]         return 1 + end - start; [EOL]     } [EOL]     return 0; [EOL] }
methods/lang3/text/translate/NumericEntityEscaper.java
public static NumericEntityEscaper between(final int codepointLow, final int codepointHigh) { [EOL]     return new NumericEntityEscaper(codepointLow, codepointHigh, true); [EOL] }
@Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     out.write("&#"); [EOL]     out.write(Integer.toString(codepoint, 10)); [EOL]     out.write(';'); [EOL]     return true; [EOL] }
public static NumericEntityEscaper above(final int codepoint) { [EOL]     return outsideOf(0, codepoint); [EOL] }
@Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     out.write("&#"); [EOL]     out.write(Integer.toString(codepoint, 10)); [EOL]     out.write(';'); [EOL]     return true; [EOL] }
public static NumericEntityEscaper outsideOf(final int codepointLow, final int codepointHigh) { [EOL]     return new NumericEntityEscaper(codepointLow, codepointHigh, false); [EOL] }
@Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     out.write("&#"); [EOL]     out.write(Integer.toString(codepoint, 10)); [EOL]     out.write(';'); [EOL]     return true; [EOL] }
public static NumericEntityEscaper between(final int codepointLow, final int codepointHigh) { [EOL]     return new NumericEntityEscaper(codepointLow, codepointHigh, true); [EOL] }
@Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     out.write("&#"); [EOL]     out.write(Integer.toString(codepoint, 10)); [EOL]     out.write(';'); [EOL]     return true; [EOL] }
public static NumericEntityEscaper between(final int codepointLow, final int codepointHigh) { [EOL]     return new NumericEntityEscaper(codepointLow, codepointHigh, true); [EOL] }
@Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     out.write("&#"); [EOL]     out.write(Integer.toString(codepoint, 10)); [EOL]     out.write(';'); [EOL]     return true; [EOL] }
public static NumericEntityEscaper above(final int codepoint) { [EOL]     return outsideOf(0, codepoint); [EOL] }
@Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     out.write("&#"); [EOL]     out.write(Integer.toString(codepoint, 10)); [EOL]     out.write(';'); [EOL]     return true; [EOL] }
public static NumericEntityEscaper below(final int codepoint) { [EOL]     return outsideOf(codepoint, Integer.MAX_VALUE); [EOL] }
methods/lang3/text/translate/UnicodeUnescaper.java
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') { [EOL]         int i = 2; [EOL]         while (index + i < input.length() && input.charAt(index + i) == 'u') { [EOL]             i++; [EOL]         } [EOL]         if (index + i < input.length() && input.charAt(index + i) == '+') { [EOL]             i++; [EOL]         } [EOL]         if (index + i + 4 <= input.length()) { [EOL]             final CharSequence unicode = input.subSequence(index + i, index + i + 4); [EOL]             try { [EOL]                 final int value = Integer.parseInt(unicode.toString(), 16); [EOL]                 out.write((char) value); [EOL]             } catch (final NumberFormatException nfe) { [EOL]                 throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [EOL]             } [EOL]             return i + 4; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence"); [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') { [EOL]         int i = 2; [EOL]         while (index + i < input.length() && input.charAt(index + i) == 'u') { [EOL]             i++; [EOL]         } [EOL]         if (index + i < input.length() && input.charAt(index + i) == '+') { [EOL]             i++; [EOL]         } [EOL]         if (index + i + 4 <= input.length()) { [EOL]             final CharSequence unicode = input.subSequence(index + i, index + i + 4); [EOL]             try { [EOL]                 final int value = Integer.parseInt(unicode.toString(), 16); [EOL]                 out.write((char) value); [EOL]             } catch (final NumberFormatException nfe) { [EOL]                 throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [EOL]             } [EOL]             return i + 4; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence"); [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') { [EOL]         int i = 2; [EOL]         while (index + i < input.length() && input.charAt(index + i) == 'u') { [EOL]             i++; [EOL]         } [EOL]         if (index + i < input.length() && input.charAt(index + i) == '+') { [EOL]             i++; [EOL]         } [EOL]         if (index + i + 4 <= input.length()) { [EOL]             final CharSequence unicode = input.subSequence(index + i, index + i + 4); [EOL]             try { [EOL]                 final int value = Integer.parseInt(unicode.toString(), 16); [EOL]                 out.write((char) value); [EOL]             } catch (final NumberFormatException nfe) { [EOL]                 throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [EOL]             } [EOL]             return i + 4; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence"); [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     if (input.charAt(index) == '\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') { [EOL]         int i = 2; [EOL]         while (index + i < input.length() && input.charAt(index + i) == 'u') { [EOL]             i++; [EOL]         } [EOL]         if (index + i < input.length() && input.charAt(index + i) == '+') { [EOL]             i++; [EOL]         } [EOL]         if (index + i + 4 <= input.length()) { [EOL]             final CharSequence unicode = input.subSequence(index + i, index + i + 4); [EOL]             try { [EOL]                 final int value = Integer.parseInt(unicode.toString(), 16); [EOL]                 out.write((char) value); [EOL]             } catch (final NumberFormatException nfe) { [EOL]                 throw new IllegalArgumentException("Unable to parse unicode value: " + unicode, nfe); [EOL]             } [EOL]             return i + 4; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Less than 4 hex digits in unicode value: '" + input.subSequence(index, input.length()) + "' due to end of CharSequence"); [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
methods/lang3/text/translate/EntityArrays.java
methods/lang3/text/translate/AggregateTranslator.java
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     for (final CharSequenceTranslator translator : translators) { [EOL]         final int consumed = translator.translate(input, index, out); [EOL]         if (consumed != 0) { [EOL]             return consumed; [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
methods/lang3/text/translate/UnicodeEscaper.java
public static UnicodeEscaper below(final int codepoint) { [EOL]     return outsideOf(codepoint, Integer.MAX_VALUE); [EOL] }
protected String toUtf16Escape(final int codepoint) { [EOL]     return "\\u" + hex(codepoint); [EOL] }
public static UnicodeEscaper above(final int codepoint) { [EOL]     return outsideOf(0, codepoint); [EOL] }
@Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if (codepoint > 0xffff) { [EOL]         out.write(toUtf16Escape(codepoint)); [EOL]     } else if (codepoint > 0xfff) { [EOL]         out.write("\\u" + hex(codepoint)); [EOL]     } else if (codepoint > 0xff) { [EOL]         out.write("\\u0" + hex(codepoint)); [EOL]     } else if (codepoint > 0xf) { [EOL]         out.write("\\u00" + hex(codepoint)); [EOL]     } else { [EOL]         out.write("\\u000" + hex(codepoint)); [EOL]     } [EOL]     return true; [EOL] }
public static UnicodeEscaper between(final int codepointLow, final int codepointHigh) { [EOL]     return new UnicodeEscaper(codepointLow, codepointHigh, true); [EOL] }
@Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if (codepoint > 0xffff) { [EOL]         out.write(toUtf16Escape(codepoint)); [EOL]     } else if (codepoint > 0xfff) { [EOL]         out.write("\\u" + hex(codepoint)); [EOL]     } else if (codepoint > 0xff) { [EOL]         out.write("\\u0" + hex(codepoint)); [EOL]     } else if (codepoint > 0xf) { [EOL]         out.write("\\u00" + hex(codepoint)); [EOL]     } else { [EOL]         out.write("\\u000" + hex(codepoint)); [EOL]     } [EOL]     return true; [EOL] }
public static UnicodeEscaper between(final int codepointLow, final int codepointHigh) { [EOL]     return new UnicodeEscaper(codepointLow, codepointHigh, true); [EOL] }
@Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if (codepoint > 0xffff) { [EOL]         out.write(toUtf16Escape(codepoint)); [EOL]     } else if (codepoint > 0xfff) { [EOL]         out.write("\\u" + hex(codepoint)); [EOL]     } else if (codepoint > 0xff) { [EOL]         out.write("\\u0" + hex(codepoint)); [EOL]     } else if (codepoint > 0xf) { [EOL]         out.write("\\u00" + hex(codepoint)); [EOL]     } else { [EOL]         out.write("\\u000" + hex(codepoint)); [EOL]     } [EOL]     return true; [EOL] }
public static UnicodeEscaper below(final int codepoint) { [EOL]     return outsideOf(codepoint, Integer.MAX_VALUE); [EOL] }
@Override [EOL] public boolean translate(final int codepoint, final Writer out) throws IOException { [EOL]     if (between) { [EOL]         if (codepoint < below || codepoint > above) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (codepoint >= below && codepoint <= above) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if (codepoint > 0xffff) { [EOL]         out.write(toUtf16Escape(codepoint)); [EOL]     } else if (codepoint > 0xfff) { [EOL]         out.write("\\u" + hex(codepoint)); [EOL]     } else if (codepoint > 0xff) { [EOL]         out.write("\\u0" + hex(codepoint)); [EOL]     } else if (codepoint > 0xf) { [EOL]         out.write("\\u00" + hex(codepoint)); [EOL]     } else { [EOL]         out.write("\\u000" + hex(codepoint)); [EOL]     } [EOL]     return true; [EOL] }
methods/lang3/text/translate/JavaUnicodeEscaper.java
public static JavaUnicodeEscaper between(final int codepointLow, final int codepointHigh) { [EOL]     return new JavaUnicodeEscaper(codepointLow, codepointHigh, true); [EOL] }
public static JavaUnicodeEscaper outsideOf(final int codepointLow, final int codepointHigh) { [EOL]     return new JavaUnicodeEscaper(codepointLow, codepointHigh, false); [EOL] }
public static JavaUnicodeEscaper below(final int codepoint) { [EOL]     return outsideOf(codepoint, Integer.MAX_VALUE); [EOL] }
methods/lang3/text/translate/CodePointTranslator.java
public abstract boolean translate(int codepoint, Writer out) throws IOException;
public abstract boolean translate(int codepoint, Writer out) throws IOException;
public abstract boolean translate(int codepoint, Writer out) throws IOException;
methods/lang3/text/translate/CharSequenceTranslator.java
public final void translate(final CharSequence input, final Writer out) throws IOException { [EOL]     if (out == null) { [EOL]         throw new IllegalArgumentException("The Writer must not be null"); [EOL]     } [EOL]     if (input == null) { [EOL]         return; [EOL]     } [EOL]     int pos = 0; [EOL]     final int len = input.length(); [EOL]     while (pos < len) { [EOL]         final int consumed = translate(input, pos, out); [EOL]         if (consumed == 0) { [EOL]             final char[] c = Character.toChars(Character.codePointAt(input, pos)); [EOL]             out.write(c); [EOL]             pos += c.length; [EOL]             continue; [EOL]         } [EOL]         for (int pt = 0; pt < consumed; pt++) { [EOL]             pos += Character.charCount(Character.codePointAt(input, pt)); [EOL]         } [EOL]     } [EOL] }
public final void translate(final CharSequence input, final Writer out) throws IOException { [EOL]     if (out == null) { [EOL]         throw new IllegalArgumentException("The Writer must not be null"); [EOL]     } [EOL]     if (input == null) { [EOL]         return; [EOL]     } [EOL]     int pos = 0; [EOL]     final int len = input.length(); [EOL]     while (pos < len) { [EOL]         final int consumed = translate(input, pos, out); [EOL]         if (consumed == 0) { [EOL]             final char[] c = Character.toChars(Character.codePointAt(input, pos)); [EOL]             out.write(c); [EOL]             pos += c.length; [EOL]             continue; [EOL]         } [EOL]         for (int pt = 0; pt < consumed; pt++) { [EOL]             pos += Character.charCount(Character.codePointAt(input, pt)); [EOL]         } [EOL]     } [EOL] }
public final void translate(final CharSequence input, final Writer out) throws IOException { [EOL]     if (out == null) { [EOL]         throw new IllegalArgumentException("The Writer must not be null"); [EOL]     } [EOL]     if (input == null) { [EOL]         return; [EOL]     } [EOL]     int pos = 0; [EOL]     final int len = input.length(); [EOL]     while (pos < len) { [EOL]         final int consumed = translate(input, pos, out); [EOL]         if (consumed == 0) { [EOL]             final char[] c = Character.toChars(Character.codePointAt(input, pos)); [EOL]             out.write(c); [EOL]             pos += c.length; [EOL]             continue; [EOL]         } [EOL]         for (int pt = 0; pt < consumed; pt++) { [EOL]             pos += Character.charCount(Character.codePointAt(input, pt)); [EOL]         } [EOL]     } [EOL] }
public final void translate(final CharSequence input, final Writer out) throws IOException { [EOL]     if (out == null) { [EOL]         throw new IllegalArgumentException("The Writer must not be null"); [EOL]     } [EOL]     if (input == null) { [EOL]         return; [EOL]     } [EOL]     int pos = 0; [EOL]     final int len = input.length(); [EOL]     while (pos < len) { [EOL]         final int consumed = translate(input, pos, out); [EOL]         if (consumed == 0) { [EOL]             final char[] c = Character.toChars(Character.codePointAt(input, pos)); [EOL]             out.write(c); [EOL]             pos += c.length; [EOL]             continue; [EOL]         } [EOL]         for (int pt = 0; pt < consumed; pt++) { [EOL]             pos += Character.charCount(Character.codePointAt(input, pt)); [EOL]         } [EOL]     } [EOL] }
public final void translate(final CharSequence input, final Writer out) throws IOException { [EOL]     if (out == null) { [EOL]         throw new IllegalArgumentException("The Writer must not be null"); [EOL]     } [EOL]     if (input == null) { [EOL]         return; [EOL]     } [EOL]     int pos = 0; [EOL]     final int len = input.length(); [EOL]     while (pos < len) { [EOL]         final int consumed = translate(input, pos, out); [EOL]         if (consumed == 0) { [EOL]             final char[] c = Character.toChars(Character.codePointAt(input, pos)); [EOL]             out.write(c); [EOL]             pos += c.length; [EOL]             continue; [EOL]         } [EOL]         for (int pt = 0; pt < consumed; pt++) { [EOL]             pos += Character.charCount(Character.codePointAt(input, pt)); [EOL]         } [EOL]     } [EOL] }
public final void translate(final CharSequence input, final Writer out) throws IOException { [EOL]     if (out == null) { [EOL]         throw new IllegalArgumentException("The Writer must not be null"); [EOL]     } [EOL]     if (input == null) { [EOL]         return; [EOL]     } [EOL]     int pos = 0; [EOL]     final int len = input.length(); [EOL]     while (pos < len) { [EOL]         final int consumed = translate(input, pos, out); [EOL]         if (consumed == 0) { [EOL]             final char[] c = Character.toChars(Character.codePointAt(input, pos)); [EOL]             out.write(c); [EOL]             pos += c.length; [EOL]             continue; [EOL]         } [EOL]         for (int pt = 0; pt < consumed; pt++) { [EOL]             pos += Character.charCount(Character.codePointAt(input, pt)); [EOL]         } [EOL]     } [EOL] }
public static String hex(final int codepoint) { [EOL]     return Integer.toHexString(codepoint).toUpperCase(Locale.ENGLISH); [EOL] }
methods/lang3/text/translate/NumericEntityUnescaper.java
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] }
public boolean isSet(final OPTION option) { [EOL]     return options == null ? false : options.contains(option); [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] }
public boolean isSet(final OPTION option) { [EOL]     return options == null ? false : options.contains(option); [EOL] }
@Override [EOL] public int translate(final CharSequence input, final int index, final Writer out) throws IOException { [EOL]     final int seqEnd = input.length(); [EOL]     if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') { [EOL]         int start = index + 2; [EOL]         boolean isHex = false; [EOL]         final char firstChar = input.charAt(start); [EOL]         if (firstChar == 'x' || firstChar == 'X') { [EOL]             start++; [EOL]             isHex = true; [EOL]             if (start == seqEnd) { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]         int end = start; [EOL]         while (end < seqEnd && (input.charAt(end) >= '0' && input.charAt(end) <= '9' || input.charAt(end) >= 'a' && input.charAt(end) <= 'f' || input.charAt(end) >= 'A' && input.charAt(end) <= 'F')) { [EOL]             end++; [EOL]         } [EOL]         final boolean semiNext = end != seqEnd && input.charAt(end) == ';'; [EOL]         if (!semiNext) { [EOL]             if (isSet(OPTION.semiColonRequired)) { [EOL]                 return 0; [EOL]             } else if (isSet(OPTION.errorIfNoSemiColon)) { [EOL]                 throw new IllegalArgumentException("Semi-colon required at end of numeric entity"); [EOL]             } [EOL]         } [EOL]         int entityValue; [EOL]         try { [EOL]             if (isHex) { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16); [EOL]             } else { [EOL]                 entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10); [EOL]             } [EOL]         } catch (final NumberFormatException nfe) { [EOL]             return 0; [EOL]         } [EOL]         if (entityValue > 0xFFFF) { [EOL]             final char[] chrs = Character.toChars(entityValue); [EOL]             out.write(chrs[0]); [EOL]             out.write(chrs[1]); [EOL]         } else { [EOL]             out.write(entityValue); [EOL]         } [EOL]         return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0); [EOL]     } [EOL]     return 0; [EOL] }
methods/lang3/tuple/Triple.java
public static <L, M, R> Triple<L, M, R> of(final L left, final M middle, final R right) { [EOL]     return new ImmutableTriple<L, M, R>(left, middle, right); [EOL] }
public String toString(final String format) { [EOL]     return String.format(format, getLeft(), getMiddle(), getRight()); [EOL] }
public abstract R getRight();
public abstract R getRight();
public abstract M getMiddle();
public static <L, M, R> Triple<L, M, R> of(final L left, final M middle, final R right) { [EOL]     return new ImmutableTriple<L, M, R>(left, middle, right); [EOL] }
public abstract M getMiddle();
public static <L, M, R> Triple<L, M, R> of(final L left, final M middle, final R right) { [EOL]     return new ImmutableTriple<L, M, R>(left, middle, right); [EOL] }
public abstract L getLeft();
@Override [EOL] public int compareTo(final Triple<L, M, R> other) { [EOL]     return new CompareToBuilder().append(getLeft(), other.getLeft()).append(getMiddle(), other.getMiddle()).append(getRight(), other.getRight()).toComparison(); [EOL] }
public static <L, M, R> Triple<L, M, R> of(final L left, final M middle, final R right) { [EOL]     return new ImmutableTriple<L, M, R>(left, middle, right); [EOL] }
@Override [EOL] public int compareTo(final Triple<L, M, R> other) { [EOL]     return new CompareToBuilder().append(getLeft(), other.getLeft()).append(getMiddle(), other.getMiddle()).append(getRight(), other.getRight()).toComparison(); [EOL] }
public static <L, M, R> Triple<L, M, R> of(final L left, final M middle, final R right) { [EOL]     return new ImmutableTriple<L, M, R>(left, middle, right); [EOL] }
@Override [EOL] public int compareTo(final Triple<L, M, R> other) { [EOL]     return new CompareToBuilder().append(getLeft(), other.getLeft()).append(getMiddle(), other.getMiddle()).append(getRight(), other.getRight()).toComparison(); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Triple<?, ?, ?>) { [EOL]         final Triple<?, ?, ?> other = (Triple<?, ?, ?>) obj; [EOL]         return ObjectUtils.equals(getLeft(), other.getLeft()) && ObjectUtils.equals(getMiddle(), other.getMiddle()) && ObjectUtils.equals(getRight(), other.getRight()); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Triple<?, ?, ?>) { [EOL]         final Triple<?, ?, ?> other = (Triple<?, ?, ?>) obj; [EOL]         return ObjectUtils.equals(getLeft(), other.getLeft()) && ObjectUtils.equals(getMiddle(), other.getMiddle()) && ObjectUtils.equals(getRight(), other.getRight()); [EOL]     } [EOL]     return false; [EOL] }
public static <L, M, R> Triple<L, M, R> of(final L left, final M middle, final R right) { [EOL]     return new ImmutableTriple<L, M, R>(left, middle, right); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Triple<?, ?, ?>) { [EOL]         final Triple<?, ?, ?> other = (Triple<?, ?, ?>) obj; [EOL]         return ObjectUtils.equals(getLeft(), other.getLeft()) && ObjectUtils.equals(getMiddle(), other.getMiddle()) && ObjectUtils.equals(getRight(), other.getRight()); [EOL]     } [EOL]     return false; [EOL] }
public static <L, M, R> Triple<L, M, R> of(final L left, final M middle, final R right) { [EOL]     return new ImmutableTriple<L, M, R>(left, middle, right); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Triple<?, ?, ?>) { [EOL]         final Triple<?, ?, ?> other = (Triple<?, ?, ?>) obj; [EOL]         return ObjectUtils.equals(getLeft(), other.getLeft()) && ObjectUtils.equals(getMiddle(), other.getMiddle()) && ObjectUtils.equals(getRight(), other.getRight()); [EOL]     } [EOL]     return false; [EOL] }
public static <L, M, R> Triple<L, M, R> of(final L left, final M middle, final R right) { [EOL]     return new ImmutableTriple<L, M, R>(left, middle, right); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Triple<?, ?, ?>) { [EOL]         final Triple<?, ?, ?> other = (Triple<?, ?, ?>) obj; [EOL]         return ObjectUtils.equals(getLeft(), other.getLeft()) && ObjectUtils.equals(getMiddle(), other.getMiddle()) && ObjectUtils.equals(getRight(), other.getRight()); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Triple<?, ?, ?>) { [EOL]         final Triple<?, ?, ?> other = (Triple<?, ?, ?>) obj; [EOL]         return ObjectUtils.equals(getLeft(), other.getLeft()) && ObjectUtils.equals(getMiddle(), other.getMiddle()) && ObjectUtils.equals(getRight(), other.getRight()); [EOL]     } [EOL]     return false; [EOL] }
public String toString(final String format) { [EOL]     return String.format(format, getLeft(), getMiddle(), getRight()); [EOL] }
public String toString(final String format) { [EOL]     return String.format(format, getLeft(), getMiddle(), getRight()); [EOL] }
methods/lang3/tuple/ImmutableTriple.java
public static <L, M, R> ImmutableTriple<L, M, R> of(final L left, final M middle, final R right) { [EOL]     return new ImmutableTriple<L, M, R>(left, middle, right); [EOL] }
@Override [EOL] public L getLeft() { [EOL]     return left; [EOL] }
@Override [EOL] public R getRight() { [EOL]     return right; [EOL] }
@Override [EOL] public M getMiddle() { [EOL]     return middle; [EOL] }
public static <L, M, R> ImmutableTriple<L, M, R> of(final L left, final M middle, final R right) { [EOL]     return new ImmutableTriple<L, M, R>(left, middle, right); [EOL] }
@Override [EOL] public M getMiddle() { [EOL]     return middle; [EOL] }
@Override [EOL] public R getRight() { [EOL]     return right; [EOL] }
methods/lang3/tuple/MutablePair.java
@Override [EOL] public R getRight() { [EOL]     return right; [EOL] }
@Override [EOL] public L getLeft() { [EOL]     return left; [EOL] }
public void setLeft(final L left) { [EOL]     this.left = left; [EOL] }
@Override [EOL] public L getLeft() { [EOL]     return left; [EOL] }
@Override [EOL] public R setValue(final R value) { [EOL]     final R result = getRight(); [EOL]     setRight(value); [EOL]     return result; [EOL] }
methods/lang3/tuple/ImmutablePair.java
@Override [EOL] public R getRight() { [EOL]     return right; [EOL] }
@Override [EOL] public L getLeft() { [EOL]     return left; [EOL] }
public static <L, R> ImmutablePair<L, R> of(final L left, final R right) { [EOL]     return new ImmutablePair<L, R>(left, right); [EOL] }
@Override [EOL] public R getRight() { [EOL]     return right; [EOL] }
public static <L, R> ImmutablePair<L, R> of(final L left, final R right) { [EOL]     return new ImmutablePair<L, R>(left, right); [EOL] }
methods/lang3/tuple/Pair.java
public static <L, R> Pair<L, R> of(final L left, final R right) { [EOL]     return new ImmutablePair<L, R>(left, right); [EOL] }
public String toString(final String format) { [EOL]     return String.format(format, getLeft(), getRight()); [EOL] }
public String toString(final String format) { [EOL]     return String.format(format, getLeft(), getRight()); [EOL] }
@Override [EOL] public R getValue() { [EOL]     return getRight(); [EOL] }
@Override [EOL] public R getValue() { [EOL]     return getRight(); [EOL] }
public abstract R getRight();
public abstract R getRight();
public abstract L getLeft();
public abstract L getLeft();
@Override [EOL] public final L getKey() { [EOL]     return getLeft(); [EOL] }
@Override [EOL] public int compareTo(final Pair<L, R> other) { [EOL]     return new CompareToBuilder().append(getLeft(), other.getLeft()).append(getRight(), other.getRight()).toComparison(); [EOL] }
public static <L, R> Pair<L, R> of(final L left, final R right) { [EOL]     return new ImmutablePair<L, R>(left, right); [EOL] }
@Override [EOL] public int compareTo(final Pair<L, R> other) { [EOL]     return new CompareToBuilder().append(getLeft(), other.getLeft()).append(getRight(), other.getRight()).toComparison(); [EOL] }
public static <L, R> Pair<L, R> of(final L left, final R right) { [EOL]     return new ImmutablePair<L, R>(left, right); [EOL] }
public abstract L getLeft();
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Map.Entry<?, ?>) { [EOL]         final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj; [EOL]         return ObjectUtils.equals(getKey(), other.getKey()) && ObjectUtils.equals(getValue(), other.getValue()); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Map.Entry<?, ?>) { [EOL]         final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj; [EOL]         return ObjectUtils.equals(getKey(), other.getKey()) && ObjectUtils.equals(getValue(), other.getValue()); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Map.Entry<?, ?>) { [EOL]         final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj; [EOL]         return ObjectUtils.equals(getKey(), other.getKey()) && ObjectUtils.equals(getValue(), other.getValue()); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public final L getKey() { [EOL]     return getLeft(); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Map.Entry<?, ?>) { [EOL]         final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj; [EOL]         return ObjectUtils.equals(getKey(), other.getKey()) && ObjectUtils.equals(getValue(), other.getValue()); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public int compareTo(final Pair<L, R> other) { [EOL]     return new CompareToBuilder().append(getLeft(), other.getLeft()).append(getRight(), other.getRight()).toComparison(); [EOL] }
public static <L, R> Pair<L, R> of(final L left, final R right) { [EOL]     return new ImmutablePair<L, R>(left, right); [EOL] }
public String toString(final String format) { [EOL]     return String.format(format, getLeft(), getRight()); [EOL] }
public static <L, R> Pair<L, R> of(final L left, final R right) { [EOL]     return new ImmutablePair<L, R>(left, right); [EOL] }
public abstract L getLeft();
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Map.Entry<?, ?>) { [EOL]         final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj; [EOL]         return ObjectUtils.equals(getKey(), other.getKey()) && ObjectUtils.equals(getValue(), other.getValue()); [EOL]     } [EOL]     return false; [EOL] }
methods/lang3/tuple/MutableTriple.java
public static <L, M, R> MutableTriple<L, M, R> of(final L left, final M middle, final R right) { [EOL]     return new MutableTriple<L, M, R>(left, middle, right); [EOL] }
@Override [EOL] public M getMiddle() { [EOL]     return middle; [EOL] }
@Override [EOL] public R getRight() { [EOL]     return right; [EOL] }
public static <L, M, R> MutableTriple<L, M, R> of(final L left, final M middle, final R right) { [EOL]     return new MutableTriple<L, M, R>(left, middle, right); [EOL] }
@Override [EOL] public L getLeft() { [EOL]     return left; [EOL] }
public static <L, M, R> MutableTriple<L, M, R> of(final L left, final M middle, final R right) { [EOL]     return new MutableTriple<L, M, R>(left, middle, right); [EOL] }
@Override [EOL] public R getRight() { [EOL]     return right; [EOL] }
@Override [EOL] public L getLeft() { [EOL]     return left; [EOL] }
@Override [EOL] public M getMiddle() { [EOL]     return middle; [EOL] }
methods/lang3/mutable/MutableInt.java
@Override [EOL] public long longValue() { [EOL]     return value; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.intValue(); [EOL] }
public Integer toInteger() { [EOL]     return Integer.valueOf(intValue()); [EOL] }
public void increment() { [EOL]     value++; [EOL] }
public void add(final Number operand) { [EOL]     this.value += operand.intValue(); [EOL] }
public void subtract(final Number operand) { [EOL]     this.value -= operand.intValue(); [EOL] }
@Override [EOL] public long longValue() { [EOL]     return value; [EOL] }
public void subtract(final Number operand) { [EOL]     this.value -= operand.intValue(); [EOL] }
@Override [EOL] public long longValue() { [EOL]     return value; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return value; [EOL] }
public void subtract(final Number operand) { [EOL]     this.value -= operand.intValue(); [EOL] }
@Override [EOL] public int intValue() { [EOL]     return value; [EOL] }
@Override [EOL] public Integer getValue() { [EOL]     return Integer.valueOf(this.value); [EOL] }
public void add(final Number operand) { [EOL]     this.value += operand.intValue(); [EOL] }
@Override [EOL] public Integer getValue() { [EOL]     return Integer.valueOf(this.value); [EOL] }
public void add(final Number operand) { [EOL]     this.value += operand.intValue(); [EOL] }
public void subtract(final Number operand) { [EOL]     this.value -= operand.intValue(); [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
@Override [EOL] public Integer getValue() { [EOL]     return Integer.valueOf(this.value); [EOL] }
@Override [EOL] public Integer getValue() { [EOL]     return Integer.valueOf(this.value); [EOL] }
@Override [EOL] public int intValue() { [EOL]     return value; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return value; [EOL] }
@Override [EOL] public int compareTo(final MutableInt other) { [EOL]     final int anotherVal = other.value; [EOL]     return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof MutableInt) { [EOL]         return value == ((MutableInt) obj).intValue(); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof MutableInt) { [EOL]         return value == ((MutableInt) obj).intValue(); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public String toString() { [EOL]     return String.valueOf(value); [EOL] }
@Override [EOL] public long longValue() { [EOL]     return value; [EOL] }
@Override [EOL] public Integer getValue() { [EOL]     return Integer.valueOf(this.value); [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
public Integer toInteger() { [EOL]     return Integer.valueOf(intValue()); [EOL] }
@Override [EOL] public Integer getValue() { [EOL]     return Integer.valueOf(this.value); [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return value; [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.intValue(); [EOL] }
methods/lang3/mutable/MutableObject.java
@Override [EOL] public T getValue() { [EOL]     return this.value; [EOL] }
@Override [EOL] public T getValue() { [EOL]     return this.value; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == null) { [EOL]         return false; [EOL]     } [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (this.getClass() == obj.getClass()) { [EOL]         final MutableObject<?> that = (MutableObject<?>) obj; [EOL]         return this.value.equals(that.value); [EOL]     } else { [EOL]         return false; [EOL]     } [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == null) { [EOL]         return false; [EOL]     } [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (this.getClass() == obj.getClass()) { [EOL]         final MutableObject<?> that = (MutableObject<?>) obj; [EOL]         return this.value.equals(that.value); [EOL]     } else { [EOL]         return false; [EOL]     } [EOL] }
@Override [EOL] public String toString() { [EOL]     return value == null ? "null" : value.toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     return value == null ? "null" : value.toString(); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == null) { [EOL]         return false; [EOL]     } [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (this.getClass() == obj.getClass()) { [EOL]         final MutableObject<?> that = (MutableObject<?>) obj; [EOL]         return this.value.equals(that.value); [EOL]     } else { [EOL]         return false; [EOL]     } [EOL] }
methods/lang3/mutable/MutableFloat.java
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
@Override [EOL] public String toString() { [EOL]     return String.valueOf(value); [EOL] }
@Override [EOL] public Float getValue() { [EOL]     return Float.valueOf(this.value); [EOL] }
public void add(final Number operand) { [EOL]     this.value += operand.floatValue(); [EOL] }
public Float toFloat() { [EOL]     return Float.valueOf(floatValue()); [EOL] }
@Override [EOL] public String toString() { [EOL]     return String.valueOf(value); [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.floatValue(); [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
public Float toFloat() { [EOL]     return Float.valueOf(floatValue()); [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return value; [EOL] }
public Float toFloat() { [EOL]     return Float.valueOf(floatValue()); [EOL] }
@Override [EOL] public int intValue() { [EOL]     return (int) value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) value; [EOL] }
@Override [EOL] public Float getValue() { [EOL]     return Float.valueOf(this.value); [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.floatValue(); [EOL] }
@Override [EOL] public Float getValue() { [EOL]     return Float.valueOf(this.value); [EOL] }
public void increment() { [EOL]     value++; [EOL] }
@Override [EOL] public Float getValue() { [EOL]     return Float.valueOf(this.value); [EOL] }
public Float toFloat() { [EOL]     return Float.valueOf(floatValue()); [EOL] }
public Float toFloat() { [EOL]     return Float.valueOf(floatValue()); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     return obj instanceof MutableFloat && Float.floatToIntBits(((MutableFloat) obj).value) == Float.floatToIntBits(value); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     return obj instanceof MutableFloat && Float.floatToIntBits(((MutableFloat) obj).value) == Float.floatToIntBits(value); [EOL] }
@Override [EOL] public String toString() { [EOL]     return String.valueOf(value); [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return Float.floatToIntBits(value); [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return value; [EOL] }
public void add(final Number operand) { [EOL]     this.value += operand.floatValue(); [EOL] }
public Float toFloat() { [EOL]     return Float.valueOf(floatValue()); [EOL] }
public Float toFloat() { [EOL]     return Float.valueOf(floatValue()); [EOL] }
public void subtract(final Number operand) { [EOL]     this.value -= operand.floatValue(); [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
@Override [EOL] public Float getValue() { [EOL]     return Float.valueOf(this.value); [EOL] }
@Override [EOL] public int intValue() { [EOL]     return (int) value; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
public boolean isInfinite() { [EOL]     return Float.isInfinite(value); [EOL] }
public void add(final Number operand) { [EOL]     this.value += operand.floatValue(); [EOL] }
public Float toFloat() { [EOL]     return Float.valueOf(floatValue()); [EOL] }
public boolean isNaN() { [EOL]     return Float.isNaN(value); [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.floatValue(); [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) value; [EOL] }
@Override [EOL] public int compareTo(final MutableFloat other) { [EOL]     final float anotherVal = other.value; [EOL]     return Float.compare(value, anotherVal); [EOL] }
methods/lang3/mutable/MutableByte.java
@Override [EOL] public byte byteValue() { [EOL]     return value; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return value; [EOL] }
public Byte toByte() { [EOL]     return Byte.valueOf(byteValue()); [EOL] }
public Byte toByte() { [EOL]     return Byte.valueOf(byteValue()); [EOL] }
@Override [EOL] public long longValue() { [EOL]     return value; [EOL] }
@Override [EOL] public byte byteValue() { [EOL]     return value; [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.byteValue(); [EOL] }
@Override [EOL] public int intValue() { [EOL]     return value; [EOL] }
@Override [EOL] public Byte getValue() { [EOL]     return Byte.valueOf(this.value); [EOL] }
public void add(final Number operand) { [EOL]     this.value += operand.byteValue(); [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.byteValue(); [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return value; [EOL] }
public void add(final Number operand) { [EOL]     this.value += operand.byteValue(); [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return value; [EOL] }
@Override [EOL] public Byte getValue() { [EOL]     return Byte.valueOf(this.value); [EOL] }
@Override [EOL] public byte byteValue() { [EOL]     return value; [EOL] }
@Override [EOL] public byte byteValue() { [EOL]     return value; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
@Override [EOL] public Byte getValue() { [EOL]     return Byte.valueOf(this.value); [EOL] }
@Override [EOL] public int compareTo(final MutableByte other) { [EOL]     final byte anotherVal = other.value; [EOL]     return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1); [EOL] }
@Override [EOL] public int intValue() { [EOL]     return value; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof MutableByte) { [EOL]         return value == ((MutableByte) obj).byteValue(); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof MutableByte) { [EOL]         return value == ((MutableByte) obj).byteValue(); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.byteValue(); [EOL] }
@Override [EOL] public String toString() { [EOL]     return String.valueOf(value); [EOL] }
@Override [EOL] public Byte getValue() { [EOL]     return Byte.valueOf(this.value); [EOL] }
public void add(final Number operand) { [EOL]     this.value += operand.byteValue(); [EOL] }
@Override [EOL] public byte byteValue() { [EOL]     return value; [EOL] }
public Byte toByte() { [EOL]     return Byte.valueOf(byteValue()); [EOL] }
@Override [EOL] public int intValue() { [EOL]     return value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return value; [EOL] }
public Byte toByte() { [EOL]     return Byte.valueOf(byteValue()); [EOL] }
@Override [EOL] public String toString() { [EOL]     return String.valueOf(value); [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return value; [EOL] }
public void subtract(final Number operand) { [EOL]     this.value -= operand.byteValue(); [EOL] }
@Override [EOL] public byte byteValue() { [EOL]     return value; [EOL] }
public void subtract(final Number operand) { [EOL]     this.value -= operand.byteValue(); [EOL] }
methods/lang3/mutable/MutableBoolean.java
public Boolean toBoolean() { [EOL]     return Boolean.valueOf(booleanValue()); [EOL] }
@Override [EOL] public Boolean getValue() { [EOL]     return Boolean.valueOf(this.value); [EOL] }
public boolean booleanValue() { [EOL]     return value; [EOL] }
public boolean booleanValue() { [EOL]     return value; [EOL] }
public Boolean toBoolean() { [EOL]     return Boolean.valueOf(booleanValue()); [EOL] }
@Override [EOL] public Boolean getValue() { [EOL]     return Boolean.valueOf(this.value); [EOL] }
public boolean isFalse() { [EOL]     return value == false; [EOL] }
@Override [EOL] public void setValue(final Boolean value) { [EOL]     this.value = value.booleanValue(); [EOL] }
public boolean booleanValue() { [EOL]     return value; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return value ? Boolean.TRUE.hashCode() : Boolean.FALSE.hashCode(); [EOL] }
public boolean isFalse() { [EOL]     return value == false; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof MutableBoolean) { [EOL]         return value == ((MutableBoolean) obj).booleanValue(); [EOL]     } [EOL]     return false; [EOL] }
public boolean isFalse() { [EOL]     return value == false; [EOL] }
public boolean isFalse() { [EOL]     return value == false; [EOL] }
public boolean booleanValue() { [EOL]     return value; [EOL] }
public boolean isTrue() { [EOL]     return value == true; [EOL] }
public boolean isTrue() { [EOL]     return value == true; [EOL] }
@Override [EOL] public String toString() { [EOL]     return String.valueOf(value); [EOL] }
@Override [EOL] public void setValue(final Boolean value) { [EOL]     this.value = value.booleanValue(); [EOL] }
public boolean isTrue() { [EOL]     return value == true; [EOL] }
public Boolean toBoolean() { [EOL]     return Boolean.valueOf(booleanValue()); [EOL] }
@Override [EOL] public Boolean getValue() { [EOL]     return Boolean.valueOf(this.value); [EOL] }
methods/lang3/mutable/MutableShort.java
@Override [EOL] public short shortValue() { [EOL]     return value; [EOL] }
public Short toShort() { [EOL]     return Short.valueOf(shortValue()); [EOL] }
public Short toShort() { [EOL]     return Short.valueOf(shortValue()); [EOL] }
public void decrement() { [EOL]     value--; [EOL] }
public Short toShort() { [EOL]     return Short.valueOf(shortValue()); [EOL] }
@Override [EOL] public short shortValue() { [EOL]     return value; [EOL] }
@Override [EOL] public short shortValue() { [EOL]     return value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return value; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return value; [EOL] }
@Override [EOL] public Short getValue() { [EOL]     return Short.valueOf(this.value); [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.shortValue(); [EOL] }
@Override [EOL] public Short getValue() { [EOL]     return Short.valueOf(this.value); [EOL] }
@Override [EOL] public Short getValue() { [EOL]     return Short.valueOf(this.value); [EOL] }
public void subtract(final Number operand) { [EOL]     this.value -= operand.shortValue(); [EOL] }
public Short toShort() { [EOL]     return Short.valueOf(shortValue()); [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return value; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return value; [EOL] }
@Override [EOL] public short shortValue() { [EOL]     return value; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return value; [EOL] }
@Override [EOL] public short shortValue() { [EOL]     return value; [EOL] }
@Override [EOL] public short shortValue() { [EOL]     return value; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof MutableShort) { [EOL]         return value == ((MutableShort) obj).shortValue(); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof MutableShort) { [EOL]         return value == ((MutableShort) obj).shortValue(); [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public Short getValue() { [EOL]     return Short.valueOf(this.value); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof MutableShort) { [EOL]         return value == ((MutableShort) obj).shortValue(); [EOL]     } [EOL]     return false; [EOL] }
public void subtract(final Number operand) { [EOL]     this.value -= operand.shortValue(); [EOL] }
@Override [EOL] public int intValue() { [EOL]     return value; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return value; [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.shortValue(); [EOL] }
@Override [EOL] public String toString() { [EOL]     return String.valueOf(value); [EOL] }
@Override [EOL] public long longValue() { [EOL]     return value; [EOL] }
public Short toShort() { [EOL]     return Short.valueOf(shortValue()); [EOL] }
@Override [EOL] public String toString() { [EOL]     return String.valueOf(value); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return value; [EOL] }
@Override [EOL] public String toString() { [EOL]     return String.valueOf(value); [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return value; [EOL] }
public void add(final Number operand) { [EOL]     this.value += operand.shortValue(); [EOL] }
public Short toShort() { [EOL]     return Short.valueOf(shortValue()); [EOL] }
methods/lang3/mutable/MutableDouble.java
public void subtract(final Number operand) { [EOL]     this.value -= operand.doubleValue(); [EOL] }
public Double toDouble() { [EOL]     return Double.valueOf(doubleValue()); [EOL] }
public void increment() { [EOL]     value++; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) value; [EOL] }
public Double toDouble() { [EOL]     return Double.valueOf(doubleValue()); [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.doubleValue(); [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return value; [EOL] }
public Double toDouble() { [EOL]     return Double.valueOf(doubleValue()); [EOL] }
public Double toDouble() { [EOL]     return Double.valueOf(doubleValue()); [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) value; [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.doubleValue(); [EOL] }
@Override [EOL] public int intValue() { [EOL]     return (int) value; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return (int) value; [EOL] }
@Override [EOL] public Double getValue() { [EOL]     return Double.valueOf(this.value); [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.doubleValue(); [EOL] }
@Override [EOL] public Double getValue() { [EOL]     return Double.valueOf(this.value); [EOL] }
@Override [EOL] public Double getValue() { [EOL]     return Double.valueOf(this.value); [EOL] }
@Override [EOL] public Double getValue() { [EOL]     return Double.valueOf(this.value); [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) value; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return value; [EOL] }
@Override [EOL] public int compareTo(final MutableDouble other) { [EOL]     final double anotherVal = other.value; [EOL]     return Double.compare(value, anotherVal); [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return value; [EOL] }
@Override [EOL] public Double getValue() { [EOL]     return Double.valueOf(this.value); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     return obj instanceof MutableDouble && Double.doubleToLongBits(((MutableDouble) obj).value) == Double.doubleToLongBits(value); [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return value; [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     return obj instanceof MutableDouble && Double.doubleToLongBits(((MutableDouble) obj).value) == Double.doubleToLongBits(value); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     return obj instanceof MutableDouble && Double.doubleToLongBits(((MutableDouble) obj).value) == Double.doubleToLongBits(value); [EOL] }
@Override [EOL] public Double getValue() { [EOL]     return Double.valueOf(this.value); [EOL] }
public void decrement() { [EOL]     value--; [EOL] }
@Override [EOL] public String toString() { [EOL]     return String.valueOf(value); [EOL] }
public Double toDouble() { [EOL]     return Double.valueOf(doubleValue()); [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return value; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     final long bits = Double.doubleToLongBits(value); [EOL]     return (int) (bits ^ bits >>> 32); [EOL] }
@Override [EOL] public long longValue() { [EOL]     return (long) value; [EOL] }
public boolean isNaN() { [EOL]     return Double.isNaN(value); [EOL] }
public Double toDouble() { [EOL]     return Double.valueOf(doubleValue()); [EOL] }
@Override [EOL] public int intValue() { [EOL]     return (int) value; [EOL] }
@Override [EOL] public String toString() { [EOL]     return String.valueOf(value); [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) value; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return (float) value; [EOL] }
public boolean isInfinite() { [EOL]     return Double.isInfinite(value); [EOL] }
@Override [EOL] public String toString() { [EOL]     return String.valueOf(value); [EOL] }
methods/lang3/mutable/MutableLong.java
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.longValue(); [EOL] }
@Override [EOL] public long longValue() { [EOL]     return value; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return (int) (value ^ (value >>> 32)); [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return value; [EOL] }
public void subtract(final Number operand) { [EOL]     this.value -= operand.longValue(); [EOL] }
@Override [EOL] public long longValue() { [EOL]     return value; [EOL] }
public void add(final Number operand) { [EOL]     this.value += operand.longValue(); [EOL] }
public Long toLong() { [EOL]     return Long.valueOf(longValue()); [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.longValue(); [EOL] }
public Long toLong() { [EOL]     return Long.valueOf(longValue()); [EOL] }
public Long toLong() { [EOL]     return Long.valueOf(longValue()); [EOL] }
@Override [EOL] public long longValue() { [EOL]     return value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return value; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return (int) value; [EOL] }
@Override [EOL] public Long getValue() { [EOL]     return Long.valueOf(this.value); [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.longValue(); [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return value; [EOL] }
@Override [EOL] public int compareTo(final MutableLong other) { [EOL]     final long anotherVal = other.value; [EOL]     return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1); [EOL] }
@Override [EOL] public long longValue() { [EOL]     return value; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
public void subtract(final Number operand) { [EOL]     this.value -= operand.longValue(); [EOL] }
public Long toLong() { [EOL]     return Long.valueOf(longValue()); [EOL] }
public void increment() { [EOL]     value++; [EOL] }
public Long toLong() { [EOL]     return Long.valueOf(longValue()); [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return value; [EOL] }
@Override [EOL] public float floatValue() { [EOL]     return value; [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.longValue(); [EOL] }
@Override [EOL] public void setValue(final Number value) { [EOL]     this.value = value.longValue(); [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return value; [EOL] }
@Override [EOL] public String toString() { [EOL]     return String.valueOf(value); [EOL] }
@Override [EOL] public int intValue() { [EOL]     return (int) value; [EOL] }
@Override [EOL] public Long getValue() { [EOL]     return Long.valueOf(this.value); [EOL] }
public Long toLong() { [EOL]     return Long.valueOf(longValue()); [EOL] }
methods/lang3/builder/IDKey.java
@Override [EOL] public boolean equals(final Object other) { [EOL]     if (!(other instanceof IDKey)) { [EOL]         return false; [EOL]     } [EOL]     final IDKey idKey = (IDKey) other; [EOL]     if (id != idKey.id) { [EOL]         return false; [EOL]     } [EOL]     return value == idKey.value; [EOL] }
@Override [EOL] public boolean equals(final Object other) { [EOL]     if (!(other instanceof IDKey)) { [EOL]         return false; [EOL]     } [EOL]     final IDKey idKey = (IDKey) other; [EOL]     if (id != idKey.id) { [EOL]         return false; [EOL]     } [EOL]     return value == idKey.value; [EOL] }
@Override [EOL] public boolean equals(final Object other) { [EOL]     if (!(other instanceof IDKey)) { [EOL]         return false; [EOL]     } [EOL]     final IDKey idKey = (IDKey) other; [EOL]     if (id != idKey.id) { [EOL]         return false; [EOL]     } [EOL]     return value == idKey.value; [EOL] }
@Override [EOL] public boolean equals(final Object other) { [EOL]     if (!(other instanceof IDKey)) { [EOL]         return false; [EOL]     } [EOL]     final IDKey idKey = (IDKey) other; [EOL]     if (id != idKey.id) { [EOL]         return false; [EOL]     } [EOL]     return value == idKey.value; [EOL] }
methods/lang3/builder/ToStringStyle.java
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (array == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else if (isFullDetail(fullDetail)) { [EOL]         appendDetail(buffer, fieldName, array); [EOL]     } else { [EOL]         appendSummary(buffer, fieldName, array); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] }
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) { [EOL]     buffer.append(arrayStart); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         appendDetail(buffer, fieldName, array[i]); [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected boolean isFullDetail(final Boolean fullDetailRequest) { [EOL]     if (fullDetailRequest == null) { [EOL]         return defaultFullDetail; [EOL]     } [EOL]     return fullDetailRequest.booleanValue(); [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected void setSizeEndText(String sizeEndText) { [EOL]     if (sizeEndText == null) { [EOL]         sizeEndText = ""; [EOL]     } [EOL]     this.sizeEndText = sizeEndText; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected void setNullText(String nullText) { [EOL]     if (nullText == null) { [EOL]         nullText = ""; [EOL]     } [EOL]     this.nullText = nullText; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected void setArraySeparator(String arraySeparator) { [EOL]     if (arraySeparator == null) { [EOL]         arraySeparator = ""; [EOL]     } [EOL]     this.arraySeparator = arraySeparator; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected void setArrayEnd(String arrayEnd) { [EOL]     if (arrayEnd == null) { [EOL]         arrayEnd = ""; [EOL]     } [EOL]     this.arrayEnd = arrayEnd; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
public void appendStart(final StringBuffer buffer, final Object object) { [EOL]     if (object != null) { [EOL]         appendClassName(buffer, object); [EOL]         appendIdentityHashCode(buffer, object); [EOL]         appendContentStart(buffer); [EOL]         if (fieldSeparatorAtStart) { [EOL]             appendFieldSeparator(buffer); [EOL]         } [EOL]     } [EOL] }
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (array == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else if (isFullDetail(fullDetail)) { [EOL]         appendDetail(buffer, fieldName, array); [EOL]     } else { [EOL]         appendSummary(buffer, fieldName, array); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
public void appendEnd(final StringBuffer buffer, final Object object) { [EOL]     if (this.fieldSeparatorAtEnd == false) { [EOL]         removeLastFieldSeparator(buffer); [EOL]     } [EOL]     appendContentEnd(buffer); [EOL]     unregister(object); [EOL] }
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (array == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else if (isFullDetail(fullDetail)) { [EOL]         appendDetail(buffer, fieldName, array); [EOL]     } else { [EOL]         appendSummary(buffer, fieldName, array); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (array == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else if (isFullDetail(fullDetail)) { [EOL]         appendDetail(buffer, fieldName, array); [EOL]     } else { [EOL]         appendSummary(buffer, fieldName, array); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] }
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) { [EOL]     buffer.append(arrayStart); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         appendDetail(buffer, fieldName, array[i]); [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (array == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else if (isFullDetail(fullDetail)) { [EOL]         appendDetail(buffer, fieldName, array); [EOL]     } else { [EOL]         appendSummary(buffer, fieldName, array); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] }
protected void appendIdentityHashCode(final StringBuffer buffer, final Object object) { [EOL]     if (this.isUseIdentityHashCode() && object != null) { [EOL]         register(object); [EOL]         buffer.append('@'); [EOL]         buffer.append(Integer.toHexString(System.identityHashCode(object))); [EOL]     } [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) { [EOL]     appendFieldStart(buffer, fieldName); [EOL]     if (array == null) { [EOL]         appendNullText(buffer, fieldName); [EOL]     } else if (isFullDetail(fullDetail)) { [EOL]         appendDetail(buffer, fieldName, array); [EOL]     } else { [EOL]         appendSummary(buffer, fieldName, array); [EOL]     } [EOL]     appendFieldEnd(buffer, fieldName); [EOL] }
protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) { [EOL]     buffer.append(arrayStart); [EOL]     for (int i = 0; i < array.length; i++) { [EOL]         if (i > 0) { [EOL]             buffer.append(arraySeparator); [EOL]         } [EOL]         appendDetail(buffer, fieldName, array[i]); [EOL]     } [EOL]     buffer.append(arrayEnd); [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
protected boolean isUseClassName() { [EOL]     return useClassName; [EOL] }
protected boolean isUseShortClassName() { [EOL]     return useShortClassName; [EOL] }
protected boolean isUseIdentityHashCode() { [EOL]     return useIdentityHashCode; [EOL] }
protected boolean isUseFieldNames() { [EOL]     return useFieldNames; [EOL] }
protected boolean isDefaultFullDetail() { [EOL]     return defaultFullDetail; [EOL] }
protected boolean isArrayContentDetail() { [EOL]     return arrayContentDetail; [EOL] }
protected String getArrayStart() { [EOL]     return arrayStart; [EOL] }
protected String getArrayEnd() { [EOL]     return arrayEnd; [EOL] }
protected String getArraySeparator() { [EOL]     return arraySeparator; [EOL] }
protected String getContentStart() { [EOL]     return contentStart; [EOL] }
protected String getContentEnd() { [EOL]     return contentEnd; [EOL] }
protected String getFieldNameValueSeparator() { [EOL]     return fieldNameValueSeparator; [EOL] }
protected String getFieldSeparator() { [EOL]     return fieldSeparator; [EOL] }
protected boolean isFieldSeparatorAtStart() { [EOL]     return fieldSeparatorAtStart; [EOL] }
protected boolean isFieldSeparatorAtEnd() { [EOL]     return fieldSeparatorAtEnd; [EOL] }
protected String getNullText() { [EOL]     return nullText; [EOL] }
protected String getSizeStartText() { [EOL]     return sizeStartText; [EOL] }
protected String getSizeEndText() { [EOL]     return sizeEndText; [EOL] }
protected String getSummaryObjectStartText() { [EOL]     return summaryObjectStartText; [EOL] }
protected String getSummaryObjectEndText() { [EOL]     return summaryObjectEndText; [EOL] }
methods/lang3/builder/ReflectionToStringBuilder.java
public boolean isAppendStatics() { [EOL]     return this.appendStatics; [EOL] }
public boolean isAppendTransients() { [EOL]     return this.appendTransients; [EOL] }
public boolean isAppendStatics() { [EOL]     return this.appendStatics; [EOL] }
public boolean isAppendTransients() { [EOL]     return this.appendTransients; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         return this.getStyle().getNullText(); [EOL]     } [EOL]     Class<?> clazz = this.getObject().getClass(); [EOL]     this.appendFieldsIn(clazz); [EOL]     while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) { [EOL]         clazz = clazz.getSuperclass(); [EOL]         this.appendFieldsIn(clazz); [EOL]     } [EOL]     return super.toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         return this.getStyle().getNullText(); [EOL]     } [EOL]     Class<?> clazz = this.getObject().getClass(); [EOL]     this.appendFieldsIn(clazz); [EOL]     while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) { [EOL]         clazz = clazz.getSuperclass(); [EOL]         this.appendFieldsIn(clazz); [EOL]     } [EOL]     return super.toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         return this.getStyle().getNullText(); [EOL]     } [EOL]     Class<?> clazz = this.getObject().getClass(); [EOL]     this.appendFieldsIn(clazz); [EOL]     while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) { [EOL]         clazz = clazz.getSuperclass(); [EOL]         this.appendFieldsIn(clazz); [EOL]     } [EOL]     return super.toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         return this.getStyle().getNullText(); [EOL]     } [EOL]     Class<?> clazz = this.getObject().getClass(); [EOL]     this.appendFieldsIn(clazz); [EOL]     while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) { [EOL]         clazz = clazz.getSuperclass(); [EOL]         this.appendFieldsIn(clazz); [EOL]     } [EOL]     return super.toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         return this.getStyle().getNullText(); [EOL]     } [EOL]     Class<?> clazz = this.getObject().getClass(); [EOL]     this.appendFieldsIn(clazz); [EOL]     while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) { [EOL]         clazz = clazz.getSuperclass(); [EOL]         this.appendFieldsIn(clazz); [EOL]     } [EOL]     return super.toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         return this.getStyle().getNullText(); [EOL]     } [EOL]     Class<?> clazz = this.getObject().getClass(); [EOL]     this.appendFieldsIn(clazz); [EOL]     while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) { [EOL]         clazz = clazz.getSuperclass(); [EOL]         this.appendFieldsIn(clazz); [EOL]     } [EOL]     return super.toString(); [EOL] }
static String[] toNoNullStringArray(final Object[] array) { [EOL]     final List<String> list = new ArrayList<String>(array.length); [EOL]     for (final Object e : array) { [EOL]         if (e != null) { [EOL]             list.add(e.toString()); [EOL]         } [EOL]     } [EOL]     return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY); [EOL] }
static String[] toNoNullStringArray(final Object[] array) { [EOL]     final List<String> list = new ArrayList<String>(array.length); [EOL]     for (final Object e : array) { [EOL]         if (e != null) { [EOL]             list.add(e.toString()); [EOL]         } [EOL]     } [EOL]     return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY); [EOL] }
static String[] toNoNullStringArray(final Object[] array) { [EOL]     final List<String> list = new ArrayList<String>(array.length); [EOL]     for (final Object e : array) { [EOL]         if (e != null) { [EOL]             list.add(e.toString()); [EOL]         } [EOL]     } [EOL]     return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY); [EOL] }
static String[] toNoNullStringArray(final Object[] array) { [EOL]     final List<String> list = new ArrayList<String>(array.length); [EOL]     for (final Object e : array) { [EOL]         if (e != null) { [EOL]             list.add(e.toString()); [EOL]         } [EOL]     } [EOL]     return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY); [EOL] }
public boolean isAppendStatics() { [EOL]     return this.appendStatics; [EOL] }
public boolean isAppendStatics() { [EOL]     return this.appendStatics; [EOL] }
public boolean isAppendTransients() { [EOL]     return this.appendTransients; [EOL] }
public boolean isAppendStatics() { [EOL]     return this.appendStatics; [EOL] }
public boolean isAppendTransients() { [EOL]     return this.appendTransients; [EOL] }
public boolean isAppendStatics() { [EOL]     return this.appendStatics; [EOL] }
public boolean isAppendTransients() { [EOL]     return this.appendTransients; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         return this.getStyle().getNullText(); [EOL]     } [EOL]     Class<?> clazz = this.getObject().getClass(); [EOL]     this.appendFieldsIn(clazz); [EOL]     while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) { [EOL]         clazz = clazz.getSuperclass(); [EOL]         this.appendFieldsIn(clazz); [EOL]     } [EOL]     return super.toString(); [EOL] }
public boolean isAppendTransients() { [EOL]     return this.appendTransients; [EOL] }
public boolean isAppendStatics() { [EOL]     return this.appendStatics; [EOL] }
public boolean isAppendTransients() { [EOL]     return this.appendTransients; [EOL] }
public boolean isAppendStatics() { [EOL]     return this.appendStatics; [EOL] }
public boolean isAppendTransients() { [EOL]     return this.appendTransients; [EOL] }
public boolean isAppendStatics() { [EOL]     return this.appendStatics; [EOL] }
public boolean isAppendTransients() { [EOL]     return this.appendTransients; [EOL] }
public boolean isAppendStatics() { [EOL]     return this.appendStatics; [EOL] }
public boolean isAppendTransients() { [EOL]     return this.appendTransients; [EOL] }
public boolean isAppendTransients() { [EOL]     return this.appendTransients; [EOL] }
public boolean isAppendStatics() { [EOL]     return this.appendStatics; [EOL] }
public boolean isAppendStatics() { [EOL]     return this.appendStatics; [EOL] }
public boolean isAppendTransients() { [EOL]     return this.appendTransients; [EOL] }
public boolean isAppendStatics() { [EOL]     return this.appendStatics; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         return this.getStyle().getNullText(); [EOL]     } [EOL]     Class<?> clazz = this.getObject().getClass(); [EOL]     this.appendFieldsIn(clazz); [EOL]     while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) { [EOL]         clazz = clazz.getSuperclass(); [EOL]         this.appendFieldsIn(clazz); [EOL]     } [EOL]     return super.toString(); [EOL] }
public static String toStringExclude(final Object object, final String... excludeFieldNames) { [EOL]     return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         return this.getStyle().getNullText(); [EOL]     } [EOL]     Class<?> clazz = this.getObject().getClass(); [EOL]     this.appendFieldsIn(clazz); [EOL]     while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) { [EOL]         clazz = clazz.getSuperclass(); [EOL]         this.appendFieldsIn(clazz); [EOL]     } [EOL]     return super.toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         return this.getStyle().getNullText(); [EOL]     } [EOL]     Class<?> clazz = this.getObject().getClass(); [EOL]     this.appendFieldsIn(clazz); [EOL]     while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) { [EOL]         clazz = clazz.getSuperclass(); [EOL]         this.appendFieldsIn(clazz); [EOL]     } [EOL]     return super.toString(); [EOL] }
public static String toStringExclude(final Object object, final String... excludeFieldNames) { [EOL]     return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         return this.getStyle().getNullText(); [EOL]     } [EOL]     Class<?> clazz = this.getObject().getClass(); [EOL]     this.appendFieldsIn(clazz); [EOL]     while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) { [EOL]         clazz = clazz.getSuperclass(); [EOL]         this.appendFieldsIn(clazz); [EOL]     } [EOL]     return super.toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         return this.getStyle().getNullText(); [EOL]     } [EOL]     Class<?> clazz = this.getObject().getClass(); [EOL]     this.appendFieldsIn(clazz); [EOL]     while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) { [EOL]         clazz = clazz.getSuperclass(); [EOL]         this.appendFieldsIn(clazz); [EOL]     } [EOL]     return super.toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         return this.getStyle().getNullText(); [EOL]     } [EOL]     Class<?> clazz = this.getObject().getClass(); [EOL]     this.appendFieldsIn(clazz); [EOL]     while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) { [EOL]         clazz = clazz.getSuperclass(); [EOL]         this.appendFieldsIn(clazz); [EOL]     } [EOL]     return super.toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         return this.getStyle().getNullText(); [EOL]     } [EOL]     Class<?> clazz = this.getObject().getClass(); [EOL]     this.appendFieldsIn(clazz); [EOL]     while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) { [EOL]         clazz = clazz.getSuperclass(); [EOL]         this.appendFieldsIn(clazz); [EOL]     } [EOL]     return super.toString(); [EOL] }
public static String toStringExclude(final Object object, final String... excludeFieldNames) { [EOL]     return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString(); [EOL] }
methods/lang3/builder/StandardToStringStyle.java
@Override [EOL] public void setFieldSeparator(final String fieldSeparator) { [EOL]     super.setFieldSeparator(fieldSeparator); [EOL] }
@Override [EOL] public boolean isFieldSeparatorAtStart() { [EOL]     return super.isFieldSeparatorAtStart(); [EOL] }
@Override [EOL] public void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart) { [EOL]     super.setFieldSeparatorAtStart(fieldSeparatorAtStart); [EOL] }
@Override [EOL] public void setFieldSeparator(final String fieldSeparator) { [EOL]     super.setFieldSeparator(fieldSeparator); [EOL] }
@Override [EOL] public boolean isFieldSeparatorAtEnd() { [EOL]     return super.isFieldSeparatorAtEnd(); [EOL] }
@Override [EOL] public void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd) { [EOL]     super.setFieldSeparatorAtEnd(fieldSeparatorAtEnd); [EOL] }
@Override [EOL] public boolean isDefaultFullDetail() { [EOL]     return super.isDefaultFullDetail(); [EOL] }
@Override [EOL] public void setDefaultFullDetail(final boolean defaultFullDetail) { [EOL]     super.setDefaultFullDetail(defaultFullDetail); [EOL] }
@Override [EOL] public String getSummaryObjectStartText() { [EOL]     return super.getSummaryObjectStartText(); [EOL] }
@Override [EOL] public void setSummaryObjectStartText(final String summaryObjectStartText) { [EOL]     super.setSummaryObjectStartText(summaryObjectStartText); [EOL] }
@Override [EOL] public String getSummaryObjectEndText() { [EOL]     return super.getSummaryObjectEndText(); [EOL] }
@Override [EOL] public void setSummaryObjectEndText(final String summaryObjectEndText) { [EOL]     super.setSummaryObjectEndText(summaryObjectEndText); [EOL] }
@Override [EOL] public String getSizeStartText() { [EOL]     return super.getSizeStartText(); [EOL] }
@Override [EOL] public void setSizeStartText(final String sizeStartText) { [EOL]     super.setSizeStartText(sizeStartText); [EOL] }
@Override [EOL] public String getSizeEndText() { [EOL]     return super.getSizeEndText(); [EOL] }
@Override [EOL] public void setSizeEndText(final String sizeEndText) { [EOL]     super.setSizeEndText(sizeEndText); [EOL] }
@Override [EOL] public String getNullText() { [EOL]     return super.getNullText(); [EOL] }
@Override [EOL] public void setNullText(final String nullText) { [EOL]     super.setNullText(nullText); [EOL] }
@Override [EOL] public String getFieldNameValueSeparator() { [EOL]     return super.getFieldNameValueSeparator(); [EOL] }
@Override [EOL] public void setFieldNameValueSeparator(final String fieldNameValueSeparator) { [EOL]     super.setFieldNameValueSeparator(fieldNameValueSeparator); [EOL] }
@Override [EOL] public String getContentStart() { [EOL]     return super.getContentStart(); [EOL] }
@Override [EOL] public void setContentStart(final String contentStart) { [EOL]     super.setContentStart(contentStart); [EOL] }
@Override [EOL] public String getContentEnd() { [EOL]     return super.getContentEnd(); [EOL] }
@Override [EOL] public void setContentEnd(final String contentEnd) { [EOL]     super.setContentEnd(contentEnd); [EOL] }
@Override [EOL] public String getArrayStart() { [EOL]     return super.getArrayStart(); [EOL] }
@Override [EOL] public void setArrayStart(final String arrayStart) { [EOL]     super.setArrayStart(arrayStart); [EOL] }
@Override [EOL] public String getArraySeparator() { [EOL]     return super.getArraySeparator(); [EOL] }
@Override [EOL] public void setArraySeparator(final String arraySeparator) { [EOL]     super.setArraySeparator(arraySeparator); [EOL] }
@Override [EOL] public String getArrayEnd() { [EOL]     return super.getArrayEnd(); [EOL] }
@Override [EOL] public void setArrayEnd(final String arrayEnd) { [EOL]     super.setArrayEnd(arrayEnd); [EOL] }
@Override [EOL] public String getNullText() { [EOL]     return super.getNullText(); [EOL] }
@Override [EOL] public boolean isUseClassName() { [EOL]     return super.isUseClassName(); [EOL] }
@Override [EOL] public boolean isFieldSeparatorAtStart() { [EOL]     return super.isFieldSeparatorAtStart(); [EOL] }
@Override [EOL] public String getContentStart() { [EOL]     return super.getContentStart(); [EOL] }
@Override [EOL] public boolean isUseShortClassName() { [EOL]     return super.isUseShortClassName(); [EOL] }
@Override [EOL] public void setUseShortClassName(final boolean useShortClassName) { [EOL]     super.setUseShortClassName(useShortClassName); [EOL] }
@Override [EOL] public String getFieldSeparator() { [EOL]     return super.getFieldSeparator(); [EOL] }
@Override [EOL] public boolean isUseIdentityHashCode() { [EOL]     return super.isUseIdentityHashCode(); [EOL] }
@Override [EOL] public void setUseIdentityHashCode(final boolean useIdentityHashCode) { [EOL]     super.setUseIdentityHashCode(useIdentityHashCode); [EOL] }
@Override [EOL] public String getContentEnd() { [EOL]     return super.getContentEnd(); [EOL] }
@Override [EOL] public boolean isUseShortClassName() { [EOL]     return super.isUseShortClassName(); [EOL] }
@Override [EOL] public String getFieldSeparator() { [EOL]     return super.getFieldSeparator(); [EOL] }
@Override [EOL] public void setFieldSeparator(final String fieldSeparator) { [EOL]     super.setFieldSeparator(fieldSeparator); [EOL] }
@Override [EOL] public boolean isUseFieldNames() { [EOL]     return super.isUseFieldNames(); [EOL] }
@Override [EOL] public String getSummaryObjectStartText() { [EOL]     return super.getSummaryObjectStartText(); [EOL] }
@Override [EOL] public boolean isUseFieldNames() { [EOL]     return super.isUseFieldNames(); [EOL] }
@Override [EOL] public void setUseFieldNames(final boolean useFieldNames) { [EOL]     super.setUseFieldNames(useFieldNames); [EOL] }
@Override [EOL] public String getSizeStartText() { [EOL]     return super.getSizeStartText(); [EOL] }
@Override [EOL] public String getArrayEnd() { [EOL]     return super.getArrayEnd(); [EOL] }
@Override [EOL] public String getSummaryObjectEndText() { [EOL]     return super.getSummaryObjectEndText(); [EOL] }
@Override [EOL] public String getArrayStart() { [EOL]     return super.getArrayStart(); [EOL] }
@Override [EOL] public boolean isUseIdentityHashCode() { [EOL]     return super.isUseIdentityHashCode(); [EOL] }
@Override [EOL] public String getSizeEndText() { [EOL]     return super.getSizeEndText(); [EOL] }
@Override [EOL] public boolean isArrayContentDetail() { [EOL]     return super.isArrayContentDetail(); [EOL] }
@Override [EOL] public void setArrayContentDetail(final boolean arrayContentDetail) { [EOL]     super.setArrayContentDetail(arrayContentDetail); [EOL] }
@Override [EOL] public String getFieldNameValueSeparator() { [EOL]     return super.getFieldNameValueSeparator(); [EOL] }
@Override [EOL] public boolean isUseClassName() { [EOL]     return super.isUseClassName(); [EOL] }
@Override [EOL] public void setUseClassName(final boolean useClassName) { [EOL]     super.setUseClassName(useClassName); [EOL] }
@Override [EOL] public boolean isFieldSeparatorAtEnd() { [EOL]     return super.isFieldSeparatorAtEnd(); [EOL] }
@Override [EOL] public boolean isArrayContentDetail() { [EOL]     return super.isArrayContentDetail(); [EOL] }
@Override [EOL] public String getArraySeparator() { [EOL]     return super.getArraySeparator(); [EOL] }
@Override [EOL] public boolean isDefaultFullDetail() { [EOL]     return super.isDefaultFullDetail(); [EOL] }
methods/lang3/builder/EqualsBuilder.java
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return true; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     final Class<?> rhsClass = rhs.getClass(); [EOL]     Class<?> testClass; [EOL]     if (lhsClass.isInstance(rhs)) { [EOL]         testClass = lhsClass; [EOL]         if (!rhsClass.isInstance(lhs)) { [EOL]             testClass = rhsClass; [EOL]         } [EOL]     } else if (rhsClass.isInstance(lhs)) { [EOL]         testClass = rhsClass; [EOL]         if (!lhsClass.isInstance(rhs)) { [EOL]             testClass = lhsClass; [EOL]         } [EOL]     } else { [EOL]         return false; [EOL]     } [EOL]     final EqualsBuilder equalsBuilder = new EqualsBuilder(); [EOL]     try { [EOL]         reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         while (testClass.getSuperclass() != null && testClass != reflectUpToClass) { [EOL]             testClass = testClass.getSuperclass(); [EOL]             reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         } [EOL]     } catch (final IllegalArgumentException e) { [EOL]         return false; [EOL]     } [EOL]     return equalsBuilder.isEquals(); [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
static void register(final Object lhs, final Object rhs) { [EOL]     synchronized (EqualsBuilder.class) { [EOL]         if (getRegistry() == null) { [EOL]             REGISTRY.set(new HashSet<Pair<IDKey, IDKey>>()); [EOL]         } [EOL]     } [EOL]     final Set<Pair<IDKey, IDKey>> registry = getRegistry(); [EOL]     final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs); [EOL]     registry.add(pair); [EOL] }
static void unregister(final Object lhs, final Object rhs) { [EOL]     Set<Pair<IDKey, IDKey>> registry = getRegistry(); [EOL]     if (registry != null) { [EOL]         final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs); [EOL]         registry.remove(pair); [EOL]         synchronized (EqualsBuilder.class) { [EOL]             registry = getRegistry(); [EOL]             if (registry != null && registry.isEmpty()) { [EOL]                 REGISTRY.remove(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return true; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     final Class<?> rhsClass = rhs.getClass(); [EOL]     Class<?> testClass; [EOL]     if (lhsClass.isInstance(rhs)) { [EOL]         testClass = lhsClass; [EOL]         if (!rhsClass.isInstance(lhs)) { [EOL]             testClass = rhsClass; [EOL]         } [EOL]     } else if (rhsClass.isInstance(lhs)) { [EOL]         testClass = rhsClass; [EOL]         if (!lhsClass.isInstance(rhs)) { [EOL]             testClass = lhsClass; [EOL]         } [EOL]     } else { [EOL]         return false; [EOL]     } [EOL]     final EqualsBuilder equalsBuilder = new EqualsBuilder(); [EOL]     try { [EOL]         reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         while (testClass.getSuperclass() != null && testClass != reflectUpToClass) { [EOL]             testClass = testClass.getSuperclass(); [EOL]             reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         } [EOL]     } catch (final IllegalArgumentException e) { [EOL]         return false; [EOL]     } [EOL]     return equalsBuilder.isEquals(); [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
public EqualsBuilder appendSuper(final boolean superEquals) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = superEquals; [EOL]     return this; [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public void reset() { [EOL]     this.isEquals = true; [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
static Pair<IDKey, IDKey> getRegisterPair(final Object lhs, final Object rhs) { [EOL]     final IDKey left = new IDKey(lhs); [EOL]     final IDKey right = new IDKey(rhs); [EOL]     return Pair.of(left, right); [EOL] }
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return true; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     final Class<?> rhsClass = rhs.getClass(); [EOL]     Class<?> testClass; [EOL]     if (lhsClass.isInstance(rhs)) { [EOL]         testClass = lhsClass; [EOL]         if (!rhsClass.isInstance(lhs)) { [EOL]             testClass = rhsClass; [EOL]         } [EOL]     } else if (rhsClass.isInstance(lhs)) { [EOL]         testClass = rhsClass; [EOL]         if (!lhsClass.isInstance(rhs)) { [EOL]             testClass = lhsClass; [EOL]         } [EOL]     } else { [EOL]         return false; [EOL]     } [EOL]     final EqualsBuilder equalsBuilder = new EqualsBuilder(); [EOL]     try { [EOL]         reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         while (testClass.getSuperclass() != null && testClass != reflectUpToClass) { [EOL]             testClass = testClass.getSuperclass(); [EOL]             reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         } [EOL]     } catch (final IllegalArgumentException e) { [EOL]         return false; [EOL]     } [EOL]     return equalsBuilder.isEquals(); [EOL] }
public EqualsBuilder appendSuper(final boolean superEquals) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = superEquals; [EOL]     return this; [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
static void register(final Object lhs, final Object rhs) { [EOL]     synchronized (EqualsBuilder.class) { [EOL]         if (getRegistry() == null) { [EOL]             REGISTRY.set(new HashSet<Pair<IDKey, IDKey>>()); [EOL]         } [EOL]     } [EOL]     final Set<Pair<IDKey, IDKey>> registry = getRegistry(); [EOL]     final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs); [EOL]     registry.add(pair); [EOL] }
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return true; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     final Class<?> rhsClass = rhs.getClass(); [EOL]     Class<?> testClass; [EOL]     if (lhsClass.isInstance(rhs)) { [EOL]         testClass = lhsClass; [EOL]         if (!rhsClass.isInstance(lhs)) { [EOL]             testClass = rhsClass; [EOL]         } [EOL]     } else if (rhsClass.isInstance(lhs)) { [EOL]         testClass = rhsClass; [EOL]         if (!lhsClass.isInstance(rhs)) { [EOL]             testClass = lhsClass; [EOL]         } [EOL]     } else { [EOL]         return false; [EOL]     } [EOL]     final EqualsBuilder equalsBuilder = new EqualsBuilder(); [EOL]     try { [EOL]         reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         while (testClass.getSuperclass() != null && testClass != reflectUpToClass) { [EOL]             testClass = testClass.getSuperclass(); [EOL]             reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         } [EOL]     } catch (final IllegalArgumentException e) { [EOL]         return false; [EOL]     } [EOL]     return equalsBuilder.isEquals(); [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public void reset() { [EOL]     this.isEquals = true; [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
public EqualsBuilder appendSuper(final boolean superEquals) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = superEquals; [EOL]     return this; [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
public EqualsBuilder appendSuper(final boolean superEquals) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = superEquals; [EOL]     return this; [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
static Pair<IDKey, IDKey> getRegisterPair(final Object lhs, final Object rhs) { [EOL]     final IDKey left = new IDKey(lhs); [EOL]     final IDKey right = new IDKey(rhs); [EOL]     return Pair.of(left, right); [EOL] }
public EqualsBuilder appendSuper(final boolean superEquals) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = superEquals; [EOL]     return this; [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
protected void setEquals(final boolean isEquals) { [EOL]     this.isEquals = isEquals; [EOL] }
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return true; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     final Class<?> rhsClass = rhs.getClass(); [EOL]     Class<?> testClass; [EOL]     if (lhsClass.isInstance(rhs)) { [EOL]         testClass = lhsClass; [EOL]         if (!rhsClass.isInstance(lhs)) { [EOL]             testClass = rhsClass; [EOL]         } [EOL]     } else if (rhsClass.isInstance(lhs)) { [EOL]         testClass = rhsClass; [EOL]         if (!lhsClass.isInstance(rhs)) { [EOL]             testClass = lhsClass; [EOL]         } [EOL]     } else { [EOL]         return false; [EOL]     } [EOL]     final EqualsBuilder equalsBuilder = new EqualsBuilder(); [EOL]     try { [EOL]         reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         while (testClass.getSuperclass() != null && testClass != reflectUpToClass) { [EOL]             testClass = testClass.getSuperclass(); [EOL]             reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         } [EOL]     } catch (final IllegalArgumentException e) { [EOL]         return false; [EOL]     } [EOL]     return equalsBuilder.isEquals(); [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
public EqualsBuilder appendSuper(final boolean superEquals) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = superEquals; [EOL]     return this; [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return true; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     final Class<?> rhsClass = rhs.getClass(); [EOL]     Class<?> testClass; [EOL]     if (lhsClass.isInstance(rhs)) { [EOL]         testClass = lhsClass; [EOL]         if (!rhsClass.isInstance(lhs)) { [EOL]             testClass = rhsClass; [EOL]         } [EOL]     } else if (rhsClass.isInstance(lhs)) { [EOL]         testClass = rhsClass; [EOL]         if (!lhsClass.isInstance(rhs)) { [EOL]             testClass = lhsClass; [EOL]         } [EOL]     } else { [EOL]         return false; [EOL]     } [EOL]     final EqualsBuilder equalsBuilder = new EqualsBuilder(); [EOL]     try { [EOL]         reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         while (testClass.getSuperclass() != null && testClass != reflectUpToClass) { [EOL]             testClass = testClass.getSuperclass(); [EOL]             reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         } [EOL]     } catch (final IllegalArgumentException e) { [EOL]         return false; [EOL]     } [EOL]     return equalsBuilder.isEquals(); [EOL] }
public EqualsBuilder appendSuper(final boolean superEquals) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = superEquals; [EOL]     return this; [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return true; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     final Class<?> rhsClass = rhs.getClass(); [EOL]     Class<?> testClass; [EOL]     if (lhsClass.isInstance(rhs)) { [EOL]         testClass = lhsClass; [EOL]         if (!rhsClass.isInstance(lhs)) { [EOL]             testClass = rhsClass; [EOL]         } [EOL]     } else if (rhsClass.isInstance(lhs)) { [EOL]         testClass = rhsClass; [EOL]         if (!lhsClass.isInstance(rhs)) { [EOL]             testClass = lhsClass; [EOL]         } [EOL]     } else { [EOL]         return false; [EOL]     } [EOL]     final EqualsBuilder equalsBuilder = new EqualsBuilder(); [EOL]     try { [EOL]         reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         while (testClass.getSuperclass() != null && testClass != reflectUpToClass) { [EOL]             testClass = testClass.getSuperclass(); [EOL]             reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         } [EOL]     } catch (final IllegalArgumentException e) { [EOL]         return false; [EOL]     } [EOL]     return equalsBuilder.isEquals(); [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
static Pair<IDKey, IDKey> getRegisterPair(final Object lhs, final Object rhs) { [EOL]     final IDKey left = new IDKey(lhs); [EOL]     final IDKey right = new IDKey(rhs); [EOL]     return Pair.of(left, right); [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
public EqualsBuilder appendSuper(final boolean superEquals) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = superEquals; [EOL]     return this; [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
static Pair<IDKey, IDKey> getRegisterPair(final Object lhs, final Object rhs) { [EOL]     final IDKey left = new IDKey(lhs); [EOL]     final IDKey right = new IDKey(rhs); [EOL]     return Pair.of(left, right); [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
static void register(final Object lhs, final Object rhs) { [EOL]     synchronized (EqualsBuilder.class) { [EOL]         if (getRegistry() == null) { [EOL]             REGISTRY.set(new HashSet<Pair<IDKey, IDKey>>()); [EOL]         } [EOL]     } [EOL]     final Set<Pair<IDKey, IDKey>> registry = getRegistry(); [EOL]     final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs); [EOL]     registry.add(pair); [EOL] }
static void unregister(final Object lhs, final Object rhs) { [EOL]     Set<Pair<IDKey, IDKey>> registry = getRegistry(); [EOL]     if (registry != null) { [EOL]         final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs); [EOL]         registry.remove(pair); [EOL]         synchronized (EqualsBuilder.class) { [EOL]             registry = getRegistry(); [EOL]             if (registry != null && registry.isEmpty()) { [EOL]                 REGISTRY.remove(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return true; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     final Class<?> rhsClass = rhs.getClass(); [EOL]     Class<?> testClass; [EOL]     if (lhsClass.isInstance(rhs)) { [EOL]         testClass = lhsClass; [EOL]         if (!rhsClass.isInstance(lhs)) { [EOL]             testClass = rhsClass; [EOL]         } [EOL]     } else if (rhsClass.isInstance(lhs)) { [EOL]         testClass = rhsClass; [EOL]         if (!lhsClass.isInstance(rhs)) { [EOL]             testClass = lhsClass; [EOL]         } [EOL]     } else { [EOL]         return false; [EOL]     } [EOL]     final EqualsBuilder equalsBuilder = new EqualsBuilder(); [EOL]     try { [EOL]         reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         while (testClass.getSuperclass() != null && testClass != reflectUpToClass) { [EOL]             testClass = testClass.getSuperclass(); [EOL]             reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         } [EOL]     } catch (final IllegalArgumentException e) { [EOL]         return false; [EOL]     } [EOL]     return equalsBuilder.isEquals(); [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
static Set<Pair<IDKey, IDKey>> getRegistry() { [EOL]     return REGISTRY.get(); [EOL] }
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return true; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     final Class<?> rhsClass = rhs.getClass(); [EOL]     Class<?> testClass; [EOL]     if (lhsClass.isInstance(rhs)) { [EOL]         testClass = lhsClass; [EOL]         if (!rhsClass.isInstance(lhs)) { [EOL]             testClass = rhsClass; [EOL]         } [EOL]     } else if (rhsClass.isInstance(lhs)) { [EOL]         testClass = rhsClass; [EOL]         if (!lhsClass.isInstance(rhs)) { [EOL]             testClass = lhsClass; [EOL]         } [EOL]     } else { [EOL]         return false; [EOL]     } [EOL]     final EqualsBuilder equalsBuilder = new EqualsBuilder(); [EOL]     try { [EOL]         reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         while (testClass.getSuperclass() != null && testClass != reflectUpToClass) { [EOL]             testClass = testClass.getSuperclass(); [EOL]             reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         } [EOL]     } catch (final IllegalArgumentException e) { [EOL]         return false; [EOL]     } [EOL]     return equalsBuilder.isEquals(); [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder appendSuper(final boolean superEquals) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = superEquals; [EOL]     return this; [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
protected void setEquals(final boolean isEquals) { [EOL]     this.isEquals = isEquals; [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
static void register(final Object lhs, final Object rhs) { [EOL]     synchronized (EqualsBuilder.class) { [EOL]         if (getRegistry() == null) { [EOL]             REGISTRY.set(new HashSet<Pair<IDKey, IDKey>>()); [EOL]         } [EOL]     } [EOL]     final Set<Pair<IDKey, IDKey>> registry = getRegistry(); [EOL]     final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs); [EOL]     registry.add(pair); [EOL] }
static void unregister(final Object lhs, final Object rhs) { [EOL]     Set<Pair<IDKey, IDKey>> registry = getRegistry(); [EOL]     if (registry != null) { [EOL]         final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs); [EOL]         registry.remove(pair); [EOL]         synchronized (EqualsBuilder.class) { [EOL]             registry = getRegistry(); [EOL]             if (registry != null && registry.isEmpty()) { [EOL]                 REGISTRY.remove(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
public EqualsBuilder appendSuper(final boolean superEquals) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = superEquals; [EOL]     return this; [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return true; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     final Class<?> rhsClass = rhs.getClass(); [EOL]     Class<?> testClass; [EOL]     if (lhsClass.isInstance(rhs)) { [EOL]         testClass = lhsClass; [EOL]         if (!rhsClass.isInstance(lhs)) { [EOL]             testClass = rhsClass; [EOL]         } [EOL]     } else if (rhsClass.isInstance(lhs)) { [EOL]         testClass = rhsClass; [EOL]         if (!lhsClass.isInstance(rhs)) { [EOL]             testClass = lhsClass; [EOL]         } [EOL]     } else { [EOL]         return false; [EOL]     } [EOL]     final EqualsBuilder equalsBuilder = new EqualsBuilder(); [EOL]     try { [EOL]         reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         while (testClass.getSuperclass() != null && testClass != reflectUpToClass) { [EOL]             testClass = testClass.getSuperclass(); [EOL]             reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         } [EOL]     } catch (final IllegalArgumentException e) { [EOL]         return false; [EOL]     } [EOL]     return equalsBuilder.isEquals(); [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
public EqualsBuilder appendSuper(final boolean superEquals) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = superEquals; [EOL]     return this; [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return true; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     final Class<?> rhsClass = rhs.getClass(); [EOL]     Class<?> testClass; [EOL]     if (lhsClass.isInstance(rhs)) { [EOL]         testClass = lhsClass; [EOL]         if (!rhsClass.isInstance(lhs)) { [EOL]             testClass = rhsClass; [EOL]         } [EOL]     } else if (rhsClass.isInstance(lhs)) { [EOL]         testClass = rhsClass; [EOL]         if (!lhsClass.isInstance(rhs)) { [EOL]             testClass = lhsClass; [EOL]         } [EOL]     } else { [EOL]         return false; [EOL]     } [EOL]     final EqualsBuilder equalsBuilder = new EqualsBuilder(); [EOL]     try { [EOL]         reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         while (testClass.getSuperclass() != null && testClass != reflectUpToClass) { [EOL]             testClass = testClass.getSuperclass(); [EOL]             reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         } [EOL]     } catch (final IllegalArgumentException e) { [EOL]         return false; [EOL]     } [EOL]     return equalsBuilder.isEquals(); [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public EqualsBuilder appendSuper(final boolean superEquals) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = superEquals; [EOL]     return this; [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
static void register(final Object lhs, final Object rhs) { [EOL]     synchronized (EqualsBuilder.class) { [EOL]         if (getRegistry() == null) { [EOL]             REGISTRY.set(new HashSet<Pair<IDKey, IDKey>>()); [EOL]         } [EOL]     } [EOL]     final Set<Pair<IDKey, IDKey>> registry = getRegistry(); [EOL]     final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs); [EOL]     registry.add(pair); [EOL] }
static void unregister(final Object lhs, final Object rhs) { [EOL]     Set<Pair<IDKey, IDKey>> registry = getRegistry(); [EOL]     if (registry != null) { [EOL]         final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs); [EOL]         registry.remove(pair); [EOL]         synchronized (EqualsBuilder.class) { [EOL]             registry = getRegistry(); [EOL]             if (registry != null && registry.isEmpty()) { [EOL]                 REGISTRY.remove(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
static void register(final Object lhs, final Object rhs) { [EOL]     synchronized (EqualsBuilder.class) { [EOL]         if (getRegistry() == null) { [EOL]             REGISTRY.set(new HashSet<Pair<IDKey, IDKey>>()); [EOL]         } [EOL]     } [EOL]     final Set<Pair<IDKey, IDKey>> registry = getRegistry(); [EOL]     final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs); [EOL]     registry.add(pair); [EOL] }
static void unregister(final Object lhs, final Object rhs) { [EOL]     Set<Pair<IDKey, IDKey>> registry = getRegistry(); [EOL]     if (registry != null) { [EOL]         final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs); [EOL]         registry.remove(pair); [EOL]         synchronized (EqualsBuilder.class) { [EOL]             registry = getRegistry(); [EOL]             if (registry != null && registry.isEmpty()) { [EOL]                 REGISTRY.remove(); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return true; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         return false; [EOL]     } [EOL]     final Class<?> lhsClass = lhs.getClass(); [EOL]     final Class<?> rhsClass = rhs.getClass(); [EOL]     Class<?> testClass; [EOL]     if (lhsClass.isInstance(rhs)) { [EOL]         testClass = lhsClass; [EOL]         if (!rhsClass.isInstance(lhs)) { [EOL]             testClass = rhsClass; [EOL]         } [EOL]     } else if (rhsClass.isInstance(lhs)) { [EOL]         testClass = rhsClass; [EOL]         if (!lhsClass.isInstance(rhs)) { [EOL]             testClass = lhsClass; [EOL]         } [EOL]     } else { [EOL]         return false; [EOL]     } [EOL]     final EqualsBuilder equalsBuilder = new EqualsBuilder(); [EOL]     try { [EOL]         reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         while (testClass.getSuperclass() != null && testClass != reflectUpToClass) { [EOL]             testClass = testClass.getSuperclass(); [EOL]             reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields); [EOL]         } [EOL]     } catch (final IllegalArgumentException e) { [EOL]         return false; [EOL]     } [EOL]     return equalsBuilder.isEquals(); [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
protected void setEquals(final boolean isEquals) { [EOL]     this.isEquals = isEquals; [EOL] }
public void reset() { [EOL]     this.isEquals = true; [EOL] }
public EqualsBuilder appendSuper(final boolean superEquals) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     isEquals = superEquals; [EOL]     return this; [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
static Set<Pair<IDKey, IDKey>> getRegistry() { [EOL]     return REGISTRY.get(); [EOL] }
public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (isEquals == false) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         this.setEquals(false); [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && isEquals; ++i) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public boolean isEquals() { [EOL]     return this.isEquals; [EOL] }
@Override [EOL] public Boolean build() { [EOL]     return Boolean.valueOf(isEquals()); [EOL] }
methods/lang3/builder/HashCodeBuilder.java
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public int toHashCode() { [EOL]     return iTotal; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public int toHashCode() { [EOL]     return iTotal; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public static int reflectionHashCode(final Object object, final String... excludeFields) { [EOL]     return reflectionHashCode(17, 37, object, false, null, excludeFields); [EOL] }
public static int reflectionHashCode(final Object object, final String... excludeFields) { [EOL]     return reflectionHashCode(17, 37, object, false, null, excludeFields); [EOL] }
public static int reflectionHashCode(final Object object, final String... excludeFields) { [EOL]     return reflectionHashCode(17, 37, object, false, null, excludeFields); [EOL] }
public static int reflectionHashCode(final Object object, final String... excludeFields) { [EOL]     return reflectionHashCode(17, 37, object, false, null, excludeFields); [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public static int reflectionHashCode(final Object object, final String... excludeFields) { [EOL]     return reflectionHashCode(17, 37, object, false, null, excludeFields); [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public static int reflectionHashCode(final Object object, final String... excludeFields) { [EOL]     return reflectionHashCode(17, 37, object, false, null, excludeFields); [EOL] }
public int toHashCode() { [EOL]     return iTotal; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
static Set<IDKey> getRegistry() { [EOL]     return REGISTRY.get(); [EOL] }
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public int toHashCode() { [EOL]     return iTotal; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public int toHashCode() { [EOL]     return iTotal; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public int toHashCode() { [EOL]     return iTotal; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public int toHashCode() { [EOL]     return iTotal; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public int toHashCode() { [EOL]     return iTotal; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public int toHashCode() { [EOL]     return iTotal; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public int toHashCode() { [EOL]     return iTotal; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public int toHashCode() { [EOL]     return iTotal; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public int toHashCode() { [EOL]     return iTotal; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public int toHashCode() { [EOL]     return iTotal; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder appendSuper(final int superHashCode) { [EOL]     iTotal = iTotal * iConstant + superHashCode; [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public int toHashCode() { [EOL]     return iTotal; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public int toHashCode() { [EOL]     return iTotal; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public int toHashCode() { [EOL]     return iTotal; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public int toHashCode() { [EOL]     return iTotal; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public int toHashCode() { [EOL]     return iTotal; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public int toHashCode() { [EOL]     return iTotal; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public static int reflectionHashCode(final Object object, final String... excludeFields) { [EOL]     return reflectionHashCode(17, 37, object, false, null, excludeFields); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public int toHashCode() { [EOL]     return iTotal; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public int toHashCode() { [EOL]     return iTotal; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public static int reflectionHashCode(final Object object, final String... excludeFields) { [EOL]     return reflectionHashCode(17, 37, object, false, null, excludeFields); [EOL] }
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public int toHashCode() { [EOL]     return iTotal; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public int toHashCode() { [EOL]     return iTotal; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public static int reflectionHashCode(final Object object, final String... excludeFields) { [EOL]     return reflectionHashCode(17, 37, object, false, null, excludeFields); [EOL] }
public static int reflectionHashCode(final Object object, final String... excludeFields) { [EOL]     return reflectionHashCode(17, 37, object, false, null, excludeFields); [EOL] }
static void register(final Object value) { [EOL]     synchronized (HashCodeBuilder.class) { [EOL]         if (getRegistry() == null) { [EOL]             REGISTRY.set(new HashSet<IDKey>()); [EOL]         } [EOL]     } [EOL]     getRegistry().add(new IDKey(value)); [EOL] }
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public int toHashCode() { [EOL]     return iTotal; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public HashCodeBuilder appendSuper(final int superHashCode) { [EOL]     iTotal = iTotal * iConstant + superHashCode; [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
public HashCodeBuilder append(final short[] array) { [EOL]     if (array == null) { [EOL]         iTotal = iTotal * iConstant; [EOL]     } else { [EOL]         for (final short element : array) { [EOL]             append(element); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toHashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return toHashCode(); [EOL] }
methods/lang3/builder/CompareToBuilder.java
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder appendSuper(final int superCompareTo) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     comparison = superCompareTo; [EOL]     return this; [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return 0; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         throw new NullPointerException(); [EOL]     } [EOL]     Class<?> lhsClazz = lhs.getClass(); [EOL]     if (!lhsClazz.isInstance(rhs)) { [EOL]         throw new ClassCastException(); [EOL]     } [EOL]     final CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL]     reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) { [EOL]         lhsClazz = lhsClazz.getSuperclass(); [EOL]         reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     } [EOL]     return compareToBuilder.toComparison(); [EOL] }
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return 0; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         throw new NullPointerException(); [EOL]     } [EOL]     Class<?> lhsClazz = lhs.getClass(); [EOL]     if (!lhsClazz.isInstance(rhs)) { [EOL]         throw new ClassCastException(); [EOL]     } [EOL]     final CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL]     reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) { [EOL]         lhsClazz = lhsClazz.getSuperclass(); [EOL]         reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     } [EOL]     return compareToBuilder.toComparison(); [EOL] }
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return 0; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         throw new NullPointerException(); [EOL]     } [EOL]     Class<?> lhsClazz = lhs.getClass(); [EOL]     if (!lhsClazz.isInstance(rhs)) { [EOL]         throw new ClassCastException(); [EOL]     } [EOL]     final CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL]     reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) { [EOL]         lhsClazz = lhsClazz.getSuperclass(); [EOL]         reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     } [EOL]     return compareToBuilder.toComparison(); [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return 0; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         throw new NullPointerException(); [EOL]     } [EOL]     Class<?> lhsClazz = lhs.getClass(); [EOL]     if (!lhsClazz.isInstance(rhs)) { [EOL]         throw new ClassCastException(); [EOL]     } [EOL]     final CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL]     reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) { [EOL]         lhsClazz = lhsClazz.getSuperclass(); [EOL]         reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     } [EOL]     return compareToBuilder.toComparison(); [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return 0; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         throw new NullPointerException(); [EOL]     } [EOL]     Class<?> lhsClazz = lhs.getClass(); [EOL]     if (!lhsClazz.isInstance(rhs)) { [EOL]         throw new ClassCastException(); [EOL]     } [EOL]     final CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL]     reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) { [EOL]         lhsClazz = lhsClazz.getSuperclass(); [EOL]         reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     } [EOL]     return compareToBuilder.toComparison(); [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder appendSuper(final int superCompareTo) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     comparison = superCompareTo; [EOL]     return this; [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public CompareToBuilder appendSuper(final int superCompareTo) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     comparison = superCompareTo; [EOL]     return this; [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return 0; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         throw new NullPointerException(); [EOL]     } [EOL]     Class<?> lhsClazz = lhs.getClass(); [EOL]     if (!lhsClazz.isInstance(rhs)) { [EOL]         throw new ClassCastException(); [EOL]     } [EOL]     final CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL]     reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) { [EOL]         lhsClazz = lhsClazz.getSuperclass(); [EOL]         reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     } [EOL]     return compareToBuilder.toComparison(); [EOL] }
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return 0; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         throw new NullPointerException(); [EOL]     } [EOL]     Class<?> lhsClazz = lhs.getClass(); [EOL]     if (!lhsClazz.isInstance(rhs)) { [EOL]         throw new ClassCastException(); [EOL]     } [EOL]     final CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL]     reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) { [EOL]         lhsClazz = lhsClazz.getSuperclass(); [EOL]         reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     } [EOL]     return compareToBuilder.toComparison(); [EOL] }
public int toComparison() { [EOL]     return comparison; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return 0; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         throw new NullPointerException(); [EOL]     } [EOL]     Class<?> lhsClazz = lhs.getClass(); [EOL]     if (!lhsClazz.isInstance(rhs)) { [EOL]         throw new ClassCastException(); [EOL]     } [EOL]     final CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL]     reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) { [EOL]         lhsClazz = lhsClazz.getSuperclass(); [EOL]         reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     } [EOL]     return compareToBuilder.toComparison(); [EOL] }
public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) { [EOL]     if (comparison != 0) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == rhs) { [EOL]         return this; [EOL]     } [EOL]     if (lhs == null) { [EOL]         comparison = -1; [EOL]         return this; [EOL]     } [EOL]     if (rhs == null) { [EOL]         comparison = +1; [EOL]         return this; [EOL]     } [EOL]     if (lhs.length != rhs.length) { [EOL]         comparison = (lhs.length < rhs.length) ? -1 : +1; [EOL]         return this; [EOL]     } [EOL]     for (int i = 0; i < lhs.length && comparison == 0; i++) { [EOL]         append(lhs[i], rhs[i]); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public Integer build() { [EOL]     return Integer.valueOf(toComparison()); [EOL] }
public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields) { [EOL]     if (lhs == rhs) { [EOL]         return 0; [EOL]     } [EOL]     if (lhs == null || rhs == null) { [EOL]         throw new NullPointerException(); [EOL]     } [EOL]     Class<?> lhsClazz = lhs.getClass(); [EOL]     if (!lhsClazz.isInstance(rhs)) { [EOL]         throw new ClassCastException(); [EOL]     } [EOL]     final CompareToBuilder compareToBuilder = new CompareToBuilder(); [EOL]     reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) { [EOL]         lhsClazz = lhsClazz.getSuperclass(); [EOL]         reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields); [EOL]     } [EOL]     return compareToBuilder.toComparison(); [EOL] }
methods/lang3/builder/ToStringBuilder.java
public static <T> String reflectionToString(final T object, final ToStringStyle style, final boolean outputTransients, final Class<? super T> reflectUpToClass) { [EOL]     return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public static <T> String reflectionToString(final T object, final ToStringStyle style, final boolean outputTransients, final Class<? super T> reflectUpToClass) { [EOL]     return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public static <T> String reflectionToString(final T object, final ToStringStyle style, final boolean outputTransients, final Class<? super T> reflectUpToClass) { [EOL]     return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public StringBuffer getStringBuffer() { [EOL]     return buffer; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public Object getObject() { [EOL]     return object; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
@Override [EOL] public String build() { [EOL]     return toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringStyle getStyle() { [EOL]     return style; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public StringBuffer getStringBuffer() { [EOL]     return buffer; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public Object getObject() { [EOL]     return object; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
public ToStringBuilder appendToString(final String toString) { [EOL]     if (toString != null) { [EOL]         style.appendToString(buffer, toString); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
public ToStringBuilder appendToString(final String toString) { [EOL]     if (toString != null) { [EOL]         style.appendToString(buffer, toString); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
public ToStringBuilder appendSuper(final String superToString) { [EOL]     if (superToString != null) { [EOL]         style.appendSuper(buffer, superToString); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
public ToStringBuilder appendSuper(final String superToString) { [EOL]     if (superToString != null) { [EOL]         style.appendSuper(buffer, superToString); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public static <T> String reflectionToString(final T object, final ToStringStyle style, final boolean outputTransients, final Class<? super T> reflectUpToClass) { [EOL]     return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public static ToStringStyle getDefaultStyle() { [EOL]     return defaultStyle; [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public static <T> String reflectionToString(final T object, final ToStringStyle style, final boolean outputTransients, final Class<? super T> reflectUpToClass) { [EOL]     return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public static <T> String reflectionToString(final T object, final ToStringStyle style, final boolean outputTransients, final Class<? super T> reflectUpToClass) { [EOL]     return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
public ToStringBuilder appendAsObjectToString(final Object object) { [EOL]     ObjectUtils.identityToString(this.getStringBuffer(), object); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public static ToStringStyle getDefaultStyle() { [EOL]     return defaultStyle; [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public static ToStringStyle getDefaultStyle() { [EOL]     return defaultStyle; [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public static ToStringStyle getDefaultStyle() { [EOL]     return defaultStyle; [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public static ToStringStyle getDefaultStyle() { [EOL]     return defaultStyle; [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
@Override [EOL] public String build() { [EOL]     return toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public static <T> String reflectionToString(final T object, final ToStringStyle style, final boolean outputTransients, final Class<? super T> reflectUpToClass) { [EOL]     return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public static ToStringStyle getDefaultStyle() { [EOL]     return defaultStyle; [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
@Override [EOL] public String build() { [EOL]     return toString(); [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
public static ToStringStyle getDefaultStyle() { [EOL]     return defaultStyle; [EOL] }
public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) { [EOL]     style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail)); [EOL]     return this; [EOL] }
@Override [EOL] public String toString() { [EOL]     if (this.getObject() == null) { [EOL]         this.getStringBuffer().append(this.getStyle().getNullText()); [EOL]     } else { [EOL]         style.appendEnd(this.getStringBuffer(), this.getObject()); [EOL]     } [EOL]     return this.getStringBuffer().toString(); [EOL] }
methods/lang3/time/DateFormatUtils.java
public static String formatUTC(final Date date, final String pattern, final Locale locale) { [EOL]     return format(date, pattern, UTC_TIME_ZONE, locale); [EOL] }
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL]     return df.format(calendar); [EOL] }
public static String formatUTC(final Date date, final String pattern, final Locale locale) { [EOL]     return format(date, pattern, UTC_TIME_ZONE, locale); [EOL] }
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL]     return df.format(calendar); [EOL] }
public static String formatUTC(final Date date, final String pattern, final Locale locale) { [EOL]     return format(date, pattern, UTC_TIME_ZONE, locale); [EOL] }
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL]     return df.format(calendar); [EOL] }
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL]     return df.format(calendar); [EOL] }

public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL]     return df.format(calendar); [EOL] }

public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL]     return df.format(calendar); [EOL] }
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL]     return df.format(calendar); [EOL] }
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL]     return df.format(calendar); [EOL] }

public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL]     return df.format(calendar); [EOL] }
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL]     return df.format(calendar); [EOL] }
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL]     return df.format(calendar); [EOL] }
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL]     return df.format(calendar); [EOL] }
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL]     return df.format(calendar); [EOL] }
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL]     return df.format(calendar); [EOL] }

public static String formatUTC(final Date date, final String pattern, final Locale locale) { [EOL]     return format(date, pattern, UTC_TIME_ZONE, locale); [EOL] }
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL]     return df.format(calendar); [EOL] }
public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale); [EOL]     return df.format(calendar); [EOL] }
methods/lang3/time/StopWatch.java
public void start() { [EOL]     if (this.runningState == STATE_STOPPED) { [EOL]         throw new IllegalStateException("Stopwatch must be reset before being restarted. "); [EOL]     } [EOL]     if (this.runningState != STATE_UNSTARTED) { [EOL]         throw new IllegalStateException("Stopwatch already started. "); [EOL]     } [EOL]     this.startTime = System.nanoTime(); [EOL]     this.startTimeMillis = System.currentTimeMillis(); [EOL]     this.runningState = STATE_RUNNING; [EOL] }
public void stop() { [EOL]     if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { [EOL]         throw new IllegalStateException("Stopwatch is not running. "); [EOL]     } [EOL]     if (this.runningState == STATE_RUNNING) { [EOL]         this.stopTime = System.nanoTime(); [EOL]     } [EOL]     this.runningState = STATE_STOPPED; [EOL] }
public void suspend() { [EOL]     if (this.runningState != STATE_RUNNING) { [EOL]         throw new IllegalStateException("Stopwatch must be running to suspend. "); [EOL]     } [EOL]     this.stopTime = System.nanoTime(); [EOL]     this.runningState = STATE_SUSPENDED; [EOL] }
@Override [EOL] public String toString() { [EOL]     return DurationFormatUtils.formatDurationHMS(getTime()); [EOL] }
public void start() { [EOL]     if (this.runningState == STATE_STOPPED) { [EOL]         throw new IllegalStateException("Stopwatch must be reset before being restarted. "); [EOL]     } [EOL]     if (this.runningState != STATE_UNSTARTED) { [EOL]         throw new IllegalStateException("Stopwatch already started. "); [EOL]     } [EOL]     this.startTime = System.nanoTime(); [EOL]     this.startTimeMillis = System.currentTimeMillis(); [EOL]     this.runningState = STATE_RUNNING; [EOL] }
public void stop() { [EOL]     if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { [EOL]         throw new IllegalStateException("Stopwatch is not running. "); [EOL]     } [EOL]     if (this.runningState == STATE_RUNNING) { [EOL]         this.stopTime = System.nanoTime(); [EOL]     } [EOL]     this.runningState = STATE_STOPPED; [EOL] }
public void split() { [EOL]     if (this.runningState != STATE_RUNNING) { [EOL]         throw new IllegalStateException("Stopwatch is not running. "); [EOL]     } [EOL]     this.stopTime = System.nanoTime(); [EOL]     this.splitState = STATE_SPLIT; [EOL] }
public String toSplitString() { [EOL]     return DurationFormatUtils.formatDurationHMS(getSplitTime()); [EOL] }
public void start() { [EOL]     if (this.runningState == STATE_STOPPED) { [EOL]         throw new IllegalStateException("Stopwatch must be reset before being restarted. "); [EOL]     } [EOL]     if (this.runningState != STATE_UNSTARTED) { [EOL]         throw new IllegalStateException("Stopwatch already started. "); [EOL]     } [EOL]     this.startTime = System.nanoTime(); [EOL]     this.startTimeMillis = System.currentTimeMillis(); [EOL]     this.runningState = STATE_RUNNING; [EOL] }
public void stop() { [EOL]     if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { [EOL]         throw new IllegalStateException("Stopwatch is not running. "); [EOL]     } [EOL]     if (this.runningState == STATE_RUNNING) { [EOL]         this.stopTime = System.nanoTime(); [EOL]     } [EOL]     this.runningState = STATE_STOPPED; [EOL] }
public long getTime() { [EOL]     return getNanoTime() / NANO_2_MILLIS; [EOL] }
public void start() { [EOL]     if (this.runningState == STATE_STOPPED) { [EOL]         throw new IllegalStateException("Stopwatch must be reset before being restarted. "); [EOL]     } [EOL]     if (this.runningState != STATE_UNSTARTED) { [EOL]         throw new IllegalStateException("Stopwatch already started. "); [EOL]     } [EOL]     this.startTime = System.nanoTime(); [EOL]     this.startTimeMillis = System.currentTimeMillis(); [EOL]     this.runningState = STATE_RUNNING; [EOL] }
public void stop() { [EOL]     if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { [EOL]         throw new IllegalStateException("Stopwatch is not running. "); [EOL]     } [EOL]     if (this.runningState == STATE_RUNNING) { [EOL]         this.stopTime = System.nanoTime(); [EOL]     } [EOL]     this.runningState = STATE_STOPPED; [EOL] }
public long getStartTime() { [EOL]     if (this.runningState == STATE_UNSTARTED) { [EOL]         throw new IllegalStateException("Stopwatch has not been started"); [EOL]     } [EOL]     return this.startTimeMillis; [EOL] }
public void start() { [EOL]     if (this.runningState == STATE_STOPPED) { [EOL]         throw new IllegalStateException("Stopwatch must be reset before being restarted. "); [EOL]     } [EOL]     if (this.runningState != STATE_UNSTARTED) { [EOL]         throw new IllegalStateException("Stopwatch already started. "); [EOL]     } [EOL]     this.startTime = System.nanoTime(); [EOL]     this.startTimeMillis = System.currentTimeMillis(); [EOL]     this.runningState = STATE_RUNNING; [EOL] }
public void stop() { [EOL]     if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { [EOL]         throw new IllegalStateException("Stopwatch is not running. "); [EOL]     } [EOL]     if (this.runningState == STATE_RUNNING) { [EOL]         this.stopTime = System.nanoTime(); [EOL]     } [EOL]     this.runningState = STATE_STOPPED; [EOL] }
public void split() { [EOL]     if (this.runningState != STATE_RUNNING) { [EOL]         throw new IllegalStateException("Stopwatch is not running. "); [EOL]     } [EOL]     this.stopTime = System.nanoTime(); [EOL]     this.splitState = STATE_SPLIT; [EOL] }
public long getSplitTime() { [EOL]     return getSplitNanoTime() / NANO_2_MILLIS; [EOL] }
public void start() { [EOL]     if (this.runningState == STATE_STOPPED) { [EOL]         throw new IllegalStateException("Stopwatch must be reset before being restarted. "); [EOL]     } [EOL]     if (this.runningState != STATE_UNSTARTED) { [EOL]         throw new IllegalStateException("Stopwatch already started. "); [EOL]     } [EOL]     this.startTime = System.nanoTime(); [EOL]     this.startTimeMillis = System.currentTimeMillis(); [EOL]     this.runningState = STATE_RUNNING; [EOL] }
public void stop() { [EOL]     if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { [EOL]         throw new IllegalStateException("Stopwatch is not running. "); [EOL]     } [EOL]     if (this.runningState == STATE_RUNNING) { [EOL]         this.stopTime = System.nanoTime(); [EOL]     } [EOL]     this.runningState = STATE_STOPPED; [EOL] }
public long getNanoTime() { [EOL]     if (this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) { [EOL]         return this.stopTime - this.startTime; [EOL]     } else if (this.runningState == STATE_UNSTARTED) { [EOL]         return 0; [EOL]     } else if (this.runningState == STATE_RUNNING) { [EOL]         return System.nanoTime() - this.startTime; [EOL]     } [EOL]     throw new RuntimeException("Illegal running state has occurred."); [EOL] }
public void start() { [EOL]     if (this.runningState == STATE_STOPPED) { [EOL]         throw new IllegalStateException("Stopwatch must be reset before being restarted. "); [EOL]     } [EOL]     if (this.runningState != STATE_UNSTARTED) { [EOL]         throw new IllegalStateException("Stopwatch already started. "); [EOL]     } [EOL]     this.startTime = System.nanoTime(); [EOL]     this.startTimeMillis = System.currentTimeMillis(); [EOL]     this.runningState = STATE_RUNNING; [EOL] }
public void stop() { [EOL]     if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { [EOL]         throw new IllegalStateException("Stopwatch is not running. "); [EOL]     } [EOL]     if (this.runningState == STATE_RUNNING) { [EOL]         this.stopTime = System.nanoTime(); [EOL]     } [EOL]     this.runningState = STATE_STOPPED; [EOL] }
public long getNanoTime() { [EOL]     if (this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) { [EOL]         return this.stopTime - this.startTime; [EOL]     } else if (this.runningState == STATE_UNSTARTED) { [EOL]         return 0; [EOL]     } else if (this.runningState == STATE_RUNNING) { [EOL]         return System.nanoTime() - this.startTime; [EOL]     } [EOL]     throw new RuntimeException("Illegal running state has occurred."); [EOL] }
public void start() { [EOL]     if (this.runningState == STATE_STOPPED) { [EOL]         throw new IllegalStateException("Stopwatch must be reset before being restarted. "); [EOL]     } [EOL]     if (this.runningState != STATE_UNSTARTED) { [EOL]         throw new IllegalStateException("Stopwatch already started. "); [EOL]     } [EOL]     this.startTime = System.nanoTime(); [EOL]     this.startTimeMillis = System.currentTimeMillis(); [EOL]     this.runningState = STATE_RUNNING; [EOL] }
public void stop() { [EOL]     if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { [EOL]         throw new IllegalStateException("Stopwatch is not running. "); [EOL]     } [EOL]     if (this.runningState == STATE_RUNNING) { [EOL]         this.stopTime = System.nanoTime(); [EOL]     } [EOL]     this.runningState = STATE_STOPPED; [EOL] }
public void suspend() { [EOL]     if (this.runningState != STATE_RUNNING) { [EOL]         throw new IllegalStateException("Stopwatch must be running to suspend. "); [EOL]     } [EOL]     this.stopTime = System.nanoTime(); [EOL]     this.runningState = STATE_SUSPENDED; [EOL] }
public long getNanoTime() { [EOL]     if (this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) { [EOL]         return this.stopTime - this.startTime; [EOL]     } else if (this.runningState == STATE_UNSTARTED) { [EOL]         return 0; [EOL]     } else if (this.runningState == STATE_RUNNING) { [EOL]         return System.nanoTime() - this.startTime; [EOL]     } [EOL]     throw new RuntimeException("Illegal running state has occurred."); [EOL] }
public void stop() { [EOL]     if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { [EOL]         throw new IllegalStateException("Stopwatch is not running. "); [EOL]     } [EOL]     if (this.runningState == STATE_RUNNING) { [EOL]         this.stopTime = System.nanoTime(); [EOL]     } [EOL]     this.runningState = STATE_STOPPED; [EOL] }
public long getNanoTime() { [EOL]     if (this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) { [EOL]         return this.stopTime - this.startTime; [EOL]     } else if (this.runningState == STATE_UNSTARTED) { [EOL]         return 0; [EOL]     } else if (this.runningState == STATE_RUNNING) { [EOL]         return System.nanoTime() - this.startTime; [EOL]     } [EOL]     throw new RuntimeException("Illegal running state has occurred."); [EOL] }
public void start() { [EOL]     if (this.runningState == STATE_STOPPED) { [EOL]         throw new IllegalStateException("Stopwatch must be reset before being restarted. "); [EOL]     } [EOL]     if (this.runningState != STATE_UNSTARTED) { [EOL]         throw new IllegalStateException("Stopwatch already started. "); [EOL]     } [EOL]     this.startTime = System.nanoTime(); [EOL]     this.startTimeMillis = System.currentTimeMillis(); [EOL]     this.runningState = STATE_RUNNING; [EOL] }
public void stop() { [EOL]     if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { [EOL]         throw new IllegalStateException("Stopwatch is not running. "); [EOL]     } [EOL]     if (this.runningState == STATE_RUNNING) { [EOL]         this.stopTime = System.nanoTime(); [EOL]     } [EOL]     this.runningState = STATE_STOPPED; [EOL] }
public long getStartTime() { [EOL]     if (this.runningState == STATE_UNSTARTED) { [EOL]         throw new IllegalStateException("Stopwatch has not been started"); [EOL]     } [EOL]     return this.startTimeMillis; [EOL] }
public void start() { [EOL]     if (this.runningState == STATE_STOPPED) { [EOL]         throw new IllegalStateException("Stopwatch must be reset before being restarted. "); [EOL]     } [EOL]     if (this.runningState != STATE_UNSTARTED) { [EOL]         throw new IllegalStateException("Stopwatch already started. "); [EOL]     } [EOL]     this.startTime = System.nanoTime(); [EOL]     this.startTimeMillis = System.currentTimeMillis(); [EOL]     this.runningState = STATE_RUNNING; [EOL] }
public void stop() { [EOL]     if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { [EOL]         throw new IllegalStateException("Stopwatch is not running. "); [EOL]     } [EOL]     if (this.runningState == STATE_RUNNING) { [EOL]         this.stopTime = System.nanoTime(); [EOL]     } [EOL]     this.runningState = STATE_STOPPED; [EOL] }
public void split() { [EOL]     if (this.runningState != STATE_RUNNING) { [EOL]         throw new IllegalStateException("Stopwatch is not running. "); [EOL]     } [EOL]     this.stopTime = System.nanoTime(); [EOL]     this.splitState = STATE_SPLIT; [EOL] }
public long getSplitNanoTime() { [EOL]     if (this.splitState != STATE_SPLIT) { [EOL]         throw new IllegalStateException("Stopwatch must be split to get the split time. "); [EOL]     } [EOL]     return this.stopTime - this.startTime; [EOL] }
public void start() { [EOL]     if (this.runningState == STATE_STOPPED) { [EOL]         throw new IllegalStateException("Stopwatch must be reset before being restarted. "); [EOL]     } [EOL]     if (this.runningState != STATE_UNSTARTED) { [EOL]         throw new IllegalStateException("Stopwatch already started. "); [EOL]     } [EOL]     this.startTime = System.nanoTime(); [EOL]     this.startTimeMillis = System.currentTimeMillis(); [EOL]     this.runningState = STATE_RUNNING; [EOL] }
public void stop() { [EOL]     if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { [EOL]         throw new IllegalStateException("Stopwatch is not running. "); [EOL]     } [EOL]     if (this.runningState == STATE_RUNNING) { [EOL]         this.stopTime = System.nanoTime(); [EOL]     } [EOL]     this.runningState = STATE_STOPPED; [EOL] }
public long getTime() { [EOL]     return getNanoTime() / NANO_2_MILLIS; [EOL] }
public void start() { [EOL]     if (this.runningState == STATE_STOPPED) { [EOL]         throw new IllegalStateException("Stopwatch must be reset before being restarted. "); [EOL]     } [EOL]     if (this.runningState != STATE_UNSTARTED) { [EOL]         throw new IllegalStateException("Stopwatch already started. "); [EOL]     } [EOL]     this.startTime = System.nanoTime(); [EOL]     this.startTimeMillis = System.currentTimeMillis(); [EOL]     this.runningState = STATE_RUNNING; [EOL] }
public void stop() { [EOL]     if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { [EOL]         throw new IllegalStateException("Stopwatch is not running. "); [EOL]     } [EOL]     if (this.runningState == STATE_RUNNING) { [EOL]         this.stopTime = System.nanoTime(); [EOL]     } [EOL]     this.runningState = STATE_STOPPED; [EOL] }
public long getNanoTime() { [EOL]     if (this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) { [EOL]         return this.stopTime - this.startTime; [EOL]     } else if (this.runningState == STATE_UNSTARTED) { [EOL]         return 0; [EOL]     } else if (this.runningState == STATE_RUNNING) { [EOL]         return System.nanoTime() - this.startTime; [EOL]     } [EOL]     throw new RuntimeException("Illegal running state has occurred."); [EOL] }
methods/lang3/time/DateUtils.java
public static boolean isSameDay(final Calendar cal1, final Calendar cal2) { [EOL]     if (cal1 == null || cal2 == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR)); [EOL] }
public static Date ceiling(final Object date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date instanceof Date) { [EOL]         return ceiling((Date) date, field); [EOL]     } else if (date instanceof Calendar) { [EOL]         return ceiling((Calendar) date, field).getTime(); [EOL]     } else { [EOL]         throw new ClassCastException("Could not find ceiling of for type: " + date.getClass()); [EOL]     } [EOL] }
public static boolean isSameDay(final Calendar cal1, final Calendar cal2) { [EOL]     if (cal1 == null || cal2 == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR)); [EOL] }
public static Date truncate(final Object date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date instanceof Date) { [EOL]         return truncate((Date) date, field); [EOL]     } else if (date instanceof Calendar) { [EOL]         return truncate((Calendar) date, field).getTime(); [EOL]     } else { [EOL]         throw new ClassCastException("Could not truncate " + date); [EOL]     } [EOL] }
public static int truncatedCompareTo(final Date date1, final Date date2, final int field) { [EOL]     final Date truncatedDate1 = truncate(date1, field); [EOL]     final Date truncatedDate2 = truncate(date2, field); [EOL]     return truncatedDate1.compareTo(truncatedDate2); [EOL] }
public static Date truncate(final Object date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date instanceof Date) { [EOL]         return truncate((Date) date, field); [EOL]     } else if (date instanceof Calendar) { [EOL]         return truncate((Calendar) date, field).getTime(); [EOL]     } else { [EOL]         throw new ClassCastException("Could not truncate " + date); [EOL]     } [EOL] }
public static int truncatedCompareTo(final Date date1, final Date date2, final int field) { [EOL]     final Date truncatedDate1 = truncate(date1, field); [EOL]     final Date truncatedDate2 = truncate(date2, field); [EOL]     return truncatedDate1.compareTo(truncatedDate2); [EOL] }
private static Date set(final Date date, final int calendarField, final int amount) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setLenient(false); [EOL]     c.setTime(date); [EOL]     c.set(calendarField, amount); [EOL]     return c.getTime(); [EOL] }
private static Date set(final Date date, final int calendarField, final int amount) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setLenient(false); [EOL]     c.setTime(date); [EOL]     c.set(calendarField, amount); [EOL]     return c.getTime(); [EOL] }
private static Date set(final Date date, final int calendarField, final int amount) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setLenient(false); [EOL]     c.setTime(date); [EOL]     c.set(calendarField, amount); [EOL]     return c.getTime(); [EOL] }
public static long getFragmentInHours(final Calendar calendar, final int fragment) { [EOL]     return getFragment(calendar, fragment, Calendar.HOUR_OF_DAY); [EOL] }
private static long getFragment(final Calendar calendar, final int fragment, final int unit) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final long millisPerUnit = getMillisPerUnit(unit); [EOL]     long result = 0; [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]             result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MONTH: [EOL]             result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]     } [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]         case Calendar.MONTH: [EOL]         case Calendar.DAY_OF_YEAR: [EOL]         case Calendar.DATE: [EOL]             result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit; [EOL]         case Calendar.HOUR_OF_DAY: [EOL]             result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit; [EOL]         case Calendar.MINUTE: [EOL]             result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit; [EOL]         case Calendar.SECOND: [EOL]             result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MILLISECOND: [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The fragment " + fragment + " is not supported"); [EOL]     } [EOL]     return result; [EOL] }
public static Calendar toCalendar(final Date date) { [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setTime(date); [EOL]     return c; [EOL] }
public static long getFragmentInHours(final Calendar calendar, final int fragment) { [EOL]     return getFragment(calendar, fragment, Calendar.HOUR_OF_DAY); [EOL] }
private static long getFragment(final Calendar calendar, final int fragment, final int unit) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final long millisPerUnit = getMillisPerUnit(unit); [EOL]     long result = 0; [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]             result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MONTH: [EOL]             result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]     } [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]         case Calendar.MONTH: [EOL]         case Calendar.DAY_OF_YEAR: [EOL]         case Calendar.DATE: [EOL]             result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit; [EOL]         case Calendar.HOUR_OF_DAY: [EOL]             result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit; [EOL]         case Calendar.MINUTE: [EOL]             result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit; [EOL]         case Calendar.SECOND: [EOL]             result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MILLISECOND: [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The fragment " + fragment + " is not supported"); [EOL]     } [EOL]     return result; [EOL] }
public static long getFragmentInHours(final Calendar calendar, final int fragment) { [EOL]     return getFragment(calendar, fragment, Calendar.HOUR_OF_DAY); [EOL] }
private static long getFragment(final Calendar calendar, final int fragment, final int unit) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final long millisPerUnit = getMillisPerUnit(unit); [EOL]     long result = 0; [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]             result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MONTH: [EOL]             result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]     } [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]         case Calendar.MONTH: [EOL]         case Calendar.DAY_OF_YEAR: [EOL]         case Calendar.DATE: [EOL]             result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit; [EOL]         case Calendar.HOUR_OF_DAY: [EOL]             result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit; [EOL]         case Calendar.MINUTE: [EOL]             result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit; [EOL]         case Calendar.SECOND: [EOL]             result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MILLISECOND: [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The fragment " + fragment + " is not supported"); [EOL]     } [EOL]     return result; [EOL] }
private static Date set(final Date date, final int calendarField, final int amount) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setLenient(false); [EOL]     c.setTime(date); [EOL]     c.set(calendarField, amount); [EOL]     return c.getTime(); [EOL] }
public static Date ceiling(final Object date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date instanceof Date) { [EOL]         return ceiling((Date) date, field); [EOL]     } else if (date instanceof Calendar) { [EOL]         return ceiling((Calendar) date, field).getTime(); [EOL]     } else { [EOL]         throw new ClassCastException("Could not find ceiling of for type: " + date.getClass()); [EOL]     } [EOL] }
public static Iterator<?> iterator(final Object focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (focus instanceof Date) { [EOL]         return iterator((Date) focus, rangeStyle); [EOL]     } else if (focus instanceof Calendar) { [EOL]         return iterator((Calendar) focus, rangeStyle); [EOL]     } else { [EOL]         throw new ClassCastException("Could not iterate based on " + focus); [EOL]     } [EOL] }
private static Date set(final Date date, final int calendarField, final int amount) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setLenient(false); [EOL]     c.setTime(date); [EOL]     c.set(calendarField, amount); [EOL]     return c.getTime(); [EOL] }
public static Iterator<?> iterator(final Object focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (focus instanceof Date) { [EOL]         return iterator((Date) focus, rangeStyle); [EOL]     } else if (focus instanceof Calendar) { [EOL]         return iterator((Calendar) focus, rangeStyle); [EOL]     } else { [EOL]         throw new ClassCastException("Could not iterate based on " + focus); [EOL]     } [EOL] }
private static Date set(final Date date, final int calendarField, final int amount) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setLenient(false); [EOL]     c.setTime(date); [EOL]     c.set(calendarField, amount); [EOL]     return c.getTime(); [EOL] }
public static Iterator<?> iterator(final Object focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (focus instanceof Date) { [EOL]         return iterator((Date) focus, rangeStyle); [EOL]     } else if (focus instanceof Calendar) { [EOL]         return iterator((Calendar) focus, rangeStyle); [EOL]     } else { [EOL]         throw new ClassCastException("Could not iterate based on " + focus); [EOL]     } [EOL] }
public static Iterator<?> iterator(final Object focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (focus instanceof Date) { [EOL]         return iterator((Date) focus, rangeStyle); [EOL]     } else if (focus instanceof Calendar) { [EOL]         return iterator((Calendar) focus, rangeStyle); [EOL]     } else { [EOL]         throw new ClassCastException("Could not iterate based on " + focus); [EOL]     } [EOL] }
public static Iterator<?> iterator(final Object focus, final int rangeStyle) { [EOL]     if (focus == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (focus instanceof Date) { [EOL]         return iterator((Date) focus, rangeStyle); [EOL]     } else if (focus instanceof Calendar) { [EOL]         return iterator((Calendar) focus, rangeStyle); [EOL]     } else { [EOL]         throw new ClassCastException("Could not iterate based on " + focus); [EOL]     } [EOL] }
public static Date round(final Object date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date instanceof Date) { [EOL]         return round((Date) date, field); [EOL]     } else if (date instanceof Calendar) { [EOL]         return round((Calendar) date, field).getTime(); [EOL]     } else { [EOL]         throw new ClassCastException("Could not round " + date); [EOL]     } [EOL] }
public static Date ceiling(final Object date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date instanceof Date) { [EOL]         return ceiling((Date) date, field); [EOL]     } else if (date instanceof Calendar) { [EOL]         return ceiling((Calendar) date, field).getTime(); [EOL]     } else { [EOL]         throw new ClassCastException("Could not find ceiling of for type: " + date.getClass()); [EOL]     } [EOL] }
public static Date ceiling(final Object date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date instanceof Date) { [EOL]         return ceiling((Date) date, field); [EOL]     } else if (date instanceof Calendar) { [EOL]         return ceiling((Calendar) date, field).getTime(); [EOL]     } else { [EOL]         throw new ClassCastException("Could not find ceiling of for type: " + date.getClass()); [EOL]     } [EOL] }
private static Date set(final Date date, final int calendarField, final int amount) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setLenient(false); [EOL]     c.setTime(date); [EOL]     c.set(calendarField, amount); [EOL]     return c.getTime(); [EOL] }
public static Date truncate(final Object date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date instanceof Date) { [EOL]         return truncate((Date) date, field); [EOL]     } else if (date instanceof Calendar) { [EOL]         return truncate((Calendar) date, field).getTime(); [EOL]     } else { [EOL]         throw new ClassCastException("Could not truncate " + date); [EOL]     } [EOL] }
public static Date ceiling(final Object date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date instanceof Date) { [EOL]         return ceiling((Date) date, field); [EOL]     } else if (date instanceof Calendar) { [EOL]         return ceiling((Calendar) date, field).getTime(); [EOL]     } else { [EOL]         throw new ClassCastException("Could not find ceiling of for type: " + date.getClass()); [EOL]     } [EOL] }
public static Date ceiling(final Object date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date instanceof Date) { [EOL]         return ceiling((Date) date, field); [EOL]     } else if (date instanceof Calendar) { [EOL]         return ceiling((Calendar) date, field).getTime(); [EOL]     } else { [EOL]         throw new ClassCastException("Could not find ceiling of for type: " + date.getClass()); [EOL]     } [EOL] }
public static Date round(final Object date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date instanceof Date) { [EOL]         return round((Date) date, field); [EOL]     } else if (date instanceof Calendar) { [EOL]         return round((Calendar) date, field).getTime(); [EOL]     } else { [EOL]         throw new ClassCastException("Could not round " + date); [EOL]     } [EOL] }
public static Date round(final Object date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date instanceof Date) { [EOL]         return round((Date) date, field); [EOL]     } else if (date instanceof Calendar) { [EOL]         return round((Calendar) date, field).getTime(); [EOL]     } else { [EOL]         throw new ClassCastException("Could not round " + date); [EOL]     } [EOL] }
private static Date set(final Date date, final int calendarField, final int amount) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setLenient(false); [EOL]     c.setTime(date); [EOL]     c.set(calendarField, amount); [EOL]     return c.getTime(); [EOL] }
public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2) { [EOL]     if (cal1 == null || cal2 == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass()); [EOL] }
public static Calendar toCalendar(final Date date) { [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setTime(date); [EOL]     return c; [EOL] }
public static boolean isSameInstant(final Calendar cal1, final Calendar cal2) { [EOL]     if (cal1 == null || cal2 == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     return cal1.getTime().getTime() == cal2.getTime().getTime(); [EOL] }
public static boolean isSameInstant(final Calendar cal1, final Calendar cal2) { [EOL]     if (cal1 == null || cal2 == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     return cal1.getTime().getTime() == cal2.getTime().getTime(); [EOL] }
public static boolean isSameInstant(final Calendar cal1, final Calendar cal2) { [EOL]     if (cal1 == null || cal2 == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     return cal1.getTime().getTime() == cal2.getTime().getTime(); [EOL] }
public static boolean isSameDay(final Calendar cal1, final Calendar cal2) { [EOL]     if (cal1 == null || cal2 == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR)); [EOL] }
public static boolean isSameDay(final Calendar cal1, final Calendar cal2) { [EOL]     if (cal1 == null || cal2 == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR)); [EOL] }
public static Date setYears(final Date date, final int amount) { [EOL]     return set(date, Calendar.YEAR, amount); [EOL] }
private static Date set(final Date date, final int calendarField, final int amount) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setLenient(false); [EOL]     c.setTime(date); [EOL]     c.set(calendarField, amount); [EOL]     return c.getTime(); [EOL] }
public static Date truncate(final Object date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date instanceof Date) { [EOL]         return truncate((Date) date, field); [EOL]     } else if (date instanceof Calendar) { [EOL]         return truncate((Calendar) date, field).getTime(); [EOL]     } else { [EOL]         throw new ClassCastException("Could not truncate " + date); [EOL]     } [EOL] }
public static Date setMilliseconds(final Date date, final int amount) { [EOL]     return set(date, Calendar.MILLISECOND, amount); [EOL] }
private static Date set(final Date date, final int calendarField, final int amount) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setLenient(false); [EOL]     c.setTime(date); [EOL]     c.set(calendarField, amount); [EOL]     return c.getTime(); [EOL] }
public static Date truncate(final Object date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date instanceof Date) { [EOL]         return truncate((Date) date, field); [EOL]     } else if (date instanceof Calendar) { [EOL]         return truncate((Calendar) date, field).getTime(); [EOL]     } else { [EOL]         throw new ClassCastException("Could not truncate " + date); [EOL]     } [EOL] }
public static boolean truncatedEquals(final Date date1, final Date date2, final int field) { [EOL]     return truncatedCompareTo(date1, date2, field) == 0; [EOL] }
public static Date setSeconds(final Date date, final int amount) { [EOL]     return set(date, Calendar.SECOND, amount); [EOL] }
private static Date set(final Date date, final int calendarField, final int amount) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setLenient(false); [EOL]     c.setTime(date); [EOL]     c.set(calendarField, amount); [EOL]     return c.getTime(); [EOL] }
public static Date truncate(final Object date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date instanceof Date) { [EOL]         return truncate((Date) date, field); [EOL]     } else if (date instanceof Calendar) { [EOL]         return truncate((Calendar) date, field).getTime(); [EOL]     } else { [EOL]         throw new ClassCastException("Could not truncate " + date); [EOL]     } [EOL] }
public static boolean truncatedEquals(final Date date1, final Date date2, final int field) { [EOL]     return truncatedCompareTo(date1, date2, field) == 0; [EOL] }
public static Date addSeconds(final Date date, final int amount) { [EOL]     return add(date, Calendar.SECOND, amount); [EOL] }
private static Date add(final Date date, final int calendarField, final int amount) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setTime(date); [EOL]     c.add(calendarField, amount); [EOL]     return c.getTime(); [EOL] }
public static Calendar toCalendar(final Date date) { [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setTime(date); [EOL]     return c; [EOL] }
public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment) { [EOL]     return getFragment(calendar, fragment, Calendar.MILLISECOND); [EOL] }
private static long getFragment(final Calendar calendar, final int fragment, final int unit) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final long millisPerUnit = getMillisPerUnit(unit); [EOL]     long result = 0; [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]             result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MONTH: [EOL]             result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]     } [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]         case Calendar.MONTH: [EOL]         case Calendar.DAY_OF_YEAR: [EOL]         case Calendar.DATE: [EOL]             result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit; [EOL]         case Calendar.HOUR_OF_DAY: [EOL]             result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit; [EOL]         case Calendar.MINUTE: [EOL]             result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit; [EOL]         case Calendar.SECOND: [EOL]             result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MILLISECOND: [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The fragment " + fragment + " is not supported"); [EOL]     } [EOL]     return result; [EOL] }
public static Date addDays(final Date date, final int amount) { [EOL]     return add(date, Calendar.DAY_OF_MONTH, amount); [EOL] }
private static Date add(final Date date, final int calendarField, final int amount) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setTime(date); [EOL]     c.add(calendarField, amount); [EOL]     return c.getTime(); [EOL] }
public static Date truncate(final Object date, final int field) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date instanceof Date) { [EOL]         return truncate((Date) date, field); [EOL]     } else if (date instanceof Calendar) { [EOL]         return truncate((Calendar) date, field).getTime(); [EOL]     } else { [EOL]         throw new ClassCastException("Could not truncate " + date); [EOL]     } [EOL] }
public static Date setDays(final Date date, final int amount) { [EOL]     return set(date, Calendar.DAY_OF_MONTH, amount); [EOL] }
private static Date set(final Date date, final int calendarField, final int amount) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setLenient(false); [EOL]     c.setTime(date); [EOL]     c.set(calendarField, amount); [EOL]     return c.getTime(); [EOL] }
public static Date addYears(final Date date, final int amount) { [EOL]     return add(date, Calendar.YEAR, amount); [EOL] }
private static Date add(final Date date, final int calendarField, final int amount) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setTime(date); [EOL]     c.add(calendarField, amount); [EOL]     return c.getTime(); [EOL] }
public static Date addMonths(final Date date, final int amount) { [EOL]     return add(date, Calendar.MONTH, amount); [EOL] }
private static Date add(final Date date, final int calendarField, final int amount) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setTime(date); [EOL]     c.add(calendarField, amount); [EOL]     return c.getTime(); [EOL] }
public static long getFragmentInDays(final Calendar calendar, final int fragment) { [EOL]     return getFragment(calendar, fragment, Calendar.DAY_OF_YEAR); [EOL] }
private static long getFragment(final Calendar calendar, final int fragment, final int unit) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final long millisPerUnit = getMillisPerUnit(unit); [EOL]     long result = 0; [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]             result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MONTH: [EOL]             result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]     } [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]         case Calendar.MONTH: [EOL]         case Calendar.DAY_OF_YEAR: [EOL]         case Calendar.DATE: [EOL]             result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit; [EOL]         case Calendar.HOUR_OF_DAY: [EOL]             result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit; [EOL]         case Calendar.MINUTE: [EOL]             result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit; [EOL]         case Calendar.SECOND: [EOL]             result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MILLISECOND: [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The fragment " + fragment + " is not supported"); [EOL]     } [EOL]     return result; [EOL] }
public static Date setMinutes(final Date date, final int amount) { [EOL]     return set(date, Calendar.MINUTE, amount); [EOL] }
private static Date set(final Date date, final int calendarField, final int amount) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setLenient(false); [EOL]     c.setTime(date); [EOL]     c.set(calendarField, amount); [EOL]     return c.getTime(); [EOL] }
public static Calendar toCalendar(final Date date) { [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setTime(date); [EOL]     return c; [EOL] }
public static long getFragmentInHours(final Calendar calendar, final int fragment) { [EOL]     return getFragment(calendar, fragment, Calendar.HOUR_OF_DAY); [EOL] }
private static long getFragment(final Calendar calendar, final int fragment, final int unit) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final long millisPerUnit = getMillisPerUnit(unit); [EOL]     long result = 0; [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]             result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MONTH: [EOL]             result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit; [EOL]             break; [EOL]     } [EOL]     switch(fragment) { [EOL]         case Calendar.YEAR: [EOL]         case Calendar.MONTH: [EOL]         case Calendar.DAY_OF_YEAR: [EOL]         case Calendar.DATE: [EOL]             result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit; [EOL]         case Calendar.HOUR_OF_DAY: [EOL]             result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit; [EOL]         case Calendar.MINUTE: [EOL]             result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit; [EOL]         case Calendar.SECOND: [EOL]             result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit; [EOL]             break; [EOL]         case Calendar.MILLISECOND: [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("The fragment " + fragment + " is not supported"); [EOL]     } [EOL]     return result; [EOL] }
public static Date addMinutes(final Date date, final int amount) { [EOL]     return add(date, Calendar.MINUTE, amount); [EOL] }
private static Date add(final Date date, final int calendarField, final int amount) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setTime(date); [EOL]     c.add(calendarField, amount); [EOL]     return c.getTime(); [EOL] }
public static Date setMonths(final Date date, final int amount) { [EOL]     return set(date, Calendar.MONTH, amount); [EOL] }
private static Date set(final Date date, final int calendarField, final int amount) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setLenient(false); [EOL]     c.setTime(date); [EOL]     c.set(calendarField, amount); [EOL]     return c.getTime(); [EOL] }
public static Date addHours(final Date date, final int amount) { [EOL]     return add(date, Calendar.HOUR_OF_DAY, amount); [EOL] }
private static Date add(final Date date, final int calendarField, final int amount) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setTime(date); [EOL]     c.add(calendarField, amount); [EOL]     return c.getTime(); [EOL] }
public static Date setHours(final Date date, final int amount) { [EOL]     return set(date, Calendar.HOUR_OF_DAY, amount); [EOL] }
private static Date set(final Date date, final int calendarField, final int amount) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setLenient(false); [EOL]     c.setTime(date); [EOL]     c.set(calendarField, amount); [EOL]     return c.getTime(); [EOL] }
private static Date set(final Date date, final int calendarField, final int amount) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     final Calendar c = Calendar.getInstance(); [EOL]     c.setLenient(false); [EOL]     c.setTime(date); [EOL]     c.set(calendarField, amount); [EOL]     return c.getTime(); [EOL] }
@Override [EOL] public boolean hasNext() { [EOL]     return spot.before(endFinal); [EOL] }
methods/lang3/time/FormatCache.java
static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) { [EOL]     final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale); [EOL]     String pattern = cDateTimeInstanceCache.get(key); [EOL]     if (pattern == null) { [EOL]         try { [EOL]             DateFormat formatter; [EOL]             if (dateStyle == null) { [EOL]                 formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale); [EOL]             } else if (timeStyle == null) { [EOL]                 formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale); [EOL]             } else { [EOL]                 formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale); [EOL]             } [EOL]             pattern = ((SimpleDateFormat) formatter).toPattern(); [EOL]             final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern); [EOL]             if (previous != null) { [EOL]                 pattern = previous; [EOL]             } [EOL]         } catch (final ClassCastException ex) { [EOL]             throw new IllegalArgumentException("No date time pattern for locale: " + locale); [EOL]         } [EOL]     } [EOL]     return pattern; [EOL] }
methods/lang3/time/FastDateParser.java
methods/lang3/time/FastDatePrinter.java
public int getMaxLengthEstimate() { [EOL]     return mMaxLengthEstimate; [EOL] }
methods/lang3/time/FastDateFormat.java
public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale) { [EOL]     return cache.getTimeInstance(style, timeZone, locale); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof FastDateFormat == false) { [EOL]         return false; [EOL]     } [EOL]     final FastDateFormat other = (FastDateFormat) obj; [EOL]     return printer.equals(other.printer); [EOL] }
public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale) { [EOL]     return cache.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale); [EOL] }
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     return cache.getInstance(pattern, timeZone, locale); [EOL] }
@Override [EOL] public Date parse(final String source, final ParsePosition pos) { [EOL]     return parser.parse(source, pos); [EOL] }
@Override [EOL] public Object parseObject(final String source, final ParsePosition pos) { [EOL]     return parser.parseObject(source, pos); [EOL] }
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     return cache.getInstance(pattern, timeZone, locale); [EOL] }
@Override [EOL] public Date parse(final String source, final ParsePosition pos) { [EOL]     return parser.parse(source, pos); [EOL] }
public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale) { [EOL]     return cache.getDateInstance(style, timeZone, locale); [EOL] }
@Override [EOL] public TimeZone getTimeZone() { [EOL]     return printer.getTimeZone(); [EOL] }
public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale) { [EOL]     return cache.getTimeInstance(style, timeZone, locale); [EOL] }
@Override [EOL] public TimeZone getTimeZone() { [EOL]     return printer.getTimeZone(); [EOL] }
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     return cache.getInstance(pattern, timeZone, locale); [EOL] }
@Override [EOL] public TimeZone getTimeZone() { [EOL]     return printer.getTimeZone(); [EOL] }
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     return cache.getInstance(pattern, timeZone, locale); [EOL] }
@Override [EOL] public Date parse(final String source, final ParsePosition pos) { [EOL]     return parser.parse(source, pos); [EOL] }
@Override [EOL] public String toString() { [EOL]     return "FastDateFormat[" + printer.getPattern() + "," + printer.getLocale() + "," + printer.getTimeZone().getID() + "]"; [EOL] }
public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale) { [EOL]     return cache.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale); [EOL] }
@Override [EOL] public TimeZone getTimeZone() { [EOL]     return printer.getTimeZone(); [EOL] }
public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale) { [EOL]     return cache.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale); [EOL] }
@Override [EOL] public StringBuffer format(final Calendar calendar, final StringBuffer buf) { [EOL]     return printer.format(calendar, buf); [EOL] }
@Override [EOL] public String toString() { [EOL]     return "FastDateFormat[" + printer.getPattern() + "," + printer.getLocale() + "," + printer.getTimeZone().getID() + "]"; [EOL] }
@Override [EOL] public String toString() { [EOL]     return "FastDateFormat[" + printer.getPattern() + "," + printer.getLocale() + "," + printer.getTimeZone().getID() + "]"; [EOL] }
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     return cache.getInstance(pattern, timeZone, locale); [EOL] }
@Override [EOL] public StringBuffer format(final Calendar calendar, final StringBuffer buf) { [EOL]     return printer.format(calendar, buf); [EOL] }
public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale) { [EOL]     return cache.getTimeInstance(style, timeZone, locale); [EOL] }
@Override [EOL] public Date parse(final String source, final ParsePosition pos) { [EOL]     return parser.parse(source, pos); [EOL] }
@Override [EOL] public TimeZone getTimeZone() { [EOL]     return printer.getTimeZone(); [EOL] }
@Override [EOL] public String toString() { [EOL]     return "FastDateFormat[" + printer.getPattern() + "," + printer.getLocale() + "," + printer.getTimeZone().getID() + "]"; [EOL] }
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     return cache.getInstance(pattern, timeZone, locale); [EOL] }
public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale) { [EOL]     return cache.getTimeInstance(style, timeZone, locale); [EOL] }
@Override [EOL] public StringBuffer format(final Calendar calendar, final StringBuffer buf) { [EOL]     return printer.format(calendar, buf); [EOL] }
@Override [EOL] public String toString() { [EOL]     return "FastDateFormat[" + printer.getPattern() + "," + printer.getLocale() + "," + printer.getTimeZone().getID() + "]"; [EOL] }
public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale) { [EOL]     return cache.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale); [EOL] }
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     return cache.getInstance(pattern, timeZone, locale); [EOL] }
@Override [EOL] public StringBuffer format(final Calendar calendar, final StringBuffer buf) { [EOL]     return printer.format(calendar, buf); [EOL] }
@Override [EOL] public String toString() { [EOL]     return "FastDateFormat[" + printer.getPattern() + "," + printer.getLocale() + "," + printer.getTimeZone().getID() + "]"; [EOL] }
public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale) { [EOL]     return cache.getDateInstance(style, timeZone, locale); [EOL] }
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj instanceof FastDateFormat == false) { [EOL]         return false; [EOL]     } [EOL]     final FastDateFormat other = (FastDateFormat) obj; [EOL]     return printer.equals(other.printer); [EOL] }
@Override [EOL] public String toString() { [EOL]     return "FastDateFormat[" + printer.getPattern() + "," + printer.getLocale() + "," + printer.getTimeZone().getID() + "]"; [EOL] }
public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale) { [EOL]     return cache.getTimeInstance(style, timeZone, locale); [EOL] }
public int getMaxLengthEstimate() { [EOL]     return printer.getMaxLengthEstimate(); [EOL] }
public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) { [EOL]     return cache.getInstance(pattern, timeZone, locale); [EOL] }
@Override [EOL] public String toString() { [EOL]     return "FastDateFormat[" + printer.getPattern() + "," + printer.getLocale() + "," + printer.getTimeZone().getID() + "]"; [EOL] }
public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale) { [EOL]     return cache.getDateInstance(style, timeZone, locale); [EOL] }
@Override [EOL] public TimeZone getTimeZone() { [EOL]     return printer.getTimeZone(); [EOL] }
@Override [EOL] public Locale getLocale() { [EOL]     return printer.getLocale(); [EOL] }
public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale) { [EOL]     return cache.getDateInstance(style, timeZone, locale); [EOL] }
@Override [EOL] public String getPattern() { [EOL]     return printer.getPattern(); [EOL] }
@Override [EOL] public TimeZone getTimeZone() { [EOL]     return printer.getTimeZone(); [EOL] }
methods/lang3/time/DurationFormatUtils.java
@Override [EOL] public boolean equals(final Object obj2) { [EOL]     if (obj2 instanceof Token) { [EOL]         final Token tok2 = (Token) obj2; [EOL]         if (this.value.getClass() != tok2.value.getClass()) { [EOL]             return false; [EOL]         } [EOL]         if (this.count != tok2.count) { [EOL]             return false; [EOL]         } [EOL]         if (this.value instanceof StringBuilder) { [EOL]             return this.value.toString().equals(tok2.value.toString()); [EOL]         } else if (this.value instanceof Number) { [EOL]             return this.value.equals(tok2.value); [EOL]         } else { [EOL]             return this.value == tok2.value; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(final Object obj2) { [EOL]     if (obj2 instanceof Token) { [EOL]         final Token tok2 = (Token) obj2; [EOL]         if (this.value.getClass() != tok2.value.getClass()) { [EOL]             return false; [EOL]         } [EOL]         if (this.count != tok2.count) { [EOL]             return false; [EOL]         } [EOL]         if (this.value instanceof StringBuilder) { [EOL]             return this.value.toString().equals(tok2.value.toString()); [EOL]         } else if (this.value instanceof Number) { [EOL]             return this.value.equals(tok2.value); [EOL]         } else { [EOL]             return this.value == tok2.value; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static String formatDurationHMS(final long durationMillis) { [EOL]     return formatDuration(durationMillis, "H:mm:ss.SSS"); [EOL] }
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) { [EOL]     final Token[] tokens = lexx(format); [EOL]     int days = 0; [EOL]     int hours = 0; [EOL]     int minutes = 0; [EOL]     int seconds = 0; [EOL]     int milliseconds = 0; [EOL]     if (Token.containsTokenWithValue(tokens, d)) { [EOL]         days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY); [EOL]         durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, H)) { [EOL]         hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR); [EOL]         durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, m)) { [EOL]         minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE); [EOL]         durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, s)) { [EOL]         seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND); [EOL]         durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, S)) { [EOL]         milliseconds = (int) durationMillis; [EOL]     } [EOL]     return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros); [EOL] }
public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] }
public static String formatPeriodISO(final long startMillis, final long endMillis) { [EOL]     return formatPeriod(startMillis, endMillis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault()); [EOL] }
public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) { [EOL]     final Token[] tokens = lexx(format); [EOL]     final Calendar start = Calendar.getInstance(timezone); [EOL]     start.setTime(new Date(startMillis)); [EOL]     final Calendar end = Calendar.getInstance(timezone); [EOL]     end.setTime(new Date(endMillis)); [EOL]     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND); [EOL]     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND); [EOL]     int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE); [EOL]     int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY); [EOL]     int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH); [EOL]     int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH); [EOL]     int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR); [EOL]     while (milliseconds < 0) { [EOL]         milliseconds += 1000; [EOL]         seconds -= 1; [EOL]     } [EOL]     while (seconds < 0) { [EOL]         seconds += 60; [EOL]         minutes -= 1; [EOL]     } [EOL]     while (minutes < 0) { [EOL]         minutes += 60; [EOL]         hours -= 1; [EOL]     } [EOL]     while (hours < 0) { [EOL]         hours += 24; [EOL]         days -= 1; [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, M)) { [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         while (months < 0) { [EOL]             months += 12; [EOL]             years -= 1; [EOL]         } [EOL]         if (!Token.containsTokenWithValue(tokens, y) && years != 0) { [EOL]             while (years != 0) { [EOL]                 months += 12 * years; [EOL]                 years = 0; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (!Token.containsTokenWithValue(tokens, y)) { [EOL]             int target = end.get(Calendar.YEAR); [EOL]             if (months < 0) { [EOL]                 target -= 1; [EOL]             } [EOL]             while (start.get(Calendar.YEAR) != target) { [EOL]                 days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR); [EOL]                 if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) { [EOL]                     days += 1; [EOL]                 } [EOL]                 start.add(Calendar.YEAR, 1); [EOL]                 days += start.get(Calendar.DAY_OF_YEAR); [EOL]             } [EOL]             years = 0; [EOL]         } [EOL]         while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         months = 0; [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, d)) { [EOL]         hours += 24 * days; [EOL]         days = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, H)) { [EOL]         minutes += 60 * hours; [EOL]         hours = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, m)) { [EOL]         seconds += 60 * minutes; [EOL]         minutes = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, s)) { [EOL]         milliseconds += 1000 * seconds; [EOL]         seconds = 0; [EOL]     } [EOL]     return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros); [EOL] }
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) { [EOL]     final StringBuilder buffer = new StringBuilder(); [EOL]     boolean lastOutputSeconds = false; [EOL]     final int sz = tokens.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final Token token = tokens[i]; [EOL]         final Object value = token.getValue(); [EOL]         final int count = token.getCount(); [EOL]         if (value instanceof StringBuilder) { [EOL]             buffer.append(value.toString()); [EOL]         } else { [EOL]             if (value == y) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == M) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == d) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == H) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == m) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == s) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds)); [EOL]                 lastOutputSeconds = true; [EOL]             } else if (value == S) { [EOL]                 if (lastOutputSeconds) { [EOL]                     milliseconds += 1000; [EOL]                     final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds); [EOL]                     buffer.append(str.substring(1)); [EOL]                 } else { [EOL]                     buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds)); [EOL]                 } [EOL]                 lastOutputSeconds = false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
@Override [EOL] public boolean equals(final Object obj2) { [EOL]     if (obj2 instanceof Token) { [EOL]         final Token tok2 = (Token) obj2; [EOL]         if (this.value.getClass() != tok2.value.getClass()) { [EOL]             return false; [EOL]         } [EOL]         if (this.count != tok2.count) { [EOL]             return false; [EOL]         } [EOL]         if (this.value instanceof StringBuilder) { [EOL]             return this.value.toString().equals(tok2.value.toString()); [EOL]         } else if (this.value instanceof Number) { [EOL]             return this.value.equals(tok2.value); [EOL]         } else { [EOL]             return this.value == tok2.value; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
