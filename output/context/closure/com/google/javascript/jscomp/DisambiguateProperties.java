 Property(String name)
private DisambiguateProperties(AbstractCompiler compiler, TypeSystem<T> typeSystem, Map<String, CheckLevel> propertiesToErrorFor)
public JSTypeSystem(AbstractCompiler compiler)
public ConcreteTypeSystem(TightenTypes tt, CodingConvention convention)
 UnionFind<T> getTypes()
 boolean addType(T type, T top, T relatedType)
 void addTypeToSkip(T type)
 void expandTypesToSkip()
 boolean shouldRename()
 boolean shouldRename(T type)
 boolean invalidate()
 boolean scheduleRenaming(Node node, T type)
 static DisambiguateProperties<JSType> forJSTypeSystem(AbstractCompiler compiler, Map<String, CheckLevel> propertiesToErrorFor)
 static DisambiguateProperties<ConcreteType> forConcreteTypeSystem(AbstractCompiler compiler, TightenTypes tt, Map<String, CheckLevel> propertiesToErrorFor)
public void process(Node externs, Node root)
private void recordInvalidationError(JSType t, JSError error)
private void addInvalidatingType(JSType type, JSError error)
protected Property getProperty(String name)
 T getTypeWithProperty(String field, T type)
public boolean shouldTraverse(NodeTraversal t, Node n, Node parent)
public void enterScope(NodeTraversal t)
public void exitScope(NodeTraversal t)
protected StaticScope<T> getScope()
public void visit(NodeTraversal t, Node n, Node parent)
public void visit(NodeTraversal t, Node n, Node parent)
private void handleGetProp(NodeTraversal t, Node n)
private void handleObjectLit(NodeTraversal t, Node n)
private void printErrorLocations(List<String> errors, JSType t)
private T processProperty(NodeTraversal t, Property prop, T type, T relatedType)
 void renameProperties()
private Map<T, String> buildPropNames(UnionFind<T> types, String name)
 Multimap<String, Collection<T>> getRenamedTypesForTesting()
 StaticScope<T> getRootScope()
 StaticScope<T> getFunctionScope(Node node)
 T getType(StaticScope<T> scope, Node node, String prop)
 boolean isInvalidatingType(T type)
 void addInvalidatingType(JSType type)
 ImmutableSet<T> getTypesToSkipForType(T type)
 boolean isTypeToSkip(T type)
 T restrictByNotNullOrUndefined(T type)
 Iterable<T> getTypeAlternatives(T type)
 T getTypeWithProperty(String field, T type)
 T getInstanceFromPrototype(T type)
 void recordInterfaces(T type, T relatedType, DisambiguateProperties<T>.Property p)
public void addInvalidatingType(JSType type)
public StaticScope<JSType> getRootScope()
public StaticScope<JSType> getFunctionScope(Node node)
public JSType getType(StaticScope<JSType> scope, Node node, String prop)
public boolean isInvalidatingType(JSType type)
public ImmutableSet<JSType> getTypesToSkipForType(JSType type)
private Set<JSType> getTypesToSkipForTypeNonUnion(JSType type)
public boolean isTypeToSkip(JSType type)
public JSType restrictByNotNullOrUndefined(JSType type)
public Iterable<JSType> getTypeAlternatives(JSType type)
public ObjectType getTypeWithProperty(String field, JSType type)
public JSType getInstanceFromPrototype(JSType type)
public void recordInterfaces(JSType type, JSType relatedType, DisambiguateProperties<JSType>.Property p)
public void addInvalidatingType(JSType type)
public StaticScope<ConcreteType> getRootScope()
public StaticScope<ConcreteType> getFunctionScope(Node decl)
public ConcreteType getType(StaticScope<ConcreteType> scope, Node node, String prop)
private ConcreteType maybeAddAutoboxes(ConcreteType cType, Node node, String prop)
private ConcreteType maybeAddAutoboxes(ConcreteType cType, JSType jsType, String prop)
public boolean isInvalidatingType(ConcreteType type)
public ImmutableSet<ConcreteType> getTypesToSkipForType(ConcreteType type)
public boolean isTypeToSkip(ConcreteType type)
public ConcreteType restrictByNotNullOrUndefined(ConcreteType type)
public Iterable<ConcreteType> getTypeAlternatives(ConcreteType type)
public ConcreteType getTypeWithProperty(String field, ConcreteType type)
public ConcreteType getInstanceFromPrototype(ConcreteType type)
public void recordInterfaces(ConcreteType type, ConcreteType relatedType, DisambiguateProperties<ConcreteType>.Property p)
int MAX_INVALDIATION_WARNINGS_PER_PROPERTY=Optional[10]
Logger logger=Optional[Logger.getLogger(DisambiguateProperties.class.getName())]
AbstractCompiler compiler
TypeSystem<T> typeSystem
Multimap<Object, JSError> invalidationMap
Map<String, CheckLevel> propertiesToErrorFor
Map<String, Property> properties=Optional[Maps.newHashMap()]
