public CpioArchiveInputStream(final InputStream in) { [EOL]     this.in = in; [EOL] } <line_num>: 87,89
public int available() throws IOException { [EOL]     ensureOpen(); [EOL]     if (this.entryEOF) { [EOL]         return 0; [EOL]     } [EOL]     return 1; [EOL] } <line_num>: 103,109
public void close() throws IOException { [EOL]     if (!this.closed) { [EOL]         super.close(); [EOL]         this.closed = true; [EOL]     } [EOL] } <line_num>: 117,122
public void closeEntry() throws IOException { [EOL]     ensureOpen(); [EOL]     while (read(this.tmpbuf, 0, this.tmpbuf.length) != -1) { [EOL]     } [EOL]     this.entryEOF = true; [EOL] } <line_num>: 132,139
private void ensureOpen() throws IOException { [EOL]     if (this.closed) { [EOL]         throw new IOException("Stream closed"); [EOL]     } [EOL] } <line_num>: 147,151
public CpioArchiveEntry getNextCPIOEntry() throws IOException { [EOL]     ensureOpen(); [EOL]     if (this.entry != null) { [EOL]         closeEntry(); [EOL]     } [EOL]     byte[] magic = new byte[2]; [EOL]     readFully(magic, 0, magic.length); [EOL]     if (CpioUtil.byteArray2long(magic, false) == MAGIC_OLD_BINARY) { [EOL]         this.entry = readOldBinaryEntry(false); [EOL]     } else if (CpioUtil.byteArray2long(magic, true) == MAGIC_OLD_BINARY) { [EOL]         this.entry = readOldBinaryEntry(true); [EOL]     } else { [EOL]         byte[] more_magic = new byte[4]; [EOL]         readFully(more_magic, 0, more_magic.length); [EOL]         byte[] tmp = new byte[6]; [EOL]         System.arraycopy(magic, 0, tmp, 0, magic.length); [EOL]         System.arraycopy(more_magic, 0, tmp, magic.length, more_magic.length); [EOL]         String magicString = new String(tmp); [EOL]         if (magicString.equals(MAGIC_NEW)) { [EOL]             this.entry = readNewEntry(false); [EOL]         } else if (magicString.equals(MAGIC_NEW_CRC)) { [EOL]             this.entry = readNewEntry(true); [EOL]         } else if (magicString.equals(MAGIC_OLD_ASCII)) { [EOL]             this.entry = readOldAsciiEntry(); [EOL]         } else { [EOL]             throw new IOException("Unknown magic [" + magicString + "]"); [EOL]         } [EOL]     } [EOL]     this.entryBytesRead = 0; [EOL]     this.entryEOF = false; [EOL]     this.crc = 0; [EOL]     if (this.entry.getName().equals("TRAILER!!!")) { [EOL]         this.entryEOF = true; [EOL]         return null; [EOL]     } [EOL]     return this.entry; [EOL] } <line_num>: 162,201
private long pad(final long count, final int border) throws IOException { [EOL]     long skip = count % border; [EOL]     if (skip > 0) { [EOL]         skip = this.in.skip(border - skip); [EOL]     } [EOL]     return skip; [EOL] } <line_num>: 203,209
public int read() throws IOException { [EOL]     return read(this.singleByteBuf, 0, 1) == -1 ? -1 : this.singleByteBuf[0] & 0xff; [EOL] } <line_num>: 220,223
public int read(final byte[] b, final int off, final int len) throws IOException { [EOL]     ensureOpen(); [EOL]     if (off < 0 || len < 0 || off > b.length - len) { [EOL]         throw new IndexOutOfBoundsException(); [EOL]     } else if (len == 0) { [EOL]         return 0; [EOL]     } [EOL]     if (this.entry == null || this.entryEOF) { [EOL]         return -1; [EOL]     } [EOL]     if (this.entryBytesRead == this.entry.getSize()) { [EOL]         if ((this.entry.getFormat() | FORMAT_NEW_MASK) == FORMAT_NEW_MASK) { [EOL]             pad(this.entry.getSize(), 4); [EOL]         } else if ((this.entry.getFormat() | FORMAT_OLD_BINARY) == FORMAT_OLD_BINARY) { [EOL]             pad(this.entry.getSize(), 2); [EOL]         } [EOL]         this.entryEOF = true; [EOL]         if ((this.entry.getFormat() | FORMAT_NEW_CRC) == FORMAT_NEW_CRC) { [EOL]             if (this.crc != this.entry.getChksum()) { [EOL]                 throw new IOException("CRC Error"); [EOL]             } [EOL]         } [EOL]         return -1; [EOL]     } [EOL]     int tmplength = (int) Math.min(len, this.entry.getSize() - this.entryBytesRead); [EOL]     if (tmplength < 0) { [EOL]         return -1; [EOL]     } [EOL]     int tmpread = this.in.read(b, off, tmplength); [EOL]     if ((this.entry.getFormat() | FORMAT_NEW_CRC) == FORMAT_NEW_CRC) { [EOL]         for (int pos = 0; pos < tmpread; pos++) { [EOL]             this.crc += b[pos] & 0xFF; [EOL]         } [EOL]     } [EOL]     this.entryBytesRead += tmpread; [EOL]     return tmpread; [EOL] } <line_num>: 241,282
private final int readFully(final byte[] b, final int off, final int len) throws IOException { [EOL]     if (len < 0) { [EOL]         throw new IndexOutOfBoundsException(); [EOL]     } [EOL]     int n = 0; [EOL]     while (n < len) { [EOL]         int count = this.in.read(b, off + n, len - n); [EOL]         if (count < 0) { [EOL]             throw new EOFException(); [EOL]         } [EOL]         n += count; [EOL]     } [EOL]     return n; [EOL] } <line_num>: 284,298
private long readBinaryLong(final int length, final boolean swapHalfWord) throws IOException { [EOL]     byte[] tmp = new byte[length]; [EOL]     readFully(tmp, 0, tmp.length); [EOL]     return CpioUtil.byteArray2long(tmp, swapHalfWord); [EOL] } <line_num>: 300,305
private long readAsciiLong(final int length, final int radix) throws IOException { [EOL]     byte[] tmpBuffer = new byte[length]; [EOL]     readFully(tmpBuffer, 0, tmpBuffer.length); [EOL]     return Long.parseLong(new String(tmpBuffer), radix); [EOL] } <line_num>: 307,312
private CpioArchiveEntry readNewEntry(final boolean hasCrc) throws IOException { [EOL]     CpioArchiveEntry ret; [EOL]     if (hasCrc) { [EOL]         ret = new CpioArchiveEntry(FORMAT_NEW_CRC); [EOL]     } else { [EOL]         ret = new CpioArchiveEntry(FORMAT_NEW); [EOL]     } [EOL]     ret.setInode(readAsciiLong(8, 16)); [EOL]     ret.setMode(readAsciiLong(8, 16)); [EOL]     ret.setUID(readAsciiLong(8, 16)); [EOL]     ret.setGID(readAsciiLong(8, 16)); [EOL]     ret.setNumberOfLinks(readAsciiLong(8, 16)); [EOL]     ret.setTime(readAsciiLong(8, 16)); [EOL]     ret.setSize(readAsciiLong(8, 16)); [EOL]     ret.setDeviceMaj(readAsciiLong(8, 16)); [EOL]     ret.setDeviceMin(readAsciiLong(8, 16)); [EOL]     ret.setRemoteDeviceMaj(readAsciiLong(8, 16)); [EOL]     ret.setRemoteDeviceMin(readAsciiLong(8, 16)); [EOL]     long namesize = readAsciiLong(8, 16); [EOL]     ret.setChksum(readAsciiLong(8, 16)); [EOL]     ret.setName(readCString((int) namesize)); [EOL]     pad(ret.getHeaderSize() + namesize, 4); [EOL]     return ret; [EOL] } <line_num>: 314,340
private CpioArchiveEntry readOldAsciiEntry() throws IOException { [EOL]     CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_ASCII); [EOL]     ret.setDevice(readAsciiLong(6, 8)); [EOL]     ret.setInode(readAsciiLong(6, 8)); [EOL]     ret.setMode(readAsciiLong(6, 8)); [EOL]     ret.setUID(readAsciiLong(6, 8)); [EOL]     ret.setGID(readAsciiLong(6, 8)); [EOL]     ret.setNumberOfLinks(readAsciiLong(6, 8)); [EOL]     ret.setRemoteDevice(readAsciiLong(6, 8)); [EOL]     ret.setTime(readAsciiLong(11, 8)); [EOL]     long namesize = readAsciiLong(6, 8); [EOL]     ret.setSize(readAsciiLong(11, 8)); [EOL]     ret.setName(readCString((int) namesize)); [EOL]     return ret; [EOL] } <line_num>: 342,358
private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord) throws IOException { [EOL]     CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_BINARY); [EOL]     ret.setDevice(readBinaryLong(2, swapHalfWord)); [EOL]     ret.setInode(readBinaryLong(2, swapHalfWord)); [EOL]     ret.setMode(readBinaryLong(2, swapHalfWord)); [EOL]     ret.setUID(readBinaryLong(2, swapHalfWord)); [EOL]     ret.setGID(readBinaryLong(2, swapHalfWord)); [EOL]     ret.setNumberOfLinks(readBinaryLong(2, swapHalfWord)); [EOL]     ret.setRemoteDevice(readBinaryLong(2, swapHalfWord)); [EOL]     ret.setTime(readBinaryLong(4, swapHalfWord)); [EOL]     long namesize = readBinaryLong(2, swapHalfWord); [EOL]     ret.setSize(readBinaryLong(4, swapHalfWord)); [EOL]     ret.setName(readCString((int) namesize)); [EOL]     pad(ret.getHeaderSize() + namesize, 2); [EOL]     return ret; [EOL] } <line_num>: 360,378
private String readCString(final int length) throws IOException { [EOL]     byte[] tmpBuffer = new byte[length]; [EOL]     readFully(tmpBuffer, 0, tmpBuffer.length); [EOL]     return new String(tmpBuffer, 0, tmpBuffer.length - 1); [EOL] } <line_num>: 380,384
public long skip(final long n) throws IOException { [EOL]     if (n < 0) { [EOL]         throw new IllegalArgumentException("negative skip length"); [EOL]     } [EOL]     ensureOpen(); [EOL]     int max = (int) Math.min(n, Integer.MAX_VALUE); [EOL]     int total = 0; [EOL]     while (total < max) { [EOL]         int len = max - total; [EOL]         if (len > this.tmpbuf.length) { [EOL]             len = this.tmpbuf.length; [EOL]         } [EOL]         len = read(this.tmpbuf, 0, len); [EOL]         if (len == -1) { [EOL]             this.entryEOF = true; [EOL]             break; [EOL]         } [EOL]         total += len; [EOL]     } [EOL]     return total; [EOL] } <line_num>: 397,418
public ArchiveEntry getNextEntry() throws IOException { [EOL]     return getNextCPIOEntry(); [EOL] } <line_num>: 420,422
public static boolean matches(byte[] signature, int length) { [EOL]     if (length < 5) { [EOL]         return false; [EOL]     } [EOL]     if (signature[0] != 0x30) { [EOL]         return false; [EOL]     } [EOL]     if (signature[1] != 0x37) { [EOL]         return false; [EOL]     } [EOL]     if (signature[2] != 0x30) { [EOL]         return false; [EOL]     } [EOL]     if (signature[3] != 0x37) { [EOL]         return false; [EOL]     } [EOL]     if (signature[4] != 0x30) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } <line_num>: 424,447
