public ZipFile(File f) throws IOException { [EOL]     this(f, ZipEncodingHelper.UTF8); [EOL] } <line_num>: 119,121
public ZipFile(String name) throws IOException { [EOL]     this(new File(name), ZipEncodingHelper.UTF8); [EOL] } <line_num>: 130,132
public ZipFile(String name, String encoding) throws IOException { [EOL]     this(new File(name), encoding, true); [EOL] } <line_num>: 144,146
public ZipFile(File f, String encoding) throws IOException { [EOL]     this(f, encoding, true); [EOL] } <line_num>: 158,160
public ZipFile(File f, String encoding, boolean useUnicodeExtraFields) throws IOException { [EOL]     this.encoding = encoding; [EOL]     this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding); [EOL]     this.useUnicodeExtraFields = useUnicodeExtraFields; [EOL]     archive = new RandomAccessFile(f, "r"); [EOL]     boolean success = false; [EOL]     try { [EOL]         Map entriesWithoutEFS = populateFromCentralDirectory(); [EOL]         resolveLocalFileHeaderData(entriesWithoutEFS); [EOL]         success = true; [EOL]     } finally { [EOL]         if (!success) { [EOL]             try { [EOL]                 archive.close(); [EOL]             } catch (IOException e2) { [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 174,194
BoundedInputStream(long start, long remaining) { [EOL]     this.remaining = remaining; [EOL]     loc = start; [EOL] } <line_num>: 623,626
private NameAndComment(byte[] name, byte[] comment) { [EOL]     this.name = name; [EOL]     this.comment = comment; [EOL] } <line_num>: 683,686
public String getEncoding() { [EOL]     return encoding; [EOL] } <line_num>: 201,203
public void close() throws IOException { [EOL]     archive.close(); [EOL] } <line_num>: 209,211
public static void closeQuietly(ZipFile zipfile) { [EOL]     if (zipfile != null) { [EOL]         try { [EOL]             zipfile.close(); [EOL]         } catch (IOException e) { [EOL]         } [EOL]     } [EOL] } <line_num>: 218,226
public Enumeration getEntries() { [EOL]     return Collections.enumeration(entries.keySet()); [EOL] } <line_num>: 232,234
public ZipArchiveEntry getEntry(String name) { [EOL]     return (ZipArchiveEntry) nameMap.get(name); [EOL] } <line_num>: 243,245
public InputStream getInputStream(ZipArchiveEntry ze) throws IOException, ZipException { [EOL]     OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze); [EOL]     if (offsetEntry == null) { [EOL]         return null; [EOL]     } [EOL]     long start = offsetEntry.dataOffset; [EOL]     BoundedInputStream bis = new BoundedInputStream(start, ze.getCompressedSize()); [EOL]     switch(ze.getMethod()) { [EOL]         case ZipArchiveEntry.STORED: [EOL]             return bis; [EOL]         case ZipArchiveEntry.DEFLATED: [EOL]             bis.addDummy(); [EOL]             return new InflaterInputStream(bis, new Inflater(true)); [EOL]         default: [EOL]             throw new ZipException("Found unsupported compression method " + ze.getMethod()); [EOL]     } [EOL] } <line_num>: 255,274
private Map populateFromCentralDirectory() throws IOException { [EOL]     HashMap noEFS = new HashMap(); [EOL]     positionAtCentralDirectory(); [EOL]     byte[] cfh = new byte[CFH_LEN]; [EOL]     byte[] signatureBytes = new byte[WORD]; [EOL]     archive.readFully(signatureBytes); [EOL]     long sig = ZipLong.getValue(signatureBytes); [EOL]     final long cfhSig = ZipLong.getValue(ZipArchiveOutputStream.CFH_SIG); [EOL]     if (sig != cfhSig && startsWithLocalFileHeader()) { [EOL]         throw new IOException("central directory is empty, can't expand" + " corrupt archive."); [EOL]     } [EOL]     while (sig == cfhSig) { [EOL]         archive.readFully(cfh); [EOL]         int off = 0; [EOL]         ZipArchiveEntry ze = new ZipArchiveEntry(); [EOL]         int versionMadeBy = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); [EOL]         off += SHORT; [EOL]         final int generalPurposeFlag = ZipShort.getValue(cfh, off); [EOL]         final boolean hasEFS = (generalPurposeFlag & ZipArchiveOutputStream.EFS_FLAG) != 0; [EOL]         final ZipEncoding entryEncoding = hasEFS ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; [EOL]         off += SHORT; [EOL]         ze.setMethod(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); [EOL]         ze.setTime(time); [EOL]         off += WORD; [EOL]         ze.setCrc(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setCompressedSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         ze.setSize(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         int fileNameLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int extraLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         int commentLen = ZipShort.getValue(cfh, off); [EOL]         off += SHORT; [EOL]         off += SHORT; [EOL]         ze.setInternalAttributes(ZipShort.getValue(cfh, off)); [EOL]         off += SHORT; [EOL]         ze.setExternalAttributes(ZipLong.getValue(cfh, off)); [EOL]         off += WORD; [EOL]         byte[] fileName = new byte[fileNameLen]; [EOL]         archive.readFully(fileName); [EOL]         ze.setName(entryEncoding.decode(fileName)); [EOL]         OffsetEntry offset = new OffsetEntry(); [EOL]         offset.headerOffset = ZipLong.getValue(cfh, off); [EOL]         entries.put(ze, offset); [EOL]         nameMap.put(ze.getName(), ze); [EOL]         byte[] cdExtraData = new byte[extraLen]; [EOL]         archive.readFully(cdExtraData); [EOL]         ze.setCentralDirectoryExtra(cdExtraData); [EOL]         byte[] comment = new byte[commentLen]; [EOL]         archive.readFully(comment); [EOL]         ze.setComment(entryEncoding.decode(comment)); [EOL]         archive.readFully(signatureBytes); [EOL]         sig = ZipLong.getValue(signatureBytes); [EOL]         if (!hasEFS && useUnicodeExtraFields) { [EOL]             noEFS.put(ze, new NameAndComment(fileName, comment)); [EOL]         } [EOL]     } [EOL]     return noEFS; [EOL] } <line_num>: 306,405
private void positionAtCentralDirectory() throws IOException { [EOL]     boolean found = false; [EOL]     long off = archive.length() - MIN_EOCD_SIZE; [EOL]     long stopSearching = Math.max(0L, archive.length() - MAX_EOCD_SIZE); [EOL]     if (off >= 0) { [EOL]         archive.seek(off); [EOL]         byte[] sig = ZipArchiveOutputStream.EOCD_SIG; [EOL]         int curr = archive.read(); [EOL]         while (off >= stopSearching && curr != -1) { [EOL]             if (curr == sig[POS_0]) { [EOL]                 curr = archive.read(); [EOL]                 if (curr == sig[POS_1]) { [EOL]                     curr = archive.read(); [EOL]                     if (curr == sig[POS_2]) { [EOL]                         curr = archive.read(); [EOL]                         if (curr == sig[POS_3]) { [EOL]                             found = true; [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]             archive.seek(--off); [EOL]             curr = archive.read(); [EOL]         } [EOL]     } [EOL]     if (!found) { [EOL]         throw new ZipException("archive is not a ZIP archive"); [EOL]     } [EOL]     archive.seek(off + CFD_LOCATOR_OFFSET); [EOL]     byte[] cfdOffset = new byte[WORD]; [EOL]     archive.readFully(cfdOffset); [EOL]     archive.seek(ZipLong.getValue(cfdOffset)); [EOL] } <line_num>: 441,475
private void resolveLocalFileHeaderData(Map entriesWithoutEFS) throws IOException { [EOL]     Enumeration e = getEntries(); [EOL]     while (e.hasMoreElements()) { [EOL]         ZipArchiveEntry ze = (ZipArchiveEntry) e.nextElement(); [EOL]         OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze); [EOL]         long offset = offsetEntry.headerOffset; [EOL]         archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH); [EOL]         byte[] b = new byte[SHORT]; [EOL]         archive.readFully(b); [EOL]         int fileNameLen = ZipShort.getValue(b); [EOL]         archive.readFully(b); [EOL]         int extraFieldLen = ZipShort.getValue(b); [EOL]         int lenToSkip = fileNameLen; [EOL]         while (lenToSkip > 0) { [EOL]             int skipped = archive.skipBytes(lenToSkip); [EOL]             if (skipped <= 0) { [EOL]                 throw new RuntimeException("failed to skip file name in" + " local file header"); [EOL]             } [EOL]             lenToSkip -= skipped; [EOL]         } [EOL]         byte[] localExtraData = new byte[extraFieldLen]; [EOL]         archive.readFully(localExtraData); [EOL]         ze.setExtra(localExtraData); [EOL]         offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT + fileNameLen + extraFieldLen; [EOL]         if (entriesWithoutEFS.containsKey(ze)) { [EOL]             setNameAndCommentFromExtraFields(ze, (NameAndComment) entriesWithoutEFS.get(ze)); [EOL]         } [EOL]     } [EOL] } <line_num>: 499,537
private boolean startsWithLocalFileHeader() throws IOException { [EOL]     archive.seek(0); [EOL]     final byte[] start = new byte[WORD]; [EOL]     archive.readFully(start); [EOL]     for (int i = 0; i < start.length; i++) { [EOL]         if (start[i] != ZipArchiveOutputStream.LFH_SIG[i]) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 543,553
private void setNameAndCommentFromExtraFields(ZipArchiveEntry ze, NameAndComment nc) { [EOL]     UnicodePathExtraField name = (UnicodePathExtraField) ze.getExtraField(UnicodePathExtraField.UPATH_ID); [EOL]     String originalName = ze.getName(); [EOL]     String newName = getUnicodeStringIfOriginalMatches(name, nc.name); [EOL]     if (newName != null && !originalName.equals(newName)) { [EOL]         ze.setName(newName); [EOL]         nameMap.remove(originalName); [EOL]         nameMap.put(newName, ze); [EOL]     } [EOL]     if (nc.comment != null && nc.comment.length > 0) { [EOL]         UnicodeCommentExtraField cmt = (UnicodeCommentExtraField) ze.getExtraField(UnicodeCommentExtraField.UCOM_ID); [EOL]         String newComment = getUnicodeStringIfOriginalMatches(cmt, nc.comment); [EOL]         if (newComment != null) { [EOL]             ze.setComment(newComment); [EOL]         } [EOL]     } [EOL] } <line_num>: 560,581
private String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f, byte[] orig) { [EOL]     if (f != null) { [EOL]         CRC32 crc32 = new CRC32(); [EOL]         crc32.update(orig); [EOL]         long origCRC32 = crc32.getValue(); [EOL]         if (origCRC32 == f.getNameCRC32()) { [EOL]             try { [EOL]                 return ZipEncodingHelper.UTF8_ZIP_ENCODING.decode(f.getUnicodeName()); [EOL]             } catch (IOException ex) { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 590,611
public int read() throws IOException { [EOL]     if (remaining-- <= 0) { [EOL]         if (addDummyByte) { [EOL]             addDummyByte = false; [EOL]             return 0; [EOL]         } [EOL]         return -1; [EOL]     } [EOL]     synchronized (archive) { [EOL]         archive.seek(loc++); [EOL]         return archive.read(); [EOL]     } [EOL] } <line_num>: 628,640
public int read(byte[] b, int off, int len) throws IOException { [EOL]     if (remaining <= 0) { [EOL]         if (addDummyByte) { [EOL]             addDummyByte = false; [EOL]             b[off] = 0; [EOL]             return 1; [EOL]         } [EOL]         return -1; [EOL]     } [EOL]     if (len <= 0) { [EOL]         return 0; [EOL]     } [EOL]     if (len > remaining) { [EOL]         len = (int) remaining; [EOL]     } [EOL]     int ret = -1; [EOL]     synchronized (archive) { [EOL]         archive.seek(loc); [EOL]         ret = archive.read(b, off, len); [EOL]     } [EOL]     if (ret > 0) { [EOL]         loc += ret; [EOL]         remaining -= ret; [EOL]     } [EOL]     return ret; [EOL] } <line_num>: 642,669
void addDummy() { [EOL]     addDummyByte = true; [EOL] } <line_num>: 675,677
