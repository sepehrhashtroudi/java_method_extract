public TarArchiveInputStream(InputStream is) { [EOL]     this(is, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE); [EOL] } <line_num>: 64,66
public TarArchiveInputStream(InputStream is, int blockSize) { [EOL]     this(is, blockSize, TarBuffer.DEFAULT_RCDSIZE); [EOL] } <line_num>: 73,75
public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) { [EOL]     this.buffer = new TarBuffer(is, blockSize, recordSize); [EOL]     this.readBuf = null; [EOL]     this.oneBuf = new byte[1]; [EOL]     this.debug = false; [EOL]     this.hasHitEOF = false; [EOL] } <line_num>: 83,89
public void setDebug(boolean debug) { [EOL]     this.debug = debug; [EOL]     buffer.setDebug(debug); [EOL] } <line_num>: 96,99
public void close() throws IOException { [EOL]     buffer.close(); [EOL] } <line_num>: 105,107
public int getRecordSize() { [EOL]     return buffer.getRecordSize(); [EOL] } <line_num>: 114,116
public int available() throws IOException { [EOL]     if (entrySize - entryOffset > Integer.MAX_VALUE) { [EOL]         return Integer.MAX_VALUE; [EOL]     } [EOL]     return (int) (entrySize - entryOffset); [EOL] } <line_num>: 130,135
public long skip(long numToSkip) throws IOException { [EOL]     byte[] skipBuf = new byte[BUFFER_SIZE]; [EOL]     long skip = numToSkip; [EOL]     while (skip > 0) { [EOL]         int realSkip = (int) (skip > skipBuf.length ? skipBuf.length : skip); [EOL]         int numRead = read(skipBuf, 0, realSkip); [EOL]         if (numRead == -1) { [EOL]             break; [EOL]         } [EOL]         skip -= numRead; [EOL]     } [EOL]     return (numToSkip - skip); [EOL] } <line_num>: 147,163
public void reset() { [EOL] } <line_num>: 168,169
public TarArchiveEntry getNextTarEntry() throws IOException { [EOL]     if (hasHitEOF) { [EOL]         return null; [EOL]     } [EOL]     if (currEntry != null) { [EOL]         long numToSkip = entrySize - entryOffset; [EOL]         if (debug) { [EOL]             System.err.println("TarInputStream: SKIP currENTRY '" + currEntry.getName() + "' SZ " + entrySize + " OFF " + entryOffset + "  skipping " + numToSkip + " bytes"); [EOL]         } [EOL]         while (numToSkip > 0) { [EOL]             long skipped = skip(numToSkip); [EOL]             if (skipped <= 0) { [EOL]                 throw new RuntimeException("failed to skip current tar" + " entry"); [EOL]             } [EOL]             numToSkip -= skipped; [EOL]         } [EOL]         readBuf = null; [EOL]     } [EOL]     byte[] headerBuf = buffer.readRecord(); [EOL]     if (headerBuf == null) { [EOL]         if (debug) { [EOL]             System.err.println("READ NULL RECORD"); [EOL]         } [EOL]         hasHitEOF = true; [EOL]     } else if (buffer.isEOFRecord(headerBuf)) { [EOL]         if (debug) { [EOL]             System.err.println("READ EOF RECORD"); [EOL]         } [EOL]         hasHitEOF = true; [EOL]     } [EOL]     if (hasHitEOF) { [EOL]         currEntry = null; [EOL]     } else { [EOL]         currEntry = new TarArchiveEntry(headerBuf); [EOL]         if (debug) { [EOL]             System.err.println("TarInputStream: SET CURRENTRY '" + currEntry.getName() + "' size = " + currEntry.getSize()); [EOL]         } [EOL]         entryOffset = 0; [EOL]         entrySize = currEntry.getSize(); [EOL]     } [EOL]     if (currEntry != null && currEntry.isGNULongNameEntry()) { [EOL]         StringBuffer longName = new StringBuffer(); [EOL]         byte[] buf = new byte[SMALL_BUFFER_SIZE]; [EOL]         int length = 0; [EOL]         while ((length = read(buf)) >= 0) { [EOL]             longName.append(new String(buf, 0, length)); [EOL]         } [EOL]         getNextEntry(); [EOL]         if (currEntry == null) { [EOL]             return null; [EOL]         } [EOL]         if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) { [EOL]             longName.deleteCharAt(longName.length() - 1); [EOL]         } [EOL]         currEntry.setName(longName.toString()); [EOL]     } [EOL]     return currEntry; [EOL] } <line_num>: 184,266
public ArchiveEntry getNextEntry() throws IOException { [EOL]     return getNextTarEntry(); [EOL] } <line_num>: 268,270
public int read() throws IOException { [EOL]     int num = read(oneBuf, 0, 1); [EOL]     return num == -1 ? -1 : oneBuf[0] & BYTE_MASK; [EOL] } <line_num>: 280,283
public int read(byte[] buf, int offset, int numToRead) throws IOException { [EOL]     int totalRead = 0; [EOL]     if (entryOffset >= entrySize) { [EOL]         return -1; [EOL]     } [EOL]     if ((numToRead + entryOffset) > entrySize) { [EOL]         numToRead = (int) (entrySize - entryOffset); [EOL]     } [EOL]     if (readBuf != null) { [EOL]         int sz = (numToRead > readBuf.length) ? readBuf.length : numToRead; [EOL]         System.arraycopy(readBuf, 0, buf, offset, sz); [EOL]         if (sz >= readBuf.length) { [EOL]             readBuf = null; [EOL]         } else { [EOL]             int newLen = readBuf.length - sz; [EOL]             byte[] newBuf = new byte[newLen]; [EOL]             System.arraycopy(readBuf, sz, newBuf, 0, newLen); [EOL]             readBuf = newBuf; [EOL]         } [EOL]         totalRead += sz; [EOL]         numToRead -= sz; [EOL]         offset += sz; [EOL]     } [EOL]     while (numToRead > 0) { [EOL]         byte[] rec = buffer.readRecord(); [EOL]         if (rec == null) { [EOL]             throw new IOException("unexpected EOF with " + numToRead + " bytes unread"); [EOL]         } [EOL]         int sz = numToRead; [EOL]         int recLen = rec.length; [EOL]         if (recLen > sz) { [EOL]             System.arraycopy(rec, 0, buf, offset, sz); [EOL]             readBuf = new byte[recLen - sz]; [EOL]             System.arraycopy(rec, sz, readBuf, 0, recLen - sz); [EOL]         } else { [EOL]             sz = recLen; [EOL]             System.arraycopy(rec, 0, buf, offset, recLen); [EOL]         } [EOL]         totalRead += sz; [EOL]         numToRead -= sz; [EOL]         offset += sz; [EOL]     } [EOL]     entryOffset += totalRead; [EOL]     return totalRead; [EOL] } <line_num>: 298,363
public void copyEntryContents(OutputStream out) throws IOException { [EOL]     byte[] buf = new byte[LARGE_BUFFER_SIZE]; [EOL]     while (true) { [EOL]         int numRead = read(buf, 0, buf.length); [EOL]         if (numRead == -1) { [EOL]             break; [EOL]         } [EOL]         out.write(buf, 0, numRead); [EOL]     } [EOL] } <line_num>: 372,384
protected final TarArchiveEntry getCurrentEntry() { [EOL]     return currEntry; [EOL] } <line_num>: 386,388
protected final void setCurrentEntry(TarArchiveEntry e) { [EOL]     currEntry = e; [EOL] } <line_num>: 390,392
protected final boolean isAtEOF() { [EOL]     return hasHitEOF; [EOL] } <line_num>: 394,396
protected final void setAtEOF(boolean b) { [EOL]     hasHitEOF = b; [EOL] } <line_num>: 398,400
public int read(byte[] b) throws IOException { [EOL]     return read(b, 0, b.length); [EOL] } <line_num>: 404,406
public static boolean matches(byte[] signature, int length) { [EOL]     if (length < 8) { [EOL]         return false; [EOL]     } [EOL]     if (signature[0] != 0x74) { [EOL]         return false; [EOL]     } [EOL]     if (signature[1] != 0x65) { [EOL]         return false; [EOL]     } [EOL]     if (signature[2] != 0x73) { [EOL]         return false; [EOL]     } [EOL]     if (signature[3] != 0x74) { [EOL]         return false; [EOL]     } [EOL]     if (signature[4] != 0x31) { [EOL]         return false; [EOL]     } [EOL]     if (signature[5] != 0x2e) { [EOL]         return false; [EOL]     } [EOL]     if (signature[6] != 0x78) { [EOL]         return false; [EOL]     } [EOL]     if (signature[7] != 0x6d) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } <line_num>: 410,443
