public ArArchiveOutputStream(final OutputStream pOut) { [EOL]     this.out = pOut; [EOL] } <line_num>: 37,39
private long writeArchiveHeader() throws IOException { [EOL]     final String header = "!<arch>\n"; [EOL]     out.write(header.getBytes()); [EOL]     return header.length(); [EOL] } <line_num>: 41,45
public void closeArchiveEntry() throws IOException { [EOL]     if ((entryOffset % 2) != 0) { [EOL]         out.write('\n'); [EOL]         archiveOffset++; [EOL]     } [EOL] } <line_num>: 47,52
public void putArchiveEntry(final ArchiveEntry pEntry) throws IOException { [EOL]     ArArchiveEntry pArEntry = (ArArchiveEntry) pEntry; [EOL]     if (prevEntry == null) { [EOL]         archiveOffset += writeArchiveHeader(); [EOL]     } else { [EOL]         if (prevEntry.getLength() != entryOffset) { [EOL]             throw new IOException("length does not match entry (" + prevEntry.getLength() + " != " + entryOffset); [EOL]         } [EOL]         closeArchiveEntry(); [EOL]     } [EOL]     prevEntry = pArEntry; [EOL]     archiveOffset += writeEntryHeader(pArEntry); [EOL]     entryOffset = 0; [EOL] } <line_num>: 54,71
private long fill(final long pOffset, final long pNewOffset, final char pFill) throws IOException { [EOL]     final long diff = pNewOffset - pOffset; [EOL]     if (diff > 0) { [EOL]         for (int i = 0; i < diff; i++) { [EOL]             write(pFill); [EOL]         } [EOL]     } [EOL]     return pNewOffset; [EOL] } <line_num>: 73,83
private long write(final String data) throws IOException { [EOL]     final byte[] bytes = data.getBytes("ascii"); [EOL]     write(bytes); [EOL]     return bytes.length; [EOL] } <line_num>: 85,89
private long writeEntryHeader(final ArArchiveEntry pEntry) throws IOException { [EOL]     long offset = 0; [EOL]     final String n = pEntry.getName(); [EOL]     if (n.length() > 16) { [EOL]         throw new IOException("filename too long"); [EOL]     } [EOL]     offset += write(n); [EOL]     offset = fill(offset, 16, ' '); [EOL]     final String m = "" + (pEntry.getLastModified() / 1000); [EOL]     if (m.length() > 12) { [EOL]         throw new IOException("modified too long"); [EOL]     } [EOL]     offset += write(m); [EOL]     offset = fill(offset, 28, ' '); [EOL]     final String u = "" + pEntry.getUserId(); [EOL]     if (u.length() > 6) { [EOL]         throw new IOException("userid too long"); [EOL]     } [EOL]     offset += write(u); [EOL]     offset = fill(offset, 34, ' '); [EOL]     final String g = "" + pEntry.getGroupId(); [EOL]     if (g.length() > 6) { [EOL]         throw new IOException("groupid too long"); [EOL]     } [EOL]     offset += write(g); [EOL]     offset = fill(offset, 40, ' '); [EOL]     final String fm = "" + Integer.toString(pEntry.getMode(), 8); [EOL]     if (fm.length() > 8) { [EOL]         throw new IOException("filemode too long"); [EOL]     } [EOL]     offset += write(fm); [EOL]     offset = fill(offset, 48, ' '); [EOL]     final String s = "" + pEntry.getLength(); [EOL]     if (s.length() > 10) { [EOL]         throw new IOException("size too long"); [EOL]     } [EOL]     offset += write(s); [EOL]     offset = fill(offset, 58, ' '); [EOL]     offset += write("`\012"); [EOL]     return offset; [EOL] } <line_num>: 91,141
public void write(int b) throws IOException { [EOL]     out.write(b); [EOL]     entryOffset++; [EOL] } <line_num>: 143,146
public void write(byte[] b, int off, int len) throws IOException { [EOL]     out.write(b, off, len); [EOL]     entryOffset += len; [EOL] } <line_num>: 148,151
public void write(byte[] b) throws IOException { [EOL]     out.write(b); [EOL]     entryOffset += b.length; [EOL] } <line_num>: 153,156
public void close() throws IOException { [EOL]     closeArchiveEntry(); [EOL]     out.close(); [EOL]     prevEntry = null; [EOL] } <line_num>: 158,162
