public NioZipEncoding(Charset charset) { [EOL]     this.charset = charset; [EOL] } <line_num>: 49,51
public boolean canEncode(String name) { [EOL]     CharsetEncoder enc = this.charset.newEncoder(); [EOL]     enc.onMalformedInput(CodingErrorAction.REPORT); [EOL]     enc.onUnmappableCharacter(CodingErrorAction.REPORT); [EOL]     return enc.canEncode(name); [EOL] } <line_num>: 57,63
public ByteBuffer encode(String name) { [EOL]     CharsetEncoder enc = this.charset.newEncoder(); [EOL]     enc.onMalformedInput(CodingErrorAction.REPORT); [EOL]     enc.onUnmappableCharacter(CodingErrorAction.REPORT); [EOL]     CharBuffer cb = CharBuffer.wrap(name); [EOL]     ByteBuffer out = ByteBuffer.allocate(name.length() + (name.length() + 1) / 2); [EOL]     while (cb.remaining() > 0) { [EOL]         CoderResult res = enc.encode(cb, out, true); [EOL]         if (res.isUnmappable() || res.isMalformed()) { [EOL]             if (res.length() * 6 > out.remaining()) { [EOL]                 out = ZipEncodingHelper.growBuffer(out, out.position() + res.length() * 6); [EOL]             } [EOL]             for (int i = 0; i < res.length(); ++i) { [EOL]                 ZipEncodingHelper.appendSurrogate(out, cb.get()); [EOL]             } [EOL]         } else if (res.isOverflow()) { [EOL]             out = ZipEncodingHelper.growBuffer(out, 0); [EOL]         } else if (res.isUnderflow()) { [EOL]             enc.flush(out); [EOL]             break; [EOL]         } [EOL]     } [EOL]     out.limit(out.position()); [EOL]     out.rewind(); [EOL]     return out; [EOL] } <line_num>: 69,110
public String decode(byte[] data) throws IOException { [EOL]     return this.charset.newDecoder().onMalformedInput(CodingErrorAction.REPORT).onUnmappableCharacter(CodingErrorAction.REPORT).decode(ByteBuffer.wrap(data)).toString(); [EOL] } <line_num>: 116,121
