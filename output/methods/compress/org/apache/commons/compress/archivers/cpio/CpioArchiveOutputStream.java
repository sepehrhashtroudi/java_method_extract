public CpioArchiveOutputStream(final OutputStream out, final short format) { [EOL]     this.out = new FilterOutputStream(out); [EOL]     setFormat(format); [EOL] } <line_num>: 85,88
public CpioArchiveOutputStream(final OutputStream out) { [EOL]     this(out, FORMAT_NEW); [EOL] } <line_num>: 97,99
private void ensureOpen() throws IOException { [EOL]     if (this.closed) { [EOL]         throw new IOException("Stream closed"); [EOL]     } [EOL] } <line_num>: 107,111
private void setFormat(final short format) { [EOL]     switch(format) { [EOL]         case FORMAT_NEW: [EOL]         case FORMAT_NEW_CRC: [EOL]         case FORMAT_OLD_ASCII: [EOL]         case FORMAT_OLD_BINARY: [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("Unknown header type"); [EOL]     } [EOL]     synchronized (this) { [EOL]         this.entryFormat = format; [EOL]     } [EOL] } <line_num>: 120,134
public void putNextEntry(final CpioArchiveEntry e) throws IOException { [EOL]     ensureOpen(); [EOL]     if (this.cpioEntry != null) { [EOL]         closeArchiveEntry(); [EOL]     } [EOL]     if (e.getTime() == -1) { [EOL]         e.setTime(System.currentTimeMillis()); [EOL]     } [EOL]     if (e.getFormat() == -1) { [EOL]         e.setFormat(this.entryFormat); [EOL]     } [EOL]     if (this.names.put(e.getName(), e) != null) { [EOL]         throw new IOException("duplicate entry: " + e.getName()); [EOL]     } [EOL]     writeHeader(e); [EOL]     this.cpioEntry = e; [EOL]     this.written = 0; [EOL] } <line_num>: 149,171
private void writeHeader(final CpioArchiveEntry e) throws IOException { [EOL]     switch(e.getFormat()) { [EOL]         case FORMAT_NEW: [EOL]             out.write(MAGIC_NEW.getBytes()); [EOL]             writeNewEntry(e); [EOL]             break; [EOL]         case FORMAT_NEW_CRC: [EOL]             out.write(MAGIC_NEW_CRC.getBytes()); [EOL]             writeNewEntry(e); [EOL]             break; [EOL]         case FORMAT_OLD_ASCII: [EOL]             out.write(MAGIC_OLD_ASCII.getBytes()); [EOL]             writeOldAsciiEntry(e); [EOL]             break; [EOL]         case FORMAT_OLD_BINARY: [EOL]             boolean swapHalfWord = true; [EOL]             writeBinaryLong(MAGIC_OLD_BINARY, 2, swapHalfWord); [EOL]             writeOldBinaryEntry(e, swapHalfWord); [EOL]             break; [EOL]     } [EOL] } <line_num>: 173,193
private void writeNewEntry(final CpioArchiveEntry entry) throws IOException { [EOL]     writeAsciiLong(entry.getInode(), 8, 16); [EOL]     writeAsciiLong(entry.getMode(), 8, 16); [EOL]     writeAsciiLong(entry.getUID(), 8, 16); [EOL]     writeAsciiLong(entry.getGID(), 8, 16); [EOL]     writeAsciiLong(entry.getNumberOfLinks(), 8, 16); [EOL]     writeAsciiLong(entry.getTime(), 8, 16); [EOL]     writeAsciiLong(entry.getSize(), 8, 16); [EOL]     writeAsciiLong(entry.getDeviceMaj(), 8, 16); [EOL]     writeAsciiLong(entry.getDeviceMin(), 8, 16); [EOL]     writeAsciiLong(entry.getRemoteDeviceMaj(), 8, 16); [EOL]     writeAsciiLong(entry.getRemoteDeviceMin(), 8, 16); [EOL]     writeAsciiLong(entry.getName().length() + 1, 8, 16); [EOL]     writeAsciiLong(entry.getChksum(), 8, 16); [EOL]     writeCString(entry.getName()); [EOL]     pad(entry.getHeaderSize() + entry.getName().length() + 1, 4); [EOL] } <line_num>: 195,211
private void writeOldAsciiEntry(final CpioArchiveEntry entry) throws IOException { [EOL]     writeAsciiLong(entry.getDevice(), 6, 8); [EOL]     writeAsciiLong(entry.getInode(), 6, 8); [EOL]     writeAsciiLong(entry.getMode(), 6, 8); [EOL]     writeAsciiLong(entry.getUID(), 6, 8); [EOL]     writeAsciiLong(entry.getGID(), 6, 8); [EOL]     writeAsciiLong(entry.getNumberOfLinks(), 6, 8); [EOL]     writeAsciiLong(entry.getRemoteDevice(), 6, 8); [EOL]     writeAsciiLong(entry.getTime(), 11, 8); [EOL]     writeAsciiLong(entry.getName().length() + 1, 6, 8); [EOL]     writeAsciiLong(entry.getSize(), 11, 8); [EOL]     writeCString(entry.getName()); [EOL] } <line_num>: 213,226
private void writeOldBinaryEntry(final CpioArchiveEntry entry, final boolean swapHalfWord) throws IOException { [EOL]     writeBinaryLong(entry.getDevice(), 2, swapHalfWord); [EOL]     writeBinaryLong(entry.getInode(), 2, swapHalfWord); [EOL]     writeBinaryLong(entry.getMode(), 2, swapHalfWord); [EOL]     writeBinaryLong(entry.getUID(), 2, swapHalfWord); [EOL]     writeBinaryLong(entry.getGID(), 2, swapHalfWord); [EOL]     writeBinaryLong(entry.getNumberOfLinks(), 2, swapHalfWord); [EOL]     writeBinaryLong(entry.getRemoteDevice(), 2, swapHalfWord); [EOL]     writeBinaryLong(entry.getTime(), 4, swapHalfWord); [EOL]     writeBinaryLong(entry.getName().length() + 1, 2, swapHalfWord); [EOL]     writeBinaryLong(entry.getSize(), 4, swapHalfWord); [EOL]     writeCString(entry.getName()); [EOL]     pad(entry.getHeaderSize() + entry.getName().length() + 1, 2); [EOL] } <line_num>: 228,242
public void closeArchiveEntry() throws IOException { [EOL]     ensureOpen(); [EOL]     if (this.cpioEntry.getSize() != this.written) { [EOL]         throw new IOException("invalid entry size (expected " + this.cpioEntry.getSize() + " but got " + this.written + " bytes)"); [EOL]     } [EOL]     if ((this.cpioEntry.getFormat() | FORMAT_NEW_MASK) == FORMAT_NEW_MASK) { [EOL]         pad(this.cpioEntry.getSize(), 4); [EOL]     } else if ((this.cpioEntry.getFormat() | FORMAT_OLD_BINARY) == FORMAT_OLD_BINARY) { [EOL]         pad(this.cpioEntry.getSize(), 2); [EOL]     } [EOL]     if ((this.cpioEntry.getFormat() | FORMAT_NEW_CRC) == FORMAT_NEW_CRC) { [EOL]         if (this.crc != this.cpioEntry.getChksum()) { [EOL]             throw new IOException("CRC Error"); [EOL]         } [EOL]     } [EOL]     this.cpioEntry = null; [EOL]     this.crc = 0; [EOL]     this.written = 0; [EOL] } <line_num>: 250,271
public void write(final byte[] b, final int off, final int len) throws IOException { [EOL]     ensureOpen(); [EOL]     if (off < 0 || len < 0 || off > b.length - len) { [EOL]         throw new IndexOutOfBoundsException(); [EOL]     } else if (len == 0) { [EOL]         return; [EOL]     } [EOL]     if (this.cpioEntry == null) { [EOL]         throw new IOException("no current CPIO entry"); [EOL]     } [EOL]     if (this.written + len > this.cpioEntry.getSize()) { [EOL]         throw new IOException("attempt to write past end of STORED entry"); [EOL]     } [EOL]     out.write(b, off, len); [EOL]     this.written += len; [EOL]     if ((this.cpioEntry.getFormat() | FORMAT_NEW_CRC) == FORMAT_NEW_CRC) { [EOL]         for (int pos = 0; pos < len; pos++) { [EOL]             this.crc += b[pos] & 0xFF; [EOL]         } [EOL]     } [EOL] } <line_num>: 287,309
public void finish() throws IOException { [EOL]     ensureOpen(); [EOL]     if (this.finished) { [EOL]         return; [EOL]     } [EOL]     if (this.cpioEntry != null) { [EOL]         closeArchiveEntry(); [EOL]     } [EOL]     this.cpioEntry = new CpioArchiveEntry(this.entryFormat); [EOL]     this.cpioEntry.setMode(0); [EOL]     this.cpioEntry.setName("TRAILER!!!"); [EOL]     this.cpioEntry.setNumberOfLinks(1); [EOL]     writeHeader(this.cpioEntry); [EOL]     closeArchiveEntry(); [EOL] } <line_num>: 320,335
public void close() throws IOException { [EOL]     if (!this.closed) { [EOL]         this.finish(); [EOL]         super.close(); [EOL]         this.closed = true; [EOL]     } [EOL] } <line_num>: 344,350
private void pad(final long count, final int border) throws IOException { [EOL]     long skip = count % border; [EOL]     if (skip > 0) { [EOL]         byte[] tmp = new byte[(int) (border - skip)]; [EOL]         out.write(tmp); [EOL]     } [EOL] } <line_num>: 352,358
private void writeBinaryLong(final long number, final int length, final boolean swapHalfWord) throws IOException { [EOL]     byte[] tmp = CpioUtil.long2byteArray(number, length, swapHalfWord); [EOL]     out.write(tmp); [EOL] } <line_num>: 360,364
private void writeAsciiLong(final long number, final int length, final int radix) throws IOException { [EOL]     StringBuffer tmp = new StringBuffer(); [EOL]     String tmpStr; [EOL]     if (radix == 16) { [EOL]         tmp.append(Long.toHexString(number)); [EOL]     } else if (radix == 8) { [EOL]         tmp.append(Long.toOctalString(number)); [EOL]     } else { [EOL]         tmp.append(Long.toString(number)); [EOL]     } [EOL]     if (tmp.length() <= length) { [EOL]         long insertLength = length - tmp.length(); [EOL]         for (int pos = 0; pos < insertLength; pos++) { [EOL]             tmp.insert(0, "0"); [EOL]         } [EOL]         tmpStr = tmp.toString(); [EOL]     } else { [EOL]         tmpStr = tmp.substring(tmp.length() - length); [EOL]     } [EOL]     out.write(tmpStr.getBytes()); [EOL] } <line_num>: 366,388
private void writeCString(final String str) throws IOException { [EOL]     out.write(str.getBytes()); [EOL]     out.write('\0'); [EOL] } <line_num>: 390,393
public void putArchiveEntry(ArchiveEntry entry) throws IOException { [EOL]     this.putNextEntry((CpioArchiveEntry) entry); [EOL] } <line_num>: 402,404
public void write(int b) throws IOException { [EOL]     out.write(b); [EOL] } <line_num>: 411,413
