public BZip2CompressorOutputStream(OutputStream inStream) throws IOException { [EOL]     this(inStream, 9); [EOL] } <line_num>: 269,271
public BZip2CompressorOutputStream(OutputStream inStream, int inBlockSize) throws IOException { [EOL]     block = null; [EOL]     quadrant = null; [EOL]     zptr = null; [EOL]     ftab = null; [EOL]     bsSetStream(inStream); [EOL]     workFactor = 50; [EOL]     if (inBlockSize > 9) { [EOL]         inBlockSize = 9; [EOL]     } [EOL]     if (inBlockSize < 1) { [EOL]         inBlockSize = 1; [EOL]     } [EOL]     blockSize100k = inBlockSize; [EOL]     allocateCompressStructures(); [EOL]     initialize(); [EOL]     initBlock(); [EOL] } <line_num>: 273,293
private static void panic() { [EOL]     System.out.println("panic"); [EOL] } <line_num>: 48,51
private void makeMaps() { [EOL]     int i; [EOL]     nInUse = 0; [EOL]     for (i = 0; i < 256; i++) { [EOL]         if (inUse[i]) { [EOL]             seqToUnseq[nInUse] = (char) i; [EOL]             unseqToSeq[i] = (char) nInUse; [EOL]             nInUse++; [EOL]         } [EOL]     } [EOL] } <line_num>: 53,63
protected static void hbMakeCodeLengths(char[] len, int[] freq, int alphaSize, int maxLen) { [EOL]     int nNodes, nHeap, n1, n2, i, j, k; [EOL]     boolean tooLong; [EOL]     int[] heap = new int[MAX_ALPHA_SIZE + 2]; [EOL]     int[] weight = new int[MAX_ALPHA_SIZE * 2]; [EOL]     int[] parent = new int[MAX_ALPHA_SIZE * 2]; [EOL]     for (i = 0; i < alphaSize; i++) { [EOL]         weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8; [EOL]     } [EOL]     while (true) { [EOL]         nNodes = alphaSize; [EOL]         nHeap = 0; [EOL]         heap[0] = 0; [EOL]         weight[0] = 0; [EOL]         parent[0] = -2; [EOL]         for (i = 1; i <= alphaSize; i++) { [EOL]             parent[i] = -1; [EOL]             nHeap++; [EOL]             heap[nHeap] = i; [EOL]             { [EOL]                 int zz, tmp; [EOL]                 zz = nHeap; [EOL]                 tmp = heap[zz]; [EOL]                 while (weight[tmp] < weight[heap[zz >> 1]]) { [EOL]                     heap[zz] = heap[zz >> 1]; [EOL]                     zz >>= 1; [EOL]                 } [EOL]                 heap[zz] = tmp; [EOL]             } [EOL]         } [EOL]         if (!(nHeap < (MAX_ALPHA_SIZE + 2))) { [EOL]             panic(); [EOL]         } [EOL]         while (nHeap > 1) { [EOL]             n1 = heap[1]; [EOL]             heap[1] = heap[nHeap]; [EOL]             nHeap--; [EOL]             { [EOL]                 int zz = 0, yy = 0, tmp = 0; [EOL]                 zz = 1; [EOL]                 tmp = heap[zz]; [EOL]                 while (true) { [EOL]                     yy = zz << 1; [EOL]                     if (yy > nHeap) { [EOL]                         break; [EOL]                     } [EOL]                     if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]]) { [EOL]                         yy++; [EOL]                     } [EOL]                     if (weight[tmp] < weight[heap[yy]]) { [EOL]                         break; [EOL]                     } [EOL]                     heap[zz] = heap[yy]; [EOL]                     zz = yy; [EOL]                 } [EOL]                 heap[zz] = tmp; [EOL]             } [EOL]             n2 = heap[1]; [EOL]             heap[1] = heap[nHeap]; [EOL]             nHeap--; [EOL]             { [EOL]                 int zz = 0, yy = 0, tmp = 0; [EOL]                 zz = 1; [EOL]                 tmp = heap[zz]; [EOL]                 while (true) { [EOL]                     yy = zz << 1; [EOL]                     if (yy > nHeap) { [EOL]                         break; [EOL]                     } [EOL]                     if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]]) { [EOL]                         yy++; [EOL]                     } [EOL]                     if (weight[tmp] < weight[heap[yy]]) { [EOL]                         break; [EOL]                     } [EOL]                     heap[zz] = heap[yy]; [EOL]                     zz = yy; [EOL]                 } [EOL]                 heap[zz] = tmp; [EOL]             } [EOL]             nNodes++; [EOL]             parent[n1] = parent[n2] = nNodes; [EOL]             weight[nNodes] = ((weight[n1] & 0xffffff00) + (weight[n2] & 0xffffff00)) | (1 + (((weight[n1] & 0x000000ff) > (weight[n2] & 0x000000ff)) ? (weight[n1] & 0x000000ff) : (weight[n2] & 0x000000ff))); [EOL]             parent[nNodes] = -1; [EOL]             nHeap++; [EOL]             heap[nHeap] = nNodes; [EOL]             { [EOL]                 int zz = 0, tmp = 0; [EOL]                 zz = nHeap; [EOL]                 tmp = heap[zz]; [EOL]                 while (weight[tmp] < weight[heap[zz >> 1]]) { [EOL]                     heap[zz] = heap[zz >> 1]; [EOL]                     zz >>= 1; [EOL]                 } [EOL]                 heap[zz] = tmp; [EOL]             } [EOL]         } [EOL]         if (!(nNodes < (MAX_ALPHA_SIZE * 2))) { [EOL]             panic(); [EOL]         } [EOL]         tooLong = false; [EOL]         for (i = 1; i <= alphaSize; i++) { [EOL]             j = 0; [EOL]             k = i; [EOL]             while (parent[k] >= 0) { [EOL]                 k = parent[k]; [EOL]                 j++; [EOL]             } [EOL]             len[i - 1] = (char) j; [EOL]             if (j > maxLen) { [EOL]                 tooLong = true; [EOL]             } [EOL]         } [EOL]         if (!tooLong) { [EOL]             break; [EOL]         } [EOL]         for (i = 1; i < alphaSize; i++) { [EOL]             j = weight[i] >> 8; [EOL]             j = 1 + (j / 2); [EOL]             weight[i] = j << 8; [EOL]         } [EOL]     } [EOL] } <line_num>: 65,210
public void write(int bv) throws IOException { [EOL]     int b = (256 + bv) % 256; [EOL]     if (currentChar != -1) { [EOL]         if (currentChar == b) { [EOL]             runLength++; [EOL]             if (runLength > 254) { [EOL]                 writeRun(); [EOL]                 currentChar = -1; [EOL]                 runLength = 0; [EOL]             } [EOL]         } else { [EOL]             writeRun(); [EOL]             runLength = 1; [EOL]             currentChar = b; [EOL]         } [EOL]     } else { [EOL]         currentChar = b; [EOL]         runLength++; [EOL]     } [EOL] } <line_num>: 300,319
private void writeRun() throws IOException { [EOL]     if (last < allowableBlockSize) { [EOL]         inUse[currentChar] = true; [EOL]         for (int i = 0; i < runLength; i++) { [EOL]             mCrc.updateCRC((char) currentChar); [EOL]         } [EOL]         switch(runLength) { [EOL]             case 1: [EOL]                 last++; [EOL]                 block[last + 1] = (char) currentChar; [EOL]                 break; [EOL]             case 2: [EOL]                 last++; [EOL]                 block[last + 1] = (char) currentChar; [EOL]                 last++; [EOL]                 block[last + 1] = (char) currentChar; [EOL]                 break; [EOL]             case 3: [EOL]                 last++; [EOL]                 block[last + 1] = (char) currentChar; [EOL]                 last++; [EOL]                 block[last + 1] = (char) currentChar; [EOL]                 last++; [EOL]                 block[last + 1] = (char) currentChar; [EOL]                 break; [EOL]             default: [EOL]                 inUse[runLength - 4] = true; [EOL]                 last++; [EOL]                 block[last + 1] = (char) currentChar; [EOL]                 last++; [EOL]                 block[last + 1] = (char) currentChar; [EOL]                 last++; [EOL]                 block[last + 1] = (char) currentChar; [EOL]                 last++; [EOL]                 block[last + 1] = (char) currentChar; [EOL]                 last++; [EOL]                 block[last + 1] = (char) (runLength - 4); [EOL]                 break; [EOL]         } [EOL]     } else { [EOL]         endBlock(); [EOL]         initBlock(); [EOL]         writeRun(); [EOL]     } [EOL] } <line_num>: 321,365
protected void finalize() throws Throwable { [EOL]     close(); [EOL]     super.finalize(); [EOL] } <line_num>: 369,372
public void close() throws IOException { [EOL]     if (closed) { [EOL]         return; [EOL]     } [EOL]     finish(); [EOL]     super.close(); [EOL]     bsStream.close(); [EOL]     closed = true; [EOL] } <line_num>: 374,382
protected void finish() throws IOException { [EOL]     if (closed) { [EOL]         return; [EOL]     } [EOL]     if (runLength > 0) { [EOL]         writeRun(); [EOL]     } [EOL]     currentChar = -1; [EOL]     endBlock(); [EOL]     endCompression(); [EOL] } <line_num>: 384,395
public void flush() throws IOException { [EOL]     super.flush(); [EOL]     bsStream.flush(); [EOL] } <line_num>: 397,400
private void initialize() throws IOException { [EOL]     bytesOut = 0; [EOL]     nBlocksRandomised = 0; [EOL]     bsPutUChar('B'); [EOL]     bsPutUChar('Z'); [EOL]     bsPutUChar('h'); [EOL]     bsPutUChar('0' + blockSize100k); [EOL]     combinedCRC = 0; [EOL] } <line_num>: 404,417
private void initBlock() { [EOL]     mCrc.initialiseCRC(); [EOL]     last = -1; [EOL]     for (int i = 0; i < 256; i++) { [EOL]         inUse[i] = false; [EOL]     } [EOL]     allowableBlockSize = baseBlockSize * blockSize100k - 20; [EOL] } <line_num>: 421,433
private void endBlock() throws IOException { [EOL]     blockCRC = mCrc.getFinalCRC(); [EOL]     combinedCRC = (combinedCRC << 1) | (combinedCRC >>> 31); [EOL]     combinedCRC ^= blockCRC; [EOL]     if (last == -1) { [EOL]         return; [EOL]     } [EOL]     doReversibleTransformation(); [EOL]     bsPutUChar(0x31); [EOL]     bsPutUChar(0x41); [EOL]     bsPutUChar(0x59); [EOL]     bsPutUChar(0x26); [EOL]     bsPutUChar(0x53); [EOL]     bsPutUChar(0x59); [EOL]     bsPutint(blockCRC); [EOL]     if (blockRandomised) { [EOL]         bsW(1, 1); [EOL]         nBlocksRandomised++; [EOL]     } else { [EOL]         bsW(1, 0); [EOL]     } [EOL]     moveToFrontCodeAndSend(); [EOL] } <line_num>: 435,482
private void endCompression() throws IOException { [EOL]     bsPutUChar(0x17); [EOL]     bsPutUChar(0x72); [EOL]     bsPutUChar(0x45); [EOL]     bsPutUChar(0x38); [EOL]     bsPutUChar(0x50); [EOL]     bsPutUChar(0x90); [EOL]     bsPutint(combinedCRC); [EOL]     bsFinishedWithStream(); [EOL] } <line_num>: 484,502
private void hbAssignCodes(int[] code, char[] length, int minLen, int maxLen, int alphaSize) { [EOL]     int n, vec, i; [EOL]     vec = 0; [EOL]     for (n = minLen; n <= maxLen; n++) { [EOL]         for (i = 0; i < alphaSize; i++) { [EOL]             if (length[i] == n) { [EOL]                 code[i] = vec; [EOL]                 vec++; [EOL]             } [EOL]         } [EOL]         vec <<= 1; [EOL]     } [EOL] } <line_num>: 504,518
private void bsSetStream(OutputStream f) { [EOL]     bsStream = f; [EOL]     bsLive = 0; [EOL]     bsBuff = 0; [EOL]     bytesOut = 0; [EOL] } <line_num>: 520,525
private void bsFinishedWithStream() throws IOException { [EOL]     while (bsLive > 0) { [EOL]         int ch = (bsBuff >> 24); [EOL]         try { [EOL]             bsStream.write(ch); [EOL]         } catch (IOException e) { [EOL]             throw e; [EOL]         } [EOL]         bsBuff <<= 8; [EOL]         bsLive -= 8; [EOL]         bytesOut++; [EOL]     } [EOL] } <line_num>: 527,539
private void bsW(int n, int v) throws IOException { [EOL]     while (bsLive >= 8) { [EOL]         int ch = (bsBuff >> 24); [EOL]         try { [EOL]             bsStream.write(ch); [EOL]         } catch (IOException e) { [EOL]             throw e; [EOL]         } [EOL]         bsBuff <<= 8; [EOL]         bsLive -= 8; [EOL]         bytesOut++; [EOL]     } [EOL]     bsBuff |= (v << (32 - bsLive - n)); [EOL]     bsLive += n; [EOL] } <line_num>: 541,555
private void bsPutUChar(int c) throws IOException { [EOL]     bsW(8, c); [EOL] } <line_num>: 557,559
private void bsPutint(int u) throws IOException { [EOL]     bsW(8, (u >> 24) & 0xff); [EOL]     bsW(8, (u >> 16) & 0xff); [EOL]     bsW(8, (u >> 8) & 0xff); [EOL]     bsW(8, u & 0xff); [EOL] } <line_num>: 561,566
private void bsPutIntVS(int numBits, int c) throws IOException { [EOL]     bsW(numBits, c); [EOL] } <line_num>: 568,570
private void sendMTFValues() throws IOException { [EOL]     char[][] len = new char[N_GROUPS][MAX_ALPHA_SIZE]; [EOL]     int v, t, i, j, gs, ge, totc, bt, bc, iter; [EOL]     int nSelectors = 0, alphaSize, minLen, maxLen, selCtr; [EOL]     int nGroups; [EOL]     alphaSize = nInUse + 2; [EOL]     for (t = 0; t < N_GROUPS; t++) { [EOL]         for (v = 0; v < alphaSize; v++) { [EOL]             len[t][v] = (char) GREATER_ICOST; [EOL]         } [EOL]     } [EOL]     if (nMTF <= 0) { [EOL]         panic(); [EOL]     } [EOL]     if (nMTF < 200) { [EOL]         nGroups = 2; [EOL]     } else if (nMTF < 600) { [EOL]         nGroups = 3; [EOL]     } else if (nMTF < 1200) { [EOL]         nGroups = 4; [EOL]     } else if (nMTF < 2400) { [EOL]         nGroups = 5; [EOL]     } else { [EOL]         nGroups = 6; [EOL]     } [EOL]     { [EOL]         int nPart, remF, tFreq, aFreq; [EOL]         nPart = nGroups; [EOL]         remF = nMTF; [EOL]         gs = 0; [EOL]         while (nPart > 0) { [EOL]             tFreq = remF / nPart; [EOL]             ge = gs - 1; [EOL]             aFreq = 0; [EOL]             while (aFreq < tFreq && ge < alphaSize - 1) { [EOL]                 ge++; [EOL]                 aFreq += mtfFreq[ge]; [EOL]             } [EOL]             if (ge > gs && nPart != nGroups && nPart != 1 && ((nGroups - nPart) % 2 != 0)) { [EOL]                 aFreq -= mtfFreq[ge]; [EOL]                 ge--; [EOL]             } [EOL]             for (v = 0; v < alphaSize; v++) { [EOL]                 if (v >= gs && v <= ge) { [EOL]                     len[nPart - 1][v] = (char) LESSER_ICOST; [EOL]                 } else { [EOL]                     len[nPart - 1][v] = (char) GREATER_ICOST; [EOL]                 } [EOL]             } [EOL]             nPart--; [EOL]             gs = ge + 1; [EOL]             remF -= aFreq; [EOL]         } [EOL]     } [EOL]     int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE]; [EOL]     int[] fave = new int[N_GROUPS]; [EOL]     short[] cost = new short[N_GROUPS]; [EOL]     for (iter = 0; iter < N_ITERS; iter++) { [EOL]         for (t = 0; t < nGroups; t++) { [EOL]             fave[t] = 0; [EOL]         } [EOL]         for (t = 0; t < nGroups; t++) { [EOL]             for (v = 0; v < alphaSize; v++) { [EOL]                 rfreq[t][v] = 0; [EOL]             } [EOL]         } [EOL]         nSelectors = 0; [EOL]         totc = 0; [EOL]         gs = 0; [EOL]         while (true) { [EOL]             if (gs >= nMTF) { [EOL]                 break; [EOL]             } [EOL]             ge = gs + G_SIZE - 1; [EOL]             if (ge >= nMTF) { [EOL]                 ge = nMTF - 1; [EOL]             } [EOL]             for (t = 0; t < nGroups; t++) { [EOL]                 cost[t] = 0; [EOL]             } [EOL]             if (nGroups == 6) { [EOL]                 short cost0, cost1, cost2, cost3, cost4, cost5; [EOL]                 cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0; [EOL]                 for (i = gs; i <= ge; i++) { [EOL]                     short icv = szptr[i]; [EOL]                     cost0 += len[0][icv]; [EOL]                     cost1 += len[1][icv]; [EOL]                     cost2 += len[2][icv]; [EOL]                     cost3 += len[3][icv]; [EOL]                     cost4 += len[4][icv]; [EOL]                     cost5 += len[5][icv]; [EOL]                 } [EOL]                 cost[0] = cost0; [EOL]                 cost[1] = cost1; [EOL]                 cost[2] = cost2; [EOL]                 cost[3] = cost3; [EOL]                 cost[4] = cost4; [EOL]                 cost[5] = cost5; [EOL]             } else { [EOL]                 for (i = gs; i <= ge; i++) { [EOL]                     short icv = szptr[i]; [EOL]                     for (t = 0; t < nGroups; t++) { [EOL]                         cost[t] += len[t][icv]; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             bc = 999999999; [EOL]             bt = -1; [EOL]             for (t = 0; t < nGroups; t++) { [EOL]                 if (cost[t] < bc) { [EOL]                     bc = cost[t]; [EOL]                     bt = t; [EOL]                 } [EOL]             } [EOL]             totc += bc; [EOL]             fave[bt]++; [EOL]             selector[nSelectors] = (char) bt; [EOL]             nSelectors++; [EOL]             for (i = gs; i <= ge; i++) { [EOL]                 rfreq[bt][szptr[i]]++; [EOL]             } [EOL]             gs = ge + 1; [EOL]         } [EOL]         for (t = 0; t < nGroups; t++) { [EOL]             hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20); [EOL]         } [EOL]     } [EOL]     rfreq = null; [EOL]     fave = null; [EOL]     cost = null; [EOL]     if (!(nGroups < 8)) { [EOL]         panic(); [EOL]     } [EOL]     if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) { [EOL]         panic(); [EOL]     } [EOL]     { [EOL]         char[] pos = new char[N_GROUPS]; [EOL]         char ll_i, tmp2, tmp; [EOL]         for (i = 0; i < nGroups; i++) { [EOL]             pos[i] = (char) i; [EOL]         } [EOL]         for (i = 0; i < nSelectors; i++) { [EOL]             ll_i = selector[i]; [EOL]             j = 0; [EOL]             tmp = pos[j]; [EOL]             while (ll_i != tmp) { [EOL]                 j++; [EOL]                 tmp2 = tmp; [EOL]                 tmp = pos[j]; [EOL]                 pos[j] = tmp2; [EOL]             } [EOL]             pos[0] = tmp; [EOL]             selectorMtf[i] = (char) j; [EOL]         } [EOL]     } [EOL]     int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE]; [EOL]     for (t = 0; t < nGroups; t++) { [EOL]         minLen = 32; [EOL]         maxLen = 0; [EOL]         for (i = 0; i < alphaSize; i++) { [EOL]             if (len[t][i] > maxLen) { [EOL]                 maxLen = len[t][i]; [EOL]             } [EOL]             if (len[t][i] < minLen) { [EOL]                 minLen = len[t][i]; [EOL]             } [EOL]         } [EOL]         if (maxLen > 20) { [EOL]             panic(); [EOL]         } [EOL]         if (minLen < 1) { [EOL]             panic(); [EOL]         } [EOL]         hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize); [EOL]     } [EOL]     { [EOL]         boolean[] inUse16 = new boolean[16]; [EOL]         for (i = 0; i < 16; i++) { [EOL]             inUse16[i] = false; [EOL]             for (j = 0; j < 16; j++) { [EOL]                 if (inUse[i * 16 + j]) { [EOL]                     inUse16[i] = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (i = 0; i < 16; i++) { [EOL]             if (inUse16[i]) { [EOL]                 bsW(1, 1); [EOL]             } else { [EOL]                 bsW(1, 0); [EOL]             } [EOL]         } [EOL]         for (i = 0; i < 16; i++) { [EOL]             if (inUse16[i]) { [EOL]                 for (j = 0; j < 16; j++) { [EOL]                     if (inUse[i * 16 + j]) { [EOL]                         bsW(1, 1); [EOL]                     } else { [EOL]                         bsW(1, 0); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     bsW(3, nGroups); [EOL]     bsW(15, nSelectors); [EOL]     for (i = 0; i < nSelectors; i++) { [EOL]         for (j = 0; j < selectorMtf[i]; j++) { [EOL]             bsW(1, 1); [EOL]         } [EOL]         bsW(1, 0); [EOL]     } [EOL]     for (t = 0; t < nGroups; t++) { [EOL]         int curr = len[t][0]; [EOL]         bsW(5, curr); [EOL]         for (i = 0; i < alphaSize; i++) { [EOL]             while (curr < len[t][i]) { [EOL]                 bsW(2, 2); [EOL]                 curr++; [EOL]             } [EOL]             while (curr > len[t][i]) { [EOL]                 bsW(2, 3); [EOL]                 curr--; [EOL]             } [EOL]             bsW(1, 0); [EOL]         } [EOL]     } [EOL]     selCtr = 0; [EOL]     gs = 0; [EOL]     while (true) { [EOL]         if (gs >= nMTF) { [EOL]             break; [EOL]         } [EOL]         ge = gs + G_SIZE - 1; [EOL]         if (ge >= nMTF) { [EOL]             ge = nMTF - 1; [EOL]         } [EOL]         for (i = gs; i <= ge; i++) { [EOL]             bsW(len[selector[selCtr]][szptr[i]], code[selector[selCtr]][szptr[i]]); [EOL]         } [EOL]         gs = ge + 1; [EOL]         selCtr++; [EOL]     } [EOL]     if (!(selCtr == nSelectors)) { [EOL]         panic(); [EOL]     } [EOL] } <line_num>: 572,884
private void moveToFrontCodeAndSend() throws IOException { [EOL]     bsPutIntVS(24, origPtr); [EOL]     generateMTFValues(); [EOL]     sendMTFValues(); [EOL] } <line_num>: 886,890
private void simpleSort(int lo, int hi, int d) { [EOL]     int i, j, h, bigN, hp; [EOL]     int v; [EOL]     bigN = hi - lo + 1; [EOL]     if (bigN < 2) { [EOL]         return; [EOL]     } [EOL]     hp = 0; [EOL]     while (incs[hp] < bigN) { [EOL]         hp++; [EOL]     } [EOL]     hp--; [EOL]     for (; hp >= 0; hp--) { [EOL]         h = incs[hp]; [EOL]         i = lo + h; [EOL]         while (true) { [EOL]             if (i > hi) { [EOL]                 break; [EOL]             } [EOL]             v = zptr[i]; [EOL]             j = i; [EOL]             while (fullGtU(zptr[j - h] + d, v + d)) { [EOL]                 zptr[j] = zptr[j - h]; [EOL]                 j = j - h; [EOL]                 if (j <= (lo + h - 1)) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             zptr[j] = v; [EOL]             i++; [EOL]             if (i > hi) { [EOL]                 break; [EOL]             } [EOL]             v = zptr[i]; [EOL]             j = i; [EOL]             while (fullGtU(zptr[j - h] + d, v + d)) { [EOL]                 zptr[j] = zptr[j - h]; [EOL]                 j = j - h; [EOL]                 if (j <= (lo + h - 1)) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             zptr[j] = v; [EOL]             i++; [EOL]             if (i > hi) { [EOL]                 break; [EOL]             } [EOL]             v = zptr[i]; [EOL]             j = i; [EOL]             while (fullGtU(zptr[j - h] + d, v + d)) { [EOL]                 zptr[j] = zptr[j - h]; [EOL]                 j = j - h; [EOL]                 if (j <= (lo + h - 1)) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             zptr[j] = v; [EOL]             i++; [EOL]             if (workDone > workLimit && firstAttempt) { [EOL]                 return; [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 894,967
private void vswap(int p1, int p2, int n) { [EOL]     int temp = 0; [EOL]     while (n > 0) { [EOL]         temp = zptr[p1]; [EOL]         zptr[p1] = zptr[p2]; [EOL]         zptr[p2] = temp; [EOL]         p1++; [EOL]         p2++; [EOL]         n--; [EOL]     } [EOL] } <line_num>: 969,979
private char med3(char a, char b, char c) { [EOL]     char t; [EOL]     if (a > b) { [EOL]         t = a; [EOL]         a = b; [EOL]         b = t; [EOL]     } [EOL]     if (b > c) { [EOL]         b = c; [EOL]     } [EOL]     if (a > b) { [EOL]         b = a; [EOL]     } [EOL]     return b; [EOL] } <line_num>: 981,995
private void qSort3(int loSt, int hiSt, int dSt, StackElem[] stack) { [EOL]     int unLo, unHi, ltLo, gtHi, med, n, m; [EOL]     int sp, lo, hi, d; [EOL]     sp = 0; [EOL]     stack[sp].ll = loSt; [EOL]     stack[sp].hh = hiSt; [EOL]     stack[sp].dd = dSt; [EOL]     sp++; [EOL]     while (sp > 0) { [EOL]         if (sp >= QSORT_STACK_SIZE) { [EOL]             panic(); [EOL]         } [EOL]         sp--; [EOL]         lo = stack[sp].ll; [EOL]         hi = stack[sp].hh; [EOL]         d = stack[sp].dd; [EOL]         if (hi - lo < SMALL_THRESH || d > DEPTH_THRESH) { [EOL]             simpleSort(lo, hi, d); [EOL]             if (workDone > workLimit && firstAttempt) { [EOL]                 return; [EOL]             } [EOL]             continue; [EOL]         } [EOL]         med = med3(block[zptr[lo] + d + 1], block[zptr[hi] + d + 1], block[zptr[(lo + hi) >>> 1] + d + 1]); [EOL]         unLo = ltLo = lo; [EOL]         unHi = gtHi = hi; [EOL]         while (true) { [EOL]             while (true) { [EOL]                 if (unLo > unHi) { [EOL]                     break; [EOL]                 } [EOL]                 n = block[zptr[unLo] + d + 1] - med; [EOL]                 if (n == 0) { [EOL]                     int temp = 0; [EOL]                     temp = zptr[unLo]; [EOL]                     zptr[unLo] = zptr[ltLo]; [EOL]                     zptr[ltLo] = temp; [EOL]                     ltLo++; [EOL]                     unLo++; [EOL]                     continue; [EOL]                 } [EOL]                 if (n > 0) { [EOL]                     break; [EOL]                 } [EOL]                 unLo++; [EOL]             } [EOL]             while (true) { [EOL]                 if (unLo > unHi) { [EOL]                     break; [EOL]                 } [EOL]                 n = block[zptr[unHi] + d + 1] - med; [EOL]                 if (n == 0) { [EOL]                     int temp = 0; [EOL]                     temp = zptr[unHi]; [EOL]                     zptr[unHi] = zptr[gtHi]; [EOL]                     zptr[gtHi] = temp; [EOL]                     gtHi--; [EOL]                     unHi--; [EOL]                     continue; [EOL]                 } [EOL]                 if (n < 0) { [EOL]                     break; [EOL]                 } [EOL]                 unHi--; [EOL]             } [EOL]             if (unLo > unHi) { [EOL]                 break; [EOL]             } [EOL]             int temp = 0; [EOL]             temp = zptr[unLo]; [EOL]             zptr[unLo] = zptr[unHi]; [EOL]             zptr[unHi] = temp; [EOL]             unLo++; [EOL]             unHi--; [EOL]         } [EOL]         if (gtHi < ltLo) { [EOL]             stack[sp].ll = lo; [EOL]             stack[sp].hh = hi; [EOL]             stack[sp].dd = d + 1; [EOL]             sp++; [EOL]             continue; [EOL]         } [EOL]         n = ((ltLo - lo) < (unLo - ltLo)) ? (ltLo - lo) : (unLo - ltLo); [EOL]         vswap(lo, unLo - n, n); [EOL]         m = ((hi - gtHi) < (gtHi - unHi)) ? (hi - gtHi) : (gtHi - unHi); [EOL]         vswap(unLo, hi - m + 1, m); [EOL]         n = lo + unLo - ltLo - 1; [EOL]         m = hi - (gtHi - unHi) + 1; [EOL]         stack[sp].ll = lo; [EOL]         stack[sp].hh = n; [EOL]         stack[sp].dd = d; [EOL]         sp++; [EOL]         stack[sp].ll = n + 1; [EOL]         stack[sp].hh = m - 1; [EOL]         stack[sp].dd = d + 1; [EOL]         sp++; [EOL]         stack[sp].ll = m; [EOL]         stack[sp].hh = hi; [EOL]         stack[sp].dd = d; [EOL]         sp++; [EOL]     } [EOL] } <line_num>: 1003,1120
private void mainSort() { [EOL]     int i, j, ss, sb; [EOL]     int[] runningOrder = new int[256]; [EOL]     int[] copy = new int[256]; [EOL]     boolean[] bigDone = new boolean[256]; [EOL]     int c1, c2; [EOL]     int numQSorted; [EOL]     for (i = 0; i < NUM_OVERSHOOT_BYTES; i++) { [EOL]         block[last + i + 2] = block[(i % (last + 1)) + 1]; [EOL]     } [EOL]     for (i = 0; i <= last + NUM_OVERSHOOT_BYTES; i++) { [EOL]         quadrant[i] = 0; [EOL]     } [EOL]     block[0] = block[last + 1]; [EOL]     if (last < 4000) { [EOL]         for (i = 0; i <= last; i++) { [EOL]             zptr[i] = i; [EOL]         } [EOL]         firstAttempt = false; [EOL]         workDone = workLimit = 0; [EOL]         simpleSort(0, last, 0); [EOL]     } else { [EOL]         numQSorted = 0; [EOL]         for (i = 0; i <= 255; i++) { [EOL]             bigDone[i] = false; [EOL]         } [EOL]         for (i = 0; i <= 65536; i++) { [EOL]             ftab[i] = 0; [EOL]         } [EOL]         c1 = block[0]; [EOL]         for (i = 0; i <= last; i++) { [EOL]             c2 = block[i + 1]; [EOL]             ftab[(c1 << 8) + c2]++; [EOL]             c1 = c2; [EOL]         } [EOL]         for (i = 1; i <= 65536; i++) { [EOL]             ftab[i] += ftab[i - 1]; [EOL]         } [EOL]         c1 = block[1]; [EOL]         for (i = 0; i < last; i++) { [EOL]             c2 = block[i + 2]; [EOL]             j = (c1 << 8) + c2; [EOL]             c1 = c2; [EOL]             ftab[j]--; [EOL]             zptr[ftab[j]] = i; [EOL]         } [EOL]         j = ((block[last + 1]) << 8) + (block[1]); [EOL]         ftab[j]--; [EOL]         zptr[ftab[j]] = last; [EOL]         for (i = 0; i <= 255; i++) { [EOL]             runningOrder[i] = i; [EOL]         } [EOL]         { [EOL]             int vv; [EOL]             int h = 1; [EOL]             do { [EOL]                 h = 3 * h + 1; [EOL]             } while (h <= 256); [EOL]             do { [EOL]                 h = h / 3; [EOL]                 for (i = h; i <= 255; i++) { [EOL]                     vv = runningOrder[i]; [EOL]                     j = i; [EOL]                     while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) { [EOL]                         runningOrder[j] = runningOrder[j - h]; [EOL]                         j = j - h; [EOL]                         if (j <= (h - 1)) { [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                     runningOrder[j] = vv; [EOL]                 } [EOL]             } while (h != 1); [EOL]         } [EOL]         StackElem[] stack = new StackElem[QSORT_STACK_SIZE]; [EOL]         for (int count = 0; count < QSORT_STACK_SIZE; count++) { [EOL]             stack[count] = new StackElem(); [EOL]         } [EOL]         for (i = 0; i <= 255; i++) { [EOL]             ss = runningOrder[i]; [EOL]             for (j = 0; j <= 255; j++) { [EOL]                 sb = (ss << 8) + j; [EOL]                 if (!((ftab[sb] & SETMASK) == SETMASK)) { [EOL]                     int lo = ftab[sb] & CLEARMASK; [EOL]                     int hi = (ftab[sb + 1] & CLEARMASK) - 1; [EOL]                     if (hi > lo) { [EOL]                         qSort3(lo, hi, 2, stack); [EOL]                         numQSorted += (hi - lo + 1); [EOL]                         if (workDone > workLimit && firstAttempt) { [EOL]                             return; [EOL]                         } [EOL]                     } [EOL]                     ftab[sb] |= SETMASK; [EOL]                 } [EOL]             } [EOL]             bigDone[ss] = true; [EOL]             if (i < 255) { [EOL]                 int bbStart = ftab[ss << 8] & CLEARMASK; [EOL]                 int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart; [EOL]                 int shifts = 0; [EOL]                 while ((bbSize >> shifts) > 65534) { [EOL]                     shifts++; [EOL]                 } [EOL]                 for (j = 0; j < bbSize; j++) { [EOL]                     int a2update = zptr[bbStart + j]; [EOL]                     int qVal = (j >> shifts); [EOL]                     quadrant[a2update] = qVal; [EOL]                     if (a2update < NUM_OVERSHOOT_BYTES) { [EOL]                         quadrant[a2update + last + 1] = qVal; [EOL]                     } [EOL]                 } [EOL]                 if (!(((bbSize - 1) >> shifts) <= 65535)) { [EOL]                     panic(); [EOL]                 } [EOL]             } [EOL]             for (j = 0; j <= 255; j++) { [EOL]                 copy[j] = ftab[(j << 8) + ss] & CLEARMASK; [EOL]             } [EOL]             for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss + 1) << 8] & CLEARMASK); j++) { [EOL]                 c1 = block[zptr[j]]; [EOL]                 if (!bigDone[c1]) { [EOL]                     zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1; [EOL]                     copy[c1]++; [EOL]                 } [EOL]             } [EOL]             for (j = 0; j <= 255; j++) { [EOL]                 ftab[(j << 8) + ss] |= SETMASK; [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 1122,1321
private void randomiseBlock() { [EOL]     int i; [EOL]     int rNToGo = 0; [EOL]     int rTPos = 0; [EOL]     for (i = 0; i < 256; i++) { [EOL]         inUse[i] = false; [EOL]     } [EOL]     for (i = 0; i <= last; i++) { [EOL]         if (rNToGo == 0) { [EOL]             rNToGo = (char) rNums[rTPos]; [EOL]             rTPos++; [EOL]             if (rTPos == 512) { [EOL]                 rTPos = 0; [EOL]             } [EOL]         } [EOL]         rNToGo--; [EOL]         block[i + 1] ^= ((rNToGo == 1) ? 1 : 0); [EOL]         block[i + 1] &= 0xFF; [EOL]         inUse[block[i + 1]] = true; [EOL]     } [EOL] } <line_num>: 1323,1346
private void doReversibleTransformation() { [EOL]     int i; [EOL]     workLimit = workFactor * last; [EOL]     workDone = 0; [EOL]     blockRandomised = false; [EOL]     firstAttempt = true; [EOL]     mainSort(); [EOL]     if (workDone > workLimit && firstAttempt) { [EOL]         randomiseBlock(); [EOL]         workLimit = workDone = 0; [EOL]         blockRandomised = true; [EOL]         firstAttempt = false; [EOL]         mainSort(); [EOL]     } [EOL]     origPtr = -1; [EOL]     for (i = 0; i <= last; i++) { [EOL]         if (zptr[i] == 0) { [EOL]             origPtr = i; [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (origPtr == -1) { [EOL]         panic(); [EOL]     } [EOL] } <line_num>: 1348,1377
private boolean fullGtU(int i1, int i2) { [EOL]     int k; [EOL]     char c1, c2; [EOL]     int s1, s2; [EOL]     c1 = block[i1 + 1]; [EOL]     c2 = block[i2 + 1]; [EOL]     if (c1 != c2) { [EOL]         return (c1 > c2); [EOL]     } [EOL]     i1++; [EOL]     i2++; [EOL]     c1 = block[i1 + 1]; [EOL]     c2 = block[i2 + 1]; [EOL]     if (c1 != c2) { [EOL]         return (c1 > c2); [EOL]     } [EOL]     i1++; [EOL]     i2++; [EOL]     c1 = block[i1 + 1]; [EOL]     c2 = block[i2 + 1]; [EOL]     if (c1 != c2) { [EOL]         return (c1 > c2); [EOL]     } [EOL]     i1++; [EOL]     i2++; [EOL]     c1 = block[i1 + 1]; [EOL]     c2 = block[i2 + 1]; [EOL]     if (c1 != c2) { [EOL]         return (c1 > c2); [EOL]     } [EOL]     i1++; [EOL]     i2++; [EOL]     c1 = block[i1 + 1]; [EOL]     c2 = block[i2 + 1]; [EOL]     if (c1 != c2) { [EOL]         return (c1 > c2); [EOL]     } [EOL]     i1++; [EOL]     i2++; [EOL]     c1 = block[i1 + 1]; [EOL]     c2 = block[i2 + 1]; [EOL]     if (c1 != c2) { [EOL]         return (c1 > c2); [EOL]     } [EOL]     i1++; [EOL]     i2++; [EOL]     k = last + 1; [EOL]     do { [EOL]         c1 = block[i1 + 1]; [EOL]         c2 = block[i2 + 1]; [EOL]         if (c1 != c2) { [EOL]             return (c1 > c2); [EOL]         } [EOL]         s1 = quadrant[i1]; [EOL]         s2 = quadrant[i2]; [EOL]         if (s1 != s2) { [EOL]             return (s1 > s2); [EOL]         } [EOL]         i1++; [EOL]         i2++; [EOL]         c1 = block[i1 + 1]; [EOL]         c2 = block[i2 + 1]; [EOL]         if (c1 != c2) { [EOL]             return (c1 > c2); [EOL]         } [EOL]         s1 = quadrant[i1]; [EOL]         s2 = quadrant[i2]; [EOL]         if (s1 != s2) { [EOL]             return (s1 > s2); [EOL]         } [EOL]         i1++; [EOL]         i2++; [EOL]         c1 = block[i1 + 1]; [EOL]         c2 = block[i2 + 1]; [EOL]         if (c1 != c2) { [EOL]             return (c1 > c2); [EOL]         } [EOL]         s1 = quadrant[i1]; [EOL]         s2 = quadrant[i2]; [EOL]         if (s1 != s2) { [EOL]             return (s1 > s2); [EOL]         } [EOL]         i1++; [EOL]         i2++; [EOL]         c1 = block[i1 + 1]; [EOL]         c2 = block[i2 + 1]; [EOL]         if (c1 != c2) { [EOL]             return (c1 > c2); [EOL]         } [EOL]         s1 = quadrant[i1]; [EOL]         s2 = quadrant[i2]; [EOL]         if (s1 != s2) { [EOL]             return (s1 > s2); [EOL]         } [EOL]         i1++; [EOL]         i2++; [EOL]         if (i1 > last) { [EOL]             i1 -= last; [EOL]             i1--; [EOL]         } [EOL]         if (i2 > last) { [EOL]             i2 -= last; [EOL]             i2--; [EOL]         } [EOL]         k -= 4; [EOL]         workDone++; [EOL]     } while (k >= 0); [EOL]     return false; [EOL] } <line_num>: 1379,1501
private void allocateCompressStructures() { [EOL]     int n = baseBlockSize * blockSize100k; [EOL]     block = new char[(n + 1 + NUM_OVERSHOOT_BYTES)]; [EOL]     quadrant = new int[(n + NUM_OVERSHOOT_BYTES)]; [EOL]     zptr = new int[n]; [EOL]     ftab = new int[65537]; [EOL]     if (block == null || quadrant == null || zptr == null || ftab == null) { [EOL]     } [EOL]     szptr = new short[2 * n]; [EOL] } <line_num>: 1513,1540
private void generateMTFValues() { [EOL]     char[] yy = new char[256]; [EOL]     int i, j; [EOL]     char tmp; [EOL]     char tmp2; [EOL]     int zPend; [EOL]     int wr; [EOL]     int EOB; [EOL]     makeMaps(); [EOL]     EOB = nInUse + 1; [EOL]     for (i = 0; i <= EOB; i++) { [EOL]         mtfFreq[i] = 0; [EOL]     } [EOL]     wr = 0; [EOL]     zPend = 0; [EOL]     for (i = 0; i < nInUse; i++) { [EOL]         yy[i] = (char) i; [EOL]     } [EOL]     for (i = 0; i <= last; i++) { [EOL]         char ll_i; [EOL]         ll_i = unseqToSeq[block[zptr[i]]]; [EOL]         j = 0; [EOL]         tmp = yy[j]; [EOL]         while (ll_i != tmp) { [EOL]             j++; [EOL]             tmp2 = tmp; [EOL]             tmp = yy[j]; [EOL]             yy[j] = tmp2; [EOL]         } [EOL]         yy[0] = tmp; [EOL]         if (j == 0) { [EOL]             zPend++; [EOL]         } else { [EOL]             if (zPend > 0) { [EOL]                 zPend--; [EOL]                 while (true) { [EOL]                     switch(zPend % 2) { [EOL]                         case 0: [EOL]                             szptr[wr] = (short) RUNA; [EOL]                             wr++; [EOL]                             mtfFreq[RUNA]++; [EOL]                             break; [EOL]                         case 1: [EOL]                             szptr[wr] = (short) RUNB; [EOL]                             wr++; [EOL]                             mtfFreq[RUNB]++; [EOL]                             break; [EOL]                     } [EOL]                     if (zPend < 2) { [EOL]                         break; [EOL]                     } [EOL]                     zPend = (zPend - 2) / 2; [EOL]                 } [EOL]                 zPend = 0; [EOL]             } [EOL]             szptr[wr] = (short) (j + 1); [EOL]             wr++; [EOL]             mtfFreq[j + 1]++; [EOL]         } [EOL]     } [EOL]     if (zPend > 0) { [EOL]         zPend--; [EOL]         while (true) { [EOL]             switch(zPend % 2) { [EOL]                 case 0: [EOL]                     szptr[wr] = (short) RUNA; [EOL]                     wr++; [EOL]                     mtfFreq[RUNA]++; [EOL]                     break; [EOL]                 case 1: [EOL]                     szptr[wr] = (short) RUNB; [EOL]                     wr++; [EOL]                     mtfFreq[RUNB]++; [EOL]                     break; [EOL]             } [EOL]             if (zPend < 2) { [EOL]                 break; [EOL]             } [EOL]             zPend = (zPend - 2) / 2; [EOL]         } [EOL]     } [EOL]     szptr[wr] = (short) EOB; [EOL]     wr++; [EOL]     mtfFreq[EOB]++; [EOL]     nMTF = wr; [EOL] } <line_num>: 1542,1638
