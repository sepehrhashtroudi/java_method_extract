public BZip2CompressorInputStream(final InputStream in) throws IOException { [EOL]     super(); [EOL]     this.in = in; [EOL]     init(); [EOL] } <line_num>: 114,119
Data(int blockSize100k) { [EOL]     super(); [EOL]     this.ll8 = new byte[blockSize100k * BZip2Constants.baseBlockSize]; [EOL] } <line_num>: 945,949
public int read() throws IOException { [EOL]     if (this.in != null) { [EOL]         return read0(); [EOL]     } else { [EOL]         throw new IOException("stream closed"); [EOL]     } [EOL] } <line_num>: 126,132
public int read(final byte[] dest, final int offs, final int len) throws IOException { [EOL]     if (offs < 0) { [EOL]         throw new IndexOutOfBoundsException("offs(" + offs + ") < 0."); [EOL]     } [EOL]     if (len < 0) { [EOL]         throw new IndexOutOfBoundsException("len(" + len + ") < 0."); [EOL]     } [EOL]     if (offs + len > dest.length) { [EOL]         throw new IndexOutOfBoundsException("offs(" + offs + ") + len(" + len + ") > dest.length(" + dest.length + ")."); [EOL]     } [EOL]     if (this.in == null) { [EOL]         throw new IOException("stream closed"); [EOL]     } [EOL]     final int hi = offs + len; [EOL]     int destOffs = offs; [EOL]     for (int b; (destOffs < hi) && ((b = read0()) >= 0); ) { [EOL]         dest[destOffs++] = (byte) b; [EOL]     } [EOL]     return (destOffs == offs) ? -1 : (destOffs - offs); [EOL] } <line_num>: 139,162
private void makeMaps() { [EOL]     final boolean[] inUse = this.data.inUse; [EOL]     final byte[] seqToUnseq = this.data.seqToUnseq; [EOL]     int nInUseShadow = 0; [EOL]     for (int i = 0; i < 256; i++) { [EOL]         if (inUse[i]) [EOL]             seqToUnseq[nInUseShadow++] = (byte) i; [EOL]     } [EOL]     this.nInUse = nInUseShadow; [EOL] } <line_num>: 164,176
private int read0() throws IOException { [EOL]     final int retChar = this.currentChar; [EOL]     switch(this.currentState) { [EOL]         case EOF: [EOL]             return -1; [EOL]         case START_BLOCK_STATE: [EOL]             throw new IllegalStateException(); [EOL]         case RAND_PART_A_STATE: [EOL]             throw new IllegalStateException(); [EOL]         case RAND_PART_B_STATE: [EOL]             setupRandPartB(); [EOL]             break; [EOL]         case RAND_PART_C_STATE: [EOL]             setupRandPartC(); [EOL]             break; [EOL]         case NO_RAND_PART_A_STATE: [EOL]             throw new IllegalStateException(); [EOL]         case NO_RAND_PART_B_STATE: [EOL]             setupNoRandPartB(); [EOL]             break; [EOL]         case NO_RAND_PART_C_STATE: [EOL]             setupNoRandPartC(); [EOL]             break; [EOL]         default: [EOL]             throw new IllegalStateException(); [EOL]     } [EOL]     return retChar; [EOL] } <line_num>: 178,215
private void init() throws IOException { [EOL]     if (null == in) { [EOL]         throw new IOException("No InputStream"); [EOL]     } [EOL]     if (in.available() == 0) { [EOL]         throw new IOException("Empty InputStream"); [EOL]     } [EOL]     checkMagicChar('B', "first"); [EOL]     checkMagicChar('Z', "second"); [EOL]     checkMagicChar('h', "third"); [EOL]     int blockSize = this.in.read(); [EOL]     if ((blockSize < '1') || (blockSize > '9')) { [EOL]         throw new IOException("Stream is not BZip2 formatted: illegal " + "blocksize " + (char) blockSize); [EOL]     } [EOL]     this.blockSize100k = blockSize - '0'; [EOL]     initBlock(); [EOL]     setupBlock(); [EOL] } <line_num>: 217,238
private void checkMagicChar(char expected, String position) throws IOException { [EOL]     int magic = this.in.read(); [EOL]     if (magic != expected) { [EOL]         throw new IOException("Stream is not BZip2 formatted: expected '" + expected + "' as " + position + " byte but got '" + (char) magic + "'"); [EOL]     } [EOL] } <line_num>: 240,248
private void initBlock() throws IOException { [EOL]     char magic0 = bsGetUByte(); [EOL]     char magic1 = bsGetUByte(); [EOL]     char magic2 = bsGetUByte(); [EOL]     char magic3 = bsGetUByte(); [EOL]     char magic4 = bsGetUByte(); [EOL]     char magic5 = bsGetUByte(); [EOL]     if (magic0 == 0x17 && magic1 == 0x72 && magic2 == 0x45 && magic3 == 0x38 && magic4 == 0x50 && magic5 == 0x90) { [EOL]         complete(); [EOL]     } else if (magic0 != 0x31 || magic1 != 0x41 || magic2 != 0x59 || magic3 != 0x26 || magic4 != 0x53 || magic5 != 0x59) { [EOL]         this.currentState = EOF; [EOL]         throw new IOException("bad block header"); [EOL]     } else { [EOL]         this.storedBlockCRC = bsGetInt(); [EOL]         this.blockRandomised = bsR(1) == 1; [EOL]         if (this.data == null) { [EOL]             this.data = new Data(this.blockSize100k); [EOL]         } [EOL]         getAndMoveToFrontDecode(); [EOL]         this.crc.initialiseCRC(); [EOL]         this.currentState = START_BLOCK_STATE; [EOL]     } [EOL] } <line_num>: 250,288
private void endBlock() throws IOException { [EOL]     this.computedBlockCRC = this.crc.getFinalCRC(); [EOL]     if (this.storedBlockCRC != this.computedBlockCRC) { [EOL]         this.computedCombinedCRC = (this.storedCombinedCRC << 1) | (this.storedCombinedCRC >>> 31); [EOL]         this.computedCombinedCRC ^= this.storedBlockCRC; [EOL]         throw new IOException("BZip2 CRC error"); [EOL]     } [EOL]     this.computedCombinedCRC = (this.computedCombinedCRC << 1) | (this.computedCombinedCRC >>> 31); [EOL]     this.computedCombinedCRC ^= this.computedBlockCRC; [EOL] } <line_num>: 290,307
private void complete() throws IOException { [EOL]     this.storedCombinedCRC = bsGetInt(); [EOL]     this.currentState = EOF; [EOL]     this.data = null; [EOL]     if (this.storedCombinedCRC != this.computedCombinedCRC) { [EOL]         throw new IOException("BZip2 CRC error"); [EOL]     } [EOL] } <line_num>: 309,317
public void close() throws IOException { [EOL]     InputStream inShadow = this.in; [EOL]     if (inShadow != null) { [EOL]         try { [EOL]             if (inShadow != System.in) { [EOL]                 inShadow.close(); [EOL]             } [EOL]         } finally { [EOL]             this.data = null; [EOL]             this.in = null; [EOL]         } [EOL]     } [EOL] } <line_num>: 319,331
private int bsR(final int n) throws IOException { [EOL]     int bsLiveShadow = this.bsLive; [EOL]     int bsBuffShadow = this.bsBuff; [EOL]     if (bsLiveShadow < n) { [EOL]         final InputStream inShadow = this.in; [EOL]         do { [EOL]             int thech = inShadow.read(); [EOL]             if (thech < 0) { [EOL]                 throw new IOException("unexpected end of stream"); [EOL]             } [EOL]             bsBuffShadow = (bsBuffShadow << 8) | thech; [EOL]             bsLiveShadow += 8; [EOL]         } while (bsLiveShadow < n); [EOL]         this.bsBuff = bsBuffShadow; [EOL]     } [EOL]     this.bsLive = bsLiveShadow - n; [EOL]     return (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1); [EOL] } <line_num>: 333,355
private boolean bsGetBit() throws IOException { [EOL]     int bsLiveShadow = this.bsLive; [EOL]     int bsBuffShadow = this.bsBuff; [EOL]     if (bsLiveShadow < 1) { [EOL]         int thech = this.in.read(); [EOL]         if (thech < 0) { [EOL]             throw new IOException("unexpected end of stream"); [EOL]         } [EOL]         bsBuffShadow = (bsBuffShadow << 8) | thech; [EOL]         bsLiveShadow += 8; [EOL]         this.bsBuff = bsBuffShadow; [EOL]     } [EOL]     this.bsLive = bsLiveShadow - 1; [EOL]     return ((bsBuffShadow >> (bsLiveShadow - 1)) & 1) != 0; [EOL] } <line_num>: 357,375
private char bsGetUByte() throws IOException { [EOL]     return (char) bsR(8); [EOL] } <line_num>: 377,379
private int bsGetInt() throws IOException { [EOL]     return (((((bsR(8) << 8) | bsR(8)) << 8) | bsR(8)) << 8) | bsR(8); [EOL] } <line_num>: 381,383
private static void hbCreateDecodeTables(final int[] limit, final int[] base, final int[] perm, final char[] length, final int minLen, final int maxLen, final int alphaSize) { [EOL]     for (int i = minLen, pp = 0; i <= maxLen; i++) { [EOL]         for (int j = 0; j < alphaSize; j++) { [EOL]             if (length[j] == i) { [EOL]                 perm[pp++] = j; [EOL]             } [EOL]         } [EOL]     } [EOL]     for (int i = MAX_CODE_LEN; --i > 0; ) { [EOL]         base[i] = 0; [EOL]         limit[i] = 0; [EOL]     } [EOL]     for (int i = 0; i < alphaSize; i++) { [EOL]         base[length[i] + 1]++; [EOL]     } [EOL]     for (int i = 1, b = base[0]; i < MAX_CODE_LEN; i++) { [EOL]         b += base[i]; [EOL]         base[i] = b; [EOL]     } [EOL]     for (int i = minLen, vec = 0, b = base[i]; i <= maxLen; i++) { [EOL]         final int nb = base[i + 1]; [EOL]         vec += nb - b; [EOL]         b = nb; [EOL]         limit[i] = vec - 1; [EOL]         vec <<= 1; [EOL]     } [EOL]     for (int i = minLen + 1; i <= maxLen; i++) { [EOL]         base[i] = ((limit[i - 1] + 1) << 1) - base[i]; [EOL]     } [EOL] } <line_num>: 388,424
private void recvDecodingTables() throws IOException { [EOL]     final Data dataShadow = this.data; [EOL]     final boolean[] inUse = dataShadow.inUse; [EOL]     final byte[] pos = dataShadow.recvDecodingTables_pos; [EOL]     final byte[] selector = dataShadow.selector; [EOL]     final byte[] selectorMtf = dataShadow.selectorMtf; [EOL]     int inUse16 = 0; [EOL]     for (int i = 0; i < 16; i++) { [EOL]         if (bsGetBit()) { [EOL]             inUse16 |= 1 << i; [EOL]         } [EOL]     } [EOL]     for (int i = 256; --i >= 0; ) { [EOL]         inUse[i] = false; [EOL]     } [EOL]     for (int i = 0; i < 16; i++) { [EOL]         if ((inUse16 & (1 << i)) != 0) { [EOL]             final int i16 = i << 4; [EOL]             for (int j = 0; j < 16; j++) { [EOL]                 if (bsGetBit()) { [EOL]                     inUse[i16 + j] = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     makeMaps(); [EOL]     final int alphaSize = this.nInUse + 2; [EOL]     final int nGroups = bsR(3); [EOL]     final int nSelectors = bsR(15); [EOL]     for (int i = 0; i < nSelectors; i++) { [EOL]         int j = 0; [EOL]         while (bsGetBit()) { [EOL]             j++; [EOL]         } [EOL]         selectorMtf[i] = (byte) j; [EOL]     } [EOL]     for (int v = nGroups; --v >= 0; ) { [EOL]         pos[v] = (byte) v; [EOL]     } [EOL]     for (int i = 0; i < nSelectors; i++) { [EOL]         int v = selectorMtf[i] & 0xff; [EOL]         final byte tmp = pos[v]; [EOL]         while (v > 0) { [EOL]             pos[v] = pos[v - 1]; [EOL]             v--; [EOL]         } [EOL]         pos[0] = tmp; [EOL]         selector[i] = tmp; [EOL]     } [EOL]     final char[][] len = dataShadow.temp_charArray2d; [EOL]     for (int t = 0; t < nGroups; t++) { [EOL]         int curr = bsR(5); [EOL]         final char[] len_t = len[t]; [EOL]         for (int i = 0; i < alphaSize; i++) { [EOL]             while (bsGetBit()) { [EOL]                 curr += bsGetBit() ? -1 : 1; [EOL]             } [EOL]             len_t[i] = (char) curr; [EOL]         } [EOL]     } [EOL]     createHuffmanDecodingTables(alphaSize, nGroups); [EOL] } <line_num>: 426,505
private void createHuffmanDecodingTables(final int alphaSize, final int nGroups) { [EOL]     final Data dataShadow = this.data; [EOL]     final char[][] len = dataShadow.temp_charArray2d; [EOL]     final int[] minLens = dataShadow.minLens; [EOL]     final int[][] limit = dataShadow.limit; [EOL]     final int[][] base = dataShadow.base; [EOL]     final int[][] perm = dataShadow.perm; [EOL]     for (int t = 0; t < nGroups; t++) { [EOL]         int minLen = 32; [EOL]         int maxLen = 0; [EOL]         final char[] len_t = len[t]; [EOL]         for (int i = alphaSize; --i >= 0; ) { [EOL]             final char lent = len_t[i]; [EOL]             if (lent > maxLen) { [EOL]                 maxLen = lent; [EOL]             } [EOL]             if (lent < minLen) { [EOL]                 minLen = lent; [EOL]             } [EOL]         } [EOL]         hbCreateDecodeTables(limit[t], base[t], perm[t], len[t], minLen, maxLen, alphaSize); [EOL]         minLens[t] = minLen; [EOL]     } [EOL] } <line_num>: 510,536
private void getAndMoveToFrontDecode() throws IOException { [EOL]     this.origPtr = bsR(24); [EOL]     recvDecodingTables(); [EOL]     final InputStream inShadow = this.in; [EOL]     final Data dataShadow = this.data; [EOL]     final byte[] ll8 = dataShadow.ll8; [EOL]     final int[] unzftab = dataShadow.unzftab; [EOL]     final byte[] selector = dataShadow.selector; [EOL]     final byte[] seqToUnseq = dataShadow.seqToUnseq; [EOL]     final char[] yy = dataShadow.getAndMoveToFrontDecode_yy; [EOL]     final int[] minLens = dataShadow.minLens; [EOL]     final int[][] limit = dataShadow.limit; [EOL]     final int[][] base = dataShadow.base; [EOL]     final int[][] perm = dataShadow.perm; [EOL]     final int limitLast = this.blockSize100k * 100000; [EOL]     for (int i = 256; --i >= 0; ) { [EOL]         yy[i] = (char) i; [EOL]         unzftab[i] = 0; [EOL]     } [EOL]     int groupNo = 0; [EOL]     int groupPos = G_SIZE - 1; [EOL]     final int eob = this.nInUse + 1; [EOL]     int nextSym = getAndMoveToFrontDecode0(0); [EOL]     int bsBuffShadow = this.bsBuff; [EOL]     int bsLiveShadow = this.bsLive; [EOL]     int lastShadow = -1; [EOL]     int zt = selector[groupNo] & 0xff; [EOL]     int[] base_zt = base[zt]; [EOL]     int[] limit_zt = limit[zt]; [EOL]     int[] perm_zt = perm[zt]; [EOL]     int minLens_zt = minLens[zt]; [EOL]     while (nextSym != eob) { [EOL]         if ((nextSym == RUNA) || (nextSym == RUNB)) { [EOL]             int s = -1; [EOL]             for (int n = 1; true; n <<= 1) { [EOL]                 if (nextSym == RUNA) { [EOL]                     s += n; [EOL]                 } else if (nextSym == RUNB) { [EOL]                     s += n << 1; [EOL]                 } else { [EOL]                     break; [EOL]                 } [EOL]                 if (groupPos == 0) { [EOL]                     groupPos = G_SIZE - 1; [EOL]                     zt = selector[++groupNo] & 0xff; [EOL]                     base_zt = base[zt]; [EOL]                     limit_zt = limit[zt]; [EOL]                     perm_zt = perm[zt]; [EOL]                     minLens_zt = minLens[zt]; [EOL]                 } else { [EOL]                     groupPos--; [EOL]                 } [EOL]                 int zn = minLens_zt; [EOL]                 while (bsLiveShadow < zn) { [EOL]                     final int thech = inShadow.read(); [EOL]                     if (thech >= 0) { [EOL]                         bsBuffShadow = (bsBuffShadow << 8) | thech; [EOL]                         bsLiveShadow += 8; [EOL]                         continue; [EOL]                     } else { [EOL]                         throw new IOException("unexpected end of stream"); [EOL]                     } [EOL]                 } [EOL]                 int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); [EOL]                 bsLiveShadow -= zn; [EOL]                 while (zvec > limit_zt[zn]) { [EOL]                     zn++; [EOL]                     while (bsLiveShadow < 1) { [EOL]                         final int thech = inShadow.read(); [EOL]                         if (thech >= 0) { [EOL]                             bsBuffShadow = (bsBuffShadow << 8) | thech; [EOL]                             bsLiveShadow += 8; [EOL]                             continue; [EOL]                         } else { [EOL]                             throw new IOException("unexpected end of stream"); [EOL]                         } [EOL]                     } [EOL]                     bsLiveShadow--; [EOL]                     zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); [EOL]                 } [EOL]                 nextSym = perm_zt[zvec - base_zt[zn]]; [EOL]             } [EOL]             final byte ch = seqToUnseq[yy[0]]; [EOL]             unzftab[ch & 0xff] += s + 1; [EOL]             while (s-- >= 0) { [EOL]                 ll8[++lastShadow] = ch; [EOL]             } [EOL]             if (lastShadow >= limitLast) { [EOL]                 throw new IOException("block overrun"); [EOL]             } [EOL]         } else { [EOL]             if (++lastShadow >= limitLast) { [EOL]                 throw new IOException("block overrun"); [EOL]             } [EOL]             final char tmp = yy[nextSym - 1]; [EOL]             unzftab[seqToUnseq[tmp] & 0xff]++; [EOL]             ll8[lastShadow] = seqToUnseq[tmp]; [EOL]             if (nextSym <= 16) { [EOL]                 for (int j = nextSym - 1; j > 0; ) { [EOL]                     yy[j] = yy[--j]; [EOL]                 } [EOL]             } else { [EOL]                 System.arraycopy(yy, 0, yy, 1, nextSym - 1); [EOL]             } [EOL]             yy[0] = tmp; [EOL]             if (groupPos == 0) { [EOL]                 groupPos = G_SIZE - 1; [EOL]                 zt = selector[++groupNo] & 0xff; [EOL]                 base_zt = base[zt]; [EOL]                 limit_zt = limit[zt]; [EOL]                 perm_zt = perm[zt]; [EOL]                 minLens_zt = minLens[zt]; [EOL]             } else { [EOL]                 groupPos--; [EOL]             } [EOL]             int zn = minLens_zt; [EOL]             while (bsLiveShadow < zn) { [EOL]                 final int thech = inShadow.read(); [EOL]                 if (thech >= 0) { [EOL]                     bsBuffShadow = (bsBuffShadow << 8) | thech; [EOL]                     bsLiveShadow += 8; [EOL]                     continue; [EOL]                 } else { [EOL]                     throw new IOException("unexpected end of stream"); [EOL]                 } [EOL]             } [EOL]             int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); [EOL]             bsLiveShadow -= zn; [EOL]             while (zvec > limit_zt[zn]) { [EOL]                 zn++; [EOL]                 while (bsLiveShadow < 1) { [EOL]                     final int thech = inShadow.read(); [EOL]                     if (thech >= 0) { [EOL]                         bsBuffShadow = (bsBuffShadow << 8) | thech; [EOL]                         bsLiveShadow += 8; [EOL]                         continue; [EOL]                     } else { [EOL]                         throw new IOException("unexpected end of stream"); [EOL]                     } [EOL]                 } [EOL]                 bsLiveShadow--; [EOL]                 zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); [EOL]             } [EOL]             nextSym = perm_zt[zvec - base_zt[zn]]; [EOL]         } [EOL]     } [EOL]     this.last = lastShadow; [EOL]     this.bsLive = bsLiveShadow; [EOL]     this.bsBuff = bsBuffShadow; [EOL] } <line_num>: 538,725
private int getAndMoveToFrontDecode0(final int groupNo) throws IOException { [EOL]     final InputStream inShadow = this.in; [EOL]     final Data dataShadow = this.data; [EOL]     final int zt = dataShadow.selector[groupNo] & 0xff; [EOL]     final int[] limit_zt = dataShadow.limit[zt]; [EOL]     int zn = dataShadow.minLens[zt]; [EOL]     int zvec = bsR(zn); [EOL]     int bsLiveShadow = this.bsLive; [EOL]     int bsBuffShadow = this.bsBuff; [EOL]     while (zvec > limit_zt[zn]) { [EOL]         zn++; [EOL]         while (bsLiveShadow < 1) { [EOL]             final int thech = inShadow.read(); [EOL]             if (thech >= 0) { [EOL]                 bsBuffShadow = (bsBuffShadow << 8) | thech; [EOL]                 bsLiveShadow += 8; [EOL]                 continue; [EOL]             } else { [EOL]                 throw new IOException("unexpected end of stream"); [EOL]             } [EOL]         } [EOL]         bsLiveShadow--; [EOL]         zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); [EOL]     } [EOL]     this.bsLive = bsLiveShadow; [EOL]     this.bsBuff = bsBuffShadow; [EOL]     return dataShadow.perm[zt][zvec - dataShadow.base[zt][zn]]; [EOL] } <line_num>: 727,758
private void setupBlock() throws IOException { [EOL]     if (this.data == null) { [EOL]         return; [EOL]     } [EOL]     final int[] cftab = this.data.cftab; [EOL]     final int[] tt = this.data.initTT(this.last + 1); [EOL]     final byte[] ll8 = this.data.ll8; [EOL]     cftab[0] = 0; [EOL]     System.arraycopy(this.data.unzftab, 0, cftab, 1, 256); [EOL]     for (int i = 1, c = cftab[0]; i <= 256; i++) { [EOL]         c += cftab[i]; [EOL]         cftab[i] = c; [EOL]     } [EOL]     for (int i = 0, lastShadow = this.last; i <= lastShadow; i++) { [EOL]         tt[cftab[ll8[i] & 0xff]++] = i; [EOL]     } [EOL]     if ((this.origPtr < 0) || (this.origPtr >= tt.length)) { [EOL]         throw new IOException("stream corrupted"); [EOL]     } [EOL]     this.su_tPos = tt[this.origPtr]; [EOL]     this.su_count = 0; [EOL]     this.su_i2 = 0; [EOL]     this.su_ch2 = 256; [EOL]     if (this.blockRandomised) { [EOL]         this.su_rNToGo = 0; [EOL]         this.su_rTPos = 0; [EOL]         setupRandPartA(); [EOL]     } else { [EOL]         setupNoRandPartA(); [EOL]     } [EOL] } <line_num>: 760,796
private void setupRandPartA() throws IOException { [EOL]     if (this.su_i2 <= this.last) { [EOL]         this.su_chPrev = this.su_ch2; [EOL]         int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff; [EOL]         this.su_tPos = this.data.tt[this.su_tPos]; [EOL]         if (this.su_rNToGo == 0) { [EOL]             this.su_rNToGo = BZip2Constants.rNums[this.su_rTPos] - 1; [EOL]             if (++this.su_rTPos == 512) { [EOL]                 this.su_rTPos = 0; [EOL]             } [EOL]         } else { [EOL]             this.su_rNToGo--; [EOL]         } [EOL]         this.su_ch2 = su_ch2Shadow ^= (this.su_rNToGo == 1) ? 1 : 0; [EOL]         this.su_i2++; [EOL]         this.currentChar = su_ch2Shadow; [EOL]         this.currentState = RAND_PART_B_STATE; [EOL]         this.crc.updateCRC(su_ch2Shadow); [EOL]     } else { [EOL]         endBlock(); [EOL]         initBlock(); [EOL]         setupBlock(); [EOL]     } [EOL] } <line_num>: 798,821
private void setupNoRandPartA() throws IOException { [EOL]     if (this.su_i2 <= this.last) { [EOL]         this.su_chPrev = this.su_ch2; [EOL]         int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff; [EOL]         this.su_ch2 = su_ch2Shadow; [EOL]         this.su_tPos = this.data.tt[this.su_tPos]; [EOL]         this.su_i2++; [EOL]         this.currentChar = su_ch2Shadow; [EOL]         this.currentState = NO_RAND_PART_B_STATE; [EOL]         this.crc.updateCRC(su_ch2Shadow); [EOL]     } else { [EOL]         this.currentState = NO_RAND_PART_A_STATE; [EOL]         endBlock(); [EOL]         initBlock(); [EOL]         setupBlock(); [EOL]     } [EOL] } <line_num>: 823,839
private void setupRandPartB() throws IOException { [EOL]     if (this.su_ch2 != this.su_chPrev) { [EOL]         this.currentState = RAND_PART_A_STATE; [EOL]         this.su_count = 1; [EOL]         setupRandPartA(); [EOL]     } else if (++this.su_count >= 4) { [EOL]         this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff); [EOL]         this.su_tPos = this.data.tt[this.su_tPos]; [EOL]         if (this.su_rNToGo == 0) { [EOL]             this.su_rNToGo = BZip2Constants.rNums[this.su_rTPos] - 1; [EOL]             if (++this.su_rTPos == 512) { [EOL]                 this.su_rTPos = 0; [EOL]             } [EOL]         } else { [EOL]             this.su_rNToGo--; [EOL]         } [EOL]         this.su_j2 = 0; [EOL]         this.currentState = RAND_PART_C_STATE; [EOL]         if (this.su_rNToGo == 1) { [EOL]             this.su_z ^= 1; [EOL]         } [EOL]         setupRandPartC(); [EOL]     } else { [EOL]         this.currentState = RAND_PART_A_STATE; [EOL]         setupRandPartA(); [EOL]     } [EOL] } <line_num>: 841,867
private void setupRandPartC() throws IOException { [EOL]     if (this.su_j2 < this.su_z) { [EOL]         this.currentChar = this.su_ch2; [EOL]         this.crc.updateCRC(this.su_ch2); [EOL]         this.su_j2++; [EOL]     } else { [EOL]         this.currentState = RAND_PART_A_STATE; [EOL]         this.su_i2++; [EOL]         this.su_count = 0; [EOL]         setupRandPartA(); [EOL]     } [EOL] } <line_num>: 869,880
private void setupNoRandPartB() throws IOException { [EOL]     if (this.su_ch2 != this.su_chPrev) { [EOL]         this.su_count = 1; [EOL]         setupNoRandPartA(); [EOL]     } else if (++this.su_count >= 4) { [EOL]         this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff); [EOL]         this.su_tPos = this.data.tt[this.su_tPos]; [EOL]         this.su_j2 = 0; [EOL]         setupNoRandPartC(); [EOL]     } else { [EOL]         setupNoRandPartA(); [EOL]     } [EOL] } <line_num>: 882,894
private void setupNoRandPartC() throws IOException { [EOL]     if (this.su_j2 < this.su_z) { [EOL]         int su_ch2Shadow = this.su_ch2; [EOL]         this.currentChar = su_ch2Shadow; [EOL]         this.crc.updateCRC(su_ch2Shadow); [EOL]         this.su_j2++; [EOL]         this.currentState = NO_RAND_PART_C_STATE; [EOL]     } else { [EOL]         this.su_i2++; [EOL]         this.su_count = 0; [EOL]         setupNoRandPartA(); [EOL]     } [EOL] } <line_num>: 896,908
final int[] initTT(int length) { [EOL]     int[] ttShadow = this.tt; [EOL]     if ((ttShadow == null) || (ttShadow.length < length)) { [EOL]         this.tt = ttShadow = new int[length]; [EOL]     } [EOL]     return ttShadow; [EOL] } <line_num>: 958,970
