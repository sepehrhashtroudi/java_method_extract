public static double[] getOLSRegression(double[][] data) { [EOL]     int n = data.length; [EOL]     if (n < 2) { [EOL]         throw new IllegalArgumentException("Not enough data."); [EOL]     } [EOL]     double sumX = 0; [EOL]     double sumY = 0; [EOL]     double sumXX = 0; [EOL]     double sumXY = 0; [EOL]     for (int i = 0; i < n; i++) { [EOL]         double x = data[i][0]; [EOL]         double y = data[i][1]; [EOL]         sumX += x; [EOL]         sumY += y; [EOL]         double xx = x * x; [EOL]         sumXX += xx; [EOL]         double xy = x * y; [EOL]         sumXY += xy; [EOL]     } [EOL]     double sxx = sumXX - (sumX * sumX) / n; [EOL]     double sxy = sumXY - (sumX * sumY) / n; [EOL]     double xbar = sumX / n; [EOL]     double ybar = sumY / n; [EOL]     double[] result = new double[2]; [EOL]     result[1] = sxy / sxx; [EOL]     result[0] = ybar - result[1] * xbar; [EOL]     return result; [EOL] } <line_num>: 64,96
public static double[] getOLSRegression(XYDataset data, int series) { [EOL]     int n = data.getItemCount(series); [EOL]     if (n < 2) { [EOL]         throw new IllegalArgumentException("Not enough data."); [EOL]     } [EOL]     double sumX = 0; [EOL]     double sumY = 0; [EOL]     double sumXX = 0; [EOL]     double sumXY = 0; [EOL]     for (int i = 0; i < n; i++) { [EOL]         double x = data.getXValue(series, i); [EOL]         double y = data.getYValue(series, i); [EOL]         sumX += x; [EOL]         sumY += y; [EOL]         double xx = x * x; [EOL]         sumXX += xx; [EOL]         double xy = x * y; [EOL]         sumXY += xy; [EOL]     } [EOL]     double sxx = sumXX - (sumX * sumX) / n; [EOL]     double sxy = sumXY - (sumX * sumY) / n; [EOL]     double xbar = sumX / n; [EOL]     double ybar = sumY / n; [EOL]     double[] result = new double[2]; [EOL]     result[1] = sxy / sxx; [EOL]     result[0] = ybar - result[1] * xbar; [EOL]     return result; [EOL] } <line_num>: 108,140
public static double[] getPowerRegression(double[][] data) { [EOL]     int n = data.length; [EOL]     if (n < 2) { [EOL]         throw new IllegalArgumentException("Not enough data."); [EOL]     } [EOL]     double sumX = 0; [EOL]     double sumY = 0; [EOL]     double sumXX = 0; [EOL]     double sumXY = 0; [EOL]     for (int i = 0; i < n; i++) { [EOL]         double x = Math.log(data[i][0]); [EOL]         double y = Math.log(data[i][1]); [EOL]         sumX += x; [EOL]         sumY += y; [EOL]         double xx = x * x; [EOL]         sumXX += xx; [EOL]         double xy = x * y; [EOL]         sumXY += xy; [EOL]     } [EOL]     double sxx = sumXX - (sumX * sumX) / n; [EOL]     double sxy = sumXY - (sumX * sumY) / n; [EOL]     double xbar = sumX / n; [EOL]     double ybar = sumY / n; [EOL]     double[] result = new double[2]; [EOL]     result[1] = sxy / sxx; [EOL]     result[0] = Math.pow(Math.exp(1.0), ybar - result[1] * xbar); [EOL]     return result; [EOL] } <line_num>: 151,183
public static double[] getPowerRegression(XYDataset data, int series) { [EOL]     int n = data.getItemCount(series); [EOL]     if (n < 2) { [EOL]         throw new IllegalArgumentException("Not enough data."); [EOL]     } [EOL]     double sumX = 0; [EOL]     double sumY = 0; [EOL]     double sumXX = 0; [EOL]     double sumXY = 0; [EOL]     for (int i = 0; i < n; i++) { [EOL]         double x = Math.log(data.getXValue(series, i)); [EOL]         double y = Math.log(data.getYValue(series, i)); [EOL]         sumX += x; [EOL]         sumY += y; [EOL]         double xx = x * x; [EOL]         sumXX += xx; [EOL]         double xy = x * y; [EOL]         sumXY += xy; [EOL]     } [EOL]     double sxx = sumXX - (sumX * sumX) / n; [EOL]     double sxy = sumXY - (sumX * sumY) / n; [EOL]     double xbar = sumX / n; [EOL]     double ybar = sumY / n; [EOL]     double[] result = new double[2]; [EOL]     result[1] = sxy / sxx; [EOL]     result[0] = Math.pow(Math.exp(1.0), ybar - result[1] * xbar); [EOL]     return result; [EOL] } <line_num>: 195,227
public static double[] getPolynomialRegression(XYDataset dataset, int series, int order) { [EOL]     if (dataset == null) { [EOL]         throw new IllegalArgumentException("Null 'dataset' argument."); [EOL]     } [EOL]     int itemCount = dataset.getItemCount(series); [EOL]     if (itemCount < order + 1) { [EOL]         throw new IllegalArgumentException("Not enough data."); [EOL]     } [EOL]     int validItems = 0; [EOL]     double[][] data = new double[2][itemCount]; [EOL]     for (int item = 0; item < itemCount; item++) { [EOL]         double x = dataset.getXValue(series, item); [EOL]         double y = dataset.getYValue(series, item); [EOL]         if (!Double.isNaN(x) && !Double.isNaN(y)) { [EOL]             data[0][validItems] = x; [EOL]             data[1][validItems] = y; [EOL]             validItems++; [EOL]         } [EOL]     } [EOL]     if (validItems < order + 1) { [EOL]         throw new IllegalArgumentException("Not enough data."); [EOL]     } [EOL]     int equations = order + 1; [EOL]     int coefficients = order + 2; [EOL]     double[] result = new double[equations + 1]; [EOL]     double[][] matrix = new double[equations][coefficients]; [EOL]     double sumX = 0.0; [EOL]     double sumY = 0.0; [EOL]     for (int item = 0; item < validItems; item++) { [EOL]         sumX += data[0][item]; [EOL]         sumY += data[1][item]; [EOL]         for (int eq = 0; eq < equations; eq++) { [EOL]             for (int coe = 0; coe < coefficients - 1; coe++) { [EOL]                 matrix[eq][coe] += Math.pow(data[0][item], eq + coe); [EOL]             } [EOL]             matrix[eq][coefficients - 1] += data[1][item] * Math.pow(data[0][item], eq); [EOL]         } [EOL]     } [EOL]     double[][] subMatrix = calculateSubMatrix(matrix); [EOL]     for (int eq = 1; eq < equations; eq++) { [EOL]         matrix[eq][0] = 0; [EOL]         for (int coe = 1; coe < coefficients; coe++) { [EOL]             matrix[eq][coe] = subMatrix[eq - 1][coe - 1]; [EOL]         } [EOL]     } [EOL]     for (int eq = equations - 1; eq > -1; eq--) { [EOL]         double value = matrix[eq][coefficients - 1]; [EOL]         for (int coe = eq; coe < coefficients - 1; coe++) { [EOL]             value -= matrix[eq][coe] * result[coe]; [EOL]         } [EOL]         result[eq] = value / matrix[eq][eq]; [EOL]     } [EOL]     double meanY = sumY / validItems; [EOL]     double yObsSquare = 0.0; [EOL]     double yRegSquare = 0.0; [EOL]     for (int item = 0; item < validItems; item++) { [EOL]         double yCalc = 0; [EOL]         for (int eq = 0; eq < equations; eq++) { [EOL]             yCalc += result[eq] * Math.pow(data[0][item], eq); [EOL]         } [EOL]         yRegSquare += Math.pow(yCalc - meanY, 2); [EOL]         yObsSquare += Math.pow(data[1][item] - meanY, 2); [EOL]     } [EOL]     double rSquare = yRegSquare / yObsSquare; [EOL]     result[equations] = rSquare; [EOL]     return result; [EOL] } <line_num>: 248,316
private static double[][] calculateSubMatrix(double[][] matrix) { [EOL]     int equations = matrix.length; [EOL]     int coefficients = matrix[0].length; [EOL]     double[][] result = new double[equations - 1][coefficients - 1]; [EOL]     for (int eq = 1; eq < equations; eq++) { [EOL]         double factor = matrix[0][0] / matrix[eq][0]; [EOL]         for (int coe = 1; coe < coefficients; coe++) { [EOL]             result[eq - 1][coe - 1] = matrix[0][coe] - matrix[eq][coe] * factor; [EOL]         } [EOL]     } [EOL]     if (equations == 1) { [EOL]         return result; [EOL]     } [EOL]     if (result[0][0] == 0) { [EOL]         boolean found = false; [EOL]         for (int i = 0; i < result.length; i++) { [EOL]             if (result[i][0] != 0) { [EOL]                 found = true; [EOL]                 double[] temp = result[0]; [EOL]                 for (int j = 0; j < result[i].length; j++) { [EOL]                     result[0][j] = result[i][j]; [EOL]                 } [EOL]                 for (int j = 0; j < temp.length; j++) { [EOL]                     result[i][j] = temp[j]; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (!found) { [EOL]             System.out.println("Equation has no solution!"); [EOL]             return new double[equations - 1][coefficients - 1]; [EOL]         } [EOL]     } [EOL]     double[][] subMatrix = calculateSubMatrix(result); [EOL]     for (int eq = 1; eq < equations - 1; eq++) { [EOL]         result[eq][0] = 0; [EOL]         for (int coe = 1; coe < coefficients - 1; coe++) { [EOL]             result[eq][coe] = subMatrix[eq - 1][coe - 1]; [EOL]         } [EOL]     } [EOL]     return result; [EOL] } <line_num>: 328,371
