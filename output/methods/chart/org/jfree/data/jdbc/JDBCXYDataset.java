private JDBCXYDataset() { [EOL]     this.rows = new ArrayList(); [EOL] } <line_num>: 126,128
public JDBCXYDataset(String url, String driverName, String user, String password) throws SQLException, ClassNotFoundException { [EOL]     this(); [EOL]     Class.forName(driverName); [EOL]     this.connection = DriverManager.getConnection(url, user, password); [EOL] } <line_num>: 142,151
public JDBCXYDataset(Connection con) throws SQLException { [EOL]     this(); [EOL]     this.connection = con; [EOL] } <line_num>: 161,164
public JDBCXYDataset(Connection con, String query) throws SQLException { [EOL]     this(con); [EOL]     executeQuery(query); [EOL] } <line_num>: 175,178
public boolean isTimeSeries() { [EOL]     return this.isTimeSeries; [EOL] } <line_num>: 186,188
public void setTimeSeries(boolean timeSeries) { [EOL]     this.isTimeSeries = timeSeries; [EOL] } <line_num>: 196,198
public void executeQuery(String query) throws SQLException { [EOL]     executeQuery(this.connection, query); [EOL] } <line_num>: 212,214
public void executeQuery(Connection con, String query) throws SQLException { [EOL]     if (con == null) { [EOL]         throw new SQLException("There is no database to execute the query."); [EOL]     } [EOL]     ResultSet resultSet = null; [EOL]     Statement statement = null; [EOL]     try { [EOL]         statement = con.createStatement(); [EOL]         resultSet = statement.executeQuery(query); [EOL]         ResultSetMetaData metaData = resultSet.getMetaData(); [EOL]         int numberOfColumns = metaData.getColumnCount(); [EOL]         int numberOfValidColumns = 0; [EOL]         int[] columnTypes = new int[numberOfColumns]; [EOL]         for (int column = 0; column < numberOfColumns; column++) { [EOL]             try { [EOL]                 int type = metaData.getColumnType(column + 1); [EOL]                 switch(type) { [EOL]                     case Types.NUMERIC: [EOL]                     case Types.REAL: [EOL]                     case Types.INTEGER: [EOL]                     case Types.DOUBLE: [EOL]                     case Types.FLOAT: [EOL]                     case Types.DECIMAL: [EOL]                     case Types.BIT: [EOL]                     case Types.DATE: [EOL]                     case Types.TIME: [EOL]                     case Types.TIMESTAMP: [EOL]                     case Types.BIGINT: [EOL]                     case Types.SMALLINT: [EOL]                         ++numberOfValidColumns; [EOL]                         columnTypes[column] = type; [EOL]                         break; [EOL]                     default: [EOL]                         columnTypes[column] = Types.NULL; [EOL]                         break; [EOL]                 } [EOL]             } catch (SQLException e) { [EOL]                 columnTypes[column] = Types.NULL; [EOL]                 throw e; [EOL]             } [EOL]         } [EOL]         if (numberOfValidColumns <= 1) { [EOL]             throw new SQLException("Not enough valid columns where generated by query."); [EOL]         } [EOL]         this.columnNames = new String[numberOfValidColumns - 1]; [EOL]         int currentColumn = 0; [EOL]         for (int column = 1; column < numberOfColumns; column++) { [EOL]             if (columnTypes[column] != Types.NULL) { [EOL]                 this.columnNames[currentColumn] = metaData.getColumnLabel(column + 1); [EOL]                 ++currentColumn; [EOL]             } [EOL]         } [EOL]         if (this.rows != null) { [EOL]             for (int column = 0; column < this.rows.size(); column++) { [EOL]                 ArrayList row = (ArrayList) this.rows.get(column); [EOL]                 row.clear(); [EOL]             } [EOL]             this.rows.clear(); [EOL]         } [EOL]         switch(columnTypes[0]) { [EOL]             case Types.DATE: [EOL]             case Types.TIME: [EOL]             case Types.TIMESTAMP: [EOL]                 this.isTimeSeries = true; [EOL]                 break; [EOL]             default: [EOL]                 this.isTimeSeries = false; [EOL]                 break; [EOL]         } [EOL]         while (resultSet.next()) { [EOL]             ArrayList newRow = new ArrayList(); [EOL]             for (int column = 0; column < numberOfColumns; column++) { [EOL]                 Object xObject = resultSet.getObject(column + 1); [EOL]                 switch(columnTypes[column]) { [EOL]                     case Types.NUMERIC: [EOL]                     case Types.REAL: [EOL]                     case Types.INTEGER: [EOL]                     case Types.DOUBLE: [EOL]                     case Types.FLOAT: [EOL]                     case Types.DECIMAL: [EOL]                     case Types.BIGINT: [EOL]                     case Types.SMALLINT: [EOL]                         newRow.add(xObject); [EOL]                         break; [EOL]                     case Types.DATE: [EOL]                     case Types.TIME: [EOL]                     case Types.TIMESTAMP: [EOL]                         newRow.add(new Long(((Date) xObject).getTime())); [EOL]                         break; [EOL]                     case Types.NULL: [EOL]                         break; [EOL]                     default: [EOL]                         System.err.println("Unknown data"); [EOL]                         columnTypes[column] = Types.NULL; [EOL]                         break; [EOL]                 } [EOL]             } [EOL]             this.rows.add(newRow); [EOL]         } [EOL]         if (this.rows.size() == 0) { [EOL]             ArrayList newRow = new ArrayList(); [EOL]             for (int column = 0; column < numberOfColumns; column++) { [EOL]                 if (columnTypes[column] != Types.NULL) { [EOL]                     newRow.add(new Integer(0)); [EOL]                 } [EOL]             } [EOL]             this.rows.add(newRow); [EOL]         } [EOL]         if (this.rows.size() < 1) { [EOL]             this.maxValue = 0.0; [EOL]             this.minValue = 0.0; [EOL]         } else { [EOL]             ArrayList row = (ArrayList) this.rows.get(0); [EOL]             this.maxValue = Double.NEGATIVE_INFINITY; [EOL]             this.minValue = Double.POSITIVE_INFINITY; [EOL]             for (int rowNum = 0; rowNum < this.rows.size(); ++rowNum) { [EOL]                 row = (ArrayList) this.rows.get(rowNum); [EOL]                 for (int column = 1; column < numberOfColumns; column++) { [EOL]                     Object testValue = row.get(column); [EOL]                     if (testValue != null) { [EOL]                         double test = ((Number) testValue).doubleValue(); [EOL]                         if (test < this.minValue) { [EOL]                             this.minValue = test; [EOL]                         } [EOL]                         if (test > this.maxValue) { [EOL]                             this.maxValue = test; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         fireDatasetChanged(new DatasetChangeInfo()); [EOL]     } finally { [EOL]         if (resultSet != null) { [EOL]             try { [EOL]                 resultSet.close(); [EOL]             } catch (Exception e) { [EOL]             } [EOL]         } [EOL]         if (statement != null) { [EOL]             try { [EOL]                 statement.close(); [EOL]             } catch (Exception e) { [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 229,413
public Number getX(int seriesIndex, int itemIndex) { [EOL]     ArrayList row = (ArrayList) this.rows.get(itemIndex); [EOL]     return (Number) row.get(0); [EOL] } <line_num>: 427,430
public Number getY(int seriesIndex, int itemIndex) { [EOL]     ArrayList row = (ArrayList) this.rows.get(itemIndex); [EOL]     return (Number) row.get(seriesIndex + 1); [EOL] } <line_num>: 442,445
public int getItemCount(int seriesIndex) { [EOL]     return this.rows.size(); [EOL] } <line_num>: 456,458
public int getItemCount() { [EOL]     return getItemCount(0); [EOL] } <line_num>: 466,468
public int getSeriesCount() { [EOL]     return this.columnNames.length; [EOL] } <line_num>: 478,480
public Comparable getSeriesKey(int seriesIndex) { [EOL]     if ((seriesIndex < this.columnNames.length) && (this.columnNames[seriesIndex] != null)) { [EOL]         return this.columnNames[seriesIndex]; [EOL]     } else { [EOL]         return ""; [EOL]     } [EOL] } <line_num>: 492,502
public void close() { [EOL]     try { [EOL]         this.connection.close(); [EOL]     } catch (Exception e) { [EOL]         System.err.println("JdbcXYDataset: swallowing exception."); [EOL]     } [EOL] } <line_num>: 507,516
public double getRangeLowerBound(boolean includeInterval) { [EOL]     return this.minValue; [EOL] } <line_num>: 526,528
public double getRangeUpperBound(boolean includeInterval) { [EOL]     return this.maxValue; [EOL] } <line_num>: 538,540
public Range getRangeBounds(boolean includeInterval) { [EOL]     return new Range(this.minValue, this.maxValue); [EOL] } <line_num>: 550,552
