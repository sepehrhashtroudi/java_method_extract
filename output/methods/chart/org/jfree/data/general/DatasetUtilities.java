private DatasetUtilities() { [EOL] } <line_num>: 167,169
public static double calculatePieDatasetTotal(PieDataset dataset) { [EOL]     if (dataset == null) { [EOL]         throw new IllegalArgumentException("Null 'dataset' argument."); [EOL]     } [EOL]     List keys = dataset.getKeys(); [EOL]     double totalValue = 0; [EOL]     Iterator iterator = keys.iterator(); [EOL]     while (iterator.hasNext()) { [EOL]         Comparable current = (Comparable) iterator.next(); [EOL]         if (current != null) { [EOL]             Number value = dataset.getValue(current); [EOL]             double v = 0.0; [EOL]             if (value != null) { [EOL]                 v = value.doubleValue(); [EOL]             } [EOL]             if (v > 0) { [EOL]                 totalValue = totalValue + v; [EOL]             } [EOL]         } [EOL]     } [EOL]     return totalValue; [EOL] } <line_num>: 180,201
public static PieDataset createPieDatasetForRow(CategoryDataset dataset, Comparable rowKey) { [EOL]     int row = dataset.getRowIndex(rowKey); [EOL]     return createPieDatasetForRow(dataset, row); [EOL] } <line_num>: 212,216
public static PieDataset createPieDatasetForRow(CategoryDataset dataset, int row) { [EOL]     DefaultPieDataset result = new DefaultPieDataset(); [EOL]     int columnCount = dataset.getColumnCount(); [EOL]     for (int current = 0; current < columnCount; current++) { [EOL]         Comparable columnKey = dataset.getColumnKey(current); [EOL]         result.setValue(columnKey, dataset.getValue(row, current)); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 227,236
public static PieDataset createPieDatasetForColumn(CategoryDataset dataset, Comparable columnKey) { [EOL]     int column = dataset.getColumnIndex(columnKey); [EOL]     return createPieDatasetForColumn(dataset, column); [EOL] } <line_num>: 247,251
public static PieDataset createPieDatasetForColumn(CategoryDataset dataset, int column) { [EOL]     DefaultPieDataset result = new DefaultPieDataset(); [EOL]     int rowCount = dataset.getRowCount(); [EOL]     for (int i = 0; i < rowCount; i++) { [EOL]         Comparable rowKey = dataset.getRowKey(i); [EOL]         result.setValue(rowKey, dataset.getValue(i, column)); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 262,271
public static PieDataset createConsolidatedPieDataset(PieDataset source, Comparable key, double minimumPercent) { [EOL]     return DatasetUtilities.createConsolidatedPieDataset(source, key, minimumPercent, 2); [EOL] } <line_num>: 286,290
public static PieDataset createConsolidatedPieDataset(PieDataset source, Comparable key, double minimumPercent, int minItems) { [EOL]     DefaultPieDataset result = new DefaultPieDataset(); [EOL]     double total = DatasetUtilities.calculatePieDatasetTotal(source); [EOL]     List keys = source.getKeys(); [EOL]     ArrayList otherKeys = new ArrayList(); [EOL]     Iterator iterator = keys.iterator(); [EOL]     while (iterator.hasNext()) { [EOL]         Comparable currentKey = (Comparable) iterator.next(); [EOL]         Number dataValue = source.getValue(currentKey); [EOL]         if (dataValue != null) { [EOL]             double value = dataValue.doubleValue(); [EOL]             if (value / total < minimumPercent) { [EOL]                 otherKeys.add(currentKey); [EOL]             } [EOL]         } [EOL]     } [EOL]     iterator = keys.iterator(); [EOL]     double otherValue = 0; [EOL]     while (iterator.hasNext()) { [EOL]         Comparable currentKey = (Comparable) iterator.next(); [EOL]         Number dataValue = source.getValue(currentKey); [EOL]         if (dataValue != null) { [EOL]             if (otherKeys.contains(currentKey) && otherKeys.size() >= minItems) { [EOL]                 otherValue += dataValue.doubleValue(); [EOL]             } else { [EOL]                 result.setValue(currentKey, dataValue); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (otherKeys.size() >= minItems) { [EOL]         result.setValue(key, otherValue); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 307,351
public static CategoryDataset createCategoryDataset(String rowKeyPrefix, String columnKeyPrefix, double[][] data) { [EOL]     DefaultCategoryDataset result = new DefaultCategoryDataset(); [EOL]     for (int r = 0; r < data.length; r++) { [EOL]         String rowKey = rowKeyPrefix + (r + 1); [EOL]         for (int c = 0; c < data[r].length; c++) { [EOL]             String columnKey = columnKeyPrefix + (c + 1); [EOL]             result.addValue(new Double(data[r][c]), rowKey, columnKey); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } <line_num>: 367,380
public static CategoryDataset createCategoryDataset(String rowKeyPrefix, String columnKeyPrefix, Number[][] data) { [EOL]     DefaultCategoryDataset result = new DefaultCategoryDataset(); [EOL]     for (int r = 0; r < data.length; r++) { [EOL]         String rowKey = rowKeyPrefix + (r + 1); [EOL]         for (int c = 0; c < data[r].length; c++) { [EOL]             String columnKey = columnKeyPrefix + (c + 1); [EOL]             result.addValue(data[r][c], rowKey, columnKey); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } <line_num>: 395,408
public static CategoryDataset createCategoryDataset(Comparable[] rowKeys, Comparable[] columnKeys, double[][] data) { [EOL]     if (rowKeys == null) { [EOL]         throw new IllegalArgumentException("Null 'rowKeys' argument."); [EOL]     } [EOL]     if (columnKeys == null) { [EOL]         throw new IllegalArgumentException("Null 'columnKeys' argument."); [EOL]     } [EOL]     if (ArrayUtilities.hasDuplicateItems(rowKeys)) { [EOL]         throw new IllegalArgumentException("Duplicate items in 'rowKeys'."); [EOL]     } [EOL]     if (ArrayUtilities.hasDuplicateItems(columnKeys)) { [EOL]         throw new IllegalArgumentException("Duplicate items in 'columnKeys'."); [EOL]     } [EOL]     if (rowKeys.length != data.length) { [EOL]         throw new IllegalArgumentException("The number of row keys does not match the number of rows in " + "the data array."); [EOL]     } [EOL]     int columnCount = 0; [EOL]     for (int r = 0; r < data.length; r++) { [EOL]         columnCount = Math.max(columnCount, data[r].length); [EOL]     } [EOL]     if (columnKeys.length != columnCount) { [EOL]         throw new IllegalArgumentException("The number of column keys does not match the number of " + "columns in the data array."); [EOL]     } [EOL]     DefaultCategoryDataset result = new DefaultCategoryDataset(); [EOL]     for (int r = 0; r < data.length; r++) { [EOL]         Comparable rowKey = rowKeys[r]; [EOL]         for (int c = 0; c < data[r].length; c++) { [EOL]             Comparable columnKey = columnKeys[c]; [EOL]             result.addValue(new Double(data[r][c]), rowKey, columnKey); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } <line_num>: 423,466
public static CategoryDataset createCategoryDataset(Comparable rowKey, KeyedValues rowData) { [EOL]     if (rowKey == null) { [EOL]         throw new IllegalArgumentException("Null 'rowKey' argument."); [EOL]     } [EOL]     if (rowData == null) { [EOL]         throw new IllegalArgumentException("Null 'rowData' argument."); [EOL]     } [EOL]     DefaultCategoryDataset result = new DefaultCategoryDataset(); [EOL]     for (int i = 0; i < rowData.getItemCount(); i++) { [EOL]         result.addValue(rowData.getValue(i), rowKey, rowData.getKey(i)); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 477,492
public static XYDataset sampleFunction2D(Function2D f, double start, double end, int samples, Comparable seriesKey) { [EOL]     XYSeries series = sampleFunction2DToSeries(f, start, end, samples, seriesKey); [EOL]     XYSeriesCollection collection = new XYSeriesCollection(series); [EOL]     return collection; [EOL] } <line_num>: 507,515
public static XYSeries sampleFunction2DToSeries(Function2D f, double start, double end, int samples, Comparable seriesKey) { [EOL]     if (f == null) { [EOL]         throw new IllegalArgumentException("Null 'f' argument."); [EOL]     } [EOL]     if (seriesKey == null) { [EOL]         throw new IllegalArgumentException("Null 'seriesKey' argument."); [EOL]     } [EOL]     if (start >= end) { [EOL]         throw new IllegalArgumentException("Requires 'start' < 'end'."); [EOL]     } [EOL]     if (samples < 2) { [EOL]         throw new IllegalArgumentException("Requires 'samples' > 1"); [EOL]     } [EOL]     XYSeries series = new XYSeries(seriesKey); [EOL]     double step = (end - start) / (samples - 1); [EOL]     for (int i = 0; i < samples; i++) { [EOL]         double x = start + (step * i); [EOL]         series.add(x, f.getValue(x)); [EOL]     } [EOL]     return series; [EOL] } <line_num>: 532,555
public static boolean isEmptyOrNull(PieDataset dataset) { [EOL]     if (dataset == null) { [EOL]         return true; [EOL]     } [EOL]     int itemCount = dataset.getItemCount(); [EOL]     if (itemCount == 0) { [EOL]         return true; [EOL]     } [EOL]     for (int item = 0; item < itemCount; item++) { [EOL]         Number y = dataset.getValue(item); [EOL]         if (y != null) { [EOL]             double yy = y.doubleValue(); [EOL]             if (yy > 0.0) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 565,588
public static boolean isEmptyOrNull(CategoryDataset dataset) { [EOL]     if (dataset == null) { [EOL]         return true; [EOL]     } [EOL]     int rowCount = dataset.getRowCount(); [EOL]     int columnCount = dataset.getColumnCount(); [EOL]     if (rowCount == 0 || columnCount == 0) { [EOL]         return true; [EOL]     } [EOL]     for (int r = 0; r < rowCount; r++) { [EOL]         for (int c = 0; c < columnCount; c++) { [EOL]             if (dataset.getValue(r, c) != null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 598,621
public static boolean isEmptyOrNull(XYDataset dataset) { [EOL]     if (dataset != null) { [EOL]         for (int s = 0; s < dataset.getSeriesCount(); s++) { [EOL]             if (dataset.getItemCount(s) > 0) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 631,640
public static Range findDomainBounds(XYDataset dataset) { [EOL]     return findDomainBounds(dataset, true); [EOL] } <line_num>: 649,651
public static Range findDomainBounds(XYDataset dataset, boolean includeInterval) { [EOL]     if (dataset == null) { [EOL]         throw new IllegalArgumentException("Null 'dataset' argument."); [EOL]     } [EOL]     Range result = null; [EOL]     if (dataset instanceof DomainInfo) { [EOL]         DomainInfo info = (DomainInfo) dataset; [EOL]         result = info.getDomainBounds(includeInterval); [EOL]     } else { [EOL]         result = iterateDomainBounds(dataset, includeInterval); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 663,681
public static Range findDomainBounds(XYDataset dataset, List visibleSeriesKeys, boolean includeInterval) { [EOL]     if (dataset == null) { [EOL]         throw new IllegalArgumentException("Null 'dataset' argument."); [EOL]     } [EOL]     Range result = null; [EOL]     if (dataset instanceof XYDomainInfo) { [EOL]         XYDomainInfo info = (XYDomainInfo) dataset; [EOL]         result = info.getDomainBounds(visibleSeriesKeys, includeInterval); [EOL]     } else { [EOL]         result = iterateToFindDomainBounds(dataset, visibleSeriesKeys, includeInterval); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 698,713
public static Range iterateDomainBounds(XYDataset dataset) { [EOL]     return iterateDomainBounds(dataset, true); [EOL] } <line_num>: 725,727
public static Range iterateDomainBounds(XYDataset dataset, boolean includeInterval) { [EOL]     if (dataset == null) { [EOL]         throw new IllegalArgumentException("Null 'dataset' argument."); [EOL]     } [EOL]     double minimum = Double.POSITIVE_INFINITY; [EOL]     double maximum = Double.NEGATIVE_INFINITY; [EOL]     int seriesCount = dataset.getSeriesCount(); [EOL]     double lvalue; [EOL]     double uvalue; [EOL]     if (includeInterval && dataset instanceof IntervalXYDataset) { [EOL]         IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset; [EOL]         for (int series = 0; series < seriesCount; series++) { [EOL]             int itemCount = dataset.getItemCount(series); [EOL]             for (int item = 0; item < itemCount; item++) { [EOL]                 double value = intervalXYData.getXValue(series, item); [EOL]                 lvalue = intervalXYData.getStartXValue(series, item); [EOL]                 uvalue = intervalXYData.getEndXValue(series, item); [EOL]                 if (!Double.isNaN(value)) { [EOL]                     minimum = Math.min(minimum, value); [EOL]                     maximum = Math.max(maximum, value); [EOL]                 } [EOL]                 if (!Double.isNaN(lvalue)) { [EOL]                     minimum = Math.min(minimum, lvalue); [EOL]                     maximum = Math.max(maximum, lvalue); [EOL]                 } [EOL]                 if (!Double.isNaN(uvalue)) { [EOL]                     minimum = Math.min(minimum, uvalue); [EOL]                     maximum = Math.max(maximum, uvalue); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int series = 0; series < seriesCount; series++) { [EOL]             int itemCount = dataset.getItemCount(series); [EOL]             for (int item = 0; item < itemCount; item++) { [EOL]                 lvalue = dataset.getXValue(series, item); [EOL]                 uvalue = lvalue; [EOL]                 if (!Double.isNaN(lvalue)) { [EOL]                     minimum = Math.min(minimum, lvalue); [EOL]                     maximum = Math.max(maximum, uvalue); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (minimum > maximum) { [EOL]         return null; [EOL]     } else { [EOL]         return new Range(minimum, maximum); [EOL]     } [EOL] } <line_num>: 740,792
public static Range findRangeBounds(CategoryDataset dataset) { [EOL]     return findRangeBounds(dataset, true); [EOL] } <line_num>: 801,803
public static Range findRangeBounds(CategoryDataset dataset, boolean includeInterval) { [EOL]     if (dataset == null) { [EOL]         throw new IllegalArgumentException("Null 'dataset' argument."); [EOL]     } [EOL]     Range result = null; [EOL]     if (dataset instanceof RangeInfo) { [EOL]         RangeInfo info = (RangeInfo) dataset; [EOL]         result = info.getRangeBounds(includeInterval); [EOL]     } else { [EOL]         result = iterateRangeBounds(dataset, includeInterval); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 814,828
public static Range findRangeBounds(CategoryDataset dataset, List visibleSeriesKeys, boolean includeInterval) { [EOL]     if (dataset == null) { [EOL]         throw new IllegalArgumentException("Null 'dataset' argument."); [EOL]     } [EOL]     Range result = null; [EOL]     if (dataset instanceof CategoryRangeInfo) { [EOL]         CategoryRangeInfo info = (CategoryRangeInfo) dataset; [EOL]         result = info.getRangeBounds(visibleSeriesKeys, includeInterval); [EOL]     } else { [EOL]         result = iterateToFindRangeBounds(dataset, visibleSeriesKeys, includeInterval); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 844,859
public static Range findRangeBounds(XYDataset dataset) { [EOL]     return findRangeBounds(dataset, true); [EOL] } <line_num>: 869,871
public static Range findRangeBounds(XYDataset dataset, boolean includeInterval) { [EOL]     if (dataset == null) { [EOL]         throw new IllegalArgumentException("Null 'dataset' argument."); [EOL]     } [EOL]     Range result = null; [EOL]     if (dataset instanceof RangeInfo) { [EOL]         RangeInfo info = (RangeInfo) dataset; [EOL]         result = info.getRangeBounds(includeInterval); [EOL]     } else { [EOL]         result = iterateRangeBounds(dataset, includeInterval); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 884,898
public static Range findRangeBounds(XYDataset dataset, List visibleSeriesKeys, Range xRange, boolean includeInterval) { [EOL]     if (dataset == null) { [EOL]         throw new IllegalArgumentException("Null 'dataset' argument."); [EOL]     } [EOL]     Range result = null; [EOL]     if (dataset instanceof XYRangeInfo) { [EOL]         XYRangeInfo info = (XYRangeInfo) dataset; [EOL]         result = info.getRangeBounds(visibleSeriesKeys, xRange, includeInterval); [EOL]     } else { [EOL]         result = iterateToFindRangeBounds(dataset, visibleSeriesKeys, xRange, includeInterval); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 916,932
public static Range iterateCategoryRangeBounds(CategoryDataset dataset, boolean includeInterval) { [EOL]     return iterateRangeBounds(dataset, includeInterval); [EOL] } <line_num>: 947,950
public static Range iterateRangeBounds(CategoryDataset dataset) { [EOL]     return iterateRangeBounds(dataset, true); [EOL] } <line_num>: 962,964
public static Range iterateRangeBounds(CategoryDataset dataset, boolean includeInterval) { [EOL]     double minimum = Double.POSITIVE_INFINITY; [EOL]     double maximum = Double.NEGATIVE_INFINITY; [EOL]     int rowCount = dataset.getRowCount(); [EOL]     int columnCount = dataset.getColumnCount(); [EOL]     if (includeInterval && dataset instanceof IntervalCategoryDataset) { [EOL]         IntervalCategoryDataset icd = (IntervalCategoryDataset) dataset; [EOL]         Number value, lvalue, uvalue; [EOL]         for (int row = 0; row < rowCount; row++) { [EOL]             for (int column = 0; column < columnCount; column++) { [EOL]                 value = icd.getValue(row, column); [EOL]                 double v; [EOL]                 if ((value != null) && !Double.isNaN(v = value.doubleValue())) { [EOL]                     minimum = Math.min(v, minimum); [EOL]                     maximum = Math.max(v, maximum); [EOL]                 } [EOL]                 lvalue = icd.getStartValue(row, column); [EOL]                 if (lvalue != null && !Double.isNaN(v = lvalue.doubleValue())) { [EOL]                     minimum = Math.min(v, minimum); [EOL]                     maximum = Math.max(v, maximum); [EOL]                 } [EOL]                 uvalue = icd.getEndValue(row, column); [EOL]                 if (uvalue != null && !Double.isNaN(v = uvalue.doubleValue())) { [EOL]                     minimum = Math.min(v, minimum); [EOL]                     maximum = Math.max(v, maximum); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int row = 0; row < rowCount; row++) { [EOL]             for (int column = 0; column < columnCount; column++) { [EOL]                 Number value = dataset.getValue(row, column); [EOL]                 if (value != null) { [EOL]                     double v = value.doubleValue(); [EOL]                     if (!Double.isNaN(v)) { [EOL]                         minimum = Math.min(minimum, v); [EOL]                         maximum = Math.max(maximum, v); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (minimum == Double.POSITIVE_INFINITY) { [EOL]         return null; [EOL]     } else { [EOL]         return new Range(minimum, maximum); [EOL]     } [EOL] } <line_num>: 978,1034
public static Range iterateToFindRangeBounds(CategoryDataset dataset, List visibleSeriesKeys, boolean includeInterval) { [EOL]     if (dataset == null) { [EOL]         throw new IllegalArgumentException("Null 'dataset' argument."); [EOL]     } [EOL]     if (visibleSeriesKeys == null) { [EOL]         throw new IllegalArgumentException("Null 'visibleSeriesKeys' argument."); [EOL]     } [EOL]     double minimum = Double.POSITIVE_INFINITY; [EOL]     double maximum = Double.NEGATIVE_INFINITY; [EOL]     int columnCount = dataset.getColumnCount(); [EOL]     if (includeInterval && dataset instanceof BoxAndWhiskerCategoryDataset) { [EOL]         BoxAndWhiskerCategoryDataset bx = (BoxAndWhiskerCategoryDataset) dataset; [EOL]         Iterator iterator = visibleSeriesKeys.iterator(); [EOL]         while (iterator.hasNext()) { [EOL]             Comparable seriesKey = (Comparable) iterator.next(); [EOL]             int series = dataset.getRowIndex(seriesKey); [EOL]             int itemCount = dataset.getColumnCount(); [EOL]             for (int item = 0; item < itemCount; item++) { [EOL]                 Number lvalue = bx.getMinRegularValue(series, item); [EOL]                 if (lvalue == null) { [EOL]                     lvalue = bx.getValue(series, item); [EOL]                 } [EOL]                 Number uvalue = bx.getMaxRegularValue(series, item); [EOL]                 if (uvalue == null) { [EOL]                     uvalue = bx.getValue(series, item); [EOL]                 } [EOL]                 if (lvalue != null) { [EOL]                     minimum = Math.min(minimum, lvalue.doubleValue()); [EOL]                 } [EOL]                 if (uvalue != null) { [EOL]                     maximum = Math.max(maximum, uvalue.doubleValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else if (includeInterval && dataset instanceof IntervalCategoryDataset) { [EOL]         IntervalCategoryDataset icd = (IntervalCategoryDataset) dataset; [EOL]         Number lvalue, uvalue; [EOL]         Iterator iterator = visibleSeriesKeys.iterator(); [EOL]         while (iterator.hasNext()) { [EOL]             Comparable seriesKey = (Comparable) iterator.next(); [EOL]             int series = dataset.getRowIndex(seriesKey); [EOL]             for (int column = 0; column < columnCount; column++) { [EOL]                 lvalue = icd.getStartValue(series, column); [EOL]                 uvalue = icd.getEndValue(series, column); [EOL]                 if (lvalue != null && !Double.isNaN(lvalue.doubleValue())) { [EOL]                     minimum = Math.min(minimum, lvalue.doubleValue()); [EOL]                 } [EOL]                 if (uvalue != null && !Double.isNaN(uvalue.doubleValue())) { [EOL]                     maximum = Math.max(maximum, uvalue.doubleValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else if (includeInterval && dataset instanceof MultiValueCategoryDataset) { [EOL]         MultiValueCategoryDataset mvcd = (MultiValueCategoryDataset) dataset; [EOL]         Iterator iterator = visibleSeriesKeys.iterator(); [EOL]         while (iterator.hasNext()) { [EOL]             Comparable seriesKey = (Comparable) iterator.next(); [EOL]             int series = dataset.getRowIndex(seriesKey); [EOL]             for (int column = 0; column < columnCount; column++) { [EOL]                 List values = mvcd.getValues(series, column); [EOL]                 Iterator valueIterator = values.iterator(); [EOL]                 while (valueIterator.hasNext()) { [EOL]                     Object o = valueIterator.next(); [EOL]                     if (o instanceof Number) { [EOL]                         double v = ((Number) o).doubleValue(); [EOL]                         if (!Double.isNaN(v)) { [EOL]                             minimum = Math.min(minimum, v); [EOL]                             maximum = Math.max(maximum, v); [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else if (includeInterval && dataset instanceof StatisticalCategoryDataset) { [EOL]         StatisticalCategoryDataset scd = (StatisticalCategoryDataset) dataset; [EOL]         Iterator iterator = visibleSeriesKeys.iterator(); [EOL]         while (iterator.hasNext()) { [EOL]             Comparable seriesKey = (Comparable) iterator.next(); [EOL]             int series = dataset.getRowIndex(seriesKey); [EOL]             for (int column = 0; column < columnCount; column++) { [EOL]                 Number meanN = scd.getMeanValue(series, column); [EOL]                 if (meanN != null) { [EOL]                     double std = 0.0; [EOL]                     Number stdN = scd.getStdDevValue(series, column); [EOL]                     if (stdN != null) { [EOL]                         std = stdN.doubleValue(); [EOL]                         if (Double.isNaN(std)) { [EOL]                             std = 0.0; [EOL]                         } [EOL]                     } [EOL]                     double mean = meanN.doubleValue(); [EOL]                     if (!Double.isNaN(mean)) { [EOL]                         minimum = Math.min(minimum, mean - std); [EOL]                         maximum = Math.max(maximum, mean + std); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         Iterator iterator = visibleSeriesKeys.iterator(); [EOL]         while (iterator.hasNext()) { [EOL]             Comparable seriesKey = (Comparable) iterator.next(); [EOL]             int series = dataset.getRowIndex(seriesKey); [EOL]             for (int column = 0; column < columnCount; column++) { [EOL]                 Number value = dataset.getValue(series, column); [EOL]                 if (value != null) { [EOL]                     double v = value.doubleValue(); [EOL]                     if (!Double.isNaN(v)) { [EOL]                         minimum = Math.min(minimum, v); [EOL]                         maximum = Math.max(maximum, v); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (minimum == Double.POSITIVE_INFINITY) { [EOL]         return null; [EOL]     } else { [EOL]         return new Range(minimum, maximum); [EOL]     } [EOL] } <line_num>: 1049,1193
public static Range iterateXYRangeBounds(XYDataset dataset) { [EOL]     return iterateRangeBounds(dataset); [EOL] } <line_num>: 1205,1207
public static Range iterateRangeBounds(XYDataset dataset) { [EOL]     return iterateRangeBounds(dataset, true); [EOL] } <line_num>: 1219,1221
public static Range iterateRangeBounds(XYDataset dataset, boolean includeInterval) { [EOL]     double minimum = Double.POSITIVE_INFINITY; [EOL]     double maximum = Double.NEGATIVE_INFINITY; [EOL]     int seriesCount = dataset.getSeriesCount(); [EOL]     if (includeInterval && dataset instanceof IntervalXYDataset) { [EOL]         IntervalXYDataset ixyd = (IntervalXYDataset) dataset; [EOL]         for (int series = 0; series < seriesCount; series++) { [EOL]             int itemCount = dataset.getItemCount(series); [EOL]             for (int item = 0; item < itemCount; item++) { [EOL]                 double value = ixyd.getYValue(series, item); [EOL]                 double lvalue = ixyd.getStartYValue(series, item); [EOL]                 double uvalue = ixyd.getEndYValue(series, item); [EOL]                 if (!Double.isNaN(value)) { [EOL]                     minimum = Math.min(minimum, value); [EOL]                     maximum = Math.max(maximum, value); [EOL]                 } [EOL]                 if (!Double.isNaN(lvalue)) { [EOL]                     minimum = Math.min(minimum, lvalue); [EOL]                     maximum = Math.max(maximum, lvalue); [EOL]                 } [EOL]                 if (!Double.isNaN(uvalue)) { [EOL]                     minimum = Math.min(minimum, uvalue); [EOL]                     maximum = Math.max(maximum, uvalue); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else if (includeInterval && dataset instanceof OHLCDataset) { [EOL]         OHLCDataset ohlc = (OHLCDataset) dataset; [EOL]         for (int series = 0; series < seriesCount; series++) { [EOL]             int itemCount = dataset.getItemCount(series); [EOL]             for (int item = 0; item < itemCount; item++) { [EOL]                 double lvalue = ohlc.getLowValue(series, item); [EOL]                 double uvalue = ohlc.getHighValue(series, item); [EOL]                 if (!Double.isNaN(lvalue)) { [EOL]                     minimum = Math.min(minimum, lvalue); [EOL]                 } [EOL]                 if (!Double.isNaN(uvalue)) { [EOL]                     maximum = Math.max(maximum, uvalue); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         for (int series = 0; series < seriesCount; series++) { [EOL]             int itemCount = dataset.getItemCount(series); [EOL]             for (int item = 0; item < itemCount; item++) { [EOL]                 double value = dataset.getYValue(series, item); [EOL]                 if (!Double.isNaN(value)) { [EOL]                     minimum = Math.min(minimum, value); [EOL]                     maximum = Math.max(maximum, value); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (minimum == Double.POSITIVE_INFINITY) { [EOL]         return null; [EOL]     } else { [EOL]         return new Range(minimum, maximum); [EOL]     } [EOL] } <line_num>: 1236,1303
public static Range iterateToFindDomainBounds(XYDataset dataset, List visibleSeriesKeys, boolean includeInterval) { [EOL]     if (dataset == null) { [EOL]         throw new IllegalArgumentException("Null 'dataset' argument."); [EOL]     } [EOL]     if (visibleSeriesKeys == null) { [EOL]         throw new IllegalArgumentException("Null 'visibleSeriesKeys' argument."); [EOL]     } [EOL]     double minimum = Double.POSITIVE_INFINITY; [EOL]     double maximum = Double.NEGATIVE_INFINITY; [EOL]     if (includeInterval && dataset instanceof IntervalXYDataset) { [EOL]         IntervalXYDataset ixyd = (IntervalXYDataset) dataset; [EOL]         Iterator iterator = visibleSeriesKeys.iterator(); [EOL]         while (iterator.hasNext()) { [EOL]             Comparable seriesKey = (Comparable) iterator.next(); [EOL]             int series = dataset.indexOf(seriesKey); [EOL]             int itemCount = dataset.getItemCount(series); [EOL]             for (int item = 0; item < itemCount; item++) { [EOL]                 double lvalue = ixyd.getStartXValue(series, item); [EOL]                 double uvalue = ixyd.getEndXValue(series, item); [EOL]                 if (!Double.isNaN(lvalue)) { [EOL]                     minimum = Math.min(minimum, lvalue); [EOL]                 } [EOL]                 if (!Double.isNaN(uvalue)) { [EOL]                     maximum = Math.max(maximum, uvalue); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         Iterator iterator = visibleSeriesKeys.iterator(); [EOL]         while (iterator.hasNext()) { [EOL]             Comparable seriesKey = (Comparable) iterator.next(); [EOL]             int series = dataset.indexOf(seriesKey); [EOL]             int itemCount = dataset.getItemCount(series); [EOL]             for (int item = 0; item < itemCount; item++) { [EOL]                 double x = dataset.getXValue(series, item); [EOL]                 if (!Double.isNaN(x)) { [EOL]                     minimum = Math.min(minimum, x); [EOL]                     maximum = Math.max(maximum, x); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (minimum == Double.POSITIVE_INFINITY) { [EOL]         return null; [EOL]     } else { [EOL]         return new Range(minimum, maximum); [EOL]     } [EOL] } <line_num>: 1320,1377
public static Range iterateToFindRangeBounds(XYDataset dataset, List visibleSeriesKeys, Range xRange, boolean includeInterval) { [EOL]     if (dataset == null) { [EOL]         throw new IllegalArgumentException("Null 'dataset' argument."); [EOL]     } [EOL]     if (visibleSeriesKeys == null) { [EOL]         throw new IllegalArgumentException("Null 'visibleSeriesKeys' argument."); [EOL]     } [EOL]     if (xRange == null) { [EOL]         throw new IllegalArgumentException("Null 'xRange' argument"); [EOL]     } [EOL]     double minimum = Double.POSITIVE_INFINITY; [EOL]     double maximum = Double.NEGATIVE_INFINITY; [EOL]     if (includeInterval && dataset instanceof OHLCDataset) { [EOL]         OHLCDataset ohlc = (OHLCDataset) dataset; [EOL]         Iterator iterator = visibleSeriesKeys.iterator(); [EOL]         while (iterator.hasNext()) { [EOL]             Comparable seriesKey = (Comparable) iterator.next(); [EOL]             int series = dataset.indexOf(seriesKey); [EOL]             int itemCount = dataset.getItemCount(series); [EOL]             for (int item = 0; item < itemCount; item++) { [EOL]                 double x = ohlc.getXValue(series, item); [EOL]                 if (xRange.contains(x)) { [EOL]                     double lvalue = ohlc.getLowValue(series, item); [EOL]                     double uvalue = ohlc.getHighValue(series, item); [EOL]                     if (!Double.isNaN(lvalue)) { [EOL]                         minimum = Math.min(minimum, lvalue); [EOL]                     } [EOL]                     if (!Double.isNaN(uvalue)) { [EOL]                         maximum = Math.max(maximum, uvalue); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else if (includeInterval && dataset instanceof BoxAndWhiskerXYDataset) { [EOL]         BoxAndWhiskerXYDataset bx = (BoxAndWhiskerXYDataset) dataset; [EOL]         Iterator iterator = visibleSeriesKeys.iterator(); [EOL]         while (iterator.hasNext()) { [EOL]             Comparable seriesKey = (Comparable) iterator.next(); [EOL]             int series = dataset.indexOf(seriesKey); [EOL]             int itemCount = dataset.getItemCount(series); [EOL]             for (int item = 0; item < itemCount; item++) { [EOL]                 double x = bx.getXValue(series, item); [EOL]                 if (xRange.contains(x)) { [EOL]                     Number lvalue = bx.getMinRegularValue(series, item); [EOL]                     Number uvalue = bx.getMaxRegularValue(series, item); [EOL]                     if (lvalue != null) { [EOL]                         minimum = Math.min(minimum, lvalue.doubleValue()); [EOL]                     } [EOL]                     if (uvalue != null) { [EOL]                         maximum = Math.max(maximum, uvalue.doubleValue()); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else if (includeInterval && dataset instanceof IntervalXYDataset) { [EOL]         IntervalXYDataset ixyd = (IntervalXYDataset) dataset; [EOL]         Iterator iterator = visibleSeriesKeys.iterator(); [EOL]         while (iterator.hasNext()) { [EOL]             Comparable seriesKey = (Comparable) iterator.next(); [EOL]             int series = dataset.indexOf(seriesKey); [EOL]             int itemCount = dataset.getItemCount(series); [EOL]             for (int item = 0; item < itemCount; item++) { [EOL]                 double x = ixyd.getXValue(series, item); [EOL]                 if (xRange.contains(x)) { [EOL]                     double lvalue = ixyd.getStartYValue(series, item); [EOL]                     double uvalue = ixyd.getEndYValue(series, item); [EOL]                     if (!Double.isNaN(lvalue)) { [EOL]                         minimum = Math.min(minimum, lvalue); [EOL]                     } [EOL]                     if (!Double.isNaN(uvalue)) { [EOL]                         maximum = Math.max(maximum, uvalue); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else { [EOL]         Iterator iterator = visibleSeriesKeys.iterator(); [EOL]         while (iterator.hasNext()) { [EOL]             Comparable seriesKey = (Comparable) iterator.next(); [EOL]             int series = dataset.indexOf(seriesKey); [EOL]             int itemCount = dataset.getItemCount(series); [EOL]             for (int item = 0; item < itemCount; item++) { [EOL]                 double x = dataset.getXValue(series, item); [EOL]                 double y = dataset.getYValue(series, item); [EOL]                 if (xRange.contains(x)) { [EOL]                     if (!Double.isNaN(y)) { [EOL]                         minimum = Math.min(minimum, y); [EOL]                         maximum = Math.max(maximum, y); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (minimum == Double.POSITIVE_INFINITY) { [EOL]         return null; [EOL]     } else { [EOL]         return new Range(minimum, maximum); [EOL]     } [EOL] } <line_num>: 1396,1508
public static Number findMinimumDomainValue(XYDataset dataset) { [EOL]     if (dataset == null) { [EOL]         throw new IllegalArgumentException("Null 'dataset' argument."); [EOL]     } [EOL]     Number result = null; [EOL]     if (dataset instanceof DomainInfo) { [EOL]         DomainInfo info = (DomainInfo) dataset; [EOL]         return new Double(info.getDomainLowerBound(true)); [EOL]     } else { [EOL]         double minimum = Double.POSITIVE_INFINITY; [EOL]         int seriesCount = dataset.getSeriesCount(); [EOL]         for (int series = 0; series < seriesCount; series++) { [EOL]             int itemCount = dataset.getItemCount(series); [EOL]             for (int item = 0; item < itemCount; item++) { [EOL]                 double value; [EOL]                 if (dataset instanceof IntervalXYDataset) { [EOL]                     IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset; [EOL]                     value = intervalXYData.getStartXValue(series, item); [EOL]                 } else { [EOL]                     value = dataset.getXValue(series, item); [EOL]                 } [EOL]                 if (!Double.isNaN(value)) { [EOL]                     minimum = Math.min(minimum, value); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (minimum == Double.POSITIVE_INFINITY) { [EOL]             result = null; [EOL]         } else { [EOL]             result = new Double(minimum); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1523,1564
public static Number findMaximumDomainValue(XYDataset dataset) { [EOL]     if (dataset == null) { [EOL]         throw new IllegalArgumentException("Null 'dataset' argument."); [EOL]     } [EOL]     Number result = null; [EOL]     if (dataset instanceof DomainInfo) { [EOL]         DomainInfo info = (DomainInfo) dataset; [EOL]         return new Double(info.getDomainUpperBound(true)); [EOL]     } else { [EOL]         double maximum = Double.NEGATIVE_INFINITY; [EOL]         int seriesCount = dataset.getSeriesCount(); [EOL]         for (int series = 0; series < seriesCount; series++) { [EOL]             int itemCount = dataset.getItemCount(series); [EOL]             for (int item = 0; item < itemCount; item++) { [EOL]                 double value; [EOL]                 if (dataset instanceof IntervalXYDataset) { [EOL]                     IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset; [EOL]                     value = intervalXYData.getEndXValue(series, item); [EOL]                 } else { [EOL]                     value = dataset.getXValue(series, item); [EOL]                 } [EOL]                 if (!Double.isNaN(value)) { [EOL]                     maximum = Math.max(maximum, value); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (maximum == Double.NEGATIVE_INFINITY) { [EOL]             result = null; [EOL]         } else { [EOL]             result = new Double(maximum); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1578,1621
public static Number findMinimumRangeValue(CategoryDataset dataset) { [EOL]     if (dataset == null) { [EOL]         throw new IllegalArgumentException("Null 'dataset' argument."); [EOL]     } [EOL]     if (dataset instanceof RangeInfo) { [EOL]         RangeInfo info = (RangeInfo) dataset; [EOL]         return new Double(info.getRangeLowerBound(true)); [EOL]     } else { [EOL]         double minimum = Double.POSITIVE_INFINITY; [EOL]         int seriesCount = dataset.getRowCount(); [EOL]         int itemCount = dataset.getColumnCount(); [EOL]         for (int series = 0; series < seriesCount; series++) { [EOL]             for (int item = 0; item < itemCount; item++) { [EOL]                 Number value; [EOL]                 if (dataset instanceof IntervalCategoryDataset) { [EOL]                     IntervalCategoryDataset icd = (IntervalCategoryDataset) dataset; [EOL]                     value = icd.getStartValue(series, item); [EOL]                 } else { [EOL]                     value = dataset.getValue(series, item); [EOL]                 } [EOL]                 if (value != null) { [EOL]                     minimum = Math.min(minimum, value.doubleValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (minimum == Double.POSITIVE_INFINITY) { [EOL]             return null; [EOL]         } else { [EOL]             return new Double(minimum); [EOL]         } [EOL]     } [EOL] } <line_num>: 1635,1676
public static Number findMinimumRangeValue(XYDataset dataset) { [EOL]     if (dataset == null) { [EOL]         throw new IllegalArgumentException("Null 'dataset' argument."); [EOL]     } [EOL]     if (dataset instanceof RangeInfo) { [EOL]         RangeInfo info = (RangeInfo) dataset; [EOL]         return new Double(info.getRangeLowerBound(true)); [EOL]     } else { [EOL]         double minimum = Double.POSITIVE_INFINITY; [EOL]         int seriesCount = dataset.getSeriesCount(); [EOL]         for (int series = 0; series < seriesCount; series++) { [EOL]             int itemCount = dataset.getItemCount(series); [EOL]             for (int item = 0; item < itemCount; item++) { [EOL]                 double value; [EOL]                 if (dataset instanceof IntervalXYDataset) { [EOL]                     IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset; [EOL]                     value = intervalXYData.getStartYValue(series, item); [EOL]                 } else if (dataset instanceof OHLCDataset) { [EOL]                     OHLCDataset highLowData = (OHLCDataset) dataset; [EOL]                     value = highLowData.getLowValue(series, item); [EOL]                 } else { [EOL]                     value = dataset.getYValue(series, item); [EOL]                 } [EOL]                 if (!Double.isNaN(value)) { [EOL]                     minimum = Math.min(minimum, value); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (minimum == Double.POSITIVE_INFINITY) { [EOL]             return null; [EOL]         } else { [EOL]             return new Double(minimum); [EOL]         } [EOL]     } [EOL] } <line_num>: 1690,1738
public static Number findMaximumRangeValue(CategoryDataset dataset) { [EOL]     if (dataset == null) { [EOL]         throw new IllegalArgumentException("Null 'dataset' argument."); [EOL]     } [EOL]     if (dataset instanceof RangeInfo) { [EOL]         RangeInfo info = (RangeInfo) dataset; [EOL]         return new Double(info.getRangeUpperBound(true)); [EOL]     } else { [EOL]         double maximum = Double.NEGATIVE_INFINITY; [EOL]         int seriesCount = dataset.getRowCount(); [EOL]         int itemCount = dataset.getColumnCount(); [EOL]         for (int series = 0; series < seriesCount; series++) { [EOL]             for (int item = 0; item < itemCount; item++) { [EOL]                 Number value; [EOL]                 if (dataset instanceof IntervalCategoryDataset) { [EOL]                     IntervalCategoryDataset icd = (IntervalCategoryDataset) dataset; [EOL]                     value = icd.getEndValue(series, item); [EOL]                 } else { [EOL]                     value = dataset.getValue(series, item); [EOL]                 } [EOL]                 if (value != null) { [EOL]                     maximum = Math.max(maximum, value.doubleValue()); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (maximum == Double.NEGATIVE_INFINITY) { [EOL]             return null; [EOL]         } else { [EOL]             return new Double(maximum); [EOL]         } [EOL]     } [EOL] } <line_num>: 1751,1794
public static Number findMaximumRangeValue(XYDataset dataset) { [EOL]     if (dataset == null) { [EOL]         throw new IllegalArgumentException("Null 'dataset' argument."); [EOL]     } [EOL]     if (dataset instanceof RangeInfo) { [EOL]         RangeInfo info = (RangeInfo) dataset; [EOL]         return new Double(info.getRangeUpperBound(true)); [EOL]     } else { [EOL]         double maximum = Double.NEGATIVE_INFINITY; [EOL]         int seriesCount = dataset.getSeriesCount(); [EOL]         for (int series = 0; series < seriesCount; series++) { [EOL]             int itemCount = dataset.getItemCount(series); [EOL]             for (int item = 0; item < itemCount; item++) { [EOL]                 double value; [EOL]                 if (dataset instanceof IntervalXYDataset) { [EOL]                     IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset; [EOL]                     value = intervalXYData.getEndYValue(series, item); [EOL]                 } else if (dataset instanceof OHLCDataset) { [EOL]                     OHLCDataset highLowData = (OHLCDataset) dataset; [EOL]                     value = highLowData.getHighValue(series, item); [EOL]                 } else { [EOL]                     value = dataset.getYValue(series, item); [EOL]                 } [EOL]                 if (!Double.isNaN(value)) { [EOL]                     maximum = Math.max(maximum, value); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (maximum == Double.NEGATIVE_INFINITY) { [EOL]             return null; [EOL]         } else { [EOL]             return new Double(maximum); [EOL]         } [EOL]     } [EOL] } <line_num>: 1807,1854
public static Range findStackedRangeBounds(CategoryDataset dataset) { [EOL]     return findStackedRangeBounds(dataset, 0.0); [EOL] } <line_num>: 1864,1866
public static Range findStackedRangeBounds(CategoryDataset dataset, double base) { [EOL]     if (dataset == null) { [EOL]         throw new IllegalArgumentException("Null 'dataset' argument."); [EOL]     } [EOL]     Range result = null; [EOL]     double minimum = Double.POSITIVE_INFINITY; [EOL]     double maximum = Double.NEGATIVE_INFINITY; [EOL]     int categoryCount = dataset.getColumnCount(); [EOL]     for (int item = 0; item < categoryCount; item++) { [EOL]         double positive = base; [EOL]         double negative = base; [EOL]         int seriesCount = dataset.getRowCount(); [EOL]         for (int series = 0; series < seriesCount; series++) { [EOL]             Number number = dataset.getValue(series, item); [EOL]             if (number != null) { [EOL]                 double value = number.doubleValue(); [EOL]                 if (value > 0.0) { [EOL]                     positive = positive + value; [EOL]                 } [EOL]                 if (value < 0.0) { [EOL]                     negative = negative + value; [EOL]                 } [EOL]             } [EOL]         } [EOL]         minimum = Math.min(minimum, negative); [EOL]         maximum = Math.max(maximum, positive); [EOL]     } [EOL]     if (minimum <= maximum) { [EOL]         result = new Range(minimum, maximum); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1877,1911
public static Range findStackedRangeBounds(CategoryDataset dataset, KeyToGroupMap map) { [EOL]     if (dataset == null) { [EOL]         throw new IllegalArgumentException("Null 'dataset' argument."); [EOL]     } [EOL]     boolean hasValidData = false; [EOL]     Range result = null; [EOL]     int[] groupIndex = new int[dataset.getRowCount()]; [EOL]     for (int i = 0; i < dataset.getRowCount(); i++) { [EOL]         groupIndex[i] = map.getGroupIndex(map.getGroup(dataset.getRowKey(i))); [EOL]     } [EOL]     int groupCount = map.getGroupCount(); [EOL]     double[] minimum = new double[groupCount]; [EOL]     double[] maximum = new double[groupCount]; [EOL]     int categoryCount = dataset.getColumnCount(); [EOL]     for (int item = 0; item < categoryCount; item++) { [EOL]         double[] positive = new double[groupCount]; [EOL]         double[] negative = new double[groupCount]; [EOL]         int seriesCount = dataset.getRowCount(); [EOL]         for (int series = 0; series < seriesCount; series++) { [EOL]             Number number = dataset.getValue(series, item); [EOL]             if (number != null) { [EOL]                 hasValidData = true; [EOL]                 double value = number.doubleValue(); [EOL]                 if (value > 0.0) { [EOL]                     positive[groupIndex[series]] = positive[groupIndex[series]] + value; [EOL]                 } [EOL]                 if (value < 0.0) { [EOL]                     negative[groupIndex[series]] = negative[groupIndex[series]] + value; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (int g = 0; g < groupCount; g++) { [EOL]             minimum[g] = Math.min(minimum[g], negative[g]); [EOL]             maximum[g] = Math.max(maximum[g], positive[g]); [EOL]         } [EOL]     } [EOL]     if (hasValidData) { [EOL]         for (int j = 0; j < groupCount; j++) { [EOL]             result = Range.combine(result, new Range(minimum[j], maximum[j])); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1923,1976
public static Number findMinimumStackedRangeValue(CategoryDataset dataset) { [EOL]     if (dataset == null) { [EOL]         throw new IllegalArgumentException("Null 'dataset' argument."); [EOL]     } [EOL]     Number result = null; [EOL]     boolean hasValidData = false; [EOL]     double minimum = 0.0; [EOL]     int categoryCount = dataset.getColumnCount(); [EOL]     for (int item = 0; item < categoryCount; item++) { [EOL]         double total = 0.0; [EOL]         int seriesCount = dataset.getRowCount(); [EOL]         for (int series = 0; series < seriesCount; series++) { [EOL]             Number number = dataset.getValue(series, item); [EOL]             if (number != null) { [EOL]                 hasValidData = true; [EOL]                 double value = number.doubleValue(); [EOL]                 if (value < 0.0) { [EOL]                     total = total + value; [EOL]                 } [EOL]             } [EOL]         } [EOL]         minimum = Math.min(minimum, total); [EOL]     } [EOL]     if (hasValidData) { [EOL]         result = new Double(minimum); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1988,2016
public static Number findMaximumStackedRangeValue(CategoryDataset dataset) { [EOL]     if (dataset == null) { [EOL]         throw new IllegalArgumentException("Null 'dataset' argument."); [EOL]     } [EOL]     Number result = null; [EOL]     boolean hasValidData = false; [EOL]     double maximum = 0.0; [EOL]     int categoryCount = dataset.getColumnCount(); [EOL]     for (int item = 0; item < categoryCount; item++) { [EOL]         double total = 0.0; [EOL]         int seriesCount = dataset.getRowCount(); [EOL]         for (int series = 0; series < seriesCount; series++) { [EOL]             Number number = dataset.getValue(series, item); [EOL]             if (number != null) { [EOL]                 hasValidData = true; [EOL]                 double value = number.doubleValue(); [EOL]                 if (value > 0.0) { [EOL]                     total = total + value; [EOL]                 } [EOL]             } [EOL]         } [EOL]         maximum = Math.max(maximum, total); [EOL]     } [EOL]     if (hasValidData) { [EOL]         result = new Double(maximum); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 2028,2055
public static Range findStackedRangeBounds(TableXYDataset dataset) { [EOL]     return findStackedRangeBounds(dataset, 0.0); [EOL] } <line_num>: 2065,2067
public static Range findStackedRangeBounds(TableXYDataset dataset, double base) { [EOL]     if (dataset == null) { [EOL]         throw new IllegalArgumentException("Null 'dataset' argument."); [EOL]     } [EOL]     double minimum = base; [EOL]     double maximum = base; [EOL]     for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) { [EOL]         double positive = base; [EOL]         double negative = base; [EOL]         int seriesCount = dataset.getSeriesCount(); [EOL]         for (int seriesNo = 0; seriesNo < seriesCount; seriesNo++) { [EOL]             double y = dataset.getYValue(seriesNo, itemNo); [EOL]             if (!Double.isNaN(y)) { [EOL]                 if (y > 0.0) { [EOL]                     positive += y; [EOL]                 } else { [EOL]                     negative += y; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (positive > maximum) { [EOL]             maximum = positive; [EOL]         } [EOL]         if (negative < minimum) { [EOL]             minimum = negative; [EOL]         } [EOL]     } [EOL]     if (minimum <= maximum) { [EOL]         return new Range(minimum, maximum); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] } <line_num>: 2078,2113
public static double calculateStackTotal(TableXYDataset dataset, int item) { [EOL]     double total = 0.0; [EOL]     int seriesCount = dataset.getSeriesCount(); [EOL]     for (int s = 0; s < seriesCount; s++) { [EOL]         double value = dataset.getYValue(s, item); [EOL]         if (!Double.isNaN(value)) { [EOL]             total = total + value; [EOL]         } [EOL]     } [EOL]     return total; [EOL] } <line_num>: 2126,2136
public static Range findCumulativeRangeBounds(CategoryDataset dataset) { [EOL]     if (dataset == null) { [EOL]         throw new IllegalArgumentException("Null 'dataset' argument."); [EOL]     } [EOL]     boolean allItemsNull = true; [EOL]     double minimum = 0.0; [EOL]     double maximum = 0.0; [EOL]     for (int row = 0; row < dataset.getRowCount(); row++) { [EOL]         double runningTotal = 0.0; [EOL]         for (int column = 0; column <= dataset.getColumnCount() - 1; column++) { [EOL]             Number n = dataset.getValue(row, column); [EOL]             if (n != null) { [EOL]                 allItemsNull = false; [EOL]                 double value = n.doubleValue(); [EOL]                 if (!Double.isNaN(value)) { [EOL]                     runningTotal = runningTotal + value; [EOL]                     minimum = Math.min(minimum, runningTotal); [EOL]                     maximum = Math.max(maximum, runningTotal); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (!allItemsNull) { [EOL]         return new Range(minimum, maximum); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] } <line_num>: 2148,2178
