public PiePlot() { [EOL]     this(null); [EOL] } <line_num>: 565,567
public PiePlot(PieDataset dataset) { [EOL]     super(); [EOL]     this.dataset = dataset; [EOL]     if (dataset != null) { [EOL]         dataset.addChangeListener(this); [EOL]     } [EOL]     this.pieIndex = 0; [EOL]     this.interiorGap = DEFAULT_INTERIOR_GAP; [EOL]     this.circular = true; [EOL]     this.startAngle = DEFAULT_START_ANGLE; [EOL]     this.direction = Rotation.CLOCKWISE; [EOL]     this.minimumArcAngleToDraw = DEFAULT_MINIMUM_ARC_ANGLE_TO_DRAW; [EOL]     this.sectionPaintMap = new PaintMap(); [EOL]     this.baseSectionPaint = Color.gray; [EOL]     this.autoPopulateSectionPaint = true; [EOL]     this.sectionOutlinesVisible = true; [EOL]     this.sectionOutlinePaintMap = new PaintMap(); [EOL]     this.baseSectionOutlinePaint = DEFAULT_OUTLINE_PAINT; [EOL]     this.autoPopulateSectionOutlinePaint = false; [EOL]     this.sectionOutlineStrokeMap = new StrokeMap(); [EOL]     this.baseSectionOutlineStroke = DEFAULT_OUTLINE_STROKE; [EOL]     this.autoPopulateSectionOutlineStroke = false; [EOL]     this.explodePercentages = new TreeMap(); [EOL]     this.labelGenerator = new StandardPieSectionLabelGenerator(); [EOL]     this.labelFont = DEFAULT_LABEL_FONT; [EOL]     this.labelPaint = DEFAULT_LABEL_PAINT; [EOL]     this.labelBackgroundPaint = DEFAULT_LABEL_BACKGROUND_PAINT; [EOL]     this.labelOutlinePaint = DEFAULT_LABEL_OUTLINE_PAINT; [EOL]     this.labelOutlineStroke = DEFAULT_LABEL_OUTLINE_STROKE; [EOL]     this.labelShadowPaint = DEFAULT_LABEL_SHADOW_PAINT; [EOL]     this.labelLinksVisible = true; [EOL]     this.labelDistributor = new PieLabelDistributor(0); [EOL]     this.simpleLabels = false; [EOL]     this.simpleLabelOffset = new RectangleInsets(UnitType.RELATIVE, 0.18, 0.18, 0.18, 0.18); [EOL]     this.labelPadding = new RectangleInsets(2, 2, 2, 2); [EOL]     this.toolTipGenerator = null; [EOL]     this.urlGenerator = null; [EOL]     this.legendLabelGenerator = new StandardPieSectionLabelGenerator(); [EOL]     this.legendLabelToolTipGenerator = null; [EOL]     this.legendLabelURLGenerator = null; [EOL]     this.legendItemShape = Plot.DEFAULT_LEGEND_ITEM_CIRCLE; [EOL]     this.ignoreNullValues = false; [EOL]     this.ignoreZeroValues = false; [EOL]     this.selectedItemAttributes = new PieSelectionAttributes(); [EOL]     this.shadowGenerator = new DefaultShadowGenerator(); [EOL] } <line_num>: 574,630
public PieDataset getDataset() { [EOL]     return this.dataset; [EOL] } <line_num>: 639,641
public void setDataset(PieDataset dataset) { [EOL]     PieDataset existing = this.dataset; [EOL]     if (existing != null) { [EOL]         existing.removeChangeListener(this); [EOL]     } [EOL]     this.dataset = dataset; [EOL]     if (dataset != null) { [EOL]         setDatasetGroup(dataset.getGroup()); [EOL]         dataset.addChangeListener(this); [EOL]     } [EOL]     DatasetChangeEvent event = new DatasetChangeEvent(this, dataset, new PieDatasetChangeInfo(PieDatasetChangeType.UPDATE, -1, -1)); [EOL]     datasetChanged(event); [EOL] } <line_num>: 650,669
public int getPieIndex() { [EOL]     return this.pieIndex; [EOL] } <line_num>: 679,681
public void setPieIndex(int index) { [EOL]     this.pieIndex = index; [EOL] } <line_num>: 691,693
public double getStartAngle() { [EOL]     return this.startAngle; [EOL] } <line_num>: 703,705
public void setStartAngle(double angle) { [EOL]     this.startAngle = angle; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 717,720
public Rotation getDirection() { [EOL]     return this.direction; [EOL] } <line_num>: 730,732
public void setDirection(Rotation direction) { [EOL]     if (direction == null) { [EOL]         throw new IllegalArgumentException("Null 'direction' argument."); [EOL]     } [EOL]     this.direction = direction; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 742,749
public double getInteriorGap() { [EOL]     return this.interiorGap; [EOL] } <line_num>: 759,761
public void setInteriorGap(double percent) { [EOL]     if ((percent < 0.0) || (percent > MAX_INTERIOR_GAP)) { [EOL]         throw new IllegalArgumentException("Invalid 'percent' (" + percent + ") argument."); [EOL]     } [EOL]     if (this.interiorGap != percent) { [EOL]         this.interiorGap = percent; [EOL]         fireChangeEvent(); [EOL]     } [EOL] } <line_num>: 773,785
public boolean isCircular() { [EOL]     return this.circular; [EOL] } <line_num>: 795,797
public void setCircular(boolean flag) { [EOL]     setCircular(flag, true); [EOL] } <line_num>: 807,809
public void setCircular(boolean circular, boolean notify) { [EOL]     this.circular = circular; [EOL]     if (notify) { [EOL]         fireChangeEvent(); [EOL]     } [EOL] } <line_num>: 820,825
public boolean getIgnoreNullValues() { [EOL]     return this.ignoreNullValues; [EOL] } <line_num>: 835,837
public void setIgnoreNullValues(boolean flag) { [EOL]     this.ignoreNullValues = flag; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 850,853
public boolean getIgnoreZeroValues() { [EOL]     return this.ignoreZeroValues; [EOL] } <line_num>: 863,865
public void setIgnoreZeroValues(boolean flag) { [EOL]     this.ignoreZeroValues = flag; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 878,881
protected Paint lookupSectionPaint(Comparable key, boolean selected) { [EOL]     Paint result = null; [EOL]     if (selected) { [EOL]         result = this.selectedItemAttributes.lookupSectionPaint(key); [EOL]     } [EOL]     if (result == null) { [EOL]         result = lookupSectionPaint(key, selected, getAutoPopulateSectionPaint()); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 898,908
protected Paint lookupSectionPaint(Comparable key, boolean selected, boolean autoPopulate) { [EOL]     if (selected) { [EOL]     } [EOL]     Paint result = null; [EOL]     result = this.sectionPaintMap.getPaint(key); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (autoPopulate) { [EOL]         DrawingSupplier ds = getDrawingSupplier(); [EOL]         if (ds != null) { [EOL]             result = ds.getNextPaint(); [EOL]             this.sectionPaintMap.put(key, result); [EOL]         } else { [EOL]             result = this.baseSectionPaint; [EOL]         } [EOL]     } else { [EOL]         result = this.baseSectionPaint; [EOL]     } [EOL]     return result; [EOL] } <line_num>: 931,960
protected Comparable getSectionKey(int section) { [EOL]     Comparable key = null; [EOL]     if (this.dataset != null) { [EOL]         if (section >= 0 && section < this.dataset.getItemCount()) { [EOL]             key = this.dataset.getKey(section); [EOL]         } [EOL]     } [EOL]     if (key == null) { [EOL]         key = new Integer(section); [EOL]     } [EOL]     return key; [EOL] } <line_num>: 976,987
public Paint getSectionPaint(Comparable key, boolean selected) { [EOL]     if (selected) { [EOL]         return Color.white; [EOL]     } [EOL]     return this.sectionPaintMap.getPaint(key); [EOL] } <line_num>: 1005,1011
public void setSectionPaint(Comparable key, Paint paint) { [EOL]     this.sectionPaintMap.put(key, paint); [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1027,1031
public void clearSectionPaints(boolean notify) { [EOL]     this.sectionPaintMap.clear(); [EOL]     if (notify) { [EOL]         fireChangeEvent(); [EOL]     } [EOL] } <line_num>: 1045,1050
public Paint getBaseSectionPaint() { [EOL]     return this.baseSectionPaint; [EOL] } <line_num>: 1060,1062
public void setBaseSectionPaint(Paint paint) { [EOL]     if (paint == null) { [EOL]         throw new IllegalArgumentException("Null 'paint' argument."); [EOL]     } [EOL]     this.baseSectionPaint = paint; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1072,1078
public boolean getAutoPopulateSectionPaint() { [EOL]     return this.autoPopulateSectionPaint; [EOL] } <line_num>: 1088,1090
public void setAutoPopulateSectionPaint(boolean auto) { [EOL]     this.autoPopulateSectionPaint = auto; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1101,1104
public boolean getSectionOutlinesVisible() { [EOL]     return this.sectionOutlinesVisible; [EOL] } <line_num>: 1117,1119
public void setSectionOutlinesVisible(boolean visible) { [EOL]     this.sectionOutlinesVisible = visible; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1130,1133
protected Paint lookupSectionOutlinePaint(Comparable key, boolean selected) { [EOL]     Paint result = null; [EOL]     if (selected) { [EOL]         result = this.selectedItemAttributes.lookupSectionOutlinePaint(key); [EOL]     } [EOL]     if (result == null) { [EOL]         result = lookupSectionOutlinePaint(key, selected, getAutoPopulateSectionOutlinePaint()); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1149,1160
protected Paint lookupSectionOutlinePaint(Comparable key, boolean selected, boolean autoPopulate) { [EOL]     Paint result = null; [EOL]     if (selected) { [EOL]         return Color.WHITE; [EOL]     } [EOL]     result = this.sectionOutlinePaintMap.getPaint(key); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (autoPopulate) { [EOL]         DrawingSupplier ds = getDrawingSupplier(); [EOL]         if (ds != null) { [EOL]             result = ds.getNextOutlinePaint(); [EOL]             this.sectionOutlinePaintMap.put(key, result); [EOL]         } else { [EOL]             result = this.baseSectionOutlinePaint; [EOL]         } [EOL]     } else { [EOL]         result = this.baseSectionOutlinePaint; [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1184,1213
public Paint getSectionOutlinePaint(Comparable key) { [EOL]     return this.sectionOutlinePaintMap.getPaint(key); [EOL] } <line_num>: 1231,1234
public void setSectionOutlinePaint(Comparable key, Paint paint) { [EOL]     this.sectionOutlinePaintMap.put(key, paint); [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1250,1254
public void clearSectionOutlinePaints(boolean notify) { [EOL]     this.sectionOutlinePaintMap.clear(); [EOL]     if (notify) { [EOL]         fireChangeEvent(); [EOL]     } [EOL] } <line_num>: 1268,1273
public Paint getBaseSectionOutlinePaint() { [EOL]     return this.baseSectionOutlinePaint; [EOL] } <line_num>: 1283,1285
public void setBaseSectionOutlinePaint(Paint paint) { [EOL]     if (paint == null) { [EOL]         throw new IllegalArgumentException("Null 'paint' argument."); [EOL]     } [EOL]     this.baseSectionOutlinePaint = paint; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1294,1300
public boolean getAutoPopulateSectionOutlinePaint() { [EOL]     return this.autoPopulateSectionOutlinePaint; [EOL] } <line_num>: 1311,1313
public void setAutoPopulateSectionOutlinePaint(boolean auto) { [EOL]     this.autoPopulateSectionOutlinePaint = auto; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1324,1327
protected Stroke lookupSectionOutlineStroke(Comparable key, boolean selected) { [EOL]     Stroke s = null; [EOL]     if (selected) { [EOL]         s = this.selectedItemAttributes.lookupSectionOutlineStroke(key); [EOL]     } [EOL]     if (s == null) { [EOL]         s = lookupSectionOutlineStroke(key, selected, getAutoPopulateSectionOutlineStroke()); [EOL]     } [EOL]     return s; [EOL] } <line_num>: 1345,1356
protected Stroke lookupSectionOutlineStroke(Comparable key, boolean selected, boolean autoPopulate) { [EOL]     Stroke result = null; [EOL]     result = this.sectionOutlineStrokeMap.getStroke(key); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (autoPopulate) { [EOL]         DrawingSupplier ds = getDrawingSupplier(); [EOL]         if (ds != null) { [EOL]             result = ds.getNextOutlineStroke(); [EOL]             this.sectionOutlineStrokeMap.put(key, result); [EOL]         } else { [EOL]             result = this.baseSectionOutlineStroke; [EOL]         } [EOL]     } else { [EOL]         result = this.baseSectionOutlineStroke; [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1380,1406
public Stroke getSectionOutlineStroke(Comparable key) { [EOL]     return this.sectionOutlineStrokeMap.getStroke(key); [EOL] } <line_num>: 1424,1427
public void setSectionOutlineStroke(Comparable key, Stroke stroke) { [EOL]     this.sectionOutlineStrokeMap.put(key, stroke); [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1443,1447
public void clearSectionOutlineStrokes(boolean notify) { [EOL]     this.sectionOutlineStrokeMap.clear(); [EOL]     if (notify) { [EOL]         fireChangeEvent(); [EOL]     } [EOL] } <line_num>: 1461,1466
public Stroke getBaseSectionOutlineStroke() { [EOL]     return this.baseSectionOutlineStroke; [EOL] } <line_num>: 1476,1478
public void setBaseSectionOutlineStroke(Stroke stroke) { [EOL]     if (stroke == null) { [EOL]         throw new IllegalArgumentException("Null 'stroke' argument."); [EOL]     } [EOL]     this.baseSectionOutlineStroke = stroke; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1487,1493
public boolean getAutoPopulateSectionOutlineStroke() { [EOL]     return this.autoPopulateSectionOutlineStroke; [EOL] } <line_num>: 1504,1506
public void setAutoPopulateSectionOutlineStroke(boolean auto) { [EOL]     this.autoPopulateSectionOutlineStroke = auto; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1517,1520
public Paint getShadowPaint() { [EOL]     return this.shadowPaint; [EOL] } <line_num>: 1529,1531
public void setShadowPaint(Paint paint) { [EOL]     this.shadowPaint = paint; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1541,1544
public double getShadowXOffset() { [EOL]     return this.shadowXOffset; [EOL] } <line_num>: 1553,1555
public void setShadowXOffset(double offset) { [EOL]     this.shadowXOffset = offset; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1565,1568
public double getShadowYOffset() { [EOL]     return this.shadowYOffset; [EOL] } <line_num>: 1577,1579
public void setShadowYOffset(double offset) { [EOL]     this.shadowYOffset = offset; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1589,1592
public double getExplodePercent(Comparable key) { [EOL]     double result = 0.0; [EOL]     if (this.explodePercentages != null) { [EOL]         Number percent = (Number) this.explodePercentages.get(key); [EOL]         if (percent != null) { [EOL]             result = percent.doubleValue(); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1610,1619
public void setExplodePercent(Comparable key, double percent) { [EOL]     if (key == null) { [EOL]         throw new IllegalArgumentException("Null 'key' argument."); [EOL]     } [EOL]     if (this.explodePercentages == null) { [EOL]         this.explodePercentages = new TreeMap(); [EOL]     } [EOL]     this.explodePercentages.put(key, new Double(percent)); [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1632,1641
public double getMaximumExplodePercent() { [EOL]     if (this.dataset == null) { [EOL]         return 0.0; [EOL]     } [EOL]     double result = 0.0; [EOL]     Iterator iterator = this.dataset.getKeys().iterator(); [EOL]     while (iterator.hasNext()) { [EOL]         Comparable key = (Comparable) iterator.next(); [EOL]         Number explode = (Number) this.explodePercentages.get(key); [EOL]         if (explode != null) { [EOL]             result = Math.max(result, explode.doubleValue()); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1648,1662
public PieSectionLabelGenerator getLabelGenerator() { [EOL]     return this.labelGenerator; [EOL] } <line_num>: 1671,1673
public void setLabelGenerator(PieSectionLabelGenerator generator) { [EOL]     this.labelGenerator = generator; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1683,1686
public double getLabelGap() { [EOL]     return this.labelGap; [EOL] } <line_num>: 1696,1698
public void setLabelGap(double gap) { [EOL]     this.labelGap = gap; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1709,1712
public double getMaximumLabelWidth() { [EOL]     return this.maximumLabelWidth; [EOL] } <line_num>: 1721,1723
public void setMaximumLabelWidth(double width) { [EOL]     this.maximumLabelWidth = width; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1733,1736
public boolean getLabelLinksVisible() { [EOL]     return this.labelLinksVisible; [EOL] } <line_num>: 1746,1748
public void setLabelLinksVisible(boolean visible) { [EOL]     this.labelLinksVisible = visible; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1761,1764
public PieLabelLinkStyle getLabelLinkStyle() { [EOL]     return this.labelLinkStyle; [EOL] } <line_num>: 1775,1777
public void setLabelLinkStyle(PieLabelLinkStyle style) { [EOL]     if (style == null) { [EOL]         throw new IllegalArgumentException("Null 'style' argument."); [EOL]     } [EOL]     this.labelLinkStyle = style; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1789,1795
public double getLabelLinkMargin() { [EOL]     return this.labelLinkMargin; [EOL] } <line_num>: 1805,1807
public void setLabelLinkMargin(double margin) { [EOL]     this.labelLinkMargin = margin; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1817,1820
public Paint getLabelLinkPaint() { [EOL]     return this.labelLinkPaint; [EOL] } <line_num>: 1830,1832
public void setLabelLinkPaint(Paint paint) { [EOL]     if (paint == null) { [EOL]         throw new IllegalArgumentException("Null 'paint' argument."); [EOL]     } [EOL]     this.labelLinkPaint = paint; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1843,1849
public Stroke getLabelLinkStroke() { [EOL]     return this.labelLinkStroke; [EOL] } <line_num>: 1858,1860
public void setLabelLinkStroke(Stroke stroke) { [EOL]     if (stroke == null) { [EOL]         throw new IllegalArgumentException("Null 'stroke' argument."); [EOL]     } [EOL]     this.labelLinkStroke = stroke; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1870,1876
protected double getLabelLinkDepth() { [EOL]     return 0.1; [EOL] } <line_num>: 1889,1891
public Font getLabelFont() { [EOL]     return this.labelFont; [EOL] } <line_num>: 1900,1902
public void setLabelFont(Font font) { [EOL]     if (font == null) { [EOL]         throw new IllegalArgumentException("Null 'font' argument."); [EOL]     } [EOL]     this.labelFont = font; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1912,1918
public Paint getLabelPaint() { [EOL]     return this.labelPaint; [EOL] } <line_num>: 1927,1929
public void setLabelPaint(Paint paint) { [EOL]     if (paint == null) { [EOL]         throw new IllegalArgumentException("Null 'paint' argument."); [EOL]     } [EOL]     this.labelPaint = paint; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1939,1945
public Paint getLabelBackgroundPaint() { [EOL]     return this.labelBackgroundPaint; [EOL] } <line_num>: 1954,1956
public void setLabelBackgroundPaint(Paint paint) { [EOL]     this.labelBackgroundPaint = paint; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1966,1969
public Paint getLabelOutlinePaint() { [EOL]     return this.labelOutlinePaint; [EOL] } <line_num>: 1978,1980
public void setLabelOutlinePaint(Paint paint) { [EOL]     this.labelOutlinePaint = paint; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1990,1993
public Stroke getLabelOutlineStroke() { [EOL]     return this.labelOutlineStroke; [EOL] } <line_num>: 2002,2004
public void setLabelOutlineStroke(Stroke stroke) { [EOL]     this.labelOutlineStroke = stroke; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 2014,2017
public Paint getLabelShadowPaint() { [EOL]     return this.labelShadowPaint; [EOL] } <line_num>: 2026,2028
public void setLabelShadowPaint(Paint paint) { [EOL]     this.labelShadowPaint = paint; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 2038,2041
public RectangleInsets getLabelPadding() { [EOL]     return this.labelPadding; [EOL] } <line_num>: 2052,2054
public void setLabelPadding(RectangleInsets padding) { [EOL]     if (padding == null) { [EOL]         throw new IllegalArgumentException("Null 'padding' argument."); [EOL]     } [EOL]     this.labelPadding = padding; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 2066,2072
public boolean getSimpleLabels() { [EOL]     return this.simpleLabels; [EOL] } <line_num>: 2082,2084
public void setSimpleLabels(boolean simple) { [EOL]     this.simpleLabels = simple; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 2095,2098
public RectangleInsets getSimpleLabelOffset() { [EOL]     return this.simpleLabelOffset; [EOL] } <line_num>: 2109,2111
public void setSimpleLabelOffset(RectangleInsets offset) { [EOL]     if (offset == null) { [EOL]         throw new IllegalArgumentException("Null 'offset' argument."); [EOL]     } [EOL]     this.simpleLabelOffset = offset; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 2123,2129
public AbstractPieLabelDistributor getLabelDistributor() { [EOL]     return this.labelDistributor; [EOL] } <line_num>: 2139,2141
public void setLabelDistributor(AbstractPieLabelDistributor distributor) { [EOL]     if (distributor == null) { [EOL]         throw new IllegalArgumentException("Null 'distributor' argument."); [EOL]     } [EOL]     this.labelDistributor = distributor; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 2151,2157
public PieToolTipGenerator getToolTipGenerator() { [EOL]     return this.toolTipGenerator; [EOL] } <line_num>: 2168,2170
public void setToolTipGenerator(PieToolTipGenerator generator) { [EOL]     this.toolTipGenerator = generator; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 2181,2184
public PieURLGenerator getURLGenerator() { [EOL]     return this.urlGenerator; [EOL] } <line_num>: 2193,2195
public void setURLGenerator(PieURLGenerator generator) { [EOL]     this.urlGenerator = generator; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 2205,2208
public double getMinimumArcAngleToDraw() { [EOL]     return this.minimumArcAngleToDraw; [EOL] } <line_num>: 2218,2220
public void setMinimumArcAngleToDraw(double angle) { [EOL]     this.minimumArcAngleToDraw = angle; [EOL] } <line_num>: 2240,2242
public Shape getLegendItemShape() { [EOL]     return this.legendItemShape; [EOL] } <line_num>: 2251,2253
public void setLegendItemShape(Shape shape) { [EOL]     if (shape == null) { [EOL]         throw new IllegalArgumentException("Null 'shape' argument."); [EOL]     } [EOL]     this.legendItemShape = shape; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 2263,2269
public PieSectionLabelGenerator getLegendLabelGenerator() { [EOL]     return this.legendLabelGenerator; [EOL] } <line_num>: 2278,2280
public void setLegendLabelGenerator(PieSectionLabelGenerator generator) { [EOL]     if (generator == null) { [EOL]         throw new IllegalArgumentException("Null 'generator' argument."); [EOL]     } [EOL]     this.legendLabelGenerator = generator; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 2290,2296
public PieSectionLabelGenerator getLegendLabelToolTipGenerator() { [EOL]     return this.legendLabelToolTipGenerator; [EOL] } <line_num>: 2305,2307
public void setLegendLabelToolTipGenerator(PieSectionLabelGenerator generator) { [EOL]     this.legendLabelToolTipGenerator = generator; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 2317,2321
public PieURLGenerator getLegendLabelURLGenerator() { [EOL]     return this.legendLabelURLGenerator; [EOL] } <line_num>: 2332,2334
public void setLegendLabelURLGenerator(PieURLGenerator generator) { [EOL]     this.legendLabelURLGenerator = generator; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 2346,2349
public ShadowGenerator getShadowGenerator() { [EOL]     return this.shadowGenerator; [EOL] } <line_num>: 2358,2360
public void setShadowGenerator(ShadowGenerator generator) { [EOL]     this.shadowGenerator = generator; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 2373,2376
public void handleMouseWheelRotation(int rotateClicks) { [EOL]     setStartAngle(this.startAngle + rotateClicks * 4.0); [EOL] } <line_num>: 2386,2388
public PiePlotState initialise(Graphics2D g2, Rectangle2D plotArea, PiePlot plot, Integer index, PlotRenderingInfo info) { [EOL]     PiePlotState state = new PiePlotState(info); [EOL]     state.setPassesRequired(2); [EOL]     if (this.dataset != null) { [EOL]         state.setTotal(DatasetUtilities.calculatePieDatasetTotal(plot.getDataset())); [EOL]     } [EOL]     state.setLatestAngle(plot.getStartAngle()); [EOL]     return state; [EOL] } <line_num>: 2405,2417
public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo info) { [EOL]     RectangleInsets insets = getInsets(); [EOL]     insets.trim(area); [EOL]     if (info != null) { [EOL]         info.setPlotArea(area); [EOL]         info.setDataArea(area); [EOL]     } [EOL]     drawBackground(g2, area); [EOL]     drawOutline(g2, area); [EOL]     Shape savedClip = g2.getClip(); [EOL]     g2.clip(area); [EOL]     Composite originalComposite = g2.getComposite(); [EOL]     g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, getForegroundAlpha())); [EOL]     if (!DatasetUtilities.isEmptyOrNull(this.dataset)) { [EOL]         Graphics2D savedG2 = g2; [EOL]         Rectangle2D savedDataArea = area; [EOL]         BufferedImage dataImage = null; [EOL]         if (this.shadowGenerator != null) { [EOL]             dataImage = new BufferedImage((int) area.getWidth(), (int) area.getHeight(), BufferedImage.TYPE_INT_ARGB); [EOL]             g2 = dataImage.createGraphics(); [EOL]             g2.setRenderingHints(savedG2.getRenderingHints()); [EOL]             area = new Rectangle(0, 0, dataImage.getWidth(), dataImage.getHeight()); [EOL]         } [EOL]         drawPie(g2, area, info); [EOL]         if (this.shadowGenerator != null) { [EOL]             BufferedImage shadowImage = this.shadowGenerator.createDropShadow(dataImage); [EOL]             g2 = savedG2; [EOL]             area = savedDataArea; [EOL]             g2.drawImage(shadowImage, (int) savedDataArea.getX() + this.shadowGenerator.calculateOffsetX(), (int) savedDataArea.getY() + this.shadowGenerator.calculateOffsetY(), null); [EOL]             g2.drawImage(dataImage, (int) savedDataArea.getX(), (int) savedDataArea.getY(), null); [EOL]         } [EOL]     } else { [EOL]         drawNoDataMessage(g2, area); [EOL]     } [EOL]     g2.setClip(savedClip); [EOL]     g2.setComposite(originalComposite); [EOL]     drawOutline(g2, area); [EOL] } <line_num>: 2430,2485
private Rectangle2D[] calculateLinkAndExplodeAreas(Graphics2D g2, Rectangle2D plotArea) { [EOL]     Rectangle2D[] result = new Rectangle2D[2]; [EOL]     double labelReserve = 0.0; [EOL]     if (this.labelGenerator != null && !this.simpleLabels) { [EOL]         labelReserve = this.labelGap + this.maximumLabelWidth; [EOL]     } [EOL]     double gapHorizontal = plotArea.getWidth() * (this.interiorGap + labelReserve) * 2.0; [EOL]     double gapVertical = plotArea.getHeight() * this.interiorGap * 2.0; [EOL]     if (DEBUG_DRAW_INTERIOR) { [EOL]         double hGap = plotArea.getWidth() * this.interiorGap; [EOL]         double vGap = plotArea.getHeight() * this.interiorGap; [EOL]         double igx1 = plotArea.getX() + hGap; [EOL]         double igx2 = plotArea.getMaxX() - hGap; [EOL]         double igy1 = plotArea.getY() + vGap; [EOL]         double igy2 = plotArea.getMaxY() - vGap; [EOL]         g2.setPaint(Color.gray); [EOL]         g2.draw(new Rectangle2D.Double(igx1, igy1, igx2 - igx1, igy2 - igy1)); [EOL]     } [EOL]     double linkX = plotArea.getX() + gapHorizontal / 2; [EOL]     double linkY = plotArea.getY() + gapVertical / 2; [EOL]     double linkW = plotArea.getWidth() - gapHorizontal; [EOL]     double linkH = plotArea.getHeight() - gapVertical; [EOL]     if (this.circular) { [EOL]         double min = Math.min(linkW, linkH) / 2; [EOL]         linkX = (linkX + linkX + linkW) / 2 - min; [EOL]         linkY = (linkY + linkY + linkH) / 2 - min; [EOL]         linkW = 2 * min; [EOL]         linkH = 2 * min; [EOL]     } [EOL]     Rectangle2D linkArea = new Rectangle2D.Double(linkX, linkY, linkW, linkH); [EOL]     result[0] = linkArea; [EOL]     if (DEBUG_DRAW_LINK_AREA) { [EOL]         g2.setPaint(Color.blue); [EOL]         g2.draw(linkArea); [EOL]         g2.setPaint(Color.yellow); [EOL]         g2.draw(new Ellipse2D.Double(linkArea.getX(), linkArea.getY(), linkArea.getWidth(), linkArea.getHeight())); [EOL]     } [EOL]     double lm = 0.0; [EOL]     if (!this.simpleLabels) { [EOL]         lm = this.labelLinkMargin; [EOL]     } [EOL]     double hh = linkArea.getWidth() * lm * 2.0; [EOL]     double vv = linkArea.getHeight() * lm * 2.0; [EOL]     Rectangle2D explodeArea = new Rectangle2D.Double(linkX + hh / 2.0, linkY + vv / 2.0, linkW - hh, linkH - vv); [EOL]     result[1] = explodeArea; [EOL]     return result; [EOL] } <line_num>: 2487,2555
protected void drawPie(Graphics2D g2, Rectangle2D plotArea, PlotRenderingInfo info) { [EOL]     PiePlotState state = initialise(g2, plotArea, this, null, info); [EOL]     Rectangle2D[] areas = calculateLinkAndExplodeAreas(g2, plotArea); [EOL]     Rectangle2D linkArea = areas[0]; [EOL]     Rectangle2D explodeArea = areas[1]; [EOL]     state.setLinkArea(linkArea); [EOL]     state.setExplodedPieArea(explodeArea); [EOL]     double maximumExplodePercent = getMaximumExplodePercent(); [EOL]     double percent = maximumExplodePercent / (1.0 + maximumExplodePercent); [EOL]     double h1 = explodeArea.getWidth() * percent; [EOL]     double v1 = explodeArea.getHeight() * percent; [EOL]     Rectangle2D pieArea = new Rectangle2D.Double(explodeArea.getX() + h1 / 2.0, explodeArea.getY() + v1 / 2.0, explodeArea.getWidth() - h1, explodeArea.getHeight() - v1); [EOL]     if (DEBUG_DRAW_PIE_AREA) { [EOL]         g2.setPaint(Color.green); [EOL]         g2.draw(pieArea); [EOL]     } [EOL]     state.setPieArea(pieArea); [EOL]     state.setPieCenterX(pieArea.getCenterX()); [EOL]     state.setPieCenterY(pieArea.getCenterY()); [EOL]     state.setPieWRadius(pieArea.getWidth() / 2.0); [EOL]     state.setPieHRadius(pieArea.getHeight() / 2.0); [EOL]     if ((this.dataset != null) && (this.dataset.getKeys().size() > 0)) { [EOL]         PieDatasetSelectionState ss = findSelectionStateForDataset(this.dataset, state); [EOL]         List keys = this.dataset.getKeys(); [EOL]         double totalValue = DatasetUtilities.calculatePieDatasetTotal(this.dataset); [EOL]         int passesRequired = state.getPassesRequired(); [EOL]         for (int pass = 0; pass < passesRequired; pass++) { [EOL]             double runningTotal = 0.0; [EOL]             for (int section = 0; section < keys.size(); section++) { [EOL]                 Number n = this.dataset.getValue(section); [EOL]                 if (n != null) { [EOL]                     double value = n.doubleValue(); [EOL]                     if (value > 0.0) { [EOL]                         runningTotal += value; [EOL]                         boolean selected = false; [EOL]                         if (ss != null) { [EOL]                             selected = ss.isSelected(this.dataset.getKey(section)); [EOL]                         } [EOL]                         drawItem(g2, section, selected, explodeArea, state, pass); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (this.simpleLabels) { [EOL]             drawSimpleLabels(g2, keys, totalValue, plotArea, linkArea, state); [EOL]         } else { [EOL]             drawLabels(g2, keys, totalValue, plotArea, linkArea, state); [EOL]         } [EOL]     } else { [EOL]         drawNoDataMessage(g2, plotArea); [EOL]     } [EOL] } <line_num>: 2564,2637
protected void drawItem(Graphics2D g2, int section, boolean selected, Rectangle2D dataArea, PiePlotState state, int currentPass) { [EOL]     Number n = this.dataset.getValue(section); [EOL]     if (n == null) { [EOL]         return; [EOL]     } [EOL]     double value = n.doubleValue(); [EOL]     double angle1 = 0.0; [EOL]     double angle2 = 0.0; [EOL]     if (this.direction == Rotation.CLOCKWISE) { [EOL]         angle1 = state.getLatestAngle(); [EOL]         angle2 = angle1 - value / state.getTotal() * 360.0; [EOL]     } else if (this.direction == Rotation.ANTICLOCKWISE) { [EOL]         angle1 = state.getLatestAngle(); [EOL]         angle2 = angle1 + value / state.getTotal() * 360.0; [EOL]     } else { [EOL]         throw new IllegalStateException("Rotation type not recognised."); [EOL]     } [EOL]     double angle = (angle2 - angle1); [EOL]     if (Math.abs(angle) > getMinimumArcAngleToDraw()) { [EOL]         double ep = 0.0; [EOL]         double mep = getMaximumExplodePercent(); [EOL]         if (mep > 0.0) { [EOL]             ep = getExplodePercent(getSectionKey(section)) / mep; [EOL]         } [EOL]         Rectangle2D arcBounds = getArcBounds(state.getPieArea(), state.getExplodedPieArea(), angle1, angle, ep); [EOL]         Arc2D.Double arc = new Arc2D.Double(arcBounds, angle1, angle, Arc2D.PIE); [EOL]         if (currentPass == 0) { [EOL]             if (this.shadowPaint != null) { [EOL]                 Shape shadowArc = ShapeUtilities.createTranslatedShape(arc, (float) this.shadowXOffset, (float) this.shadowYOffset); [EOL]                 g2.setPaint(this.shadowPaint); [EOL]                 g2.fill(shadowArc); [EOL]             } [EOL]         } else if (currentPass == 1) { [EOL]             Comparable key = getSectionKey(section); [EOL]             Paint paint = lookupSectionPaint(key, selected); [EOL]             Shape savedClip = g2.getClip(); [EOL]             g2.clip(arc); [EOL]             g2.setPaint(paint); [EOL]             g2.fill(arc); [EOL]             Paint outlinePaint = lookupSectionOutlinePaint(key, selected); [EOL]             Stroke outlineStroke = lookupSectionOutlineStroke(key, selected); [EOL]             if (this.sectionOutlinesVisible) { [EOL]                 g2.setPaint(outlinePaint); [EOL]                 g2.setStroke(outlineStroke); [EOL]                 g2.draw(arc); [EOL]             } [EOL]             g2.setClip(savedClip); [EOL]             if (state.getInfo() != null) { [EOL]                 EntityCollection entities = state.getEntityCollection(); [EOL]                 if (entities != null) { [EOL]                     String tip = null; [EOL]                     if (this.toolTipGenerator != null) { [EOL]                         tip = this.toolTipGenerator.generateToolTip(this.dataset, key); [EOL]                     } [EOL]                     String url = null; [EOL]                     if (this.urlGenerator != null) { [EOL]                         url = this.urlGenerator.generateURL(this.dataset, key, this.pieIndex); [EOL]                     } [EOL]                     PieSectionEntity entity = new PieSectionEntity(arc, this.dataset, this.pieIndex, section, key, tip, url); [EOL]                     entities.add(entity); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     state.setLatestAngle(angle2); [EOL] } <line_num>: 2649,2735
protected void drawSimpleLabels(Graphics2D g2, List keys, double totalValue, Rectangle2D plotArea, Rectangle2D pieArea, PiePlotState state) { [EOL]     Composite originalComposite = g2.getComposite(); [EOL]     g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1.0f)); [EOL]     Rectangle2D labelsArea = this.simpleLabelOffset.createInsetRectangle(pieArea); [EOL]     double runningTotal = 0.0; [EOL]     Iterator iterator = keys.iterator(); [EOL]     while (iterator.hasNext()) { [EOL]         Comparable key = (Comparable) iterator.next(); [EOL]         boolean include = true; [EOL]         double v = 0.0; [EOL]         Number n = getDataset().getValue(key); [EOL]         if (n == null) { [EOL]             include = !getIgnoreNullValues(); [EOL]         } else { [EOL]             v = n.doubleValue(); [EOL]             include = getIgnoreZeroValues() ? v > 0.0 : v >= 0.0; [EOL]         } [EOL]         if (include) { [EOL]             runningTotal = runningTotal + v; [EOL]             double mid = getStartAngle() + (getDirection().getFactor() * ((runningTotal - v / 2.0) * 360) / totalValue); [EOL]             Arc2D arc = new Arc2D.Double(labelsArea, getStartAngle(), mid - getStartAngle(), Arc2D.OPEN); [EOL]             int x = (int) arc.getEndPoint().getX(); [EOL]             int y = (int) arc.getEndPoint().getY(); [EOL]             PieSectionLabelGenerator labelGenerator = getLabelGenerator(); [EOL]             if (labelGenerator == null) { [EOL]                 continue; [EOL]             } [EOL]             String label = labelGenerator.generateSectionLabel(this.dataset, key); [EOL]             if (label == null) { [EOL]                 continue; [EOL]             } [EOL]             g2.setFont(this.labelFont); [EOL]             FontMetrics fm = g2.getFontMetrics(); [EOL]             Rectangle2D bounds = TextUtilities.getTextBounds(label, g2, fm); [EOL]             Rectangle2D out = this.labelPadding.createOutsetRectangle(bounds); [EOL]             Shape bg = ShapeUtilities.createTranslatedShape(out, x - bounds.getCenterX(), y - bounds.getCenterY()); [EOL]             if (this.labelShadowPaint != null && this.shadowGenerator == null) { [EOL]                 Shape shadow = ShapeUtilities.createTranslatedShape(bg, this.shadowXOffset, this.shadowYOffset); [EOL]                 g2.setPaint(this.labelShadowPaint); [EOL]                 g2.fill(shadow); [EOL]             } [EOL]             if (this.labelBackgroundPaint != null) { [EOL]                 g2.setPaint(this.labelBackgroundPaint); [EOL]                 g2.fill(bg); [EOL]             } [EOL]             if (this.labelOutlinePaint != null && this.labelOutlineStroke != null) { [EOL]                 g2.setPaint(this.labelOutlinePaint); [EOL]                 g2.setStroke(this.labelOutlineStroke); [EOL]                 g2.draw(bg); [EOL]             } [EOL]             g2.setPaint(this.labelPaint); [EOL]             g2.setFont(this.labelFont); [EOL]             TextUtilities.drawAlignedString(getLabelGenerator().generateSectionLabel(getDataset(), key), g2, x, y, TextAnchor.CENTER); [EOL]         } [EOL]     } [EOL]     g2.setComposite(originalComposite); [EOL] } <line_num>: 2749,2831
protected void drawLabels(Graphics2D g2, List keys, double totalValue, Rectangle2D plotArea, Rectangle2D linkArea, PiePlotState state) { [EOL]     Composite originalComposite = g2.getComposite(); [EOL]     g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1.0f)); [EOL]     DefaultKeyedValues leftKeys = new DefaultKeyedValues(); [EOL]     DefaultKeyedValues rightKeys = new DefaultKeyedValues(); [EOL]     double runningTotal = 0.0; [EOL]     Iterator iterator = keys.iterator(); [EOL]     while (iterator.hasNext()) { [EOL]         Comparable key = (Comparable) iterator.next(); [EOL]         boolean include = true; [EOL]         double v = 0.0; [EOL]         Number n = this.dataset.getValue(key); [EOL]         if (n == null) { [EOL]             include = !this.ignoreNullValues; [EOL]         } else { [EOL]             v = n.doubleValue(); [EOL]             include = this.ignoreZeroValues ? v > 0.0 : v >= 0.0; [EOL]         } [EOL]         if (include) { [EOL]             runningTotal = runningTotal + v; [EOL]             double mid = this.startAngle + (this.direction.getFactor() * ((runningTotal - v / 2.0) * 360) / totalValue); [EOL]             if (Math.cos(Math.toRadians(mid)) < 0.0) { [EOL]                 leftKeys.addValue(key, new Double(mid)); [EOL]             } else { [EOL]                 rightKeys.addValue(key, new Double(mid)); [EOL]             } [EOL]         } [EOL]     } [EOL]     g2.setFont(getLabelFont()); [EOL]     double marginX = plotArea.getX() + this.interiorGap * plotArea.getWidth(); [EOL]     double gap = plotArea.getWidth() * this.labelGap; [EOL]     double ww = linkArea.getX() - gap - marginX; [EOL]     float labelWidth = (float) this.labelPadding.trimWidth(ww); [EOL]     if (this.labelGenerator != null) { [EOL]         drawLeftLabels(leftKeys, g2, plotArea, linkArea, labelWidth, state); [EOL]         drawRightLabels(rightKeys, g2, plotArea, linkArea, labelWidth, state); [EOL]     } [EOL]     g2.setComposite(originalComposite); [EOL] } <line_num>: 2843,2904
protected void drawLeftLabels(KeyedValues leftKeys, Graphics2D g2, Rectangle2D plotArea, Rectangle2D linkArea, float maxLabelWidth, PiePlotState state) { [EOL]     this.labelDistributor.clear(); [EOL]     double lGap = plotArea.getWidth() * this.labelGap; [EOL]     double verticalLinkRadius = state.getLinkArea().getHeight() / 2.0; [EOL]     for (int i = 0; i < leftKeys.getItemCount(); i++) { [EOL]         String label = this.labelGenerator.generateSectionLabel(this.dataset, leftKeys.getKey(i)); [EOL]         if (label != null) { [EOL]             TextBlock block = TextUtilities.createTextBlock(label, this.labelFont, this.labelPaint, maxLabelWidth, new G2TextMeasurer(g2)); [EOL]             TextBox labelBox = new TextBox(block); [EOL]             labelBox.setBackgroundPaint(this.labelBackgroundPaint); [EOL]             labelBox.setOutlinePaint(this.labelOutlinePaint); [EOL]             labelBox.setOutlineStroke(this.labelOutlineStroke); [EOL]             if (this.shadowGenerator == null) { [EOL]                 labelBox.setShadowPaint(this.labelShadowPaint); [EOL]             } else { [EOL]                 labelBox.setShadowPaint(null); [EOL]             } [EOL]             labelBox.setInteriorGap(this.labelPadding); [EOL]             double theta = Math.toRadians(leftKeys.getValue(i).doubleValue()); [EOL]             double baseY = state.getPieCenterY() - Math.sin(theta) * verticalLinkRadius; [EOL]             double hh = labelBox.getHeight(g2); [EOL]             this.labelDistributor.addPieLabelRecord(new PieLabelRecord(leftKeys.getKey(i), theta, baseY, labelBox, hh, lGap / 2.0 + lGap / 2.0 * -Math.cos(theta), 1.0 - getLabelLinkDepth() + getExplodePercent(leftKeys.getKey(i)))); [EOL]         } [EOL]     } [EOL]     double hh = plotArea.getHeight(); [EOL]     double gap = hh * getInteriorGap(); [EOL]     this.labelDistributor.distributeLabels(plotArea.getMinY() + gap, hh - 2 * gap); [EOL]     for (int i = 0; i < this.labelDistributor.getItemCount(); i++) { [EOL]         drawLeftLabel(g2, state, this.labelDistributor.getPieLabelRecord(i)); [EOL]     } [EOL] } <line_num>: 2918,2964
protected void drawRightLabels(KeyedValues keys, Graphics2D g2, Rectangle2D plotArea, Rectangle2D linkArea, float maxLabelWidth, PiePlotState state) { [EOL]     this.labelDistributor.clear(); [EOL]     double lGap = plotArea.getWidth() * this.labelGap; [EOL]     double verticalLinkRadius = state.getLinkArea().getHeight() / 2.0; [EOL]     for (int i = 0; i < keys.getItemCount(); i++) { [EOL]         String label = this.labelGenerator.generateSectionLabel(this.dataset, keys.getKey(i)); [EOL]         if (label != null) { [EOL]             TextBlock block = TextUtilities.createTextBlock(label, this.labelFont, this.labelPaint, maxLabelWidth, new G2TextMeasurer(g2)); [EOL]             TextBox labelBox = new TextBox(block); [EOL]             labelBox.setBackgroundPaint(this.labelBackgroundPaint); [EOL]             labelBox.setOutlinePaint(this.labelOutlinePaint); [EOL]             labelBox.setOutlineStroke(this.labelOutlineStroke); [EOL]             if (this.shadowGenerator == null) { [EOL]                 labelBox.setShadowPaint(this.labelShadowPaint); [EOL]             } else { [EOL]                 labelBox.setShadowPaint(null); [EOL]             } [EOL]             labelBox.setInteriorGap(this.labelPadding); [EOL]             double theta = Math.toRadians(keys.getValue(i).doubleValue()); [EOL]             double baseY = state.getPieCenterY() - Math.sin(theta) * verticalLinkRadius; [EOL]             double hh = labelBox.getHeight(g2); [EOL]             this.labelDistributor.addPieLabelRecord(new PieLabelRecord(keys.getKey(i), theta, baseY, labelBox, hh, lGap / 2.0 + lGap / 2.0 * Math.cos(theta), 1.0 - getLabelLinkDepth() + getExplodePercent(keys.getKey(i)))); [EOL]         } [EOL]     } [EOL]     double hh = plotArea.getHeight(); [EOL]     double gap = hh * getInteriorGap(); [EOL]     this.labelDistributor.distributeLabels(plotArea.getMinY() + gap, hh - 2 * gap); [EOL]     for (int i = 0; i < this.labelDistributor.getItemCount(); i++) { [EOL]         drawRightLabel(g2, state, this.labelDistributor.getPieLabelRecord(i)); [EOL]     } [EOL] } <line_num>: 2976,3024
public LegendItemCollection getLegendItems() { [EOL]     LegendItemCollection result = new LegendItemCollection(); [EOL]     if (this.dataset == null) { [EOL]         return result; [EOL]     } [EOL]     List keys = this.dataset.getKeys(); [EOL]     int section = 0; [EOL]     Shape shape = getLegendItemShape(); [EOL]     Iterator iterator = keys.iterator(); [EOL]     while (iterator.hasNext()) { [EOL]         Comparable key = (Comparable) iterator.next(); [EOL]         Number n = this.dataset.getValue(key); [EOL]         boolean include = true; [EOL]         if (n == null) { [EOL]             include = !this.ignoreNullValues; [EOL]         } else { [EOL]             double v = n.doubleValue(); [EOL]             if (v == 0.0) { [EOL]                 include = !this.ignoreZeroValues; [EOL]             } else { [EOL]                 include = v > 0.0; [EOL]             } [EOL]         } [EOL]         if (include) { [EOL]             String label = this.legendLabelGenerator.generateSectionLabel(this.dataset, key); [EOL]             if (label != null) { [EOL]                 String description = label; [EOL]                 String toolTipText = null; [EOL]                 if (this.legendLabelToolTipGenerator != null) { [EOL]                     toolTipText = this.legendLabelToolTipGenerator.generateSectionLabel(this.dataset, key); [EOL]                 } [EOL]                 String urlText = null; [EOL]                 if (this.legendLabelURLGenerator != null) { [EOL]                     urlText = this.legendLabelURLGenerator.generateURL(this.dataset, key, this.pieIndex); [EOL]                 } [EOL]                 Paint paint = lookupSectionPaint(key, false); [EOL]                 Paint outlinePaint = lookupSectionOutlinePaint(key, false); [EOL]                 Stroke outlineStroke = lookupSectionOutlineStroke(key, false); [EOL]                 LegendItem item = new LegendItem(label, description, toolTipText, urlText, true, shape, true, paint, true, outlinePaint, outlineStroke, false, new Line2D.Float(), new BasicStroke(), Color.black); [EOL]                 item.setDataset(getDataset()); [EOL]                 item.setSeriesIndex(this.dataset.getIndex(key)); [EOL]                 item.setSeriesKey(key); [EOL]                 result.add(item); [EOL]             } [EOL]             section++; [EOL]         } else { [EOL]             section++; [EOL]         } [EOL]     } [EOL]     return result; [EOL] } <line_num>: 3031,3093
public String getPlotType() { [EOL]     return localizationResources.getString("Pie_Plot"); [EOL] } <line_num>: 3100,3102
protected Rectangle2D getArcBounds(Rectangle2D unexploded, Rectangle2D exploded, double angle, double extent, double explodePercent) { [EOL]     if (explodePercent == 0.0) { [EOL]         return unexploded; [EOL]     } else { [EOL]         Arc2D arc1 = new Arc2D.Double(unexploded, angle, extent / 2, Arc2D.OPEN); [EOL]         Point2D point1 = arc1.getEndPoint(); [EOL]         Arc2D.Double arc2 = new Arc2D.Double(exploded, angle, extent / 2, Arc2D.OPEN); [EOL]         Point2D point2 = arc2.getEndPoint(); [EOL]         double deltaX = (point1.getX() - point2.getX()) * explodePercent; [EOL]         double deltaY = (point1.getY() - point2.getY()) * explodePercent; [EOL]         return new Rectangle2D.Double(unexploded.getX() - deltaX, unexploded.getY() - deltaY, unexploded.getWidth(), unexploded.getHeight()); [EOL]     } [EOL] } <line_num>: 3118,3139
protected void drawLeftLabel(Graphics2D g2, PiePlotState state, PieLabelRecord record) { [EOL]     double anchorX = state.getLinkArea().getMinX(); [EOL]     double targetX = anchorX - record.getGap(); [EOL]     double targetY = record.getAllocatedY(); [EOL]     if (this.labelLinksVisible) { [EOL]         double theta = record.getAngle(); [EOL]         double linkX = state.getPieCenterX() + Math.cos(theta) * state.getPieWRadius() * record.getLinkPercent(); [EOL]         double linkY = state.getPieCenterY() - Math.sin(theta) * state.getPieHRadius() * record.getLinkPercent(); [EOL]         double elbowX = state.getPieCenterX() + Math.cos(theta) * state.getLinkArea().getWidth() / 2.0; [EOL]         double elbowY = state.getPieCenterY() - Math.sin(theta) * state.getLinkArea().getHeight() / 2.0; [EOL]         double anchorY = elbowY; [EOL]         g2.setPaint(this.labelLinkPaint); [EOL]         g2.setStroke(this.labelLinkStroke); [EOL]         PieLabelLinkStyle style = getLabelLinkStyle(); [EOL]         if (style.equals(PieLabelLinkStyle.STANDARD)) { [EOL]             g2.draw(new Line2D.Double(linkX, linkY, elbowX, elbowY)); [EOL]             g2.draw(new Line2D.Double(anchorX, anchorY, elbowX, elbowY)); [EOL]             g2.draw(new Line2D.Double(anchorX, anchorY, targetX, targetY)); [EOL]         } else if (style.equals(PieLabelLinkStyle.QUAD_CURVE)) { [EOL]             QuadCurve2D q = new QuadCurve2D.Float(); [EOL]             q.setCurve(targetX, targetY, anchorX, anchorY, elbowX, elbowY); [EOL]             g2.draw(q); [EOL]             g2.draw(new Line2D.Double(elbowX, elbowY, linkX, linkY)); [EOL]         } else if (style.equals(PieLabelLinkStyle.CUBIC_CURVE)) { [EOL]             CubicCurve2D c = new CubicCurve2D.Float(); [EOL]             c.setCurve(targetX, targetY, anchorX, anchorY, elbowX, elbowY, linkX, linkY); [EOL]             g2.draw(c); [EOL]         } [EOL]     } [EOL]     TextBox tb = record.getLabel(); [EOL]     tb.draw(g2, (float) targetX, (float) targetY, RectangleAnchor.RIGHT); [EOL] } <line_num>: 3148,3190
protected void drawRightLabel(Graphics2D g2, PiePlotState state, PieLabelRecord record) { [EOL]     double anchorX = state.getLinkArea().getMaxX(); [EOL]     double targetX = anchorX + record.getGap(); [EOL]     double targetY = record.getAllocatedY(); [EOL]     if (this.labelLinksVisible) { [EOL]         double theta = record.getAngle(); [EOL]         double linkX = state.getPieCenterX() + Math.cos(theta) * state.getPieWRadius() * record.getLinkPercent(); [EOL]         double linkY = state.getPieCenterY() - Math.sin(theta) * state.getPieHRadius() * record.getLinkPercent(); [EOL]         double elbowX = state.getPieCenterX() + Math.cos(theta) * state.getLinkArea().getWidth() / 2.0; [EOL]         double elbowY = state.getPieCenterY() - Math.sin(theta) * state.getLinkArea().getHeight() / 2.0; [EOL]         double anchorY = elbowY; [EOL]         g2.setPaint(this.labelLinkPaint); [EOL]         g2.setStroke(this.labelLinkStroke); [EOL]         PieLabelLinkStyle style = getLabelLinkStyle(); [EOL]         if (style.equals(PieLabelLinkStyle.STANDARD)) { [EOL]             g2.draw(new Line2D.Double(linkX, linkY, elbowX, elbowY)); [EOL]             g2.draw(new Line2D.Double(anchorX, anchorY, elbowX, elbowY)); [EOL]             g2.draw(new Line2D.Double(anchorX, anchorY, targetX, targetY)); [EOL]         } else if (style.equals(PieLabelLinkStyle.QUAD_CURVE)) { [EOL]             QuadCurve2D q = new QuadCurve2D.Float(); [EOL]             q.setCurve(targetX, targetY, anchorX, anchorY, elbowX, elbowY); [EOL]             g2.draw(q); [EOL]             g2.draw(new Line2D.Double(elbowX, elbowY, linkX, linkY)); [EOL]         } else if (style.equals(PieLabelLinkStyle.CUBIC_CURVE)) { [EOL]             CubicCurve2D c = new CubicCurve2D.Float(); [EOL]             c.setCurve(targetX, targetY, anchorX, anchorY, elbowX, elbowY, linkX, linkY); [EOL]             g2.draw(c); [EOL]         } [EOL]     } [EOL]     TextBox tb = record.getLabel(); [EOL]     tb.draw(g2, (float) targetX, (float) targetY, RectangleAnchor.LEFT); [EOL] } <line_num>: 3199,3242
private PieDatasetSelectionState findSelectionStateForDataset(PieDataset dataset, Object source) { [EOL]     if (dataset instanceof SelectablePieDataset) { [EOL]         SelectablePieDataset sd = (SelectablePieDataset) dataset; [EOL]         PieDatasetSelectionState s = sd.getSelectionState(); [EOL]         return s; [EOL]     } [EOL]     throw new RuntimeException(); [EOL] } <line_num>: 3254,3263
public boolean canSelectByPoint() { [EOL]     return true; [EOL] } <line_num>: 3273,3275
public boolean canSelectByRegion() { [EOL]     return false; [EOL] } <line_num>: 3285,3287
public void select(double x, double y, Rectangle2D dataArea, RenderingSource source) { [EOL]     System.out.println("select " + x + ", " + y); [EOL]     PieDatasetSelectionState state = findSelectionStateForDataset(dataset, source); [EOL]     if (state == null) { [EOL]         return; [EOL]     } [EOL]     Rectangle2D[] areas = calculateLinkAndExplodeAreas(null, dataArea); [EOL]     Rectangle2D linkArea = areas[0]; [EOL]     Rectangle2D explodeArea = areas[1]; [EOL]     double maximumExplodePercent = getMaximumExplodePercent(); [EOL]     double percent = maximumExplodePercent / (1.0 + maximumExplodePercent); [EOL]     double h1 = explodeArea.getWidth() * percent; [EOL]     double v1 = explodeArea.getHeight() * percent; [EOL]     Rectangle2D pieArea = new Rectangle2D.Double(explodeArea.getX() + h1 / 2.0, explodeArea.getY() + v1 / 2.0, explodeArea.getWidth() - h1, explodeArea.getHeight() - v1); [EOL]     if ((this.dataset != null) && (this.dataset.getKeys().size() > 0)) { [EOL]         List keys = this.dataset.getKeys(); [EOL]         double total = DatasetUtilities.calculatePieDatasetTotal(this.dataset); [EOL]         double runningTotal = 0.0; [EOL]         for (int section = 0; section < keys.size(); section++) { [EOL]             Number n = this.dataset.getValue(section); [EOL]             if (n == null) { [EOL]                 continue; [EOL]             } [EOL]             double value = n.doubleValue(); [EOL]             if (value > 0.0) { [EOL]                 double angle0 = calculateAngleForValue(runningTotal, total); [EOL]                 double angle1 = calculateAngleForValue(runningTotal + value, total); [EOL]                 runningTotal += value; [EOL]                 System.out.println(this.dataset.getValue(section)); [EOL]                 System.out.println(angle0); [EOL]                 System.out.println(angle1); [EOL]                 double angle = (angle1 - angle0); [EOL]                 if (Math.abs(angle) > getMinimumArcAngleToDraw()) { [EOL]                     double ep = 0.0; [EOL]                     double mep = getMaximumExplodePercent(); [EOL]                     if (mep > 0.0) { [EOL]                         ep = getExplodePercent(getSectionKey(section)) / mep; [EOL]                     } [EOL]                     Rectangle2D arcBounds = getArcBounds(pieArea, explodeArea, angle0, angle, ep); [EOL]                     Arc2D.Double arc = new Arc2D.Double(arcBounds, angle0, angle, Arc2D.PIE); [EOL]                     if (arc.contains(x, y)) { [EOL]                         Comparable key = this.dataset.getKey(section); [EOL]                         state.setSelected(key, !state.isSelected(key)); [EOL]                         System.out.println(key + " is " + state.isSelected(key)); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 3297,3367
private double calculateAngleForValue(double value, double total) { [EOL]     if (this.direction == Rotation.CLOCKWISE) { [EOL]         return this.startAngle - (value / total * 360.0); [EOL]     } else if (this.direction == Rotation.ANTICLOCKWISE) { [EOL]         return this.startAngle + (value / total * 360.0); [EOL]     } [EOL]     throw new RuntimeException("Unrecognised Rotation type."); [EOL] } <line_num>: 3369,3377
public void select(GeneralPath region, Rectangle2D dataArea, RenderingSource source) { [EOL] } <line_num>: 3391,3394
public void clearSelection() { [EOL]     System.out.println("Clear selection."); [EOL] } <line_num>: 3401,3403
public Shape createHotSpotShape(Graphics2D g2, Rectangle2D dataArea, int section, boolean selected) { [EOL]     Number n = this.dataset.getValue(section); [EOL]     if (n == null) { [EOL]         return null; [EOL]     } [EOL]     double value = n.doubleValue(); [EOL]     double angle1 = 0.0; [EOL]     double angle2 = 0.0; [EOL]     double total = DatasetUtilities.calculatePieDatasetTotal(this.dataset); [EOL]     double lead = 0.0; [EOL]     if (this.direction == Rotation.CLOCKWISE) { [EOL]         for (int i = 0; i < section; i++) { [EOL]             n = this.dataset.getValue(i); [EOL]             if (n != null) { [EOL]                 value = n.doubleValue(); [EOL]                 if (value >= 0.0) { [EOL]                     lead = lead + value; [EOL]                 } [EOL]             } [EOL]         } [EOL]         angle1 = getStartAngle() - lead / total * 360.0; [EOL]         angle2 = angle1 - value / total * 360.0; [EOL]     } else if (this.direction == Rotation.ANTICLOCKWISE) { [EOL]         angle1 = getStartAngle() + lead / total * 360.0; [EOL]         angle2 = angle1 + value / total * 360.0; [EOL]     } else { [EOL]         throw new IllegalStateException("Rotation type not recognised."); [EOL]     } [EOL]     double angle = (angle2 - angle1); [EOL]     if (Math.abs(angle) > getMinimumArcAngleToDraw()) { [EOL]         double ep = 0.0; [EOL]         double mep = getMaximumExplodePercent(); [EOL]         if (mep > 0.0) { [EOL]             ep = getExplodePercent(getSectionKey(section)) / mep; [EOL]         } [EOL]         Rectangle2D arcBounds = getArcBounds(dataArea, dataArea, angle1, angle, ep); [EOL]         Arc2D.Double arc = new Arc2D.Double(arcBounds, angle1, angle, Arc2D.PIE); [EOL]         return arc; [EOL]     } [EOL]     return null; [EOL] } <line_num>: 3414,3462
public boolean equals(Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(obj instanceof PiePlot)) { [EOL]         return false; [EOL]     } [EOL]     if (!super.equals(obj)) { [EOL]         return false; [EOL]     } [EOL]     PiePlot that = (PiePlot) obj; [EOL]     if (this.pieIndex != that.pieIndex) { [EOL]         return false; [EOL]     } [EOL]     if (this.interiorGap != that.interiorGap) { [EOL]         return false; [EOL]     } [EOL]     if (this.circular != that.circular) { [EOL]         return false; [EOL]     } [EOL]     if (this.startAngle != that.startAngle) { [EOL]         return false; [EOL]     } [EOL]     if (this.direction != that.direction) { [EOL]         return false; [EOL]     } [EOL]     if (this.ignoreZeroValues != that.ignoreZeroValues) { [EOL]         return false; [EOL]     } [EOL]     if (this.ignoreNullValues != that.ignoreNullValues) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.sectionPaintMap, that.sectionPaintMap)) { [EOL]         return false; [EOL]     } [EOL]     if (!PaintUtilities.equal(this.baseSectionPaint, that.baseSectionPaint)) { [EOL]         return false; [EOL]     } [EOL]     if (this.sectionOutlinesVisible != that.sectionOutlinesVisible) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.sectionOutlinePaintMap, that.sectionOutlinePaintMap)) { [EOL]         return false; [EOL]     } [EOL]     if (!PaintUtilities.equal(this.baseSectionOutlinePaint, that.baseSectionOutlinePaint)) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.sectionOutlineStrokeMap, that.sectionOutlineStrokeMap)) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.baseSectionOutlineStroke, that.baseSectionOutlineStroke)) { [EOL]         return false; [EOL]     } [EOL]     if (!PaintUtilities.equal(this.shadowPaint, that.shadowPaint)) { [EOL]         return false; [EOL]     } [EOL]     if (!(this.shadowXOffset == that.shadowXOffset)) { [EOL]         return false; [EOL]     } [EOL]     if (!(this.shadowYOffset == that.shadowYOffset)) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.explodePercentages, that.explodePercentages)) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.labelGenerator, that.labelGenerator)) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.labelFont, that.labelFont)) { [EOL]         return false; [EOL]     } [EOL]     if (!PaintUtilities.equal(this.labelPaint, that.labelPaint)) { [EOL]         return false; [EOL]     } [EOL]     if (!PaintUtilities.equal(this.labelBackgroundPaint, that.labelBackgroundPaint)) { [EOL]         return false; [EOL]     } [EOL]     if (!PaintUtilities.equal(this.labelOutlinePaint, that.labelOutlinePaint)) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.labelOutlineStroke, that.labelOutlineStroke)) { [EOL]         return false; [EOL]     } [EOL]     if (!PaintUtilities.equal(this.labelShadowPaint, that.labelShadowPaint)) { [EOL]         return false; [EOL]     } [EOL]     if (this.simpleLabels != that.simpleLabels) { [EOL]         return false; [EOL]     } [EOL]     if (!this.simpleLabelOffset.equals(that.simpleLabelOffset)) { [EOL]         return false; [EOL]     } [EOL]     if (!this.labelPadding.equals(that.labelPadding)) { [EOL]         return false; [EOL]     } [EOL]     if (!(this.maximumLabelWidth == that.maximumLabelWidth)) { [EOL]         return false; [EOL]     } [EOL]     if (!(this.labelGap == that.labelGap)) { [EOL]         return false; [EOL]     } [EOL]     if (!(this.labelLinkMargin == that.labelLinkMargin)) { [EOL]         return false; [EOL]     } [EOL]     if (this.labelLinksVisible != that.labelLinksVisible) { [EOL]         return false; [EOL]     } [EOL]     if (!this.labelLinkStyle.equals(that.labelLinkStyle)) { [EOL]         return false; [EOL]     } [EOL]     if (!PaintUtilities.equal(this.labelLinkPaint, that.labelLinkPaint)) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.labelLinkStroke, that.labelLinkStroke)) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.toolTipGenerator, that.toolTipGenerator)) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.urlGenerator, that.urlGenerator)) { [EOL]         return false; [EOL]     } [EOL]     if (!(this.minimumArcAngleToDraw == that.minimumArcAngleToDraw)) { [EOL]         return false; [EOL]     } [EOL]     if (!ShapeUtilities.equal(this.legendItemShape, that.legendItemShape)) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.legendLabelGenerator, that.legendLabelGenerator)) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.legendLabelToolTipGenerator, that.legendLabelToolTipGenerator)) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.legendLabelURLGenerator, that.legendLabelURLGenerator)) { [EOL]         return false; [EOL]     } [EOL]     if (this.autoPopulateSectionPaint != that.autoPopulateSectionPaint) { [EOL]         return false; [EOL]     } [EOL]     if (this.autoPopulateSectionOutlinePaint != that.autoPopulateSectionOutlinePaint) { [EOL]         return false; [EOL]     } [EOL]     if (this.autoPopulateSectionOutlineStroke != that.autoPopulateSectionOutlineStroke) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.shadowGenerator, that.shadowGenerator)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } <line_num>: 3472,3643
public Object clone() throws CloneNotSupportedException { [EOL]     PiePlot clone = (PiePlot) super.clone(); [EOL]     if (clone.dataset != null) { [EOL]         clone.dataset.addChangeListener(clone); [EOL]     } [EOL]     if (this.urlGenerator instanceof PublicCloneable) { [EOL]         clone.urlGenerator = (PieURLGenerator) ObjectUtilities.clone(this.urlGenerator); [EOL]     } [EOL]     clone.legendItemShape = ShapeUtilities.clone(this.legendItemShape); [EOL]     if (this.legendLabelGenerator != null) { [EOL]         clone.legendLabelGenerator = (PieSectionLabelGenerator) ObjectUtilities.clone(this.legendLabelGenerator); [EOL]     } [EOL]     if (this.legendLabelToolTipGenerator != null) { [EOL]         clone.legendLabelToolTipGenerator = (PieSectionLabelGenerator) ObjectUtilities.clone(this.legendLabelToolTipGenerator); [EOL]     } [EOL]     if (this.legendLabelURLGenerator instanceof PublicCloneable) { [EOL]         clone.legendLabelURLGenerator = (PieURLGenerator) ObjectUtilities.clone(this.legendLabelURLGenerator); [EOL]     } [EOL]     return clone; [EOL] } <line_num>: 3653,3676
private void writeObject(ObjectOutputStream stream) throws IOException { [EOL]     stream.defaultWriteObject(); [EOL]     SerialUtilities.writePaint(this.baseSectionPaint, stream); [EOL]     SerialUtilities.writePaint(this.baseSectionOutlinePaint, stream); [EOL]     SerialUtilities.writeStroke(this.baseSectionOutlineStroke, stream); [EOL]     SerialUtilities.writePaint(this.shadowPaint, stream); [EOL]     SerialUtilities.writePaint(this.labelPaint, stream); [EOL]     SerialUtilities.writePaint(this.labelBackgroundPaint, stream); [EOL]     SerialUtilities.writePaint(this.labelOutlinePaint, stream); [EOL]     SerialUtilities.writeStroke(this.labelOutlineStroke, stream); [EOL]     SerialUtilities.writePaint(this.labelShadowPaint, stream); [EOL]     SerialUtilities.writePaint(this.labelLinkPaint, stream); [EOL]     SerialUtilities.writeStroke(this.labelLinkStroke, stream); [EOL]     SerialUtilities.writeShape(this.legendItemShape, stream); [EOL] } <line_num>: 3685,3699
private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException { [EOL]     stream.defaultReadObject(); [EOL]     this.baseSectionPaint = SerialUtilities.readPaint(stream); [EOL]     this.baseSectionOutlinePaint = SerialUtilities.readPaint(stream); [EOL]     this.baseSectionOutlineStroke = SerialUtilities.readStroke(stream); [EOL]     this.shadowPaint = SerialUtilities.readPaint(stream); [EOL]     this.labelPaint = SerialUtilities.readPaint(stream); [EOL]     this.labelBackgroundPaint = SerialUtilities.readPaint(stream); [EOL]     this.labelOutlinePaint = SerialUtilities.readPaint(stream); [EOL]     this.labelOutlineStroke = SerialUtilities.readStroke(stream); [EOL]     this.labelShadowPaint = SerialUtilities.readPaint(stream); [EOL]     this.labelLinkPaint = SerialUtilities.readPaint(stream); [EOL]     this.labelLinkStroke = SerialUtilities.readStroke(stream); [EOL]     this.legendItemShape = SerialUtilities.readShape(stream); [EOL] } <line_num>: 3709,3724
public PieSelectionAttributes getSelectedItemAttributes() { [EOL]     return this.selectedItemAttributes; [EOL] } <line_num>: 3726,3728
