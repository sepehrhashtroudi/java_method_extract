public CategoryPlot() { [EOL]     this(null, null, null, null); [EOL] } <line_num>: 566,568
public CategoryPlot(CategoryDataset dataset, CategoryAxis domainAxis, ValueAxis rangeAxis, CategoryItemRenderer renderer) { [EOL]     super(); [EOL]     this.orientation = PlotOrientation.VERTICAL; [EOL]     this.domainAxes = new ObjectList(); [EOL]     this.domainAxisLocations = new ObjectList(); [EOL]     this.rangeAxes = new ObjectList(); [EOL]     this.rangeAxisLocations = new ObjectList(); [EOL]     this.datasetToDomainAxesMap = new TreeMap(); [EOL]     this.datasetToRangeAxesMap = new TreeMap(); [EOL]     this.renderers = new ObjectList(); [EOL]     this.datasets = new ObjectList(); [EOL]     this.datasets.set(0, dataset); [EOL]     if (dataset != null) { [EOL]         dataset.addChangeListener(this); [EOL]     } [EOL]     this.axisOffset = new RectangleInsets(4.0, 4.0, 4.0, 4.0); [EOL]     setDomainAxisLocation(AxisLocation.BOTTOM_OR_LEFT, false); [EOL]     setRangeAxisLocation(AxisLocation.TOP_OR_LEFT, false); [EOL]     this.renderers.set(0, renderer); [EOL]     if (renderer != null) { [EOL]         renderer.setPlot(this); [EOL]         renderer.addChangeListener(this); [EOL]     } [EOL]     this.domainAxes.set(0, domainAxis); [EOL]     this.mapDatasetToDomainAxis(0, 0); [EOL]     if (domainAxis != null) { [EOL]         domainAxis.setPlot(this); [EOL]         domainAxis.addChangeListener(this); [EOL]     } [EOL]     this.drawSharedDomainAxis = false; [EOL]     this.rangeAxes.set(0, rangeAxis); [EOL]     this.mapDatasetToRangeAxis(0, 0); [EOL]     if (rangeAxis != null) { [EOL]         rangeAxis.setPlot(this); [EOL]         rangeAxis.addChangeListener(this); [EOL]     } [EOL]     configureDomainAxes(); [EOL]     configureRangeAxes(); [EOL]     this.domainGridlinesVisible = DEFAULT_DOMAIN_GRIDLINES_VISIBLE; [EOL]     this.domainGridlinePosition = CategoryAnchor.MIDDLE; [EOL]     this.domainGridlineStroke = DEFAULT_GRIDLINE_STROKE; [EOL]     this.domainGridlinePaint = DEFAULT_GRIDLINE_PAINT; [EOL]     this.rangeZeroBaselineVisible = false; [EOL]     this.rangeZeroBaselinePaint = Color.black; [EOL]     this.rangeZeroBaselineStroke = new BasicStroke(0.5f); [EOL]     this.rangeGridlinesVisible = DEFAULT_RANGE_GRIDLINES_VISIBLE; [EOL]     this.rangeGridlineStroke = DEFAULT_GRIDLINE_STROKE; [EOL]     this.rangeGridlinePaint = DEFAULT_GRIDLINE_PAINT; [EOL]     this.rangeMinorGridlinesVisible = false; [EOL]     this.rangeMinorGridlineStroke = DEFAULT_GRIDLINE_STROKE; [EOL]     this.rangeMinorGridlinePaint = Color.white; [EOL]     this.foregroundDomainMarkers = new HashMap(); [EOL]     this.backgroundDomainMarkers = new HashMap(); [EOL]     this.foregroundRangeMarkers = new HashMap(); [EOL]     this.backgroundRangeMarkers = new HashMap(); [EOL]     this.anchorValue = 0.0; [EOL]     this.domainCrosshairVisible = false; [EOL]     this.domainCrosshairStroke = DEFAULT_CROSSHAIR_STROKE; [EOL]     this.domainCrosshairPaint = DEFAULT_CROSSHAIR_PAINT; [EOL]     this.rangeCrosshairVisible = DEFAULT_CROSSHAIR_VISIBLE; [EOL]     this.rangeCrosshairValue = 0.0; [EOL]     this.rangeCrosshairStroke = DEFAULT_CROSSHAIR_STROKE; [EOL]     this.rangeCrosshairPaint = DEFAULT_CROSSHAIR_PAINT; [EOL]     this.annotations = new java.util.ArrayList(); [EOL]     this.rangePannable = false; [EOL]     this.shadowGenerator = new DefaultShadowGenerator(); [EOL] } <line_num>: 579,671
public String getPlotType() { [EOL]     return localizationResources.getString("Category_Plot"); [EOL] } <line_num>: 678,680
public PlotOrientation getOrientation() { [EOL]     return this.orientation; [EOL] } <line_num>: 689,691
public void setOrientation(PlotOrientation orientation) { [EOL]     if (orientation == null) { [EOL]         throw new IllegalArgumentException("Null 'orientation' argument."); [EOL]     } [EOL]     this.orientation = orientation; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 701,707
public RectangleInsets getAxisOffset() { [EOL]     return this.axisOffset; [EOL] } <line_num>: 716,718
public void setAxisOffset(RectangleInsets offset) { [EOL]     if (offset == null) { [EOL]         throw new IllegalArgumentException("Null 'offset' argument."); [EOL]     } [EOL]     this.axisOffset = offset; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 728,734
public CategoryAxis getDomainAxis() { [EOL]     return getDomainAxis(0); [EOL] } <line_num>: 745,747
public CategoryAxis getDomainAxis(int index) { [EOL]     CategoryAxis result = null; [EOL]     if (index < this.domainAxes.size()) { [EOL]         result = (CategoryAxis) this.domainAxes.get(index); [EOL]     } [EOL]     if (result == null) { [EOL]         Plot parent = getParent(); [EOL]         if (parent instanceof CategoryPlot) { [EOL]             CategoryPlot cp = (CategoryPlot) parent; [EOL]             result = cp.getDomainAxis(index); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } <line_num>: 758,771
public void setDomainAxis(CategoryAxis axis) { [EOL]     setDomainAxis(0, axis); [EOL] } <line_num>: 781,783
public void setDomainAxis(int index, CategoryAxis axis) { [EOL]     setDomainAxis(index, axis, true); [EOL] } <line_num>: 794,796
public void setDomainAxis(int index, CategoryAxis axis, boolean notify) { [EOL]     CategoryAxis existing = (CategoryAxis) this.domainAxes.get(index); [EOL]     if (existing != null) { [EOL]         existing.removeChangeListener(this); [EOL]     } [EOL]     if (axis != null) { [EOL]         axis.setPlot(this); [EOL]     } [EOL]     this.domainAxes.set(index, axis); [EOL]     if (axis != null) { [EOL]         axis.configure(); [EOL]         axis.addChangeListener(this); [EOL]     } [EOL]     if (notify) { [EOL]         fireChangeEvent(); [EOL]     } [EOL] } <line_num>: 806,822
public void setDomainAxes(CategoryAxis[] axes) { [EOL]     for (int i = 0; i < axes.length; i++) { [EOL]         setDomainAxis(i, axes[i], false); [EOL]     } [EOL]     fireChangeEvent(); [EOL] } <line_num>: 832,837
public int getDomainAxisIndex(CategoryAxis axis) { [EOL]     if (axis == null) { [EOL]         throw new IllegalArgumentException("Null 'axis' argument."); [EOL]     } [EOL]     return this.domainAxes.indexOf(axis); [EOL] } <line_num>: 852,857
public AxisLocation getDomainAxisLocation() { [EOL]     return getDomainAxisLocation(0); [EOL] } <line_num>: 866,868
public AxisLocation getDomainAxisLocation(int index) { [EOL]     AxisLocation result = null; [EOL]     if (index < this.domainAxisLocations.size()) { [EOL]         result = (AxisLocation) this.domainAxisLocations.get(index); [EOL]     } [EOL]     if (result == null) { [EOL]         result = AxisLocation.getOpposite(getDomainAxisLocation(0)); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 879,888
public void setDomainAxisLocation(AxisLocation location) { [EOL]     setDomainAxisLocation(0, location, true); [EOL] } <line_num>: 899,902
public void setDomainAxisLocation(AxisLocation location, boolean notify) { [EOL]     setDomainAxisLocation(0, location, notify); [EOL] } <line_num>: 911,914
public void setDomainAxisLocation(int index, AxisLocation location) { [EOL]     setDomainAxisLocation(index, location, true); [EOL] } <line_num>: 926,929
public void setDomainAxisLocation(int index, AxisLocation location, boolean notify) { [EOL]     if (index == 0 && location == null) { [EOL]         throw new IllegalArgumentException("Null 'location' for index 0 not permitted."); [EOL]     } [EOL]     this.domainAxisLocations.set(index, location); [EOL]     if (notify) { [EOL]         fireChangeEvent(); [EOL]     } [EOL] } <line_num>: 944,954
public RectangleEdge getDomainAxisEdge() { [EOL]     return getDomainAxisEdge(0); [EOL] } <line_num>: 962,964
public RectangleEdge getDomainAxisEdge(int index) { [EOL]     RectangleEdge result = null; [EOL]     AxisLocation location = getDomainAxisLocation(index); [EOL]     if (location != null) { [EOL]         result = Plot.resolveDomainAxisLocation(location, this.orientation); [EOL]     } else { [EOL]         result = RectangleEdge.opposite(getDomainAxisEdge(0)); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 973,983
public int getDomainAxisCount() { [EOL]     return this.domainAxes.size(); [EOL] } <line_num>: 990,992
public void clearDomainAxes() { [EOL]     for (int i = 0; i < this.domainAxes.size(); i++) { [EOL]         CategoryAxis axis = (CategoryAxis) this.domainAxes.get(i); [EOL]         if (axis != null) { [EOL]             axis.removeChangeListener(this); [EOL]         } [EOL]     } [EOL]     this.domainAxes.clear(); [EOL]     fireChangeEvent(); [EOL] } <line_num>: 998,1007
public void configureDomainAxes() { [EOL]     for (int i = 0; i < this.domainAxes.size(); i++) { [EOL]         CategoryAxis axis = (CategoryAxis) this.domainAxes.get(i); [EOL]         if (axis != null) { [EOL]             axis.configure(); [EOL]         } [EOL]     } [EOL] } <line_num>: 1012,1019
public ValueAxis getRangeAxis() { [EOL]     return getRangeAxis(0); [EOL] } <line_num>: 1028,1030
public ValueAxis getRangeAxis(int index) { [EOL]     ValueAxis result = null; [EOL]     if (index < this.rangeAxes.size()) { [EOL]         result = (ValueAxis) this.rangeAxes.get(index); [EOL]     } [EOL]     if (result == null) { [EOL]         Plot parent = getParent(); [EOL]         if (parent instanceof CategoryPlot) { [EOL]             CategoryPlot cp = (CategoryPlot) parent; [EOL]             result = cp.getRangeAxis(index); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1039,1052
public void setRangeAxis(ValueAxis axis) { [EOL]     setRangeAxis(0, axis); [EOL] } <line_num>: 1060,1062
public void setRangeAxis(int index, ValueAxis axis) { [EOL]     setRangeAxis(index, axis, true); [EOL] } <line_num>: 1071,1073
public void setRangeAxis(int index, ValueAxis axis, boolean notify) { [EOL]     ValueAxis existing = (ValueAxis) this.rangeAxes.get(index); [EOL]     if (existing != null) { [EOL]         existing.removeChangeListener(this); [EOL]     } [EOL]     if (axis != null) { [EOL]         axis.setPlot(this); [EOL]     } [EOL]     this.rangeAxes.set(index, axis); [EOL]     if (axis != null) { [EOL]         axis.configure(); [EOL]         axis.addChangeListener(this); [EOL]     } [EOL]     if (notify) { [EOL]         fireChangeEvent(); [EOL]     } [EOL] } <line_num>: 1083,1099
public void setRangeAxes(ValueAxis[] axes) { [EOL]     for (int i = 0; i < axes.length; i++) { [EOL]         setRangeAxis(i, axes[i], false); [EOL]     } [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1109,1114
public int getRangeAxisIndex(ValueAxis axis) { [EOL]     if (axis == null) { [EOL]         throw new IllegalArgumentException("Null 'axis' argument."); [EOL]     } [EOL]     int result = this.rangeAxes.indexOf(axis); [EOL]     if (result < 0) { [EOL]         Plot parent = getParent(); [EOL]         if (parent instanceof CategoryPlot) { [EOL]             CategoryPlot p = (CategoryPlot) parent; [EOL]             result = p.getRangeAxisIndex(axis); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1129,1142
public AxisLocation getRangeAxisLocation() { [EOL]     return getRangeAxisLocation(0); [EOL] } <line_num>: 1149,1151
public AxisLocation getRangeAxisLocation(int index) { [EOL]     AxisLocation result = null; [EOL]     if (index < this.rangeAxisLocations.size()) { [EOL]         result = (AxisLocation) this.rangeAxisLocations.get(index); [EOL]     } [EOL]     if (result == null) { [EOL]         result = AxisLocation.getOpposite(getRangeAxisLocation(0)); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1162,1171
public void setRangeAxisLocation(AxisLocation location) { [EOL]     setRangeAxisLocation(location, true); [EOL] } <line_num>: 1182,1185
public void setRangeAxisLocation(AxisLocation location, boolean notify) { [EOL]     setRangeAxisLocation(0, location, notify); [EOL] } <line_num>: 1196,1198
public void setRangeAxisLocation(int index, AxisLocation location) { [EOL]     setRangeAxisLocation(index, location, true); [EOL] } <line_num>: 1210,1212
public void setRangeAxisLocation(int index, AxisLocation location, boolean notify) { [EOL]     if (index == 0 && location == null) { [EOL]         throw new IllegalArgumentException("Null 'location' for index 0 not permitted."); [EOL]     } [EOL]     this.rangeAxisLocations.set(index, location); [EOL]     if (notify) { [EOL]         fireChangeEvent(); [EOL]     } [EOL] } <line_num>: 1225,1235
public RectangleEdge getRangeAxisEdge() { [EOL]     return getRangeAxisEdge(0); [EOL] } <line_num>: 1242,1244
public RectangleEdge getRangeAxisEdge(int index) { [EOL]     AxisLocation location = getRangeAxisLocation(index); [EOL]     RectangleEdge result = Plot.resolveRangeAxisLocation(location, this.orientation); [EOL]     if (result == null) { [EOL]         result = RectangleEdge.opposite(getRangeAxisEdge(0)); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1253,1261
public int getRangeAxisCount() { [EOL]     return this.rangeAxes.size(); [EOL] } <line_num>: 1268,1270
public void clearRangeAxes() { [EOL]     for (int i = 0; i < this.rangeAxes.size(); i++) { [EOL]         ValueAxis axis = (ValueAxis) this.rangeAxes.get(i); [EOL]         if (axis != null) { [EOL]             axis.removeChangeListener(this); [EOL]         } [EOL]     } [EOL]     this.rangeAxes.clear(); [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1276,1285
public void configureRangeAxes() { [EOL]     for (int i = 0; i < this.rangeAxes.size(); i++) { [EOL]         ValueAxis axis = (ValueAxis) this.rangeAxes.get(i); [EOL]         if (axis != null) { [EOL]             axis.configure(); [EOL]         } [EOL]     } [EOL] } <line_num>: 1290,1297
public CategoryDataset getDataset() { [EOL]     return getDataset(0); [EOL] } <line_num>: 1306,1308
public CategoryDataset getDataset(int index) { [EOL]     CategoryDataset result = null; [EOL]     if (this.datasets.size() > index) { [EOL]         result = (CategoryDataset) this.datasets.get(index); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1319,1325
public void setDataset(CategoryDataset dataset) { [EOL]     setDataset(0, dataset); [EOL] } <line_num>: 1338,1340
public void setDataset(int index, CategoryDataset dataset) { [EOL]     CategoryDataset existing = (CategoryDataset) this.datasets.get(index); [EOL]     if (existing != null) { [EOL]         existing.removeChangeListener(this); [EOL]     } [EOL]     this.datasets.set(index, dataset); [EOL]     if (dataset != null) { [EOL]         dataset.addChangeListener(this); [EOL]     } [EOL]     DatasetChangeEvent event = new DatasetChangeEvent(this, dataset, new DatasetChangeInfo()); [EOL]     datasetChanged(event); [EOL] } <line_num>: 1350,1367
public int getDatasetCount() { [EOL]     return this.datasets.size(); [EOL] } <line_num>: 1376,1378
public int indexOf(CategoryDataset dataset) { [EOL]     int result = -1; [EOL]     for (int i = 0; i < this.datasets.size(); i++) { [EOL]         if (dataset == this.datasets.get(i)) { [EOL]             result = i; [EOL]             break; [EOL]         } [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1390,1399
public void mapDatasetToDomainAxis(int index, int axisIndex) { [EOL]     List axisIndices = new java.util.ArrayList(1); [EOL]     axisIndices.add(new Integer(axisIndex)); [EOL]     mapDatasetToDomainAxes(index, axisIndices); [EOL] } <line_num>: 1409,1413
public void mapDatasetToDomainAxes(int index, List axisIndices) { [EOL]     if (index < 0) { [EOL]         throw new IllegalArgumentException("Requires 'index' >= 0."); [EOL]     } [EOL]     checkAxisIndices(axisIndices); [EOL]     Integer key = new Integer(index); [EOL]     this.datasetToDomainAxesMap.put(key, new ArrayList(axisIndices)); [EOL]     datasetChanged(new DatasetChangeEvent(this, getDataset(index), new DatasetChangeInfo())); [EOL] } <line_num>: 1425,1436
private void checkAxisIndices(List indices) { [EOL]     if (indices == null) { [EOL]         return; [EOL]     } [EOL]     int count = indices.size(); [EOL]     if (count == 0) { [EOL]         throw new IllegalArgumentException("Empty list not permitted."); [EOL]     } [EOL]     HashSet set = new HashSet(); [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object item = indices.get(i); [EOL]         if (!(item instanceof Integer)) { [EOL]             throw new IllegalArgumentException("Indices must be Integer instances."); [EOL]         } [EOL]         if (set.contains(item)) { [EOL]             throw new IllegalArgumentException("Indices must be unique."); [EOL]         } [EOL]         set.add(item); [EOL]     } [EOL] } <line_num>: 1445,1468
public CategoryAxis getDomainAxisForDataset(int index) { [EOL]     if (index < 0) { [EOL]         throw new IllegalArgumentException("Negative 'index'."); [EOL]     } [EOL]     CategoryAxis axis = null; [EOL]     List axisIndices = (List) this.datasetToDomainAxesMap.get(new Integer(index)); [EOL]     if (axisIndices != null) { [EOL]         Integer axisIndex = (Integer) axisIndices.get(0); [EOL]         axis = getDomainAxis(axisIndex.intValue()); [EOL]     } else { [EOL]         axis = getDomainAxis(0); [EOL]     } [EOL]     return axis; [EOL] } <line_num>: 1480,1496
public void mapDatasetToRangeAxis(int index, int axisIndex) { [EOL]     List axisIndices = new java.util.ArrayList(1); [EOL]     axisIndices.add(new Integer(axisIndex)); [EOL]     mapDatasetToRangeAxes(index, axisIndices); [EOL] } <line_num>: 1506,1510
public void mapDatasetToRangeAxes(int index, List axisIndices) { [EOL]     if (index < 0) { [EOL]         throw new IllegalArgumentException("Requires 'index' >= 0."); [EOL]     } [EOL]     checkAxisIndices(axisIndices); [EOL]     Integer key = new Integer(index); [EOL]     this.datasetToRangeAxesMap.put(key, new ArrayList(axisIndices)); [EOL]     datasetChanged(new DatasetChangeEvent(this, getDataset(index), new DatasetChangeInfo())); [EOL] } <line_num>: 1522,1534
public ValueAxis getRangeAxisForDataset(int index) { [EOL]     if (index < 0) { [EOL]         throw new IllegalArgumentException("Negative 'index'."); [EOL]     } [EOL]     ValueAxis axis = null; [EOL]     List axisIndices = (List) this.datasetToRangeAxesMap.get(new Integer(index)); [EOL]     if (axisIndices != null) { [EOL]         Integer axisIndex = (Integer) axisIndices.get(0); [EOL]         axis = getRangeAxis(axisIndex.intValue()); [EOL]     } else { [EOL]         axis = getRangeAxis(0); [EOL]     } [EOL]     return axis; [EOL] } <line_num>: 1546,1562
public int getRendererCount() { [EOL]     return this.renderers.size(); [EOL] } <line_num>: 1571,1573
public CategoryItemRenderer getRenderer() { [EOL]     return getRenderer(0); [EOL] } <line_num>: 1582,1584
public CategoryItemRenderer getRenderer(int index) { [EOL]     CategoryItemRenderer result = null; [EOL]     if (this.renderers.size() > index) { [EOL]         result = (CategoryItemRenderer) this.renderers.get(index); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1595,1601
public void setRenderer(CategoryItemRenderer renderer) { [EOL]     setRenderer(0, renderer, true); [EOL] } <line_num>: 1612,1614
public void setRenderer(CategoryItemRenderer renderer, boolean notify) { [EOL]     setRenderer(0, renderer, notify); [EOL] } <line_num>: 1633,1635
public void setRenderer(int index, CategoryItemRenderer renderer) { [EOL]     setRenderer(index, renderer, true); [EOL] } <line_num>: 1647,1649
public void setRenderer(int index, CategoryItemRenderer renderer, boolean notify) { [EOL]     CategoryItemRenderer existing = (CategoryItemRenderer) this.renderers.get(index); [EOL]     if (existing != null) { [EOL]         existing.removeChangeListener(this); [EOL]     } [EOL]     this.renderers.set(index, renderer); [EOL]     if (renderer != null) { [EOL]         renderer.setPlot(this); [EOL]         renderer.addChangeListener(this); [EOL]     } [EOL]     configureDomainAxes(); [EOL]     configureRangeAxes(); [EOL]     if (notify) { [EOL]         fireChangeEvent(); [EOL]     } [EOL] } <line_num>: 1661,1684
public void setRenderers(CategoryItemRenderer[] renderers) { [EOL]     for (int i = 0; i < renderers.length; i++) { [EOL]         setRenderer(i, renderers[i], false); [EOL]     } [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1692,1697
public CategoryItemRenderer getRendererForDataset(CategoryDataset dataset) { [EOL]     CategoryItemRenderer result = null; [EOL]     for (int i = 0; i < this.datasets.size(); i++) { [EOL]         if (this.datasets.get(i) == dataset) { [EOL]             result = (CategoryItemRenderer) this.renderers.get(i); [EOL]             break; [EOL]         } [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1707,1716
public int getIndexOf(CategoryItemRenderer renderer) { [EOL]     return this.renderers.indexOf(renderer); [EOL] } <line_num>: 1726,1728
public DatasetRenderingOrder getDatasetRenderingOrder() { [EOL]     return this.renderingOrder; [EOL] } <line_num>: 1737,1739
public void setDatasetRenderingOrder(DatasetRenderingOrder order) { [EOL]     if (order == null) { [EOL]         throw new IllegalArgumentException("Null 'order' argument."); [EOL]     } [EOL]     this.renderingOrder = order; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1751,1757
public SortOrder getColumnRenderingOrder() { [EOL]     return this.columnRenderingOrder; [EOL] } <line_num>: 1767,1769
public void setColumnRenderingOrder(SortOrder order) { [EOL]     if (order == null) { [EOL]         throw new IllegalArgumentException("Null 'order' argument."); [EOL]     } [EOL]     this.columnRenderingOrder = order; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1782,1788
public SortOrder getRowRenderingOrder() { [EOL]     return this.rowRenderingOrder; [EOL] } <line_num>: 1798,1800
public void setRowRenderingOrder(SortOrder order) { [EOL]     if (order == null) { [EOL]         throw new IllegalArgumentException("Null 'order' argument."); [EOL]     } [EOL]     this.rowRenderingOrder = order; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1813,1819
public boolean isDomainGridlinesVisible() { [EOL]     return this.domainGridlinesVisible; [EOL] } <line_num>: 1828,1830
public void setDomainGridlinesVisible(boolean visible) { [EOL]     if (this.domainGridlinesVisible != visible) { [EOL]         this.domainGridlinesVisible = visible; [EOL]         fireChangeEvent(); [EOL]     } [EOL] } <line_num>: 1843,1848
public CategoryAnchor getDomainGridlinePosition() { [EOL]     return this.domainGridlinePosition; [EOL] } <line_num>: 1857,1859
public void setDomainGridlinePosition(CategoryAnchor position) { [EOL]     if (position == null) { [EOL]         throw new IllegalArgumentException("Null 'position' argument."); [EOL]     } [EOL]     this.domainGridlinePosition = position; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1869,1875
public Stroke getDomainGridlineStroke() { [EOL]     return this.domainGridlineStroke; [EOL] } <line_num>: 1884,1886
public void setDomainGridlineStroke(Stroke stroke) { [EOL]     if (stroke == null) { [EOL]         throw new IllegalArgumentException("Null 'stroke' not permitted."); [EOL]     } [EOL]     this.domainGridlineStroke = stroke; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1896,1902
public Paint getDomainGridlinePaint() { [EOL]     return this.domainGridlinePaint; [EOL] } <line_num>: 1911,1913
public void setDomainGridlinePaint(Paint paint) { [EOL]     if (paint == null) { [EOL]         throw new IllegalArgumentException("Null 'paint' argument."); [EOL]     } [EOL]     this.domainGridlinePaint = paint; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1923,1929
public boolean isRangeZeroBaselineVisible() { [EOL]     return this.rangeZeroBaselineVisible; [EOL] } <line_num>: 1941,1943
public void setRangeZeroBaselineVisible(boolean visible) { [EOL]     this.rangeZeroBaselineVisible = visible; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1956,1959
public Stroke getRangeZeroBaselineStroke() { [EOL]     return this.rangeZeroBaselineStroke; [EOL] } <line_num>: 1970,1972
public void setRangeZeroBaselineStroke(Stroke stroke) { [EOL]     if (stroke == null) { [EOL]         throw new IllegalArgumentException("Null 'stroke' argument."); [EOL]     } [EOL]     this.rangeZeroBaselineStroke = stroke; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 1984,1990
public Paint getRangeZeroBaselinePaint() { [EOL]     return this.rangeZeroBaselinePaint; [EOL] } <line_num>: 2002,2004
public void setRangeZeroBaselinePaint(Paint paint) { [EOL]     if (paint == null) { [EOL]         throw new IllegalArgumentException("Null 'paint' argument."); [EOL]     } [EOL]     this.rangeZeroBaselinePaint = paint; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 2016,2022
public boolean isRangeGridlinesVisible() { [EOL]     return this.rangeGridlinesVisible; [EOL] } <line_num>: 2031,2033
public void setRangeGridlinesVisible(boolean visible) { [EOL]     if (this.rangeGridlinesVisible != visible) { [EOL]         this.rangeGridlinesVisible = visible; [EOL]         fireChangeEvent(); [EOL]     } [EOL] } <line_num>: 2044,2049
public Stroke getRangeGridlineStroke() { [EOL]     return this.rangeGridlineStroke; [EOL] } <line_num>: 2058,2060
public void setRangeGridlineStroke(Stroke stroke) { [EOL]     if (stroke == null) { [EOL]         throw new IllegalArgumentException("Null 'stroke' argument."); [EOL]     } [EOL]     this.rangeGridlineStroke = stroke; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 2070,2076
public Paint getRangeGridlinePaint() { [EOL]     return this.rangeGridlinePaint; [EOL] } <line_num>: 2085,2087
public void setRangeGridlinePaint(Paint paint) { [EOL]     if (paint == null) { [EOL]         throw new IllegalArgumentException("Null 'paint' argument."); [EOL]     } [EOL]     this.rangeGridlinePaint = paint; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 2097,2103
public boolean isRangeMinorGridlinesVisible() { [EOL]     return this.rangeMinorGridlinesVisible; [EOL] } <line_num>: 2115,2117
public void setRangeMinorGridlinesVisible(boolean visible) { [EOL]     if (this.rangeMinorGridlinesVisible != visible) { [EOL]         this.rangeMinorGridlinesVisible = visible; [EOL]         fireChangeEvent(); [EOL]     } [EOL] } <line_num>: 2132,2137
public Stroke getRangeMinorGridlineStroke() { [EOL]     return this.rangeMinorGridlineStroke; [EOL] } <line_num>: 2149,2151
public void setRangeMinorGridlineStroke(Stroke stroke) { [EOL]     if (stroke == null) { [EOL]         throw new IllegalArgumentException("Null 'stroke' argument."); [EOL]     } [EOL]     this.rangeMinorGridlineStroke = stroke; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 2163,2169
public Paint getRangeMinorGridlinePaint() { [EOL]     return this.rangeMinorGridlinePaint; [EOL] } <line_num>: 2181,2183
public void setRangeMinorGridlinePaint(Paint paint) { [EOL]     if (paint == null) { [EOL]         throw new IllegalArgumentException("Null 'paint' argument."); [EOL]     } [EOL]     this.rangeMinorGridlinePaint = paint; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 2195,2201
public LegendItemCollection getFixedLegendItems() { [EOL]     return this.fixedLegendItems; [EOL] } <line_num>: 2210,2212
public void setFixedLegendItems(LegendItemCollection items) { [EOL]     this.fixedLegendItems = items; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 2223,2226
public LegendItemCollection getLegendItems() { [EOL]     if (this.fixedLegendItems != null) { [EOL]         return this.fixedLegendItems; [EOL]     } [EOL]     LegendItemCollection result = new LegendItemCollection(); [EOL]     int count = this.datasets.size(); [EOL]     for (int datasetIndex = 0; datasetIndex < count; datasetIndex++) { [EOL]         CategoryDataset dataset = getDataset(datasetIndex); [EOL]         if (dataset != null) { [EOL]             CategoryItemRenderer renderer = getRenderer(datasetIndex); [EOL]             if (renderer != null) { [EOL]                 result.addAll(renderer.getLegendItems()); [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] } <line_num>: 2235,2252
public void handleClick(int x, int y, PlotRenderingInfo info) { [EOL]     Rectangle2D dataArea = info.getDataArea(); [EOL]     if (dataArea.contains(x, y)) { [EOL]         double java2D = 0.0; [EOL]         if (this.orientation == PlotOrientation.HORIZONTAL) { [EOL]             java2D = x; [EOL]         } else if (this.orientation == PlotOrientation.VERTICAL) { [EOL]             java2D = y; [EOL]         } [EOL]         RectangleEdge edge = Plot.resolveRangeAxisLocation(getRangeAxisLocation(), this.orientation); [EOL]         double value = getRangeAxis().java2DToValue(java2D, info.getDataArea(), edge); [EOL]         setAnchorValue(value); [EOL]         setRangeCrosshairValue(value); [EOL]     } [EOL] } <line_num>: 2262,2282
public void zoom(double percent) { [EOL]     if (percent > 0.0) { [EOL]         double range = getRangeAxis().getRange().getLength(); [EOL]         double scaledRange = range * percent; [EOL]         getRangeAxis().setRange(this.anchorValue - scaledRange / 2.0, this.anchorValue + scaledRange / 2.0); [EOL]     } else { [EOL]         getRangeAxis().setAutoRange(true); [EOL]     } [EOL] } <line_num>: 2293,2305
public void annotationChanged(AnnotationChangeEvent event) { [EOL]     if (getParent() != null) { [EOL]         getParent().annotationChanged(event); [EOL]     } else { [EOL]         PlotChangeEvent e = new PlotChangeEvent(this); [EOL]         notifyListeners(e); [EOL]     } [EOL] } <line_num>: 2315,2323
public void datasetChanged(DatasetChangeEvent event) { [EOL]     int count = this.rangeAxes.size(); [EOL]     for (int axisIndex = 0; axisIndex < count; axisIndex++) { [EOL]         ValueAxis yAxis = getRangeAxis(axisIndex); [EOL]         if (yAxis != null) { [EOL]             yAxis.configure(); [EOL]         } [EOL]     } [EOL]     if (getParent() != null) { [EOL]         getParent().datasetChanged(event); [EOL]     } else { [EOL]         PlotChangeEvent e = new PlotChangeEvent(this); [EOL]         e.setType(ChartChangeEventType.DATASET_UPDATED); [EOL]         notifyListeners(e); [EOL]     } [EOL] } <line_num>: 2332,2350
public void rendererChanged(RendererChangeEvent event) { [EOL]     Plot parent = getParent(); [EOL]     if (parent != null) { [EOL]         if (parent instanceof RendererChangeListener) { [EOL]             RendererChangeListener rcl = (RendererChangeListener) parent; [EOL]             rcl.rendererChanged(event); [EOL]         } else { [EOL]             throw new RuntimeException("The renderer has changed and I don't know what to do!"); [EOL]         } [EOL]     } else { [EOL]         configureRangeAxes(); [EOL]         PlotChangeEvent e = new PlotChangeEvent(this); [EOL]         notifyListeners(e); [EOL]     } [EOL] } <line_num>: 2357,2376
public void addDomainMarker(CategoryMarker marker) { [EOL]     addDomainMarker(marker, Layer.FOREGROUND); [EOL] } <line_num>: 2388,2390
public void addDomainMarker(CategoryMarker marker, Layer layer) { [EOL]     addDomainMarker(0, marker, layer); [EOL] } <line_num>: 2404,2406
public void addDomainMarker(int index, CategoryMarker marker, Layer layer) { [EOL]     addDomainMarker(index, marker, layer, true); [EOL] } <line_num>: 2421,2423
public void addDomainMarker(int index, CategoryMarker marker, Layer layer, boolean notify) { [EOL]     if (marker == null) { [EOL]         throw new IllegalArgumentException("Null 'marker' not permitted."); [EOL]     } [EOL]     if (layer == null) { [EOL]         throw new IllegalArgumentException("Null 'layer' not permitted."); [EOL]     } [EOL]     Collection markers; [EOL]     if (layer == Layer.FOREGROUND) { [EOL]         markers = (Collection) this.foregroundDomainMarkers.get(new Integer(index)); [EOL]         if (markers == null) { [EOL]             markers = new java.util.ArrayList(); [EOL]             this.foregroundDomainMarkers.put(new Integer(index), markers); [EOL]         } [EOL]         markers.add(marker); [EOL]     } else if (layer == Layer.BACKGROUND) { [EOL]         markers = (Collection) this.backgroundDomainMarkers.get(new Integer(index)); [EOL]         if (markers == null) { [EOL]             markers = new java.util.ArrayList(); [EOL]             this.backgroundDomainMarkers.put(new Integer(index), markers); [EOL]         } [EOL]         markers.add(marker); [EOL]     } [EOL]     marker.addChangeListener(this); [EOL]     if (notify) { [EOL]         fireChangeEvent(); [EOL]     } [EOL] } <line_num>: 2441,2472
public void clearDomainMarkers() { [EOL]     if (this.backgroundDomainMarkers != null) { [EOL]         Set keys = this.backgroundDomainMarkers.keySet(); [EOL]         Iterator iterator = keys.iterator(); [EOL]         while (iterator.hasNext()) { [EOL]             Integer key = (Integer) iterator.next(); [EOL]             clearDomainMarkers(key.intValue()); [EOL]         } [EOL]         this.backgroundDomainMarkers.clear(); [EOL]     } [EOL]     if (this.foregroundDomainMarkers != null) { [EOL]         Set keys = this.foregroundDomainMarkers.keySet(); [EOL]         Iterator iterator = keys.iterator(); [EOL]         while (iterator.hasNext()) { [EOL]             Integer key = (Integer) iterator.next(); [EOL]             clearDomainMarkers(key.intValue()); [EOL]         } [EOL]         this.foregroundDomainMarkers.clear(); [EOL]     } [EOL]     fireChangeEvent(); [EOL] } <line_num>: 2480,2500
public Collection getDomainMarkers(Layer layer) { [EOL]     return getDomainMarkers(0, layer); [EOL] } <line_num>: 2509,2511
public Collection getDomainMarkers(int index, Layer layer) { [EOL]     Collection result = null; [EOL]     Integer key = new Integer(index); [EOL]     if (layer == Layer.FOREGROUND) { [EOL]         result = (Collection) this.foregroundDomainMarkers.get(key); [EOL]     } else if (layer == Layer.BACKGROUND) { [EOL]         result = (Collection) this.backgroundDomainMarkers.get(key); [EOL]     } [EOL]     if (result != null) { [EOL]         result = Collections.unmodifiableCollection(result); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 2522,2535
public void clearDomainMarkers(int index) { [EOL]     Integer key = new Integer(index); [EOL]     if (this.backgroundDomainMarkers != null) { [EOL]         Collection markers = (Collection) this.backgroundDomainMarkers.get(key); [EOL]         if (markers != null) { [EOL]             Iterator iterator = markers.iterator(); [EOL]             while (iterator.hasNext()) { [EOL]                 Marker m = (Marker) iterator.next(); [EOL]                 m.removeChangeListener(this); [EOL]             } [EOL]             markers.clear(); [EOL]         } [EOL]     } [EOL]     if (this.foregroundDomainMarkers != null) { [EOL]         Collection markers = (Collection) this.foregroundDomainMarkers.get(key); [EOL]         if (markers != null) { [EOL]             Iterator iterator = markers.iterator(); [EOL]             while (iterator.hasNext()) { [EOL]                 Marker m = (Marker) iterator.next(); [EOL]                 m.removeChangeListener(this); [EOL]             } [EOL]             markers.clear(); [EOL]         } [EOL]     } [EOL]     fireChangeEvent(); [EOL] } <line_num>: 2544,2571
public boolean removeDomainMarker(Marker marker) { [EOL]     return removeDomainMarker(marker, Layer.FOREGROUND); [EOL] } <line_num>: 2584,2586
public boolean removeDomainMarker(Marker marker, Layer layer) { [EOL]     return removeDomainMarker(0, marker, layer); [EOL] } <line_num>: 2600,2602
public boolean removeDomainMarker(int index, Marker marker, Layer layer) { [EOL]     return removeDomainMarker(index, marker, layer, true); [EOL] } <line_num>: 2617,2619
public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify) { [EOL]     ArrayList markers; [EOL]     if (layer == Layer.FOREGROUND) { [EOL]         markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(index)); [EOL]     } else { [EOL]         markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(index)); [EOL]     } [EOL]     if (markers == null) { [EOL]         return false; [EOL]     } [EOL]     boolean removed = markers.remove(marker); [EOL]     if (removed && notify) { [EOL]         fireChangeEvent(); [EOL]     } [EOL]     return removed; [EOL] } <line_num>: 2635,2654
public void addRangeMarker(Marker marker) { [EOL]     addRangeMarker(marker, Layer.FOREGROUND); [EOL] } <line_num>: 2666,2668
public void addRangeMarker(Marker marker, Layer layer) { [EOL]     addRangeMarker(0, marker, layer); [EOL] } <line_num>: 2682,2684
public void addRangeMarker(int index, Marker marker, Layer layer) { [EOL]     addRangeMarker(index, marker, layer, true); [EOL] } <line_num>: 2699,2701
public void addRangeMarker(int index, Marker marker, Layer layer, boolean notify) { [EOL]     Collection markers; [EOL]     if (layer == Layer.FOREGROUND) { [EOL]         markers = (Collection) this.foregroundRangeMarkers.get(new Integer(index)); [EOL]         if (markers == null) { [EOL]             markers = new java.util.ArrayList(); [EOL]             this.foregroundRangeMarkers.put(new Integer(index), markers); [EOL]         } [EOL]         markers.add(marker); [EOL]     } else if (layer == Layer.BACKGROUND) { [EOL]         markers = (Collection) this.backgroundRangeMarkers.get(new Integer(index)); [EOL]         if (markers == null) { [EOL]             markers = new java.util.ArrayList(); [EOL]             this.backgroundRangeMarkers.put(new Integer(index), markers); [EOL]         } [EOL]         markers.add(marker); [EOL]     } [EOL]     marker.addChangeListener(this); [EOL]     if (notify) { [EOL]         fireChangeEvent(); [EOL]     } [EOL] } <line_num>: 2719,2744
public void clearRangeMarkers() { [EOL]     if (this.backgroundRangeMarkers != null) { [EOL]         Set keys = this.backgroundRangeMarkers.keySet(); [EOL]         Iterator iterator = keys.iterator(); [EOL]         while (iterator.hasNext()) { [EOL]             Integer key = (Integer) iterator.next(); [EOL]             clearRangeMarkers(key.intValue()); [EOL]         } [EOL]         this.backgroundRangeMarkers.clear(); [EOL]     } [EOL]     if (this.foregroundRangeMarkers != null) { [EOL]         Set keys = this.foregroundRangeMarkers.keySet(); [EOL]         Iterator iterator = keys.iterator(); [EOL]         while (iterator.hasNext()) { [EOL]             Integer key = (Integer) iterator.next(); [EOL]             clearRangeMarkers(key.intValue()); [EOL]         } [EOL]         this.foregroundRangeMarkers.clear(); [EOL]     } [EOL]     fireChangeEvent(); [EOL] } <line_num>: 2752,2772
public Collection getRangeMarkers(Layer layer) { [EOL]     return getRangeMarkers(0, layer); [EOL] } <line_num>: 2783,2785
public Collection getRangeMarkers(int index, Layer layer) { [EOL]     Collection result = null; [EOL]     Integer key = new Integer(index); [EOL]     if (layer == Layer.FOREGROUND) { [EOL]         result = (Collection) this.foregroundRangeMarkers.get(key); [EOL]     } else if (layer == Layer.BACKGROUND) { [EOL]         result = (Collection) this.backgroundRangeMarkers.get(key); [EOL]     } [EOL]     if (result != null) { [EOL]         result = Collections.unmodifiableCollection(result); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 2796,2809
public void clearRangeMarkers(int index) { [EOL]     Integer key = new Integer(index); [EOL]     if (this.backgroundRangeMarkers != null) { [EOL]         Collection markers = (Collection) this.backgroundRangeMarkers.get(key); [EOL]         if (markers != null) { [EOL]             Iterator iterator = markers.iterator(); [EOL]             while (iterator.hasNext()) { [EOL]                 Marker m = (Marker) iterator.next(); [EOL]                 m.removeChangeListener(this); [EOL]             } [EOL]             markers.clear(); [EOL]         } [EOL]     } [EOL]     if (this.foregroundRangeMarkers != null) { [EOL]         Collection markers = (Collection) this.foregroundRangeMarkers.get(key); [EOL]         if (markers != null) { [EOL]             Iterator iterator = markers.iterator(); [EOL]             while (iterator.hasNext()) { [EOL]                 Marker m = (Marker) iterator.next(); [EOL]                 m.removeChangeListener(this); [EOL]             } [EOL]             markers.clear(); [EOL]         } [EOL]     } [EOL]     fireChangeEvent(); [EOL] } <line_num>: 2818,2845
public boolean removeRangeMarker(Marker marker) { [EOL]     return removeRangeMarker(marker, Layer.FOREGROUND); [EOL] } <line_num>: 2860,2862
public boolean removeRangeMarker(Marker marker, Layer layer) { [EOL]     return removeRangeMarker(0, marker, layer); [EOL] } <line_num>: 2878,2880
public boolean removeRangeMarker(int index, Marker marker, Layer layer) { [EOL]     return removeRangeMarker(index, marker, layer, true); [EOL] } <line_num>: 2897,2899
public boolean removeRangeMarker(int index, Marker marker, Layer layer, boolean notify) { [EOL]     if (marker == null) { [EOL]         throw new IllegalArgumentException("Null 'marker' argument."); [EOL]     } [EOL]     ArrayList markers; [EOL]     if (layer == Layer.FOREGROUND) { [EOL]         markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(index)); [EOL]     } else { [EOL]         markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(index)); [EOL]     } [EOL]     if (markers == null) { [EOL]         return false; [EOL]     } [EOL]     boolean removed = markers.remove(marker); [EOL]     if (removed && notify) { [EOL]         fireChangeEvent(); [EOL]     } [EOL]     return removed; [EOL] } <line_num>: 2917,2939
public boolean isDomainCrosshairVisible() { [EOL]     return this.domainCrosshairVisible; [EOL] } <line_num>: 2951,2953
public void setDomainCrosshairVisible(boolean flag) { [EOL]     if (this.domainCrosshairVisible != flag) { [EOL]         this.domainCrosshairVisible = flag; [EOL]         fireChangeEvent(); [EOL]     } [EOL] } <line_num>: 2967,2972
public Comparable getDomainCrosshairRowKey() { [EOL]     return this.domainCrosshairRowKey; [EOL] } <line_num>: 2981,2983
public void setDomainCrosshairRowKey(Comparable key) { [EOL]     setDomainCrosshairRowKey(key, true); [EOL] } <line_num>: 2993,2995
public void setDomainCrosshairRowKey(Comparable key, boolean notify) { [EOL]     this.domainCrosshairRowKey = key; [EOL]     if (notify) { [EOL]         fireChangeEvent(); [EOL]     } [EOL] } <line_num>: 3006,3011
public Comparable getDomainCrosshairColumnKey() { [EOL]     return this.domainCrosshairColumnKey; [EOL] } <line_num>: 3020,3022
public void setDomainCrosshairColumnKey(Comparable key) { [EOL]     setDomainCrosshairColumnKey(key, true); [EOL] } <line_num>: 3032,3034
public void setDomainCrosshairColumnKey(Comparable key, boolean notify) { [EOL]     this.domainCrosshairColumnKey = key; [EOL]     if (notify) { [EOL]         fireChangeEvent(); [EOL]     } [EOL] } <line_num>: 3045,3050
public int getCrosshairDatasetIndex() { [EOL]     return this.crosshairDatasetIndex; [EOL] } <line_num>: 3059,3061
public void setCrosshairDatasetIndex(int index) { [EOL]     setCrosshairDatasetIndex(index, true); [EOL] } <line_num>: 3071,3073
public void setCrosshairDatasetIndex(int index, boolean notify) { [EOL]     this.crosshairDatasetIndex = index; [EOL]     if (notify) { [EOL]         fireChangeEvent(); [EOL]     } [EOL] } <line_num>: 3084,3089
public Paint getDomainCrosshairPaint() { [EOL]     return this.domainCrosshairPaint; [EOL] } <line_num>: 3101,3103
public void setDomainCrosshairPaint(Paint paint) { [EOL]     if (paint == null) { [EOL]         throw new IllegalArgumentException("Null 'paint' argument."); [EOL]     } [EOL]     this.domainCrosshairPaint = paint; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 3114,3120
public Stroke getDomainCrosshairStroke() { [EOL]     return this.domainCrosshairStroke; [EOL] } <line_num>: 3132,3134
public void setDomainCrosshairStroke(Stroke stroke) { [EOL]     if (stroke == null) { [EOL]         throw new IllegalArgumentException("Null 'stroke' argument."); [EOL]     } [EOL]     this.domainCrosshairStroke = stroke; [EOL] } <line_num>: 3146,3151
public boolean isRangeCrosshairVisible() { [EOL]     return this.rangeCrosshairVisible; [EOL] } <line_num>: 3160,3162
public void setRangeCrosshairVisible(boolean flag) { [EOL]     if (this.rangeCrosshairVisible != flag) { [EOL]         this.rangeCrosshairVisible = flag; [EOL]         fireChangeEvent(); [EOL]     } [EOL] } <line_num>: 3171,3176
public boolean isRangeCrosshairLockedOnData() { [EOL]     return this.rangeCrosshairLockedOnData; [EOL] } <line_num>: 3186,3188
public void setRangeCrosshairLockedOnData(boolean flag) { [EOL]     if (this.rangeCrosshairLockedOnData != flag) { [EOL]         this.rangeCrosshairLockedOnData = flag; [EOL]         fireChangeEvent(); [EOL]     } [EOL] } <line_num>: 3199,3204
public double getRangeCrosshairValue() { [EOL]     return this.rangeCrosshairValue; [EOL] } <line_num>: 3213,3215
public void setRangeCrosshairValue(double value) { [EOL]     setRangeCrosshairValue(value, true); [EOL] } <line_num>: 3225,3227
public void setRangeCrosshairValue(double value, boolean notify) { [EOL]     this.rangeCrosshairValue = value; [EOL]     if (isRangeCrosshairVisible() && notify) { [EOL]         fireChangeEvent(); [EOL]     } [EOL] } <line_num>: 3240,3245
public Stroke getRangeCrosshairStroke() { [EOL]     return this.rangeCrosshairStroke; [EOL] } <line_num>: 3257,3259
public void setRangeCrosshairStroke(Stroke stroke) { [EOL]     if (stroke == null) { [EOL]         throw new IllegalArgumentException("Null 'stroke' argument."); [EOL]     } [EOL]     this.rangeCrosshairStroke = stroke; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 3271,3277
public Paint getRangeCrosshairPaint() { [EOL]     return this.rangeCrosshairPaint; [EOL] } <line_num>: 3288,3290
public void setRangeCrosshairPaint(Paint paint) { [EOL]     if (paint == null) { [EOL]         throw new IllegalArgumentException("Null 'paint' argument."); [EOL]     } [EOL]     this.rangeCrosshairPaint = paint; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 3300,3306
public List getAnnotations() { [EOL]     return this.annotations; [EOL] } <line_num>: 3316,3318
public void addAnnotation(CategoryAnnotation annotation) { [EOL]     addAnnotation(annotation, true); [EOL] } <line_num>: 3328,3330
public void addAnnotation(CategoryAnnotation annotation, boolean notify) { [EOL]     if (annotation == null) { [EOL]         throw new IllegalArgumentException("Null 'annotation' argument."); [EOL]     } [EOL]     this.annotations.add(annotation); [EOL]     annotation.addChangeListener(this); [EOL]     if (notify) { [EOL]         fireChangeEvent(); [EOL]     } [EOL] } <line_num>: 3341,3350
public boolean removeAnnotation(CategoryAnnotation annotation) { [EOL]     return removeAnnotation(annotation, true); [EOL] } <line_num>: 3362,3364
public boolean removeAnnotation(CategoryAnnotation annotation, boolean notify) { [EOL]     if (annotation == null) { [EOL]         throw new IllegalArgumentException("Null 'annotation' argument."); [EOL]     } [EOL]     boolean removed = this.annotations.remove(annotation); [EOL]     annotation.removeChangeListener(this); [EOL]     if (removed && notify) { [EOL]         fireChangeEvent(); [EOL]     } [EOL]     return removed; [EOL] } <line_num>: 3377,3388
public void clearAnnotations() { [EOL]     for (int i = 0; i < this.annotations.size(); i++) { [EOL]         CategoryAnnotation annotation = (CategoryAnnotation) this.annotations.get(i); [EOL]         annotation.removeChangeListener(this); [EOL]     } [EOL]     this.annotations.clear(); [EOL]     fireChangeEvent(); [EOL] } <line_num>: 3394,3402
public ShadowGenerator getShadowGenerator() { [EOL]     return this.shadowGenerator; [EOL] } <line_num>: 3411,3413
public void setShadowGenerator(ShadowGenerator generator) { [EOL]     this.shadowGenerator = generator; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 3426,3429
protected AxisSpace calculateDomainAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space) { [EOL]     if (space == null) { [EOL]         space = new AxisSpace(); [EOL]     } [EOL]     if (this.fixedDomainAxisSpace != null) { [EOL]         if (this.orientation == PlotOrientation.HORIZONTAL) { [EOL]             space.ensureAtLeast(this.fixedDomainAxisSpace.getLeft(), RectangleEdge.LEFT); [EOL]             space.ensureAtLeast(this.fixedDomainAxisSpace.getRight(), RectangleEdge.RIGHT); [EOL]         } else if (this.orientation == PlotOrientation.VERTICAL) { [EOL]             space.ensureAtLeast(this.fixedDomainAxisSpace.getTop(), RectangleEdge.TOP); [EOL]             space.ensureAtLeast(this.fixedDomainAxisSpace.getBottom(), RectangleEdge.BOTTOM); [EOL]         } [EOL]     } else { [EOL]         RectangleEdge domainEdge = Plot.resolveDomainAxisLocation(getDomainAxisLocation(), this.orientation); [EOL]         if (this.drawSharedDomainAxis) { [EOL]             space = getDomainAxis().reserveSpace(g2, this, plotArea, domainEdge, space); [EOL]         } [EOL]         for (int i = 0; i < this.domainAxes.size(); i++) { [EOL]             Axis xAxis = (Axis) this.domainAxes.get(i); [EOL]             if (xAxis != null) { [EOL]                 RectangleEdge edge = getDomainAxisEdge(i); [EOL]                 space = xAxis.reserveSpace(g2, this, plotArea, edge, space); [EOL]             } [EOL]         } [EOL]     } [EOL]     return space; [EOL] } <line_num>: 3440,3484
protected AxisSpace calculateRangeAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space) { [EOL]     if (space == null) { [EOL]         space = new AxisSpace(); [EOL]     } [EOL]     if (this.fixedRangeAxisSpace != null) { [EOL]         if (this.orientation == PlotOrientation.HORIZONTAL) { [EOL]             space.ensureAtLeast(this.fixedRangeAxisSpace.getTop(), RectangleEdge.TOP); [EOL]             space.ensureAtLeast(this.fixedRangeAxisSpace.getBottom(), RectangleEdge.BOTTOM); [EOL]         } else if (this.orientation == PlotOrientation.VERTICAL) { [EOL]             space.ensureAtLeast(this.fixedRangeAxisSpace.getLeft(), RectangleEdge.LEFT); [EOL]             space.ensureAtLeast(this.fixedRangeAxisSpace.getRight(), RectangleEdge.RIGHT); [EOL]         } [EOL]     } else { [EOL]         for (int i = 0; i < this.rangeAxes.size(); i++) { [EOL]             Axis yAxis = (Axis) this.rangeAxes.get(i); [EOL]             if (yAxis != null) { [EOL]                 RectangleEdge edge = getRangeAxisEdge(i); [EOL]                 space = yAxis.reserveSpace(g2, this, plotArea, edge, space); [EOL]             } [EOL]         } [EOL]     } [EOL]     return space; [EOL] } <line_num>: 3495,3530
private Rectangle integerise(Rectangle2D rect) { [EOL]     int x0 = (int) Math.ceil(rect.getMinX()); [EOL]     int y0 = (int) Math.ceil(rect.getMinY()); [EOL]     int x1 = (int) Math.floor(rect.getMaxX()); [EOL]     int y1 = (int) Math.floor(rect.getMaxY()); [EOL]     return new Rectangle(x0, y0, (x1 - x0), (y1 - y0)); [EOL] } <line_num>: 3539,3545
protected AxisSpace calculateAxisSpace(Graphics2D g2, Rectangle2D plotArea) { [EOL]     AxisSpace space = new AxisSpace(); [EOL]     space = calculateRangeAxisSpace(g2, plotArea, space); [EOL]     space = calculateDomainAxisSpace(g2, plotArea, space); [EOL]     return space; [EOL] } <line_num>: 3555,3561
public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo state) { [EOL]     boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW); [EOL]     boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW); [EOL]     if (b1 || b2) { [EOL]         return; [EOL]     } [EOL]     if (state == null) { [EOL]         state = new PlotRenderingInfo(null); [EOL]     } [EOL]     state.setPlotArea(area); [EOL]     RectangleInsets insets = getInsets(); [EOL]     insets.trim(area); [EOL]     AxisSpace space = calculateAxisSpace(g2, area); [EOL]     Rectangle2D dataArea = space.shrink(area, null); [EOL]     this.axisOffset.trim(dataArea); [EOL]     dataArea = integerise(dataArea); [EOL]     if (dataArea.isEmpty()) { [EOL]         return; [EOL]     } [EOL]     state.setDataArea(dataArea); [EOL]     createAndAddEntity((Rectangle2D) dataArea.clone(), state, null, null); [EOL]     if (getRenderer() != null) { [EOL]         getRenderer().drawBackground(g2, this, dataArea); [EOL]     } else { [EOL]         drawBackground(g2, dataArea); [EOL]     } [EOL]     Map axisStateMap = drawAxes(g2, area, dataArea, state); [EOL]     if (anchor != null && !dataArea.contains(anchor)) { [EOL]         anchor = ShapeUtilities.getPointInRectangle(anchor.getX(), anchor.getY(), dataArea); [EOL]     } [EOL]     CategoryCrosshairState crosshairState = new CategoryCrosshairState(); [EOL]     crosshairState.setCrosshairDistance(Double.POSITIVE_INFINITY); [EOL]     crosshairState.setAnchor(anchor); [EOL]     crosshairState.setAnchorX(Double.NaN); [EOL]     crosshairState.setAnchorY(Double.NaN); [EOL]     if (anchor != null) { [EOL]         ValueAxis rangeAxis = getRangeAxis(); [EOL]         if (rangeAxis != null) { [EOL]             double y; [EOL]             if (getOrientation() == PlotOrientation.VERTICAL) { [EOL]                 y = rangeAxis.java2DToValue(anchor.getY(), dataArea, getRangeAxisEdge()); [EOL]             } else { [EOL]                 y = rangeAxis.java2DToValue(anchor.getX(), dataArea, getRangeAxisEdge()); [EOL]             } [EOL]             crosshairState.setAnchorY(y); [EOL]         } [EOL]     } [EOL]     crosshairState.setRowKey(getDomainCrosshairRowKey()); [EOL]     crosshairState.setColumnKey(getDomainCrosshairColumnKey()); [EOL]     crosshairState.setCrosshairY(getRangeCrosshairValue()); [EOL]     Shape savedClip = g2.getClip(); [EOL]     g2.clip(dataArea); [EOL]     drawDomainGridlines(g2, dataArea); [EOL]     AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis()); [EOL]     if (rangeAxisState == null) { [EOL]         if (parentState != null) { [EOL]             rangeAxisState = (AxisState) parentState.getSharedAxisStates().get(getRangeAxis()); [EOL]         } [EOL]     } [EOL]     if (rangeAxisState != null) { [EOL]         drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks()); [EOL]         drawZeroRangeBaseline(g2, dataArea); [EOL]     } [EOL]     Graphics2D savedG2 = g2; [EOL]     Rectangle2D savedDataArea = dataArea; [EOL]     BufferedImage dataImage = null; [EOL]     if (this.shadowGenerator != null) { [EOL]         dataImage = new BufferedImage((int) dataArea.getWidth(), (int) dataArea.getHeight(), BufferedImage.TYPE_INT_ARGB); [EOL]         g2 = dataImage.createGraphics(); [EOL]         g2.setRenderingHints(savedG2.getRenderingHints()); [EOL]         dataArea = new Rectangle(0, 0, dataImage.getWidth(), dataImage.getHeight()); [EOL]     } [EOL]     for (int i = 0; i < this.renderers.size(); i++) { [EOL]         drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND); [EOL]     } [EOL]     for (int i = 0; i < this.renderers.size(); i++) { [EOL]         drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND); [EOL]     } [EOL]     boolean foundData = false; [EOL]     Composite originalComposite = g2.getComposite(); [EOL]     g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, getForegroundAlpha())); [EOL]     DatasetRenderingOrder order = getDatasetRenderingOrder(); [EOL]     if (order == DatasetRenderingOrder.FORWARD) { [EOL]         int datasetCount = this.datasets.size(); [EOL]         for (int i = 0; i < datasetCount; i++) { [EOL]             CategoryItemRenderer r = getRenderer(i); [EOL]             if (r != null) { [EOL]                 CategoryAxis domainAxis = getDomainAxisForDataset(i); [EOL]                 ValueAxis rangeAxis = getRangeAxisForDataset(i); [EOL]                 r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis, Layer.BACKGROUND, state); [EOL]             } [EOL]         } [EOL]         for (int i = 0; i < datasetCount; i++) { [EOL]             foundData = render(g2, dataArea, i, state, crosshairState) || foundData; [EOL]         } [EOL]         for (int i = 0; i < datasetCount; i++) { [EOL]             CategoryItemRenderer r = getRenderer(i); [EOL]             if (r != null) { [EOL]                 CategoryAxis domainAxis = getDomainAxisForDataset(i); [EOL]                 ValueAxis rangeAxis = getRangeAxisForDataset(i); [EOL]                 r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis, Layer.FOREGROUND, state); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         int datasetCount = this.datasets.size(); [EOL]         for (int i = datasetCount - 1; i >= 0; i--) { [EOL]             CategoryItemRenderer r = getRenderer(i); [EOL]             if (r != null) { [EOL]                 CategoryAxis domainAxis = getDomainAxisForDataset(i); [EOL]                 ValueAxis rangeAxis = getRangeAxisForDataset(i); [EOL]                 r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis, Layer.BACKGROUND, state); [EOL]             } [EOL]         } [EOL]         for (int i = this.datasets.size() - 1; i >= 0; i--) { [EOL]             foundData = render(g2, dataArea, i, state, crosshairState) || foundData; [EOL]         } [EOL]         for (int i = datasetCount - 1; i >= 0; i--) { [EOL]             CategoryItemRenderer r = getRenderer(i); [EOL]             if (r != null) { [EOL]                 CategoryAxis domainAxis = getDomainAxisForDataset(i); [EOL]                 ValueAxis rangeAxis = getRangeAxisForDataset(i); [EOL]                 r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis, Layer.FOREGROUND, state); [EOL]             } [EOL]         } [EOL]     } [EOL]     for (int i = 0; i < this.renderers.size(); i++) { [EOL]         drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND); [EOL]     } [EOL]     for (int i = 0; i < this.renderers.size(); i++) { [EOL]         drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND); [EOL]     } [EOL]     drawAnnotations(g2, dataArea, state); [EOL]     if (this.shadowGenerator != null) { [EOL]         BufferedImage shadowImage = this.shadowGenerator.createDropShadow(dataImage); [EOL]         g2 = savedG2; [EOL]         dataArea = savedDataArea; [EOL]         g2.drawImage(shadowImage, (int) savedDataArea.getX() + this.shadowGenerator.calculateOffsetX(), (int) savedDataArea.getY() + this.shadowGenerator.calculateOffsetY(), null); [EOL]         g2.drawImage(dataImage, (int) savedDataArea.getX(), (int) savedDataArea.getY(), null); [EOL]     } [EOL]     g2.setClip(savedClip); [EOL]     g2.setComposite(originalComposite); [EOL]     if (!foundData) { [EOL]         drawNoDataMessage(g2, dataArea); [EOL]     } [EOL]     int datasetIndex = crosshairState.getDatasetIndex(); [EOL]     setCrosshairDatasetIndex(datasetIndex, false); [EOL]     Comparable rowKey = crosshairState.getRowKey(); [EOL]     Comparable columnKey = crosshairState.getColumnKey(); [EOL]     setDomainCrosshairRowKey(rowKey, false); [EOL]     setDomainCrosshairColumnKey(columnKey, false); [EOL]     if (isDomainCrosshairVisible() && columnKey != null) { [EOL]         Paint paint = getDomainCrosshairPaint(); [EOL]         Stroke stroke = getDomainCrosshairStroke(); [EOL]         drawDomainCrosshair(g2, dataArea, this.orientation, datasetIndex, rowKey, columnKey, stroke, paint); [EOL]     } [EOL]     ValueAxis yAxis = getRangeAxisForDataset(datasetIndex); [EOL]     RectangleEdge yAxisEdge = getRangeAxisEdge(); [EOL]     if (!this.rangeCrosshairLockedOnData && anchor != null) { [EOL]         double yy; [EOL]         if (getOrientation() == PlotOrientation.VERTICAL) { [EOL]             yy = yAxis.java2DToValue(anchor.getY(), dataArea, yAxisEdge); [EOL]         } else { [EOL]             yy = yAxis.java2DToValue(anchor.getX(), dataArea, yAxisEdge); [EOL]         } [EOL]         crosshairState.setCrosshairY(yy); [EOL]     } [EOL]     setRangeCrosshairValue(crosshairState.getCrosshairY(), false); [EOL]     if (isRangeCrosshairVisible()) { [EOL]         double y = getRangeCrosshairValue(); [EOL]         Paint paint = getRangeCrosshairPaint(); [EOL]         Stroke stroke = getRangeCrosshairStroke(); [EOL]         drawRangeCrosshair(g2, dataArea, getOrientation(), y, yAxis, stroke, paint); [EOL]     } [EOL]     if (isOutlineVisible()) { [EOL]         if (getRenderer() != null) { [EOL]             getRenderer().drawOutline(g2, this, dataArea); [EOL]         } else { [EOL]             drawOutline(g2, dataArea); [EOL]         } [EOL]     } [EOL] } <line_num>: 3579,3843
public void drawBackground(Graphics2D g2, Rectangle2D area) { [EOL]     fillBackground(g2, area, this.orientation); [EOL]     drawBackgroundImage(g2, area); [EOL] } <line_num>: 3855,3858
protected Map drawAxes(Graphics2D g2, Rectangle2D plotArea, Rectangle2D dataArea, PlotRenderingInfo plotState) { [EOL]     AxisCollection axisCollection = new AxisCollection(); [EOL]     for (int index = 0; index < this.domainAxes.size(); index++) { [EOL]         CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(index); [EOL]         if (xAxis != null) { [EOL]             axisCollection.add(xAxis, getDomainAxisEdge(index)); [EOL]         } [EOL]     } [EOL]     for (int index = 0; index < this.rangeAxes.size(); index++) { [EOL]         ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(index); [EOL]         if (yAxis != null) { [EOL]             axisCollection.add(yAxis, getRangeAxisEdge(index)); [EOL]         } [EOL]     } [EOL]     Map axisStateMap = new HashMap(); [EOL]     double cursor = dataArea.getMinY() - this.axisOffset.calculateTopOutset(dataArea.getHeight()); [EOL]     Iterator iterator = axisCollection.getAxesAtTop().iterator(); [EOL]     while (iterator.hasNext()) { [EOL]         Axis axis = (Axis) iterator.next(); [EOL]         if (axis != null) { [EOL]             AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea, RectangleEdge.TOP, plotState); [EOL]             cursor = axisState.getCursor(); [EOL]             axisStateMap.put(axis, axisState); [EOL]         } [EOL]     } [EOL]     cursor = dataArea.getMaxY() + this.axisOffset.calculateBottomOutset(dataArea.getHeight()); [EOL]     iterator = axisCollection.getAxesAtBottom().iterator(); [EOL]     while (iterator.hasNext()) { [EOL]         Axis axis = (Axis) iterator.next(); [EOL]         if (axis != null) { [EOL]             AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea, RectangleEdge.BOTTOM, plotState); [EOL]             cursor = axisState.getCursor(); [EOL]             axisStateMap.put(axis, axisState); [EOL]         } [EOL]     } [EOL]     cursor = dataArea.getMinX() - this.axisOffset.calculateLeftOutset(dataArea.getWidth()); [EOL]     iterator = axisCollection.getAxesAtLeft().iterator(); [EOL]     while (iterator.hasNext()) { [EOL]         Axis axis = (Axis) iterator.next(); [EOL]         if (axis != null) { [EOL]             AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea, RectangleEdge.LEFT, plotState); [EOL]             cursor = axisState.getCursor(); [EOL]             axisStateMap.put(axis, axisState); [EOL]         } [EOL]     } [EOL]     cursor = dataArea.getMaxX() + this.axisOffset.calculateRightOutset(dataArea.getWidth()); [EOL]     iterator = axisCollection.getAxesAtRight().iterator(); [EOL]     while (iterator.hasNext()) { [EOL]         Axis axis = (Axis) iterator.next(); [EOL]         if (axis != null) { [EOL]             AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea, RectangleEdge.RIGHT, plotState); [EOL]             cursor = axisState.getCursor(); [EOL]             axisStateMap.put(axis, axisState); [EOL]         } [EOL]     } [EOL]     return axisStateMap; [EOL] } <line_num>: 3871,3954
public boolean render(Graphics2D g2, Rectangle2D dataArea, int index, PlotRenderingInfo info, CategoryCrosshairState crosshairState) { [EOL]     boolean foundData = false; [EOL]     CategoryDataset currentDataset = getDataset(index); [EOL]     CategoryItemRenderer renderer = getRenderer(index); [EOL]     CategoryAxis domainAxis = getDomainAxisForDataset(index); [EOL]     ValueAxis rangeAxis = getRangeAxisForDataset(index); [EOL]     boolean hasData = !DatasetUtilities.isEmptyOrNull(currentDataset); [EOL]     if (hasData && renderer != null) { [EOL]         foundData = true; [EOL]         CategoryItemRendererState state = renderer.initialise(g2, dataArea, this, currentDataset, info); [EOL]         CategoryDatasetSelectionState selectionState = state.getSelectionState(); [EOL]         state.setCrosshairState(crosshairState); [EOL]         int columnCount = currentDataset.getColumnCount(); [EOL]         int rowCount = currentDataset.getRowCount(); [EOL]         int passCount = renderer.getPassCount(); [EOL]         for (int pass = 0; pass < passCount; pass++) { [EOL]             if (this.columnRenderingOrder == SortOrder.ASCENDING) { [EOL]                 for (int column = 0; column < columnCount; column++) { [EOL]                     if (this.rowRenderingOrder == SortOrder.ASCENDING) { [EOL]                         for (int row = 0; row < rowCount; row++) { [EOL]                             boolean selected = false; [EOL]                             if (selectionState != null) { [EOL]                                 selected = selectionState.isSelected(row, column); [EOL]                             } [EOL]                             renderer.drawItem(g2, state, dataArea, this, domainAxis, rangeAxis, currentDataset, row, column, selected, pass); [EOL]                         } [EOL]                     } else { [EOL]                         for (int row = rowCount - 1; row >= 0; row--) { [EOL]                             boolean selected = false; [EOL]                             if (selectionState != null) { [EOL]                                 selected = selectionState.isSelected(row, column); [EOL]                             } [EOL]                             renderer.drawItem(g2, state, dataArea, this, domainAxis, rangeAxis, currentDataset, row, column, selected, pass); [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } else { [EOL]                 for (int column = columnCount - 1; column >= 0; column--) { [EOL]                     if (this.rowRenderingOrder == SortOrder.ASCENDING) { [EOL]                         for (int row = 0; row < rowCount; row++) { [EOL]                             boolean selected = false; [EOL]                             if (selectionState != null) { [EOL]                                 selected = selectionState.isSelected(row, column); [EOL]                             } [EOL]                             renderer.drawItem(g2, state, dataArea, this, domainAxis, rangeAxis, currentDataset, row, column, selected, pass); [EOL]                         } [EOL]                     } else { [EOL]                         for (int row = rowCount - 1; row >= 0; row--) { [EOL]                             boolean selected = false; [EOL]                             if (selectionState != null) { [EOL]                                 selected = selectionState.isSelected(row, column); [EOL]                             } [EOL]                             renderer.drawItem(g2, state, dataArea, this, domainAxis, rangeAxis, currentDataset, row, column, selected, pass); [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return foundData; [EOL] } <line_num>: 3971,4051
protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea) { [EOL]     if (!isDomainGridlinesVisible()) { [EOL]         return; [EOL]     } [EOL]     CategoryAnchor anchor = getDomainGridlinePosition(); [EOL]     RectangleEdge domainAxisEdge = getDomainAxisEdge(); [EOL]     CategoryDataset dataset = getDataset(); [EOL]     if (dataset == null) { [EOL]         return; [EOL]     } [EOL]     CategoryAxis axis = getDomainAxis(); [EOL]     if (axis != null) { [EOL]         int columnCount = dataset.getColumnCount(); [EOL]         for (int c = 0; c < columnCount; c++) { [EOL]             double xx = axis.getCategoryJava2DCoordinate(anchor, c, columnCount, dataArea, domainAxisEdge); [EOL]             CategoryItemRenderer renderer1 = getRenderer(); [EOL]             if (renderer1 != null) { [EOL]                 renderer1.drawDomainLine(g2, this, dataArea, xx, getDomainGridlinePaint(), getDomainGridlineStroke()); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 4061,4086
protected void drawRangeGridlines(Graphics2D g2, Rectangle2D dataArea, List ticks) { [EOL]     if (!isRangeGridlinesVisible() && !isRangeMinorGridlinesVisible()) { [EOL]         return; [EOL]     } [EOL]     ValueAxis axis = getRangeAxis(); [EOL]     if (axis == null) { [EOL]         return; [EOL]     } [EOL]     CategoryItemRenderer r = getRenderer(); [EOL]     if (r == null) { [EOL]         return; [EOL]     } [EOL]     Stroke gridStroke = null; [EOL]     Paint gridPaint = null; [EOL]     boolean paintLine = false; [EOL]     Iterator iterator = ticks.iterator(); [EOL]     while (iterator.hasNext()) { [EOL]         paintLine = false; [EOL]         ValueTick tick = (ValueTick) iterator.next(); [EOL]         if ((tick.getTickType() == TickType.MINOR) && isRangeMinorGridlinesVisible()) { [EOL]             gridStroke = getRangeMinorGridlineStroke(); [EOL]             gridPaint = getRangeMinorGridlinePaint(); [EOL]             paintLine = true; [EOL]         } else if ((tick.getTickType() == TickType.MAJOR) && isRangeGridlinesVisible()) { [EOL]             gridStroke = getRangeGridlineStroke(); [EOL]             gridPaint = getRangeGridlinePaint(); [EOL]             paintLine = true; [EOL]         } [EOL]         if (((tick.getValue() != 0.0) || !isRangeZeroBaselineVisible()) && paintLine) { [EOL]             r.drawRangeLine(g2, this, axis, dataArea, tick.getValue(), gridPaint, gridStroke); [EOL]         } [EOL]     } [EOL] } <line_num>: 4097,4139
protected void drawZeroRangeBaseline(Graphics2D g2, Rectangle2D area) { [EOL]     if (!isRangeZeroBaselineVisible()) { [EOL]         return; [EOL]     } [EOL]     CategoryItemRenderer r = getRenderer(); [EOL]     r.drawRangeLine(g2, this, getRangeAxis(), area, 0.0, this.rangeZeroBaselinePaint, this.rangeZeroBaselineStroke); [EOL] } <line_num>: 4151,4158
protected void drawAnnotations(Graphics2D g2, Rectangle2D dataArea, PlotRenderingInfo info) { [EOL]     Iterator iterator = getAnnotations().iterator(); [EOL]     while (iterator.hasNext()) { [EOL]         CategoryAnnotation annotation = (CategoryAnnotation) iterator.next(); [EOL]         annotation.draw(g2, this, dataArea, getDomainAxis(), getRangeAxis(), 0, info); [EOL]     } [EOL] } <line_num>: 4167,4178
protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer) { [EOL]     CategoryItemRenderer r = getRenderer(index); [EOL]     if (r == null) { [EOL]         return; [EOL]     } [EOL]     Collection markers = getDomainMarkers(index, layer); [EOL]     CategoryAxis axis = getDomainAxisForDataset(index); [EOL]     if (markers != null && axis != null) { [EOL]         Iterator iterator = markers.iterator(); [EOL]         while (iterator.hasNext()) { [EOL]             CategoryMarker marker = (CategoryMarker) iterator.next(); [EOL]             r.drawDomainMarker(g2, this, axis, marker, dataArea); [EOL]         } [EOL]     } [EOL] } <line_num>: 4191,4209
protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer) { [EOL]     CategoryItemRenderer r = getRenderer(index); [EOL]     if (r == null) { [EOL]         return; [EOL]     } [EOL]     Collection markers = getRangeMarkers(index, layer); [EOL]     ValueAxis axis = getRangeAxisForDataset(index); [EOL]     if (markers != null && axis != null) { [EOL]         Iterator iterator = markers.iterator(); [EOL]         while (iterator.hasNext()) { [EOL]             Marker marker = (Marker) iterator.next(); [EOL]             r.drawRangeMarker(g2, this, axis, marker, dataArea); [EOL]         } [EOL]     } [EOL] } <line_num>: 4222,4240
protected void drawRangeLine(Graphics2D g2, Rectangle2D dataArea, double value, Stroke stroke, Paint paint) { [EOL]     double java2D = getRangeAxis().valueToJava2D(value, dataArea, getRangeAxisEdge()); [EOL]     Line2D line = null; [EOL]     if (this.orientation == PlotOrientation.HORIZONTAL) { [EOL]         line = new Line2D.Double(java2D, dataArea.getMinY(), java2D, dataArea.getMaxY()); [EOL]     } else if (this.orientation == PlotOrientation.VERTICAL) { [EOL]         line = new Line2D.Double(dataArea.getMinX(), java2D, dataArea.getMaxX(), java2D); [EOL]     } [EOL]     g2.setStroke(stroke); [EOL]     g2.setPaint(paint); [EOL]     g2.draw(line); [EOL] } <line_num>: 4252,4270
protected void drawDomainCrosshair(Graphics2D g2, Rectangle2D dataArea, PlotOrientation orientation, int datasetIndex, Comparable rowKey, Comparable columnKey, Stroke stroke, Paint paint) { [EOL]     CategoryDataset dataset = getDataset(datasetIndex); [EOL]     CategoryAxis axis = getDomainAxisForDataset(datasetIndex); [EOL]     CategoryItemRenderer renderer = getRenderer(datasetIndex); [EOL]     Line2D line = null; [EOL]     if (orientation == PlotOrientation.VERTICAL) { [EOL]         double xx = renderer.getItemMiddle(rowKey, columnKey, dataset, axis, dataArea, RectangleEdge.BOTTOM); [EOL]         line = new Line2D.Double(xx, dataArea.getMinY(), xx, dataArea.getMaxY()); [EOL]     } else { [EOL]         double yy = renderer.getItemMiddle(rowKey, columnKey, dataset, axis, dataArea, RectangleEdge.LEFT); [EOL]         line = new Line2D.Double(dataArea.getMinX(), yy, dataArea.getMaxX(), yy); [EOL]     } [EOL]     g2.setStroke(stroke); [EOL]     g2.setPaint(paint); [EOL]     g2.draw(line); [EOL] } <line_num>: 4289,4314
protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea, PlotOrientation orientation, double value, ValueAxis axis, Stroke stroke, Paint paint) { [EOL]     if (!axis.getRange().contains(value)) { [EOL]         return; [EOL]     } [EOL]     Line2D line = null; [EOL]     if (orientation == PlotOrientation.HORIZONTAL) { [EOL]         double xx = axis.valueToJava2D(value, dataArea, RectangleEdge.BOTTOM); [EOL]         line = new Line2D.Double(xx, dataArea.getMinY(), xx, dataArea.getMaxY()); [EOL]     } else { [EOL]         double yy = axis.valueToJava2D(value, dataArea, RectangleEdge.LEFT); [EOL]         line = new Line2D.Double(dataArea.getMinX(), yy, dataArea.getMaxX(), yy); [EOL]     } [EOL]     g2.setStroke(stroke); [EOL]     g2.setPaint(paint); [EOL]     g2.draw(line); [EOL] } <line_num>: 4332,4356
public Range getDataRange(ValueAxis axis) { [EOL]     Range result = null; [EOL]     List mappedDatasets = new ArrayList(); [EOL]     int rangeIndex = this.rangeAxes.indexOf(axis); [EOL]     if (rangeIndex >= 0) { [EOL]         mappedDatasets.addAll(datasetsMappedToRangeAxis(rangeIndex)); [EOL]     } else if (axis == getRangeAxis()) { [EOL]         mappedDatasets.addAll(datasetsMappedToRangeAxis(0)); [EOL]     } [EOL]     Iterator iterator = mappedDatasets.iterator(); [EOL]     while (iterator.hasNext()) { [EOL]         CategoryDataset d = (CategoryDataset) iterator.next(); [EOL]         CategoryItemRenderer r = getRendererForDataset(d); [EOL]         if (r != null) { [EOL]             result = Range.combine(result, r.findRangeBounds(d)); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } <line_num>: 4367,4392
private List datasetsMappedToDomainAxis(int axisIndex) { [EOL]     Integer key = new Integer(axisIndex); [EOL]     List result = new ArrayList(); [EOL]     for (int i = 0; i < this.datasets.size(); i++) { [EOL]         List mappedAxes = (List) this.datasetToDomainAxesMap.get(new Integer(i)); [EOL]         CategoryDataset dataset = (CategoryDataset) this.datasets.get(i); [EOL]         if (mappedAxes == null) { [EOL]             if (key.equals(ZERO)) { [EOL]                 if (dataset != null) { [EOL]                     result.add(dataset); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (mappedAxes.contains(key)) { [EOL]                 if (dataset != null) { [EOL]                     result.add(dataset); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] } <line_num>: 4404,4427
private List datasetsMappedToRangeAxis(int index) { [EOL]     Integer key = new Integer(index); [EOL]     List result = new ArrayList(); [EOL]     for (int i = 0; i < this.datasets.size(); i++) { [EOL]         List mappedAxes = (List) this.datasetToRangeAxesMap.get(new Integer(i)); [EOL]         if (mappedAxes == null) { [EOL]             if (key.equals(ZERO)) { [EOL]                 result.add(this.datasets.get(i)); [EOL]             } [EOL]         } else { [EOL]             if (mappedAxes.contains(key)) { [EOL]                 result.add(this.datasets.get(i)); [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] } <line_num>: 4437,4455
public int getWeight() { [EOL]     return this.weight; [EOL] } <line_num>: 4465,4467
public void setWeight(int weight) { [EOL]     this.weight = weight; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 4477,4480
public AxisSpace getFixedDomainAxisSpace() { [EOL]     return this.fixedDomainAxisSpace; [EOL] } <line_num>: 4489,4491
public void setFixedDomainAxisSpace(AxisSpace space) { [EOL]     setFixedDomainAxisSpace(space, true); [EOL] } <line_num>: 4501,4503
public void setFixedDomainAxisSpace(AxisSpace space, boolean notify) { [EOL]     this.fixedDomainAxisSpace = space; [EOL]     if (notify) { [EOL]         fireChangeEvent(); [EOL]     } [EOL] } <line_num>: 4516,4521
public AxisSpace getFixedRangeAxisSpace() { [EOL]     return this.fixedRangeAxisSpace; [EOL] } <line_num>: 4530,4532
public void setFixedRangeAxisSpace(AxisSpace space) { [EOL]     setFixedRangeAxisSpace(space, true); [EOL] } <line_num>: 4542,4544
public void setFixedRangeAxisSpace(AxisSpace space, boolean notify) { [EOL]     this.fixedRangeAxisSpace = space; [EOL]     if (notify) { [EOL]         fireChangeEvent(); [EOL]     } [EOL] } <line_num>: 4557,4562
public List getCategories() { [EOL]     List result = null; [EOL]     if (getDataset() != null) { [EOL]         result = Collections.unmodifiableList(getDataset().getColumnKeys()); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 4571,4577
public List getCategoriesForAxis(CategoryAxis axis) { [EOL]     List result = new ArrayList(); [EOL]     int axisIndex = this.domainAxes.indexOf(axis); [EOL]     List datasets = datasetsMappedToDomainAxis(axisIndex); [EOL]     Iterator iterator = datasets.iterator(); [EOL]     while (iterator.hasNext()) { [EOL]         CategoryDataset dataset = (CategoryDataset) iterator.next(); [EOL]         for (int i = 0; i < dataset.getColumnCount(); i++) { [EOL]             Comparable category = dataset.getColumnKey(i); [EOL]             if (!result.contains(category)) { [EOL]                 result.add(category); [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] } <line_num>: 4589,4605
public boolean getDrawSharedDomainAxis() { [EOL]     return this.drawSharedDomainAxis; [EOL] } <line_num>: 4615,4617
public void setDrawSharedDomainAxis(boolean draw) { [EOL]     this.drawSharedDomainAxis = draw; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 4627,4630
public boolean isDomainPannable() { [EOL]     return false; [EOL] } <line_num>: 4642,4644
public boolean isRangePannable() { [EOL]     return this.rangePannable; [EOL] } <line_num>: 4657,4659
public void setRangePannable(boolean pannable) { [EOL]     this.rangePannable = pannable; [EOL] } <line_num>: 4671,4673
public void panDomainAxes(double percent, PlotRenderingInfo info, Point2D source) { [EOL] } <line_num>: 4684,4687
public void panRangeAxes(double percent, PlotRenderingInfo info, Point2D source) { [EOL]     if (!isRangePannable()) { [EOL]         return; [EOL]     } [EOL]     int rangeAxisCount = getRangeAxisCount(); [EOL]     for (int i = 0; i < rangeAxisCount; i++) { [EOL]         ValueAxis axis = getRangeAxis(i); [EOL]         if (axis == null) { [EOL]             continue; [EOL]         } [EOL]         double length = axis.getRange().getLength(); [EOL]         double adj = percent * length; [EOL]         if (axis.isInverted()) { [EOL]             adj = -adj; [EOL]         } [EOL]         axis.setRange(axis.getLowerBound() + adj, axis.getUpperBound() + adj); [EOL]     } [EOL] } <line_num>: 4698,4717
public boolean isDomainZoomable() { [EOL]     return false; [EOL] } <line_num>: 4727,4729
public boolean isRangeZoomable() { [EOL]     return true; [EOL] } <line_num>: 4738,4740
public void zoomDomainAxes(double factor, PlotRenderingInfo state, Point2D source) { [EOL] } <line_num>: 4750,4753
public void zoomDomainAxes(double lowerPercent, double upperPercent, PlotRenderingInfo state, Point2D source) { [EOL] } <line_num>: 4764,4767
public void zoomDomainAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor) { [EOL] } <line_num>: 4782,4785
public void zoomRangeAxes(double factor, PlotRenderingInfo state, Point2D source) { [EOL]     zoomRangeAxes(factor, state, source, false); [EOL] } <line_num>: 4794,4798
public void zoomRangeAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor) { [EOL]     for (int i = 0; i < this.rangeAxes.size(); i++) { [EOL]         ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i); [EOL]         if (rangeAxis != null) { [EOL]             if (useAnchor) { [EOL]                 double sourceY = source.getY(); [EOL]                 if (this.orientation == PlotOrientation.HORIZONTAL) { [EOL]                     sourceY = source.getX(); [EOL]                 } [EOL]                 double anchorY = rangeAxis.java2DToValue(sourceY, info.getDataArea(), getRangeAxisEdge()); [EOL]                 rangeAxis.resizeRange2(factor, anchorY); [EOL]             } else { [EOL]                 rangeAxis.resizeRange(factor); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 4813,4836
public void zoomRangeAxes(double lowerPercent, double upperPercent, PlotRenderingInfo state, Point2D source) { [EOL]     for (int i = 0; i < this.rangeAxes.size(); i++) { [EOL]         ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i); [EOL]         if (rangeAxis != null) { [EOL]             rangeAxis.zoomRange(lowerPercent, upperPercent); [EOL]         } [EOL]     } [EOL] } <line_num>: 4846,4854
public double getAnchorValue() { [EOL]     return this.anchorValue; [EOL] } <line_num>: 4863,4865
public void setAnchorValue(double value) { [EOL]     setAnchorValue(value, true); [EOL] } <line_num>: 4875,4877
public void setAnchorValue(double value, boolean notify) { [EOL]     this.anchorValue = value; [EOL]     if (notify) { [EOL]         fireChangeEvent(); [EOL]     } [EOL] } <line_num>: 4888,4893
public boolean equals(Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(obj instanceof CategoryPlot)) { [EOL]         return false; [EOL]     } [EOL]     CategoryPlot that = (CategoryPlot) obj; [EOL]     if (this.orientation != that.orientation) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.axisOffset, that.axisOffset)) { [EOL]         return false; [EOL]     } [EOL]     if (!this.domainAxes.equals(that.domainAxes)) { [EOL]         return false; [EOL]     } [EOL]     if (!this.domainAxisLocations.equals(that.domainAxisLocations)) { [EOL]         return false; [EOL]     } [EOL]     if (this.drawSharedDomainAxis != that.drawSharedDomainAxis) { [EOL]         return false; [EOL]     } [EOL]     if (!this.rangeAxes.equals(that.rangeAxes)) { [EOL]         return false; [EOL]     } [EOL]     if (!this.rangeAxisLocations.equals(that.rangeAxisLocations)) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.datasetToDomainAxesMap, that.datasetToDomainAxesMap)) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.datasetToRangeAxesMap, that.datasetToRangeAxesMap)) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.renderers, that.renderers)) { [EOL]         return false; [EOL]     } [EOL]     if (this.renderingOrder != that.renderingOrder) { [EOL]         return false; [EOL]     } [EOL]     if (this.columnRenderingOrder != that.columnRenderingOrder) { [EOL]         return false; [EOL]     } [EOL]     if (this.rowRenderingOrder != that.rowRenderingOrder) { [EOL]         return false; [EOL]     } [EOL]     if (this.domainGridlinesVisible != that.domainGridlinesVisible) { [EOL]         return false; [EOL]     } [EOL]     if (this.domainGridlinePosition != that.domainGridlinePosition) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.domainGridlineStroke, that.domainGridlineStroke)) { [EOL]         return false; [EOL]     } [EOL]     if (!PaintUtilities.equal(this.domainGridlinePaint, that.domainGridlinePaint)) { [EOL]         return false; [EOL]     } [EOL]     if (this.rangeGridlinesVisible != that.rangeGridlinesVisible) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.rangeGridlineStroke, that.rangeGridlineStroke)) { [EOL]         return false; [EOL]     } [EOL]     if (!PaintUtilities.equal(this.rangeGridlinePaint, that.rangeGridlinePaint)) { [EOL]         return false; [EOL]     } [EOL]     if (this.anchorValue != that.anchorValue) { [EOL]         return false; [EOL]     } [EOL]     if (this.rangeCrosshairVisible != that.rangeCrosshairVisible) { [EOL]         return false; [EOL]     } [EOL]     if (this.rangeCrosshairValue != that.rangeCrosshairValue) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.rangeCrosshairStroke, that.rangeCrosshairStroke)) { [EOL]         return false; [EOL]     } [EOL]     if (!PaintUtilities.equal(this.rangeCrosshairPaint, that.rangeCrosshairPaint)) { [EOL]         return false; [EOL]     } [EOL]     if (this.rangeCrosshairLockedOnData != that.rangeCrosshairLockedOnData) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.foregroundDomainMarkers, that.foregroundDomainMarkers)) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.backgroundDomainMarkers, that.backgroundDomainMarkers)) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.foregroundRangeMarkers, that.foregroundRangeMarkers)) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.backgroundRangeMarkers, that.backgroundRangeMarkers)) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.annotations, that.annotations)) { [EOL]         return false; [EOL]     } [EOL]     if (this.weight != that.weight) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.fixedDomainAxisSpace, that.fixedDomainAxisSpace)) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.fixedRangeAxisSpace, that.fixedRangeAxisSpace)) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.fixedLegendItems, that.fixedLegendItems)) { [EOL]         return false; [EOL]     } [EOL]     if (this.domainCrosshairVisible != that.domainCrosshairVisible) { [EOL]         return false; [EOL]     } [EOL]     if (this.crosshairDatasetIndex != that.crosshairDatasetIndex) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.domainCrosshairColumnKey, that.domainCrosshairColumnKey)) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.domainCrosshairRowKey, that.domainCrosshairRowKey)) { [EOL]         return false; [EOL]     } [EOL]     if (!PaintUtilities.equal(this.domainCrosshairPaint, that.domainCrosshairPaint)) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.domainCrosshairStroke, that.domainCrosshairStroke)) { [EOL]         return false; [EOL]     } [EOL]     if (this.rangeMinorGridlinesVisible != that.rangeMinorGridlinesVisible) { [EOL]         return false; [EOL]     } [EOL]     if (!PaintUtilities.equal(this.rangeMinorGridlinePaint, that.rangeMinorGridlinePaint)) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.rangeMinorGridlineStroke, that.rangeMinorGridlineStroke)) { [EOL]         return false; [EOL]     } [EOL]     if (this.rangeZeroBaselineVisible != that.rangeZeroBaselineVisible) { [EOL]         return false; [EOL]     } [EOL]     if (!PaintUtilities.equal(this.rangeZeroBaselinePaint, that.rangeZeroBaselinePaint)) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.rangeZeroBaselineStroke, that.rangeZeroBaselineStroke)) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.shadowGenerator, that.shadowGenerator)) { [EOL]         return false; [EOL]     } [EOL]     return super.equals(obj); [EOL] } <line_num>: 4902,5081
public Object clone() throws CloneNotSupportedException { [EOL]     CategoryPlot clone = (CategoryPlot) super.clone(); [EOL]     clone.domainAxes = new ObjectList(); [EOL]     for (int i = 0; i < this.domainAxes.size(); i++) { [EOL]         CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(i); [EOL]         if (xAxis != null) { [EOL]             CategoryAxis clonedAxis = (CategoryAxis) xAxis.clone(); [EOL]             clone.setDomainAxis(i, clonedAxis); [EOL]         } [EOL]     } [EOL]     clone.domainAxisLocations = (ObjectList) this.domainAxisLocations.clone(); [EOL]     clone.rangeAxes = new ObjectList(); [EOL]     for (int i = 0; i < this.rangeAxes.size(); i++) { [EOL]         ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(i); [EOL]         if (yAxis != null) { [EOL]             ValueAxis clonedAxis = (ValueAxis) yAxis.clone(); [EOL]             clone.setRangeAxis(i, clonedAxis); [EOL]         } [EOL]     } [EOL]     clone.rangeAxisLocations = (ObjectList) this.rangeAxisLocations.clone(); [EOL]     clone.datasets = (ObjectList) this.datasets.clone(); [EOL]     for (int i = 0; i < clone.datasets.size(); i++) { [EOL]         CategoryDataset dataset = clone.getDataset(i); [EOL]         if (dataset != null) { [EOL]             dataset.addChangeListener(clone); [EOL]         } [EOL]     } [EOL]     clone.datasetToDomainAxesMap = new TreeMap(); [EOL]     clone.datasetToDomainAxesMap.putAll(this.datasetToDomainAxesMap); [EOL]     clone.datasetToRangeAxesMap = new TreeMap(); [EOL]     clone.datasetToRangeAxesMap.putAll(this.datasetToRangeAxesMap); [EOL]     clone.renderers = (ObjectList) this.renderers.clone(); [EOL]     for (int i = 0; i < this.renderers.size(); i++) { [EOL]         CategoryItemRenderer renderer2 = (CategoryItemRenderer) this.renderers.get(i); [EOL]         if (renderer2 instanceof PublicCloneable) { [EOL]             PublicCloneable pc = (PublicCloneable) renderer2; [EOL]             CategoryItemRenderer rc = (CategoryItemRenderer) pc.clone(); [EOL]             clone.renderers.set(i, rc); [EOL]             rc.setPlot(clone); [EOL]             rc.addChangeListener(clone); [EOL]         } [EOL]     } [EOL]     if (this.fixedDomainAxisSpace != null) { [EOL]         clone.fixedDomainAxisSpace = (AxisSpace) ObjectUtilities.clone(this.fixedDomainAxisSpace); [EOL]     } [EOL]     if (this.fixedRangeAxisSpace != null) { [EOL]         clone.fixedRangeAxisSpace = (AxisSpace) ObjectUtilities.clone(this.fixedRangeAxisSpace); [EOL]     } [EOL]     clone.annotations = (List) ObjectUtilities.deepClone(this.annotations); [EOL]     clone.foregroundDomainMarkers = cloneMarkerMap(this.foregroundDomainMarkers); [EOL]     clone.backgroundDomainMarkers = cloneMarkerMap(this.backgroundDomainMarkers); [EOL]     clone.foregroundRangeMarkers = cloneMarkerMap(this.foregroundRangeMarkers); [EOL]     clone.backgroundRangeMarkers = cloneMarkerMap(this.backgroundRangeMarkers); [EOL]     if (this.fixedLegendItems != null) { [EOL]         clone.fixedLegendItems = (LegendItemCollection) this.fixedLegendItems.clone(); [EOL]     } [EOL]     return clone; [EOL] } <line_num>: 5090,5163
private Map cloneMarkerMap(Map map) throws CloneNotSupportedException { [EOL]     Map clone = new HashMap(); [EOL]     Set keys = map.keySet(); [EOL]     Iterator iterator = keys.iterator(); [EOL]     while (iterator.hasNext()) { [EOL]         Object key = iterator.next(); [EOL]         List entry = (List) map.get(key); [EOL]         Object toAdd = ObjectUtilities.deepClone(entry); [EOL]         clone.put(key, toAdd); [EOL]     } [EOL]     return clone; [EOL] } <line_num>: 5175,5186
private void writeObject(ObjectOutputStream stream) throws IOException { [EOL]     stream.defaultWriteObject(); [EOL]     SerialUtilities.writeStroke(this.domainGridlineStroke, stream); [EOL]     SerialUtilities.writePaint(this.domainGridlinePaint, stream); [EOL]     SerialUtilities.writeStroke(this.rangeGridlineStroke, stream); [EOL]     SerialUtilities.writePaint(this.rangeGridlinePaint, stream); [EOL]     SerialUtilities.writeStroke(this.rangeCrosshairStroke, stream); [EOL]     SerialUtilities.writePaint(this.rangeCrosshairPaint, stream); [EOL]     SerialUtilities.writeStroke(this.domainCrosshairStroke, stream); [EOL]     SerialUtilities.writePaint(this.domainCrosshairPaint, stream); [EOL]     SerialUtilities.writeStroke(this.rangeMinorGridlineStroke, stream); [EOL]     SerialUtilities.writePaint(this.rangeMinorGridlinePaint, stream); [EOL]     SerialUtilities.writeStroke(this.rangeZeroBaselineStroke, stream); [EOL]     SerialUtilities.writePaint(this.rangeZeroBaselinePaint, stream); [EOL] } <line_num>: 5195,5209
private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException { [EOL]     stream.defaultReadObject(); [EOL]     this.domainGridlineStroke = SerialUtilities.readStroke(stream); [EOL]     this.domainGridlinePaint = SerialUtilities.readPaint(stream); [EOL]     this.rangeGridlineStroke = SerialUtilities.readStroke(stream); [EOL]     this.rangeGridlinePaint = SerialUtilities.readPaint(stream); [EOL]     this.rangeCrosshairStroke = SerialUtilities.readStroke(stream); [EOL]     this.rangeCrosshairPaint = SerialUtilities.readPaint(stream); [EOL]     this.domainCrosshairStroke = SerialUtilities.readStroke(stream); [EOL]     this.domainCrosshairPaint = SerialUtilities.readPaint(stream); [EOL]     this.rangeMinorGridlineStroke = SerialUtilities.readStroke(stream); [EOL]     this.rangeMinorGridlinePaint = SerialUtilities.readPaint(stream); [EOL]     this.rangeZeroBaselineStroke = SerialUtilities.readStroke(stream); [EOL]     this.rangeZeroBaselinePaint = SerialUtilities.readPaint(stream); [EOL]     for (int i = 0; i < this.domainAxes.size(); i++) { [EOL]         CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(i); [EOL]         if (xAxis != null) { [EOL]             xAxis.setPlot(this); [EOL]             xAxis.addChangeListener(this); [EOL]         } [EOL]     } [EOL]     for (int i = 0; i < this.rangeAxes.size(); i++) { [EOL]         ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(i); [EOL]         if (yAxis != null) { [EOL]             yAxis.setPlot(this); [EOL]             yAxis.addChangeListener(this); [EOL]         } [EOL]     } [EOL]     int datasetCount = this.datasets.size(); [EOL]     for (int i = 0; i < datasetCount; i++) { [EOL]         Dataset dataset = (Dataset) this.datasets.get(i); [EOL]         if (dataset != null) { [EOL]             dataset.addChangeListener(this); [EOL]         } [EOL]     } [EOL]     int rendererCount = this.renderers.size(); [EOL]     for (int i = 0; i < rendererCount; i++) { [EOL]         CategoryItemRenderer renderer = (CategoryItemRenderer) this.renderers.get(i); [EOL]         if (renderer != null) { [EOL]             renderer.addChangeListener(this); [EOL]         } [EOL]     } [EOL] } <line_num>: 5219,5266
public boolean canSelectByPoint() { [EOL]     return true; [EOL] } <line_num>: 5276,5278
public boolean canSelectByRegion() { [EOL]     return true; [EOL] } <line_num>: 5288,5290
public void select(double x, double y, Rectangle2D dataArea, RenderingSource source) { [EOL]     int datasetCount = this.datasets.size(); [EOL]     for (int d = 0; d < datasetCount; d++) { [EOL]         CategoryDataset dataset = (CategoryDataset) this.datasets.get(d); [EOL]         if (dataset == null) { [EOL]             continue; [EOL]         } [EOL]         CategoryDatasetSelectionState state = findSelectionStateForDataset(dataset, source); [EOL]         if (state == null) { [EOL]             continue; [EOL]         } [EOL]         Graphics2D g2 = source.createGraphics2D(); [EOL]         CategoryItemRenderer renderer = getRendererForDataset(dataset); [EOL]         CategoryItemRendererState rs = renderer.initialise(g2, dataArea, this, dataset, null); [EOL]         int rowCount = dataset.getRowCount(); [EOL]         int columnCount = dataset.getColumnCount(); [EOL]         for (int r = 0; r < rowCount; r++) { [EOL]             for (int c = 0; c < columnCount; c++) { [EOL]                 if (renderer.hitTest(x, y, null, dataArea, this, getDomainAxisForDataset(d), getRangeAxisForDataset(d), dataset, r, c, false, rs)) { [EOL]                     state.setSelected(r, c, !state.isSelected(r, c)); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 5303,5334
public void select(GeneralPath region, Rectangle2D dataArea, RenderingSource source) { [EOL]     System.out.println(region); [EOL]     System.out.println("Select a region..."); [EOL] } <line_num>: 5346,5350
public void clearSelection() { [EOL]     int datasetCount = this.datasets.size(); [EOL]     for (int d = 0; d < datasetCount; d++) { [EOL]         CategoryDataset dataset = (CategoryDataset) this.datasets.get(d); [EOL]         if (dataset instanceof SelectableCategoryDataset) { [EOL]             SelectableCategoryDataset scd = (SelectableCategoryDataset) dataset; [EOL]             if (scd.getSelectionState() != null) { [EOL]                 CategoryDatasetSelectionState selState = scd.getSelectionState(); [EOL]                 selState.clearSelection(); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 5357,5374
private CategoryDatasetSelectionState findSelectionStateForDataset(CategoryDataset dataset, Object source) { [EOL]     if (dataset instanceof SelectableCategoryDataset) { [EOL]         SelectableCategoryDataset sd = (SelectableCategoryDataset) dataset; [EOL]         CategoryDatasetSelectionState s = sd.getSelectionState(); [EOL]         return s; [EOL]     } [EOL]     throw new RuntimeException(); [EOL] } <line_num>: 5386,5395
