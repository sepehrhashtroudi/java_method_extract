public DateAxis() { [EOL]     this(null); [EOL] } <line_num>: 339,341
public DateAxis(String label) { [EOL]     this(label, TimeZone.getDefault()); [EOL] } <line_num>: 348,350
public DateAxis(String label, TimeZone zone) { [EOL]     this(label, zone, Locale.getDefault()); [EOL] } <line_num>: 365,367
public DateAxis(String label, TimeZone zone, Locale locale) { [EOL]     super(label, DateAxis.createStandardDateTickUnits(zone, locale)); [EOL]     setTickUnit(DateAxis.DEFAULT_DATE_TICK_UNIT, false, false); [EOL]     setAutoRangeMinimumSize(DEFAULT_AUTO_RANGE_MINIMUM_SIZE_IN_MILLISECONDS); [EOL]     setRange(DEFAULT_DATE_RANGE, false, false); [EOL]     this.dateFormatOverride = null; [EOL]     this.timeZone = zone; [EOL]     this.locale = locale; [EOL]     this.timeline = DEFAULT_TIMELINE; [EOL] } <line_num>: 382,392
public long toTimelineValue(long millisecond) { [EOL]     return millisecond; [EOL] } <line_num>: 222,224
public long toTimelineValue(Date date) { [EOL]     return date.getTime(); [EOL] } <line_num>: 233,235
public long toMillisecond(long value) { [EOL]     return value; [EOL] } <line_num>: 245,247
public boolean containsDomainValue(long millisecond) { [EOL]     return true; [EOL] } <line_num>: 257,259
public boolean containsDomainValue(Date date) { [EOL]     return true; [EOL] } <line_num>: 269,271
public boolean containsDomainRange(long from, long to) { [EOL]     return true; [EOL] } <line_num>: 282,284
public boolean containsDomainRange(Date from, Date to) { [EOL]     return true; [EOL] } <line_num>: 295,297
public boolean equals(Object object) { [EOL]     if (object == null) { [EOL]         return false; [EOL]     } [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof DefaultTimeline) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 306,317
public TimeZone getTimeZone() { [EOL]     return this.timeZone; [EOL] } <line_num>: 403,405
public void setTimeZone(TimeZone zone) { [EOL]     if (zone == null) { [EOL]         throw new IllegalArgumentException("Null 'zone' argument."); [EOL]     } [EOL]     if (!this.timeZone.equals(zone)) { [EOL]         this.timeZone = zone; [EOL]         setStandardTickUnits(createStandardDateTickUnits(zone, this.locale)); [EOL]         notifyListeners(new AxisChangeEvent(this)); [EOL]     } [EOL] } <line_num>: 417,427
public Timeline getTimeline() { [EOL]     return this.timeline; [EOL] } <line_num>: 434,436
public void setTimeline(Timeline timeline) { [EOL]     if (this.timeline != timeline) { [EOL]         this.timeline = timeline; [EOL]         notifyListeners(new AxisChangeEvent(this)); [EOL]     } [EOL] } <line_num>: 446,451
public DateTickUnit getTickUnit() { [EOL]     return this.tickUnit; [EOL] } <line_num>: 466,468
public void setTickUnit(DateTickUnit unit) { [EOL]     setTickUnit(unit, true, true); [EOL] } <line_num>: 480,482
public void setTickUnit(DateTickUnit unit, boolean notify, boolean turnOffAutoSelection) { [EOL]     this.tickUnit = unit; [EOL]     if (turnOffAutoSelection) { [EOL]         setAutoTickUnitSelection(false, false); [EOL]     } [EOL]     if (notify) { [EOL]         notifyListeners(new AxisChangeEvent(this)); [EOL]     } [EOL] } <line_num>: 493,504
public DateFormat getDateFormatOverride() { [EOL]     return this.dateFormatOverride; [EOL] } <line_num>: 512,514
public void setDateFormatOverride(DateFormat formatter) { [EOL]     this.dateFormatOverride = formatter; [EOL]     notifyListeners(new AxisChangeEvent(this)); [EOL] } <line_num>: 522,525
public void setRange(Range range) { [EOL]     setRange(range, true, true); [EOL] } <line_num>: 534,536
public void setRange(Range range, boolean turnOffAutoRange, boolean notify) { [EOL]     if (range == null) { [EOL]         throw new IllegalArgumentException("Null 'range' argument."); [EOL]     } [EOL]     if (!(range instanceof DateRange)) { [EOL]         range = new DateRange(range); [EOL]     } [EOL]     super.setRange(range, turnOffAutoRange, notify); [EOL] } <line_num>: 549,560
public void setRange(Date lower, Date upper) { [EOL]     if (lower.getTime() >= upper.getTime()) { [EOL]         throw new IllegalArgumentException("Requires 'lower' < 'upper'."); [EOL]     } [EOL]     setRange(new DateRange(lower, upper)); [EOL] } <line_num>: 569,574
public void setRange(double lower, double upper) { [EOL]     if (lower >= upper) { [EOL]         throw new IllegalArgumentException("Requires 'lower' < 'upper'."); [EOL]     } [EOL]     setRange(new DateRange(lower, upper)); [EOL] } <line_num>: 583,588
public Date getMinimumDate() { [EOL]     Date result = null; [EOL]     Range range = getRange(); [EOL]     if (range instanceof DateRange) { [EOL]         DateRange r = (DateRange) range; [EOL]         result = r.getLowerDate(); [EOL]     } else { [EOL]         result = new Date((long) range.getLowerBound()); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 598,609
public void setMinimumDate(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("Null 'date' argument."); [EOL]     } [EOL]     Date maxDate = getMaximumDate(); [EOL]     long maxMillis = maxDate.getTime(); [EOL]     long newMinMillis = date.getTime(); [EOL]     if (maxMillis <= newMinMillis) { [EOL]         Date oldMin = getMinimumDate(); [EOL]         long length = maxMillis - oldMin.getTime(); [EOL]         maxDate = new Date(newMinMillis + length); [EOL]     } [EOL]     setRange(new DateRange(date, maxDate), true, false); [EOL]     notifyListeners(new AxisChangeEvent(this)); [EOL] } <line_num>: 623,638
public Date getMaximumDate() { [EOL]     Date result = null; [EOL]     Range range = getRange(); [EOL]     if (range instanceof DateRange) { [EOL]         DateRange r = (DateRange) range; [EOL]         result = r.getUpperDate(); [EOL]     } else { [EOL]         result = new Date((long) range.getUpperBound()); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 648,659
public void setMaximumDate(Date maximumDate) { [EOL]     if (maximumDate == null) { [EOL]         throw new IllegalArgumentException("Null 'maximumDate' argument."); [EOL]     } [EOL]     Date minDate = getMinimumDate(); [EOL]     long minMillis = minDate.getTime(); [EOL]     long newMaxMillis = maximumDate.getTime(); [EOL]     if (minMillis >= newMaxMillis) { [EOL]         Date oldMax = getMaximumDate(); [EOL]         long length = oldMax.getTime() - minMillis; [EOL]         minDate = new Date(newMaxMillis - length); [EOL]     } [EOL]     setRange(new DateRange(minDate, maximumDate), true, false); [EOL]     notifyListeners(new AxisChangeEvent(this)); [EOL] } <line_num>: 673,688
public DateTickMarkPosition getTickMarkPosition() { [EOL]     return this.tickMarkPosition; [EOL] } <line_num>: 695,697
public void setTickMarkPosition(DateTickMarkPosition position) { [EOL]     if (position == null) { [EOL]         throw new IllegalArgumentException("Null 'position' argument."); [EOL]     } [EOL]     this.tickMarkPosition = position; [EOL]     notifyListeners(new AxisChangeEvent(this)); [EOL] } <line_num>: 705,711
public void configure() { [EOL]     if (isAutoRange()) { [EOL]         autoAdjustRange(); [EOL]     } [EOL] } <line_num>: 717,721
public boolean isHiddenValue(long millis) { [EOL]     return (!this.timeline.containsDomainValue(new Date(millis))); [EOL] } <line_num>: 731,733
public double valueToJava2D(double value, Rectangle2D area, RectangleEdge edge) { [EOL]     value = this.timeline.toTimelineValue((long) value); [EOL]     DateRange range = (DateRange) getRange(); [EOL]     double axisMin = this.timeline.toTimelineValue(range.getLowerMillis()); [EOL]     double axisMax = this.timeline.toTimelineValue(range.getUpperMillis()); [EOL]     double result = 0.0; [EOL]     if (RectangleEdge.isTopOrBottom(edge)) { [EOL]         double minX = area.getX(); [EOL]         double maxX = area.getMaxX(); [EOL]         if (isInverted()) { [EOL]             result = maxX + ((value - axisMin) / (axisMax - axisMin)) * (minX - maxX); [EOL]         } else { [EOL]             result = minX + ((value - axisMin) / (axisMax - axisMin)) * (maxX - minX); [EOL]         } [EOL]     } else if (RectangleEdge.isLeftOrRight(edge)) { [EOL]         double minY = area.getMinY(); [EOL]         double maxY = area.getMaxY(); [EOL]         if (isInverted()) { [EOL]             result = minY + (((value - axisMin) / (axisMax - axisMin)) * (maxY - minY)); [EOL]         } else { [EOL]             result = maxY - (((value - axisMin) / (axisMax - axisMin)) * (maxY - minY)); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } <line_num>: 746,781
public double dateToJava2D(Date date, Rectangle2D area, RectangleEdge edge) { [EOL]     double value = date.getTime(); [EOL]     return valueToJava2D(value, area, edge); [EOL] } <line_num>: 794,798
public double java2DToValue(double java2DValue, Rectangle2D area, RectangleEdge edge) { [EOL]     DateRange range = (DateRange) getRange(); [EOL]     double axisMin = this.timeline.toTimelineValue(range.getLowerMillis()); [EOL]     double axisMax = this.timeline.toTimelineValue(range.getUpperMillis()); [EOL]     double min = 0.0; [EOL]     double max = 0.0; [EOL]     if (RectangleEdge.isTopOrBottom(edge)) { [EOL]         min = area.getX(); [EOL]         max = area.getMaxX(); [EOL]     } else if (RectangleEdge.isLeftOrRight(edge)) { [EOL]         min = area.getMaxY(); [EOL]         max = area.getY(); [EOL]     } [EOL]     double result; [EOL]     if (isInverted()) { [EOL]         result = axisMax - ((java2DValue - min) / (max - min) * (axisMax - axisMin)); [EOL]     } else { [EOL]         result = axisMin + ((java2DValue - min) / (max - min) * (axisMax - axisMin)); [EOL]     } [EOL]     return this.timeline.toMillisecond((long) result); [EOL] } <line_num>: 812,841
public Date calculateLowestVisibleTickValue(DateTickUnit unit) { [EOL]     return nextStandardDate(getMinimumDate(), unit); [EOL] } <line_num>: 850,852
public Date calculateHighestVisibleTickValue(DateTickUnit unit) { [EOL]     return previousStandardDate(getMaximumDate(), unit); [EOL] } <line_num>: 861,863
protected Date previousStandardDate(Date date, DateTickUnit unit) { [EOL]     int milliseconds; [EOL]     int seconds; [EOL]     int minutes; [EOL]     int hours; [EOL]     int days; [EOL]     int months; [EOL]     int years; [EOL]     Calendar calendar = Calendar.getInstance(this.timeZone, this.locale); [EOL]     calendar.setTime(date); [EOL]     int count = unit.getMultiple(); [EOL]     int current = calendar.get(unit.getCalendarField()); [EOL]     int value = count * (current / count); [EOL]     DateTickUnitType t = unit.getUnitType(); [EOL]     if (t.equals(DateTickUnitType.MILLISECOND)) { [EOL]         years = calendar.get(Calendar.YEAR); [EOL]         months = calendar.get(Calendar.MONTH); [EOL]         days = calendar.get(Calendar.DATE); [EOL]         hours = calendar.get(Calendar.HOUR_OF_DAY); [EOL]         minutes = calendar.get(Calendar.MINUTE); [EOL]         seconds = calendar.get(Calendar.SECOND); [EOL]         calendar.set(years, months, days, hours, minutes, seconds); [EOL]         calendar.set(Calendar.MILLISECOND, value); [EOL]         Date mm = calendar.getTime(); [EOL]         if (mm.getTime() >= date.getTime()) { [EOL]             calendar.set(Calendar.MILLISECOND, value - 1); [EOL]             mm = calendar.getTime(); [EOL]         } [EOL]         return mm; [EOL]     } else if (t.equals(DateTickUnitType.SECOND)) { [EOL]         years = calendar.get(Calendar.YEAR); [EOL]         months = calendar.get(Calendar.MONTH); [EOL]         days = calendar.get(Calendar.DATE); [EOL]         hours = calendar.get(Calendar.HOUR_OF_DAY); [EOL]         minutes = calendar.get(Calendar.MINUTE); [EOL]         if (this.tickMarkPosition == DateTickMarkPosition.START) { [EOL]             milliseconds = 0; [EOL]         } else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) { [EOL]             milliseconds = 500; [EOL]         } else { [EOL]             milliseconds = 999; [EOL]         } [EOL]         calendar.set(Calendar.MILLISECOND, milliseconds); [EOL]         calendar.set(years, months, days, hours, minutes, value); [EOL]         Date dd = calendar.getTime(); [EOL]         if (dd.getTime() >= date.getTime()) { [EOL]             calendar.set(Calendar.SECOND, value - 1); [EOL]             dd = calendar.getTime(); [EOL]         } [EOL]         return dd; [EOL]     } else if (t.equals(DateTickUnitType.MINUTE)) { [EOL]         years = calendar.get(Calendar.YEAR); [EOL]         months = calendar.get(Calendar.MONTH); [EOL]         days = calendar.get(Calendar.DATE); [EOL]         hours = calendar.get(Calendar.HOUR_OF_DAY); [EOL]         if (this.tickMarkPosition == DateTickMarkPosition.START) { [EOL]             seconds = 0; [EOL]         } else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) { [EOL]             seconds = 30; [EOL]         } else { [EOL]             seconds = 59; [EOL]         } [EOL]         calendar.clear(Calendar.MILLISECOND); [EOL]         calendar.set(years, months, days, hours, value, seconds); [EOL]         Date d0 = calendar.getTime(); [EOL]         if (d0.getTime() >= date.getTime()) { [EOL]             calendar.set(Calendar.MINUTE, value - 1); [EOL]             d0 = calendar.getTime(); [EOL]         } [EOL]         return d0; [EOL]     } else if (t.equals(DateTickUnitType.HOUR)) { [EOL]         years = calendar.get(Calendar.YEAR); [EOL]         months = calendar.get(Calendar.MONTH); [EOL]         days = calendar.get(Calendar.DATE); [EOL]         if (this.tickMarkPosition == DateTickMarkPosition.START) { [EOL]             minutes = 0; [EOL]             seconds = 0; [EOL]         } else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) { [EOL]             minutes = 30; [EOL]             seconds = 0; [EOL]         } else { [EOL]             minutes = 59; [EOL]             seconds = 59; [EOL]         } [EOL]         calendar.clear(Calendar.MILLISECOND); [EOL]         calendar.set(years, months, days, value, minutes, seconds); [EOL]         Date d1 = calendar.getTime(); [EOL]         if (d1.getTime() >= date.getTime()) { [EOL]             calendar.set(Calendar.HOUR_OF_DAY, value - 1); [EOL]             d1 = calendar.getTime(); [EOL]         } [EOL]         return d1; [EOL]     } else if (t.equals(DateTickUnitType.DAY)) { [EOL]         years = calendar.get(Calendar.YEAR); [EOL]         months = calendar.get(Calendar.MONTH); [EOL]         if (this.tickMarkPosition == DateTickMarkPosition.START) { [EOL]             hours = 0; [EOL]             minutes = 0; [EOL]             seconds = 0; [EOL]         } else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) { [EOL]             hours = 12; [EOL]             minutes = 0; [EOL]             seconds = 0; [EOL]         } else { [EOL]             hours = 23; [EOL]             minutes = 59; [EOL]             seconds = 59; [EOL]         } [EOL]         calendar.clear(Calendar.MILLISECOND); [EOL]         calendar.set(years, months, value, hours, 0, 0); [EOL]         Date d2 = calendar.getTime(); [EOL]         if (d2.getTime() >= date.getTime()) { [EOL]             calendar.set(Calendar.DATE, value - 1); [EOL]             d2 = calendar.getTime(); [EOL]         } [EOL]         return d2; [EOL]     } else if (t.equals(DateTickUnitType.MONTH)) { [EOL]         years = calendar.get(Calendar.YEAR); [EOL]         calendar.clear(Calendar.MILLISECOND); [EOL]         calendar.set(years, value, 1, 0, 0, 0); [EOL]         Month month = new Month(calendar.getTime(), this.timeZone, this.locale); [EOL]         Date standardDate = calculateDateForPosition(month, this.tickMarkPosition); [EOL]         long millis = standardDate.getTime(); [EOL]         if (millis >= date.getTime()) { [EOL]             month = (Month) month.previous(); [EOL]             month.peg(Calendar.getInstance(this.timeZone)); [EOL]             standardDate = calculateDateForPosition(month, this.tickMarkPosition); [EOL]         } [EOL]         return standardDate; [EOL]     } else if (t.equals(DateTickUnitType.YEAR)) { [EOL]         if (this.tickMarkPosition == DateTickMarkPosition.START) { [EOL]             months = 0; [EOL]             days = 1; [EOL]         } else if (this.tickMarkPosition == DateTickMarkPosition.MIDDLE) { [EOL]             months = 6; [EOL]             days = 1; [EOL]         } else { [EOL]             months = 11; [EOL]             days = 31; [EOL]         } [EOL]         calendar.clear(Calendar.MILLISECOND); [EOL]         calendar.set(value, months, days, 0, 0, 0); [EOL]         Date d3 = calendar.getTime(); [EOL]         if (d3.getTime() >= date.getTime()) { [EOL]             calendar.set(Calendar.YEAR, value - 1); [EOL]             d3 = calendar.getTime(); [EOL]         } [EOL]         return d3; [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] } <line_num>: 873,1052
private Date calculateDateForPosition(RegularTimePeriod period, DateTickMarkPosition position) { [EOL]     if (position == null) { [EOL]         throw new IllegalArgumentException("Null 'position' argument."); [EOL]     } [EOL]     Date result = null; [EOL]     if (position == DateTickMarkPosition.START) { [EOL]         result = new Date(period.getFirstMillisecond()); [EOL]     } else if (position == DateTickMarkPosition.MIDDLE) { [EOL]         result = new Date(period.getMiddleMillisecond()); [EOL]     } else if (position == DateTickMarkPosition.END) { [EOL]         result = new Date(period.getLastMillisecond()); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1063,1081
protected Date nextStandardDate(Date date, DateTickUnit unit) { [EOL]     Date previous = previousStandardDate(date, unit); [EOL]     Calendar calendar = Calendar.getInstance(this.timeZone, this.locale); [EOL]     calendar.setTime(previous); [EOL]     calendar.add(unit.getCalendarField(), unit.getMultiple()); [EOL]     return calendar.getTime(); [EOL] } <line_num>: 1092,1098
public static TickUnitSource createStandardDateTickUnits() { [EOL]     return createStandardDateTickUnits(TimeZone.getDefault(), Locale.getDefault()); [EOL] } <line_num>: 1109,1112
public static TickUnitSource createStandardDateTickUnits(TimeZone zone) { [EOL]     return createStandardDateTickUnits(zone, Locale.getDefault()); [EOL] } <line_num>: 1129,1131
public static TickUnitSource createStandardDateTickUnits(TimeZone zone, Locale locale) { [EOL]     if (zone == null) { [EOL]         throw new IllegalArgumentException("Null 'zone' argument."); [EOL]     } [EOL]     if (locale == null) { [EOL]         throw new IllegalArgumentException("Null 'locale' argument."); [EOL]     } [EOL]     TickUnits units = new TickUnits(); [EOL]     DateFormat f1 = new SimpleDateFormat("HH:mm:ss.SSS", locale); [EOL]     DateFormat f2 = new SimpleDateFormat("HH:mm:ss", locale); [EOL]     DateFormat f3 = new SimpleDateFormat("HH:mm", locale); [EOL]     DateFormat f4 = new SimpleDateFormat("d-MMM, HH:mm", locale); [EOL]     DateFormat f5 = new SimpleDateFormat("d-MMM", locale); [EOL]     DateFormat f6 = new SimpleDateFormat("MMM-yyyy", locale); [EOL]     DateFormat f7 = new SimpleDateFormat("yyyy", locale); [EOL]     f1.setTimeZone(zone); [EOL]     f2.setTimeZone(zone); [EOL]     f3.setTimeZone(zone); [EOL]     f4.setTimeZone(zone); [EOL]     f5.setTimeZone(zone); [EOL]     f6.setTimeZone(zone); [EOL]     f7.setTimeZone(zone); [EOL]     units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 1, f1)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 5, DateTickUnitType.MILLISECOND, 1, f1)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 10, DateTickUnitType.MILLISECOND, 1, f1)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 25, DateTickUnitType.MILLISECOND, 5, f1)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 50, DateTickUnitType.MILLISECOND, 10, f1)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 100, DateTickUnitType.MILLISECOND, 10, f1)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 250, DateTickUnitType.MILLISECOND, 10, f1)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 500, DateTickUnitType.MILLISECOND, 50, f1)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.SECOND, 1, DateTickUnitType.MILLISECOND, 50, f2)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.SECOND, 5, DateTickUnitType.SECOND, 1, f2)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.SECOND, 10, DateTickUnitType.SECOND, 1, f2)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.SECOND, 30, DateTickUnitType.SECOND, 5, f2)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.MINUTE, 1, DateTickUnitType.SECOND, 5, f3)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.MINUTE, 2, DateTickUnitType.SECOND, 10, f3)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.MINUTE, 5, DateTickUnitType.MINUTE, 1, f3)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.MINUTE, 10, DateTickUnitType.MINUTE, 1, f3)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.MINUTE, 15, DateTickUnitType.MINUTE, 5, f3)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.MINUTE, 20, DateTickUnitType.MINUTE, 5, f3)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.MINUTE, 30, DateTickUnitType.MINUTE, 5, f3)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.HOUR, 1, DateTickUnitType.MINUTE, 5, f3)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.HOUR, 2, DateTickUnitType.MINUTE, 10, f3)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.HOUR, 4, DateTickUnitType.MINUTE, 30, f3)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.HOUR, 6, DateTickUnitType.HOUR, 1, f3)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.HOUR, 12, DateTickUnitType.HOUR, 1, f4)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.DAY, 1, DateTickUnitType.HOUR, 1, f5)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.DAY, 2, DateTickUnitType.HOUR, 1, f5)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.DAY, 7, DateTickUnitType.DAY, 1, f5)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.DAY, 15, DateTickUnitType.DAY, 1, f5)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.MONTH, 1, DateTickUnitType.DAY, 1, f6)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.MONTH, 2, DateTickUnitType.DAY, 1, f6)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.MONTH, 3, DateTickUnitType.MONTH, 1, f6)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.MONTH, 4, DateTickUnitType.MONTH, 1, f6)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.MONTH, 6, DateTickUnitType.MONTH, 1, f6)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.YEAR, 1, DateTickUnitType.MONTH, 1, f7)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.YEAR, 2, DateTickUnitType.MONTH, 3, f7)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.YEAR, 5, DateTickUnitType.YEAR, 1, f7)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.YEAR, 10, DateTickUnitType.YEAR, 1, f7)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.YEAR, 25, DateTickUnitType.YEAR, 5, f7)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.YEAR, 50, DateTickUnitType.YEAR, 10, f7)); [EOL]     units.add(new DateTickUnit(DateTickUnitType.YEAR, 100, DateTickUnitType.YEAR, 20, f7)); [EOL]     return units; [EOL] } <line_num>: 1147,1270
protected void autoAdjustRange() { [EOL]     Plot plot = getPlot(); [EOL]     if (plot == null) { [EOL]         return; [EOL]     } [EOL]     if (plot instanceof ValueAxisPlot) { [EOL]         ValueAxisPlot vap = (ValueAxisPlot) plot; [EOL]         Range r = vap.getDataRange(this); [EOL]         if (r == null) { [EOL]             if (this.timeline instanceof SegmentedTimeline) { [EOL]                 r = new DateRange(((SegmentedTimeline) this.timeline).getStartTime(), ((SegmentedTimeline) this.timeline).getStartTime() + 1); [EOL]             } else { [EOL]                 r = new DateRange(); [EOL]             } [EOL]         } [EOL]         long upper = this.timeline.toTimelineValue((long) r.getUpperBound()); [EOL]         long lower; [EOL]         long fixedAutoRange = (long) getFixedAutoRange(); [EOL]         if (fixedAutoRange > 0.0) { [EOL]             lower = upper - fixedAutoRange; [EOL]         } else { [EOL]             lower = this.timeline.toTimelineValue((long) r.getLowerBound()); [EOL]             double range = upper - lower; [EOL]             long minRange = (long) getAutoRangeMinimumSize(); [EOL]             if (range < minRange) { [EOL]                 long expand = (long) (minRange - range) / 2; [EOL]                 upper = upper + expand; [EOL]                 lower = lower - expand; [EOL]             } [EOL]             upper = upper + (long) (range * getUpperMargin()); [EOL]             lower = lower - (long) (range * getLowerMargin()); [EOL]         } [EOL]         upper = this.timeline.toMillisecond(upper); [EOL]         lower = this.timeline.toMillisecond(lower); [EOL]         DateRange dr = new DateRange(new Date(lower), new Date(upper)); [EOL]         setRange(dr, false, false); [EOL]     } [EOL] } <line_num>: 1275,1326
protected void selectAutoTickUnit(Graphics2D g2, Rectangle2D dataArea, RectangleEdge edge) { [EOL]     if (RectangleEdge.isTopOrBottom(edge)) { [EOL]         selectHorizontalAutoTickUnit(g2, dataArea, edge); [EOL]     } else if (RectangleEdge.isLeftOrRight(edge)) { [EOL]         selectVerticalAutoTickUnit(g2, dataArea, edge); [EOL]     } [EOL] } <line_num>: 1337,1348
protected void selectHorizontalAutoTickUnit(Graphics2D g2, Rectangle2D dataArea, RectangleEdge edge) { [EOL]     long shift = 0; [EOL]     if (this.timeline instanceof SegmentedTimeline) { [EOL]         shift = ((SegmentedTimeline) this.timeline).getStartTime(); [EOL]     } [EOL]     double zero = valueToJava2D(shift + 0.0, dataArea, edge); [EOL]     double tickLabelWidth = estimateMaximumTickLabelWidth(g2, getTickUnit()); [EOL]     TickUnitSource tickUnits = getStandardTickUnits(); [EOL]     TickUnit unit1 = tickUnits.getCeilingTickUnit(getTickUnit()); [EOL]     double x1 = valueToJava2D(shift + unit1.getSize(), dataArea, edge); [EOL]     double unit1Width = Math.abs(x1 - zero); [EOL]     double guess = (tickLabelWidth / unit1Width) * unit1.getSize(); [EOL]     DateTickUnit unit2 = (DateTickUnit) tickUnits.getCeilingTickUnit(guess); [EOL]     double x2 = valueToJava2D(shift + unit2.getSize(), dataArea, edge); [EOL]     double unit2Width = Math.abs(x2 - zero); [EOL]     tickLabelWidth = estimateMaximumTickLabelWidth(g2, unit2); [EOL]     if (tickLabelWidth > unit2Width) { [EOL]         unit2 = (DateTickUnit) tickUnits.getLargerTickUnit(unit2); [EOL]     } [EOL]     setTickUnit(unit2, false, false); [EOL] } <line_num>: 1359,1386
protected void selectVerticalAutoTickUnit(Graphics2D g2, Rectangle2D dataArea, RectangleEdge edge) { [EOL]     TickUnitSource tickUnits = getStandardTickUnits(); [EOL]     double zero = valueToJava2D(0.0, dataArea, edge); [EOL]     double estimate1 = getRange().getLength() / 10.0; [EOL]     DateTickUnit candidate1 = (DateTickUnit) tickUnits.getCeilingTickUnit(estimate1); [EOL]     double labelHeight1 = estimateMaximumTickLabelHeight(g2, candidate1); [EOL]     double y1 = valueToJava2D(candidate1.getSize(), dataArea, edge); [EOL]     double candidate1UnitHeight = Math.abs(y1 - zero); [EOL]     double estimate2 = (labelHeight1 / candidate1UnitHeight) * candidate1.getSize(); [EOL]     DateTickUnit candidate2 = (DateTickUnit) tickUnits.getCeilingTickUnit(estimate2); [EOL]     double labelHeight2 = estimateMaximumTickLabelHeight(g2, candidate2); [EOL]     double y2 = valueToJava2D(candidate2.getSize(), dataArea, edge); [EOL]     double unit2Height = Math.abs(y2 - zero); [EOL]     DateTickUnit finalUnit; [EOL]     if (labelHeight2 < unit2Height) { [EOL]         finalUnit = candidate2; [EOL]     } else { [EOL]         finalUnit = (DateTickUnit) tickUnits.getLargerTickUnit(candidate2); [EOL]     } [EOL]     setTickUnit(finalUnit, false, false); [EOL] } <line_num>: 1397,1432
private double estimateMaximumTickLabelWidth(Graphics2D g2, DateTickUnit unit) { [EOL]     RectangleInsets tickLabelInsets = getTickLabelInsets(); [EOL]     double result = tickLabelInsets.getLeft() + tickLabelInsets.getRight(); [EOL]     Font tickLabelFont = getTickLabelFont(); [EOL]     FontRenderContext frc = g2.getFontRenderContext(); [EOL]     LineMetrics lm = tickLabelFont.getLineMetrics("ABCxyz", frc); [EOL]     if (isVerticalTickLabels()) { [EOL]         result += lm.getHeight(); [EOL]     } else { [EOL]         DateRange range = (DateRange) getRange(); [EOL]         Date lower = range.getLowerDate(); [EOL]         Date upper = range.getUpperDate(); [EOL]         String lowerStr = null; [EOL]         String upperStr = null; [EOL]         DateFormat formatter = getDateFormatOverride(); [EOL]         if (formatter != null) { [EOL]             lowerStr = formatter.format(lower); [EOL]             upperStr = formatter.format(upper); [EOL]         } else { [EOL]             lowerStr = unit.dateToString(lower); [EOL]             upperStr = unit.dateToString(upper); [EOL]         } [EOL]         FontMetrics fm = g2.getFontMetrics(tickLabelFont); [EOL]         double w1 = fm.stringWidth(lowerStr); [EOL]         double w2 = fm.stringWidth(upperStr); [EOL]         result += Math.max(w1, w2); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1447,1485
private double estimateMaximumTickLabelHeight(Graphics2D g2, DateTickUnit unit) { [EOL]     RectangleInsets tickLabelInsets = getTickLabelInsets(); [EOL]     double result = tickLabelInsets.getTop() + tickLabelInsets.getBottom(); [EOL]     Font tickLabelFont = getTickLabelFont(); [EOL]     FontRenderContext frc = g2.getFontRenderContext(); [EOL]     LineMetrics lm = tickLabelFont.getLineMetrics("ABCxyz", frc); [EOL]     if (!isVerticalTickLabels()) { [EOL]         result += lm.getHeight(); [EOL]     } else { [EOL]         DateRange range = (DateRange) getRange(); [EOL]         Date lower = range.getLowerDate(); [EOL]         Date upper = range.getUpperDate(); [EOL]         String lowerStr = null; [EOL]         String upperStr = null; [EOL]         DateFormat formatter = getDateFormatOverride(); [EOL]         if (formatter != null) { [EOL]             lowerStr = formatter.format(lower); [EOL]             upperStr = formatter.format(upper); [EOL]         } else { [EOL]             lowerStr = unit.dateToString(lower); [EOL]             upperStr = unit.dateToString(upper); [EOL]         } [EOL]         FontMetrics fm = g2.getFontMetrics(tickLabelFont); [EOL]         double w1 = fm.stringWidth(lowerStr); [EOL]         double w2 = fm.stringWidth(upperStr); [EOL]         result += Math.max(w1, w2); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1500,1538
public List refreshTicks(Graphics2D g2, AxisState state, Rectangle2D dataArea, RectangleEdge edge) { [EOL]     List result = null; [EOL]     if (RectangleEdge.isTopOrBottom(edge)) { [EOL]         result = refreshTicksHorizontal(g2, dataArea, edge); [EOL]     } else if (RectangleEdge.isLeftOrRight(edge)) { [EOL]         result = refreshTicksVertical(g2, dataArea, edge); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1551,1565
private Date correctTickDateForPosition(Date time, DateTickUnit unit, DateTickMarkPosition position) { [EOL]     Date result = time; [EOL]     DateTickUnitType t = unit.getUnitType(); [EOL]     if (t.equals(DateTickUnitType.MONTH)) { [EOL]         result = calculateDateForPosition(new Month(time, this.timeZone, this.locale), position); [EOL]     } else if (t.equals(DateTickUnitType.YEAR)) { [EOL]         result = calculateDateForPosition(new Year(time, this.timeZone, this.locale), position); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1576,1589
protected List refreshTicksHorizontal(Graphics2D g2, Rectangle2D dataArea, RectangleEdge edge) { [EOL]     List result = new java.util.ArrayList(); [EOL]     Font tickLabelFont = getTickLabelFont(); [EOL]     g2.setFont(tickLabelFont); [EOL]     if (isAutoTickUnitSelection()) { [EOL]         selectAutoTickUnit(g2, dataArea, edge); [EOL]     } [EOL]     DateTickUnit unit = getTickUnit(); [EOL]     Date tickDate = calculateLowestVisibleTickValue(unit); [EOL]     Date upperDate = getMaximumDate(); [EOL]     while (tickDate.before(upperDate)) { [EOL]         tickDate = correctTickDateForPosition(tickDate, unit, this.tickMarkPosition); [EOL]         long lowestTickTime = tickDate.getTime(); [EOL]         long distance = unit.addToDate(tickDate, this.timeZone).getTime() - lowestTickTime; [EOL]         int minorTickSpaces = getMinorTickCount(); [EOL]         if (minorTickSpaces <= 0) { [EOL]             minorTickSpaces = unit.getMinorTickCount(); [EOL]         } [EOL]         for (int minorTick = 1; minorTick < minorTickSpaces; minorTick++) { [EOL]             long minorTickTime = lowestTickTime - distance * minorTick / minorTickSpaces; [EOL]             if (minorTickTime > 0 && getRange().contains(minorTickTime) && (!isHiddenValue(minorTickTime))) { [EOL]                 result.add(new DateTick(TickType.MINOR, new Date(minorTickTime), "", TextAnchor.TOP_CENTER, TextAnchor.CENTER, 0.0)); [EOL]             } [EOL]         } [EOL]         if (!isHiddenValue(tickDate.getTime())) { [EOL]             String tickLabel; [EOL]             DateFormat formatter = getDateFormatOverride(); [EOL]             if (formatter != null) { [EOL]                 tickLabel = formatter.format(tickDate); [EOL]             } else { [EOL]                 tickLabel = this.tickUnit.dateToString(tickDate); [EOL]             } [EOL]             TextAnchor anchor = null; [EOL]             TextAnchor rotationAnchor = null; [EOL]             double angle = 0.0; [EOL]             if (isVerticalTickLabels()) { [EOL]                 anchor = TextAnchor.CENTER_RIGHT; [EOL]                 rotationAnchor = TextAnchor.CENTER_RIGHT; [EOL]                 if (edge == RectangleEdge.TOP) { [EOL]                     angle = Math.PI / 2.0; [EOL]                 } else { [EOL]                     angle = -Math.PI / 2.0; [EOL]                 } [EOL]             } else { [EOL]                 if (edge == RectangleEdge.TOP) { [EOL]                     anchor = TextAnchor.BOTTOM_CENTER; [EOL]                     rotationAnchor = TextAnchor.BOTTOM_CENTER; [EOL]                 } else { [EOL]                     anchor = TextAnchor.TOP_CENTER; [EOL]                     rotationAnchor = TextAnchor.TOP_CENTER; [EOL]                 } [EOL]             } [EOL]             Tick tick = new DateTick(tickDate, tickLabel, anchor, rotationAnchor, angle); [EOL]             result.add(tick); [EOL]             long currentTickTime = tickDate.getTime(); [EOL]             tickDate = unit.addToDate(tickDate, this.timeZone); [EOL]             long nextTickTime = tickDate.getTime(); [EOL]             for (int minorTick = 1; minorTick < minorTickSpaces; minorTick++) { [EOL]                 long minorTickTime = currentTickTime + (nextTickTime - currentTickTime) * minorTick / minorTickSpaces; [EOL]                 if (getRange().contains(minorTickTime) && (!isHiddenValue(minorTickTime))) { [EOL]                     result.add(new DateTick(TickType.MINOR, new Date(minorTickTime), "", TextAnchor.TOP_CENTER, TextAnchor.CENTER, 0.0)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             tickDate = unit.rollDate(tickDate, this.timeZone); [EOL]             continue; [EOL]         } [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1600,1703
protected List refreshTicksVertical(Graphics2D g2, Rectangle2D dataArea, RectangleEdge edge) { [EOL]     List result = new java.util.ArrayList(); [EOL]     Font tickLabelFont = getTickLabelFont(); [EOL]     g2.setFont(tickLabelFont); [EOL]     if (isAutoTickUnitSelection()) { [EOL]         selectAutoTickUnit(g2, dataArea, edge); [EOL]     } [EOL]     DateTickUnit unit = getTickUnit(); [EOL]     Date tickDate = calculateLowestVisibleTickValue(unit); [EOL]     Date upperDate = getMaximumDate(); [EOL]     while (tickDate.before(upperDate)) { [EOL]         tickDate = correctTickDateForPosition(tickDate, unit, this.tickMarkPosition); [EOL]         long lowestTickTime = tickDate.getTime(); [EOL]         long distance = unit.addToDate(tickDate, this.timeZone).getTime() - lowestTickTime; [EOL]         int minorTickSpaces = getMinorTickCount(); [EOL]         if (minorTickSpaces <= 0) { [EOL]             minorTickSpaces = unit.getMinorTickCount(); [EOL]         } [EOL]         for (int minorTick = 1; minorTick < minorTickSpaces; minorTick++) { [EOL]             long minorTickTime = lowestTickTime - distance * minorTick / minorTickSpaces; [EOL]             if (minorTickTime > 0 && getRange().contains(minorTickTime) && (!isHiddenValue(minorTickTime))) { [EOL]                 result.add(new DateTick(TickType.MINOR, new Date(minorTickTime), "", TextAnchor.TOP_CENTER, TextAnchor.CENTER, 0.0)); [EOL]             } [EOL]         } [EOL]         if (!isHiddenValue(tickDate.getTime())) { [EOL]             String tickLabel; [EOL]             DateFormat formatter = getDateFormatOverride(); [EOL]             if (formatter != null) { [EOL]                 tickLabel = formatter.format(tickDate); [EOL]             } else { [EOL]                 tickLabel = this.tickUnit.dateToString(tickDate); [EOL]             } [EOL]             TextAnchor anchor = null; [EOL]             TextAnchor rotationAnchor = null; [EOL]             double angle = 0.0; [EOL]             if (isVerticalTickLabels()) { [EOL]                 anchor = TextAnchor.BOTTOM_CENTER; [EOL]                 rotationAnchor = TextAnchor.BOTTOM_CENTER; [EOL]                 if (edge == RectangleEdge.LEFT) { [EOL]                     angle = -Math.PI / 2.0; [EOL]                 } else { [EOL]                     angle = Math.PI / 2.0; [EOL]                 } [EOL]             } else { [EOL]                 if (edge == RectangleEdge.LEFT) { [EOL]                     anchor = TextAnchor.CENTER_RIGHT; [EOL]                     rotationAnchor = TextAnchor.CENTER_RIGHT; [EOL]                 } else { [EOL]                     anchor = TextAnchor.CENTER_LEFT; [EOL]                     rotationAnchor = TextAnchor.CENTER_LEFT; [EOL]                 } [EOL]             } [EOL]             Tick tick = new DateTick(tickDate, tickLabel, anchor, rotationAnchor, angle); [EOL]             result.add(tick); [EOL]             long currentTickTime = tickDate.getTime(); [EOL]             tickDate = unit.addToDate(tickDate, this.timeZone); [EOL]             long nextTickTime = tickDate.getTime(); [EOL]             for (int minorTick = 1; minorTick < minorTickSpaces; minorTick++) { [EOL]                 long minorTickTime = currentTickTime + (nextTickTime - currentTickTime) * minorTick / minorTickSpaces; [EOL]                 if (getRange().contains(minorTickTime) && (!isHiddenValue(minorTickTime))) { [EOL]                     result.add(new DateTick(TickType.MINOR, new Date(minorTickTime), "", TextAnchor.TOP_CENTER, TextAnchor.CENTER, 0.0)); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             tickDate = unit.rollDate(tickDate, this.timeZone); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1714,1811
public AxisState draw(Graphics2D g2, double cursor, Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, PlotRenderingInfo plotState) { [EOL]     if (!isVisible()) { [EOL]         AxisState state = new AxisState(cursor); [EOL]         List ticks = refreshTicks(g2, state, dataArea, edge); [EOL]         state.setTicks(ticks); [EOL]         return state; [EOL]     } [EOL]     AxisState state = drawTickMarksAndLabels(g2, cursor, plotArea, dataArea, edge, plotState); [EOL]     state = drawLabel(getLabel(), g2, plotArea, dataArea, edge, state, plotState); [EOL]     createAndAddEntity(cursor, state, dataArea, edge, plotState); [EOL]     return state; [EOL] } <line_num>: 1829,1854
public void zoomRange(double lowerPercent, double upperPercent) { [EOL]     double start = this.timeline.toTimelineValue((long) getRange().getLowerBound()); [EOL]     double length = (this.timeline.toTimelineValue((long) getRange().getUpperBound()) - this.timeline.toTimelineValue((long) getRange().getLowerBound())); [EOL]     Range adjusted = null; [EOL]     if (isInverted()) { [EOL]         adjusted = new DateRange(this.timeline.toMillisecond((long) (start + (length * (1 - upperPercent)))), this.timeline.toMillisecond((long) (start + (length * (1 - lowerPercent))))); [EOL]     } else { [EOL]         adjusted = new DateRange(this.timeline.toMillisecond((long) (start + length * lowerPercent)), this.timeline.toMillisecond((long) (start + length * upperPercent))); [EOL]     } [EOL]     setRange(adjusted); [EOL] } <line_num>: 1862,1884
public boolean equals(Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(obj instanceof DateAxis)) { [EOL]         return false; [EOL]     } [EOL]     DateAxis that = (DateAxis) obj; [EOL]     if (!ObjectUtilities.equal(this.tickUnit, that.tickUnit)) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.dateFormatOverride, that.dateFormatOverride)) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.tickMarkPosition, that.tickMarkPosition)) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.timeline, that.timeline)) { [EOL]         return false; [EOL]     } [EOL]     return super.equals(obj); [EOL] } <line_num>: 1893,1916
public int hashCode() { [EOL]     if (getLabel() != null) { [EOL]         return getLabel().hashCode(); [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] } <line_num>: 1923,1930
public Object clone() throws CloneNotSupportedException { [EOL]     DateAxis clone = (DateAxis) super.clone(); [EOL]     if (this.dateFormatOverride != null) { [EOL]         clone.dateFormatOverride = (DateFormat) this.dateFormatOverride.clone(); [EOL]     } [EOL]     return clone; [EOL] } <line_num>: 1940,1949
