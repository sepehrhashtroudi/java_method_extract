public LogarithmicAxis(String label) { [EOL]     super(label); [EOL]     setupNumberFmtObj(); [EOL] } <line_num>: 154,157
public void setAllowNegativesFlag(boolean flgVal) { [EOL]     this.allowNegativesFlag = flgVal; [EOL] } <line_num>: 166,168
public boolean getAllowNegativesFlag() { [EOL]     return this.allowNegativesFlag; [EOL] } <line_num>: 177,179
public void setStrictValuesFlag(boolean flgVal) { [EOL]     this.strictValuesFlag = flgVal; [EOL] } <line_num>: 189,191
public boolean getStrictValuesFlag() { [EOL]     return this.strictValuesFlag; [EOL] } <line_num>: 201,203
public void setExpTickLabelsFlag(boolean flgVal) { [EOL]     this.expTickLabelsFlag = flgVal; [EOL]     setupNumberFmtObj(); [EOL] } <line_num>: 213,216
public boolean getExpTickLabelsFlag() { [EOL]     return this.expTickLabelsFlag; [EOL] } <line_num>: 224,226
public void setLog10TickLabelsFlag(boolean flag) { [EOL]     this.log10TickLabelsFlag = flag; [EOL] } <line_num>: 234,236
public boolean getLog10TickLabelsFlag() { [EOL]     return this.log10TickLabelsFlag; [EOL] } <line_num>: 245,247
public void setAutoRangeNextLogFlag(boolean flag) { [EOL]     this.autoRangeNextLogFlag = flag; [EOL] } <line_num>: 258,260
public boolean getAutoRangeNextLogFlag() { [EOL]     return this.autoRangeNextLogFlag; [EOL] } <line_num>: 268,270
public void setRange(Range range) { [EOL]     super.setRange(range); [EOL]     setupSmallLogFlag(); [EOL] } <line_num>: 278,281
protected void setupSmallLogFlag() { [EOL]     double lowerVal = getRange().getLowerBound(); [EOL]     this.smallLogFlag = (!this.allowNegativesFlag && lowerVal < 10.0 && lowerVal > 0.0); [EOL] } <line_num>: 287,293
protected void setupNumberFmtObj() { [EOL]     if (this.numberFormatterObj instanceof DecimalFormat) { [EOL]         ((DecimalFormat) this.numberFormatterObj).applyPattern(this.expTickLabelsFlag ? "0E0" : "0.###"); [EOL]     } [EOL] } <line_num>: 299,306
protected double switchedLog10(double val) { [EOL]     return this.smallLogFlag ? Math.log(val) / LOG10_VALUE : adjustedLog10(val); [EOL] } <line_num>: 321,324
public double switchedPow10(double val) { [EOL]     return this.smallLogFlag ? Math.pow(10.0, val) : adjustedPow10(val); [EOL] } <line_num>: 340,342
public double adjustedLog10(double val) { [EOL]     boolean negFlag = (val < 0.0); [EOL]     if (negFlag) { [EOL]         val = -val; [EOL]     } [EOL]     if (val < 10.0) { [EOL]         val += (10.0 - val) / 10.0; [EOL]     } [EOL]     double res = Math.log(val) / LOG10_VALUE; [EOL]     return negFlag ? (-res) : res; [EOL] } <line_num>: 358,369
public double adjustedPow10(double val) { [EOL]     boolean negFlag = (val < 0.0); [EOL]     if (negFlag) { [EOL]         val = -val; [EOL]     } [EOL]     double res; [EOL]     if (val < 1.0) { [EOL]         res = (Math.pow(10, val + 1.0) - 10.0) / 9.0; [EOL]     } else { [EOL]         res = Math.pow(10, val); [EOL]     } [EOL]     return negFlag ? (-res) : res; [EOL] } <line_num>: 385,398
protected double computeLogFloor(double lower) { [EOL]     double logFloor; [EOL]     if (this.allowNegativesFlag) { [EOL]         if (lower > 10.0) { [EOL]             logFloor = Math.log(lower) / LOG10_VALUE; [EOL]             logFloor = Math.floor(logFloor); [EOL]             logFloor = Math.pow(10, logFloor); [EOL]         } else if (lower < -10.0) { [EOL]             logFloor = Math.log(-lower) / LOG10_VALUE; [EOL]             logFloor = Math.floor(-logFloor); [EOL]             logFloor = -Math.pow(10, -logFloor); [EOL]         } else { [EOL]             logFloor = Math.floor(lower); [EOL]         } [EOL]     } else { [EOL]         if (lower > 0.0) { [EOL]             logFloor = Math.log(lower) / LOG10_VALUE; [EOL]             logFloor = Math.floor(logFloor); [EOL]             logFloor = Math.pow(10, logFloor); [EOL]         } else { [EOL]             logFloor = Math.floor(lower); [EOL]         } [EOL]     } [EOL]     return logFloor; [EOL] } <line_num>: 410,448
protected double computeLogCeil(double upper) { [EOL]     double logCeil; [EOL]     if (this.allowNegativesFlag) { [EOL]         if (upper > 10.0) { [EOL]             logCeil = Math.log(upper) / LOG10_VALUE; [EOL]             logCeil = Math.ceil(logCeil); [EOL]             logCeil = Math.pow(10, logCeil); [EOL]         } else if (upper < -10.0) { [EOL]             logCeil = Math.log(-upper) / LOG10_VALUE; [EOL]             logCeil = Math.ceil(-logCeil); [EOL]             logCeil = -Math.pow(10, -logCeil); [EOL]         } else { [EOL]             logCeil = Math.ceil(upper); [EOL]         } [EOL]     } else { [EOL]         if (upper > 0.0) { [EOL]             logCeil = Math.log(upper) / LOG10_VALUE; [EOL]             logCeil = Math.ceil(logCeil); [EOL]             logCeil = Math.pow(10, logCeil); [EOL]         } else { [EOL]             logCeil = Math.ceil(upper); [EOL]         } [EOL]     } [EOL]     return logCeil; [EOL] } <line_num>: 460,501
public void autoAdjustRange() { [EOL]     Plot plot = getPlot(); [EOL]     if (plot == null) { [EOL]         return; [EOL]     } [EOL]     if (plot instanceof ValueAxisPlot) { [EOL]         ValueAxisPlot vap = (ValueAxisPlot) plot; [EOL]         double lower; [EOL]         Range r = vap.getDataRange(this); [EOL]         if (r == null) { [EOL]             r = getDefaultAutoRange(); [EOL]             lower = r.getLowerBound(); [EOL]         } else { [EOL]             lower = r.getLowerBound(); [EOL]             if (this.strictValuesFlag && !this.allowNegativesFlag && lower <= 0.0) { [EOL]                 throw new RuntimeException("Values less than or equal to " + "zero not allowed with logarithmic axis"); [EOL]             } [EOL]         } [EOL]         final double lowerMargin; [EOL]         if (lower > 0.0 && (lowerMargin = getLowerMargin()) > 0.0) { [EOL]             final double logLower = (Math.log(lower) / LOG10_VALUE); [EOL]             double logAbs; [EOL]             if ((logAbs = Math.abs(logLower)) < 1.0) { [EOL]                 logAbs = 1.0; [EOL]             } [EOL]             lower = Math.pow(10, (logLower - (logAbs * lowerMargin))); [EOL]         } [EOL]         if (this.autoRangeNextLogFlag) { [EOL]             lower = computeLogFloor(lower); [EOL]         } [EOL]         if (!this.allowNegativesFlag && lower >= 0.0 && lower < SMALL_LOG_VALUE) { [EOL]             lower = r.getLowerBound(); [EOL]         } [EOL]         double upper = r.getUpperBound(); [EOL]         final double upperMargin; [EOL]         if (upper > 0.0 && (upperMargin = getUpperMargin()) > 0.0) { [EOL]             final double logUpper = (Math.log(upper) / LOG10_VALUE); [EOL]             double logAbs; [EOL]             if ((logAbs = Math.abs(logUpper)) < 1.0) { [EOL]                 logAbs = 1.0; [EOL]             } [EOL]             upper = Math.pow(10, (logUpper + (logAbs * upperMargin))); [EOL]         } [EOL]         if (!this.allowNegativesFlag && upper < 1.0 && upper > 0.0 && lower > 0.0) { [EOL]             double expVal = Math.log(upper) / LOG10_VALUE; [EOL]             expVal = Math.ceil(-expVal + 0.001); [EOL]             expVal = Math.pow(10, expVal); [EOL]             upper = (expVal > 0.0) ? Math.ceil(upper * expVal) / expVal : Math.ceil(upper); [EOL]         } else { [EOL]             upper = (this.autoRangeNextLogFlag) ? computeLogCeil(upper) : Math.ceil(upper); [EOL]         } [EOL]         double minRange = getAutoRangeMinimumSize(); [EOL]         if (upper - lower < minRange) { [EOL]             upper = (upper + lower + minRange) / 2; [EOL]             lower = (upper + lower - minRange) / 2; [EOL]             if (upper - lower < minRange) { [EOL]                 double absUpper = Math.abs(upper); [EOL]                 double adjVal = (absUpper > SMALL_LOG_VALUE) ? absUpper / 100.0 : 0.01; [EOL]                 upper = (upper + lower + adjVal) / 2; [EOL]                 lower = (upper + lower - adjVal) / 2; [EOL]             } [EOL]         } [EOL]         setRange(new Range(lower, upper), false, false); [EOL]         setupSmallLogFlag(); [EOL]     } [EOL] } <line_num>: 506,611
public double valueToJava2D(double value, Rectangle2D plotArea, RectangleEdge edge) { [EOL]     Range range = getRange(); [EOL]     double axisMin = switchedLog10(range.getLowerBound()); [EOL]     double axisMax = switchedLog10(range.getUpperBound()); [EOL]     double min = 0.0; [EOL]     double max = 0.0; [EOL]     if (RectangleEdge.isTopOrBottom(edge)) { [EOL]         min = plotArea.getMinX(); [EOL]         max = plotArea.getMaxX(); [EOL]     } else if (RectangleEdge.isLeftOrRight(edge)) { [EOL]         min = plotArea.getMaxY(); [EOL]         max = plotArea.getMinY(); [EOL]     } [EOL]     value = switchedLog10(value); [EOL]     if (isInverted()) { [EOL]         return max - (((value - axisMin) / (axisMax - axisMin)) * (max - min)); [EOL]     } else { [EOL]         return min + (((value - axisMin) / (axisMax - axisMin)) * (max - min)); [EOL]     } [EOL] } <line_num>: 625,654
public double java2DToValue(double java2DValue, Rectangle2D plotArea, RectangleEdge edge) { [EOL]     Range range = getRange(); [EOL]     double axisMin = switchedLog10(range.getLowerBound()); [EOL]     double axisMax = switchedLog10(range.getUpperBound()); [EOL]     double plotMin = 0.0; [EOL]     double plotMax = 0.0; [EOL]     if (RectangleEdge.isTopOrBottom(edge)) { [EOL]         plotMin = plotArea.getX(); [EOL]         plotMax = plotArea.getMaxX(); [EOL]     } else if (RectangleEdge.isLeftOrRight(edge)) { [EOL]         plotMin = plotArea.getMaxY(); [EOL]         plotMax = plotArea.getMinY(); [EOL]     } [EOL]     if (isInverted()) { [EOL]         return switchedPow10(axisMax - ((java2DValue - plotMin) / (plotMax - plotMin)) * (axisMax - axisMin)); [EOL]     } else { [EOL]         return switchedPow10(axisMin + ((java2DValue - plotMin) / (plotMax - plotMin)) * (axisMax - axisMin)); [EOL]     } [EOL] } <line_num>: 667,693
public void zoomRange(double lowerPercent, double upperPercent) { [EOL]     double startLog = switchedLog10(getRange().getLowerBound()); [EOL]     double lengthLog = switchedLog10(getRange().getUpperBound()) - startLog; [EOL]     Range adjusted; [EOL]     if (isInverted()) { [EOL]         adjusted = new Range(switchedPow10(startLog + (lengthLog * (1 - upperPercent))), switchedPow10(startLog + (lengthLog * (1 - lowerPercent)))); [EOL]     } else { [EOL]         adjusted = new Range(switchedPow10(startLog + (lengthLog * lowerPercent)), switchedPow10(startLog + (lengthLog * upperPercent))); [EOL]     } [EOL]     setRange(adjusted); [EOL] } <line_num>: 701,721
protected List refreshTicksHorizontal(Graphics2D g2, Rectangle2D dataArea, RectangleEdge edge) { [EOL]     List ticks = new java.util.ArrayList(); [EOL]     Range range = getRange(); [EOL]     double lowerBoundVal = range.getLowerBound(); [EOL]     if (this.smallLogFlag && lowerBoundVal < SMALL_LOG_VALUE) { [EOL]         lowerBoundVal = SMALL_LOG_VALUE; [EOL]     } [EOL]     double upperBoundVal = range.getUpperBound(); [EOL]     int iBegCount = (int) Math.rint(switchedLog10(lowerBoundVal)); [EOL]     int iEndCount = (int) Math.rint(switchedLog10(upperBoundVal)); [EOL]     if (iBegCount == iEndCount && iBegCount > 0 && Math.pow(10, iBegCount) > lowerBoundVal) { [EOL]         --iBegCount; [EOL]     } [EOL]     double currentTickValue; [EOL]     String tickLabel; [EOL]     boolean zeroTickFlag = false; [EOL]     for (int i = iBegCount; i <= iEndCount; i++) { [EOL]         for (int j = 0; j < 10; ++j) { [EOL]             if (this.smallLogFlag) { [EOL]                 currentTickValue = Math.pow(10, i) + (Math.pow(10, i) * j); [EOL]                 if (this.expTickLabelsFlag || (i < 0 && currentTickValue > 0.0 && currentTickValue < 1.0)) { [EOL]                     if (j == 0 || (i > -4 && j < 2) || currentTickValue >= upperBoundVal) { [EOL]                         this.numberFormatterObj.setMaximumFractionDigits(-i); [EOL]                         tickLabel = makeTickLabel(currentTickValue, true); [EOL]                     } else { [EOL]                         tickLabel = ""; [EOL]                     } [EOL]                 } else { [EOL]                     tickLabel = (j < 1 || (i < 1 && j < 5) || (j < 4 - i) || currentTickValue >= upperBoundVal) ? makeTickLabel(currentTickValue) : ""; [EOL]                 } [EOL]             } else { [EOL]                 if (zeroTickFlag) { [EOL]                     --j; [EOL]                 } [EOL]                 currentTickValue = (i >= 0) ? Math.pow(10, i) + (Math.pow(10, i) * j) : -(Math.pow(10, -i) - (Math.pow(10, -i - 1) * j)); [EOL]                 if (!zeroTickFlag) { [EOL]                     if (Math.abs(currentTickValue - 1.0) < 0.0001 && lowerBoundVal <= 0.0 && upperBoundVal >= 0.0) { [EOL]                         currentTickValue = 0.0; [EOL]                         zeroTickFlag = true; [EOL]                     } [EOL]                 } else { [EOL]                     zeroTickFlag = false; [EOL]                 } [EOL]                 tickLabel = ((this.expTickLabelsFlag && j < 2) || j < 1 || (i < 1 && j < 5) || (j < 4 - i) || currentTickValue >= upperBoundVal) ? makeTickLabel(currentTickValue) : ""; [EOL]             } [EOL]             if (currentTickValue > upperBoundVal) { [EOL]                 return ticks; [EOL]             } [EOL]             if (currentTickValue >= lowerBoundVal - SMALL_LOG_VALUE) { [EOL]                 TextAnchor anchor = null; [EOL]                 TextAnchor rotationAnchor = null; [EOL]                 double angle = 0.0; [EOL]                 if (isVerticalTickLabels()) { [EOL]                     anchor = TextAnchor.CENTER_RIGHT; [EOL]                     rotationAnchor = TextAnchor.CENTER_RIGHT; [EOL]                     if (edge == RectangleEdge.TOP) { [EOL]                         angle = Math.PI / 2.0; [EOL]                     } else { [EOL]                         angle = -Math.PI / 2.0; [EOL]                     } [EOL]                 } else { [EOL]                     if (edge == RectangleEdge.TOP) { [EOL]                         anchor = TextAnchor.BOTTOM_CENTER; [EOL]                         rotationAnchor = TextAnchor.BOTTOM_CENTER; [EOL]                     } else { [EOL]                         anchor = TextAnchor.TOP_CENTER; [EOL]                         rotationAnchor = TextAnchor.TOP_CENTER; [EOL]                     } [EOL]                 } [EOL]                 Tick tick = new NumberTick(new Double(currentTickValue), tickLabel, anchor, rotationAnchor, angle); [EOL]                 ticks.add(tick); [EOL]             } [EOL]         } [EOL]     } [EOL]     return ticks; [EOL] } <line_num>: 733,870
protected List refreshTicksVertical(Graphics2D g2, Rectangle2D dataArea, RectangleEdge edge) { [EOL]     List ticks = new java.util.ArrayList(); [EOL]     double lowerBoundVal = getRange().getLowerBound(); [EOL]     if (this.smallLogFlag && lowerBoundVal < SMALL_LOG_VALUE) { [EOL]         lowerBoundVal = SMALL_LOG_VALUE; [EOL]     } [EOL]     double upperBoundVal = getRange().getUpperBound(); [EOL]     int iBegCount = (int) Math.rint(switchedLog10(lowerBoundVal)); [EOL]     int iEndCount = (int) Math.rint(switchedLog10(upperBoundVal)); [EOL]     if (iBegCount == iEndCount && iBegCount > 0 && Math.pow(10, iBegCount) > lowerBoundVal) { [EOL]         --iBegCount; [EOL]     } [EOL]     double tickVal; [EOL]     String tickLabel; [EOL]     boolean zeroTickFlag = false; [EOL]     for (int i = iBegCount; i <= iEndCount; i++) { [EOL]         int jEndCount = 10; [EOL]         if (i == iEndCount) { [EOL]             jEndCount = 1; [EOL]         } [EOL]         for (int j = 0; j < jEndCount; j++) { [EOL]             if (this.smallLogFlag) { [EOL]                 tickVal = Math.pow(10, i) + (Math.pow(10, i) * j); [EOL]                 if (j == 0) { [EOL]                     if (this.log10TickLabelsFlag) { [EOL]                         tickLabel = "10^" + i; [EOL]                     } else { [EOL]                         if (this.expTickLabelsFlag) { [EOL]                             tickLabel = "1e" + i; [EOL]                         } else { [EOL]                             if (i >= 0) { [EOL]                                 NumberFormat format = getNumberFormatOverride(); [EOL]                                 if (format != null) { [EOL]                                     tickLabel = format.format(tickVal); [EOL]                                 } else { [EOL]                                     tickLabel = Long.toString((long) Math.rint(tickVal)); [EOL]                                 } [EOL]                             } else { [EOL]                                 this.numberFormatterObj.setMaximumFractionDigits(-i); [EOL]                                 tickLabel = this.numberFormatterObj.format(tickVal); [EOL]                             } [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     tickLabel = ""; [EOL]                 } [EOL]             } else { [EOL]                 if (zeroTickFlag) { [EOL]                     --j; [EOL]                 } [EOL]                 tickVal = (i >= 0) ? Math.pow(10, i) + (Math.pow(10, i) * j) : -(Math.pow(10, -i) - (Math.pow(10, -i - 1) * j)); [EOL]                 if (j == 0) { [EOL]                     if (!zeroTickFlag) { [EOL]                         if (i > iBegCount && i < iEndCount && Math.abs(tickVal - 1.0) < 0.0001) { [EOL]                             tickVal = 0.0; [EOL]                             zeroTickFlag = true; [EOL]                             tickLabel = "0"; [EOL]                         } else { [EOL]                             if (this.log10TickLabelsFlag) { [EOL]                                 tickLabel = (((i < 0) ? "-" : "") + "10^" + Math.abs(i)); [EOL]                             } else { [EOL]                                 if (this.expTickLabelsFlag) { [EOL]                                     tickLabel = (((i < 0) ? "-" : "") + "1e" + Math.abs(i)); [EOL]                                 } else { [EOL]                                     NumberFormat format = getNumberFormatOverride(); [EOL]                                     if (format != null) { [EOL]                                         tickLabel = format.format(tickVal); [EOL]                                     } else { [EOL]                                         tickLabel = Long.toString((long) Math.rint(tickVal)); [EOL]                                     } [EOL]                                 } [EOL]                             } [EOL]                         } [EOL]                     } else { [EOL]                         tickLabel = ""; [EOL]                         zeroTickFlag = false; [EOL]                     } [EOL]                 } else { [EOL]                     tickLabel = ""; [EOL]                     zeroTickFlag = false; [EOL]                 } [EOL]             } [EOL]             if (tickVal > upperBoundVal) { [EOL]                 return ticks; [EOL]             } [EOL]             if (tickVal >= lowerBoundVal - SMALL_LOG_VALUE) { [EOL]                 TextAnchor anchor = null; [EOL]                 TextAnchor rotationAnchor = null; [EOL]                 double angle = 0.0; [EOL]                 if (isVerticalTickLabels()) { [EOL]                     if (edge == RectangleEdge.LEFT) { [EOL]                         anchor = TextAnchor.BOTTOM_CENTER; [EOL]                         rotationAnchor = TextAnchor.BOTTOM_CENTER; [EOL]                         angle = -Math.PI / 2.0; [EOL]                     } else { [EOL]                         anchor = TextAnchor.BOTTOM_CENTER; [EOL]                         rotationAnchor = TextAnchor.BOTTOM_CENTER; [EOL]                         angle = Math.PI / 2.0; [EOL]                     } [EOL]                 } else { [EOL]                     if (edge == RectangleEdge.LEFT) { [EOL]                         anchor = TextAnchor.CENTER_RIGHT; [EOL]                         rotationAnchor = TextAnchor.CENTER_RIGHT; [EOL]                     } else { [EOL]                         anchor = TextAnchor.CENTER_LEFT; [EOL]                         rotationAnchor = TextAnchor.CENTER_LEFT; [EOL]                     } [EOL]                 } [EOL]                 ticks.add(new NumberTick(new Double(tickVal), tickLabel, anchor, rotationAnchor, angle)); [EOL]             } [EOL]         } [EOL]     } [EOL]     return ticks; [EOL] } <line_num>: 882,1060
protected String makeTickLabel(double val, boolean forceFmtFlag) { [EOL]     if (this.expTickLabelsFlag || forceFmtFlag) { [EOL]         return this.numberFormatterObj.format(val).toLowerCase(); [EOL]     } [EOL]     return getTickUnit().valueToString(val); [EOL] } <line_num>: 1071,1078
protected String makeTickLabel(double val) { [EOL]     return makeTickLabel(val, false); [EOL] } <line_num>: 1086,1088
