public CyclicNumberAxis(double period) { [EOL]     this(period, 0.0); [EOL] } <line_num>: 164,166
public CyclicNumberAxis(double period, double offset) { [EOL]     this(period, offset, null); [EOL] } <line_num>: 174,176
public CyclicNumberAxis(double period, String label) { [EOL]     this(0, period, label); [EOL] } <line_num>: 184,186
public CyclicNumberAxis(double period, double offset, String label) { [EOL]     super(label); [EOL]     this.period = period; [EOL]     this.offset = offset; [EOL]     setFixedAutoRange(period); [EOL]     this.advanceLineVisible = true; [EOL]     this.advanceLinePaint = DEFAULT_ADVANCE_LINE_PAINT; [EOL] } <line_num>: 195,202
public CycleBoundTick(boolean mapToLastCycle, Number number, String label, TextAnchor textAnchor, TextAnchor rotationAnchor, double angle) { [EOL]     super(number, label, textAnchor, rotationAnchor, angle); [EOL]     this.mapToLastCycle = mapToLastCycle; [EOL] } <line_num>: 379,384
public boolean isAdvanceLineVisible() { [EOL]     return this.advanceLineVisible; [EOL] } <line_num>: 210,212
public void setAdvanceLineVisible(boolean visible) { [EOL]     this.advanceLineVisible = visible; [EOL] } <line_num>: 220,222
public Paint getAdvanceLinePaint() { [EOL]     return this.advanceLinePaint; [EOL] } <line_num>: 230,232
public void setAdvanceLinePaint(Paint paint) { [EOL]     if (paint == null) { [EOL]         throw new IllegalArgumentException("Null 'paint' argument."); [EOL]     } [EOL]     this.advanceLinePaint = paint; [EOL] } <line_num>: 240,245
public Stroke getAdvanceLineStroke() { [EOL]     return this.advanceLineStroke; [EOL] } <line_num>: 253,255
public void setAdvanceLineStroke(Stroke stroke) { [EOL]     if (stroke == null) { [EOL]         throw new IllegalArgumentException("Null 'stroke' argument."); [EOL]     } [EOL]     this.advanceLineStroke = stroke; [EOL] } <line_num>: 262,267
public boolean isBoundMappedToLastCycle() { [EOL]     return this.boundMappedToLastCycle; [EOL] } <line_num>: 283,285
public void setBoundMappedToLastCycle(boolean boundMappedToLastCycle) { [EOL]     this.boundMappedToLastCycle = boundMappedToLastCycle; [EOL] } <line_num>: 300,302
protected void selectHorizontalAutoTickUnit(Graphics2D g2, Rectangle2D drawArea, Rectangle2D dataArea, RectangleEdge edge) { [EOL]     double tickLabelWidth = estimateMaximumTickLabelWidth(g2, getTickUnit()); [EOL]     double n = getRange().getLength() * tickLabelWidth / dataArea.getWidth(); [EOL]     setTickUnit((NumberTickUnit) getStandardTickUnits().getCeilingTickUnit(n), false, false); [EOL] } <line_num>: 312,329
protected void selectVerticalAutoTickUnit(Graphics2D g2, Rectangle2D drawArea, Rectangle2D dataArea, RectangleEdge edge) { [EOL]     double tickLabelWidth = estimateMaximumTickLabelWidth(g2, getTickUnit()); [EOL]     double n = getRange().getLength() * tickLabelWidth / dataArea.getHeight(); [EOL]     setTickUnit((NumberTickUnit) getStandardTickUnits().getCeilingTickUnit(n), false, false); [EOL] } <line_num>: 339,356
protected float[] calculateAnchorPoint(ValueTick tick, double cursor, Rectangle2D dataArea, RectangleEdge edge) { [EOL]     if (tick instanceof CycleBoundTick) { [EOL]         boolean mapsav = this.boundMappedToLastCycle; [EOL]         this.boundMappedToLastCycle = ((CycleBoundTick) tick).mapToLastCycle; [EOL]         float[] ret = super.calculateAnchorPoint(tick, cursor, dataArea, edge); [EOL]         this.boundMappedToLastCycle = mapsav; [EOL]         return ret; [EOL]     } [EOL]     return super.calculateAnchorPoint(tick, cursor, dataArea, edge); [EOL] } <line_num>: 397,411
protected List refreshTicksHorizontal(Graphics2D g2, Rectangle2D dataArea, RectangleEdge edge) { [EOL]     List result = new java.util.ArrayList(); [EOL]     Font tickLabelFont = getTickLabelFont(); [EOL]     g2.setFont(tickLabelFont); [EOL]     if (isAutoTickUnitSelection()) { [EOL]         selectAutoTickUnit(g2, dataArea, edge); [EOL]     } [EOL]     double unit = getTickUnit().getSize(); [EOL]     double cycleBound = getCycleBound(); [EOL]     double currentTickValue = Math.ceil(cycleBound / unit) * unit; [EOL]     double upperValue = getRange().getUpperBound(); [EOL]     boolean cycled = false; [EOL]     boolean boundMapping = this.boundMappedToLastCycle; [EOL]     this.boundMappedToLastCycle = false; [EOL]     CycleBoundTick lastTick = null; [EOL]     float lastX = 0.0f; [EOL]     if (upperValue == cycleBound) { [EOL]         currentTickValue = calculateLowestVisibleTickValue(); [EOL]         cycled = true; [EOL]         this.boundMappedToLastCycle = true; [EOL]     } [EOL]     while (currentTickValue <= upperValue) { [EOL]         boolean cyclenow = false; [EOL]         if ((currentTickValue + unit > upperValue) && !cycled) { [EOL]             cyclenow = true; [EOL]         } [EOL]         double xx = valueToJava2D(currentTickValue, dataArea, edge); [EOL]         String tickLabel; [EOL]         NumberFormat formatter = getNumberFormatOverride(); [EOL]         if (formatter != null) { [EOL]             tickLabel = formatter.format(currentTickValue); [EOL]         } else { [EOL]             tickLabel = getTickUnit().valueToString(currentTickValue); [EOL]         } [EOL]         float x = (float) xx; [EOL]         TextAnchor anchor = null; [EOL]         TextAnchor rotationAnchor = null; [EOL]         double angle = 0.0; [EOL]         if (isVerticalTickLabels()) { [EOL]             if (edge == RectangleEdge.TOP) { [EOL]                 angle = Math.PI / 2.0; [EOL]             } else { [EOL]                 angle = -Math.PI / 2.0; [EOL]             } [EOL]             anchor = TextAnchor.CENTER_RIGHT; [EOL]             if ((lastTick != null) && (lastX == x) && (currentTickValue != cycleBound)) { [EOL]                 anchor = isInverted() ? TextAnchor.TOP_RIGHT : TextAnchor.BOTTOM_RIGHT; [EOL]                 result.remove(result.size() - 1); [EOL]                 result.add(new CycleBoundTick(this.boundMappedToLastCycle, lastTick.getNumber(), lastTick.getText(), anchor, anchor, lastTick.getAngle())); [EOL]                 this.internalMarkerWhenTicksOverlap = true; [EOL]                 anchor = isInverted() ? TextAnchor.BOTTOM_RIGHT : TextAnchor.TOP_RIGHT; [EOL]             } [EOL]             rotationAnchor = anchor; [EOL]         } else { [EOL]             if (edge == RectangleEdge.TOP) { [EOL]                 anchor = TextAnchor.BOTTOM_CENTER; [EOL]                 if ((lastTick != null) && (lastX == x) && (currentTickValue != cycleBound)) { [EOL]                     anchor = isInverted() ? TextAnchor.BOTTOM_LEFT : TextAnchor.BOTTOM_RIGHT; [EOL]                     result.remove(result.size() - 1); [EOL]                     result.add(new CycleBoundTick(this.boundMappedToLastCycle, lastTick.getNumber(), lastTick.getText(), anchor, anchor, lastTick.getAngle())); [EOL]                     this.internalMarkerWhenTicksOverlap = true; [EOL]                     anchor = isInverted() ? TextAnchor.BOTTOM_RIGHT : TextAnchor.BOTTOM_LEFT; [EOL]                 } [EOL]                 rotationAnchor = anchor; [EOL]             } else { [EOL]                 anchor = TextAnchor.TOP_CENTER; [EOL]                 if ((lastTick != null) && (lastX == x) && (currentTickValue != cycleBound)) { [EOL]                     anchor = isInverted() ? TextAnchor.TOP_LEFT : TextAnchor.TOP_RIGHT; [EOL]                     result.remove(result.size() - 1); [EOL]                     result.add(new CycleBoundTick(this.boundMappedToLastCycle, lastTick.getNumber(), lastTick.getText(), anchor, anchor, lastTick.getAngle())); [EOL]                     this.internalMarkerWhenTicksOverlap = true; [EOL]                     anchor = isInverted() ? TextAnchor.TOP_RIGHT : TextAnchor.TOP_LEFT; [EOL]                 } [EOL]                 rotationAnchor = anchor; [EOL]             } [EOL]         } [EOL]         CycleBoundTick tick = new CycleBoundTick(this.boundMappedToLastCycle, new Double(currentTickValue), tickLabel, anchor, rotationAnchor, angle); [EOL]         if (currentTickValue == cycleBound) { [EOL]             this.internalMarkerCycleBoundTick = tick; [EOL]         } [EOL]         result.add(tick); [EOL]         lastTick = tick; [EOL]         lastX = x; [EOL]         currentTickValue += unit; [EOL]         if (cyclenow) { [EOL]             currentTickValue = calculateLowestVisibleTickValue(); [EOL]             upperValue = cycleBound; [EOL]             cycled = true; [EOL]             this.boundMappedToLastCycle = true; [EOL]         } [EOL]     } [EOL]     this.boundMappedToLastCycle = boundMapping; [EOL]     return result; [EOL] } <line_num>: 425,566
protected List refreshVerticalTicks(Graphics2D g2, Rectangle2D dataArea, RectangleEdge edge) { [EOL]     List result = new java.util.ArrayList(); [EOL]     result.clear(); [EOL]     Font tickLabelFont = getTickLabelFont(); [EOL]     g2.setFont(tickLabelFont); [EOL]     if (isAutoTickUnitSelection()) { [EOL]         selectAutoTickUnit(g2, dataArea, edge); [EOL]     } [EOL]     double unit = getTickUnit().getSize(); [EOL]     double cycleBound = getCycleBound(); [EOL]     double currentTickValue = Math.ceil(cycleBound / unit) * unit; [EOL]     double upperValue = getRange().getUpperBound(); [EOL]     boolean cycled = false; [EOL]     boolean boundMapping = this.boundMappedToLastCycle; [EOL]     this.boundMappedToLastCycle = true; [EOL]     NumberTick lastTick = null; [EOL]     float lastY = 0.0f; [EOL]     if (upperValue == cycleBound) { [EOL]         currentTickValue = calculateLowestVisibleTickValue(); [EOL]         cycled = true; [EOL]         this.boundMappedToLastCycle = true; [EOL]     } [EOL]     while (currentTickValue <= upperValue) { [EOL]         boolean cyclenow = false; [EOL]         if ((currentTickValue + unit > upperValue) && !cycled) { [EOL]             cyclenow = true; [EOL]         } [EOL]         double yy = valueToJava2D(currentTickValue, dataArea, edge); [EOL]         String tickLabel; [EOL]         NumberFormat formatter = getNumberFormatOverride(); [EOL]         if (formatter != null) { [EOL]             tickLabel = formatter.format(currentTickValue); [EOL]         } else { [EOL]             tickLabel = getTickUnit().valueToString(currentTickValue); [EOL]         } [EOL]         float y = (float) yy; [EOL]         TextAnchor anchor = null; [EOL]         TextAnchor rotationAnchor = null; [EOL]         double angle = 0.0; [EOL]         if (isVerticalTickLabels()) { [EOL]             if (edge == RectangleEdge.LEFT) { [EOL]                 anchor = TextAnchor.BOTTOM_CENTER; [EOL]                 if ((lastTick != null) && (lastY == y) && (currentTickValue != cycleBound)) { [EOL]                     anchor = isInverted() ? TextAnchor.BOTTOM_LEFT : TextAnchor.BOTTOM_RIGHT; [EOL]                     result.remove(result.size() - 1); [EOL]                     result.add(new CycleBoundTick(this.boundMappedToLastCycle, lastTick.getNumber(), lastTick.getText(), anchor, anchor, lastTick.getAngle())); [EOL]                     this.internalMarkerWhenTicksOverlap = true; [EOL]                     anchor = isInverted() ? TextAnchor.BOTTOM_RIGHT : TextAnchor.BOTTOM_LEFT; [EOL]                 } [EOL]                 rotationAnchor = anchor; [EOL]                 angle = -Math.PI / 2.0; [EOL]             } else { [EOL]                 anchor = TextAnchor.BOTTOM_CENTER; [EOL]                 if ((lastTick != null) && (lastY == y) && (currentTickValue != cycleBound)) { [EOL]                     anchor = isInverted() ? TextAnchor.BOTTOM_RIGHT : TextAnchor.BOTTOM_LEFT; [EOL]                     result.remove(result.size() - 1); [EOL]                     result.add(new CycleBoundTick(this.boundMappedToLastCycle, lastTick.getNumber(), lastTick.getText(), anchor, anchor, lastTick.getAngle())); [EOL]                     this.internalMarkerWhenTicksOverlap = true; [EOL]                     anchor = isInverted() ? TextAnchor.BOTTOM_LEFT : TextAnchor.BOTTOM_RIGHT; [EOL]                 } [EOL]                 rotationAnchor = anchor; [EOL]                 angle = Math.PI / 2.0; [EOL]             } [EOL]         } else { [EOL]             if (edge == RectangleEdge.LEFT) { [EOL]                 anchor = TextAnchor.CENTER_RIGHT; [EOL]                 if ((lastTick != null) && (lastY == y) && (currentTickValue != cycleBound)) { [EOL]                     anchor = isInverted() ? TextAnchor.BOTTOM_RIGHT : TextAnchor.TOP_RIGHT; [EOL]                     result.remove(result.size() - 1); [EOL]                     result.add(new CycleBoundTick(this.boundMappedToLastCycle, lastTick.getNumber(), lastTick.getText(), anchor, anchor, lastTick.getAngle())); [EOL]                     this.internalMarkerWhenTicksOverlap = true; [EOL]                     anchor = isInverted() ? TextAnchor.TOP_RIGHT : TextAnchor.BOTTOM_RIGHT; [EOL]                 } [EOL]                 rotationAnchor = anchor; [EOL]             } else { [EOL]                 anchor = TextAnchor.CENTER_LEFT; [EOL]                 if ((lastTick != null) && (lastY == y) && (currentTickValue != cycleBound)) { [EOL]                     anchor = isInverted() ? TextAnchor.BOTTOM_LEFT : TextAnchor.TOP_LEFT; [EOL]                     result.remove(result.size() - 1); [EOL]                     result.add(new CycleBoundTick(this.boundMappedToLastCycle, lastTick.getNumber(), lastTick.getText(), anchor, anchor, lastTick.getAngle())); [EOL]                     this.internalMarkerWhenTicksOverlap = true; [EOL]                     anchor = isInverted() ? TextAnchor.TOP_LEFT : TextAnchor.BOTTOM_LEFT; [EOL]                 } [EOL]                 rotationAnchor = anchor; [EOL]             } [EOL]         } [EOL]         CycleBoundTick tick = new CycleBoundTick(this.boundMappedToLastCycle, new Double(currentTickValue), tickLabel, anchor, rotationAnchor, angle); [EOL]         if (currentTickValue == cycleBound) { [EOL]             this.internalMarkerCycleBoundTick = tick; [EOL]         } [EOL]         result.add(tick); [EOL]         lastTick = tick; [EOL]         lastY = y; [EOL]         if (currentTickValue == cycleBound) { [EOL]             this.internalMarkerCycleBoundTick = tick; [EOL]         } [EOL]         currentTickValue += unit; [EOL]         if (cyclenow) { [EOL]             currentTickValue = calculateLowestVisibleTickValue(); [EOL]             upperValue = cycleBound; [EOL]             cycled = true; [EOL]             this.boundMappedToLastCycle = false; [EOL]         } [EOL]     } [EOL]     this.boundMappedToLastCycle = boundMapping; [EOL]     return result; [EOL] } <line_num>: 578,738
public double java2DToValue(double java2DValue, Rectangle2D dataArea, RectangleEdge edge) { [EOL]     Range range = getRange(); [EOL]     double vmax = range.getUpperBound(); [EOL]     double vp = getCycleBound(); [EOL]     double jmin = 0.0; [EOL]     double jmax = 0.0; [EOL]     if (RectangleEdge.isTopOrBottom(edge)) { [EOL]         jmin = dataArea.getMinX(); [EOL]         jmax = dataArea.getMaxX(); [EOL]     } else if (RectangleEdge.isLeftOrRight(edge)) { [EOL]         jmin = dataArea.getMaxY(); [EOL]         jmax = dataArea.getMinY(); [EOL]     } [EOL]     if (isInverted()) { [EOL]         double jbreak = jmax - (vmax - vp) * (jmax - jmin) / this.period; [EOL]         if (java2DValue >= jbreak) { [EOL]             return vp + (jmax - java2DValue) * this.period / (jmax - jmin); [EOL]         } else { [EOL]             return vp - (java2DValue - jmin) * this.period / (jmax - jmin); [EOL]         } [EOL]     } else { [EOL]         double jbreak = (vmax - vp) * (jmax - jmin) / this.period + jmin; [EOL]         if (java2DValue <= jbreak) { [EOL]             return vp + (java2DValue - jmin) * this.period / (jmax - jmin); [EOL]         } else { [EOL]             return vp - (jmax - java2DValue) * this.period / (jmax - jmin); [EOL]         } [EOL]     } [EOL] } <line_num>: 749,785
public double valueToJava2D(double value, Rectangle2D dataArea, RectangleEdge edge) { [EOL]     Range range = getRange(); [EOL]     double vmin = range.getLowerBound(); [EOL]     double vmax = range.getUpperBound(); [EOL]     double vp = getCycleBound(); [EOL]     if ((value < vmin) || (value > vmax)) { [EOL]         return Double.NaN; [EOL]     } [EOL]     double jmin = 0.0; [EOL]     double jmax = 0.0; [EOL]     if (RectangleEdge.isTopOrBottom(edge)) { [EOL]         jmin = dataArea.getMinX(); [EOL]         jmax = dataArea.getMaxX(); [EOL]     } else if (RectangleEdge.isLeftOrRight(edge)) { [EOL]         jmax = dataArea.getMinY(); [EOL]         jmin = dataArea.getMaxY(); [EOL]     } [EOL]     if (isInverted()) { [EOL]         if (value == vp) { [EOL]             return this.boundMappedToLastCycle ? jmin : jmax; [EOL]         } else if (value > vp) { [EOL]             return jmax - (value - vp) * (jmax - jmin) / this.period; [EOL]         } else { [EOL]             return jmin + (vp - value) * (jmax - jmin) / this.period; [EOL]         } [EOL]     } else { [EOL]         if (value == vp) { [EOL]             return this.boundMappedToLastCycle ? jmax : jmin; [EOL]         } else if (value >= vp) { [EOL]             return jmin + (value - vp) * (jmax - jmin) / this.period; [EOL]         } else { [EOL]             return jmax - (vp - value) * (jmax - jmin) / this.period; [EOL]         } [EOL]     } [EOL] } <line_num>: 796,842
public void centerRange(double value) { [EOL]     setRange(value - this.period / 2.0, value + this.period / 2.0); [EOL] } <line_num>: 849,851
public void setAutoRangeMinimumSize(double size, boolean notify) { [EOL]     if (size > this.period) { [EOL]         this.period = size; [EOL]     } [EOL]     super.setAutoRangeMinimumSize(size, notify); [EOL] } <line_num>: 864,869
public void setFixedAutoRange(double length) { [EOL]     this.period = length; [EOL]     super.setFixedAutoRange(length); [EOL] } <line_num>: 879,882
public void setRange(Range range, boolean turnOffAutoRange, boolean notify) { [EOL]     double size = range.getUpperBound() - range.getLowerBound(); [EOL]     if (size > this.period) { [EOL]         this.period = size; [EOL]     } [EOL]     super.setRange(range, turnOffAutoRange, notify); [EOL] } <line_num>: 894,901
public double getCycleBound() { [EOL]     return Math.floor((getRange().getUpperBound() - this.offset) / this.period) * this.period + this.offset; [EOL] } <line_num>: 913,917
public double getOffset() { [EOL]     return this.offset; [EOL] } <line_num>: 929,931
public void setOffset(double offset) { [EOL]     this.offset = offset; [EOL] } <line_num>: 943,945
public double getPeriod() { [EOL]     return this.period; [EOL] } <line_num>: 957,959
public void setPeriod(double period) { [EOL]     this.period = period; [EOL] } <line_num>: 971,973
protected AxisState drawTickMarksAndLabels(Graphics2D g2, double cursor, Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, PlotRenderingInfo info) { [EOL]     this.internalMarkerWhenTicksOverlap = false; [EOL]     AxisState ret = super.drawTickMarksAndLabels(g2, cursor, plotArea, dataArea, edge, info); [EOL]     if (!this.internalMarkerWhenTicksOverlap) { [EOL]         return ret; [EOL]     } [EOL]     double ol = getTickMarkOutsideLength(); [EOL]     FontMetrics fm = g2.getFontMetrics(getTickLabelFont()); [EOL]     if (isVerticalTickLabels()) { [EOL]         ol = fm.getMaxAdvance(); [EOL]     } else { [EOL]         ol = fm.getHeight(); [EOL]     } [EOL]     double il = 0; [EOL]     if (isTickMarksVisible()) { [EOL]         float xx = (float) valueToJava2D(getRange().getUpperBound(), dataArea, edge); [EOL]         Line2D mark = null; [EOL]         g2.setStroke(getTickMarkStroke()); [EOL]         g2.setPaint(getTickMarkPaint()); [EOL]         if (edge == RectangleEdge.LEFT) { [EOL]             mark = new Line2D.Double(cursor - ol, xx, cursor + il, xx); [EOL]         } else if (edge == RectangleEdge.RIGHT) { [EOL]             mark = new Line2D.Double(cursor + ol, xx, cursor - il, xx); [EOL]         } else if (edge == RectangleEdge.TOP) { [EOL]             mark = new Line2D.Double(xx, cursor - ol, xx, cursor + il); [EOL]         } else if (edge == RectangleEdge.BOTTOM) { [EOL]             mark = new Line2D.Double(xx, cursor + ol, xx, cursor - il); [EOL]         } [EOL]         g2.draw(mark); [EOL]     } [EOL]     return ret; [EOL] } <line_num>: 987,1032
public AxisState draw(Graphics2D g2, double cursor, Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, PlotRenderingInfo plotState) { [EOL]     AxisState ret = super.draw(g2, cursor, plotArea, dataArea, edge, plotState); [EOL]     if (isAdvanceLineVisible()) { [EOL]         double xx = valueToJava2D(getRange().getUpperBound(), dataArea, edge); [EOL]         Line2D mark = null; [EOL]         g2.setStroke(getAdvanceLineStroke()); [EOL]         g2.setPaint(getAdvanceLinePaint()); [EOL]         if (edge == RectangleEdge.LEFT) { [EOL]             mark = new Line2D.Double(cursor, xx, cursor + dataArea.getWidth(), xx); [EOL]         } else if (edge == RectangleEdge.RIGHT) { [EOL]             mark = new Line2D.Double(cursor - dataArea.getWidth(), xx, cursor, xx); [EOL]         } else if (edge == RectangleEdge.TOP) { [EOL]             mark = new Line2D.Double(xx, cursor + dataArea.getHeight(), xx, cursor); [EOL]         } else if (edge == RectangleEdge.BOTTOM) { [EOL]             mark = new Line2D.Double(xx, cursor, xx, cursor - dataArea.getHeight()); [EOL]         } [EOL]         g2.draw(mark); [EOL]     } [EOL]     return ret; [EOL] } <line_num>: 1047,1087
public AxisSpace reserveSpace(Graphics2D g2, Plot plot, Rectangle2D plotArea, RectangleEdge edge, AxisSpace space) { [EOL]     this.internalMarkerCycleBoundTick = null; [EOL]     AxisSpace ret = super.reserveSpace(g2, plot, plotArea, edge, space); [EOL]     if (this.internalMarkerCycleBoundTick == null) { [EOL]         return ret; [EOL]     } [EOL]     FontMetrics fm = g2.getFontMetrics(getTickLabelFont()); [EOL]     Rectangle2D r = TextUtilities.getTextBounds(this.internalMarkerCycleBoundTick.getText(), g2, fm); [EOL]     if (RectangleEdge.isTopOrBottom(edge)) { [EOL]         if (isVerticalTickLabels()) { [EOL]             space.add(r.getHeight() / 2, RectangleEdge.RIGHT); [EOL]         } else { [EOL]             space.add(r.getWidth() / 2, RectangleEdge.RIGHT); [EOL]         } [EOL]     } else if (RectangleEdge.isLeftOrRight(edge)) { [EOL]         if (isVerticalTickLabels()) { [EOL]             space.add(r.getWidth() / 2, RectangleEdge.TOP); [EOL]         } else { [EOL]             space.add(r.getHeight() / 2, RectangleEdge.TOP); [EOL]         } [EOL]     } [EOL]     return ret; [EOL] } <line_num>: 1101,1137
private void writeObject(ObjectOutputStream stream) throws IOException { [EOL]     stream.defaultWriteObject(); [EOL]     SerialUtilities.writePaint(this.advanceLinePaint, stream); [EOL]     SerialUtilities.writeStroke(this.advanceLineStroke, stream); [EOL] } <line_num>: 1146,1152
private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException { [EOL]     stream.defaultReadObject(); [EOL]     this.advanceLinePaint = SerialUtilities.readPaint(stream); [EOL]     this.advanceLineStroke = SerialUtilities.readStroke(stream); [EOL] } <line_num>: 1162,1169
public boolean equals(Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(obj instanceof CyclicNumberAxis)) { [EOL]         return false; [EOL]     } [EOL]     if (!super.equals(obj)) { [EOL]         return false; [EOL]     } [EOL]     CyclicNumberAxis that = (CyclicNumberAxis) obj; [EOL]     if (this.period != that.period) { [EOL]         return false; [EOL]     } [EOL]     if (this.offset != that.offset) { [EOL]         return false; [EOL]     } [EOL]     if (!PaintUtilities.equal(this.advanceLinePaint, that.advanceLinePaint)) { [EOL]         return false; [EOL]     } [EOL]     if (!ObjectUtilities.equal(this.advanceLineStroke, that.advanceLineStroke)) { [EOL]         return false; [EOL]     } [EOL]     if (this.advanceLineVisible != that.advanceLineVisible) { [EOL]         return false; [EOL]     } [EOL]     if (this.boundMappedToLastCycle != that.boundMappedToLastCycle) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } <line_num>: 1179,1211
