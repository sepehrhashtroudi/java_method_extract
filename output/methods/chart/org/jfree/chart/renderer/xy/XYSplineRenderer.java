public XYSplineRenderer() { [EOL]     this(5); [EOL] } <line_num>: 88,90
public XYSplineRenderer(int precision) { [EOL]     super(); [EOL]     if (precision <= 0) { [EOL]         throw new IllegalArgumentException("Requires precision > 0."); [EOL]     } [EOL]     this.precision = precision; [EOL] } <line_num>: 97,103
public ControlPoint(float x, float y) { [EOL]     this.x = x; [EOL]     this.y = y; [EOL] } <line_num>: 342,345
public int getPrecision() { [EOL]     return this.precision; [EOL] } <line_num>: 112,114
public void setPrecision(int p) { [EOL]     if (p <= 0) { [EOL]         throw new IllegalArgumentException("Requires p > 0."); [EOL]     } [EOL]     this.precision = p; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 124,130
public XYItemRendererState initialise(Graphics2D g2, Rectangle2D dataArea, XYPlot plot, XYDataset data, PlotRenderingInfo info) { [EOL]     State state = (State) super.initialise(g2, dataArea, plot, data, info); [EOL]     state.setProcessVisibleItemsOnly(false); [EOL]     this.points = new Vector(); [EOL]     setDrawSeriesLineAsPath(true); [EOL]     return state; [EOL] } <line_num>: 148,156
protected void drawPrimaryLineAsPath(XYItemRendererState state, Graphics2D g2, XYPlot plot, XYDataset dataset, int pass, int series, int item, boolean selected, ValueAxis domainAxis, ValueAxis rangeAxis, Rectangle2D dataArea) { [EOL]     RectangleEdge xAxisLocation = plot.getDomainAxisEdge(); [EOL]     RectangleEdge yAxisLocation = plot.getRangeAxisEdge(); [EOL]     double x1 = dataset.getXValue(series, item); [EOL]     double y1 = dataset.getYValue(series, item); [EOL]     double transX1 = domainAxis.valueToJava2D(x1, dataArea, xAxisLocation); [EOL]     double transY1 = rangeAxis.valueToJava2D(y1, dataArea, yAxisLocation); [EOL]     if (!Double.isNaN(transX1) && !Double.isNaN(transY1)) { [EOL]         ControlPoint p = new ControlPoint(plot.getOrientation() == PlotOrientation.HORIZONTAL ? (float) transY1 : (float) transX1, plot.getOrientation() == PlotOrientation.HORIZONTAL ? (float) transX1 : (float) transY1); [EOL]         if (!this.points.contains(p)) { [EOL]             this.points.add(p); [EOL]         } [EOL]     } [EOL]     if (item == dataset.getItemCount(series) - 1) { [EOL]         State s = (State) state; [EOL]         if (this.points.size() > 1) { [EOL]             ControlPoint cp0 = (ControlPoint) this.points.get(0); [EOL]             s.seriesPath.moveTo(cp0.x, cp0.y); [EOL]             if (this.points.size() == 2) { [EOL]                 ControlPoint cp1 = (ControlPoint) this.points.get(1); [EOL]                 s.seriesPath.lineTo(cp1.x, cp1.y); [EOL]             } else { [EOL]                 int np = this.points.size(); [EOL]                 float[] d = new float[np]; [EOL]                 float[] x = new float[np]; [EOL]                 float y; [EOL]                 float t; [EOL]                 float oldy = 0; [EOL]                 float oldt = 0; [EOL]                 float[] a = new float[np]; [EOL]                 float t1; [EOL]                 float t2; [EOL]                 float[] h = new float[np]; [EOL]                 for (int i = 0; i < np; i++) { [EOL]                     ControlPoint cpi = (ControlPoint) this.points.get(i); [EOL]                     x[i] = cpi.x; [EOL]                     d[i] = cpi.y; [EOL]                 } [EOL]                 for (int i = 1; i <= np - 1; i++) { [EOL]                     h[i] = x[i] - x[i - 1]; [EOL]                 } [EOL]                 float[] sub = new float[np - 1]; [EOL]                 float[] diag = new float[np - 1]; [EOL]                 float[] sup = new float[np - 1]; [EOL]                 for (int i = 1; i <= np - 2; i++) { [EOL]                     diag[i] = (h[i] + h[i + 1]) / 3; [EOL]                     sup[i] = h[i + 1] / 6; [EOL]                     sub[i] = h[i] / 6; [EOL]                     a[i] = (d[i + 1] - d[i]) / h[i + 1] - (d[i] - d[i - 1]) / h[i]; [EOL]                 } [EOL]                 solveTridiag(sub, diag, sup, a, np - 2); [EOL]                 oldt = x[0]; [EOL]                 oldy = d[0]; [EOL]                 s.seriesPath.moveTo(oldt, oldy); [EOL]                 for (int i = 1; i <= np - 1; i++) { [EOL]                     for (int j = 1; j <= this.precision; j++) { [EOL]                         t1 = (h[i] * j) / this.precision; [EOL]                         t2 = h[i] - t1; [EOL]                         y = ((-a[i - 1] / 6 * (t2 + h[i]) * t1 + d[i - 1]) * t2 + (-a[i] / 6 * (t1 + h[i]) * t2 + d[i]) * t1) / h[i]; [EOL]                         t = x[i - 1] + t1; [EOL]                         s.seriesPath.lineTo(t, y); [EOL]                         oldt = t; [EOL]                         oldy = y; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             drawShape1(g2, pass, series, item, selected, s.seriesPath); [EOL]         } [EOL]         this.points = new Vector(); [EOL]     } [EOL] } <line_num>: 177,279
private void solveTridiag(float[] sub, float[] diag, float[] sup, float[] b, int n) { [EOL]     int i; [EOL]     for (i = 2; i <= n; i++) { [EOL]         sub[i] = sub[i] / diag[i - 1]; [EOL]         diag[i] = diag[i] - sub[i] * sup[i - 1]; [EOL]         b[i] = b[i] - sub[i] * b[i - 1]; [EOL]     } [EOL]     b[n] = b[n] / diag[n]; [EOL]     for (i = n - 1; i >= 1; i--) { [EOL]         b[i] = (b[i] - sup[i] * b[i + 1]) / diag[i]; [EOL]     } [EOL] } <line_num>: 281,302
public boolean equals(Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(obj instanceof XYSplineRenderer)) { [EOL]         return false; [EOL]     } [EOL]     XYSplineRenderer that = (XYSplineRenderer) obj; [EOL]     if (this.precision != that.precision) { [EOL]         return false; [EOL]     } [EOL]     return super.equals(obj); [EOL] } <line_num>: 311,323
public boolean equals(Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(obj instanceof ControlPoint)) { [EOL]         return false; [EOL]     } [EOL]     ControlPoint that = (ControlPoint) obj; [EOL]     if (this.x != that.x) { [EOL]         return false; [EOL]     } [EOL]     ; [EOL]     return true; [EOL] } <line_num>: 354,367
