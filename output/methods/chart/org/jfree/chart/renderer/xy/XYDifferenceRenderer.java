public XYDifferenceRenderer() { [EOL]     this(Color.green, Color.red, false); [EOL] } <line_num>: 155,157
public XYDifferenceRenderer(Paint positivePaint, Paint negativePaint, boolean shapes) { [EOL]     if (positivePaint == null) { [EOL]         throw new IllegalArgumentException("Null 'positivePaint' argument."); [EOL]     } [EOL]     if (negativePaint == null) { [EOL]         throw new IllegalArgumentException("Null 'negativePaint' argument."); [EOL]     } [EOL]     this.positivePaint = positivePaint; [EOL]     this.negativePaint = negativePaint; [EOL]     this.shapesVisible = shapes; [EOL]     this.legendLine = new Line2D.Double(-7.0, 0.0, 7.0, 0.0); [EOL]     this.roundXCoordinates = false; [EOL] } <line_num>: 168,183
public Paint getPositivePaint() { [EOL]     return this.positivePaint; [EOL] } <line_num>: 192,194
public void setPositivePaint(Paint paint) { [EOL]     if (paint == null) { [EOL]         throw new IllegalArgumentException("Null 'paint' argument."); [EOL]     } [EOL]     this.positivePaint = paint; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 204,210
public Paint getNegativePaint() { [EOL]     return this.negativePaint; [EOL] } <line_num>: 219,221
public void setNegativePaint(Paint paint) { [EOL]     if (paint == null) { [EOL]         throw new IllegalArgumentException("Null 'paint' argument."); [EOL]     } [EOL]     this.negativePaint = paint; [EOL]     notifyListeners(new RendererChangeEvent(this)); [EOL] } <line_num>: 230,236
public boolean getShapesVisible() { [EOL]     return this.shapesVisible; [EOL] } <line_num>: 246,248
public void setShapesVisible(boolean flag) { [EOL]     this.shapesVisible = flag; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 259,262
public Shape getLegendLine() { [EOL]     return this.legendLine; [EOL] } <line_num>: 271,273
public void setLegendLine(Shape line) { [EOL]     if (line == null) { [EOL]         throw new IllegalArgumentException("Null 'line' argument."); [EOL]     } [EOL]     this.legendLine = line; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 283,289
public boolean getRoundXCoordinates() { [EOL]     return this.roundXCoordinates; [EOL] } <line_num>: 301,303
public void setRoundXCoordinates(boolean round) { [EOL]     this.roundXCoordinates = round; [EOL]     fireChangeEvent(); [EOL] } <line_num>: 316,319
public XYItemRendererState initialise(Graphics2D g2, Rectangle2D dataArea, XYPlot plot, XYDataset data, PlotRenderingInfo info) { [EOL]     XYItemRendererState state = super.initialise(g2, dataArea, plot, data, info); [EOL]     state.setProcessVisibleItemsOnly(false); [EOL]     return state; [EOL] } <line_num>: 337,348
public int getPassCount() { [EOL]     return 2; [EOL] } <line_num>: 356,358
public void drawItem(Graphics2D g2, XYItemRendererState state, Rectangle2D dataArea, XYPlot plot, ValueAxis domainAxis, ValueAxis rangeAxis, XYDataset dataset, int series, int item, boolean selected, int pass) { [EOL]     if (pass == 0) { [EOL]         drawItemPass0(g2, state, dataArea, plot, domainAxis, rangeAxis, dataset, series, item, selected); [EOL]     } else if (pass == 1) { [EOL]         drawItemPass1(g2, state, dataArea, plot, domainAxis, rangeAxis, dataset, series, item, selected); [EOL]     } [EOL] } <line_num>: 375,389
protected void drawItemPass0(Graphics2D x_graphics, XYItemRendererState state, Rectangle2D x_dataArea, XYPlot x_plot, ValueAxis x_domainAxis, ValueAxis x_rangeAxis, XYDataset x_dataset, int x_series, int x_item, boolean selected) { [EOL]     if (!((0 == x_series) && (0 == x_item))) { [EOL]         return; [EOL]     } [EOL]     boolean b_impliedZeroSubtrahend = (1 == x_dataset.getSeriesCount()); [EOL]     if (isEitherSeriesDegenerate(x_dataset, b_impliedZeroSubtrahend)) { [EOL]         return; [EOL]     } [EOL]     if (!b_impliedZeroSubtrahend && areSeriesDisjoint(x_dataset)) { [EOL]         return; [EOL]     } [EOL]     LinkedList l_minuendXs = new LinkedList(); [EOL]     LinkedList l_minuendYs = new LinkedList(); [EOL]     LinkedList l_subtrahendXs = new LinkedList(); [EOL]     LinkedList l_subtrahendYs = new LinkedList(); [EOL]     LinkedList l_polygonXs = new LinkedList(); [EOL]     LinkedList l_polygonYs = new LinkedList(); [EOL]     int l_minuendItem = 0; [EOL]     int l_minuendItemCount = x_dataset.getItemCount(0); [EOL]     Double l_minuendCurX = null; [EOL]     Double l_minuendNextX = null; [EOL]     Double l_minuendCurY = null; [EOL]     Double l_minuendNextY = null; [EOL]     double l_minuendMaxY = Double.NEGATIVE_INFINITY; [EOL]     double l_minuendMinY = Double.POSITIVE_INFINITY; [EOL]     int l_subtrahendItem = 0; [EOL]     int l_subtrahendItemCount = 0; [EOL]     Double l_subtrahendCurX = null; [EOL]     Double l_subtrahendNextX = null; [EOL]     Double l_subtrahendCurY = null; [EOL]     Double l_subtrahendNextY = null; [EOL]     double l_subtrahendMaxY = Double.NEGATIVE_INFINITY; [EOL]     double l_subtrahendMinY = Double.POSITIVE_INFINITY; [EOL]     if (b_impliedZeroSubtrahend) { [EOL]         l_subtrahendItem = 0; [EOL]         l_subtrahendItemCount = 2; [EOL]         l_subtrahendCurX = new Double(x_dataset.getXValue(0, 0)); [EOL]         l_subtrahendNextX = new Double(x_dataset.getXValue(0, (l_minuendItemCount - 1))); [EOL]         l_subtrahendCurY = new Double(0.0); [EOL]         l_subtrahendNextY = new Double(0.0); [EOL]         l_subtrahendMaxY = 0.0; [EOL]         l_subtrahendMinY = 0.0; [EOL]         l_subtrahendXs.add(l_subtrahendCurX); [EOL]         l_subtrahendYs.add(l_subtrahendCurY); [EOL]     } else { [EOL]         l_subtrahendItemCount = x_dataset.getItemCount(1); [EOL]     } [EOL]     boolean b_minuendDone = false; [EOL]     boolean b_minuendAdvanced = true; [EOL]     boolean b_minuendAtIntersect = false; [EOL]     boolean b_minuendFastForward = false; [EOL]     boolean b_subtrahendDone = false; [EOL]     boolean b_subtrahendAdvanced = true; [EOL]     boolean b_subtrahendAtIntersect = false; [EOL]     boolean b_subtrahendFastForward = false; [EOL]     boolean b_colinear = false; [EOL]     boolean b_positive; [EOL]     double l_x1 = 0.0, l_y1 = 0.0; [EOL]     double l_x2 = 0.0, l_y2 = 0.0; [EOL]     double l_x3 = 0.0, l_y3 = 0.0; [EOL]     double l_x4 = 0.0, l_y4 = 0.0; [EOL]     boolean b_fastForwardDone = false; [EOL]     while (!b_fastForwardDone) { [EOL]         l_x1 = x_dataset.getXValue(0, l_minuendItem); [EOL]         l_y1 = x_dataset.getYValue(0, l_minuendItem); [EOL]         l_x2 = x_dataset.getXValue(0, l_minuendItem + 1); [EOL]         l_y2 = x_dataset.getYValue(0, l_minuendItem + 1); [EOL]         l_minuendCurX = new Double(l_x1); [EOL]         l_minuendCurY = new Double(l_y1); [EOL]         l_minuendNextX = new Double(l_x2); [EOL]         l_minuendNextY = new Double(l_y2); [EOL]         if (b_impliedZeroSubtrahend) { [EOL]             l_x3 = l_subtrahendCurX.doubleValue(); [EOL]             l_y3 = l_subtrahendCurY.doubleValue(); [EOL]             l_x4 = l_subtrahendNextX.doubleValue(); [EOL]             l_y4 = l_subtrahendNextY.doubleValue(); [EOL]         } else { [EOL]             l_x3 = x_dataset.getXValue(1, l_subtrahendItem); [EOL]             l_y3 = x_dataset.getYValue(1, l_subtrahendItem); [EOL]             l_x4 = x_dataset.getXValue(1, l_subtrahendItem + 1); [EOL]             l_y4 = x_dataset.getYValue(1, l_subtrahendItem + 1); [EOL]             l_subtrahendCurX = new Double(l_x3); [EOL]             l_subtrahendCurY = new Double(l_y3); [EOL]             l_subtrahendNextX = new Double(l_x4); [EOL]             l_subtrahendNextY = new Double(l_y4); [EOL]         } [EOL]         if (l_x2 <= l_x3) { [EOL]             l_minuendItem++; [EOL]             b_minuendFastForward = true; [EOL]             continue; [EOL]         } [EOL]         if (l_x4 <= l_x1) { [EOL]             l_subtrahendItem++; [EOL]             b_subtrahendFastForward = true; [EOL]             continue; [EOL]         } [EOL]         if ((l_x3 < l_x1) && (l_x1 < l_x4)) { [EOL]             double l_slope = (l_y4 - l_y3) / (l_x4 - l_x3); [EOL]             l_subtrahendCurX = l_minuendCurX; [EOL]             l_subtrahendCurY = new Double((l_slope * l_x1) + (l_y3 - (l_slope * l_x3))); [EOL]             l_subtrahendXs.add(l_subtrahendCurX); [EOL]             l_subtrahendYs.add(l_subtrahendCurY); [EOL]         } [EOL]         if ((l_x1 < l_x3) && (l_x3 < l_x2)) { [EOL]             double l_slope = (l_y2 - l_y1) / (l_x2 - l_x1); [EOL]             l_minuendCurX = l_subtrahendCurX; [EOL]             l_minuendCurY = new Double((l_slope * l_x3) + (l_y1 - (l_slope * l_x1))); [EOL]             l_minuendXs.add(l_minuendCurX); [EOL]             l_minuendYs.add(l_minuendCurY); [EOL]         } [EOL]         l_minuendMaxY = l_minuendCurY.doubleValue(); [EOL]         l_minuendMinY = l_minuendCurY.doubleValue(); [EOL]         l_subtrahendMaxY = l_subtrahendCurY.doubleValue(); [EOL]         l_subtrahendMinY = l_subtrahendCurY.doubleValue(); [EOL]         b_fastForwardDone = true; [EOL]     } [EOL]     while (!b_minuendDone && !b_subtrahendDone) { [EOL]         if (!b_minuendDone && !b_minuendFastForward && b_minuendAdvanced) { [EOL]             l_x1 = x_dataset.getXValue(0, l_minuendItem); [EOL]             l_y1 = x_dataset.getYValue(0, l_minuendItem); [EOL]             l_minuendCurX = new Double(l_x1); [EOL]             l_minuendCurY = new Double(l_y1); [EOL]             if (!b_minuendAtIntersect) { [EOL]                 l_minuendXs.add(l_minuendCurX); [EOL]                 l_minuendYs.add(l_minuendCurY); [EOL]             } [EOL]             l_minuendMaxY = Math.max(l_minuendMaxY, l_y1); [EOL]             l_minuendMinY = Math.min(l_minuendMinY, l_y1); [EOL]             l_x2 = x_dataset.getXValue(0, l_minuendItem + 1); [EOL]             l_y2 = x_dataset.getYValue(0, l_minuendItem + 1); [EOL]             l_minuendNextX = new Double(l_x2); [EOL]             l_minuendNextY = new Double(l_y2); [EOL]         } [EOL]         if (!b_impliedZeroSubtrahend && !b_subtrahendDone && !b_subtrahendFastForward && b_subtrahendAdvanced) { [EOL]             l_x3 = x_dataset.getXValue(1, l_subtrahendItem); [EOL]             l_y3 = x_dataset.getYValue(1, l_subtrahendItem); [EOL]             l_subtrahendCurX = new Double(l_x3); [EOL]             l_subtrahendCurY = new Double(l_y3); [EOL]             if (!b_subtrahendAtIntersect) { [EOL]                 l_subtrahendXs.add(l_subtrahendCurX); [EOL]                 l_subtrahendYs.add(l_subtrahendCurY); [EOL]             } [EOL]             l_subtrahendMaxY = Math.max(l_subtrahendMaxY, l_y3); [EOL]             l_subtrahendMinY = Math.min(l_subtrahendMinY, l_y3); [EOL]             l_x4 = x_dataset.getXValue(1, l_subtrahendItem + 1); [EOL]             l_y4 = x_dataset.getYValue(1, l_subtrahendItem + 1); [EOL]             l_subtrahendNextX = new Double(l_x4); [EOL]             l_subtrahendNextY = new Double(l_y4); [EOL]         } [EOL]         b_minuendFastForward = false; [EOL]         b_subtrahendFastForward = false; [EOL]         Double l_intersectX = null; [EOL]         Double l_intersectY = null; [EOL]         boolean b_intersect = false; [EOL]         b_minuendAtIntersect = false; [EOL]         b_subtrahendAtIntersect = false; [EOL]         if ((l_x2 == l_x4) && (l_y2 == l_y4)) { [EOL]             if ((l_x1 == l_x3) && (l_y1 == l_y3)) { [EOL]                 b_colinear = true; [EOL]             } else { [EOL]                 l_intersectX = new Double(l_x2); [EOL]                 l_intersectY = new Double(l_y2); [EOL]                 b_intersect = true; [EOL]                 b_minuendAtIntersect = true; [EOL]                 b_subtrahendAtIntersect = true; [EOL]             } [EOL]         } else { [EOL]             double l_denominator = ((l_y4 - l_y3) * (l_x2 - l_x1)) - ((l_x4 - l_x3) * (l_y2 - l_y1)); [EOL]             double l_deltaY = l_y1 - l_y3; [EOL]             double l_deltaX = l_x1 - l_x3; [EOL]             double l_numeratorA = ((l_x4 - l_x3) * l_deltaY) - ((l_y4 - l_y3) * l_deltaX); [EOL]             double l_numeratorB = ((l_x2 - l_x1) * l_deltaY) - ((l_y2 - l_y1) * l_deltaX); [EOL]             if ((0 == l_numeratorA) && (0 == l_numeratorB) && (0 == l_denominator)) { [EOL]                 b_colinear = true; [EOL]             } else { [EOL]                 if (b_colinear) { [EOL]                     l_minuendXs.clear(); [EOL]                     l_minuendYs.clear(); [EOL]                     l_subtrahendXs.clear(); [EOL]                     l_subtrahendYs.clear(); [EOL]                     l_polygonXs.clear(); [EOL]                     l_polygonYs.clear(); [EOL]                     b_colinear = false; [EOL]                     boolean b_useMinuend = ((l_x3 <= l_x1) && (l_x1 <= l_x4)); [EOL]                     l_polygonXs.add(b_useMinuend ? l_minuendCurX : l_subtrahendCurX); [EOL]                     l_polygonYs.add(b_useMinuend ? l_minuendCurY : l_subtrahendCurY); [EOL]                 } [EOL]                 double l_slopeA = l_numeratorA / l_denominator; [EOL]                 double l_slopeB = l_numeratorB / l_denominator; [EOL]                 if ((0 < l_slopeA) && (l_slopeA <= 1) && (0 < l_slopeB) && (l_slopeB <= 1)) { [EOL]                     double l_xi = l_x1 + (l_slopeA * (l_x2 - l_x1)); [EOL]                     double l_yi = l_y1 + (l_slopeA * (l_y2 - l_y1)); [EOL]                     l_intersectX = new Double(l_xi); [EOL]                     l_intersectY = new Double(l_yi); [EOL]                     b_intersect = true; [EOL]                     b_minuendAtIntersect = ((l_xi == l_x2) && (l_yi == l_y2)); [EOL]                     b_subtrahendAtIntersect = ((l_xi == l_x4) && (l_yi == l_y4)); [EOL]                     l_minuendCurX = l_intersectX; [EOL]                     l_minuendCurY = l_intersectY; [EOL]                     l_subtrahendCurX = l_intersectX; [EOL]                     l_subtrahendCurY = l_intersectY; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (b_intersect) { [EOL]             l_polygonXs.addAll(l_minuendXs); [EOL]             l_polygonYs.addAll(l_minuendYs); [EOL]             l_polygonXs.add(l_intersectX); [EOL]             l_polygonYs.add(l_intersectY); [EOL]             Collections.reverse(l_subtrahendXs); [EOL]             Collections.reverse(l_subtrahendYs); [EOL]             l_polygonXs.addAll(l_subtrahendXs); [EOL]             l_polygonYs.addAll(l_subtrahendYs); [EOL]             b_positive = (l_subtrahendMaxY <= l_minuendMaxY) && (l_subtrahendMinY <= l_minuendMinY); [EOL]             createPolygon(x_graphics, x_dataArea, x_plot, x_domainAxis, x_rangeAxis, b_positive, l_polygonXs, l_polygonYs); [EOL]             l_minuendXs.clear(); [EOL]             l_minuendYs.clear(); [EOL]             l_subtrahendXs.clear(); [EOL]             l_subtrahendYs.clear(); [EOL]             l_polygonXs.clear(); [EOL]             l_polygonYs.clear(); [EOL]             double l_y = l_intersectY.doubleValue(); [EOL]             l_minuendMaxY = l_y; [EOL]             l_subtrahendMaxY = l_y; [EOL]             l_minuendMinY = l_y; [EOL]             l_subtrahendMinY = l_y; [EOL]             l_polygonXs.add(l_intersectX); [EOL]             l_polygonYs.add(l_intersectY); [EOL]         } [EOL]         if (l_x2 <= l_x4) { [EOL]             l_minuendItem++; [EOL]             b_minuendAdvanced = true; [EOL]         } else { [EOL]             b_minuendAdvanced = false; [EOL]         } [EOL]         if (l_x4 <= l_x2) { [EOL]             l_subtrahendItem++; [EOL]             b_subtrahendAdvanced = true; [EOL]         } else { [EOL]             b_subtrahendAdvanced = false; [EOL]         } [EOL]         b_minuendDone = (l_minuendItem == (l_minuendItemCount - 1)); [EOL]         b_subtrahendDone = (l_subtrahendItem == (l_subtrahendItemCount - 1)); [EOL]     } [EOL]     if (b_minuendDone && (l_x3 < l_x2) && (l_x2 < l_x4)) { [EOL]         double l_slope = (l_y4 - l_y3) / (l_x4 - l_x3); [EOL]         l_subtrahendNextX = l_minuendNextX; [EOL]         l_subtrahendNextY = new Double((l_slope * l_x2) + (l_y3 - (l_slope * l_x3))); [EOL]     } [EOL]     if (b_subtrahendDone && (l_x1 < l_x4) && (l_x4 < l_x2)) { [EOL]         double l_slope = (l_y2 - l_y1) / (l_x2 - l_x1); [EOL]         l_minuendNextX = l_subtrahendNextX; [EOL]         l_minuendNextY = new Double((l_slope * l_x4) + (l_y1 - (l_slope * l_x1))); [EOL]     } [EOL]     l_minuendMaxY = Math.max(l_minuendMaxY, l_minuendNextY.doubleValue()); [EOL]     l_subtrahendMaxY = Math.max(l_subtrahendMaxY, l_subtrahendNextY.doubleValue()); [EOL]     l_minuendMinY = Math.min(l_minuendMinY, l_minuendNextY.doubleValue()); [EOL]     l_subtrahendMinY = Math.min(l_subtrahendMinY, l_subtrahendNextY.doubleValue()); [EOL]     l_minuendXs.add(l_minuendNextX); [EOL]     l_minuendYs.add(l_minuendNextY); [EOL]     l_subtrahendXs.add(l_subtrahendNextX); [EOL]     l_subtrahendYs.add(l_subtrahendNextY); [EOL]     l_polygonXs.addAll(l_minuendXs); [EOL]     l_polygonYs.addAll(l_minuendYs); [EOL]     Collections.reverse(l_subtrahendXs); [EOL]     Collections.reverse(l_subtrahendYs); [EOL]     l_polygonXs.addAll(l_subtrahendXs); [EOL]     l_polygonYs.addAll(l_subtrahendYs); [EOL]     b_positive = (l_subtrahendMaxY <= l_minuendMaxY) && (l_subtrahendMinY <= l_minuendMinY); [EOL]     createPolygon(x_graphics, x_dataArea, x_plot, x_domainAxis, x_rangeAxis, b_positive, l_polygonXs, l_polygonYs); [EOL] } <line_num>: 408,827
protected void drawItemPass1(Graphics2D x_graphics, XYItemRendererState state, Rectangle2D x_dataArea, XYPlot x_plot, ValueAxis x_domainAxis, ValueAxis x_rangeAxis, XYDataset x_dataset, int x_series, int x_item, boolean selected) { [EOL]     Shape l_entityArea = null; [EOL]     EntityCollection l_entities = null; [EOL]     if (state.getInfo() != null) { [EOL]         l_entities = state.getInfo().getOwner().getEntityCollection(); [EOL]     } [EOL]     Paint l_seriesPaint = getItemPaint(x_series, x_item, selected); [EOL]     Stroke l_seriesStroke = getItemStroke(x_series, x_item, selected); [EOL]     x_graphics.setPaint(l_seriesPaint); [EOL]     x_graphics.setStroke(l_seriesStroke); [EOL]     PlotOrientation l_orientation = x_plot.getOrientation(); [EOL]     RectangleEdge l_domainAxisLocation = x_plot.getDomainAxisEdge(); [EOL]     RectangleEdge l_rangeAxisLocation = x_plot.getRangeAxisEdge(); [EOL]     double l_x0 = x_dataset.getXValue(x_series, x_item); [EOL]     double l_y0 = x_dataset.getYValue(x_series, x_item); [EOL]     double l_x1 = x_domainAxis.valueToJava2D(l_x0, x_dataArea, l_domainAxisLocation); [EOL]     double l_y1 = x_rangeAxis.valueToJava2D(l_y0, x_dataArea, l_rangeAxisLocation); [EOL]     if (getShapesVisible()) { [EOL]         Shape l_shape = getItemShape(x_series, x_item, selected); [EOL]         if (l_orientation == PlotOrientation.HORIZONTAL) { [EOL]             l_shape = ShapeUtilities.createTranslatedShape(l_shape, l_y1, l_x1); [EOL]         } else { [EOL]             l_shape = ShapeUtilities.createTranslatedShape(l_shape, l_x1, l_y1); [EOL]         } [EOL]         if (l_shape.intersects(x_dataArea)) { [EOL]             x_graphics.setPaint(getItemPaint(x_series, x_item, selected)); [EOL]             x_graphics.fill(l_shape); [EOL]         } [EOL]         l_entityArea = l_shape; [EOL]     } [EOL]     if (null != l_entities) { [EOL]         if (null == l_entityArea) { [EOL]             l_entityArea = new Rectangle2D.Double((l_x1 - 2), (l_y1 - 2), 4, 4); [EOL]         } [EOL]         String l_tip = null; [EOL]         XYToolTipGenerator l_tipGenerator = getToolTipGenerator(x_series, x_item, selected); [EOL]         if (null != l_tipGenerator) { [EOL]             l_tip = l_tipGenerator.generateToolTip(x_dataset, x_series, x_item); [EOL]         } [EOL]         String l_url = null; [EOL]         XYURLGenerator l_urlGenerator = getURLGenerator(x_series, x_item, selected); [EOL]         if (null != l_urlGenerator) { [EOL]             l_url = l_urlGenerator.generateURL(x_dataset, x_series, x_item); [EOL]         } [EOL]         XYItemEntity l_entity = new XYItemEntity(l_entityArea, x_dataset, x_series, x_item, l_tip, l_url); [EOL]         l_entities.add(l_entity); [EOL]     } [EOL]     if (isItemLabelVisible(x_series, x_item, selected)) { [EOL]         drawItemLabel(x_graphics, l_orientation, x_dataset, x_series, x_item, selected, l_x1, l_y1, (l_y1 < 0.0)); [EOL]     } [EOL]     int l_domainAxisIndex = x_plot.getDomainAxisIndex(x_domainAxis); [EOL]     int l_rangeAxisIndex = x_plot.getRangeAxisIndex(x_rangeAxis); [EOL]     XYCrosshairState crosshairState = state.getCrosshairState(); [EOL]     updateCrosshairValues(crosshairState, l_x0, l_y0, l_domainAxisIndex, l_rangeAxisIndex, l_x1, l_y1, l_orientation); [EOL]     if (0 == x_item) { [EOL]         return; [EOL]     } [EOL]     double l_x2 = x_domainAxis.valueToJava2D(x_dataset.getXValue(x_series, (x_item - 1)), x_dataArea, l_domainAxisLocation); [EOL]     double l_y2 = x_rangeAxis.valueToJava2D(x_dataset.getYValue(x_series, (x_item - 1)), x_dataArea, l_rangeAxisLocation); [EOL]     Line2D l_line = null; [EOL]     if (PlotOrientation.HORIZONTAL == l_orientation) { [EOL]         l_line = new Line2D.Double(l_y1, l_x1, l_y2, l_x2); [EOL]     } else if (PlotOrientation.VERTICAL == l_orientation) { [EOL]         l_line = new Line2D.Double(l_x1, l_y1, l_x2, l_y2); [EOL]     } [EOL]     if ((null != l_line) && l_line.intersects(x_dataArea)) { [EOL]         x_graphics.setPaint(getItemPaint(x_series, x_item, selected)); [EOL]         x_graphics.setStroke(getItemStroke(x_series, x_item, selected)); [EOL]         x_graphics.draw(l_line); [EOL]     } [EOL] } <line_num>: 848,951
private boolean isEitherSeriesDegenerate(XYDataset x_dataset, boolean x_impliedZeroSubtrahend) { [EOL]     if (x_impliedZeroSubtrahend) { [EOL]         return (x_dataset.getItemCount(0) < 2); [EOL]     } [EOL]     return ((x_dataset.getItemCount(0) < 2) || (x_dataset.getItemCount(1) < 2)); [EOL] } <line_num>: 962,971
private boolean areSeriesDisjoint(XYDataset x_dataset) { [EOL]     int l_minuendItemCount = x_dataset.getItemCount(0); [EOL]     double l_minuendFirst = x_dataset.getXValue(0, 0); [EOL]     double l_minuendLast = x_dataset.getXValue(0, l_minuendItemCount - 1); [EOL]     int l_subtrahendItemCount = x_dataset.getItemCount(1); [EOL]     double l_subtrahendFirst = x_dataset.getXValue(1, 0); [EOL]     double l_subtrahendLast = x_dataset.getXValue(1, l_subtrahendItemCount - 1); [EOL]     return ((l_minuendLast < l_subtrahendFirst) || (l_subtrahendLast < l_minuendFirst)); [EOL] } <line_num>: 981,994
private void createPolygon(Graphics2D x_graphics, Rectangle2D x_dataArea, XYPlot x_plot, ValueAxis x_domainAxis, ValueAxis x_rangeAxis, boolean x_positive, LinkedList x_xValues, LinkedList x_yValues) { [EOL]     PlotOrientation l_orientation = x_plot.getOrientation(); [EOL]     RectangleEdge l_domainAxisLocation = x_plot.getDomainAxisEdge(); [EOL]     RectangleEdge l_rangeAxisLocation = x_plot.getRangeAxisEdge(); [EOL]     Object[] l_xValues = x_xValues.toArray(); [EOL]     Object[] l_yValues = x_yValues.toArray(); [EOL]     GeneralPath l_path = new GeneralPath(); [EOL]     if (PlotOrientation.VERTICAL == l_orientation) { [EOL]         double l_x = x_domainAxis.valueToJava2D(((Double) l_xValues[0]).doubleValue(), x_dataArea, l_domainAxisLocation); [EOL]         if (this.roundXCoordinates) { [EOL]             l_x = Math.rint(l_x); [EOL]         } [EOL]         double l_y = x_rangeAxis.valueToJava2D(((Double) l_yValues[0]).doubleValue(), x_dataArea, l_rangeAxisLocation); [EOL]         l_path.moveTo((float) l_x, (float) l_y); [EOL]         for (int i = 1; i < l_xValues.length; i++) { [EOL]             l_x = x_domainAxis.valueToJava2D(((Double) l_xValues[i]).doubleValue(), x_dataArea, l_domainAxisLocation); [EOL]             if (this.roundXCoordinates) { [EOL]                 l_x = Math.rint(l_x); [EOL]             } [EOL]             l_y = x_rangeAxis.valueToJava2D(((Double) l_yValues[i]).doubleValue(), x_dataArea, l_rangeAxisLocation); [EOL]             l_path.lineTo((float) l_x, (float) l_y); [EOL]         } [EOL]         l_path.closePath(); [EOL]     } else { [EOL]         double l_x = x_domainAxis.valueToJava2D(((Double) l_xValues[0]).doubleValue(), x_dataArea, l_domainAxisLocation); [EOL]         if (this.roundXCoordinates) { [EOL]             l_x = Math.rint(l_x); [EOL]         } [EOL]         double l_y = x_rangeAxis.valueToJava2D(((Double) l_yValues[0]).doubleValue(), x_dataArea, l_rangeAxisLocation); [EOL]         l_path.moveTo((float) l_y, (float) l_x); [EOL]         for (int i = 1; i < l_xValues.length; i++) { [EOL]             l_x = x_domainAxis.valueToJava2D(((Double) l_xValues[i]).doubleValue(), x_dataArea, l_domainAxisLocation); [EOL]             if (this.roundXCoordinates) { [EOL]                 l_x = Math.rint(l_x); [EOL]             } [EOL]             l_y = x_rangeAxis.valueToJava2D(((Double) l_yValues[i]).doubleValue(), x_dataArea, l_rangeAxisLocation); [EOL]             l_path.lineTo((float) l_y, (float) l_x); [EOL]         } [EOL]         l_path.closePath(); [EOL]     } [EOL]     if (l_path.intersects(x_dataArea)) { [EOL]         x_graphics.setPaint(x_positive ? getPositivePaint() : getNegativePaint()); [EOL]         x_graphics.fill(l_path); [EOL]     } [EOL] } <line_num>: 1012,1092
public LegendItem getLegendItem(int datasetIndex, int series) { [EOL]     LegendItem result = null; [EOL]     XYPlot p = getPlot(); [EOL]     if (p != null) { [EOL]         XYDataset dataset = p.getDataset(datasetIndex); [EOL]         if (dataset != null) { [EOL]             if (getItemVisible(series, 0)) { [EOL]                 String label = getLegendItemLabelGenerator().generateLabel(dataset, series); [EOL]                 String description = label; [EOL]                 String toolTipText = null; [EOL]                 if (getLegendItemToolTipGenerator() != null) { [EOL]                     toolTipText = getLegendItemToolTipGenerator().generateLabel(dataset, series); [EOL]                 } [EOL]                 String urlText = null; [EOL]                 if (getLegendItemURLGenerator() != null) { [EOL]                     urlText = getLegendItemURLGenerator().generateLabel(dataset, series); [EOL]                 } [EOL]                 Paint paint = lookupSeriesPaint(series); [EOL]                 Stroke stroke = lookupSeriesStroke(series); [EOL]                 Shape line = getLegendLine(); [EOL]                 result = new LegendItem(label, description, toolTipText, urlText, line, stroke, paint); [EOL]                 result.setLabelFont(lookupLegendTextFont(series)); [EOL]                 Paint labelPaint = lookupLegendTextPaint(series); [EOL]                 if (labelPaint != null) { [EOL]                     result.setLabelPaint(labelPaint); [EOL]                 } [EOL]                 result.setDataset(dataset); [EOL]                 result.setDatasetIndex(datasetIndex); [EOL]                 result.setSeriesKey(dataset.getSeriesKey(series)); [EOL]                 result.setSeriesIndex(series); [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1103,1145
public boolean equals(Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(obj instanceof XYDifferenceRenderer)) { [EOL]         return false; [EOL]     } [EOL]     if (!super.equals(obj)) { [EOL]         return false; [EOL]     } [EOL]     XYDifferenceRenderer that = (XYDifferenceRenderer) obj; [EOL]     if (!PaintUtilities.equal(this.positivePaint, that.positivePaint)) { [EOL]         return false; [EOL]     } [EOL]     if (!PaintUtilities.equal(this.negativePaint, that.negativePaint)) { [EOL]         return false; [EOL]     } [EOL]     if (this.shapesVisible != that.shapesVisible) { [EOL]         return false; [EOL]     } [EOL]     if (!ShapeUtilities.equal(this.legendLine, that.legendLine)) { [EOL]         return false; [EOL]     } [EOL]     if (this.roundXCoordinates != that.roundXCoordinates) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } <line_num>: 1154,1181
public Object clone() throws CloneNotSupportedException { [EOL]     XYDifferenceRenderer clone = (XYDifferenceRenderer) super.clone(); [EOL]     clone.legendLine = ShapeUtilities.clone(this.legendLine); [EOL]     return clone; [EOL] } <line_num>: 1190,1194
private void writeObject(ObjectOutputStream stream) throws IOException { [EOL]     stream.defaultWriteObject(); [EOL]     SerialUtilities.writePaint(this.positivePaint, stream); [EOL]     SerialUtilities.writePaint(this.negativePaint, stream); [EOL]     SerialUtilities.writeShape(this.legendLine, stream); [EOL] } <line_num>: 1203,1208
private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException { [EOL]     stream.defaultReadObject(); [EOL]     this.positivePaint = SerialUtilities.readPaint(stream); [EOL]     this.negativePaint = SerialUtilities.readPaint(stream); [EOL]     this.legendLine = SerialUtilities.readShape(stream); [EOL] } <line_num>: 1218,1224
