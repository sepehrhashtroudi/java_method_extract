public CSVLexer1(CSVFormat format, ExtendedBufferedReader in) { [EOL]     super(format, in); [EOL] } <line_num>: 29,31
@Override [EOL] Token nextToken(Token tkn) throws IOException { [EOL]     wsBuf.setLength(0); [EOL]     int lastChar = in.readAgain(); [EOL]     int c = in.read(); [EOL]     boolean eol = isEndOfLine(c); [EOL]     c = in.readAgain(); [EOL]     if (format.isEmptyLinesIgnored()) { [EOL]         while (eol && (lastChar == '\n' || lastChar == '\r' || lastChar == ExtendedBufferedReader.UNDEFINED) && !isEndOfFile(lastChar)) { [EOL]             lastChar = c; [EOL]             c = in.read(); [EOL]             eol = isEndOfLine(c); [EOL]             c = in.readAgain(); [EOL]             if (isEndOfFile(c)) { [EOL]                 tkn.type = EOF; [EOL]                 return tkn; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (isEndOfFile(lastChar) || (lastChar != format.getDelimiter() && isEndOfFile(c))) { [EOL]         tkn.type = EOF; [EOL]         return tkn; [EOL]     } [EOL]     while (!tkn.isReady && tkn.type != EOF) { [EOL]         if (format.isSurroundingSpacesIgnored()) { [EOL]             while (isWhitespace(c) && !eol) { [EOL]                 wsBuf.append((char) c); [EOL]                 c = in.read(); [EOL]                 eol = isEndOfLine(c); [EOL]             } [EOL]         } [EOL]         if (c == format.getCommentStart()) { [EOL]             in.readLine(); [EOL]             tkn = nextToken(tkn.reset()); [EOL]         } else if (c == format.getDelimiter()) { [EOL]             tkn.type = TOKEN; [EOL]             tkn.isReady = true; [EOL]         } else if (eol) { [EOL]             tkn.type = EORECORD; [EOL]             tkn.isReady = true; [EOL]         } else if (c == format.getEncapsulator()) { [EOL]             encapsulatedTokenLexer(tkn, c); [EOL]         } else if (isEndOfFile(c)) { [EOL]             tkn.type = EOF; [EOL]             tkn.isReady = true; [EOL]         } else { [EOL]             if (!format.isSurroundingSpacesIgnored()) { [EOL]                 tkn.content.append(wsBuf); [EOL]             } [EOL]             simpleTokenLexer(tkn, c); [EOL]         } [EOL]     } [EOL]     return tkn; [EOL] } <line_num>: 42,125
private Token simpleTokenLexer(Token tkn, int c) throws IOException { [EOL]     while (true) { [EOL]         if (isEndOfLine(c)) { [EOL]             tkn.type = EORECORD; [EOL]             tkn.isReady = true; [EOL]             break; [EOL]         } else if (isEndOfFile(c)) { [EOL]             tkn.type = EOF; [EOL]             tkn.isReady = true; [EOL]             break; [EOL]         } else if (c == format.getDelimiter()) { [EOL]             tkn.type = TOKEN; [EOL]             tkn.isReady = true; [EOL]             break; [EOL]         } else if (c == format.getEscape()) { [EOL]             tkn.content.append((char) readEscape(c)); [EOL]         } else { [EOL]             tkn.content.append((char) c); [EOL]         } [EOL]         c = in.read(); [EOL]     } [EOL]     if (format.isSurroundingSpacesIgnored()) { [EOL]         trimTrailingSpaces(tkn.content); [EOL]     } [EOL]     return tkn; [EOL] } <line_num>: 144,175
private Token encapsulatedTokenLexer(Token tkn, int c) throws IOException { [EOL]     int startLineNumber = getLineNumber(); [EOL]     while (true) { [EOL]         c = in.read(); [EOL]         if (c == format.getEscape()) { [EOL]             tkn.content.append((char) readEscape(c)); [EOL]         } else if (c == format.getEncapsulator()) { [EOL]             if (in.lookAhead() == format.getEncapsulator()) { [EOL]                 c = in.read(); [EOL]                 tkn.content.append((char) c); [EOL]             } else { [EOL]                 while (true) { [EOL]                     c = in.read(); [EOL]                     if (c == format.getDelimiter()) { [EOL]                         tkn.type = TOKEN; [EOL]                         tkn.isReady = true; [EOL]                         return tkn; [EOL]                     } else if (isEndOfFile(c)) { [EOL]                         tkn.type = EOF; [EOL]                         tkn.isReady = true; [EOL]                         return tkn; [EOL]                     } else if (isEndOfLine(c)) { [EOL]                         tkn.type = EORECORD; [EOL]                         tkn.isReady = true; [EOL]                         return tkn; [EOL]                     } else if (!isWhitespace(c)) { [EOL]                         throw new IOException("(line " + getLineNumber() + ") invalid char between encapsulated token and delimiter"); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } else if (isEndOfFile(c)) { [EOL]             throw new IOException("(startline " + startLineNumber + ") EOF reached before encapsulated token finished"); [EOL]         } else { [EOL]             tkn.content.append((char) c); [EOL]         } [EOL]     } [EOL] } <line_num>: 190,236
