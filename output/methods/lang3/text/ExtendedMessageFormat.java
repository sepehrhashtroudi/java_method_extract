public ExtendedMessageFormat(final String pattern) { [EOL]     this(pattern, Locale.getDefault()); [EOL] } <line_num>: 90,92
public ExtendedMessageFormat(final String pattern, final Locale locale) { [EOL]     this(pattern, locale, null); [EOL] } <line_num>: 101,103
public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry) { [EOL]     this(pattern, Locale.getDefault(), registry); [EOL] } <line_num>: 112,114
public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry) { [EOL]     super(DUMMY_PATTERN); [EOL]     setLocale(locale); [EOL]     this.registry = registry; [EOL]     applyPattern(pattern); [EOL] } <line_num>: 124,129
@Override [EOL] public String toPattern() { [EOL]     return toPattern; [EOL] } <line_num>: 134,137
@Override [EOL] public final void applyPattern(final String pattern) { [EOL]     if (registry == null) { [EOL]         super.applyPattern(pattern); [EOL]         toPattern = super.toPattern(); [EOL]         return; [EOL]     } [EOL]     final ArrayList<Format> foundFormats = new ArrayList<Format>(); [EOL]     final ArrayList<String> foundDescriptions = new ArrayList<String>(); [EOL]     final StringBuilder stripCustom = new StringBuilder(pattern.length()); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     int fmtCount = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, stripCustom, true); [EOL]                 break; [EOL]             case START_FE: [EOL]                 fmtCount++; [EOL]                 seekNonWs(pattern, pos); [EOL]                 final int start = pos.getIndex(); [EOL]                 final int index = readArgumentIndex(pattern, next(pos)); [EOL]                 stripCustom.append(START_FE).append(index); [EOL]                 seekNonWs(pattern, pos); [EOL]                 Format format = null; [EOL]                 String formatDescription = null; [EOL]                 if (c[pos.getIndex()] == START_FMT) { [EOL]                     formatDescription = parseFormatDescription(pattern, next(pos)); [EOL]                     format = getFormat(formatDescription); [EOL]                     if (format == null) { [EOL]                         stripCustom.append(START_FMT).append(formatDescription); [EOL]                     } [EOL]                 } [EOL]                 foundFormats.add(format); [EOL]                 foundDescriptions.add(format == null ? null : formatDescription); [EOL]                 Validate.isTrue(foundFormats.size() == fmtCount); [EOL]                 Validate.isTrue(foundDescriptions.size() == fmtCount); [EOL]                 if (c[pos.getIndex()] != END_FE) { [EOL]                     throw new IllegalArgumentException("Unreadable format element at position " + start); [EOL]                 } [EOL]             default: [EOL]                 stripCustom.append(c[pos.getIndex()]); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     super.applyPattern(stripCustom.toString()); [EOL]     toPattern = insertFormats(super.toPattern(), foundDescriptions); [EOL]     if (containsElements(foundFormats)) { [EOL]         final Format[] origFormats = getFormats(); [EOL]         int i = 0; [EOL]         for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) { [EOL]             final Format f = it.next(); [EOL]             if (f != null) { [EOL]                 origFormats[i] = f; [EOL]             } [EOL]         } [EOL]         super.setFormats(origFormats); [EOL]     } [EOL] } <line_num>: 144,209
@Override [EOL] public void setFormat(final int formatElementIndex, final Format newFormat) { [EOL]     throw new UnsupportedOperationException(); [EOL] } <line_num>: 218,221
@Override [EOL] public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat) { [EOL]     throw new UnsupportedOperationException(); [EOL] } <line_num>: 230,233
@Override [EOL] public void setFormats(final Format[] newFormats) { [EOL]     throw new UnsupportedOperationException(); [EOL] } <line_num>: 241,244
@Override [EOL] public void setFormatsByArgumentIndex(final Format[] newFormats) { [EOL]     throw new UnsupportedOperationException(); [EOL] } <line_num>: 252,255
@Override [EOL] public boolean equals(final Object obj) { [EOL]     if (obj == this) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null) { [EOL]         return false; [EOL]     } [EOL]     if (!super.equals(obj)) { [EOL]         return false; [EOL]     } [EOL]     if (ObjectUtils.notEqual(getClass(), obj.getClass())) { [EOL]         return false; [EOL]     } [EOL]     final ExtendedMessageFormat rhs = (ExtendedMessageFormat) obj; [EOL]     if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) { [EOL]         return false; [EOL]     } [EOL]     if (ObjectUtils.notEqual(registry, rhs.registry)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } <line_num>: 263,285
@Override [EOL] public int hashCode() { [EOL]     int result = super.hashCode(); [EOL]     result = HASH_SEED * result + ObjectUtils.hashCode(registry); [EOL]     result = HASH_SEED * result + ObjectUtils.hashCode(toPattern); [EOL]     return result; [EOL] } <line_num>: 292,298
private Format getFormat(final String desc) { [EOL]     if (registry != null) { [EOL]         String name = desc; [EOL]         String args = null; [EOL]         final int i = desc.indexOf(START_FMT); [EOL]         if (i > 0) { [EOL]             name = desc.substring(0, i).trim(); [EOL]             args = desc.substring(i + 1).trim(); [EOL]         } [EOL]         final FormatFactory factory = registry.get(name); [EOL]         if (factory != null) { [EOL]             return factory.getFormat(name, args, getLocale()); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 306,321
private int readArgumentIndex(final String pattern, final ParsePosition pos) { [EOL]     final int start = pos.getIndex(); [EOL]     seekNonWs(pattern, pos); [EOL]     final StringBuilder result = new StringBuilder(); [EOL]     boolean error = false; [EOL]     for (; !error && pos.getIndex() < pattern.length(); next(pos)) { [EOL]         char c = pattern.charAt(pos.getIndex()); [EOL]         if (Character.isWhitespace(c)) { [EOL]             seekNonWs(pattern, pos); [EOL]             c = pattern.charAt(pos.getIndex()); [EOL]             if (c != START_FMT && c != END_FE) { [EOL]                 error = true; [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if ((c == START_FMT || c == END_FE) && result.length() > 0) { [EOL]             try { [EOL]                 return Integer.parseInt(result.toString()); [EOL]             } catch (final NumberFormatException e) { [EOL]             } [EOL]         } [EOL]         error = !Character.isDigit(c); [EOL]         result.append(c); [EOL]     } [EOL]     if (error) { [EOL]         throw new IllegalArgumentException("Invalid format argument index at position " + start + ": " + pattern.substring(start, pos.getIndex())); [EOL]     } [EOL]     throw new IllegalArgumentException("Unterminated format element at position " + start); [EOL] } <line_num>: 330,363
private String parseFormatDescription(final String pattern, final ParsePosition pos) { [EOL]     final int start = pos.getIndex(); [EOL]     seekNonWs(pattern, pos); [EOL]     final int text = pos.getIndex(); [EOL]     int depth = 1; [EOL]     for (; pos.getIndex() < pattern.length(); next(pos)) { [EOL]         switch(pattern.charAt(pos.getIndex())) { [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]                 if (depth == 0) { [EOL]                     return pattern.substring(text, pos.getIndex()); [EOL]                 } [EOL]                 break; [EOL]             case QUOTE: [EOL]                 getQuotedString(pattern, pos, false); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("Unterminated format element at position " + start); [EOL] } <line_num>: 372,395
private String insertFormats(final String pattern, final ArrayList<String> customPatterns) { [EOL]     if (!containsElements(customPatterns)) { [EOL]         return pattern; [EOL]     } [EOL]     final StringBuilder sb = new StringBuilder(pattern.length() * 2); [EOL]     final ParsePosition pos = new ParsePosition(0); [EOL]     int fe = -1; [EOL]     int depth = 0; [EOL]     while (pos.getIndex() < pattern.length()) { [EOL]         final char c = pattern.charAt(pos.getIndex()); [EOL]         switch(c) { [EOL]             case QUOTE: [EOL]                 appendQuotedString(pattern, pos, sb, false); [EOL]                 break; [EOL]             case START_FE: [EOL]                 depth++; [EOL]                 if (depth == 1) { [EOL]                     fe++; [EOL]                     sb.append(START_FE).append(readArgumentIndex(pattern, next(pos))); [EOL]                     final String customPattern = customPatterns.get(fe); [EOL]                     if (customPattern != null) { [EOL]                         sb.append(START_FMT).append(customPattern); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case END_FE: [EOL]                 depth--; [EOL]             default: [EOL]                 sb.append(c); [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } <line_num>: 404,439
private void seekNonWs(final String pattern, final ParsePosition pos) { [EOL]     int len = 0; [EOL]     final char[] buffer = pattern.toCharArray(); [EOL]     do { [EOL]         len = StrMatcher.splitMatcher().isMatch(buffer, pos.getIndex()); [EOL]         pos.setIndex(pos.getIndex() + len); [EOL]     } while (len > 0 && pos.getIndex() < pattern.length()); [EOL] } <line_num>: 447,454
private ParsePosition next(final ParsePosition pos) { [EOL]     pos.setIndex(pos.getIndex() + 1); [EOL]     return pos; [EOL] } <line_num>: 462,465
private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos, final StringBuilder appendTo, final boolean escapingOn) { [EOL]     final int start = pos.getIndex(); [EOL]     final char[] c = pattern.toCharArray(); [EOL]     if (escapingOn && c[start] == QUOTE) { [EOL]         next(pos); [EOL]         return appendTo == null ? null : appendTo.append(QUOTE); [EOL]     } [EOL]     int lastHold = start; [EOL]     for (int i = pos.getIndex(); i < pattern.length(); i++) { [EOL]         if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { [EOL]             appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(QUOTE); [EOL]             pos.setIndex(i + ESCAPED_QUOTE.length()); [EOL]             lastHold = pos.getIndex(); [EOL]             continue; [EOL]         } [EOL]         switch(c[pos.getIndex()]) { [EOL]             case QUOTE: [EOL]                 next(pos); [EOL]                 return appendTo == null ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); [EOL]             default: [EOL]                 next(pos); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("Unterminated quoted string at position " + start); [EOL] } <line_num>: 477,505
private void getQuotedString(final String pattern, final ParsePosition pos, final boolean escapingOn) { [EOL]     appendQuotedString(pattern, pos, null, escapingOn); [EOL] } <line_num>: 514,517
private boolean containsElements(final Collection<?> coll) { [EOL]     if (coll == null || coll.isEmpty()) { [EOL]         return false; [EOL]     } [EOL]     for (final Object name : coll) { [EOL]         if (name != null) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 524,534
