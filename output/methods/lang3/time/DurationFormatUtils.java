public DurationFormatUtils() { [EOL]     super(); [EOL] } <line_num>: 52,54
Token(final Object value) { [EOL]     this.value = value; [EOL]     this.count = 1; [EOL] } <line_num>: 586,589
Token(final Object value, final int count) { [EOL]     this.value = value; [EOL]     this.count = count; [EOL] } <line_num>: 598,601
public static String formatDurationHMS(final long durationMillis) { [EOL]     return formatDuration(durationMillis, "H:mm:ss.SSS"); [EOL] } <line_num>: 75,77
public static String formatDurationISO(final long durationMillis) { [EOL]     return formatDuration(durationMillis, ISO_EXTENDED_FORMAT_PATTERN, false); [EOL] } <line_num>: 90,92
public static String formatDuration(final long durationMillis, final String format) { [EOL]     return formatDuration(durationMillis, format, true); [EOL] } <line_num>: 105,107
public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) { [EOL]     final Token[] tokens = lexx(format); [EOL]     int days = 0; [EOL]     int hours = 0; [EOL]     int minutes = 0; [EOL]     int seconds = 0; [EOL]     int milliseconds = 0; [EOL]     if (Token.containsTokenWithValue(tokens, d)) { [EOL]         days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY); [EOL]         durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, H)) { [EOL]         hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR); [EOL]         durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, m)) { [EOL]         minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE); [EOL]         durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, s)) { [EOL]         seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND); [EOL]         durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, S)) { [EOL]         milliseconds = (int) durationMillis; [EOL]     } [EOL]     return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros); [EOL] } <line_num>: 122,153
public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) { [EOL]     String duration = formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'"); [EOL]     if (suppressLeadingZeroElements) { [EOL]         duration = " " + duration; [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 days", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]                 duration = tmp; [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 seconds", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (duration.length() != 0) { [EOL]             duration = duration.substring(1); [EOL]         } [EOL]     } [EOL]     if (suppressTrailingZeroElements) { [EOL]         String tmp = StringUtils.replaceOnce(duration, " 0 seconds", ""); [EOL]         if (tmp.length() != duration.length()) { [EOL]             duration = tmp; [EOL]             tmp = StringUtils.replaceOnce(duration, " 0 minutes", ""); [EOL]             if (tmp.length() != duration.length()) { [EOL]                 duration = tmp; [EOL]                 tmp = StringUtils.replaceOnce(duration, " 0 hours", ""); [EOL]                 if (tmp.length() != duration.length()) { [EOL]                     duration = StringUtils.replaceOnce(tmp, " 0 days", ""); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     duration = " " + duration; [EOL]     duration = StringUtils.replaceOnce(duration, " 1 seconds", " 1 second"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 hours", " 1 hour"); [EOL]     duration = StringUtils.replaceOnce(duration, " 1 days", " 1 day"); [EOL]     return duration.trim(); [EOL] } <line_num>: 166,217
public static String formatPeriodISO(final long startMillis, final long endMillis) { [EOL]     return formatPeriod(startMillis, endMillis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault()); [EOL] } <line_num>: 229,231
public static String formatPeriod(final long startMillis, final long endMillis, final String format) { [EOL]     return formatPeriod(startMillis, endMillis, format, true, TimeZone.getDefault()); [EOL] } <line_num>: 242,244
public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone) { [EOL]     final Token[] tokens = lexx(format); [EOL]     final Calendar start = Calendar.getInstance(timezone); [EOL]     start.setTime(new Date(startMillis)); [EOL]     final Calendar end = Calendar.getInstance(timezone); [EOL]     end.setTime(new Date(endMillis)); [EOL]     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND); [EOL]     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND); [EOL]     int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE); [EOL]     int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY); [EOL]     int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH); [EOL]     int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH); [EOL]     int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR); [EOL]     while (milliseconds < 0) { [EOL]         milliseconds += 1000; [EOL]         seconds -= 1; [EOL]     } [EOL]     while (seconds < 0) { [EOL]         seconds += 60; [EOL]         minutes -= 1; [EOL]     } [EOL]     while (minutes < 0) { [EOL]         minutes += 60; [EOL]         hours -= 1; [EOL]     } [EOL]     while (hours < 0) { [EOL]         hours += 24; [EOL]         days -= 1; [EOL]     } [EOL]     if (Token.containsTokenWithValue(tokens, M)) { [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         while (months < 0) { [EOL]             months += 12; [EOL]             years -= 1; [EOL]         } [EOL]         if (!Token.containsTokenWithValue(tokens, y) && years != 0) { [EOL]             while (years != 0) { [EOL]                 months += 12 * years; [EOL]                 years = 0; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (!Token.containsTokenWithValue(tokens, y)) { [EOL]             int target = end.get(Calendar.YEAR); [EOL]             if (months < 0) { [EOL]                 target -= 1; [EOL]             } [EOL]             while (start.get(Calendar.YEAR) != target) { [EOL]                 days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR); [EOL]                 if (start instanceof GregorianCalendar && start.get(Calendar.MONTH) == Calendar.FEBRUARY && start.get(Calendar.DAY_OF_MONTH) == 29) { [EOL]                     days += 1; [EOL]                 } [EOL]                 start.add(Calendar.YEAR, 1); [EOL]                 days += start.get(Calendar.DAY_OF_YEAR); [EOL]             } [EOL]             years = 0; [EOL]         } [EOL]         while (start.get(Calendar.MONTH) != end.get(Calendar.MONTH)) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]         months = 0; [EOL]         while (days < 0) { [EOL]             days += start.getActualMaximum(Calendar.DAY_OF_MONTH); [EOL]             months -= 1; [EOL]             start.add(Calendar.MONTH, 1); [EOL]         } [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, d)) { [EOL]         hours += 24 * days; [EOL]         days = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, H)) { [EOL]         minutes += 60 * hours; [EOL]         hours = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, m)) { [EOL]         seconds += 60 * minutes; [EOL]         minutes = 0; [EOL]     } [EOL]     if (!Token.containsTokenWithValue(tokens, s)) { [EOL]         milliseconds += 1000 * seconds; [EOL]         seconds = 0; [EOL]     } [EOL]     return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros); [EOL] } <line_num>: 269,397
static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds, int milliseconds, final boolean padWithZeros) { [EOL]     final StringBuilder buffer = new StringBuilder(); [EOL]     boolean lastOutputSeconds = false; [EOL]     final int sz = tokens.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final Token token = tokens[i]; [EOL]         final Object value = token.getValue(); [EOL]         final int count = token.getCount(); [EOL]         if (value instanceof StringBuilder) { [EOL]             buffer.append(value.toString()); [EOL]         } else { [EOL]             if (value == y) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == M) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == d) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == H) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == m) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes)); [EOL]                 lastOutputSeconds = false; [EOL]             } else if (value == s) { [EOL]                 buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds)); [EOL]                 lastOutputSeconds = true; [EOL]             } else if (value == S) { [EOL]                 if (lastOutputSeconds) { [EOL]                     milliseconds += 1000; [EOL]                     final String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds); [EOL]                     buffer.append(str.substring(1)); [EOL]                 } else { [EOL]                     buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds)); [EOL]                 } [EOL]                 lastOutputSeconds = false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] } <line_num>: 414,467
static Token[] lexx(final String format) { [EOL]     final char[] array = format.toCharArray(); [EOL]     final ArrayList<Token> list = new ArrayList<Token>(array.length); [EOL]     boolean inLiteral = false; [EOL]     StringBuilder buffer = null; [EOL]     Token previous = null; [EOL]     final int sz = array.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         final char ch = array[i]; [EOL]         if (inLiteral && ch != '\'') { [EOL]             buffer.append(ch); [EOL]             continue; [EOL]         } [EOL]         Object value = null; [EOL]         switch(ch) { [EOL]             case '\'': [EOL]                 if (inLiteral) { [EOL]                     buffer = null; [EOL]                     inLiteral = false; [EOL]                 } else { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                     inLiteral = true; [EOL]                 } [EOL]                 break; [EOL]             case 'y': [EOL]                 value = y; [EOL]                 break; [EOL]             case 'M': [EOL]                 value = M; [EOL]                 break; [EOL]             case 'd': [EOL]                 value = d; [EOL]                 break; [EOL]             case 'H': [EOL]                 value = H; [EOL]                 break; [EOL]             case 'm': [EOL]                 value = m; [EOL]                 break; [EOL]             case 's': [EOL]                 value = s; [EOL]                 break; [EOL]             case 'S': [EOL]                 value = S; [EOL]                 break; [EOL]             default: [EOL]                 if (buffer == null) { [EOL]                     buffer = new StringBuilder(); [EOL]                     list.add(new Token(buffer)); [EOL]                 } [EOL]                 buffer.append(ch); [EOL]         } [EOL]         if (value != null) { [EOL]             if (previous != null && previous.getValue() == value) { [EOL]                 previous.increment(); [EOL]             } else { [EOL]                 final Token token = new Token(value); [EOL]                 list.add(token); [EOL]                 previous = token; [EOL]             } [EOL]             buffer = null; [EOL]         } [EOL]     } [EOL]     return list.toArray(new Token[list.size()]); [EOL] } <line_num>: 483,553
static boolean containsTokenWithValue(final Token[] tokens, final Object value) { [EOL]     final int sz = tokens.length; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         if (tokens[i].getValue() == value) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 568,576
void increment() { [EOL]     count++; [EOL] } <line_num>: 606,608
int getCount() { [EOL]     return count; [EOL] } <line_num>: 615,617
Object getValue() { [EOL]     return value; [EOL] } <line_num>: 624,626
@Override [EOL] public boolean equals(final Object obj2) { [EOL]     if (obj2 instanceof Token) { [EOL]         final Token tok2 = (Token) obj2; [EOL]         if (this.value.getClass() != tok2.value.getClass()) { [EOL]             return false; [EOL]         } [EOL]         if (this.count != tok2.count) { [EOL]             return false; [EOL]         } [EOL]         if (this.value instanceof StringBuilder) { [EOL]             return this.value.toString().equals(tok2.value.toString()); [EOL]         } else if (this.value instanceof Number) { [EOL]             return this.value.equals(tok2.value); [EOL]         } else { [EOL]             return this.value == tok2.value; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 634,653
@Override [EOL] public int hashCode() { [EOL]     return this.value.hashCode(); [EOL] } <line_num>: 662,665
@Override [EOL] public String toString() { [EOL]     return StringUtils.repeat(this.value.toString(), this.count); [EOL] } <line_num>: 672,675
