public TypeUtils() { [EOL]     super(); [EOL] } <line_num>: 50,52
public static boolean isAssignable(final Type type, final Type toType) { [EOL]     return isAssignable(type, toType, null); [EOL] } <line_num>: 64,66
private static boolean isAssignable(final Type type, final Type toType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (toType == null || toType instanceof Class<?>) { [EOL]         return isAssignable(type, (Class<?>) toType); [EOL]     } [EOL]     if (toType instanceof ParameterizedType) { [EOL]         return isAssignable(type, (ParameterizedType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof GenericArrayType) { [EOL]         return isAssignable(type, (GenericArrayType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof WildcardType) { [EOL]         return isAssignable(type, (WildcardType) toType, typeVarAssigns); [EOL]     } [EOL]     if (toType instanceof TypeVariable<?>) { [EOL]         return isAssignable(type, (TypeVariable<?>) toType, typeVarAssigns); [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + toType); [EOL] } <line_num>: 77,102
private static boolean isAssignable(final Type type, final Class<?> toClass) { [EOL]     if (type == null) { [EOL]         return toClass == null || !toClass.isPrimitive(); [EOL]     } [EOL]     if (toClass == null) { [EOL]         return false; [EOL]     } [EOL]     if (toClass.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     if (type instanceof Class<?>) { [EOL]         return ClassUtils.isAssignable((Class<?>) type, toClass); [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return isAssignable(getRawType((ParameterizedType) type), toClass); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : ((TypeVariable<?>) type).getBounds()) { [EOL]             if (isAssignable(bound, toClass)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return toClass.equals(Object.class) || toClass.isArray() && isAssignable(((GenericArrayType) type).getGenericComponentType(), toClass.getComponentType()); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] } <line_num>: 112,168
private static boolean isAssignable(final Type type, final ParameterizedType toParameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toParameterizedType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toParameterizedType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Class<?> toClass = getRawType(toParameterizedType); [EOL]     final Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null); [EOL]     if (fromTypeVarAssigns == null) { [EOL]         return false; [EOL]     } [EOL]     if (fromTypeVarAssigns.isEmpty()) { [EOL]         return true; [EOL]     } [EOL]     final Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType, toClass, typeVarAssigns); [EOL]     for (final TypeVariable<?> var : toTypeVarAssigns.keySet()) { [EOL]         final Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns); [EOL]         final Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns); [EOL]         if (fromTypeArg != null && !toTypeArg.equals(fromTypeArg) && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg, typeVarAssigns))) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 179,235
private static Type unrollVariableAssignments(TypeVariable<?> var, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     Type result; [EOL]     do { [EOL]         result = typeVarAssigns.get(var); [EOL]         if (result instanceof TypeVariable<?> && !result.equals(var)) { [EOL]             var = (TypeVariable<?>) result; [EOL]             continue; [EOL]         } [EOL]         break; [EOL]     } while (true); [EOL]     return result; [EOL] } <line_num>: 237,248
private static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toGenericArrayType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toGenericArrayType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type toComponentType = toGenericArrayType.getGenericComponentType(); [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> cls = (Class<?>) type; [EOL]         return cls.isArray() && isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return isAssignable(((GenericArrayType) type).getGenericComponentType(), toComponentType, typeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toGenericArrayType)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] } <line_num>: 260,324
private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toWildcardType == null) { [EOL]         return false; [EOL]     } [EOL]     if (toWildcardType.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType); [EOL]     final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType); [EOL]     if (type instanceof WildcardType) { [EOL]         final WildcardType wildcardType = (WildcardType) type; [EOL]         final Type[] upperBounds = getImplicitUpperBounds(wildcardType); [EOL]         final Type[] lowerBounds = getImplicitLowerBounds(wildcardType); [EOL]         for (Type toBound : toUpperBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : upperBounds) { [EOL]                 if (!isAssignable(bound, toBound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (Type toBound : toLowerBounds) { [EOL]             toBound = substituteTypeVariables(toBound, typeVarAssigns); [EOL]             for (final Type bound : lowerBounds) { [EOL]                 if (!isAssignable(toBound, bound, typeVarAssigns)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     for (final Type toBound : toUpperBounds) { [EOL]         if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (final Type toBound : toLowerBounds) { [EOL]         if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 336,413
private static boolean isAssignable(final Type type, final TypeVariable<?> toTypeVariable, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type == null) { [EOL]         return true; [EOL]     } [EOL]     if (toTypeVariable == null) { [EOL]         return false; [EOL]     } [EOL]     if (toTypeVariable.equals(type)) { [EOL]         return true; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         final Type[] bounds = getImplicitBounds((TypeVariable<?>) type); [EOL]         for (final Type bound : bounds) { [EOL]             if (isAssignable(bound, toTypeVariable, typeVarAssigns)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (type instanceof Class<?> || type instanceof ParameterizedType || type instanceof GenericArrayType || type instanceof WildcardType) { [EOL]         return false; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] } <line_num>: 425,461
private static Type substituteTypeVariables(final Type type, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     if (type instanceof TypeVariable<?> && typeVarAssigns != null) { [EOL]         final Type replacementType = typeVarAssigns.get(type); [EOL]         if (replacementType == null) { [EOL]             throw new IllegalArgumentException("missing assignment type for type variable " + type); [EOL]         } [EOL]         return replacementType; [EOL]     } [EOL]     return type; [EOL] } <line_num>: 471,484
public static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType type) { [EOL]     return getTypeArguments(type, getRawType(type), null); [EOL] } <line_num>: 497,499
public static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass) { [EOL]     return getTypeArguments(type, toClass, null); [EOL] } <line_num>: 533,535
private static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL]     if (type instanceof Class<?>) { [EOL]         return getTypeArguments((Class<?>) type, toClass, subtypeVarAssigns); [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getTypeArguments((ParameterizedType) type, toClass, subtypeVarAssigns); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return getTypeArguments(((GenericArrayType) type).getGenericComponentType(), toClass.isArray() ? toClass.getComponentType() : toClass, subtypeVarAssigns); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         for (final Type bound : getImplicitUpperBounds((WildcardType) type)) { [EOL]             if (isAssignable(bound, toClass)) { [EOL]                 return getTypeArguments(bound, toClass, subtypeVarAssigns); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) { [EOL]             if (isAssignable(bound, toClass)) { [EOL]                 return getTypeArguments(bound, toClass, subtypeVarAssigns); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     throw new IllegalStateException("found an unhandled type: " + type); [EOL] } <line_num>: 545,587
private static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType parameterizedType, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL]     final Class<?> cls = getRawType(parameterizedType); [EOL]     if (!isAssignable(cls, toClass)) { [EOL]         return null; [EOL]     } [EOL]     final Type ownerType = parameterizedType.getOwnerType(); [EOL]     Map<TypeVariable<?>, Type> typeVarAssigns; [EOL]     if (ownerType instanceof ParameterizedType) { [EOL]         final ParameterizedType parameterizedOwnerType = (ParameterizedType) ownerType; [EOL]         typeVarAssigns = getTypeArguments(parameterizedOwnerType, getRawType(parameterizedOwnerType), subtypeVarAssigns); [EOL]     } else { [EOL]         typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns); [EOL]     } [EOL]     final Type[] typeArgs = parameterizedType.getActualTypeArguments(); [EOL]     final TypeVariable<?>[] typeParams = cls.getTypeParameters(); [EOL]     for (int i = 0; i < typeParams.length; i++) { [EOL]         final Type typeArg = typeArgs[i]; [EOL]         typeVarAssigns.put(typeParams[i], typeVarAssigns.containsKey(typeArg) ? typeVarAssigns.get(typeArg) : typeArg); [EOL]     } [EOL]     if (toClass.equals(cls)) { [EOL]         return typeVarAssigns; [EOL]     } [EOL]     return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns); [EOL] } <line_num>: 597,640
private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns) { [EOL]     if (!isAssignable(cls, toClass)) { [EOL]         return null; [EOL]     } [EOL]     if (cls.isPrimitive()) { [EOL]         if (toClass.isPrimitive()) { [EOL]             return new HashMap<TypeVariable<?>, Type>(); [EOL]         } [EOL]         cls = ClassUtils.primitiveToWrapper(cls); [EOL]     } [EOL]     final HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns); [EOL]     if (toClass.equals(cls)) { [EOL]         return typeVarAssigns; [EOL]     } [EOL]     return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns); [EOL] } <line_num>: 650,681
public static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls, final ParameterizedType superType) { [EOL]     final Class<?> superClass = getRawType(superType); [EOL]     if (!isAssignable(cls, superClass)) { [EOL]         return null; [EOL]     } [EOL]     if (cls.equals(superClass)) { [EOL]         return getTypeArguments(superType, superClass, null); [EOL]     } [EOL]     final Type midType = getClosestParentType(cls, superClass); [EOL]     if (midType instanceof Class<?>) { [EOL]         return determineTypeArguments((Class<?>) midType, superType); [EOL]     } [EOL]     final ParameterizedType midParameterizedType = (ParameterizedType) midType; [EOL]     final Class<?> midClass = getRawType(midParameterizedType); [EOL]     final Map<TypeVariable<?>, Type> typeVarAssigns = determineTypeArguments(midClass, superType); [EOL]     mapTypeVariablesToArguments(cls, midParameterizedType, typeVarAssigns); [EOL]     return typeVarAssigns; [EOL] } <line_num>: 710,740
private static <T> void mapTypeVariablesToArguments(final Class<T> cls, final ParameterizedType parameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     final Type ownerType = parameterizedType.getOwnerType(); [EOL]     if (ownerType instanceof ParameterizedType) { [EOL]         mapTypeVariablesToArguments(cls, (ParameterizedType) ownerType, typeVarAssigns); [EOL]     } [EOL]     final Type[] typeArgs = parameterizedType.getActualTypeArguments(); [EOL]     final TypeVariable<?>[] typeVars = getRawType(parameterizedType).getTypeParameters(); [EOL]     final List<TypeVariable<Class<T>>> typeVarList = Arrays.asList(cls.getTypeParameters()); [EOL]     for (int i = 0; i < typeArgs.length; i++) { [EOL]         final TypeVariable<?> typeVar = typeVars[i]; [EOL]         final Type typeArg = typeArgs[i]; [EOL]         if (typeVarList.contains(typeArg) && typeVarAssigns.containsKey(typeVar)) { [EOL]             typeVarAssigns.put((TypeVariable<?>) typeArg, typeVarAssigns.get(typeVar)); [EOL]         } [EOL]     } [EOL] } <line_num>: 750,787
private static Type getClosestParentType(final Class<?> cls, final Class<?> superClass) { [EOL]     if (superClass.isInterface()) { [EOL]         final Type[] interfaceTypes = cls.getGenericInterfaces(); [EOL]         Type genericInterface = null; [EOL]         for (final Type midType : interfaceTypes) { [EOL]             Class<?> midClass = null; [EOL]             if (midType instanceof ParameterizedType) { [EOL]                 midClass = getRawType((ParameterizedType) midType); [EOL]             } else if (midType instanceof Class<?>) { [EOL]                 midClass = (Class<?>) midType; [EOL]             } else { [EOL]                 throw new IllegalStateException("Unexpected generic" + " interface type found: " + midType); [EOL]             } [EOL]             if (isAssignable(midClass, superClass) && isAssignable(genericInterface, (Type) midClass)) { [EOL]                 genericInterface = midType; [EOL]             } [EOL]         } [EOL]         if (genericInterface != null) { [EOL]             return genericInterface; [EOL]         } [EOL]     } [EOL]     return cls.getGenericSuperclass(); [EOL] } <line_num>: 797,835
public static boolean isInstance(final Object value, final Type type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     return value == null ? !(type instanceof Class<?>) || !((Class<?>) type).isPrimitive() : isAssignable(value.getClass(), type, null); [EOL] } <line_num>: 845,852
public static Type[] normalizeUpperBounds(final Type[] bounds) { [EOL]     if (bounds.length < 2) { [EOL]         return bounds; [EOL]     } [EOL]     final Set<Type> types = new HashSet<Type>(bounds.length); [EOL]     for (final Type type1 : bounds) { [EOL]         boolean subtypeFound = false; [EOL]         for (final Type type2 : bounds) { [EOL]             if (type1 != type2 && isAssignable(type2, type1, null)) { [EOL]                 subtypeFound = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (!subtypeFound) { [EOL]             types.add(type1); [EOL]         } [EOL]     } [EOL]     return types.toArray(new Type[types.size()]); [EOL] } <line_num>: 875,899
public static Type[] getImplicitBounds(final TypeVariable<?> typeVariable) { [EOL]     final Type[] bounds = typeVariable.getBounds(); [EOL]     return bounds.length == 0 ? new Type[] { Object.class } : normalizeUpperBounds(bounds); [EOL] } <line_num>: 910,914
public static Type[] getImplicitUpperBounds(final WildcardType wildcardType) { [EOL]     final Type[] bounds = wildcardType.getUpperBounds(); [EOL]     return bounds.length == 0 ? new Type[] { Object.class } : normalizeUpperBounds(bounds); [EOL] } <line_num>: 926,930
public static Type[] getImplicitLowerBounds(final WildcardType wildcardType) { [EOL]     final Type[] bounds = wildcardType.getLowerBounds(); [EOL]     return bounds.length == 0 ? new Type[] { null } : bounds; [EOL] } <line_num>: 941,945
public static boolean typesSatisfyVariables(final Map<TypeVariable<?>, Type> typeVarAssigns) { [EOL]     for (final Map.Entry<TypeVariable<?>, Type> entry : typeVarAssigns.entrySet()) { [EOL]         final TypeVariable<?> typeVar = entry.getKey(); [EOL]         final Type type = entry.getValue(); [EOL]         for (final Type bound : getImplicitBounds(typeVar)) { [EOL]             if (!isAssignable(type, substituteTypeVariables(bound, typeVarAssigns), typeVarAssigns)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 960,976
private static Class<?> getRawType(final ParameterizedType parameterizedType) { [EOL]     final Type rawType = parameterizedType.getRawType(); [EOL]     if (!(rawType instanceof Class<?>)) { [EOL]         throw new IllegalStateException("Wait... What!? Type of rawType: " + rawType); [EOL]     } [EOL]     return (Class<?>) rawType; [EOL] } <line_num>: 985,998
public static Class<?> getRawType(final Type type, final Type assigningType) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } [EOL]     if (type instanceof ParameterizedType) { [EOL]         return getRawType((ParameterizedType) type); [EOL]     } [EOL]     if (type instanceof TypeVariable<?>) { [EOL]         if (assigningType == null) { [EOL]             return null; [EOL]         } [EOL]         final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration(); [EOL]         if (!(genericDeclaration instanceof Class<?>)) { [EOL]             return null; [EOL]         } [EOL]         final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration); [EOL]         if (typeVarAssigns == null) { [EOL]             return null; [EOL]         } [EOL]         final Type typeArgument = typeVarAssigns.get(type); [EOL]         if (typeArgument == null) { [EOL]             return null; [EOL]         } [EOL]         return getRawType(typeArgument, assigningType); [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType); [EOL]         return Array.newInstance(rawComponentType, 0).getClass(); [EOL]     } [EOL]     if (type instanceof WildcardType) { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("unknown type: " + type); [EOL] } <line_num>: 1012,1074
public static boolean isArrayType(final Type type) { [EOL]     return type instanceof GenericArrayType || type instanceof Class<?> && ((Class<?>) type).isArray(); [EOL] } <line_num>: 1081,1083
public static Type getArrayComponentType(final Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         final Class<?> clazz = (Class<?>) type; [EOL]         return clazz.isArray() ? clazz.getComponentType() : null; [EOL]     } [EOL]     if (type instanceof GenericArrayType) { [EOL]         return ((GenericArrayType) type).getGenericComponentType(); [EOL]     } [EOL]     return null; [EOL] } <line_num>: 1090,1099
