@Override [EOL] public StaticSlot<JSType> getSlot(String name) { [EOL]     if ("goog".equals(name)) { [EOL]         return new SimpleSlot("goog", googObject, false); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] } <line_num>: 158,165
@Override [EOL] protected void setUp() throws Exception { [EOL]     super.setUp(); [EOL]     RecordTypeBuilder builder = new RecordTypeBuilder(registry); [EOL]     builder.addProperty("a", NUMBER_TYPE, null); [EOL]     builder.addProperty("b", STRING_TYPE, null); [EOL]     recordType = builder.build(); [EOL]     enumType = new EnumType(registry, "Enum", null, NUMBER_TYPE); [EOL]     elementsType = enumType.getElementsType(); [EOL]     functionType = new FunctionBuilder(registry).withReturnType(NUMBER_TYPE).build(); [EOL]     dateMethod = new FunctionBuilder(registry).withParamsNode(new Node(Token.PARAM_LIST)).withReturnType(NUMBER_TYPE).withTypeOfThis(DATE_TYPE).build(); [EOL]     unresolvedNamedType = new NamedType(registry, "not.resolved.named.type", null, -1, -1); [EOL]     namedGoogBar = new NamedType(registry, "goog.Bar", null, -1, -1); [EOL]     subclassCtor = new FunctionType(registry, null, null, createArrowType(null), null, null, true, false); [EOL]     subclassCtor.setPrototypeBasedOn(unresolvedNamedType); [EOL]     subclassOfUnresolvedNamedType = subclassCtor.getInstanceType(); [EOL]     interfaceType = FunctionType.forInterface(registry, "Interface", null); [EOL]     interfaceInstType = interfaceType.getInstanceType(); [EOL]     subInterfaceType = FunctionType.forInterface(registry, "SubInterface", null); [EOL]     subInterfaceType.setExtendedInterfaces(Lists.<ObjectType>newArrayList(interfaceInstType)); [EOL]     subInterfaceInstType = subInterfaceType.getInstanceType(); [EOL]     googBar = registry.createConstructorType("goog.Bar", null, null, null, null); [EOL]     googBar.getPrototype().defineDeclaredProperty("date", DATE_TYPE, null); [EOL]     googBar.setImplementedInterfaces(Lists.<ObjectType>newArrayList(interfaceInstType)); [EOL]     googBarInst = googBar.getInstanceType(); [EOL]     googSubBar = registry.createConstructorType("googSubBar", null, null, null, null); [EOL]     googSubBar.setPrototypeBasedOn(googBar.getInstanceType()); [EOL]     googSubBarInst = googSubBar.getInstanceType(); [EOL]     googSubSubBar = registry.createConstructorType("googSubSubBar", null, null, null, null); [EOL]     googSubSubBar.setPrototypeBasedOn(googSubBar.getInstanceType()); [EOL]     googSubSubBarInst = googSubSubBar.getInstanceType(); [EOL]     final ObjectType googObject = registry.createAnonymousObjectType(null); [EOL]     googObject.defineDeclaredProperty("Bar", googBar, null); [EOL]     namedGoogBar.resolve(null, new AbstractStaticScope<JSType>() { [EOL]  [EOL]         @Override [EOL]         public StaticSlot<JSType> getSlot(String name) { [EOL]             if ("goog".equals(name)) { [EOL]                 return new SimpleSlot("goog", googObject, false); [EOL]             } else { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]     }); [EOL]     assertNotNull(namedGoogBar.getImplicitPrototype()); [EOL]     forwardDeclaredNamedType = new NamedType(registry, "forwardDeclared", "source", 1, 0); [EOL]     registry.forwardDeclareType("forwardDeclared"); [EOL]     forwardDeclaredNamedType.resolve(new SimpleErrorReporter(), EMPTY_SCOPE); [EOL]     types = ImmutableList.of(NO_OBJECT_TYPE, NO_RESOLVED_TYPE, NO_TYPE, BOOLEAN_OBJECT_TYPE, BOOLEAN_TYPE, STRING_OBJECT_TYPE, STRING_TYPE, VOID_TYPE, UNKNOWN_TYPE, NULL_TYPE, NUMBER_OBJECT_TYPE, NUMBER_TYPE, DATE_TYPE, ERROR_TYPE, SYNTAX_ERROR_TYPE, dateMethod, functionType, unresolvedNamedType, googBar, googSubBar, googSubSubBar, namedGoogBar, googBar.getInstanceType(), subclassOfUnresolvedNamedType, subclassCtor, recordType, enumType, elementsType, googBar, googSubBar, forwardDeclaredNamedType); [EOL] } <line_num>: 98,207
public void testUniversalConstructorType() throws Exception { [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isNoObjectType()); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isNoType()); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isArrayType()); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isBooleanValueType()); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isDateType()); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isEnumElementType()); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isNullType()); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isNamedType()); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isNullType()); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isNumber()); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isNumberObjectType()); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isNumberValueType()); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.isObject()); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isFunctionPrototypeType()); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isRegexpType()); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isString()); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isStringObjectType()); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isStringValueType()); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isEnumType()); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isUnionType()); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isStruct()); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isDict()); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isAllType()); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isVoidType()); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.isConstructor()); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.isInstanceType()); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(NO_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(NO_OBJECT_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(ARRAY_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(BOOLEAN_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(DATE_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(ERROR_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(EVAL_ERROR_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(functionType)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(recordType)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(NULL_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(NUMBER_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(NUMBER_OBJECT_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(OBJECT_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(URI_ERROR_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(RANGE_ERROR_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(REFERENCE_ERROR_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(REGEXP_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(STRING_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(SYNTAX_ERROR_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(TYPE_ERROR_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(ALL_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(VOID_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.canTestForEqualityWith(NO_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.canTestForEqualityWith(NO_OBJECT_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.canTestForEqualityWith(ALL_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.canTestForEqualityWith(ARRAY_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.canTestForEqualityWith(BOOLEAN_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.canTestForEqualityWith(BOOLEAN_OBJECT_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.canTestForEqualityWith(DATE_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.canTestForEqualityWith(ERROR_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.canTestForEqualityWith(EVAL_ERROR_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.canTestForEqualityWith(functionType)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.canTestForEqualityWith(recordType)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.canTestForEqualityWith(NULL_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.canTestForEqualityWith(NUMBER_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.canTestForEqualityWith(NUMBER_OBJECT_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.canTestForEqualityWith(OBJECT_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.canTestForEqualityWith(URI_ERROR_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.canTestForEqualityWith(RANGE_ERROR_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.canTestForEqualityWith(REFERENCE_ERROR_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.canTestForEqualityWith(REGEXP_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.canTestForEqualityWith(STRING_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.canTestForEqualityWith(STRING_OBJECT_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.canTestForEqualityWith(SYNTAX_ERROR_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.canTestForEqualityWith(TYPE_ERROR_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.canTestForEqualityWith(VOID_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.canTestForShallowEqualityWith(NO_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.canTestForShallowEqualityWith(functionType)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.canTestForShallowEqualityWith(recordType)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.isNullable()); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.isObject()); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.matchesInt32Context()); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.matchesNumberContext()); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.matchesObjectContext()); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.matchesStringContext()); [EOL]     assertFalse(U2U_CONSTRUCTOR_TYPE.matchesUint32Context()); [EOL]     assertEquals("Function", U2U_CONSTRUCTOR_TYPE.toString()); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.hasDisplayName()); [EOL]     assertEquals("Function", U2U_CONSTRUCTOR_TYPE.getDisplayName()); [EOL]     assertTypeEquals(UNKNOWN_TYPE, U2U_CONSTRUCTOR_TYPE.getPropertyType("anyProperty")); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.isNativeObjectType()); [EOL]     Asserts.assertResolvesToSame(U2U_CONSTRUCTOR_TYPE); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.isNominalConstructor()); [EOL] } <line_num>: 212,395
public void testNoObjectType() throws Exception { [EOL]     assertTrue(NO_OBJECT_TYPE.isNoObjectType()); [EOL]     assertFalse(NO_OBJECT_TYPE.isNoType()); [EOL]     assertFalse(NO_OBJECT_TYPE.isArrayType()); [EOL]     assertFalse(NO_OBJECT_TYPE.isBooleanValueType()); [EOL]     assertFalse(NO_OBJECT_TYPE.isDateType()); [EOL]     assertFalse(NO_OBJECT_TYPE.isEnumElementType()); [EOL]     assertFalse(NO_OBJECT_TYPE.isNullType()); [EOL]     assertFalse(NO_OBJECT_TYPE.isNamedType()); [EOL]     assertFalse(NO_OBJECT_TYPE.isNullType()); [EOL]     assertTrue(NO_OBJECT_TYPE.isNumber()); [EOL]     assertFalse(NO_OBJECT_TYPE.isNumberObjectType()); [EOL]     assertFalse(NO_OBJECT_TYPE.isNumberValueType()); [EOL]     assertTrue(NO_OBJECT_TYPE.isObject()); [EOL]     assertFalse(NO_OBJECT_TYPE.isFunctionPrototypeType()); [EOL]     assertFalse(NO_OBJECT_TYPE.isRegexpType()); [EOL]     assertTrue(NO_OBJECT_TYPE.isString()); [EOL]     assertFalse(NO_OBJECT_TYPE.isStringObjectType()); [EOL]     assertFalse(NO_OBJECT_TYPE.isStringValueType()); [EOL]     assertFalse(NO_OBJECT_TYPE.isEnumType()); [EOL]     assertFalse(NO_OBJECT_TYPE.isUnionType()); [EOL]     assertFalse(NO_OBJECT_TYPE.isStruct()); [EOL]     assertFalse(NO_OBJECT_TYPE.isDict()); [EOL]     assertFalse(NO_OBJECT_TYPE.isAllType()); [EOL]     assertFalse(NO_OBJECT_TYPE.isVoidType()); [EOL]     assertTrue(NO_OBJECT_TYPE.isConstructor()); [EOL]     assertFalse(NO_OBJECT_TYPE.isInstanceType()); [EOL]     assertFalse(NO_OBJECT_TYPE.isSubtype(NO_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(NO_OBJECT_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(ARRAY_TYPE)); [EOL]     assertFalse(NO_OBJECT_TYPE.isSubtype(BOOLEAN_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(DATE_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(ERROR_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(EVAL_ERROR_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(functionType)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(recordType)); [EOL]     assertFalse(NO_OBJECT_TYPE.isSubtype(NULL_TYPE)); [EOL]     assertFalse(NO_OBJECT_TYPE.isSubtype(NUMBER_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(NUMBER_OBJECT_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(OBJECT_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(URI_ERROR_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(RANGE_ERROR_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(REFERENCE_ERROR_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(REGEXP_TYPE)); [EOL]     assertFalse(NO_OBJECT_TYPE.isSubtype(STRING_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(SYNTAX_ERROR_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(TYPE_ERROR_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(ALL_TYPE)); [EOL]     assertFalse(NO_OBJECT_TYPE.isSubtype(VOID_TYPE)); [EOL]     assertCannotTestForEqualityWith(NO_OBJECT_TYPE, NO_TYPE); [EOL]     assertCannotTestForEqualityWith(NO_OBJECT_TYPE, NO_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(NO_OBJECT_TYPE, ALL_TYPE); [EOL]     assertCanTestForEqualityWith(NO_OBJECT_TYPE, ARRAY_TYPE); [EOL]     assertCanTestForEqualityWith(NO_OBJECT_TYPE, BOOLEAN_TYPE); [EOL]     assertCanTestForEqualityWith(NO_OBJECT_TYPE, BOOLEAN_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(NO_OBJECT_TYPE, DATE_TYPE); [EOL]     assertCanTestForEqualityWith(NO_OBJECT_TYPE, ERROR_TYPE); [EOL]     assertCanTestForEqualityWith(NO_OBJECT_TYPE, EVAL_ERROR_TYPE); [EOL]     assertCanTestForEqualityWith(NO_OBJECT_TYPE, functionType); [EOL]     assertCanTestForEqualityWith(NO_OBJECT_TYPE, recordType); [EOL]     assertCanTestForEqualityWith(NO_OBJECT_TYPE, NULL_TYPE); [EOL]     assertCanTestForEqualityWith(NO_OBJECT_TYPE, NUMBER_TYPE); [EOL]     assertCanTestForEqualityWith(NO_OBJECT_TYPE, NUMBER_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(NO_OBJECT_TYPE, OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(NO_OBJECT_TYPE, URI_ERROR_TYPE); [EOL]     assertCanTestForEqualityWith(NO_OBJECT_TYPE, RANGE_ERROR_TYPE); [EOL]     assertCanTestForEqualityWith(NO_OBJECT_TYPE, REFERENCE_ERROR_TYPE); [EOL]     assertCanTestForEqualityWith(NO_OBJECT_TYPE, REGEXP_TYPE); [EOL]     assertCanTestForEqualityWith(NO_OBJECT_TYPE, STRING_TYPE); [EOL]     assertCanTestForEqualityWith(NO_OBJECT_TYPE, STRING_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(NO_OBJECT_TYPE, SYNTAX_ERROR_TYPE); [EOL]     assertCanTestForEqualityWith(NO_OBJECT_TYPE, TYPE_ERROR_TYPE); [EOL]     assertCanTestForEqualityWith(NO_OBJECT_TYPE, VOID_TYPE); [EOL]     assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(NO_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); [EOL]     assertFalse(NO_OBJECT_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(functionType)); [EOL]     assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(recordType)); [EOL]     assertFalse(NO_OBJECT_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); [EOL]     assertFalse(NO_OBJECT_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); [EOL]     assertFalse(NO_OBJECT_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); [EOL]     assertFalse(NO_OBJECT_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); [EOL]     assertFalse(NO_OBJECT_TYPE.isNullable()); [EOL]     assertTrue(NO_OBJECT_TYPE.isObject()); [EOL]     assertTrue(NO_OBJECT_TYPE.matchesInt32Context()); [EOL]     assertTrue(NO_OBJECT_TYPE.matchesNumberContext()); [EOL]     assertTrue(NO_OBJECT_TYPE.matchesObjectContext()); [EOL]     assertTrue(NO_OBJECT_TYPE.matchesStringContext()); [EOL]     assertTrue(NO_OBJECT_TYPE.matchesUint32Context()); [EOL]     assertEquals("NoObject", NO_OBJECT_TYPE.toString()); [EOL]     assertFalse(NO_OBJECT_TYPE.hasDisplayName()); [EOL]     assertEquals(null, NO_OBJECT_TYPE.getDisplayName()); [EOL]     assertTypeEquals(NO_TYPE, NO_OBJECT_TYPE.getPropertyType("anyProperty")); [EOL]     Asserts.assertResolvesToSame(NO_OBJECT_TYPE); [EOL]     assertFalse(NO_OBJECT_TYPE.isNominalConstructor()); [EOL] } <line_num>: 400,538
public void testNoType() throws Exception { [EOL]     assertFalse(NO_TYPE.isNoObjectType()); [EOL]     assertTrue(NO_TYPE.isNoType()); [EOL]     assertFalse(NO_TYPE.isArrayType()); [EOL]     assertFalse(NO_TYPE.isBooleanValueType()); [EOL]     assertFalse(NO_TYPE.isDateType()); [EOL]     assertFalse(NO_TYPE.isEnumElementType()); [EOL]     assertFalse(NO_TYPE.isNullType()); [EOL]     assertFalse(NO_TYPE.isNamedType()); [EOL]     assertFalse(NO_TYPE.isNullType()); [EOL]     assertTrue(NO_TYPE.isNumber()); [EOL]     assertFalse(NO_TYPE.isNumberObjectType()); [EOL]     assertFalse(NO_TYPE.isNumberValueType()); [EOL]     assertTrue(NO_TYPE.isObject()); [EOL]     assertFalse(NO_TYPE.isFunctionPrototypeType()); [EOL]     assertFalse(NO_TYPE.isRegexpType()); [EOL]     assertTrue(NO_TYPE.isString()); [EOL]     assertFalse(NO_TYPE.isStringObjectType()); [EOL]     assertFalse(NO_TYPE.isStringValueType()); [EOL]     assertFalse(NO_TYPE.isEnumType()); [EOL]     assertFalse(NO_TYPE.isUnionType()); [EOL]     assertFalse(NO_TYPE.isStruct()); [EOL]     assertFalse(NO_TYPE.isDict()); [EOL]     assertFalse(NO_TYPE.isAllType()); [EOL]     assertFalse(NO_TYPE.isVoidType()); [EOL]     assertTrue(NO_TYPE.isConstructor()); [EOL]     assertFalse(NO_TYPE.isInstanceType()); [EOL]     assertTrue(NO_TYPE.isSubtype(NO_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(NO_OBJECT_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(ARRAY_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(BOOLEAN_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(DATE_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(ERROR_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(EVAL_ERROR_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(functionType)); [EOL]     assertTrue(NO_TYPE.isSubtype(NULL_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(NUMBER_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(NUMBER_OBJECT_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(OBJECT_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(URI_ERROR_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(RANGE_ERROR_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(REFERENCE_ERROR_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(REGEXP_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(STRING_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(SYNTAX_ERROR_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(TYPE_ERROR_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(ALL_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(VOID_TYPE)); [EOL]     assertCannotTestForEqualityWith(NO_TYPE, NO_TYPE); [EOL]     assertCannotTestForEqualityWith(NO_TYPE, NO_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(NO_TYPE, ARRAY_TYPE); [EOL]     assertCanTestForEqualityWith(NO_TYPE, BOOLEAN_TYPE); [EOL]     assertCanTestForEqualityWith(NO_TYPE, BOOLEAN_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(NO_TYPE, DATE_TYPE); [EOL]     assertCanTestForEqualityWith(NO_TYPE, ERROR_TYPE); [EOL]     assertCanTestForEqualityWith(NO_TYPE, EVAL_ERROR_TYPE); [EOL]     assertCanTestForEqualityWith(NO_TYPE, functionType); [EOL]     assertCanTestForEqualityWith(NO_TYPE, NULL_TYPE); [EOL]     assertCanTestForEqualityWith(NO_TYPE, NUMBER_TYPE); [EOL]     assertCanTestForEqualityWith(NO_TYPE, NUMBER_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(NO_TYPE, OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(NO_TYPE, URI_ERROR_TYPE); [EOL]     assertCanTestForEqualityWith(NO_TYPE, RANGE_ERROR_TYPE); [EOL]     assertCanTestForEqualityWith(NO_TYPE, REFERENCE_ERROR_TYPE); [EOL]     assertCanTestForEqualityWith(NO_TYPE, REGEXP_TYPE); [EOL]     assertCanTestForEqualityWith(NO_TYPE, STRING_TYPE); [EOL]     assertCanTestForEqualityWith(NO_TYPE, STRING_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(NO_TYPE, SYNTAX_ERROR_TYPE); [EOL]     assertCanTestForEqualityWith(NO_TYPE, TYPE_ERROR_TYPE); [EOL]     assertCanTestForEqualityWith(NO_TYPE, ALL_TYPE); [EOL]     assertCanTestForEqualityWith(NO_TYPE, VOID_TYPE); [EOL]     assertTrue(NO_TYPE.canTestForShallowEqualityWith(NO_TYPE)); [EOL]     assertTrue(NO_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); [EOL]     assertTrue(NO_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); [EOL]     assertTrue(NO_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); [EOL]     assertTrue(NO_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); [EOL]     assertTrue(NO_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); [EOL]     assertTrue(NO_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); [EOL]     assertTrue(NO_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); [EOL]     assertTrue(NO_TYPE.canTestForShallowEqualityWith(functionType)); [EOL]     assertTrue(NO_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); [EOL]     assertTrue(NO_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); [EOL]     assertTrue(NO_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); [EOL]     assertTrue(NO_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); [EOL]     assertTrue(NO_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE)); [EOL]     assertTrue(NO_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); [EOL]     assertTrue(NO_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); [EOL]     assertTrue(NO_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); [EOL]     assertTrue(NO_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); [EOL]     assertTrue(NO_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); [EOL]     assertTrue(NO_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); [EOL]     assertTrue(NO_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); [EOL]     assertTrue(NO_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); [EOL]     assertTrue(NO_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); [EOL]     assertTrue(NO_TYPE.isNullable()); [EOL]     assertTrue(NO_TYPE.isObject()); [EOL]     assertTrue(NO_TYPE.matchesInt32Context()); [EOL]     assertTrue(NO_TYPE.matchesNumberContext()); [EOL]     assertTrue(NO_TYPE.matchesObjectContext()); [EOL]     assertTrue(NO_TYPE.matchesStringContext()); [EOL]     assertTrue(NO_TYPE.matchesUint32Context()); [EOL]     assertEquals("None", NO_TYPE.toString()); [EOL]     assertEquals(null, NO_TYPE.getDisplayName()); [EOL]     assertFalse(NO_TYPE.hasDisplayName()); [EOL]     assertTypeEquals(NO_TYPE, NO_TYPE.getPropertyType("anyProperty")); [EOL]     Asserts.assertResolvesToSame(NO_TYPE); [EOL]     assertFalse(NO_TYPE.isNominalConstructor()); [EOL] } <line_num>: 543,672
public void testNoResolvedType() throws Exception { [EOL]     assertFalse(NO_RESOLVED_TYPE.isNoObjectType()); [EOL]     assertFalse(NO_RESOLVED_TYPE.isNoType()); [EOL]     assertTrue(NO_RESOLVED_TYPE.isNoResolvedType()); [EOL]     assertFalse(NO_RESOLVED_TYPE.isArrayType()); [EOL]     assertFalse(NO_RESOLVED_TYPE.isBooleanValueType()); [EOL]     assertFalse(NO_RESOLVED_TYPE.isDateType()); [EOL]     assertFalse(NO_RESOLVED_TYPE.isEnumElementType()); [EOL]     assertFalse(NO_RESOLVED_TYPE.isNullType()); [EOL]     assertFalse(NO_RESOLVED_TYPE.isNamedType()); [EOL]     assertTrue(NO_RESOLVED_TYPE.isNumber()); [EOL]     assertFalse(NO_RESOLVED_TYPE.isNumberObjectType()); [EOL]     assertFalse(NO_RESOLVED_TYPE.isNumberValueType()); [EOL]     assertTrue(NO_RESOLVED_TYPE.isObject()); [EOL]     assertFalse(NO_RESOLVED_TYPE.isFunctionPrototypeType()); [EOL]     assertFalse(NO_RESOLVED_TYPE.isRegexpType()); [EOL]     assertTrue(NO_RESOLVED_TYPE.isString()); [EOL]     assertFalse(NO_RESOLVED_TYPE.isStringObjectType()); [EOL]     assertFalse(NO_RESOLVED_TYPE.isStringValueType()); [EOL]     assertFalse(NO_RESOLVED_TYPE.isEnumType()); [EOL]     assertFalse(NO_RESOLVED_TYPE.isUnionType()); [EOL]     assertFalse(NO_RESOLVED_TYPE.isStruct()); [EOL]     assertFalse(NO_RESOLVED_TYPE.isDict()); [EOL]     assertFalse(NO_RESOLVED_TYPE.isAllType()); [EOL]     assertFalse(NO_RESOLVED_TYPE.isVoidType()); [EOL]     assertTrue(NO_RESOLVED_TYPE.isConstructor()); [EOL]     assertFalse(NO_RESOLVED_TYPE.isInstanceType()); [EOL]     assertTrue(NO_RESOLVED_TYPE.isSubtype(NO_RESOLVED_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.isSubtype(NO_OBJECT_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.isSubtype(ARRAY_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.isSubtype(BOOLEAN_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.isSubtype(DATE_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.isSubtype(ERROR_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.isSubtype(EVAL_ERROR_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.isSubtype(functionType)); [EOL]     assertTrue(NO_RESOLVED_TYPE.isSubtype(NULL_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.isSubtype(NUMBER_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.isSubtype(NUMBER_OBJECT_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.isSubtype(OBJECT_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.isSubtype(URI_ERROR_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.isSubtype(RANGE_ERROR_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.isSubtype(REFERENCE_ERROR_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.isSubtype(REGEXP_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.isSubtype(STRING_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.isSubtype(SYNTAX_ERROR_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.isSubtype(TYPE_ERROR_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.isSubtype(ALL_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.isSubtype(VOID_TYPE)); [EOL]     assertCanTestForEqualityWith(NO_RESOLVED_TYPE, NO_RESOLVED_TYPE); [EOL]     assertCanTestForEqualityWith(NO_RESOLVED_TYPE, NO_TYPE); [EOL]     assertCanTestForEqualityWith(NO_RESOLVED_TYPE, NO_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(NO_RESOLVED_TYPE, ARRAY_TYPE); [EOL]     assertCanTestForEqualityWith(NO_RESOLVED_TYPE, BOOLEAN_TYPE); [EOL]     assertCanTestForEqualityWith(NO_RESOLVED_TYPE, BOOLEAN_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(NO_RESOLVED_TYPE, DATE_TYPE); [EOL]     assertCanTestForEqualityWith(NO_RESOLVED_TYPE, ERROR_TYPE); [EOL]     assertCanTestForEqualityWith(NO_RESOLVED_TYPE, EVAL_ERROR_TYPE); [EOL]     assertCanTestForEqualityWith(NO_RESOLVED_TYPE, functionType); [EOL]     assertCanTestForEqualityWith(NO_RESOLVED_TYPE, NULL_TYPE); [EOL]     assertCanTestForEqualityWith(NO_RESOLVED_TYPE, NUMBER_TYPE); [EOL]     assertCanTestForEqualityWith(NO_RESOLVED_TYPE, NUMBER_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(NO_RESOLVED_TYPE, OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(NO_RESOLVED_TYPE, URI_ERROR_TYPE); [EOL]     assertCanTestForEqualityWith(NO_RESOLVED_TYPE, RANGE_ERROR_TYPE); [EOL]     assertCanTestForEqualityWith(NO_RESOLVED_TYPE, REFERENCE_ERROR_TYPE); [EOL]     assertCanTestForEqualityWith(NO_RESOLVED_TYPE, REGEXP_TYPE); [EOL]     assertCanTestForEqualityWith(NO_RESOLVED_TYPE, STRING_TYPE); [EOL]     assertCanTestForEqualityWith(NO_RESOLVED_TYPE, STRING_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(NO_RESOLVED_TYPE, SYNTAX_ERROR_TYPE); [EOL]     assertCanTestForEqualityWith(NO_RESOLVED_TYPE, TYPE_ERROR_TYPE); [EOL]     assertCanTestForEqualityWith(NO_RESOLVED_TYPE, ALL_TYPE); [EOL]     assertCanTestForEqualityWith(NO_RESOLVED_TYPE, VOID_TYPE); [EOL]     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NO_RESOLVED_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(functionType)); [EOL]     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); [EOL]     assertTrue(NO_RESOLVED_TYPE.isNullable()); [EOL]     assertTrue(NO_RESOLVED_TYPE.isObject()); [EOL]     assertTrue(NO_RESOLVED_TYPE.matchesInt32Context()); [EOL]     assertTrue(NO_RESOLVED_TYPE.matchesNumberContext()); [EOL]     assertTrue(NO_RESOLVED_TYPE.matchesObjectContext()); [EOL]     assertTrue(NO_RESOLVED_TYPE.matchesStringContext()); [EOL]     assertTrue(NO_RESOLVED_TYPE.matchesUint32Context()); [EOL]     assertEquals("NoResolvedType", NO_RESOLVED_TYPE.toString()); [EOL]     assertEquals(null, NO_RESOLVED_TYPE.getDisplayName()); [EOL]     assertFalse(NO_RESOLVED_TYPE.hasDisplayName()); [EOL]     assertTypeEquals(CHECKED_UNKNOWN_TYPE, NO_RESOLVED_TYPE.getPropertyType("anyProperty")); [EOL]     Asserts.assertResolvesToSame(NO_RESOLVED_TYPE); [EOL]     assertTrue(forwardDeclaredNamedType.isEmptyType()); [EOL]     assertTrue(forwardDeclaredNamedType.isNoResolvedType()); [EOL]     UnionType nullable = (UnionType) registry.createNullableType(NO_RESOLVED_TYPE); [EOL]     assertTypeEquals(nullable, nullable.getGreatestSubtype(NULL_TYPE)); [EOL]     assertTypeEquals(NO_RESOLVED_TYPE, nullable.getRestrictedUnion(NULL_TYPE)); [EOL] } <line_num>: 677,821
public void testArrayType() throws Exception { [EOL]     assertTrue(ARRAY_TYPE.isArrayType()); [EOL]     assertFalse(ARRAY_TYPE.isBooleanValueType()); [EOL]     assertFalse(ARRAY_TYPE.isDateType()); [EOL]     assertFalse(ARRAY_TYPE.isEnumElementType()); [EOL]     assertFalse(ARRAY_TYPE.isNamedType()); [EOL]     assertFalse(ARRAY_TYPE.isNullType()); [EOL]     assertFalse(ARRAY_TYPE.isNumber()); [EOL]     assertFalse(ARRAY_TYPE.isNumberObjectType()); [EOL]     assertFalse(ARRAY_TYPE.isNumberValueType()); [EOL]     assertTrue(ARRAY_TYPE.isObject()); [EOL]     assertFalse(ARRAY_TYPE.isFunctionPrototypeType()); [EOL]     assertTrue(ARRAY_TYPE.getImplicitPrototype().isFunctionPrototypeType()); [EOL]     assertFalse(ARRAY_TYPE.isRegexpType()); [EOL]     assertFalse(ARRAY_TYPE.isString()); [EOL]     assertFalse(ARRAY_TYPE.isStringObjectType()); [EOL]     assertFalse(ARRAY_TYPE.isStringValueType()); [EOL]     assertFalse(ARRAY_TYPE.isEnumType()); [EOL]     assertFalse(ARRAY_TYPE.isUnionType()); [EOL]     assertFalse(ARRAY_TYPE.isStruct()); [EOL]     assertFalse(ARRAY_TYPE.isDict()); [EOL]     assertFalse(ARRAY_TYPE.isAllType()); [EOL]     assertFalse(ARRAY_TYPE.isVoidType()); [EOL]     assertFalse(ARRAY_TYPE.isConstructor()); [EOL]     assertTrue(ARRAY_TYPE.isInstanceType()); [EOL]     assertFalse(ARRAY_TYPE.isSubtype(NO_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.isSubtype(NO_OBJECT_TYPE)); [EOL]     assertTrue(ARRAY_TYPE.isSubtype(ALL_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.isSubtype(NUMBER_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.isSubtype(functionType)); [EOL]     assertFalse(ARRAY_TYPE.isSubtype(recordType)); [EOL]     assertFalse(ARRAY_TYPE.isSubtype(NULL_TYPE)); [EOL]     assertTrue(ARRAY_TYPE.isSubtype(OBJECT_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.isSubtype(DATE_TYPE)); [EOL]     assertTrue(ARRAY_TYPE.isSubtype(unresolvedNamedType)); [EOL]     assertFalse(ARRAY_TYPE.isSubtype(namedGoogBar)); [EOL]     assertFalse(ARRAY_TYPE.isSubtype(REGEXP_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.canBeCalled()); [EOL]     assertCanTestForEqualityWith(ARRAY_TYPE, NO_TYPE); [EOL]     assertCanTestForEqualityWith(ARRAY_TYPE, NO_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(ARRAY_TYPE, ALL_TYPE); [EOL]     assertCanTestForEqualityWith(ARRAY_TYPE, STRING_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(ARRAY_TYPE, NUMBER_TYPE); [EOL]     assertCanTestForEqualityWith(ARRAY_TYPE, functionType); [EOL]     assertCanTestForEqualityWith(ARRAY_TYPE, recordType); [EOL]     assertCannotTestForEqualityWith(ARRAY_TYPE, VOID_TYPE); [EOL]     assertCanTestForEqualityWith(ARRAY_TYPE, OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(ARRAY_TYPE, DATE_TYPE); [EOL]     assertCanTestForEqualityWith(ARRAY_TYPE, REGEXP_TYPE); [EOL]     assertTrue(ARRAY_TYPE.canTestForShallowEqualityWith(NO_TYPE)); [EOL]     assertTrue(ARRAY_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); [EOL]     assertTrue(ARRAY_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(functionType)); [EOL]     assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(recordType)); [EOL]     assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); [EOL]     assertTrue(ARRAY_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); [EOL]     assertTrue(ARRAY_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.isNullable()); [EOL]     assertTrue(createUnionType(ARRAY_TYPE, NULL_TYPE).isNullable()); [EOL]     assertTrue(ARRAY_TYPE.isObject()); [EOL]     assertTypeEquals(ALL_TYPE, ARRAY_TYPE.getLeastSupertype(ALL_TYPE)); [EOL]     assertTypeEquals(createUnionType(STRING_OBJECT_TYPE, ARRAY_TYPE), ARRAY_TYPE.getLeastSupertype(STRING_OBJECT_TYPE)); [EOL]     assertTypeEquals(createUnionType(NUMBER_TYPE, ARRAY_TYPE), ARRAY_TYPE.getLeastSupertype(NUMBER_TYPE)); [EOL]     assertTypeEquals(createUnionType(ARRAY_TYPE, functionType), ARRAY_TYPE.getLeastSupertype(functionType)); [EOL]     assertTypeEquals(OBJECT_TYPE, ARRAY_TYPE.getLeastSupertype(OBJECT_TYPE)); [EOL]     assertTypeEquals(createUnionType(DATE_TYPE, ARRAY_TYPE), ARRAY_TYPE.getLeastSupertype(DATE_TYPE)); [EOL]     assertTypeEquals(createUnionType(REGEXP_TYPE, ARRAY_TYPE), ARRAY_TYPE.getLeastSupertype(REGEXP_TYPE)); [EOL]     assertEquals(17, ARRAY_TYPE.getImplicitPrototype().getPropertiesCount()); [EOL]     assertEquals(18, ARRAY_TYPE.getPropertiesCount()); [EOL]     assertReturnTypeEquals(ARRAY_TYPE, ARRAY_TYPE.getPropertyType("constructor")); [EOL]     assertReturnTypeEquals(STRING_TYPE, ARRAY_TYPE.getPropertyType("toString")); [EOL]     assertReturnTypeEquals(STRING_TYPE, ARRAY_TYPE.getPropertyType("toLocaleString")); [EOL]     assertReturnTypeEquals(ARRAY_TYPE, ARRAY_TYPE.getPropertyType("concat")); [EOL]     assertReturnTypeEquals(STRING_TYPE, ARRAY_TYPE.getPropertyType("join")); [EOL]     assertReturnTypeEquals(UNKNOWN_TYPE, ARRAY_TYPE.getPropertyType("pop")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, ARRAY_TYPE.getPropertyType("push")); [EOL]     assertReturnTypeEquals(ARRAY_TYPE, ARRAY_TYPE.getPropertyType("reverse")); [EOL]     assertReturnTypeEquals(UNKNOWN_TYPE, ARRAY_TYPE.getPropertyType("shift")); [EOL]     assertReturnTypeEquals(ARRAY_TYPE, ARRAY_TYPE.getPropertyType("slice")); [EOL]     assertReturnTypeEquals(ARRAY_TYPE, ARRAY_TYPE.getPropertyType("sort")); [EOL]     assertReturnTypeEquals(ARRAY_TYPE, ARRAY_TYPE.getPropertyType("splice")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, ARRAY_TYPE.getPropertyType("unshift")); [EOL]     assertTypeEquals(NUMBER_TYPE, ARRAY_TYPE.getPropertyType("length")); [EOL]     assertPropertyTypeDeclared(ARRAY_TYPE, "pop"); [EOL]     assertFalse(ARRAY_TYPE.matchesInt32Context()); [EOL]     assertFalse(ARRAY_TYPE.matchesNumberContext()); [EOL]     assertTrue(ARRAY_TYPE.matchesObjectContext()); [EOL]     assertTrue(ARRAY_TYPE.matchesStringContext()); [EOL]     assertFalse(ARRAY_TYPE.matchesUint32Context()); [EOL]     assertEquals("Array", ARRAY_TYPE.toString()); [EOL]     assertTrue(ARRAY_TYPE.hasDisplayName()); [EOL]     assertEquals("Array", ARRAY_TYPE.getDisplayName()); [EOL]     assertTrue(ARRAY_TYPE.isNativeObjectType()); [EOL]     Asserts.assertResolvesToSame(ARRAY_TYPE); [EOL]     assertFalse(ARRAY_TYPE.isNominalConstructor()); [EOL]     assertTrue(ARRAY_TYPE.getConstructor().isNominalConstructor()); [EOL] } <line_num>: 826,975
public void testUnknownType() throws Exception { [EOL]     assertFalse(UNKNOWN_TYPE.isArrayType()); [EOL]     assertFalse(UNKNOWN_TYPE.isBooleanObjectType()); [EOL]     assertFalse(UNKNOWN_TYPE.isBooleanValueType()); [EOL]     assertFalse(UNKNOWN_TYPE.isDateType()); [EOL]     assertFalse(UNKNOWN_TYPE.isEnumElementType()); [EOL]     assertFalse(UNKNOWN_TYPE.isNamedType()); [EOL]     assertFalse(UNKNOWN_TYPE.isNullType()); [EOL]     assertFalse(UNKNOWN_TYPE.isNumberObjectType()); [EOL]     assertFalse(UNKNOWN_TYPE.isNumberValueType()); [EOL]     assertTrue(UNKNOWN_TYPE.isObject()); [EOL]     assertFalse(UNKNOWN_TYPE.isFunctionPrototypeType()); [EOL]     assertFalse(UNKNOWN_TYPE.isRegexpType()); [EOL]     assertFalse(UNKNOWN_TYPE.isStringObjectType()); [EOL]     assertFalse(UNKNOWN_TYPE.isStringValueType()); [EOL]     assertFalse(UNKNOWN_TYPE.isEnumType()); [EOL]     assertFalse(UNKNOWN_TYPE.isUnionType()); [EOL]     assertFalse(UNKNOWN_TYPE.isStruct()); [EOL]     assertFalse(UNKNOWN_TYPE.isDict()); [EOL]     assertTrue(UNKNOWN_TYPE.isUnknownType()); [EOL]     assertFalse(UNKNOWN_TYPE.isVoidType()); [EOL]     assertFalse(UNKNOWN_TYPE.isConstructor()); [EOL]     assertFalse(UNKNOWN_TYPE.isInstanceType()); [EOL]     assertNull(UNKNOWN_TYPE.autoboxesTo()); [EOL]     assertTrue(UNKNOWN_TYPE.isSubtype(UNKNOWN_TYPE)); [EOL]     assertTrue(UNKNOWN_TYPE.isSubtype(STRING_TYPE)); [EOL]     assertTrue(UNKNOWN_TYPE.isSubtype(NUMBER_TYPE)); [EOL]     assertTrue(UNKNOWN_TYPE.isSubtype(functionType)); [EOL]     assertTrue(UNKNOWN_TYPE.isSubtype(recordType)); [EOL]     assertTrue(UNKNOWN_TYPE.isSubtype(NULL_TYPE)); [EOL]     assertTrue(UNKNOWN_TYPE.isSubtype(OBJECT_TYPE)); [EOL]     assertTrue(UNKNOWN_TYPE.isSubtype(DATE_TYPE)); [EOL]     assertTrue(UNKNOWN_TYPE.isSubtype(namedGoogBar)); [EOL]     assertTrue(UNKNOWN_TYPE.isSubtype(unresolvedNamedType)); [EOL]     assertTrue(UNKNOWN_TYPE.isSubtype(REGEXP_TYPE)); [EOL]     assertTrue(UNKNOWN_TYPE.isSubtype(VOID_TYPE)); [EOL]     assertTrue(UNKNOWN_TYPE.canBeCalled()); [EOL]     assertCanTestForEqualityWith(UNKNOWN_TYPE, UNKNOWN_TYPE); [EOL]     assertCanTestForEqualityWith(UNKNOWN_TYPE, STRING_TYPE); [EOL]     assertCanTestForEqualityWith(UNKNOWN_TYPE, NUMBER_TYPE); [EOL]     assertCanTestForEqualityWith(UNKNOWN_TYPE, functionType); [EOL]     assertCanTestForEqualityWith(UNKNOWN_TYPE, recordType); [EOL]     assertCanTestForEqualityWith(UNKNOWN_TYPE, VOID_TYPE); [EOL]     assertCanTestForEqualityWith(UNKNOWN_TYPE, OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(UNKNOWN_TYPE, DATE_TYPE); [EOL]     assertCanTestForEqualityWith(UNKNOWN_TYPE, REGEXP_TYPE); [EOL]     assertCanTestForEqualityWith(UNKNOWN_TYPE, BOOLEAN_TYPE); [EOL]     assertTrue(UNKNOWN_TYPE.canTestForShallowEqualityWith(UNKNOWN_TYPE)); [EOL]     assertTrue(UNKNOWN_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); [EOL]     assertTrue(UNKNOWN_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); [EOL]     assertTrue(UNKNOWN_TYPE.canTestForShallowEqualityWith(functionType)); [EOL]     assertTrue(UNKNOWN_TYPE.canTestForShallowEqualityWith(recordType)); [EOL]     assertTrue(UNKNOWN_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); [EOL]     assertTrue(UNKNOWN_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); [EOL]     assertTrue(UNKNOWN_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); [EOL]     assertTrue(UNKNOWN_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); [EOL]     assertTrue(UNKNOWN_TYPE.isNullable()); [EOL]     assertTypeEquals(UNKNOWN_TYPE, UNKNOWN_TYPE.getLeastSupertype(UNKNOWN_TYPE)); [EOL]     assertTypeEquals(UNKNOWN_TYPE, UNKNOWN_TYPE.getLeastSupertype(STRING_TYPE)); [EOL]     assertTypeEquals(UNKNOWN_TYPE, UNKNOWN_TYPE.getLeastSupertype(NUMBER_TYPE)); [EOL]     assertTypeEquals(UNKNOWN_TYPE, UNKNOWN_TYPE.getLeastSupertype(functionType)); [EOL]     assertTypeEquals(UNKNOWN_TYPE, UNKNOWN_TYPE.getLeastSupertype(OBJECT_TYPE)); [EOL]     assertTypeEquals(UNKNOWN_TYPE, UNKNOWN_TYPE.getLeastSupertype(DATE_TYPE)); [EOL]     assertTypeEquals(UNKNOWN_TYPE, UNKNOWN_TYPE.getLeastSupertype(REGEXP_TYPE)); [EOL]     assertTrue(UNKNOWN_TYPE.matchesInt32Context()); [EOL]     assertTrue(UNKNOWN_TYPE.matchesNumberContext()); [EOL]     assertTrue(UNKNOWN_TYPE.matchesObjectContext()); [EOL]     assertTrue(UNKNOWN_TYPE.matchesStringContext()); [EOL]     assertTrue(UNKNOWN_TYPE.matchesUint32Context()); [EOL]     assertPropertyTypeUnknown(UNKNOWN_TYPE, "XXX"); [EOL]     assertEquals("?", UNKNOWN_TYPE.toString()); [EOL]     assertTrue(UNKNOWN_TYPE.hasDisplayName()); [EOL]     assertEquals("Unknown", UNKNOWN_TYPE.getDisplayName()); [EOL]     Asserts.assertResolvesToSame(UNKNOWN_TYPE); [EOL]     assertFalse(UNKNOWN_TYPE.isNominalConstructor()); [EOL]     assertEquals(UNKNOWN_TYPE, UNKNOWN_TYPE.getPropertyType("abc")); [EOL] } <line_num>: 980,1086
public void testCheckedUnknownType() throws Exception { [EOL]     assertPropertyTypeUnknown(CHECKED_UNKNOWN_TYPE, "XXX"); [EOL]     assertEquals("??", CHECKED_UNKNOWN_TYPE.toString()); [EOL]     assertTrue(CHECKED_UNKNOWN_TYPE.hasDisplayName()); [EOL]     assertEquals("Unknown", CHECKED_UNKNOWN_TYPE.getDisplayName()); [EOL]     Asserts.assertResolvesToSame(CHECKED_UNKNOWN_TYPE); [EOL]     assertFalse(CHECKED_UNKNOWN_TYPE.isNominalConstructor()); [EOL]     assertEquals(CHECKED_UNKNOWN_TYPE, CHECKED_UNKNOWN_TYPE.getPropertyType("abc")); [EOL] } <line_num>: 1091,1105
public void testAllType() throws Exception { [EOL]     assertFalse(ALL_TYPE.isArrayType()); [EOL]     assertFalse(ALL_TYPE.isBooleanValueType()); [EOL]     assertFalse(ALL_TYPE.isDateType()); [EOL]     assertFalse(ALL_TYPE.isEnumElementType()); [EOL]     assertFalse(ALL_TYPE.isNamedType()); [EOL]     assertFalse(ALL_TYPE.isNullType()); [EOL]     assertFalse(ALL_TYPE.isNumber()); [EOL]     assertFalse(ALL_TYPE.isNumberObjectType()); [EOL]     assertFalse(ALL_TYPE.isNumberValueType()); [EOL]     assertFalse(ALL_TYPE.isObject()); [EOL]     assertFalse(ALL_TYPE.isFunctionPrototypeType()); [EOL]     assertFalse(ALL_TYPE.isRegexpType()); [EOL]     assertFalse(ALL_TYPE.isString()); [EOL]     assertFalse(ALL_TYPE.isStringObjectType()); [EOL]     assertFalse(ALL_TYPE.isStringValueType()); [EOL]     assertFalse(ALL_TYPE.isEnumType()); [EOL]     assertFalse(ALL_TYPE.isUnionType()); [EOL]     assertFalse(ALL_TYPE.isStruct()); [EOL]     assertFalse(ALL_TYPE.isDict()); [EOL]     assertTrue(ALL_TYPE.isAllType()); [EOL]     assertFalse(ALL_TYPE.isVoidType()); [EOL]     assertFalse(ALL_TYPE.isConstructor()); [EOL]     assertFalse(ALL_TYPE.isInstanceType()); [EOL]     assertFalse(ALL_TYPE.isSubtype(NO_TYPE)); [EOL]     assertFalse(ALL_TYPE.isSubtype(NO_OBJECT_TYPE)); [EOL]     assertTrue(ALL_TYPE.isSubtype(ALL_TYPE)); [EOL]     assertFalse(ALL_TYPE.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertFalse(ALL_TYPE.isSubtype(NUMBER_TYPE)); [EOL]     assertFalse(ALL_TYPE.isSubtype(functionType)); [EOL]     assertFalse(ALL_TYPE.isSubtype(recordType)); [EOL]     assertFalse(ALL_TYPE.isSubtype(NULL_TYPE)); [EOL]     assertFalse(ALL_TYPE.isSubtype(OBJECT_TYPE)); [EOL]     assertFalse(ALL_TYPE.isSubtype(DATE_TYPE)); [EOL]     assertTrue(ALL_TYPE.isSubtype(unresolvedNamedType)); [EOL]     assertFalse(ALL_TYPE.isSubtype(namedGoogBar)); [EOL]     assertFalse(ALL_TYPE.isSubtype(REGEXP_TYPE)); [EOL]     assertFalse(ALL_TYPE.isSubtype(VOID_TYPE)); [EOL]     assertTrue(ALL_TYPE.isSubtype(UNKNOWN_TYPE)); [EOL]     assertFalse(ALL_TYPE.canBeCalled()); [EOL]     assertCanTestForEqualityWith(ALL_TYPE, ALL_TYPE); [EOL]     assertCanTestForEqualityWith(ALL_TYPE, STRING_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(ALL_TYPE, NUMBER_TYPE); [EOL]     assertCanTestForEqualityWith(ALL_TYPE, functionType); [EOL]     assertCanTestForEqualityWith(ALL_TYPE, recordType); [EOL]     assertCanTestForEqualityWith(ALL_TYPE, VOID_TYPE); [EOL]     assertCanTestForEqualityWith(ALL_TYPE, OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(ALL_TYPE, DATE_TYPE); [EOL]     assertCanTestForEqualityWith(ALL_TYPE, REGEXP_TYPE); [EOL]     assertTrue(ALL_TYPE.canTestForShallowEqualityWith(NO_TYPE)); [EOL]     assertTrue(ALL_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); [EOL]     assertTrue(ALL_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); [EOL]     assertTrue(ALL_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); [EOL]     assertTrue(ALL_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); [EOL]     assertTrue(ALL_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); [EOL]     assertTrue(ALL_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); [EOL]     assertTrue(ALL_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); [EOL]     assertTrue(ALL_TYPE.canTestForShallowEqualityWith(functionType)); [EOL]     assertTrue(ALL_TYPE.canTestForShallowEqualityWith(recordType)); [EOL]     assertTrue(ALL_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); [EOL]     assertTrue(ALL_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); [EOL]     assertTrue(ALL_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); [EOL]     assertTrue(ALL_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); [EOL]     assertTrue(ALL_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE)); [EOL]     assertTrue(ALL_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); [EOL]     assertTrue(ALL_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); [EOL]     assertTrue(ALL_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); [EOL]     assertTrue(ALL_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); [EOL]     assertTrue(ALL_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); [EOL]     assertTrue(ALL_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); [EOL]     assertTrue(ALL_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); [EOL]     assertTrue(ALL_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); [EOL]     assertTrue(ALL_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); [EOL]     assertFalse(ALL_TYPE.isNullable()); [EOL]     assertTypeEquals(ALL_TYPE, ALL_TYPE.getLeastSupertype(ALL_TYPE)); [EOL]     assertTypeEquals(ALL_TYPE, ALL_TYPE.getLeastSupertype(UNKNOWN_TYPE)); [EOL]     assertTypeEquals(ALL_TYPE, ALL_TYPE.getLeastSupertype(STRING_OBJECT_TYPE)); [EOL]     assertTypeEquals(ALL_TYPE, ALL_TYPE.getLeastSupertype(NUMBER_TYPE)); [EOL]     assertTypeEquals(ALL_TYPE, ALL_TYPE.getLeastSupertype(functionType)); [EOL]     assertTypeEquals(ALL_TYPE, ALL_TYPE.getLeastSupertype(OBJECT_TYPE)); [EOL]     assertTypeEquals(ALL_TYPE, ALL_TYPE.getLeastSupertype(DATE_TYPE)); [EOL]     assertTypeEquals(ALL_TYPE, ALL_TYPE.getLeastSupertype(REGEXP_TYPE)); [EOL]     assertFalse(ALL_TYPE.matchesInt32Context()); [EOL]     assertFalse(ALL_TYPE.matchesNumberContext()); [EOL]     assertTrue(ALL_TYPE.matchesObjectContext()); [EOL]     assertTrue(ALL_TYPE.matchesStringContext()); [EOL]     assertFalse(ALL_TYPE.matchesUint32Context()); [EOL]     assertEquals("*", ALL_TYPE.toString()); [EOL]     assertTrue(ALL_TYPE.hasDisplayName()); [EOL]     assertEquals("<Any Type>", ALL_TYPE.getDisplayName()); [EOL]     Asserts.assertResolvesToSame(ALL_TYPE); [EOL]     assertFalse(ALL_TYPE.isNominalConstructor()); [EOL] } <line_num>: 1110,1229
public void testTheObjectType() throws Exception { [EOL]     assertTypeEquals(OBJECT_PROTOTYPE, OBJECT_TYPE.getImplicitPrototype()); [EOL]     assertFalse(OBJECT_TYPE.isNoObjectType()); [EOL]     assertFalse(OBJECT_TYPE.isNoType()); [EOL]     assertFalse(OBJECT_TYPE.isArrayType()); [EOL]     assertFalse(OBJECT_TYPE.isBooleanValueType()); [EOL]     assertFalse(OBJECT_TYPE.isDateType()); [EOL]     assertFalse(OBJECT_TYPE.isEnumElementType()); [EOL]     assertFalse(OBJECT_TYPE.isNullType()); [EOL]     assertFalse(OBJECT_TYPE.isNamedType()); [EOL]     assertFalse(OBJECT_TYPE.isNullType()); [EOL]     assertFalse(OBJECT_TYPE.isNumber()); [EOL]     assertFalse(OBJECT_TYPE.isNumberObjectType()); [EOL]     assertFalse(OBJECT_TYPE.isNumberValueType()); [EOL]     assertTrue(OBJECT_TYPE.isObject()); [EOL]     assertFalse(OBJECT_TYPE.isFunctionPrototypeType()); [EOL]     assertTrue(OBJECT_TYPE.getImplicitPrototype().isFunctionPrototypeType()); [EOL]     assertFalse(OBJECT_TYPE.isRegexpType()); [EOL]     assertFalse(OBJECT_TYPE.isString()); [EOL]     assertFalse(OBJECT_TYPE.isStringObjectType()); [EOL]     assertFalse(OBJECT_TYPE.isStringValueType()); [EOL]     assertFalse(OBJECT_TYPE.isEnumType()); [EOL]     assertFalse(OBJECT_TYPE.isUnionType()); [EOL]     assertFalse(OBJECT_TYPE.isStruct()); [EOL]     assertFalse(OBJECT_TYPE.isDict()); [EOL]     assertFalse(OBJECT_TYPE.isAllType()); [EOL]     assertFalse(OBJECT_TYPE.isVoidType()); [EOL]     assertFalse(OBJECT_TYPE.isConstructor()); [EOL]     assertTrue(OBJECT_TYPE.isInstanceType()); [EOL]     assertFalse(OBJECT_TYPE.isSubtype(NO_TYPE)); [EOL]     assertTrue(OBJECT_TYPE.isSubtype(ALL_TYPE)); [EOL]     assertFalse(OBJECT_TYPE.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertFalse(OBJECT_TYPE.isSubtype(NUMBER_TYPE)); [EOL]     assertFalse(OBJECT_TYPE.isSubtype(functionType)); [EOL]     assertFalse(OBJECT_TYPE.isSubtype(recordType)); [EOL]     assertFalse(OBJECT_TYPE.isSubtype(NULL_TYPE)); [EOL]     assertTrue(OBJECT_TYPE.isSubtype(OBJECT_TYPE)); [EOL]     assertFalse(OBJECT_TYPE.isSubtype(DATE_TYPE)); [EOL]     assertFalse(OBJECT_TYPE.isSubtype(namedGoogBar)); [EOL]     assertTrue(OBJECT_TYPE.isSubtype(unresolvedNamedType)); [EOL]     assertFalse(OBJECT_TYPE.isSubtype(REGEXP_TYPE)); [EOL]     assertFalse(OBJECT_TYPE.isSubtype(ARRAY_TYPE)); [EOL]     assertTrue(OBJECT_TYPE.isSubtype(UNKNOWN_TYPE)); [EOL]     assertFalse(OBJECT_TYPE.canBeCalled()); [EOL]     assertCanTestForEqualityWith(OBJECT_TYPE, ALL_TYPE); [EOL]     assertCanTestForEqualityWith(OBJECT_TYPE, STRING_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(OBJECT_TYPE, NUMBER_TYPE); [EOL]     assertCanTestForEqualityWith(OBJECT_TYPE, STRING_TYPE); [EOL]     assertCanTestForEqualityWith(OBJECT_TYPE, BOOLEAN_TYPE); [EOL]     assertCanTestForEqualityWith(OBJECT_TYPE, functionType); [EOL]     assertCanTestForEqualityWith(OBJECT_TYPE, recordType); [EOL]     assertCannotTestForEqualityWith(OBJECT_TYPE, VOID_TYPE); [EOL]     assertCanTestForEqualityWith(OBJECT_TYPE, OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(OBJECT_TYPE, DATE_TYPE); [EOL]     assertCanTestForEqualityWith(OBJECT_TYPE, REGEXP_TYPE); [EOL]     assertCanTestForEqualityWith(OBJECT_TYPE, ARRAY_TYPE); [EOL]     assertCanTestForEqualityWith(OBJECT_TYPE, UNKNOWN_TYPE); [EOL]     assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(NO_TYPE)); [EOL]     assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); [EOL]     assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); [EOL]     assertFalse(OBJECT_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); [EOL]     assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); [EOL]     assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); [EOL]     assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); [EOL]     assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); [EOL]     assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(functionType)); [EOL]     assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(recordType)); [EOL]     assertFalse(OBJECT_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); [EOL]     assertFalse(OBJECT_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); [EOL]     assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); [EOL]     assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); [EOL]     assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE)); [EOL]     assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); [EOL]     assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); [EOL]     assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); [EOL]     assertFalse(OBJECT_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); [EOL]     assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); [EOL]     assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); [EOL]     assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); [EOL]     assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); [EOL]     assertFalse(OBJECT_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); [EOL]     assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(UNKNOWN_TYPE)); [EOL]     assertFalse(OBJECT_TYPE.isNullable()); [EOL]     assertTypeEquals(ALL_TYPE, OBJECT_TYPE.getLeastSupertype(ALL_TYPE)); [EOL]     assertTypeEquals(OBJECT_TYPE, OBJECT_TYPE.getLeastSupertype(STRING_OBJECT_TYPE)); [EOL]     assertTypeEquals(createUnionType(OBJECT_TYPE, NUMBER_TYPE), OBJECT_TYPE.getLeastSupertype(NUMBER_TYPE)); [EOL]     assertTypeEquals(OBJECT_TYPE, OBJECT_TYPE.getLeastSupertype(functionType)); [EOL]     assertTypeEquals(OBJECT_TYPE, OBJECT_TYPE.getLeastSupertype(OBJECT_TYPE)); [EOL]     assertTypeEquals(OBJECT_TYPE, OBJECT_TYPE.getLeastSupertype(DATE_TYPE)); [EOL]     assertTypeEquals(OBJECT_TYPE, OBJECT_TYPE.getLeastSupertype(REGEXP_TYPE)); [EOL]     assertEquals(7, OBJECT_TYPE.getPropertiesCount()); [EOL]     assertReturnTypeEquals(OBJECT_TYPE, OBJECT_TYPE.getPropertyType("constructor")); [EOL]     assertReturnTypeEquals(STRING_TYPE, OBJECT_TYPE.getPropertyType("toString")); [EOL]     assertReturnTypeEquals(STRING_TYPE, OBJECT_TYPE.getPropertyType("toLocaleString")); [EOL]     assertReturnTypeEquals(UNKNOWN_TYPE, OBJECT_TYPE.getPropertyType("valueOf")); [EOL]     assertReturnTypeEquals(BOOLEAN_TYPE, OBJECT_TYPE.getPropertyType("hasOwnProperty")); [EOL]     assertReturnTypeEquals(BOOLEAN_TYPE, OBJECT_TYPE.getPropertyType("isPrototypeOf")); [EOL]     assertReturnTypeEquals(BOOLEAN_TYPE, OBJECT_TYPE.getPropertyType("propertyIsEnumerable")); [EOL]     assertFalse(OBJECT_TYPE.matchesInt32Context()); [EOL]     assertFalse(OBJECT_TYPE.matchesNumberContext()); [EOL]     assertTrue(OBJECT_TYPE.matchesObjectContext()); [EOL]     assertTrue(OBJECT_TYPE.matchesStringContext()); [EOL]     assertFalse(OBJECT_TYPE.matchesUint32Context()); [EOL]     assertTypeEquals(OBJECT_PROTOTYPE, OBJECT_TYPE.getImplicitPrototype()); [EOL]     assertEquals("Object", OBJECT_TYPE.toString()); [EOL]     assertTrue(OBJECT_TYPE.isNativeObjectType()); [EOL]     assertTrue(OBJECT_TYPE.getImplicitPrototype().isNativeObjectType()); [EOL]     Asserts.assertResolvesToSame(OBJECT_TYPE); [EOL]     assertFalse(OBJECT_TYPE.isNominalConstructor()); [EOL]     assertTrue(OBJECT_TYPE.getConstructor().isNominalConstructor()); [EOL] } <line_num>: 1235,1385
public void testNumberObjectType() throws Exception { [EOL]     assertFalse(NUMBER_OBJECT_TYPE.isArrayType()); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.isBooleanObjectType()); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.isBooleanValueType()); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.isDateType()); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.isEnumElementType()); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.isNamedType()); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.isNullType()); [EOL]     assertTrue(NUMBER_OBJECT_TYPE.isNumber()); [EOL]     assertTrue(NUMBER_OBJECT_TYPE.isNumberObjectType()); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.isNumberValueType()); [EOL]     assertTrue(NUMBER_OBJECT_TYPE.isObject()); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.isFunctionPrototypeType()); [EOL]     assertTrue(NUMBER_OBJECT_TYPE.getImplicitPrototype().isFunctionPrototypeType()); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.isRegexpType()); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.isString()); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.isStringObjectType()); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.isStringValueType()); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.isEnumType()); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.isUnionType()); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.isStruct()); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.isDict()); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.isAllType()); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.isVoidType()); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.isConstructor()); [EOL]     assertTrue(NUMBER_OBJECT_TYPE.isInstanceType()); [EOL]     assertTypeEquals(NUMBER_OBJECT_TYPE, NUMBER_TYPE.autoboxesTo()); [EOL]     assertTypeEquals(NUMBER_TYPE, NUMBER_OBJECT_TYPE.unboxesTo()); [EOL]     assertTrue(NUMBER_OBJECT_TYPE.isSubtype(ALL_TYPE)); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.isSubtype(NUMBER_TYPE)); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.isSubtype(functionType)); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.isSubtype(NULL_TYPE)); [EOL]     assertTrue(NUMBER_OBJECT_TYPE.isSubtype(OBJECT_TYPE)); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.isSubtype(DATE_TYPE)); [EOL]     assertTrue(NUMBER_OBJECT_TYPE.isSubtype(unresolvedNamedType)); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.isSubtype(namedGoogBar)); [EOL]     assertTrue(NUMBER_OBJECT_TYPE.isSubtype(createUnionType(NUMBER_OBJECT_TYPE, NULL_TYPE))); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.isSubtype(createUnionType(NUMBER_TYPE, NULL_TYPE))); [EOL]     assertTrue(NUMBER_OBJECT_TYPE.isSubtype(UNKNOWN_TYPE)); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.canBeCalled()); [EOL]     assertCanTestForEqualityWith(NUMBER_OBJECT_TYPE, NO_TYPE); [EOL]     assertCanTestForEqualityWith(NUMBER_OBJECT_TYPE, NO_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(NUMBER_OBJECT_TYPE, ALL_TYPE); [EOL]     assertCanTestForEqualityWith(NUMBER_OBJECT_TYPE, NUMBER_TYPE); [EOL]     assertCanTestForEqualityWith(NUMBER_OBJECT_TYPE, STRING_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(NUMBER_OBJECT_TYPE, functionType); [EOL]     assertCanTestForEqualityWith(NUMBER_OBJECT_TYPE, elementsType); [EOL]     assertCannotTestForEqualityWith(NUMBER_OBJECT_TYPE, VOID_TYPE); [EOL]     assertCanTestForEqualityWith(NUMBER_OBJECT_TYPE, OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(NUMBER_OBJECT_TYPE, DATE_TYPE); [EOL]     assertCanTestForEqualityWith(NUMBER_OBJECT_TYPE, REGEXP_TYPE); [EOL]     assertCanTestForEqualityWith(NUMBER_OBJECT_TYPE, ARRAY_TYPE); [EOL]     assertTrue(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(NO_TYPE)); [EOL]     assertTrue(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(functionType)); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); [EOL]     assertTrue(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); [EOL]     assertTrue(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE)); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); [EOL]     assertTrue(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); [EOL]     assertFalse(NUMBER_OBJECT_TYPE.isNullable()); [EOL]     assertTypeEquals(ALL_TYPE, NUMBER_OBJECT_TYPE.getLeastSupertype(ALL_TYPE)); [EOL]     assertTypeEquals(createUnionType(NUMBER_OBJECT_TYPE, STRING_OBJECT_TYPE), NUMBER_OBJECT_TYPE.getLeastSupertype(STRING_OBJECT_TYPE)); [EOL]     assertTypeEquals(createUnionType(NUMBER_OBJECT_TYPE, NUMBER_TYPE), NUMBER_OBJECT_TYPE.getLeastSupertype(NUMBER_TYPE)); [EOL]     assertTypeEquals(createUnionType(NUMBER_OBJECT_TYPE, functionType), NUMBER_OBJECT_TYPE.getLeastSupertype(functionType)); [EOL]     assertTypeEquals(OBJECT_TYPE, NUMBER_OBJECT_TYPE.getLeastSupertype(OBJECT_TYPE)); [EOL]     assertTypeEquals(createUnionType(NUMBER_OBJECT_TYPE, DATE_TYPE), NUMBER_OBJECT_TYPE.getLeastSupertype(DATE_TYPE)); [EOL]     assertTypeEquals(createUnionType(NUMBER_OBJECT_TYPE, REGEXP_TYPE), NUMBER_OBJECT_TYPE.getLeastSupertype(REGEXP_TYPE)); [EOL]     assertTrue(NUMBER_OBJECT_TYPE.matchesInt32Context()); [EOL]     assertTrue(NUMBER_OBJECT_TYPE.matchesNumberContext()); [EOL]     assertTrue(NUMBER_OBJECT_TYPE.matchesObjectContext()); [EOL]     assertTrue(NUMBER_OBJECT_TYPE.matchesStringContext()); [EOL]     assertTrue(NUMBER_OBJECT_TYPE.matchesUint32Context()); [EOL]     assertEquals("Number", NUMBER_OBJECT_TYPE.toString()); [EOL]     assertTrue(NUMBER_OBJECT_TYPE.hasDisplayName()); [EOL]     assertEquals("Number", NUMBER_OBJECT_TYPE.getDisplayName()); [EOL]     assertTrue(NUMBER_OBJECT_TYPE.isNativeObjectType()); [EOL]     Asserts.assertResolvesToSame(NUMBER_OBJECT_TYPE); [EOL] } <line_num>: 1390,1527
public void testNumberValueType() throws Exception { [EOL]     assertFalse(NUMBER_TYPE.isArrayType()); [EOL]     assertFalse(NUMBER_TYPE.isBooleanObjectType()); [EOL]     assertFalse(NUMBER_TYPE.isBooleanValueType()); [EOL]     assertFalse(NUMBER_TYPE.isDateType()); [EOL]     assertFalse(NUMBER_TYPE.isEnumElementType()); [EOL]     assertFalse(NUMBER_TYPE.isNamedType()); [EOL]     assertFalse(NUMBER_TYPE.isNullType()); [EOL]     assertTrue(NUMBER_TYPE.isNumber()); [EOL]     assertFalse(NUMBER_TYPE.isNumberObjectType()); [EOL]     assertTrue(NUMBER_TYPE.isNumberValueType()); [EOL]     assertFalse(NUMBER_TYPE.isFunctionPrototypeType()); [EOL]     assertFalse(NUMBER_TYPE.isRegexpType()); [EOL]     assertFalse(NUMBER_TYPE.isString()); [EOL]     assertFalse(NUMBER_TYPE.isStringObjectType()); [EOL]     assertFalse(NUMBER_TYPE.isStringValueType()); [EOL]     assertFalse(NUMBER_TYPE.isEnumType()); [EOL]     assertFalse(NUMBER_TYPE.isUnionType()); [EOL]     assertFalse(NUMBER_TYPE.isStruct()); [EOL]     assertFalse(NUMBER_TYPE.isDict()); [EOL]     assertFalse(NUMBER_TYPE.isAllType()); [EOL]     assertFalse(NUMBER_TYPE.isVoidType()); [EOL]     assertFalse(NUMBER_TYPE.isConstructor()); [EOL]     assertFalse(NUMBER_TYPE.isInstanceType()); [EOL]     assertTypeEquals(NUMBER_OBJECT_TYPE, NUMBER_TYPE.autoboxesTo()); [EOL]     assertTrue(NUMBER_TYPE.isSubtype(ALL_TYPE)); [EOL]     assertFalse(NUMBER_TYPE.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertTrue(NUMBER_TYPE.isSubtype(NUMBER_TYPE)); [EOL]     assertFalse(NUMBER_TYPE.isSubtype(functionType)); [EOL]     assertFalse(NUMBER_TYPE.isSubtype(NULL_TYPE)); [EOL]     assertFalse(NUMBER_TYPE.isSubtype(OBJECT_TYPE)); [EOL]     assertFalse(NUMBER_TYPE.isSubtype(DATE_TYPE)); [EOL]     assertTrue(NUMBER_TYPE.isSubtype(unresolvedNamedType)); [EOL]     assertFalse(NUMBER_TYPE.isSubtype(namedGoogBar)); [EOL]     assertTrue(NUMBER_TYPE.isSubtype(createUnionType(NUMBER_TYPE, NULL_TYPE))); [EOL]     assertTrue(NUMBER_TYPE.isSubtype(UNKNOWN_TYPE)); [EOL]     assertFalse(NUMBER_TYPE.canBeCalled()); [EOL]     assertCanTestForEqualityWith(NUMBER_TYPE, NO_TYPE); [EOL]     assertCanTestForEqualityWith(NUMBER_TYPE, NO_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(NUMBER_TYPE, ALL_TYPE); [EOL]     assertCanTestForEqualityWith(NUMBER_TYPE, NUMBER_TYPE); [EOL]     assertCanTestForEqualityWith(NUMBER_TYPE, STRING_OBJECT_TYPE); [EOL]     assertCannotTestForEqualityWith(NUMBER_TYPE, functionType); [EOL]     assertCannotTestForEqualityWith(NUMBER_TYPE, VOID_TYPE); [EOL]     assertCanTestForEqualityWith(NUMBER_TYPE, OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(NUMBER_TYPE, DATE_TYPE); [EOL]     assertCanTestForEqualityWith(NUMBER_TYPE, REGEXP_TYPE); [EOL]     assertCanTestForEqualityWith(NUMBER_TYPE, ARRAY_TYPE); [EOL]     assertCanTestForEqualityWith(NUMBER_TYPE, UNKNOWN_TYPE); [EOL]     assertTrue(NUMBER_TYPE.canTestForShallowEqualityWith(NO_TYPE)); [EOL]     assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); [EOL]     assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); [EOL]     assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); [EOL]     assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); [EOL]     assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); [EOL]     assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); [EOL]     assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); [EOL]     assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(functionType)); [EOL]     assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); [EOL]     assertTrue(NUMBER_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); [EOL]     assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); [EOL]     assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); [EOL]     assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE)); [EOL]     assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); [EOL]     assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); [EOL]     assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); [EOL]     assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); [EOL]     assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); [EOL]     assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); [EOL]     assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); [EOL]     assertTrue(NUMBER_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); [EOL]     assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); [EOL]     assertTrue(NUMBER_TYPE.canTestForShallowEqualityWith(UNKNOWN_TYPE)); [EOL]     assertFalse(NUMBER_TYPE.isNullable()); [EOL]     assertTypeEquals(ALL_TYPE, NUMBER_TYPE.getLeastSupertype(ALL_TYPE)); [EOL]     assertTypeEquals(createUnionType(NUMBER_TYPE, STRING_OBJECT_TYPE), NUMBER_TYPE.getLeastSupertype(STRING_OBJECT_TYPE)); [EOL]     assertTypeEquals(NUMBER_TYPE, NUMBER_TYPE.getLeastSupertype(NUMBER_TYPE)); [EOL]     assertTypeEquals(createUnionType(NUMBER_TYPE, functionType), NUMBER_TYPE.getLeastSupertype(functionType)); [EOL]     assertTypeEquals(createUnionType(NUMBER_TYPE, OBJECT_TYPE), NUMBER_TYPE.getLeastSupertype(OBJECT_TYPE)); [EOL]     assertTypeEquals(createUnionType(NUMBER_TYPE, DATE_TYPE), NUMBER_TYPE.getLeastSupertype(DATE_TYPE)); [EOL]     assertTypeEquals(createUnionType(NUMBER_TYPE, REGEXP_TYPE), NUMBER_TYPE.getLeastSupertype(REGEXP_TYPE)); [EOL]     assertTrue(NUMBER_TYPE.matchesInt32Context()); [EOL]     assertTrue(NUMBER_TYPE.matchesNumberContext()); [EOL]     assertTrue(NUMBER_TYPE.matchesObjectContext()); [EOL]     assertTrue(NUMBER_TYPE.matchesStringContext()); [EOL]     assertTrue(NUMBER_TYPE.matchesUint32Context()); [EOL]     assertEquals("number", NUMBER_TYPE.toString()); [EOL]     assertTrue(NUMBER_TYPE.hasDisplayName()); [EOL]     assertEquals("number", NUMBER_TYPE.getDisplayName()); [EOL]     Asserts.assertResolvesToSame(NUMBER_TYPE); [EOL]     assertFalse(NUMBER_TYPE.isNominalConstructor()); [EOL] } <line_num>: 1532,1652
public void testNullType() throws Exception { [EOL]     assertFalse(NULL_TYPE.isArrayType()); [EOL]     assertFalse(NULL_TYPE.isBooleanValueType()); [EOL]     assertFalse(NULL_TYPE.isDateType()); [EOL]     assertFalse(NULL_TYPE.isEnumElementType()); [EOL]     assertFalse(NULL_TYPE.isNamedType()); [EOL]     assertTrue(NULL_TYPE.isNullType()); [EOL]     assertFalse(NULL_TYPE.isNumber()); [EOL]     assertFalse(NULL_TYPE.isNumberObjectType()); [EOL]     assertFalse(NULL_TYPE.isNumberValueType()); [EOL]     assertFalse(NULL_TYPE.isFunctionPrototypeType()); [EOL]     assertFalse(NULL_TYPE.isRegexpType()); [EOL]     assertFalse(NULL_TYPE.isString()); [EOL]     assertFalse(NULL_TYPE.isStringObjectType()); [EOL]     assertFalse(NULL_TYPE.isStringValueType()); [EOL]     assertFalse(NULL_TYPE.isEnumType()); [EOL]     assertFalse(NULL_TYPE.isUnionType()); [EOL]     assertFalse(NULL_TYPE.isStruct()); [EOL]     assertFalse(NULL_TYPE.isDict()); [EOL]     assertFalse(NULL_TYPE.isAllType()); [EOL]     assertFalse(NULL_TYPE.isVoidType()); [EOL]     assertFalse(NULL_TYPE.isConstructor()); [EOL]     assertFalse(NULL_TYPE.isInstanceType()); [EOL]     assertNull(NULL_TYPE.autoboxesTo()); [EOL]     assertFalse(NULL_TYPE.isSubtype(NO_OBJECT_TYPE)); [EOL]     assertFalse(NULL_TYPE.isSubtype(NO_TYPE)); [EOL]     assertTrue(NULL_TYPE.isSubtype(NULL_TYPE)); [EOL]     assertTrue(NULL_TYPE.isSubtype(ALL_TYPE)); [EOL]     assertFalse(NULL_TYPE.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertFalse(NULL_TYPE.isSubtype(NUMBER_TYPE)); [EOL]     assertFalse(NULL_TYPE.isSubtype(functionType)); [EOL]     assertFalse(NULL_TYPE.isSubtype(OBJECT_TYPE)); [EOL]     assertFalse(NULL_TYPE.isSubtype(DATE_TYPE)); [EOL]     assertFalse(NULL_TYPE.isSubtype(REGEXP_TYPE)); [EOL]     assertFalse(NULL_TYPE.isSubtype(ARRAY_TYPE)); [EOL]     assertTrue(NULL_TYPE.isSubtype(UNKNOWN_TYPE)); [EOL]     assertTrue(NULL_TYPE.isSubtype(createNullableType(NO_OBJECT_TYPE))); [EOL]     assertTrue(NULL_TYPE.isSubtype(createNullableType(NO_TYPE))); [EOL]     assertTrue(NULL_TYPE.isSubtype(createNullableType(NULL_TYPE))); [EOL]     assertTrue(NULL_TYPE.isSubtype(createNullableType(ALL_TYPE))); [EOL]     assertTrue(NULL_TYPE.isSubtype(createNullableType(STRING_OBJECT_TYPE))); [EOL]     assertTrue(NULL_TYPE.isSubtype(createNullableType(NUMBER_TYPE))); [EOL]     assertTrue(NULL_TYPE.isSubtype(createNullableType(functionType))); [EOL]     assertTrue(NULL_TYPE.isSubtype(createNullableType(OBJECT_TYPE))); [EOL]     assertTrue(NULL_TYPE.isSubtype(createNullableType(DATE_TYPE))); [EOL]     assertTrue(NULL_TYPE.isSubtype(createNullableType(REGEXP_TYPE))); [EOL]     assertTrue(NULL_TYPE.isSubtype(createNullableType(ARRAY_TYPE))); [EOL]     assertFalse(NULL_TYPE.canBeCalled()); [EOL]     assertCanTestForEqualityWith(NULL_TYPE, NO_TYPE); [EOL]     assertCanTestForEqualityWith(NULL_TYPE, NO_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(NULL_TYPE, ALL_TYPE); [EOL]     assertCannotTestForEqualityWith(NULL_TYPE, ARRAY_TYPE); [EOL]     assertCannotTestForEqualityWith(NULL_TYPE, BOOLEAN_TYPE); [EOL]     assertCannotTestForEqualityWith(NULL_TYPE, BOOLEAN_OBJECT_TYPE); [EOL]     assertCannotTestForEqualityWith(NULL_TYPE, DATE_TYPE); [EOL]     assertCannotTestForEqualityWith(NULL_TYPE, ERROR_TYPE); [EOL]     assertCannotTestForEqualityWith(NULL_TYPE, EVAL_ERROR_TYPE); [EOL]     assertCannotTestForEqualityWith(NULL_TYPE, functionType); [EOL]     assertCannotTestForEqualityWith(NULL_TYPE, NULL_TYPE); [EOL]     assertCannotTestForEqualityWith(NULL_TYPE, NUMBER_TYPE); [EOL]     assertCannotTestForEqualityWith(NULL_TYPE, NUMBER_OBJECT_TYPE); [EOL]     assertCannotTestForEqualityWith(NULL_TYPE, OBJECT_TYPE); [EOL]     assertCannotTestForEqualityWith(NULL_TYPE, URI_ERROR_TYPE); [EOL]     assertCannotTestForEqualityWith(NULL_TYPE, RANGE_ERROR_TYPE); [EOL]     assertCannotTestForEqualityWith(NULL_TYPE, REFERENCE_ERROR_TYPE); [EOL]     assertCannotTestForEqualityWith(NULL_TYPE, REGEXP_TYPE); [EOL]     assertCannotTestForEqualityWith(NULL_TYPE, STRING_TYPE); [EOL]     assertCannotTestForEqualityWith(NULL_TYPE, STRING_OBJECT_TYPE); [EOL]     assertCannotTestForEqualityWith(NULL_TYPE, SYNTAX_ERROR_TYPE); [EOL]     assertCannotTestForEqualityWith(NULL_TYPE, TYPE_ERROR_TYPE); [EOL]     assertCannotTestForEqualityWith(NULL_TYPE, VOID_TYPE); [EOL]     assertTrue(NULL_TYPE.canTestForShallowEqualityWith(NO_TYPE)); [EOL]     assertFalse(NULL_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); [EOL]     assertFalse(NULL_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); [EOL]     assertFalse(NULL_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); [EOL]     assertFalse(NULL_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); [EOL]     assertFalse(NULL_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); [EOL]     assertFalse(NULL_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); [EOL]     assertFalse(NULL_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); [EOL]     assertFalse(NULL_TYPE.canTestForShallowEqualityWith(functionType)); [EOL]     assertTrue(NULL_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); [EOL]     assertFalse(NULL_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); [EOL]     assertFalse(NULL_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); [EOL]     assertFalse(NULL_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); [EOL]     assertFalse(NULL_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE)); [EOL]     assertFalse(NULL_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); [EOL]     assertFalse(NULL_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); [EOL]     assertFalse(NULL_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); [EOL]     assertFalse(NULL_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); [EOL]     assertFalse(NULL_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); [EOL]     assertFalse(NULL_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); [EOL]     assertFalse(NULL_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); [EOL]     assertTrue(NULL_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); [EOL]     assertFalse(NULL_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); [EOL]     assertTrue(NULL_TYPE.canTestForShallowEqualityWith(createNullableType(STRING_OBJECT_TYPE))); [EOL]     assertTypeEquals(NULL_TYPE, NULL_TYPE.getLeastSupertype(NULL_TYPE)); [EOL]     assertTypeEquals(ALL_TYPE, NULL_TYPE.getLeastSupertype(ALL_TYPE)); [EOL]     assertTypeEquals(createNullableType(STRING_OBJECT_TYPE), NULL_TYPE.getLeastSupertype(STRING_OBJECT_TYPE)); [EOL]     assertTypeEquals(createNullableType(NUMBER_TYPE), NULL_TYPE.getLeastSupertype(NUMBER_TYPE)); [EOL]     assertTypeEquals(createNullableType(functionType), NULL_TYPE.getLeastSupertype(functionType)); [EOL]     assertTypeEquals(createNullableType(OBJECT_TYPE), NULL_TYPE.getLeastSupertype(OBJECT_TYPE)); [EOL]     assertTypeEquals(createNullableType(DATE_TYPE), NULL_TYPE.getLeastSupertype(DATE_TYPE)); [EOL]     assertTypeEquals(createNullableType(REGEXP_TYPE), NULL_TYPE.getLeastSupertype(REGEXP_TYPE)); [EOL]     assertTrue(NULL_TYPE.matchesInt32Context()); [EOL]     assertTrue(NULL_TYPE.matchesNumberContext()); [EOL]     assertFalse(NULL_TYPE.matchesObjectContext()); [EOL]     assertTrue(NULL_TYPE.matchesStringContext()); [EOL]     assertTrue(NULL_TYPE.matchesUint32Context()); [EOL]     assertFalse(NULL_TYPE.matchesObjectContext()); [EOL]     assertEquals("null", NULL_TYPE.toString()); [EOL]     assertTrue(NULL_TYPE.hasDisplayName()); [EOL]     assertEquals("null", NULL_TYPE.getDisplayName()); [EOL]     Asserts.assertResolvesToSame(NULL_TYPE); [EOL]     assertTrue(NULL_TYPE.isSubtype(createUnionType(forwardDeclaredNamedType, NULL_TYPE))); [EOL]     assertTypeEquals(createUnionType(forwardDeclaredNamedType, NULL_TYPE), NULL_TYPE.getGreatestSubtype(createUnionType(forwardDeclaredNamedType, NULL_TYPE))); [EOL]     assertFalse(NULL_TYPE.isNominalConstructor()); [EOL]     assertTrue(NULL_TYPE.differsFrom(UNKNOWN_TYPE)); [EOL] } <line_num>: 1657,1813
public void testDateType() throws Exception { [EOL]     assertFalse(DATE_TYPE.isArrayType()); [EOL]     assertFalse(DATE_TYPE.isBooleanValueType()); [EOL]     assertTrue(DATE_TYPE.isDateType()); [EOL]     assertFalse(DATE_TYPE.isEnumElementType()); [EOL]     assertFalse(DATE_TYPE.isNamedType()); [EOL]     assertFalse(DATE_TYPE.isNullType()); [EOL]     assertFalse(DATE_TYPE.isNumberValueType()); [EOL]     assertFalse(DATE_TYPE.isFunctionPrototypeType()); [EOL]     assertTrue(DATE_TYPE.getImplicitPrototype().isFunctionPrototypeType()); [EOL]     assertFalse(DATE_TYPE.isRegexpType()); [EOL]     assertFalse(DATE_TYPE.isStringValueType()); [EOL]     assertFalse(DATE_TYPE.isEnumType()); [EOL]     assertFalse(DATE_TYPE.isUnionType()); [EOL]     assertFalse(DATE_TYPE.isStruct()); [EOL]     assertFalse(DATE_TYPE.isDict()); [EOL]     assertFalse(DATE_TYPE.isAllType()); [EOL]     assertFalse(DATE_TYPE.isVoidType()); [EOL]     assertFalse(DATE_TYPE.isConstructor()); [EOL]     assertTrue(DATE_TYPE.isInstanceType()); [EOL]     assertNull(DATE_TYPE.autoboxesTo()); [EOL]     assertFalse(DATE_TYPE.isSubtype(NO_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(NO_OBJECT_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(ARRAY_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(BOOLEAN_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE)); [EOL]     assertTrue(DATE_TYPE.isSubtype(DATE_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(ERROR_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(EVAL_ERROR_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(functionType)); [EOL]     assertFalse(DATE_TYPE.isSubtype(NULL_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(NUMBER_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(NUMBER_OBJECT_TYPE)); [EOL]     assertTrue(DATE_TYPE.isSubtype(OBJECT_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(URI_ERROR_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(RANGE_ERROR_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(REFERENCE_ERROR_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(REGEXP_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(STRING_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(SYNTAX_ERROR_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(TYPE_ERROR_TYPE)); [EOL]     assertTrue(DATE_TYPE.isSubtype(ALL_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(VOID_TYPE)); [EOL]     assertFalse(DATE_TYPE.canBeCalled()); [EOL]     assertCanTestForEqualityWith(DATE_TYPE, ALL_TYPE); [EOL]     assertCanTestForEqualityWith(DATE_TYPE, STRING_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(DATE_TYPE, NUMBER_TYPE); [EOL]     assertCanTestForEqualityWith(DATE_TYPE, functionType); [EOL]     assertCannotTestForEqualityWith(DATE_TYPE, VOID_TYPE); [EOL]     assertCanTestForEqualityWith(DATE_TYPE, OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(DATE_TYPE, DATE_TYPE); [EOL]     assertCanTestForEqualityWith(DATE_TYPE, REGEXP_TYPE); [EOL]     assertCanTestForEqualityWith(DATE_TYPE, ARRAY_TYPE); [EOL]     assertTrue(DATE_TYPE.canTestForShallowEqualityWith(NO_TYPE)); [EOL]     assertTrue(DATE_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); [EOL]     assertFalse(DATE_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); [EOL]     assertFalse(DATE_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); [EOL]     assertFalse(DATE_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); [EOL]     assertTrue(DATE_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); [EOL]     assertFalse(DATE_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); [EOL]     assertFalse(DATE_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); [EOL]     assertFalse(DATE_TYPE.canTestForShallowEqualityWith(functionType)); [EOL]     assertFalse(DATE_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); [EOL]     assertFalse(DATE_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); [EOL]     assertFalse(DATE_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); [EOL]     assertTrue(DATE_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); [EOL]     assertFalse(DATE_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE)); [EOL]     assertFalse(DATE_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); [EOL]     assertFalse(DATE_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); [EOL]     assertFalse(DATE_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); [EOL]     assertFalse(DATE_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); [EOL]     assertFalse(DATE_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); [EOL]     assertFalse(DATE_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); [EOL]     assertFalse(DATE_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); [EOL]     assertTrue(DATE_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); [EOL]     assertFalse(DATE_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); [EOL]     assertFalse(DATE_TYPE.isNullable()); [EOL]     assertTrue(createNullableType(DATE_TYPE).isNullable()); [EOL]     assertTypeEquals(ALL_TYPE, DATE_TYPE.getLeastSupertype(ALL_TYPE)); [EOL]     assertTypeEquals(createUnionType(DATE_TYPE, STRING_OBJECT_TYPE), DATE_TYPE.getLeastSupertype(STRING_OBJECT_TYPE)); [EOL]     assertTypeEquals(createUnionType(DATE_TYPE, NUMBER_TYPE), DATE_TYPE.getLeastSupertype(NUMBER_TYPE)); [EOL]     assertTypeEquals(createUnionType(DATE_TYPE, functionType), DATE_TYPE.getLeastSupertype(functionType)); [EOL]     assertTypeEquals(OBJECT_TYPE, DATE_TYPE.getLeastSupertype(OBJECT_TYPE)); [EOL]     assertTypeEquals(DATE_TYPE, DATE_TYPE.getLeastSupertype(DATE_TYPE)); [EOL]     assertTypeEquals(createUnionType(DATE_TYPE, REGEXP_TYPE), DATE_TYPE.getLeastSupertype(REGEXP_TYPE)); [EOL]     assertEquals(46, DATE_TYPE.getImplicitPrototype().getPropertiesCount()); [EOL]     assertEquals(46, DATE_TYPE.getPropertiesCount()); [EOL]     assertReturnTypeEquals(DATE_TYPE, DATE_TYPE.getPropertyType("constructor")); [EOL]     assertReturnTypeEquals(STRING_TYPE, DATE_TYPE.getPropertyType("toString")); [EOL]     assertReturnTypeEquals(STRING_TYPE, DATE_TYPE.getPropertyType("toDateString")); [EOL]     assertReturnTypeEquals(STRING_TYPE, DATE_TYPE.getPropertyType("toTimeString")); [EOL]     assertReturnTypeEquals(STRING_TYPE, DATE_TYPE.getPropertyType("toLocaleString")); [EOL]     assertReturnTypeEquals(STRING_TYPE, DATE_TYPE.getPropertyType("toLocaleDateString")); [EOL]     assertReturnTypeEquals(STRING_TYPE, DATE_TYPE.getPropertyType("toLocaleTimeString")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("valueOf")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getTime")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getFullYear")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getUTCFullYear")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getMonth")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getUTCMonth")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getDate")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getUTCDate")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getDay")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getUTCDay")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getHours")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getUTCHours")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getMinutes")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getUTCMinutes")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getSeconds")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getUTCSeconds")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getMilliseconds")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getUTCMilliseconds")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getTimezoneOffset")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setTime")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setMilliseconds")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setUTCMilliseconds")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setSeconds")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setUTCSeconds")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setUTCSeconds")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setMinutes")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setUTCMinutes")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setHours")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setUTCHours")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setDate")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setUTCDate")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setMonth")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setUTCMonth")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setFullYear")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setUTCFullYear")); [EOL]     assertReturnTypeEquals(STRING_TYPE, DATE_TYPE.getPropertyType("toUTCString")); [EOL]     assertReturnTypeEquals(STRING_TYPE, DATE_TYPE.getPropertyType("toGMTString")); [EOL]     assertTrue(DATE_TYPE.matchesInt32Context()); [EOL]     assertTrue(DATE_TYPE.matchesNumberContext()); [EOL]     assertTrue(DATE_TYPE.matchesObjectContext()); [EOL]     assertTrue(DATE_TYPE.matchesStringContext()); [EOL]     assertTrue(DATE_TYPE.matchesUint32Context()); [EOL]     assertEquals("Date", DATE_TYPE.toString()); [EOL]     assertTrue(DATE_TYPE.hasDisplayName()); [EOL]     assertEquals("Date", DATE_TYPE.getDisplayName()); [EOL]     assertTrue(DATE_TYPE.isNativeObjectType()); [EOL]     Asserts.assertResolvesToSame(DATE_TYPE); [EOL]     assertFalse(DATE_TYPE.isNominalConstructor()); [EOL]     assertTrue(DATE_TYPE.getConstructor().isNominalConstructor()); [EOL] } <line_num>: 1818,2024
public void testRegExpType() throws Exception { [EOL]     assertFalse(REGEXP_TYPE.isNoType()); [EOL]     assertFalse(REGEXP_TYPE.isNoObjectType()); [EOL]     assertFalse(REGEXP_TYPE.isArrayType()); [EOL]     assertFalse(REGEXP_TYPE.isBooleanValueType()); [EOL]     assertFalse(REGEXP_TYPE.isDateType()); [EOL]     assertFalse(REGEXP_TYPE.isEnumElementType()); [EOL]     assertFalse(REGEXP_TYPE.isNamedType()); [EOL]     assertFalse(REGEXP_TYPE.isNullType()); [EOL]     assertFalse(REGEXP_TYPE.isNumberValueType()); [EOL]     assertFalse(REGEXP_TYPE.isFunctionPrototypeType()); [EOL]     assertTrue(REGEXP_TYPE.getImplicitPrototype().isFunctionPrototypeType()); [EOL]     assertTrue(REGEXP_TYPE.isRegexpType()); [EOL]     assertFalse(REGEXP_TYPE.isStringValueType()); [EOL]     assertFalse(REGEXP_TYPE.isEnumType()); [EOL]     assertFalse(REGEXP_TYPE.isUnionType()); [EOL]     assertFalse(REGEXP_TYPE.isStruct()); [EOL]     assertFalse(REGEXP_TYPE.isDict()); [EOL]     assertFalse(REGEXP_TYPE.isAllType()); [EOL]     assertFalse(REGEXP_TYPE.isVoidType()); [EOL]     assertNull(REGEXP_TYPE.autoboxesTo()); [EOL]     assertFalse(REGEXP_TYPE.isSubtype(NO_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.isSubtype(NO_OBJECT_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.isSubtype(ARRAY_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.isSubtype(BOOLEAN_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.isSubtype(DATE_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.isSubtype(ERROR_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.isSubtype(EVAL_ERROR_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.isSubtype(functionType)); [EOL]     assertFalse(REGEXP_TYPE.isSubtype(NULL_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.isSubtype(NUMBER_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.isSubtype(NUMBER_OBJECT_TYPE)); [EOL]     assertTrue(REGEXP_TYPE.isSubtype(OBJECT_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.isSubtype(URI_ERROR_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.isSubtype(RANGE_ERROR_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.isSubtype(REFERENCE_ERROR_TYPE)); [EOL]     assertTrue(REGEXP_TYPE.isSubtype(REGEXP_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.isSubtype(STRING_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.isSubtype(SYNTAX_ERROR_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.isSubtype(TYPE_ERROR_TYPE)); [EOL]     assertTrue(REGEXP_TYPE.isSubtype(ALL_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.isSubtype(VOID_TYPE)); [EOL]     assertTrue(REGEXP_TYPE.canBeCalled()); [EOL]     assertCanTestForEqualityWith(REGEXP_TYPE, ALL_TYPE); [EOL]     assertCanTestForEqualityWith(REGEXP_TYPE, STRING_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(REGEXP_TYPE, NUMBER_TYPE); [EOL]     assertCanTestForEqualityWith(REGEXP_TYPE, functionType); [EOL]     assertCannotTestForEqualityWith(REGEXP_TYPE, VOID_TYPE); [EOL]     assertCanTestForEqualityWith(REGEXP_TYPE, OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(REGEXP_TYPE, DATE_TYPE); [EOL]     assertCanTestForEqualityWith(REGEXP_TYPE, REGEXP_TYPE); [EOL]     assertCanTestForEqualityWith(REGEXP_TYPE, ARRAY_TYPE); [EOL]     assertTrue(REGEXP_TYPE.canTestForShallowEqualityWith(NO_TYPE)); [EOL]     assertTrue(REGEXP_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(functionType)); [EOL]     assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); [EOL]     assertTrue(REGEXP_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); [EOL]     assertTrue(REGEXP_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); [EOL]     assertTrue(REGEXP_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); [EOL]     assertFalse(REGEXP_TYPE.isNullable()); [EOL]     assertTrue(createNullableType(REGEXP_TYPE).isNullable()); [EOL]     assertTypeEquals(ALL_TYPE, REGEXP_TYPE.getLeastSupertype(ALL_TYPE)); [EOL]     assertTypeEquals(createUnionType(REGEXP_TYPE, STRING_OBJECT_TYPE), REGEXP_TYPE.getLeastSupertype(STRING_OBJECT_TYPE)); [EOL]     assertTypeEquals(createUnionType(REGEXP_TYPE, NUMBER_TYPE), REGEXP_TYPE.getLeastSupertype(NUMBER_TYPE)); [EOL]     assertTypeEquals(createUnionType(REGEXP_TYPE, functionType), REGEXP_TYPE.getLeastSupertype(functionType)); [EOL]     assertTypeEquals(OBJECT_TYPE, REGEXP_TYPE.getLeastSupertype(OBJECT_TYPE)); [EOL]     assertTypeEquals(createUnionType(DATE_TYPE, REGEXP_TYPE), REGEXP_TYPE.getLeastSupertype(DATE_TYPE)); [EOL]     assertTypeEquals(REGEXP_TYPE, REGEXP_TYPE.getLeastSupertype(REGEXP_TYPE)); [EOL]     assertEquals(9, REGEXP_TYPE.getImplicitPrototype().getPropertiesCount()); [EOL]     assertEquals(14, REGEXP_TYPE.getPropertiesCount()); [EOL]     assertReturnTypeEquals(REGEXP_TYPE, REGEXP_TYPE.getPropertyType("constructor")); [EOL]     assertReturnTypeEquals(createNullableType(ARRAY_TYPE), REGEXP_TYPE.getPropertyType("exec")); [EOL]     assertReturnTypeEquals(BOOLEAN_TYPE, REGEXP_TYPE.getPropertyType("test")); [EOL]     assertReturnTypeEquals(STRING_TYPE, REGEXP_TYPE.getPropertyType("toString")); [EOL]     assertTypeEquals(STRING_TYPE, REGEXP_TYPE.getPropertyType("source")); [EOL]     assertTypeEquals(BOOLEAN_TYPE, REGEXP_TYPE.getPropertyType("global")); [EOL]     assertTypeEquals(BOOLEAN_TYPE, REGEXP_TYPE.getPropertyType("ignoreCase")); [EOL]     assertTypeEquals(BOOLEAN_TYPE, REGEXP_TYPE.getPropertyType("multiline")); [EOL]     assertTypeEquals(NUMBER_TYPE, REGEXP_TYPE.getPropertyType("lastIndex")); [EOL]     assertFalse(REGEXP_TYPE.matchesInt32Context()); [EOL]     assertFalse(REGEXP_TYPE.matchesNumberContext()); [EOL]     assertTrue(REGEXP_TYPE.matchesObjectContext()); [EOL]     assertTrue(REGEXP_TYPE.matchesStringContext()); [EOL]     assertFalse(REGEXP_TYPE.matchesUint32Context()); [EOL]     assertEquals("RegExp", REGEXP_TYPE.toString()); [EOL]     assertTrue(REGEXP_TYPE.hasDisplayName()); [EOL]     assertEquals("RegExp", REGEXP_TYPE.getDisplayName()); [EOL]     assertTrue(REGEXP_TYPE.isNativeObjectType()); [EOL]     Asserts.assertResolvesToSame(REGEXP_TYPE); [EOL]     assertFalse(REGEXP_TYPE.isNominalConstructor()); [EOL]     assertTrue(REGEXP_TYPE.getConstructor().isNominalConstructor()); [EOL] } <line_num>: 2029,2173
public void testStringObjectType() throws Exception { [EOL]     assertFalse(STRING_OBJECT_TYPE.isArrayType()); [EOL]     assertFalse(STRING_OBJECT_TYPE.isBooleanObjectType()); [EOL]     assertFalse(STRING_OBJECT_TYPE.isBooleanValueType()); [EOL]     assertFalse(STRING_OBJECT_TYPE.isDateType()); [EOL]     assertFalse(STRING_OBJECT_TYPE.isEnumElementType()); [EOL]     assertFalse(STRING_OBJECT_TYPE.isNamedType()); [EOL]     assertFalse(STRING_OBJECT_TYPE.isNullType()); [EOL]     assertFalse(STRING_OBJECT_TYPE.isNumber()); [EOL]     assertFalse(STRING_OBJECT_TYPE.isNumberObjectType()); [EOL]     assertFalse(STRING_OBJECT_TYPE.isNumberValueType()); [EOL]     assertFalse(STRING_OBJECT_TYPE.isFunctionPrototypeType()); [EOL]     assertTrue(STRING_OBJECT_TYPE.getImplicitPrototype().isFunctionPrototypeType()); [EOL]     assertFalse(STRING_OBJECT_TYPE.isRegexpType()); [EOL]     assertTrue(STRING_OBJECT_TYPE.isString()); [EOL]     assertTrue(STRING_OBJECT_TYPE.isStringObjectType()); [EOL]     assertFalse(STRING_OBJECT_TYPE.isStringValueType()); [EOL]     assertFalse(STRING_OBJECT_TYPE.isEnumType()); [EOL]     assertFalse(STRING_OBJECT_TYPE.isUnionType()); [EOL]     assertFalse(STRING_OBJECT_TYPE.isStruct()); [EOL]     assertFalse(STRING_OBJECT_TYPE.isDict()); [EOL]     assertFalse(STRING_OBJECT_TYPE.isAllType()); [EOL]     assertFalse(STRING_OBJECT_TYPE.isVoidType()); [EOL]     assertFalse(STRING_OBJECT_TYPE.isConstructor()); [EOL]     assertTrue(STRING_OBJECT_TYPE.isInstanceType()); [EOL]     assertTypeEquals(STRING_OBJECT_TYPE, STRING_TYPE.autoboxesTo()); [EOL]     assertTypeEquals(STRING_TYPE, STRING_OBJECT_TYPE.unboxesTo()); [EOL]     assertTrue(STRING_OBJECT_TYPE.isSubtype(ALL_TYPE)); [EOL]     assertTrue(STRING_OBJECT_TYPE.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertFalse(STRING_OBJECT_TYPE.isSubtype(STRING_TYPE)); [EOL]     assertTrue(STRING_OBJECT_TYPE.isSubtype(OBJECT_TYPE)); [EOL]     assertFalse(STRING_OBJECT_TYPE.isSubtype(NUMBER_TYPE)); [EOL]     assertFalse(STRING_OBJECT_TYPE.isSubtype(DATE_TYPE)); [EOL]     assertFalse(STRING_OBJECT_TYPE.isSubtype(REGEXP_TYPE)); [EOL]     assertFalse(STRING_OBJECT_TYPE.isSubtype(ARRAY_TYPE)); [EOL]     assertFalse(STRING_OBJECT_TYPE.isSubtype(STRING_TYPE)); [EOL]     assertFalse(STRING_OBJECT_TYPE.canBeCalled()); [EOL]     assertCanTestForEqualityWith(STRING_OBJECT_TYPE, ALL_TYPE); [EOL]     assertCanTestForEqualityWith(STRING_OBJECT_TYPE, STRING_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(STRING_OBJECT_TYPE, STRING_TYPE); [EOL]     assertCanTestForEqualityWith(STRING_OBJECT_TYPE, functionType); [EOL]     assertCanTestForEqualityWith(STRING_OBJECT_TYPE, OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(STRING_OBJECT_TYPE, NUMBER_TYPE); [EOL]     assertCanTestForEqualityWith(STRING_OBJECT_TYPE, BOOLEAN_TYPE); [EOL]     assertCanTestForEqualityWith(STRING_OBJECT_TYPE, BOOLEAN_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(STRING_OBJECT_TYPE, DATE_TYPE); [EOL]     assertCanTestForEqualityWith(STRING_OBJECT_TYPE, REGEXP_TYPE); [EOL]     assertCanTestForEqualityWith(STRING_OBJECT_TYPE, ARRAY_TYPE); [EOL]     assertCanTestForEqualityWith(STRING_OBJECT_TYPE, UNKNOWN_TYPE); [EOL]     assertTrue(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(NO_TYPE)); [EOL]     assertTrue(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); [EOL]     assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); [EOL]     assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); [EOL]     assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); [EOL]     assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); [EOL]     assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); [EOL]     assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); [EOL]     assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(functionType)); [EOL]     assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); [EOL]     assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); [EOL]     assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); [EOL]     assertTrue(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); [EOL]     assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE)); [EOL]     assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); [EOL]     assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); [EOL]     assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); [EOL]     assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); [EOL]     assertTrue(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); [EOL]     assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); [EOL]     assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); [EOL]     assertTrue(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); [EOL]     assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); [EOL]     assertTrue(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(UNKNOWN_TYPE)); [EOL]     assertEquals(23, STRING_OBJECT_TYPE.getImplicitPrototype().getPropertiesCount()); [EOL]     assertEquals(24, STRING_OBJECT_TYPE.getPropertiesCount()); [EOL]     assertReturnTypeEquals(STRING_TYPE, STRING_OBJECT_TYPE.getPropertyType("toString")); [EOL]     assertReturnTypeEquals(STRING_TYPE, STRING_OBJECT_TYPE.getPropertyType("valueOf")); [EOL]     assertReturnTypeEquals(STRING_TYPE, STRING_OBJECT_TYPE.getPropertyType("charAt")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, STRING_OBJECT_TYPE.getPropertyType("charCodeAt")); [EOL]     assertReturnTypeEquals(STRING_TYPE, STRING_OBJECT_TYPE.getPropertyType("concat")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, STRING_OBJECT_TYPE.getPropertyType("indexOf")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, STRING_OBJECT_TYPE.getPropertyType("lastIndexOf")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, STRING_OBJECT_TYPE.getPropertyType("localeCompare")); [EOL]     assertReturnTypeEquals(createNullableType(ARRAY_TYPE), STRING_OBJECT_TYPE.getPropertyType("match")); [EOL]     assertReturnTypeEquals(STRING_TYPE, STRING_OBJECT_TYPE.getPropertyType("replace")); [EOL]     assertReturnTypeEquals(NUMBER_TYPE, STRING_OBJECT_TYPE.getPropertyType("search")); [EOL]     assertReturnTypeEquals(STRING_TYPE, STRING_OBJECT_TYPE.getPropertyType("slice")); [EOL]     assertReturnTypeEquals(ARRAY_TYPE, STRING_OBJECT_TYPE.getPropertyType("split")); [EOL]     assertReturnTypeEquals(STRING_TYPE, STRING_OBJECT_TYPE.getPropertyType("substring")); [EOL]     assertReturnTypeEquals(STRING_TYPE, STRING_OBJECT_TYPE.getPropertyType("toLowerCase")); [EOL]     assertReturnTypeEquals(STRING_TYPE, STRING_OBJECT_TYPE.getPropertyType("toLocaleLowerCase")); [EOL]     assertReturnTypeEquals(STRING_TYPE, STRING_OBJECT_TYPE.getPropertyType("toUpperCase")); [EOL]     assertReturnTypeEquals(STRING_TYPE, STRING_OBJECT_TYPE.getPropertyType("toLocaleUpperCase")); [EOL]     assertTypeEquals(NUMBER_TYPE, STRING_OBJECT_TYPE.getPropertyType("length")); [EOL]     assertTrue(STRING_OBJECT_TYPE.matchesInt32Context()); [EOL]     assertTrue(STRING_OBJECT_TYPE.matchesNumberContext()); [EOL]     assertTrue(STRING_OBJECT_TYPE.matchesObjectContext()); [EOL]     assertTrue(STRING_OBJECT_TYPE.matchesStringContext()); [EOL]     assertTrue(STRING_OBJECT_TYPE.matchesUint32Context()); [EOL]     assertFalse(STRING_OBJECT_TYPE.isNullable()); [EOL]     assertTrue(createNullableType(STRING_OBJECT_TYPE).isNullable()); [EOL]     assertTrue(STRING_OBJECT_TYPE.isNativeObjectType()); [EOL]     Asserts.assertResolvesToSame(STRING_OBJECT_TYPE); [EOL]     assertTrue(STRING_OBJECT_TYPE.hasDisplayName()); [EOL]     assertEquals("String", STRING_OBJECT_TYPE.getDisplayName()); [EOL]     assertFalse(STRING_OBJECT_TYPE.isNominalConstructor()); [EOL]     assertTrue(STRING_OBJECT_TYPE.getConstructor().isNominalConstructor()); [EOL] } <line_num>: 2178,2338
public void testStringValueType() throws Exception { [EOL]     assertFalse(STRING_TYPE.isArrayType()); [EOL]     assertFalse(STRING_TYPE.isBooleanObjectType()); [EOL]     assertFalse(STRING_TYPE.isBooleanValueType()); [EOL]     assertFalse(STRING_TYPE.isDateType()); [EOL]     assertFalse(STRING_TYPE.isEnumElementType()); [EOL]     assertFalse(STRING_TYPE.isNamedType()); [EOL]     assertFalse(STRING_TYPE.isNullType()); [EOL]     assertFalse(STRING_TYPE.isNumber()); [EOL]     assertFalse(STRING_TYPE.isNumberObjectType()); [EOL]     assertFalse(STRING_TYPE.isNumberValueType()); [EOL]     assertFalse(STRING_TYPE.isFunctionPrototypeType()); [EOL]     assertFalse(STRING_TYPE.isRegexpType()); [EOL]     assertTrue(STRING_TYPE.isString()); [EOL]     assertFalse(STRING_TYPE.isStringObjectType()); [EOL]     assertTrue(STRING_TYPE.isStringValueType()); [EOL]     assertFalse(STRING_TYPE.isEnumType()); [EOL]     assertFalse(STRING_TYPE.isUnionType()); [EOL]     assertFalse(STRING_TYPE.isStruct()); [EOL]     assertFalse(STRING_TYPE.isDict()); [EOL]     assertFalse(STRING_TYPE.isAllType()); [EOL]     assertFalse(STRING_TYPE.isVoidType()); [EOL]     assertFalse(STRING_TYPE.isConstructor()); [EOL]     assertFalse(STRING_TYPE.isInstanceType()); [EOL]     assertTypeEquals(STRING_OBJECT_TYPE, STRING_TYPE.autoboxesTo()); [EOL]     assertTypeEquals(STRING_TYPE, STRING_OBJECT_TYPE.unboxesTo()); [EOL]     assertTrue(STRING_TYPE.isSubtype(ALL_TYPE)); [EOL]     assertFalse(STRING_TYPE.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertFalse(STRING_TYPE.isSubtype(NUMBER_TYPE)); [EOL]     assertFalse(STRING_TYPE.isSubtype(OBJECT_TYPE)); [EOL]     assertFalse(STRING_TYPE.isSubtype(NUMBER_TYPE)); [EOL]     assertFalse(STRING_TYPE.isSubtype(DATE_TYPE)); [EOL]     assertFalse(STRING_TYPE.isSubtype(REGEXP_TYPE)); [EOL]     assertFalse(STRING_TYPE.isSubtype(ARRAY_TYPE)); [EOL]     assertTrue(STRING_TYPE.isSubtype(STRING_TYPE)); [EOL]     assertTrue(STRING_TYPE.isSubtype(UNKNOWN_TYPE)); [EOL]     assertFalse(STRING_TYPE.canBeCalled()); [EOL]     assertCanTestForEqualityWith(STRING_TYPE, ALL_TYPE); [EOL]     assertCanTestForEqualityWith(STRING_TYPE, STRING_OBJECT_TYPE); [EOL]     assertCannotTestForEqualityWith(STRING_TYPE, functionType); [EOL]     assertCanTestForEqualityWith(STRING_TYPE, OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(STRING_TYPE, NUMBER_TYPE); [EOL]     assertCanTestForEqualityWith(STRING_TYPE, BOOLEAN_TYPE); [EOL]     assertCanTestForEqualityWith(STRING_TYPE, BOOLEAN_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(STRING_TYPE, DATE_TYPE); [EOL]     assertCanTestForEqualityWith(STRING_TYPE, REGEXP_TYPE); [EOL]     assertCanTestForEqualityWith(STRING_TYPE, ARRAY_TYPE); [EOL]     assertCanTestForEqualityWith(STRING_TYPE, UNKNOWN_TYPE); [EOL]     assertTrue(STRING_TYPE.canTestForShallowEqualityWith(NO_TYPE)); [EOL]     assertFalse(STRING_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); [EOL]     assertFalse(STRING_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); [EOL]     assertFalse(STRING_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); [EOL]     assertFalse(STRING_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); [EOL]     assertFalse(STRING_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); [EOL]     assertFalse(STRING_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); [EOL]     assertFalse(STRING_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); [EOL]     assertFalse(STRING_TYPE.canTestForShallowEqualityWith(functionType)); [EOL]     assertFalse(STRING_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); [EOL]     assertFalse(STRING_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); [EOL]     assertFalse(STRING_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); [EOL]     assertFalse(STRING_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); [EOL]     assertFalse(STRING_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE)); [EOL]     assertFalse(STRING_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); [EOL]     assertFalse(STRING_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); [EOL]     assertFalse(STRING_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); [EOL]     assertTrue(STRING_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); [EOL]     assertFalse(STRING_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); [EOL]     assertFalse(STRING_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); [EOL]     assertFalse(STRING_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); [EOL]     assertTrue(STRING_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); [EOL]     assertFalse(STRING_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); [EOL]     assertTrue(STRING_TYPE.canTestForShallowEqualityWith(UNKNOWN_TYPE)); [EOL]     assertTrue(STRING_TYPE.matchesInt32Context()); [EOL]     assertTrue(STRING_TYPE.matchesNumberContext()); [EOL]     assertTrue(STRING_TYPE.matchesObjectContext()); [EOL]     assertTrue(STRING_TYPE.matchesStringContext()); [EOL]     assertTrue(STRING_TYPE.matchesUint32Context()); [EOL]     assertFalse(STRING_TYPE.isNullable()); [EOL]     assertTrue(createNullableType(STRING_TYPE).isNullable()); [EOL]     assertEquals("string", STRING_TYPE.toString()); [EOL]     assertTrue(STRING_TYPE.hasDisplayName()); [EOL]     assertEquals("string", STRING_TYPE.getDisplayName()); [EOL]     assertTypeEquals(NUMBER_TYPE, STRING_TYPE.findPropertyType("length")); [EOL]     assertEquals(null, STRING_TYPE.findPropertyType("unknownProperty")); [EOL]     Asserts.assertResolvesToSame(STRING_TYPE); [EOL]     assertFalse(STRING_TYPE.isNominalConstructor()); [EOL] } <line_num>: 2343,2452
private void assertPropertyTypeDeclared(ObjectType ownerType, String prop) { [EOL]     assertTrue(ownerType.isPropertyTypeDeclared(prop)); [EOL]     assertFalse(ownerType.isPropertyTypeInferred(prop)); [EOL] } <line_num>: 2454,2457
private void assertPropertyTypeInferred(ObjectType ownerType, String prop) { [EOL]     assertFalse(ownerType.isPropertyTypeDeclared(prop)); [EOL]     assertTrue(ownerType.isPropertyTypeInferred(prop)); [EOL] } <line_num>: 2459,2462
private void assertPropertyTypeUnknown(ObjectType ownerType, String prop) { [EOL]     assertFalse(ownerType.isPropertyTypeDeclared(prop)); [EOL]     assertFalse(ownerType.isPropertyTypeInferred(prop)); [EOL]     assertTrue(ownerType.getPropertyType(prop).isUnknownType()); [EOL] } <line_num>: 2464,2468
private void assertReturnTypeEquals(JSType expectedReturnType, JSType function) { [EOL]     assertTrue(function instanceof FunctionType); [EOL]     assertTypeEquals(expectedReturnType, ((FunctionType) function).getReturnType()); [EOL] } <line_num>: 2470,2475
public void testRecordType() throws Exception { [EOL]     assertTrue(recordType.isObject()); [EOL]     assertFalse(recordType.isFunctionPrototypeType()); [EOL]     assertTrue(recordType.isSubtype(ALL_TYPE)); [EOL]     assertFalse(recordType.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertFalse(recordType.isSubtype(NUMBER_TYPE)); [EOL]     assertFalse(recordType.isSubtype(DATE_TYPE)); [EOL]     assertFalse(recordType.isSubtype(REGEXP_TYPE)); [EOL]     assertTrue(recordType.isSubtype(UNKNOWN_TYPE)); [EOL]     assertTrue(recordType.isSubtype(OBJECT_TYPE)); [EOL]     assertFalse(recordType.isSubtype(U2U_CONSTRUCTOR_TYPE)); [EOL]     assertNull(recordType.autoboxesTo()); [EOL]     assertFalse(recordType.canBeCalled()); [EOL]     assertCanTestForEqualityWith(recordType, ALL_TYPE); [EOL]     assertCanTestForEqualityWith(recordType, STRING_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(recordType, recordType); [EOL]     assertCanTestForEqualityWith(recordType, functionType); [EOL]     assertCanTestForEqualityWith(recordType, OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(recordType, NUMBER_TYPE); [EOL]     assertCanTestForEqualityWith(recordType, DATE_TYPE); [EOL]     assertCanTestForEqualityWith(recordType, REGEXP_TYPE); [EOL]     assertTrue(recordType.canTestForShallowEqualityWith(NO_TYPE)); [EOL]     assertTrue(recordType.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); [EOL]     assertFalse(recordType.canTestForShallowEqualityWith(ARRAY_TYPE)); [EOL]     assertFalse(recordType.canTestForShallowEqualityWith(BOOLEAN_TYPE)); [EOL]     assertFalse(recordType.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); [EOL]     assertFalse(recordType.canTestForShallowEqualityWith(DATE_TYPE)); [EOL]     assertFalse(recordType.canTestForShallowEqualityWith(ERROR_TYPE)); [EOL]     assertFalse(recordType.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); [EOL]     assertTrue(recordType.canTestForShallowEqualityWith(recordType)); [EOL]     assertFalse(recordType.canTestForShallowEqualityWith(NULL_TYPE)); [EOL]     assertFalse(recordType.canTestForShallowEqualityWith(NUMBER_TYPE)); [EOL]     assertFalse(recordType.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); [EOL]     assertTrue(recordType.canTestForShallowEqualityWith(OBJECT_TYPE)); [EOL]     assertFalse(recordType.canTestForShallowEqualityWith(URI_ERROR_TYPE)); [EOL]     assertFalse(recordType.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); [EOL]     assertFalse(recordType.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); [EOL]     assertFalse(recordType.canTestForShallowEqualityWith(REGEXP_TYPE)); [EOL]     assertFalse(recordType.canTestForShallowEqualityWith(STRING_TYPE)); [EOL]     assertFalse(recordType.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); [EOL]     assertFalse(recordType.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); [EOL]     assertFalse(recordType.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); [EOL]     assertTrue(recordType.canTestForShallowEqualityWith(ALL_TYPE)); [EOL]     assertFalse(recordType.canTestForShallowEqualityWith(VOID_TYPE)); [EOL]     assertTrue(recordType.canTestForShallowEqualityWith(UNKNOWN_TYPE)); [EOL]     assertFalse(recordType.matchesInt32Context()); [EOL]     assertFalse(recordType.matchesNumberContext()); [EOL]     assertTrue(recordType.matchesObjectContext()); [EOL]     assertFalse(recordType.matchesStringContext()); [EOL]     assertFalse(recordType.matchesUint32Context()); [EOL]     Asserts.assertResolvesToSame(recordType); [EOL] } <line_num>: 2481,2548
public void testFunctionInstanceType() throws Exception { [EOL]     FunctionType functionInst = FUNCTION_INSTANCE_TYPE; [EOL]     assertTrue(functionInst.isObject()); [EOL]     assertFalse(functionInst.isFunctionPrototypeType()); [EOL]     assertTrue(functionInst.getImplicitPrototype().isFunctionPrototypeType()); [EOL]     assertTrue(functionInst.isSubtype(ALL_TYPE)); [EOL]     assertFalse(functionInst.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertFalse(functionInst.isSubtype(NUMBER_TYPE)); [EOL]     assertFalse(functionInst.isSubtype(DATE_TYPE)); [EOL]     assertFalse(functionInst.isSubtype(REGEXP_TYPE)); [EOL]     assertTrue(functionInst.isSubtype(UNKNOWN_TYPE)); [EOL]     assertTrue(functionInst.isSubtype(U2U_CONSTRUCTOR_TYPE)); [EOL]     assertNull(functionInst.autoboxesTo()); [EOL]     assertTrue(functionInst.canBeCalled()); [EOL]     assertCanTestForEqualityWith(functionInst, ALL_TYPE); [EOL]     assertCanTestForEqualityWith(functionInst, STRING_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(functionInst, functionInst); [EOL]     assertCanTestForEqualityWith(functionInst, OBJECT_TYPE); [EOL]     assertCannotTestForEqualityWith(functionInst, NUMBER_TYPE); [EOL]     assertCanTestForEqualityWith(functionInst, DATE_TYPE); [EOL]     assertCanTestForEqualityWith(functionInst, REGEXP_TYPE); [EOL]     assertTrue(functionInst.canTestForShallowEqualityWith(NO_TYPE)); [EOL]     assertTrue(functionInst.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); [EOL]     assertFalse(functionInst.canTestForShallowEqualityWith(ARRAY_TYPE)); [EOL]     assertFalse(functionInst.canTestForShallowEqualityWith(BOOLEAN_TYPE)); [EOL]     assertFalse(functionInst.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); [EOL]     assertFalse(functionInst.canTestForShallowEqualityWith(DATE_TYPE)); [EOL]     assertFalse(functionInst.canTestForShallowEqualityWith(ERROR_TYPE)); [EOL]     assertFalse(functionInst.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); [EOL]     assertTrue(functionInst.canTestForShallowEqualityWith(functionInst)); [EOL]     assertFalse(functionInst.canTestForShallowEqualityWith(NULL_TYPE)); [EOL]     assertFalse(functionInst.canTestForShallowEqualityWith(NUMBER_TYPE)); [EOL]     assertFalse(functionInst.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); [EOL]     assertTrue(functionInst.canTestForShallowEqualityWith(OBJECT_TYPE)); [EOL]     assertFalse(functionInst.canTestForShallowEqualityWith(URI_ERROR_TYPE)); [EOL]     assertFalse(functionInst.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); [EOL]     assertFalse(functionInst.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); [EOL]     assertFalse(functionInst.canTestForShallowEqualityWith(REGEXP_TYPE)); [EOL]     assertFalse(functionInst.canTestForShallowEqualityWith(STRING_TYPE)); [EOL]     assertFalse(functionInst.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); [EOL]     assertFalse(functionInst.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); [EOL]     assertFalse(functionInst.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); [EOL]     assertTrue(functionInst.canTestForShallowEqualityWith(ALL_TYPE)); [EOL]     assertFalse(functionInst.canTestForShallowEqualityWith(VOID_TYPE)); [EOL]     assertTrue(functionInst.canTestForShallowEqualityWith(UNKNOWN_TYPE)); [EOL]     assertFalse(functionInst.matchesInt32Context()); [EOL]     assertFalse(functionInst.matchesNumberContext()); [EOL]     assertTrue(functionInst.matchesObjectContext()); [EOL]     assertFalse(functionInst.matchesStringContext()); [EOL]     assertFalse(functionInst.matchesUint32Context()); [EOL]     assertTrue(functionInst.hasProperty("prototype")); [EOL]     assertPropertyTypeInferred(functionInst, "prototype"); [EOL]     assertTypeEquals(FUNCTION_FUNCTION_TYPE, functionInst.getConstructor()); [EOL]     assertTypeEquals(FUNCTION_PROTOTYPE, functionInst.getImplicitPrototype()); [EOL]     assertTypeEquals(functionInst, FUNCTION_FUNCTION_TYPE.getInstanceType()); [EOL]     Asserts.assertResolvesToSame(functionInst); [EOL] } <line_num>: 2553,2631
public void testFunctionType() throws Exception { [EOL]     assertTrue(functionType.isObject()); [EOL]     assertFalse(functionType.isFunctionPrototypeType()); [EOL]     assertTrue(functionType.getImplicitPrototype().getImplicitPrototype().isFunctionPrototypeType()); [EOL]     assertTrue(functionType.isSubtype(ALL_TYPE)); [EOL]     assertFalse(functionType.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertFalse(functionType.isSubtype(NUMBER_TYPE)); [EOL]     assertFalse(functionType.isSubtype(DATE_TYPE)); [EOL]     assertFalse(functionType.isSubtype(REGEXP_TYPE)); [EOL]     assertTrue(functionType.isSubtype(UNKNOWN_TYPE)); [EOL]     assertTrue(functionType.isSubtype(U2U_CONSTRUCTOR_TYPE)); [EOL]     assertNull(functionType.autoboxesTo()); [EOL]     assertTrue(functionType.canBeCalled()); [EOL]     assertCanTestForEqualityWith(functionType, ALL_TYPE); [EOL]     assertCanTestForEqualityWith(functionType, STRING_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(functionType, functionType); [EOL]     assertCanTestForEqualityWith(functionType, OBJECT_TYPE); [EOL]     assertCannotTestForEqualityWith(functionType, NUMBER_TYPE); [EOL]     assertCanTestForEqualityWith(functionType, DATE_TYPE); [EOL]     assertCanTestForEqualityWith(functionType, REGEXP_TYPE); [EOL]     assertTrue(functionType.canTestForShallowEqualityWith(NO_TYPE)); [EOL]     assertTrue(functionType.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); [EOL]     assertFalse(functionType.canTestForShallowEqualityWith(ARRAY_TYPE)); [EOL]     assertFalse(functionType.canTestForShallowEqualityWith(BOOLEAN_TYPE)); [EOL]     assertFalse(functionType.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); [EOL]     assertFalse(functionType.canTestForShallowEqualityWith(DATE_TYPE)); [EOL]     assertFalse(functionType.canTestForShallowEqualityWith(ERROR_TYPE)); [EOL]     assertFalse(functionType.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); [EOL]     assertTrue(functionType.canTestForShallowEqualityWith(functionType)); [EOL]     assertFalse(functionType.canTestForShallowEqualityWith(NULL_TYPE)); [EOL]     assertFalse(functionType.canTestForShallowEqualityWith(NUMBER_TYPE)); [EOL]     assertFalse(functionType.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); [EOL]     assertTrue(functionType.canTestForShallowEqualityWith(OBJECT_TYPE)); [EOL]     assertFalse(functionType.canTestForShallowEqualityWith(URI_ERROR_TYPE)); [EOL]     assertFalse(functionType.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); [EOL]     assertFalse(functionType.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); [EOL]     assertFalse(functionType.canTestForShallowEqualityWith(REGEXP_TYPE)); [EOL]     assertFalse(functionType.canTestForShallowEqualityWith(STRING_TYPE)); [EOL]     assertFalse(functionType.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); [EOL]     assertFalse(functionType.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); [EOL]     assertFalse(functionType.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); [EOL]     assertTrue(functionType.canTestForShallowEqualityWith(ALL_TYPE)); [EOL]     assertFalse(functionType.canTestForShallowEqualityWith(VOID_TYPE)); [EOL]     assertTrue(functionType.canTestForShallowEqualityWith(UNKNOWN_TYPE)); [EOL]     assertFalse(functionType.matchesInt32Context()); [EOL]     assertFalse(functionType.matchesNumberContext()); [EOL]     assertTrue(functionType.matchesObjectContext()); [EOL]     assertFalse(functionType.matchesStringContext()); [EOL]     assertFalse(functionType.matchesUint32Context()); [EOL]     assertTrue(functionType.hasProperty("prototype")); [EOL]     assertPropertyTypeInferred(functionType, "prototype"); [EOL]     Asserts.assertResolvesToSame(functionType); [EOL]     assertEquals("aFunctionName", new FunctionBuilder(registry).withName("aFunctionName").build().getDisplayName()); [EOL] } <line_num>: 2636,2711
public void testRecordTypeSubtyping() { [EOL]     RecordTypeBuilder builder = new RecordTypeBuilder(registry); [EOL]     builder.addProperty("a", NUMBER_TYPE, null); [EOL]     builder.addProperty("b", STRING_TYPE, null); [EOL]     builder.addProperty("c", STRING_TYPE, null); [EOL]     JSType subRecordType = builder.build(); [EOL]     assertTrue(subRecordType.isSubtype(recordType)); [EOL]     assertFalse(recordType.isSubtype(subRecordType)); [EOL]     builder = new RecordTypeBuilder(registry); [EOL]     builder.addProperty("a", OBJECT_TYPE, null); [EOL]     builder.addProperty("b", STRING_TYPE, null); [EOL]     JSType differentRecordType = builder.build(); [EOL]     assertFalse(differentRecordType.isSubtype(recordType)); [EOL]     assertFalse(recordType.isSubtype(differentRecordType)); [EOL] } <line_num>: 2716,2733
public void testRecordTypeSubtypingWithInferredProperties() { [EOL]     RecordTypeBuilder builder = new RecordTypeBuilder(registry); [EOL]     builder.addProperty("a", googSubBarInst, null); [EOL]     JSType record = builder.build(); [EOL]     ObjectType subtypeProp = registry.createAnonymousObjectType(null); [EOL]     subtypeProp.defineInferredProperty("a", googSubSubBarInst, null); [EOL]     assertTrue(subtypeProp.isSubtype(record)); [EOL]     assertFalse(record.isSubtype(subtypeProp)); [EOL]     ObjectType supertypeProp = registry.createAnonymousObjectType(null); [EOL]     supertypeProp.defineInferredProperty("a", googBarInst, null); [EOL]     assertFalse(supertypeProp.isSubtype(record)); [EOL]     assertFalse(record.isSubtype(supertypeProp)); [EOL]     ObjectType declaredSubtypeProp = registry.createAnonymousObjectType(null); [EOL]     declaredSubtypeProp.defineDeclaredProperty("a", googSubSubBarInst, null); [EOL]     assertFalse(declaredSubtypeProp.isSubtype(record)); [EOL]     assertFalse(record.isSubtype(declaredSubtypeProp)); [EOL] } <line_num>: 2739,2759
public void testRecordTypeLeastSuperType1() { [EOL]     RecordTypeBuilder builder = new RecordTypeBuilder(registry); [EOL]     builder.addProperty("a", NUMBER_TYPE, null); [EOL]     builder.addProperty("b", STRING_TYPE, null); [EOL]     builder.addProperty("c", STRING_TYPE, null); [EOL]     JSType subRecordType = builder.build(); [EOL]     JSType leastSupertype = recordType.getLeastSupertype(subRecordType); [EOL]     assertTypeEquals(leastSupertype, recordType); [EOL] } <line_num>: 2764,2773
public void testRecordTypeLeastSuperType2() { [EOL]     RecordTypeBuilder builder = new RecordTypeBuilder(registry); [EOL]     builder.addProperty("e", NUMBER_TYPE, null); [EOL]     builder.addProperty("b", STRING_TYPE, null); [EOL]     builder.addProperty("c", STRING_TYPE, null); [EOL]     JSType otherRecordType = builder.build(); [EOL]     assertTypeEquals(registry.createUnionType(recordType, otherRecordType), recordType.getLeastSupertype(otherRecordType)); [EOL] } <line_num>: 2775,2785
public void testRecordTypeLeastSuperType3() { [EOL]     RecordTypeBuilder builder = new RecordTypeBuilder(registry); [EOL]     builder.addProperty("d", NUMBER_TYPE, null); [EOL]     builder.addProperty("e", STRING_TYPE, null); [EOL]     builder.addProperty("f", STRING_TYPE, null); [EOL]     JSType otherRecordType = builder.build(); [EOL]     assertTypeEquals(registry.createUnionType(recordType, otherRecordType), recordType.getLeastSupertype(otherRecordType)); [EOL] } <line_num>: 2787,2797
public void testRecordTypeLeastSuperType4() { [EOL]     JSType leastSupertype = recordType.getLeastSupertype(OBJECT_TYPE); [EOL]     assertTypeEquals(leastSupertype, OBJECT_TYPE); [EOL] } <line_num>: 2799,2802
public void testRecordTypeGreatestSubType1() { [EOL]     RecordTypeBuilder builder = new RecordTypeBuilder(registry); [EOL]     builder.addProperty("d", NUMBER_TYPE, null); [EOL]     builder.addProperty("e", STRING_TYPE, null); [EOL]     builder.addProperty("f", STRING_TYPE, null); [EOL]     JSType subRecordType = builder.build(); [EOL]     JSType subtype = recordType.getGreatestSubtype(subRecordType); [EOL]     builder = new RecordTypeBuilder(registry); [EOL]     builder.addProperty("d", NUMBER_TYPE, null); [EOL]     builder.addProperty("e", STRING_TYPE, null); [EOL]     builder.addProperty("f", STRING_TYPE, null); [EOL]     builder.addProperty("a", NUMBER_TYPE, null); [EOL]     builder.addProperty("b", STRING_TYPE, null); [EOL]     assertTypeEquals(subtype, builder.build()); [EOL] } <line_num>: 2807,2825
public void testRecordTypeGreatestSubType2() { [EOL]     RecordTypeBuilder builder = new RecordTypeBuilder(registry); [EOL]     JSType subRecordType = builder.build(); [EOL]     JSType subtype = recordType.getGreatestSubtype(subRecordType); [EOL]     builder = new RecordTypeBuilder(registry); [EOL]     builder.addProperty("a", NUMBER_TYPE, null); [EOL]     builder.addProperty("b", STRING_TYPE, null); [EOL]     assertTypeEquals(subtype, builder.build()); [EOL] } <line_num>: 2827,2839
public void testRecordTypeGreatestSubType3() { [EOL]     RecordTypeBuilder builder = new RecordTypeBuilder(registry); [EOL]     builder.addProperty("a", NUMBER_TYPE, null); [EOL]     builder.addProperty("b", STRING_TYPE, null); [EOL]     builder.addProperty("c", STRING_TYPE, null); [EOL]     JSType subRecordType = builder.build(); [EOL]     JSType subtype = recordType.getGreatestSubtype(subRecordType); [EOL]     builder = new RecordTypeBuilder(registry); [EOL]     builder.addProperty("a", NUMBER_TYPE, null); [EOL]     builder.addProperty("b", STRING_TYPE, null); [EOL]     builder.addProperty("c", STRING_TYPE, null); [EOL]     assertTypeEquals(subtype, builder.build()); [EOL] } <line_num>: 2841,2857
public void testRecordTypeGreatestSubType4() { [EOL]     RecordTypeBuilder builder = new RecordTypeBuilder(registry); [EOL]     builder.addProperty("a", STRING_TYPE, null); [EOL]     builder.addProperty("b", STRING_TYPE, null); [EOL]     builder.addProperty("c", STRING_TYPE, null); [EOL]     JSType subRecordType = builder.build(); [EOL]     JSType subtype = recordType.getGreatestSubtype(subRecordType); [EOL]     assertTypeEquals(subtype, NO_TYPE); [EOL] } <line_num>: 2859,2869
public void testRecordTypeGreatestSubType5() { [EOL]     RecordTypeBuilder builder = new RecordTypeBuilder(registry); [EOL]     builder.addProperty("a", STRING_TYPE, null); [EOL]     JSType recordType = builder.build(); [EOL]     assertTypeEquals(NO_OBJECT_TYPE, recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE)); [EOL]     U2U_CONSTRUCTOR_TYPE.defineDeclaredProperty("a", STRING_TYPE, null); [EOL]     assertTypeEquals(U2U_CONSTRUCTOR_TYPE, recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE)); [EOL]     assertTypeEquals(U2U_CONSTRUCTOR_TYPE, U2U_CONSTRUCTOR_TYPE.getGreatestSubtype(recordType)); [EOL] } <line_num>: 2871,2887
public void testRecordTypeGreatestSubType6() { [EOL]     RecordTypeBuilder builder = new RecordTypeBuilder(registry); [EOL]     builder.addProperty("x", UNKNOWN_TYPE, null); [EOL]     JSType recordType = builder.build(); [EOL]     assertTypeEquals(NO_OBJECT_TYPE, recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE)); [EOL]     U2U_CONSTRUCTOR_TYPE.defineDeclaredProperty("x", STRING_TYPE, null); [EOL]     assertTypeEquals(U2U_CONSTRUCTOR_TYPE, recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE)); [EOL]     assertTypeEquals(U2U_CONSTRUCTOR_TYPE, U2U_CONSTRUCTOR_TYPE.getGreatestSubtype(recordType)); [EOL] } <line_num>: 2889,2905
public void testRecordTypeGreatestSubType7() { [EOL]     RecordTypeBuilder builder = new RecordTypeBuilder(registry); [EOL]     builder.addProperty("x", NUMBER_TYPE, null); [EOL]     JSType recordType = builder.build(); [EOL]     U2U_CONSTRUCTOR_TYPE.defineDeclaredProperty("x", STRING_TYPE, null); [EOL]     assertTypeEquals(NO_OBJECT_TYPE, recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE)); [EOL] } <line_num>: 2907,2918
public void testRecordTypeGreatestSubType8() { [EOL]     RecordTypeBuilder builder = new RecordTypeBuilder(registry); [EOL]     builder.addProperty("xyz", UNKNOWN_TYPE, null); [EOL]     JSType recordType = builder.build(); [EOL]     assertTypeEquals(NO_OBJECT_TYPE, recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE)); [EOL]     googBar.defineDeclaredProperty("xyz", STRING_TYPE, null); [EOL]     assertTypeEquals(googBar, recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE)); [EOL]     assertTypeEquals(googBar, U2U_CONSTRUCTOR_TYPE.getGreatestSubtype(recordType)); [EOL]     ObjectType googBarInst = googBar.getInstanceType(); [EOL]     assertTypeEquals(NO_OBJECT_TYPE, recordType.getGreatestSubtype(googBarInst)); [EOL]     assertTypeEquals(NO_OBJECT_TYPE, googBarInst.getGreatestSubtype(recordType)); [EOL] } <line_num>: 2919,2942
public void testApplyOfDateMethod() { [EOL]     JSType applyType = dateMethod.getPropertyType("apply"); [EOL]     assertTrue("apply should be a function", applyType instanceof FunctionType); [EOL]     FunctionType applyFn = (FunctionType) applyType; [EOL]     assertTypeEquals("apply should have the same return type as its function", NUMBER_TYPE, applyFn.getReturnType()); [EOL]     Node params = applyFn.getParametersNode(); [EOL]     assertEquals("apply takes two args", 2, params.getChildCount()); [EOL]     assertTypeEquals("apply's first arg is the @this type", registry.createOptionalNullableType(DATE_TYPE), params.getFirstChild().getJSType()); [EOL]     assertTypeEquals("apply's second arg is an Array", registry.createOptionalNullableType(OBJECT_TYPE), params.getLastChild().getJSType()); [EOL]     assertTrue("apply's args must be optional", params.getFirstChild().isOptionalArg()); [EOL]     assertTrue("apply's args must be optional", params.getLastChild().isOptionalArg()); [EOL] } <line_num>: 2947,2969
public void testCallOfDateMethod() { [EOL]     JSType callType = dateMethod.getPropertyType("call"); [EOL]     assertTrue("call should be a function", callType instanceof FunctionType); [EOL]     FunctionType callFn = (FunctionType) callType; [EOL]     assertTypeEquals("call should have the same return type as its function", NUMBER_TYPE, callFn.getReturnType()); [EOL]     Node params = callFn.getParametersNode(); [EOL]     assertEquals("call takes one argument in this case", 1, params.getChildCount()); [EOL]     assertTypeEquals("call's first arg is the @this type", registry.createOptionalNullableType(DATE_TYPE), params.getFirstChild().getJSType()); [EOL]     assertTrue("call's args must be optional", params.getFirstChild().isOptionalArg()); [EOL] } <line_num>: 2974,2991
public void testFunctionTypeRepresentation() { [EOL]     assertEquals("function (number, string): boolean", registry.createFunctionType(BOOLEAN_TYPE, false, NUMBER_TYPE, STRING_TYPE).toString()); [EOL]     assertEquals("function (new:Array, ...[*]): Array", ARRAY_FUNCTION_TYPE.toString()); [EOL]     assertEquals("function (new:Boolean, *=): boolean", BOOLEAN_OBJECT_FUNCTION_TYPE.toString()); [EOL]     assertEquals("function (new:Number, *=): number", NUMBER_OBJECT_FUNCTION_TYPE.toString()); [EOL]     assertEquals("function (new:String, *=): string", STRING_OBJECT_FUNCTION_TYPE.toString()); [EOL]     assertEquals("function (...[number]): boolean", registry.createFunctionType(BOOLEAN_TYPE, true, NUMBER_TYPE).toString()); [EOL]     assertEquals("function (number, ...[string]): boolean", registry.createFunctionType(BOOLEAN_TYPE, true, NUMBER_TYPE, STRING_TYPE).toString()); [EOL]     assertEquals("function (this:Date, number): (boolean|number|string)", new FunctionBuilder(registry).withParamsNode(registry.createParameters(NUMBER_TYPE)).withReturnType(NUMBER_STRING_BOOLEAN).withTypeOfThis(DATE_TYPE).build().toString()); [EOL] } <line_num>: 2996,3027
public void testFunctionTypeRelationships() { [EOL]     FunctionType dateMethodEmpty = new FunctionBuilder(registry).withParamsNode(registry.createParameters()).withTypeOfThis(DATE_TYPE).build(); [EOL]     FunctionType dateMethodWithParam = new FunctionBuilder(registry).withParamsNode(registry.createOptionalParameters(NUMBER_TYPE)).withTypeOfThis(DATE_TYPE).build(); [EOL]     FunctionType dateMethodWithReturn = new FunctionBuilder(registry).withReturnType(NUMBER_TYPE).withTypeOfThis(DATE_TYPE).build(); [EOL]     FunctionType stringMethodEmpty = new FunctionBuilder(registry).withParamsNode(registry.createParameters()).withTypeOfThis(STRING_OBJECT_TYPE).build(); [EOL]     FunctionType stringMethodWithParam = new FunctionBuilder(registry).withParamsNode(registry.createOptionalParameters(NUMBER_TYPE)).withTypeOfThis(STRING_OBJECT_TYPE).build(); [EOL]     FunctionType stringMethodWithReturn = new FunctionBuilder(registry).withReturnType(NUMBER_TYPE).withTypeOfThis(STRING_OBJECT_TYPE).build(); [EOL]     assertFalse(stringMethodEmpty.isSubtype(dateMethodEmpty)); [EOL]     List<FunctionType> allFunctions = Lists.newArrayList(dateMethodEmpty, dateMethodWithParam, dateMethodWithReturn, stringMethodEmpty, stringMethodWithParam, stringMethodWithReturn); [EOL]     for (int i = 0; i < allFunctions.size(); i++) { [EOL]         for (int j = 0; j < allFunctions.size(); j++) { [EOL]             FunctionType typeA = allFunctions.get(i); [EOL]             FunctionType typeB = allFunctions.get(j); [EOL]             assertEquals(String.format("equals(%s, %s)", typeA, typeB), i == j, typeA.isEquivalentTo(typeB)); [EOL]             assertEquals(String.format("isSubtype(%s, %s)", typeA, typeB), typeA.getTypeOfThis().isEquivalentTo(typeB.getTypeOfThis()), typeA.isSubtype(typeB)); [EOL]             if (i == j) { [EOL]                 assertTypeEquals(typeA, typeA.getLeastSupertype(typeB)); [EOL]                 assertTypeEquals(typeA, typeA.getGreatestSubtype(typeB)); [EOL]             } else { [EOL]                 assertTypeEquals(String.format("sup(%s, %s)", typeA, typeB), U2U_CONSTRUCTOR_TYPE, typeA.getLeastSupertype(typeB)); [EOL]                 assertTypeEquals(String.format("inf(%s, %s)", typeA, typeB), LEAST_FUNCTION_TYPE, typeA.getGreatestSubtype(typeB)); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 3032,3083
public void testProxiedFunctionTypeRelationships() { [EOL]     FunctionType dateMethodEmpty = new FunctionBuilder(registry).withParamsNode(registry.createParameters()).withTypeOfThis(DATE_TYPE).build().toMaybeFunctionType(); [EOL]     FunctionType dateMethodWithParam = new FunctionBuilder(registry).withParamsNode(registry.createParameters(NUMBER_TYPE)).withTypeOfThis(DATE_TYPE).build().toMaybeFunctionType(); [EOL]     ProxyObjectType proxyDateMethodEmpty = new ProxyObjectType(registry, dateMethodEmpty); [EOL]     ProxyObjectType proxyDateMethodWithParam = new ProxyObjectType(registry, dateMethodWithParam); [EOL]     assertTypeEquals(U2U_CONSTRUCTOR_TYPE, proxyDateMethodEmpty.getLeastSupertype(proxyDateMethodWithParam)); [EOL]     assertTypeEquals(LEAST_FUNCTION_TYPE, proxyDateMethodEmpty.getGreatestSubtype(proxyDateMethodWithParam)); [EOL] } <line_num>: 3085,3101
public void testFunctionSubTypeRelationships() { [EOL]     FunctionType googBarMethod = new FunctionBuilder(registry).withTypeOfThis(googBar).build(); [EOL]     FunctionType googBarParamFn = new FunctionBuilder(registry).withParamsNode(registry.createParameters(googBar)).build(); [EOL]     FunctionType googBarReturnFn = new FunctionBuilder(registry).withParamsNode(registry.createParameters()).withReturnType(googBar).build(); [EOL]     FunctionType googSubBarMethod = new FunctionBuilder(registry).withTypeOfThis(googSubBar).build(); [EOL]     FunctionType googSubBarParamFn = new FunctionBuilder(registry).withParamsNode(registry.createParameters(googSubBar)).build(); [EOL]     FunctionType googSubBarReturnFn = new FunctionBuilder(registry).withReturnType(googSubBar).build(); [EOL]     assertTrue(googBarMethod.isSubtype(googSubBarMethod)); [EOL]     assertTrue(googBarReturnFn.isSubtype(googSubBarReturnFn)); [EOL]     List<FunctionType> allFunctions = Lists.newArrayList(googBarMethod, googBarParamFn, googBarReturnFn, googSubBarMethod, googSubBarParamFn, googSubBarReturnFn); [EOL]     for (int i = 0; i < allFunctions.size(); i++) { [EOL]         for (int j = 0; j < allFunctions.size(); j++) { [EOL]             FunctionType typeA = allFunctions.get(i); [EOL]             FunctionType typeB = allFunctions.get(j); [EOL]             assertEquals(String.format("equals(%s, %s)", typeA, typeB), i == j, typeA.isEquivalentTo(typeB)); [EOL]             if (i == j) { [EOL]                 assertTypeEquals(typeA, typeA.getLeastSupertype(typeB)); [EOL]                 assertTypeEquals(typeA, typeA.getGreatestSubtype(typeB)); [EOL]             } else { [EOL]                 assertTypeEquals(String.format("sup(%s, %s)", typeA, typeB), U2U_CONSTRUCTOR_TYPE, typeA.getLeastSupertype(typeB)); [EOL]                 assertTypeEquals(String.format("inf(%s, %s)", typeA, typeB), LEAST_FUNCTION_TYPE, typeA.getGreatestSubtype(typeB)); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 3106,3147
public void testFunctionPrototypeAndImplicitPrototype1() { [EOL]     FunctionType constructor = registry.createConstructorType("Foo", null, null, null, null); [EOL]     ObjectType instance = constructor.getInstanceType(); [EOL]     ObjectType prototype = (ObjectType) constructor.getPropertyType("prototype"); [EOL]     prototype.defineDeclaredProperty("foo", DATE_TYPE, null); [EOL]     assertEquals(NATIVE_PROPERTIES_COUNT + 1, instance.getPropertiesCount()); [EOL] } <line_num>: 3153,3164
public void testFunctionPrototypeAndImplicitPrototype2() { [EOL]     FunctionType constructor = registry.createConstructorType(null, null, null, null); [EOL]     ObjectType instance = constructor.getInstanceType(); [EOL]     ObjectType prototype = registry.createAnonymousObjectType(null); [EOL]     prototype.defineDeclaredProperty("foo", DATE_TYPE, null); [EOL]     constructor.defineDeclaredProperty("prototype", prototype, null); [EOL]     assertEquals(NATIVE_PROPERTIES_COUNT + 1, instance.getPropertiesCount()); [EOL] } <line_num>: 3170,3181
public void testJSDocOnPrototypeProperty() throws Exception { [EOL]     subclassCtor.setPropertyJSDocInfo("prototype", new JSDocInfo()); [EOL]     assertNull(subclassCtor.getOwnPropertyJSDocInfo("prototype")); [EOL] } <line_num>: 3184,3187
public void testVoidType() throws Exception { [EOL]     assertTrue(VOID_TYPE.isSubtype(ALL_TYPE)); [EOL]     assertFalse(VOID_TYPE.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertFalse(VOID_TYPE.isSubtype(REGEXP_TYPE)); [EOL]     assertNull(VOID_TYPE.autoboxesTo()); [EOL]     assertCanTestForEqualityWith(VOID_TYPE, ALL_TYPE); [EOL]     assertCannotTestForEqualityWith(VOID_TYPE, REGEXP_TYPE); [EOL]     assertTrue(VOID_TYPE.canTestForShallowEqualityWith(NO_TYPE)); [EOL]     assertFalse(VOID_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); [EOL]     assertFalse(VOID_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); [EOL]     assertFalse(VOID_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); [EOL]     assertFalse(VOID_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); [EOL]     assertFalse(VOID_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); [EOL]     assertFalse(VOID_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); [EOL]     assertFalse(VOID_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); [EOL]     assertFalse(VOID_TYPE.canTestForShallowEqualityWith(functionType)); [EOL]     assertFalse(VOID_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); [EOL]     assertFalse(VOID_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); [EOL]     assertFalse(VOID_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); [EOL]     assertFalse(VOID_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); [EOL]     assertFalse(VOID_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE)); [EOL]     assertFalse(VOID_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); [EOL]     assertFalse(VOID_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); [EOL]     assertFalse(VOID_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); [EOL]     assertFalse(VOID_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); [EOL]     assertFalse(VOID_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); [EOL]     assertFalse(VOID_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); [EOL]     assertFalse(VOID_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); [EOL]     assertTrue(VOID_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); [EOL]     assertTrue(VOID_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); [EOL]     assertTrue(VOID_TYPE.canTestForShallowEqualityWith(createUnionType(NUMBER_TYPE, VOID_TYPE))); [EOL]     assertFalse(VOID_TYPE.matchesInt32Context()); [EOL]     assertFalse(VOID_TYPE.matchesNumberContext()); [EOL]     assertFalse(VOID_TYPE.matchesObjectContext()); [EOL]     assertTrue(VOID_TYPE.matchesStringContext()); [EOL]     assertFalse(VOID_TYPE.matchesUint32Context()); [EOL]     Asserts.assertResolvesToSame(VOID_TYPE); [EOL] } <line_num>: 3192,3240
public void testBooleanValueType() throws Exception { [EOL]     assertFalse(BOOLEAN_TYPE.isArrayType()); [EOL]     assertFalse(BOOLEAN_TYPE.isBooleanObjectType()); [EOL]     assertTrue(BOOLEAN_TYPE.isBooleanValueType()); [EOL]     assertFalse(BOOLEAN_TYPE.isDateType()); [EOL]     assertFalse(BOOLEAN_TYPE.isEnumElementType()); [EOL]     assertFalse(BOOLEAN_TYPE.isNamedType()); [EOL]     assertFalse(BOOLEAN_TYPE.isNullType()); [EOL]     assertFalse(BOOLEAN_TYPE.isNumberObjectType()); [EOL]     assertFalse(BOOLEAN_TYPE.isNumberValueType()); [EOL]     assertFalse(BOOLEAN_TYPE.isFunctionPrototypeType()); [EOL]     assertFalse(BOOLEAN_TYPE.isRegexpType()); [EOL]     assertFalse(BOOLEAN_TYPE.isStringObjectType()); [EOL]     assertFalse(BOOLEAN_TYPE.isStringValueType()); [EOL]     assertFalse(BOOLEAN_TYPE.isEnumType()); [EOL]     assertFalse(BOOLEAN_TYPE.isUnionType()); [EOL]     assertFalse(BOOLEAN_TYPE.isStruct()); [EOL]     assertFalse(BOOLEAN_TYPE.isDict()); [EOL]     assertFalse(BOOLEAN_TYPE.isAllType()); [EOL]     assertFalse(BOOLEAN_TYPE.isVoidType()); [EOL]     assertFalse(BOOLEAN_TYPE.isConstructor()); [EOL]     assertFalse(BOOLEAN_TYPE.isInstanceType()); [EOL]     assertTypeEquals(BOOLEAN_OBJECT_TYPE, BOOLEAN_TYPE.autoboxesTo()); [EOL]     assertTypeEquals(BOOLEAN_TYPE, BOOLEAN_OBJECT_TYPE.unboxesTo()); [EOL]     assertTrue(BOOLEAN_TYPE.isSubtype(ALL_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.isSubtype(NUMBER_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.isSubtype(functionType)); [EOL]     assertFalse(BOOLEAN_TYPE.isSubtype(NULL_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.isSubtype(OBJECT_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.isSubtype(DATE_TYPE)); [EOL]     assertTrue(BOOLEAN_TYPE.isSubtype(unresolvedNamedType)); [EOL]     assertFalse(BOOLEAN_TYPE.isSubtype(namedGoogBar)); [EOL]     assertFalse(BOOLEAN_TYPE.isSubtype(REGEXP_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.canBeCalled()); [EOL]     assertCanTestForEqualityWith(BOOLEAN_TYPE, ALL_TYPE); [EOL]     assertCanTestForEqualityWith(BOOLEAN_TYPE, STRING_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(BOOLEAN_TYPE, NUMBER_TYPE); [EOL]     assertCannotTestForEqualityWith(BOOLEAN_TYPE, functionType); [EOL]     assertCannotTestForEqualityWith(BOOLEAN_TYPE, VOID_TYPE); [EOL]     assertCanTestForEqualityWith(BOOLEAN_TYPE, OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(BOOLEAN_TYPE, DATE_TYPE); [EOL]     assertCanTestForEqualityWith(BOOLEAN_TYPE, REGEXP_TYPE); [EOL]     assertCanTestForEqualityWith(BOOLEAN_TYPE, UNKNOWN_TYPE); [EOL]     assertTrue(BOOLEAN_TYPE.canTestForShallowEqualityWith(NO_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); [EOL]     assertTrue(BOOLEAN_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(functionType)); [EOL]     assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); [EOL]     assertTrue(BOOLEAN_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); [EOL]     assertTrue(BOOLEAN_TYPE.canTestForShallowEqualityWith(UNKNOWN_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.isNullable()); [EOL]     assertTrue(BOOLEAN_TYPE.matchesInt32Context()); [EOL]     assertTrue(BOOLEAN_TYPE.matchesNumberContext()); [EOL]     assertTrue(BOOLEAN_TYPE.matchesObjectContext()); [EOL]     assertTrue(BOOLEAN_TYPE.matchesStringContext()); [EOL]     assertTrue(BOOLEAN_TYPE.matchesUint32Context()); [EOL]     assertEquals("boolean", BOOLEAN_TYPE.toString()); [EOL]     assertTrue(BOOLEAN_TYPE.hasDisplayName()); [EOL]     assertEquals("boolean", BOOLEAN_TYPE.getDisplayName()); [EOL]     Asserts.assertResolvesToSame(BOOLEAN_TYPE); [EOL] } <line_num>: 3245,3345
public void testBooleanObjectType() throws Exception { [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isArrayType()); [EOL]     assertTrue(BOOLEAN_OBJECT_TYPE.isBooleanObjectType()); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isBooleanValueType()); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isDateType()); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isEnumElementType()); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isNamedType()); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isNullType()); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isNumberObjectType()); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isNumberValueType()); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isFunctionPrototypeType()); [EOL]     assertTrue(BOOLEAN_OBJECT_TYPE.getImplicitPrototype().isFunctionPrototypeType()); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isRegexpType()); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isStringObjectType()); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isStringValueType()); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isEnumType()); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isUnionType()); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isStruct()); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isDict()); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isAllType()); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isVoidType()); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isConstructor()); [EOL]     assertTrue(BOOLEAN_OBJECT_TYPE.isInstanceType()); [EOL]     assertTrue(BOOLEAN_OBJECT_TYPE.isSubtype(ALL_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(NUMBER_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(functionType)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(NULL_TYPE)); [EOL]     assertTrue(BOOLEAN_OBJECT_TYPE.isSubtype(OBJECT_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(DATE_TYPE)); [EOL]     assertTrue(BOOLEAN_OBJECT_TYPE.isSubtype(unresolvedNamedType)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(namedGoogBar)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(REGEXP_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.canBeCalled()); [EOL]     assertCanTestForEqualityWith(BOOLEAN_OBJECT_TYPE, ALL_TYPE); [EOL]     assertCanTestForEqualityWith(BOOLEAN_OBJECT_TYPE, STRING_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(BOOLEAN_OBJECT_TYPE, NUMBER_TYPE); [EOL]     assertCanTestForEqualityWith(BOOLEAN_OBJECT_TYPE, functionType); [EOL]     assertCannotTestForEqualityWith(BOOLEAN_OBJECT_TYPE, VOID_TYPE); [EOL]     assertCanTestForEqualityWith(BOOLEAN_OBJECT_TYPE, OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(BOOLEAN_OBJECT_TYPE, DATE_TYPE); [EOL]     assertCanTestForEqualityWith(BOOLEAN_OBJECT_TYPE, REGEXP_TYPE); [EOL]     assertTrue(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(NO_TYPE)); [EOL]     assertTrue(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); [EOL]     assertTrue(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(functionType)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); [EOL]     assertTrue(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); [EOL]     assertTrue(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isNullable()); [EOL]     assertTrue(BOOLEAN_OBJECT_TYPE.matchesInt32Context()); [EOL]     assertTrue(BOOLEAN_OBJECT_TYPE.matchesNumberContext()); [EOL]     assertTrue(BOOLEAN_OBJECT_TYPE.matchesObjectContext()); [EOL]     assertTrue(BOOLEAN_OBJECT_TYPE.matchesStringContext()); [EOL]     assertTrue(BOOLEAN_OBJECT_TYPE.matchesUint32Context()); [EOL]     assertEquals("Boolean", BOOLEAN_OBJECT_TYPE.toString()); [EOL]     assertTrue(BOOLEAN_OBJECT_TYPE.hasDisplayName()); [EOL]     assertEquals("Boolean", BOOLEAN_OBJECT_TYPE.getDisplayName()); [EOL]     assertTrue(BOOLEAN_OBJECT_TYPE.isNativeObjectType()); [EOL]     Asserts.assertResolvesToSame(BOOLEAN_OBJECT_TYPE); [EOL] } <line_num>: 3350,3455
public void testEnumType() throws Exception { [EOL]     EnumType enumType = new EnumType(registry, "Enum", null, NUMBER_TYPE); [EOL]     assertFalse(enumType.isArrayType()); [EOL]     assertFalse(enumType.isBooleanObjectType()); [EOL]     assertFalse(enumType.isBooleanValueType()); [EOL]     assertFalse(enumType.isDateType()); [EOL]     assertFalse(enumType.isEnumElementType()); [EOL]     assertFalse(enumType.isNamedType()); [EOL]     assertFalse(enumType.isNullType()); [EOL]     assertFalse(enumType.isNumberObjectType()); [EOL]     assertFalse(enumType.isNumberValueType()); [EOL]     assertFalse(enumType.isFunctionPrototypeType()); [EOL]     assertFalse(enumType.isRegexpType()); [EOL]     assertFalse(enumType.isStringObjectType()); [EOL]     assertFalse(enumType.isStringValueType()); [EOL]     assertTrue(enumType.isEnumType()); [EOL]     assertFalse(enumType.isUnionType()); [EOL]     assertFalse(enumType.isStruct()); [EOL]     assertFalse(enumType.isDict()); [EOL]     assertFalse(enumType.isAllType()); [EOL]     assertFalse(enumType.isVoidType()); [EOL]     assertFalse(enumType.isConstructor()); [EOL]     assertFalse(enumType.isInstanceType()); [EOL]     assertTrue(enumType.isSubtype(ALL_TYPE)); [EOL]     assertFalse(enumType.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertFalse(enumType.isSubtype(NUMBER_TYPE)); [EOL]     assertFalse(enumType.isSubtype(functionType)); [EOL]     assertFalse(enumType.isSubtype(NULL_TYPE)); [EOL]     assertTrue(enumType.isSubtype(OBJECT_TYPE)); [EOL]     assertFalse(enumType.isSubtype(DATE_TYPE)); [EOL]     assertTrue(enumType.isSubtype(unresolvedNamedType)); [EOL]     assertFalse(enumType.isSubtype(namedGoogBar)); [EOL]     assertFalse(enumType.isSubtype(REGEXP_TYPE)); [EOL]     assertFalse(enumType.canBeCalled()); [EOL]     assertCanTestForEqualityWith(enumType, ALL_TYPE); [EOL]     assertCanTestForEqualityWith(enumType, STRING_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(enumType, NUMBER_TYPE); [EOL]     assertCanTestForEqualityWith(enumType, functionType); [EOL]     assertCannotTestForEqualityWith(enumType, VOID_TYPE); [EOL]     assertCanTestForEqualityWith(enumType, OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(enumType, DATE_TYPE); [EOL]     assertCanTestForEqualityWith(enumType, REGEXP_TYPE); [EOL]     assertTrue(enumType.canTestForShallowEqualityWith(NO_TYPE)); [EOL]     assertTrue(enumType.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); [EOL]     assertFalse(enumType.canTestForShallowEqualityWith(ARRAY_TYPE)); [EOL]     assertFalse(enumType.canTestForShallowEqualityWith(BOOLEAN_TYPE)); [EOL]     assertTrue(enumType.canTestForShallowEqualityWith(enumType)); [EOL]     assertFalse(enumType.canTestForShallowEqualityWith(DATE_TYPE)); [EOL]     assertFalse(enumType.canTestForShallowEqualityWith(ERROR_TYPE)); [EOL]     assertFalse(enumType.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); [EOL]     assertFalse(enumType.canTestForShallowEqualityWith(functionType)); [EOL]     assertFalse(enumType.canTestForShallowEqualityWith(NULL_TYPE)); [EOL]     assertFalse(enumType.canTestForShallowEqualityWith(NUMBER_TYPE)); [EOL]     assertFalse(enumType.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); [EOL]     assertTrue(enumType.canTestForShallowEqualityWith(OBJECT_TYPE)); [EOL]     assertFalse(enumType.canTestForShallowEqualityWith(URI_ERROR_TYPE)); [EOL]     assertFalse(enumType.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); [EOL]     assertFalse(enumType.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); [EOL]     assertFalse(enumType.canTestForShallowEqualityWith(REGEXP_TYPE)); [EOL]     assertFalse(enumType.canTestForShallowEqualityWith(STRING_TYPE)); [EOL]     assertFalse(enumType.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); [EOL]     assertFalse(enumType.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); [EOL]     assertFalse(enumType.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); [EOL]     assertTrue(enumType.canTestForShallowEqualityWith(ALL_TYPE)); [EOL]     assertFalse(enumType.canTestForShallowEqualityWith(VOID_TYPE)); [EOL]     assertFalse(enumType.isNullable()); [EOL]     assertFalse(enumType.matchesInt32Context()); [EOL]     assertFalse(enumType.matchesNumberContext()); [EOL]     assertTrue(enumType.matchesObjectContext()); [EOL]     assertTrue(enumType.matchesStringContext()); [EOL]     assertFalse(enumType.matchesUint32Context()); [EOL]     assertEquals("enum{Enum}", enumType.toString()); [EOL]     assertTrue(enumType.hasDisplayName()); [EOL]     assertEquals("Enum", enumType.getDisplayName()); [EOL]     assertEquals("AnotherEnum", new EnumType(registry, "AnotherEnum", null, NUMBER_TYPE).getDisplayName()); [EOL]     assertFalse(new EnumType(registry, null, null, NUMBER_TYPE).hasDisplayName()); [EOL]     Asserts.assertResolvesToSame(enumType); [EOL] } <line_num>: 3460,3569
public void testEnumElementType() throws Exception { [EOL]     assertFalse(elementsType.isArrayType()); [EOL]     assertFalse(elementsType.isBooleanObjectType()); [EOL]     assertFalse(elementsType.isBooleanValueType()); [EOL]     assertFalse(elementsType.isDateType()); [EOL]     assertTrue(elementsType.isEnumElementType()); [EOL]     assertFalse(elementsType.isNamedType()); [EOL]     assertFalse(elementsType.isNullType()); [EOL]     assertFalse(elementsType.isNumberObjectType()); [EOL]     assertFalse(elementsType.isNumberValueType()); [EOL]     assertFalse(elementsType.isFunctionPrototypeType()); [EOL]     assertFalse(elementsType.isRegexpType()); [EOL]     assertFalse(elementsType.isStringObjectType()); [EOL]     assertFalse(elementsType.isStringValueType()); [EOL]     assertFalse(elementsType.isEnumType()); [EOL]     assertFalse(elementsType.isUnionType()); [EOL]     assertFalse(elementsType.isStruct()); [EOL]     assertFalse(elementsType.isDict()); [EOL]     assertFalse(elementsType.isAllType()); [EOL]     assertFalse(elementsType.isVoidType()); [EOL]     assertFalse(elementsType.isConstructor()); [EOL]     assertFalse(elementsType.isInstanceType()); [EOL]     assertTrue(elementsType.isSubtype(ALL_TYPE)); [EOL]     assertFalse(elementsType.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertTrue(elementsType.isSubtype(NUMBER_TYPE)); [EOL]     assertFalse(elementsType.isSubtype(functionType)); [EOL]     assertFalse(elementsType.isSubtype(NULL_TYPE)); [EOL]     assertFalse(elementsType.isSubtype(OBJECT_TYPE)); [EOL]     assertFalse(elementsType.isSubtype(DATE_TYPE)); [EOL]     assertTrue(elementsType.isSubtype(unresolvedNamedType)); [EOL]     assertFalse(elementsType.isSubtype(namedGoogBar)); [EOL]     assertFalse(elementsType.isSubtype(REGEXP_TYPE)); [EOL]     assertFalse(elementsType.canBeCalled()); [EOL]     assertCanTestForEqualityWith(elementsType, ALL_TYPE); [EOL]     assertCanTestForEqualityWith(elementsType, STRING_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(elementsType, NUMBER_TYPE); [EOL]     assertCanTestForEqualityWith(elementsType, NUMBER_OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(elementsType, elementsType); [EOL]     assertCannotTestForEqualityWith(elementsType, functionType); [EOL]     assertCannotTestForEqualityWith(elementsType, VOID_TYPE); [EOL]     assertCanTestForEqualityWith(elementsType, OBJECT_TYPE); [EOL]     assertCanTestForEqualityWith(elementsType, DATE_TYPE); [EOL]     assertCanTestForEqualityWith(elementsType, REGEXP_TYPE); [EOL]     assertTrue(elementsType.canTestForShallowEqualityWith(NO_TYPE)); [EOL]     assertFalse(elementsType.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); [EOL]     assertFalse(elementsType.canTestForShallowEqualityWith(ARRAY_TYPE)); [EOL]     assertFalse(elementsType.canTestForShallowEqualityWith(BOOLEAN_TYPE)); [EOL]     assertTrue(elementsType.canTestForShallowEqualityWith(elementsType)); [EOL]     assertFalse(elementsType.canTestForShallowEqualityWith(DATE_TYPE)); [EOL]     assertFalse(elementsType.canTestForShallowEqualityWith(ERROR_TYPE)); [EOL]     assertFalse(elementsType.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); [EOL]     assertFalse(elementsType.canTestForShallowEqualityWith(functionType)); [EOL]     assertFalse(elementsType.canTestForShallowEqualityWith(NULL_TYPE)); [EOL]     assertTrue(elementsType.canTestForShallowEqualityWith(NUMBER_TYPE)); [EOL]     assertFalse(elementsType.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); [EOL]     assertFalse(elementsType.canTestForShallowEqualityWith(OBJECT_TYPE)); [EOL]     assertFalse(elementsType.canTestForShallowEqualityWith(URI_ERROR_TYPE)); [EOL]     assertFalse(elementsType.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); [EOL]     assertFalse(elementsType.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); [EOL]     assertFalse(elementsType.canTestForShallowEqualityWith(REGEXP_TYPE)); [EOL]     assertFalse(elementsType.canTestForShallowEqualityWith(STRING_TYPE)); [EOL]     assertFalse(elementsType.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); [EOL]     assertFalse(elementsType.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); [EOL]     assertFalse(elementsType.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); [EOL]     assertTrue(elementsType.canTestForShallowEqualityWith(ALL_TYPE)); [EOL]     assertFalse(elementsType.canTestForShallowEqualityWith(VOID_TYPE)); [EOL]     assertFalse(elementsType.isNullable()); [EOL]     assertTrue(elementsType.matchesInt32Context()); [EOL]     assertTrue(elementsType.matchesNumberContext()); [EOL]     assertTrue(elementsType.matchesObjectContext()); [EOL]     assertTrue(elementsType.matchesStringContext()); [EOL]     assertTrue(elementsType.matchesUint32Context()); [EOL]     assertEquals("Enum.<number>", elementsType.toString()); [EOL]     assertTrue(elementsType.hasDisplayName()); [EOL]     assertEquals("Enum", elementsType.getDisplayName()); [EOL]     Asserts.assertResolvesToSame(elementsType); [EOL] } <line_num>: 3574,3678
public void testStringEnumType() throws Exception { [EOL]     EnumElementType stringEnum = new EnumType(registry, "Enum", null, STRING_TYPE).getElementsType(); [EOL]     assertTypeEquals(UNKNOWN_TYPE, stringEnum.getPropertyType("length")); [EOL]     assertTypeEquals(NUMBER_TYPE, stringEnum.findPropertyType("length")); [EOL]     assertEquals(false, stringEnum.hasProperty("length")); [EOL]     assertTypeEquals(STRING_OBJECT_TYPE, stringEnum.autoboxesTo()); [EOL]     assertNull(stringEnum.getConstructor()); [EOL]     Asserts.assertResolvesToSame(stringEnum); [EOL] } <line_num>: 3680,3691
public void testStringObjectEnumType() throws Exception { [EOL]     EnumElementType stringEnum = new EnumType(registry, "Enum", null, STRING_OBJECT_TYPE).getElementsType(); [EOL]     assertTypeEquals(NUMBER_TYPE, stringEnum.getPropertyType("length")); [EOL]     assertTypeEquals(NUMBER_TYPE, stringEnum.findPropertyType("length")); [EOL]     assertEquals(true, stringEnum.hasProperty("length")); [EOL]     assertTypeEquals(STRING_OBJECT_FUNCTION_TYPE, stringEnum.getConstructor()); [EOL] } <line_num>: 3693,3702
public void testObjectType() throws Exception { [EOL]     PrototypeObjectType objectType = new PrototypeObjectType(registry, null, null); [EOL]     assertFalse(objectType.isAllType()); [EOL]     assertFalse(objectType.isArrayType()); [EOL]     assertFalse(objectType.isDateType()); [EOL]     assertFalse(objectType.isFunctionPrototypeType()); [EOL]     assertTrue(objectType.getImplicitPrototype() == OBJECT_TYPE); [EOL]     assertTrue(objectType.isSubtype(ALL_TYPE)); [EOL]     assertFalse(objectType.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertFalse(objectType.isSubtype(NUMBER_TYPE)); [EOL]     assertFalse(objectType.isSubtype(functionType)); [EOL]     assertFalse(objectType.isSubtype(NULL_TYPE)); [EOL]     assertFalse(objectType.isSubtype(DATE_TYPE)); [EOL]     assertTrue(objectType.isSubtype(OBJECT_TYPE)); [EOL]     assertTrue(objectType.isSubtype(unresolvedNamedType)); [EOL]     assertFalse(objectType.isSubtype(namedGoogBar)); [EOL]     assertFalse(objectType.isSubtype(REGEXP_TYPE)); [EOL]     assertNull(objectType.autoboxesTo()); [EOL]     assertCanTestForEqualityWith(objectType, NUMBER_TYPE); [EOL]     assertFalse(objectType.matchesInt32Context()); [EOL]     assertFalse(objectType.matchesNumberContext()); [EOL]     assertTrue(objectType.matchesObjectContext()); [EOL]     assertFalse(objectType.matchesStringContext()); [EOL]     assertFalse(objectType.matchesUint32Context()); [EOL]     assertFalse(objectType.isNullable()); [EOL]     assertTrue(createNullableType(objectType).isNullable()); [EOL]     assertEquals("{...}", objectType.toString()); [EOL]     assertEquals(null, objectType.getDisplayName()); [EOL]     assertFalse(objectType.hasReferenceName()); [EOL]     assertEquals("anObject", new PrototypeObjectType(registry, "anObject", null).getDisplayName()); [EOL]     Asserts.assertResolvesToSame(objectType); [EOL] } <line_num>: 3708,3756
public void testGoogBar() throws Exception { [EOL]     assertTrue(namedGoogBar.isInstanceType()); [EOL]     assertFalse(googBar.isInstanceType()); [EOL]     assertFalse(namedGoogBar.isConstructor()); [EOL]     assertTrue(googBar.isConstructor()); [EOL]     assertTrue(googBar.getInstanceType().isInstanceType()); [EOL]     assertTrue(namedGoogBar.getConstructor().isConstructor()); [EOL]     assertTrue(namedGoogBar.getImplicitPrototype().isFunctionPrototypeType()); [EOL]     assertTypeCanAssignToItself(googBar); [EOL]     assertTypeCanAssignToItself(namedGoogBar); [EOL]     googBar.isSubtype(namedGoogBar); [EOL]     namedGoogBar.isSubtype(googBar); [EOL]     assertTypeEquals(googBar, googBar); [EOL]     assertTypeNotEquals(googBar, googSubBar); [EOL]     Asserts.assertResolvesToSame(googBar); [EOL]     Asserts.assertResolvesToSame(googSubBar); [EOL] } <line_num>: 3761,3780
public void testObjectTypePropertiesCount() throws Exception { [EOL]     ObjectType sup = registry.createAnonymousObjectType(null); [EOL]     int nativeProperties = sup.getPropertiesCount(); [EOL]     sup.defineDeclaredProperty("a", DATE_TYPE, null); [EOL]     assertEquals(nativeProperties + 1, sup.getPropertiesCount()); [EOL]     sup.defineDeclaredProperty("b", DATE_TYPE, null); [EOL]     assertEquals(nativeProperties + 2, sup.getPropertiesCount()); [EOL]     ObjectType sub = registry.createObjectType(sup); [EOL]     assertEquals(nativeProperties + 2, sub.getPropertiesCount()); [EOL] } <line_num>: 3785,3797
public void testDefineProperties() { [EOL]     ObjectType prototype = googBar.getPrototype(); [EOL]     ObjectType instance = googBar.getInstanceType(); [EOL]     assertTypeEquals(instance.getImplicitPrototype(), prototype); [EOL]     assertTrue(prototype.defineDeclaredProperty("declared", NUMBER_TYPE, null)); [EOL]     assertFalse(prototype.defineDeclaredProperty("declared", NUMBER_TYPE, null)); [EOL]     assertFalse(instance.defineDeclaredProperty("declared", NUMBER_TYPE, null)); [EOL]     assertTypeEquals(NUMBER_TYPE, instance.getPropertyType("declared")); [EOL]     assertTrue(prototype.defineInferredProperty("inferred1", STRING_TYPE, null)); [EOL]     assertTrue(prototype.defineInferredProperty("inferred1", NUMBER_TYPE, null)); [EOL]     assertTypeEquals(createUnionType(NUMBER_TYPE, STRING_TYPE), instance.getPropertyType("inferred1")); [EOL]     assertTrue(prototype.defineInferredProperty("inferred2", STRING_TYPE, null)); [EOL]     assertTrue(instance.defineInferredProperty("inferred2", NUMBER_TYPE, null)); [EOL]     assertTypeEquals(createUnionType(NUMBER_TYPE, STRING_TYPE), instance.getPropertyType("inferred2")); [EOL]     assertTrue(prototype.defineInferredProperty("prop", STRING_TYPE, null)); [EOL]     assertTrue(instance.defineDeclaredProperty("prop", NUMBER_TYPE, null)); [EOL]     assertTypeEquals(NUMBER_TYPE, instance.getPropertyType("prop")); [EOL]     assertTypeEquals(STRING_TYPE, prototype.getPropertyType("prop")); [EOL] } <line_num>: 3802,3842
public void testObjectTypePropertiesCountWithShadowing() { [EOL]     ObjectType sup = registry.createAnonymousObjectType(null); [EOL]     int nativeProperties = sup.getPropertiesCount(); [EOL]     sup.defineDeclaredProperty("a", OBJECT_TYPE, null); [EOL]     assertEquals(nativeProperties + 1, sup.getPropertiesCount()); [EOL]     ObjectType sub = registry.createObjectType(sup); [EOL]     sub.defineDeclaredProperty("a", OBJECT_TYPE, null); [EOL]     assertEquals(nativeProperties + 1, sub.getPropertiesCount()); [EOL] } <line_num>: 3847,3857
public void testNamedGoogBar() throws Exception { [EOL]     assertFalse(namedGoogBar.isFunctionPrototypeType()); [EOL]     assertTrue(namedGoogBar.getImplicitPrototype().isFunctionPrototypeType()); [EOL]     assertTrue(namedGoogBar.isSubtype(ALL_TYPE)); [EOL]     assertFalse(namedGoogBar.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertFalse(namedGoogBar.isSubtype(NUMBER_TYPE)); [EOL]     assertFalse(namedGoogBar.isSubtype(functionType)); [EOL]     assertFalse(namedGoogBar.isSubtype(NULL_TYPE)); [EOL]     assertTrue(namedGoogBar.isSubtype(OBJECT_TYPE)); [EOL]     assertFalse(namedGoogBar.isSubtype(DATE_TYPE)); [EOL]     assertTrue(namedGoogBar.isSubtype(namedGoogBar)); [EOL]     assertTrue(namedGoogBar.isSubtype(unresolvedNamedType)); [EOL]     assertFalse(namedGoogBar.isSubtype(REGEXP_TYPE)); [EOL]     assertFalse(namedGoogBar.isSubtype(ARRAY_TYPE)); [EOL]     assertNull(namedGoogBar.autoboxesTo()); [EOL]     assertTypeEquals(DATE_TYPE, namedGoogBar.getPropertyType("date")); [EOL]     assertFalse(namedGoogBar.isNativeObjectType()); [EOL]     assertFalse(namedGoogBar.getImplicitPrototype().isNativeObjectType()); [EOL]     JSType resolvedNamedGoogBar = Asserts.assertValidResolve(namedGoogBar); [EOL]     assertNotSame(resolvedNamedGoogBar, namedGoogBar); [EOL]     assertSame(resolvedNamedGoogBar, googBar.getInstanceType()); [EOL] } <line_num>: 3862,3892
public void testPrototypeChaining() throws Exception { [EOL]     assertTypeEquals(ARRAY_TYPE.getImplicitPrototype().getImplicitPrototype(), OBJECT_TYPE); [EOL]     assertTypeEquals(BOOLEAN_OBJECT_TYPE.getImplicitPrototype().getImplicitPrototype(), OBJECT_TYPE); [EOL]     assertTypeEquals(DATE_TYPE.getImplicitPrototype().getImplicitPrototype(), OBJECT_TYPE); [EOL]     assertTypeEquals(ERROR_TYPE.getImplicitPrototype().getImplicitPrototype(), OBJECT_TYPE); [EOL]     assertTypeEquals(EVAL_ERROR_TYPE.getImplicitPrototype().getImplicitPrototype(), ERROR_TYPE); [EOL]     assertTypeEquals(NUMBER_OBJECT_TYPE.getImplicitPrototype().getImplicitPrototype(), OBJECT_TYPE); [EOL]     assertTypeEquals(URI_ERROR_TYPE.getImplicitPrototype().getImplicitPrototype(), ERROR_TYPE); [EOL]     assertTypeEquals(RANGE_ERROR_TYPE.getImplicitPrototype().getImplicitPrototype(), ERROR_TYPE); [EOL]     assertTypeEquals(REFERENCE_ERROR_TYPE.getImplicitPrototype().getImplicitPrototype(), ERROR_TYPE); [EOL]     assertTypeEquals(STRING_OBJECT_TYPE.getImplicitPrototype().getImplicitPrototype(), OBJECT_TYPE); [EOL]     assertTypeEquals(REGEXP_TYPE.getImplicitPrototype().getImplicitPrototype(), OBJECT_TYPE); [EOL]     assertTypeEquals(SYNTAX_ERROR_TYPE.getImplicitPrototype().getImplicitPrototype(), ERROR_TYPE); [EOL]     assertTypeEquals(TYPE_ERROR_TYPE.getImplicitPrototype().getImplicitPrototype(), ERROR_TYPE); [EOL]     assertNotSame(EVAL_ERROR_TYPE.getImplicitPrototype(), URI_ERROR_TYPE.getImplicitPrototype()); [EOL]     assertNotSame(EVAL_ERROR_TYPE.getImplicitPrototype(), RANGE_ERROR_TYPE.getImplicitPrototype()); [EOL]     assertNotSame(EVAL_ERROR_TYPE.getImplicitPrototype(), REFERENCE_ERROR_TYPE.getImplicitPrototype()); [EOL]     assertNotSame(EVAL_ERROR_TYPE.getImplicitPrototype(), SYNTAX_ERROR_TYPE.getImplicitPrototype()); [EOL]     assertNotSame(EVAL_ERROR_TYPE.getImplicitPrototype(), TYPE_ERROR_TYPE.getImplicitPrototype()); [EOL]     assertNotSame(URI_ERROR_TYPE.getImplicitPrototype(), RANGE_ERROR_TYPE.getImplicitPrototype()); [EOL]     assertNotSame(URI_ERROR_TYPE.getImplicitPrototype(), REFERENCE_ERROR_TYPE.getImplicitPrototype()); [EOL]     assertNotSame(URI_ERROR_TYPE.getImplicitPrototype(), SYNTAX_ERROR_TYPE.getImplicitPrototype()); [EOL]     assertNotSame(URI_ERROR_TYPE.getImplicitPrototype(), TYPE_ERROR_TYPE.getImplicitPrototype()); [EOL]     assertNotSame(RANGE_ERROR_TYPE.getImplicitPrototype(), REFERENCE_ERROR_TYPE.getImplicitPrototype()); [EOL]     assertNotSame(RANGE_ERROR_TYPE.getImplicitPrototype(), SYNTAX_ERROR_TYPE.getImplicitPrototype()); [EOL]     assertNotSame(RANGE_ERROR_TYPE.getImplicitPrototype(), TYPE_ERROR_TYPE.getImplicitPrototype()); [EOL]     assertNotSame(REFERENCE_ERROR_TYPE.getImplicitPrototype(), SYNTAX_ERROR_TYPE.getImplicitPrototype()); [EOL]     assertNotSame(REFERENCE_ERROR_TYPE.getImplicitPrototype(), TYPE_ERROR_TYPE.getImplicitPrototype()); [EOL]     assertNotSame(SYNTAX_ERROR_TYPE.getImplicitPrototype(), TYPE_ERROR_TYPE.getImplicitPrototype()); [EOL] } <line_num>: 3897,3974
public void testInstanceFunctionChaining() throws Exception { [EOL]     assertTypeEquals(ARRAY_FUNCTION_TYPE, ARRAY_TYPE.getConstructor()); [EOL]     assertTypeEquals(BOOLEAN_OBJECT_FUNCTION_TYPE, BOOLEAN_OBJECT_TYPE.getConstructor()); [EOL]     assertTypeEquals(DATE_FUNCTION_TYPE, DATE_TYPE.getConstructor()); [EOL]     assertTypeEquals(ERROR_FUNCTION_TYPE, ERROR_TYPE.getConstructor()); [EOL]     assertTypeEquals(EVAL_ERROR_FUNCTION_TYPE, EVAL_ERROR_TYPE.getConstructor()); [EOL]     assertTypeEquals(NUMBER_OBJECT_FUNCTION_TYPE, NUMBER_OBJECT_TYPE.getConstructor()); [EOL]     assertTypeEquals(OBJECT_FUNCTION_TYPE, OBJECT_TYPE.getConstructor()); [EOL]     assertTypeEquals(RANGE_ERROR_FUNCTION_TYPE, RANGE_ERROR_TYPE.getConstructor()); [EOL]     assertTypeEquals(REFERENCE_ERROR_FUNCTION_TYPE, REFERENCE_ERROR_TYPE.getConstructor()); [EOL]     assertTypeEquals(REGEXP_FUNCTION_TYPE, REGEXP_TYPE.getConstructor()); [EOL]     assertTypeEquals(STRING_OBJECT_FUNCTION_TYPE, STRING_OBJECT_TYPE.getConstructor()); [EOL]     assertTypeEquals(SYNTAX_ERROR_FUNCTION_TYPE, SYNTAX_ERROR_TYPE.getConstructor()); [EOL]     assertTypeEquals(TYPE_ERROR_FUNCTION_TYPE, TYPE_ERROR_TYPE.getConstructor()); [EOL]     assertTypeEquals(URI_ERROR_FUNCTION_TYPE, URI_ERROR_TYPE.getConstructor()); [EOL] } <line_num>: 3980,4040
@SuppressWarnings("checked") [EOL] public void testCanTestForEqualityWithCornerCases() { [EOL]     assertCannotTestForEqualityWith(NULL_TYPE, VOID_TYPE); [EOL]     UnionType nullableObject = (UnionType) createUnionType(OBJECT_TYPE, NULL_TYPE); [EOL]     assertCanTestForEqualityWith(nullableObject, VOID_TYPE); [EOL]     assertCanTestForEqualityWith(VOID_TYPE, nullableObject); [EOL] } <line_num>: 4046,4056
public void testTestForEquality() { [EOL]     compare(TRUE, NO_OBJECT_TYPE, NO_OBJECT_TYPE); [EOL]     compare(UNKNOWN, ALL_TYPE, ALL_TYPE); [EOL]     compare(TRUE, NO_TYPE, NO_TYPE); [EOL]     compare(UNKNOWN, NO_RESOLVED_TYPE, NO_RESOLVED_TYPE); [EOL]     compare(UNKNOWN, NO_OBJECT_TYPE, NUMBER_TYPE); [EOL]     compare(UNKNOWN, ALL_TYPE, NUMBER_TYPE); [EOL]     compare(UNKNOWN, NO_TYPE, NUMBER_TYPE); [EOL]     compare(FALSE, NULL_TYPE, BOOLEAN_TYPE); [EOL]     compare(TRUE, NULL_TYPE, NULL_TYPE); [EOL]     compare(FALSE, NULL_TYPE, NUMBER_TYPE); [EOL]     compare(FALSE, NULL_TYPE, OBJECT_TYPE); [EOL]     compare(FALSE, NULL_TYPE, STRING_TYPE); [EOL]     compare(TRUE, NULL_TYPE, VOID_TYPE); [EOL]     compare(UNKNOWN, NULL_TYPE, createUnionType(UNKNOWN_TYPE, VOID_TYPE)); [EOL]     compare(UNKNOWN, NULL_TYPE, createUnionType(OBJECT_TYPE, VOID_TYPE)); [EOL]     compare(UNKNOWN, NULL_TYPE, unresolvedNamedType); [EOL]     compare(UNKNOWN, NULL_TYPE, createUnionType(unresolvedNamedType, DATE_TYPE)); [EOL]     compare(FALSE, VOID_TYPE, REGEXP_TYPE); [EOL]     compare(TRUE, VOID_TYPE, VOID_TYPE); [EOL]     compare(UNKNOWN, VOID_TYPE, createUnionType(REGEXP_TYPE, VOID_TYPE)); [EOL]     compare(UNKNOWN, NUMBER_TYPE, BOOLEAN_TYPE); [EOL]     compare(UNKNOWN, NUMBER_TYPE, NUMBER_TYPE); [EOL]     compare(UNKNOWN, NUMBER_TYPE, OBJECT_TYPE); [EOL]     compare(UNKNOWN, ARRAY_TYPE, BOOLEAN_TYPE); [EOL]     compare(UNKNOWN, OBJECT_TYPE, BOOLEAN_TYPE); [EOL]     compare(UNKNOWN, OBJECT_TYPE, STRING_TYPE); [EOL]     compare(UNKNOWN, STRING_TYPE, STRING_TYPE); [EOL]     compare(UNKNOWN, STRING_TYPE, BOOLEAN_TYPE); [EOL]     compare(UNKNOWN, STRING_TYPE, NUMBER_TYPE); [EOL]     compare(FALSE, STRING_TYPE, VOID_TYPE); [EOL]     compare(FALSE, STRING_TYPE, NULL_TYPE); [EOL]     compare(FALSE, STRING_TYPE, createUnionType(NULL_TYPE, VOID_TYPE)); [EOL]     compare(UNKNOWN, UNKNOWN_TYPE, BOOLEAN_TYPE); [EOL]     compare(UNKNOWN, UNKNOWN_TYPE, NULL_TYPE); [EOL]     compare(UNKNOWN, UNKNOWN_TYPE, VOID_TYPE); [EOL]     compare(FALSE, U2U_CONSTRUCTOR_TYPE, BOOLEAN_TYPE); [EOL]     compare(FALSE, U2U_CONSTRUCTOR_TYPE, NUMBER_TYPE); [EOL]     compare(FALSE, U2U_CONSTRUCTOR_TYPE, STRING_TYPE); [EOL]     compare(FALSE, U2U_CONSTRUCTOR_TYPE, VOID_TYPE); [EOL]     compare(FALSE, U2U_CONSTRUCTOR_TYPE, NULL_TYPE); [EOL]     compare(UNKNOWN, U2U_CONSTRUCTOR_TYPE, OBJECT_TYPE); [EOL]     compare(UNKNOWN, U2U_CONSTRUCTOR_TYPE, ALL_TYPE); [EOL]     compare(UNKNOWN, NULL_TYPE, subclassOfUnresolvedNamedType); [EOL]     JSType functionAndNull = createUnionType(NULL_TYPE, dateMethod); [EOL]     compare(UNKNOWN, functionAndNull, dateMethod); [EOL]     compare(UNKNOWN, NULL_TYPE, NO_TYPE); [EOL]     compare(UNKNOWN, VOID_TYPE, NO_TYPE); [EOL]     compare(UNKNOWN, NULL_TYPE, unresolvedNamedType); [EOL]     compare(UNKNOWN, VOID_TYPE, unresolvedNamedType); [EOL]     compare(TRUE, NO_TYPE, NO_TYPE); [EOL] } <line_num>: 4061,4124
private void compare(TernaryValue r, JSType t1, JSType t2) { [EOL]     assertEquals(r, t1.testForEquality(t2)); [EOL]     assertEquals(r, t2.testForEquality(t1)); [EOL] } <line_num>: 4126,4129
private void assertCanTestForEqualityWith(JSType t1, JSType t2) { [EOL]     assertTrue(t1.canTestForEqualityWith(t2)); [EOL]     assertTrue(t2.canTestForEqualityWith(t1)); [EOL] } <line_num>: 4131,4134
private void assertCannotTestForEqualityWith(JSType t1, JSType t2) { [EOL]     assertFalse(t1.canTestForEqualityWith(t2)); [EOL]     assertFalse(t2.canTestForEqualityWith(t1)); [EOL] } <line_num>: 4136,4139
public void testSubtypingSimpleTypes() throws Exception { [EOL]     assertTrue(NO_TYPE.isSubtype(NO_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(NO_OBJECT_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(ARRAY_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(BOOLEAN_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(DATE_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(ERROR_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(EVAL_ERROR_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(functionType)); [EOL]     assertTrue(NO_TYPE.isSubtype(NULL_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(NUMBER_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(NUMBER_OBJECT_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(OBJECT_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(URI_ERROR_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(RANGE_ERROR_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(REFERENCE_ERROR_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(REGEXP_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(STRING_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(SYNTAX_ERROR_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(TYPE_ERROR_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(ALL_TYPE)); [EOL]     assertTrue(NO_TYPE.isSubtype(VOID_TYPE)); [EOL]     assertFalse(NO_OBJECT_TYPE.isSubtype(NO_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(NO_OBJECT_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(ARRAY_TYPE)); [EOL]     assertFalse(NO_OBJECT_TYPE.isSubtype(BOOLEAN_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(DATE_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(ERROR_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(EVAL_ERROR_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(functionType)); [EOL]     assertFalse(NO_OBJECT_TYPE.isSubtype(NULL_TYPE)); [EOL]     assertFalse(NO_OBJECT_TYPE.isSubtype(NUMBER_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(NUMBER_OBJECT_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(OBJECT_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(URI_ERROR_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(RANGE_ERROR_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(REFERENCE_ERROR_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(REGEXP_TYPE)); [EOL]     assertFalse(NO_OBJECT_TYPE.isSubtype(STRING_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(SYNTAX_ERROR_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(TYPE_ERROR_TYPE)); [EOL]     assertTrue(NO_OBJECT_TYPE.isSubtype(ALL_TYPE)); [EOL]     assertFalse(NO_OBJECT_TYPE.isSubtype(VOID_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.isSubtype(NO_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.isSubtype(NO_OBJECT_TYPE)); [EOL]     assertTrue(ARRAY_TYPE.isSubtype(ARRAY_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.isSubtype(BOOLEAN_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.isSubtype(DATE_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.isSubtype(ERROR_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.isSubtype(EVAL_ERROR_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.isSubtype(functionType)); [EOL]     assertFalse(ARRAY_TYPE.isSubtype(NULL_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.isSubtype(NUMBER_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.isSubtype(NUMBER_OBJECT_TYPE)); [EOL]     assertTrue(ARRAY_TYPE.isSubtype(OBJECT_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.isSubtype(URI_ERROR_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.isSubtype(RANGE_ERROR_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.isSubtype(REFERENCE_ERROR_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.isSubtype(REGEXP_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.isSubtype(STRING_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.isSubtype(SYNTAX_ERROR_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.isSubtype(TYPE_ERROR_TYPE)); [EOL]     assertTrue(ARRAY_TYPE.isSubtype(ALL_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.isSubtype(VOID_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.isSubtype(NO_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.isSubtype(NO_OBJECT_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.isSubtype(ARRAY_TYPE)); [EOL]     assertTrue(BOOLEAN_TYPE.isSubtype(BOOLEAN_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.isSubtype(DATE_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.isSubtype(ERROR_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.isSubtype(EVAL_ERROR_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.isSubtype(functionType)); [EOL]     assertFalse(BOOLEAN_TYPE.isSubtype(NULL_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.isSubtype(NUMBER_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.isSubtype(NUMBER_OBJECT_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.isSubtype(OBJECT_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.isSubtype(URI_ERROR_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.isSubtype(RANGE_ERROR_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.isSubtype(REFERENCE_ERROR_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.isSubtype(REGEXP_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.isSubtype(STRING_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.isSubtype(SYNTAX_ERROR_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.isSubtype(TYPE_ERROR_TYPE)); [EOL]     assertTrue(BOOLEAN_TYPE.isSubtype(ALL_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.isSubtype(VOID_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(NO_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(NO_OBJECT_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(ARRAY_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(BOOLEAN_TYPE)); [EOL]     assertTrue(BOOLEAN_OBJECT_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(DATE_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(ERROR_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(EVAL_ERROR_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(functionType)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(NULL_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(NUMBER_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(NUMBER_OBJECT_TYPE)); [EOL]     assertTrue(BOOLEAN_OBJECT_TYPE.isSubtype(OBJECT_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(URI_ERROR_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(RANGE_ERROR_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(REFERENCE_ERROR_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(REGEXP_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(STRING_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(SYNTAX_ERROR_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(TYPE_ERROR_TYPE)); [EOL]     assertTrue(BOOLEAN_OBJECT_TYPE.isSubtype(ALL_TYPE)); [EOL]     assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(VOID_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(NO_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(NO_OBJECT_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(ARRAY_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(BOOLEAN_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE)); [EOL]     assertTrue(DATE_TYPE.isSubtype(DATE_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(ERROR_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(EVAL_ERROR_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(functionType)); [EOL]     assertFalse(DATE_TYPE.isSubtype(NULL_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(NUMBER_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(NUMBER_OBJECT_TYPE)); [EOL]     assertTrue(DATE_TYPE.isSubtype(OBJECT_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(URI_ERROR_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(RANGE_ERROR_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(REFERENCE_ERROR_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(REGEXP_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(STRING_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(SYNTAX_ERROR_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(TYPE_ERROR_TYPE)); [EOL]     assertTrue(DATE_TYPE.isSubtype(ALL_TYPE)); [EOL]     assertFalse(DATE_TYPE.isSubtype(VOID_TYPE)); [EOL]     assertFalse(ERROR_TYPE.isSubtype(NO_TYPE)); [EOL]     assertFalse(ERROR_TYPE.isSubtype(NO_OBJECT_TYPE)); [EOL]     assertFalse(ERROR_TYPE.isSubtype(ARRAY_TYPE)); [EOL]     assertFalse(ERROR_TYPE.isSubtype(BOOLEAN_TYPE)); [EOL]     assertFalse(ERROR_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE)); [EOL]     assertFalse(ERROR_TYPE.isSubtype(DATE_TYPE)); [EOL]     assertTrue(ERROR_TYPE.isSubtype(ERROR_TYPE)); [EOL]     assertFalse(ERROR_TYPE.isSubtype(EVAL_ERROR_TYPE)); [EOL]     assertFalse(ERROR_TYPE.isSubtype(functionType)); [EOL]     assertFalse(ERROR_TYPE.isSubtype(NULL_TYPE)); [EOL]     assertFalse(ERROR_TYPE.isSubtype(NUMBER_TYPE)); [EOL]     assertFalse(ERROR_TYPE.isSubtype(NUMBER_OBJECT_TYPE)); [EOL]     assertTrue(ERROR_TYPE.isSubtype(OBJECT_TYPE)); [EOL]     assertFalse(ERROR_TYPE.isSubtype(URI_ERROR_TYPE)); [EOL]     assertFalse(ERROR_TYPE.isSubtype(RANGE_ERROR_TYPE)); [EOL]     assertFalse(ERROR_TYPE.isSubtype(REFERENCE_ERROR_TYPE)); [EOL]     assertFalse(ERROR_TYPE.isSubtype(REGEXP_TYPE)); [EOL]     assertFalse(ERROR_TYPE.isSubtype(STRING_TYPE)); [EOL]     assertFalse(ERROR_TYPE.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertFalse(ERROR_TYPE.isSubtype(SYNTAX_ERROR_TYPE)); [EOL]     assertFalse(ERROR_TYPE.isSubtype(TYPE_ERROR_TYPE)); [EOL]     assertTrue(ERROR_TYPE.isSubtype(ALL_TYPE)); [EOL]     assertFalse(ERROR_TYPE.isSubtype(VOID_TYPE)); [EOL]     assertFalse(EVAL_ERROR_TYPE.isSubtype(NO_TYPE)); [EOL]     assertFalse(EVAL_ERROR_TYPE.isSubtype(NO_OBJECT_TYPE)); [EOL]     assertFalse(EVAL_ERROR_TYPE.isSubtype(ARRAY_TYPE)); [EOL]     assertFalse(EVAL_ERROR_TYPE.isSubtype(BOOLEAN_TYPE)); [EOL]     assertFalse(EVAL_ERROR_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE)); [EOL]     assertFalse(ERROR_TYPE.isSubtype(DATE_TYPE)); [EOL]     assertTrue(EVAL_ERROR_TYPE.isSubtype(ERROR_TYPE)); [EOL]     assertTrue(EVAL_ERROR_TYPE.isSubtype(EVAL_ERROR_TYPE)); [EOL]     assertFalse(EVAL_ERROR_TYPE.isSubtype(functionType)); [EOL]     assertFalse(EVAL_ERROR_TYPE.isSubtype(NULL_TYPE)); [EOL]     assertFalse(EVAL_ERROR_TYPE.isSubtype(NUMBER_TYPE)); [EOL]     assertFalse(EVAL_ERROR_TYPE.isSubtype(NUMBER_OBJECT_TYPE)); [EOL]     assertTrue(EVAL_ERROR_TYPE.isSubtype(OBJECT_TYPE)); [EOL]     assertFalse(EVAL_ERROR_TYPE.isSubtype(URI_ERROR_TYPE)); [EOL]     assertFalse(EVAL_ERROR_TYPE.isSubtype(RANGE_ERROR_TYPE)); [EOL]     assertFalse(EVAL_ERROR_TYPE.isSubtype(REFERENCE_ERROR_TYPE)); [EOL]     assertFalse(EVAL_ERROR_TYPE.isSubtype(REGEXP_TYPE)); [EOL]     assertFalse(EVAL_ERROR_TYPE.isSubtype(STRING_TYPE)); [EOL]     assertFalse(EVAL_ERROR_TYPE.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertFalse(EVAL_ERROR_TYPE.isSubtype(SYNTAX_ERROR_TYPE)); [EOL]     assertFalse(EVAL_ERROR_TYPE.isSubtype(TYPE_ERROR_TYPE)); [EOL]     assertTrue(EVAL_ERROR_TYPE.isSubtype(ALL_TYPE)); [EOL]     assertFalse(EVAL_ERROR_TYPE.isSubtype(VOID_TYPE)); [EOL]     assertTrue(RANGE_ERROR_TYPE.isSubtype(ERROR_TYPE)); [EOL]     assertTrue(REFERENCE_ERROR_TYPE.isSubtype(ERROR_TYPE)); [EOL]     assertTrue(TYPE_ERROR_TYPE.isSubtype(ERROR_TYPE)); [EOL]     assertTrue(URI_ERROR_TYPE.isSubtype(ERROR_TYPE)); [EOL]     assertFalse(ALL_TYPE.isSubtype(NO_TYPE)); [EOL]     assertFalse(ALL_TYPE.isSubtype(NO_OBJECT_TYPE)); [EOL]     assertFalse(ALL_TYPE.isSubtype(ARRAY_TYPE)); [EOL]     assertFalse(ALL_TYPE.isSubtype(BOOLEAN_TYPE)); [EOL]     assertFalse(ALL_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE)); [EOL]     assertFalse(ERROR_TYPE.isSubtype(DATE_TYPE)); [EOL]     assertFalse(ALL_TYPE.isSubtype(ERROR_TYPE)); [EOL]     assertFalse(ALL_TYPE.isSubtype(EVAL_ERROR_TYPE)); [EOL]     assertFalse(ALL_TYPE.isSubtype(functionType)); [EOL]     assertFalse(ALL_TYPE.isSubtype(NULL_TYPE)); [EOL]     assertFalse(ALL_TYPE.isSubtype(NUMBER_TYPE)); [EOL]     assertFalse(ALL_TYPE.isSubtype(NUMBER_OBJECT_TYPE)); [EOL]     assertFalse(ALL_TYPE.isSubtype(OBJECT_TYPE)); [EOL]     assertFalse(ALL_TYPE.isSubtype(URI_ERROR_TYPE)); [EOL]     assertFalse(ALL_TYPE.isSubtype(RANGE_ERROR_TYPE)); [EOL]     assertFalse(ALL_TYPE.isSubtype(REFERENCE_ERROR_TYPE)); [EOL]     assertFalse(ALL_TYPE.isSubtype(REGEXP_TYPE)); [EOL]     assertFalse(ALL_TYPE.isSubtype(STRING_TYPE)); [EOL]     assertFalse(ALL_TYPE.isSubtype(STRING_OBJECT_TYPE)); [EOL]     assertFalse(ALL_TYPE.isSubtype(SYNTAX_ERROR_TYPE)); [EOL]     assertFalse(ALL_TYPE.isSubtype(TYPE_ERROR_TYPE)); [EOL]     assertTrue(ALL_TYPE.isSubtype(ALL_TYPE)); [EOL]     assertFalse(ALL_TYPE.isSubtype(VOID_TYPE)); [EOL] } <line_num>: 4144,4381
public void testSubtypingObjectTopOfObjects() throws Exception { [EOL]     assertTrue(OBJECT_TYPE.isSubtype(OBJECT_TYPE)); [EOL]     assertTrue(createUnionType(DATE_TYPE, REGEXP_TYPE).isSubtype(OBJECT_TYPE)); [EOL]     assertTrue(createUnionType(OBJECT_TYPE, NO_OBJECT_TYPE).isSubtype(OBJECT_TYPE)); [EOL]     assertTrue(functionType.isSubtype(OBJECT_TYPE)); [EOL] } <line_num>: 4387,4393
public void testSubtypingFunctionPrototypeType() throws Exception { [EOL]     FunctionType sub1 = registry.createConstructorType(null, null, null, null); [EOL]     sub1.setPrototypeBasedOn(googBar); [EOL]     FunctionType sub2 = registry.createConstructorType(null, null, null, null); [EOL]     sub2.setPrototypeBasedOn(googBar); [EOL]     ObjectType o1 = sub1.getInstanceType(); [EOL]     ObjectType o2 = sub2.getInstanceType(); [EOL]     assertFalse(o1.isSubtype(o2)); [EOL]     assertFalse(o1.getImplicitPrototype().isSubtype(o2.getImplicitPrototype())); [EOL]     assertTrue(o1.getImplicitPrototype().isSubtype(googBar)); [EOL]     assertTrue(o2.getImplicitPrototype().isSubtype(googBar)); [EOL] } <line_num>: 4395,4408
public void testSubtypingFunctionFixedArgs() throws Exception { [EOL]     FunctionType f1 = registry.createFunctionType(OBJECT_TYPE, false, BOOLEAN_TYPE); [EOL]     FunctionType f2 = registry.createFunctionType(STRING_OBJECT_TYPE, false, BOOLEAN_TYPE); [EOL]     assertTrue(f1.isSubtype(f1)); [EOL]     assertFalse(f1.isSubtype(f2)); [EOL]     assertTrue(f2.isSubtype(f1)); [EOL]     assertTrue(f2.isSubtype(f2)); [EOL]     assertTrue(f1.isSubtype(U2U_CONSTRUCTOR_TYPE)); [EOL]     assertTrue(f2.isSubtype(U2U_CONSTRUCTOR_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(f1)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(f2)); [EOL] } <line_num>: 4410,4425
public void testSubtypingFunctionMultipleFixedArgs() throws Exception { [EOL]     FunctionType f1 = registry.createFunctionType(OBJECT_TYPE, false, EVAL_ERROR_TYPE, STRING_TYPE); [EOL]     FunctionType f2 = registry.createFunctionType(STRING_OBJECT_TYPE, false, ERROR_TYPE, ALL_TYPE); [EOL]     assertTrue(f1.isSubtype(f1)); [EOL]     assertFalse(f1.isSubtype(f2)); [EOL]     assertTrue(f2.isSubtype(f1)); [EOL]     assertTrue(f2.isSubtype(f2)); [EOL]     assertTrue(f1.isSubtype(U2U_CONSTRUCTOR_TYPE)); [EOL]     assertTrue(f2.isSubtype(U2U_CONSTRUCTOR_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(f1)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(f2)); [EOL] } <line_num>: 4427,4442
public void testSubtypingFunctionFixedArgsNotMatching() throws Exception { [EOL]     FunctionType f1 = registry.createFunctionType(OBJECT_TYPE, false, EVAL_ERROR_TYPE, UNKNOWN_TYPE); [EOL]     FunctionType f2 = registry.createFunctionType(STRING_OBJECT_TYPE, false, ERROR_TYPE, ALL_TYPE); [EOL]     assertTrue(f1.isSubtype(f1)); [EOL]     assertFalse(f1.isSubtype(f2)); [EOL]     assertTrue(f2.isSubtype(f1)); [EOL]     assertTrue(f2.isSubtype(f2)); [EOL]     assertTrue(f1.isSubtype(U2U_CONSTRUCTOR_TYPE)); [EOL]     assertTrue(f2.isSubtype(U2U_CONSTRUCTOR_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(f1)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(f2)); [EOL] } <line_num>: 4444,4459
public void testSubtypingFunctionVariableArgsOneOnly() throws Exception { [EOL]     FunctionType f1 = registry.createFunctionType(OBJECT_TYPE, true, EVAL_ERROR_TYPE); [EOL]     FunctionType f2 = registry.createFunctionType(STRING_OBJECT_TYPE, false, ERROR_TYPE, OBJECT_TYPE); [EOL]     assertTrue(f1.isSubtype(f1)); [EOL]     assertFalse(f1.isSubtype(f2)); [EOL]     assertFalse(f2.isSubtype(f1)); [EOL]     assertTrue(f2.isSubtype(f2)); [EOL]     assertTrue(f1.isSubtype(U2U_CONSTRUCTOR_TYPE)); [EOL]     assertTrue(f2.isSubtype(U2U_CONSTRUCTOR_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(f1)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(f2)); [EOL] } <line_num>: 4461,4478
public void testSubtypingFunctionVariableArgsBoth() throws Exception { [EOL]     FunctionType f1 = registry.createFunctionType(OBJECT_TYPE, true, URI_ERROR_TYPE, EVAL_ERROR_TYPE, EVAL_ERROR_TYPE); [EOL]     FunctionType f2 = registry.createFunctionType(STRING_OBJECT_TYPE, true, ERROR_TYPE, OBJECT_TYPE, EVAL_ERROR_TYPE); [EOL]     assertTrue(f1.isSubtype(f1)); [EOL]     assertFalse(f1.isSubtype(f2)); [EOL]     assertTrue(f2.isSubtype(f1)); [EOL]     assertTrue(f2.isSubtype(f2)); [EOL]     assertTrue(f1.isSubtype(U2U_CONSTRUCTOR_TYPE)); [EOL]     assertTrue(f2.isSubtype(U2U_CONSTRUCTOR_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(f1)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(f2)); [EOL] } <line_num>: 4480,4497
public void testSubtypingMostGeneralFunction() throws Exception { [EOL]     FunctionType f1 = registry.createFunctionType(OBJECT_TYPE, false, EVAL_ERROR_TYPE, STRING_TYPE); [EOL]     FunctionType f2 = registry.createFunctionType(NUMBER_TYPE, false, STRING_TYPE, VOID_TYPE); [EOL]     FunctionType f3 = registry.createFunctionType(NO_OBJECT_TYPE, false, DATE_TYPE, STRING_TYPE, NUMBER_TYPE); [EOL]     FunctionType f4 = registry.createFunctionType(NO_TYPE, false, NUMBER_OBJECT_TYPE); [EOL]     FunctionType f5 = registry.createFunctionType(OBJECT_TYPE, true, EVAL_ERROR_TYPE); [EOL]     FunctionType f6 = registry.createFunctionType(STRING_OBJECT_TYPE, false, ERROR_TYPE, OBJECT_TYPE); [EOL]     FunctionType f7 = registry.createFunctionType(OBJECT_TYPE, true, URI_ERROR_TYPE, EVAL_ERROR_TYPE); [EOL]     FunctionType f8 = registry.createFunctionType(STRING_OBJECT_TYPE, true, ERROR_TYPE, OBJECT_TYPE, EVAL_ERROR_TYPE); [EOL]     assertTrue(LEAST_FUNCTION_TYPE.isSubtype(GREATEST_FUNCTION_TYPE)); [EOL]     assertTrue(LEAST_FUNCTION_TYPE.isSubtype(U2U_CONSTRUCTOR_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(LEAST_FUNCTION_TYPE)); [EOL]     assertFalse(GREATEST_FUNCTION_TYPE.isSubtype(LEAST_FUNCTION_TYPE)); [EOL]     assertTrue(GREATEST_FUNCTION_TYPE.isSubtype(U2U_CONSTRUCTOR_TYPE)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(GREATEST_FUNCTION_TYPE)); [EOL]     assertTrue(f1.isSubtype(GREATEST_FUNCTION_TYPE)); [EOL]     assertTrue(f2.isSubtype(GREATEST_FUNCTION_TYPE)); [EOL]     assertTrue(f3.isSubtype(GREATEST_FUNCTION_TYPE)); [EOL]     assertTrue(f4.isSubtype(GREATEST_FUNCTION_TYPE)); [EOL]     assertTrue(f5.isSubtype(GREATEST_FUNCTION_TYPE)); [EOL]     assertTrue(f6.isSubtype(GREATEST_FUNCTION_TYPE)); [EOL]     assertTrue(f7.isSubtype(GREATEST_FUNCTION_TYPE)); [EOL]     assertTrue(f8.isSubtype(GREATEST_FUNCTION_TYPE)); [EOL]     assertFalse(f1.isSubtype(LEAST_FUNCTION_TYPE)); [EOL]     assertFalse(f2.isSubtype(LEAST_FUNCTION_TYPE)); [EOL]     assertFalse(f3.isSubtype(LEAST_FUNCTION_TYPE)); [EOL]     assertFalse(f4.isSubtype(LEAST_FUNCTION_TYPE)); [EOL]     assertFalse(f5.isSubtype(LEAST_FUNCTION_TYPE)); [EOL]     assertFalse(f6.isSubtype(LEAST_FUNCTION_TYPE)); [EOL]     assertFalse(f7.isSubtype(LEAST_FUNCTION_TYPE)); [EOL]     assertFalse(f8.isSubtype(LEAST_FUNCTION_TYPE)); [EOL]     assertTrue(LEAST_FUNCTION_TYPE.isSubtype(f1)); [EOL]     assertTrue(LEAST_FUNCTION_TYPE.isSubtype(f2)); [EOL]     assertTrue(LEAST_FUNCTION_TYPE.isSubtype(f3)); [EOL]     assertTrue(LEAST_FUNCTION_TYPE.isSubtype(f4)); [EOL]     assertTrue(LEAST_FUNCTION_TYPE.isSubtype(f5)); [EOL]     assertTrue(LEAST_FUNCTION_TYPE.isSubtype(f6)); [EOL]     assertTrue(LEAST_FUNCTION_TYPE.isSubtype(f7)); [EOL]     assertTrue(LEAST_FUNCTION_TYPE.isSubtype(f8)); [EOL]     assertFalse(GREATEST_FUNCTION_TYPE.isSubtype(f1)); [EOL]     assertFalse(GREATEST_FUNCTION_TYPE.isSubtype(f2)); [EOL]     assertFalse(GREATEST_FUNCTION_TYPE.isSubtype(f3)); [EOL]     assertFalse(GREATEST_FUNCTION_TYPE.isSubtype(f4)); [EOL]     assertFalse(GREATEST_FUNCTION_TYPE.isSubtype(f5)); [EOL]     assertFalse(GREATEST_FUNCTION_TYPE.isSubtype(f6)); [EOL]     assertFalse(GREATEST_FUNCTION_TYPE.isSubtype(f7)); [EOL]     assertFalse(GREATEST_FUNCTION_TYPE.isSubtype(f8)); [EOL] } <line_num>: 4499,4568
private List<JSType> getTypesToTestForSymmetry() { [EOL]     return Lists.newArrayList(UNKNOWN_TYPE, NULL_TYPE, VOID_TYPE, NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE, OBJECT_TYPE, U2U_CONSTRUCTOR_TYPE, LEAST_FUNCTION_TYPE, GREATEST_FUNCTION_TYPE, ALL_TYPE, NO_TYPE, NO_OBJECT_TYPE, NO_RESOLVED_TYPE, createUnionType(BOOLEAN_TYPE, STRING_TYPE), createUnionType(NUMBER_TYPE, STRING_TYPE), createUnionType(NULL_TYPE, dateMethod), createUnionType(UNKNOWN_TYPE, dateMethod), createUnionType(namedGoogBar, dateMethod), createUnionType(NULL_TYPE, unresolvedNamedType), enumType, elementsType, dateMethod, functionType, unresolvedNamedType, googBar, namedGoogBar, googBar.getInstanceType(), namedGoogBar, subclassOfUnresolvedNamedType, subclassCtor, recordType, forwardDeclaredNamedType, createUnionType(forwardDeclaredNamedType, NULL_TYPE), createParameterizedType(OBJECT_TYPE, STRING_TYPE), createParameterizedType(OBJECT_TYPE, NUMBER_TYPE), createParameterizedType(ARRAY_TYPE, STRING_TYPE), createParameterizedType(ARRAY_TYPE, NUMBER_TYPE), createUnionType(createParameterizedType(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), createUnionType(createParameterizedType(OBJECT_TYPE, BOOLEAN_TYPE), NULL_TYPE)); [EOL] } <line_num>: 4573,4618
public void testSymmetryOfTestForEquality() { [EOL]     List<JSType> listA = getTypesToTestForSymmetry(); [EOL]     List<JSType> listB = getTypesToTestForSymmetry(); [EOL]     for (JSType typeA : listA) { [EOL]         for (JSType typeB : listB) { [EOL]             TernaryValue aOnB = typeA.testForEquality(typeB); [EOL]             TernaryValue bOnA = typeB.testForEquality(typeA); [EOL]             assertTrue(String.format("testForEquality not symmetrical:\n" + "typeA: %s\ntypeB: %s\n" + "a.testForEquality(b): %s\n" + "b.testForEquality(a): %s\n", typeA, typeB, aOnB, bOnA), aOnB == bOnA); [EOL]         } [EOL]     } [EOL] } <line_num>: 4620,4636
public void testSymmetryOfLeastSupertype() { [EOL]     List<JSType> listA = getTypesToTestForSymmetry(); [EOL]     List<JSType> listB = getTypesToTestForSymmetry(); [EOL]     for (JSType typeA : listA) { [EOL]         for (JSType typeB : listB) { [EOL]             JSType aOnB = typeA.getLeastSupertype(typeB); [EOL]             JSType bOnA = typeB.getLeastSupertype(typeA); [EOL]             assertTrue(String.format("getLeastSupertype not symmetrical:\n" + "typeA: %s\ntypeB: %s\n" + "a.getLeastSupertype(b): %s\n" + "b.getLeastSupertype(a): %s\n", typeA, typeB, aOnB, bOnA), aOnB.isEquivalentTo(bOnA)); [EOL]         } [EOL]     } [EOL] } <line_num>: 4641,4660
public void testWeirdBug() { [EOL]     assertTypeNotEquals(googBar, googBar.getInstanceType()); [EOL]     assertFalse(googBar.isSubtype(googBar.getInstanceType())); [EOL]     assertFalse(googBar.getInstanceType().isSubtype(googBar)); [EOL] } <line_num>: 4662,4666
public void testSymmetryOfGreatestSubtype() { [EOL]     List<JSType> listA = getTypesToTestForSymmetry(); [EOL]     List<JSType> listB = getTypesToTestForSymmetry(); [EOL]     for (JSType typeA : listA) { [EOL]         for (JSType typeB : listB) { [EOL]             JSType aOnB = typeA.getGreatestSubtype(typeB); [EOL]             JSType bOnA = typeB.getGreatestSubtype(typeA); [EOL]             assertTrue(String.format("getGreatestSubtype not symmetrical:\n" + "typeA: %s\ntypeB: %s\n" + "a.getGreatestSubtype(b): %s\n" + "b.getGreatestSubtype(a): %s\n", typeA, typeB, aOnB, bOnA), aOnB.isEquivalentTo(bOnA)); [EOL]         } [EOL]     } [EOL] } <line_num>: 4671,4690
public void testReflexivityOfLeastSupertype() { [EOL]     List<JSType> list = getTypesToTestForSymmetry(); [EOL]     for (JSType type : list) { [EOL]         assertTypeEquals("getLeastSupertype not reflexive", type, type.getLeastSupertype(type)); [EOL]     } [EOL] } <line_num>: 4695,4701
public void testReflexivityOfGreatestSubtype() { [EOL]     List<JSType> list = getTypesToTestForSymmetry(); [EOL]     for (JSType type : list) { [EOL]         assertTypeEquals("getGreatestSubtype not reflexive", type, type.getGreatestSubtype(type)); [EOL]     } [EOL] } <line_num>: 4706,4712
public void testLeastSupertypeUnresolvedNamedType() { [EOL]     JSType expected = registry.createUnionType(unresolvedNamedType, U2U_FUNCTION_TYPE); [EOL]     assertTypeEquals(expected, unresolvedNamedType.getLeastSupertype(U2U_FUNCTION_TYPE)); [EOL]     assertTypeEquals(expected, U2U_FUNCTION_TYPE.getLeastSupertype(unresolvedNamedType)); [EOL]     assertEquals("(function (...[?]): ?|not.resolved.named.type)", expected.toString()); [EOL] } <line_num>: 4717,4727
public void testLeastSupertypeUnresolvedNamedType2() { [EOL]     JSType expected = registry.createUnionType(unresolvedNamedType, UNKNOWN_TYPE); [EOL]     assertTypeEquals(expected, unresolvedNamedType.getLeastSupertype(UNKNOWN_TYPE)); [EOL]     assertTypeEquals(expected, UNKNOWN_TYPE.getLeastSupertype(unresolvedNamedType)); [EOL]     assertTypeEquals(UNKNOWN_TYPE, expected); [EOL] } <line_num>: 4729,4737
public void testLeastSupertypeUnresolvedNamedType3() { [EOL]     JSType expected = registry.createUnionType(unresolvedNamedType, CHECKED_UNKNOWN_TYPE); [EOL]     assertTypeEquals(expected, unresolvedNamedType.getLeastSupertype(CHECKED_UNKNOWN_TYPE)); [EOL]     assertTypeEquals(expected, CHECKED_UNKNOWN_TYPE.getLeastSupertype(unresolvedNamedType)); [EOL]     assertTypeEquals(CHECKED_UNKNOWN_TYPE, expected); [EOL] } <line_num>: 4739,4747
public void testSubclassOfUnresolvedNamedType() { [EOL]     assertTrue(subclassOfUnresolvedNamedType.isUnknownType()); [EOL] } <line_num>: 4750,4752
public void testSupertypeOfProxiedFunctionTypes() { [EOL]     ObjectType fn1 = new FunctionBuilder(registry).withParamsNode(new Node(Token.PARAM_LIST)).withReturnType(NUMBER_TYPE).build(); [EOL]     ObjectType fn2 = new FunctionBuilder(registry).withParamsNode(new Node(Token.PARAM_LIST)).withReturnType(STRING_TYPE).build(); [EOL]     ObjectType p1 = new ProxyObjectType(registry, fn1); [EOL]     ObjectType p2 = new ProxyObjectType(registry, fn2); [EOL]     ObjectType supremum = new FunctionBuilder(registry).withParamsNode(new Node(Token.PARAM_LIST)).withReturnType(registry.createUnionType(STRING_TYPE, NUMBER_TYPE)).build(); [EOL]     assertTypeEquals(fn1.getLeastSupertype(fn2), p1.getLeastSupertype(p2)); [EOL]     assertTypeEquals(supremum, fn1.getLeastSupertype(fn2)); [EOL]     assertTypeEquals(supremum, fn1.getLeastSupertype(p2)); [EOL]     assertTypeEquals(supremum, p1.getLeastSupertype(fn2)); [EOL]     assertTypeEquals(supremum, p1.getLeastSupertype(p2)); [EOL] } <line_num>: 4758,4782
public void testTypeOfThisIsProxied() { [EOL]     ObjectType fnType = new FunctionBuilder(registry).withReturnType(NUMBER_TYPE).withTypeOfThis(OBJECT_TYPE).build(); [EOL]     ObjectType proxyType = new ProxyObjectType(registry, fnType); [EOL]     assertTypeEquals(fnType.getTypeOfThis(), proxyType.getTypeOfThis()); [EOL] } <line_num>: 4784,4789
public void testNamedTypeEquals() { [EOL]     JSTypeRegistry jst = new JSTypeRegistry(null); [EOL]     NamedType a = new NamedType(jst, "type1", "source", 1, 0); [EOL]     NamedType b = new NamedType(jst, "type1", "source", 1, 0); [EOL]     assertTrue(a.isEquivalentTo(b)); [EOL]     assertTrue(namedGoogBar.isEquivalentTo(googBar.getInstanceType())); [EOL]     assertTrue(googBar.getInstanceType().isEquivalentTo(namedGoogBar)); [EOL] } <line_num>: 4794,4805
public void testNamedTypeEquals2() { [EOL]     NamedType a = new NamedType(registry, "typeA", "source", 1, 0); [EOL]     NamedType b = new NamedType(registry, "typeB", "source", 1, 0); [EOL]     ObjectType realA = registry.createConstructorType("typeA", null, null, null, null).getInstanceType(); [EOL]     ObjectType realB = registry.createEnumType("typeB", null, NUMBER_TYPE).getElementsType(); [EOL]     registry.declareType("typeA", realA); [EOL]     registry.declareType("typeB", realB); [EOL]     assertTypeEquals(a, realA); [EOL]     assertTypeEquals(b, realB); [EOL]     a.resolve(null, null); [EOL]     b.resolve(null, null); [EOL]     assertTrue(a.isResolved()); [EOL]     assertTrue(b.isResolved()); [EOL]     assertTypeEquals(a, realA); [EOL]     assertTypeEquals(b, realB); [EOL]     JSType resolvedA = Asserts.assertValidResolve(a); [EOL]     assertNotSame(resolvedA, a); [EOL]     assertSame(resolvedA, realA); [EOL]     JSType resolvedB = Asserts.assertValidResolve(b); [EOL]     assertNotSame(resolvedB, b); [EOL]     assertSame(resolvedB, realB); [EOL] } <line_num>: 4810,4840
public void testForwardDeclaredNamedTypeEquals() { [EOL]     NamedType a = new NamedType(registry, "typeA", "source", 1, 0); [EOL]     NamedType b = new NamedType(registry, "typeA", "source", 1, 0); [EOL]     registry.forwardDeclareType("typeA"); [EOL]     assertTypeEquals(a, b); [EOL]     a.resolve(null, EMPTY_SCOPE); [EOL]     assertTrue(a.isResolved()); [EOL]     assertFalse(b.isResolved()); [EOL]     assertTypeEquals(a, b); [EOL]     assertFalse(a.isEquivalentTo(UNKNOWN_TYPE)); [EOL]     assertFalse(b.isEquivalentTo(UNKNOWN_TYPE)); [EOL]     assertTrue(a.isEmptyType()); [EOL]     assertFalse(a.isNoType()); [EOL]     assertTrue(a.isNoResolvedType()); [EOL] } <line_num>: 4846,4866
public void testForwardDeclaredNamedType() { [EOL]     NamedType a = new NamedType(registry, "typeA", "source", 1, 0); [EOL]     registry.forwardDeclareType("typeA"); [EOL]     assertTypeEquals(UNKNOWN_TYPE, a.getLeastSupertype(UNKNOWN_TYPE)); [EOL]     assertTypeEquals(CHECKED_UNKNOWN_TYPE, a.getLeastSupertype(CHECKED_UNKNOWN_TYPE)); [EOL]     assertTypeEquals(UNKNOWN_TYPE, UNKNOWN_TYPE.getLeastSupertype(a)); [EOL]     assertTypeEquals(CHECKED_UNKNOWN_TYPE, CHECKED_UNKNOWN_TYPE.getLeastSupertype(a)); [EOL] } <line_num>: 4868,4878
public void testGreatestSubtypeSimpleTypes() { [EOL]     assertTypeEquals(ARRAY_TYPE, ARRAY_TYPE.getGreatestSubtype(ALL_TYPE)); [EOL]     assertTypeEquals(ARRAY_TYPE, ALL_TYPE.getGreatestSubtype(ARRAY_TYPE)); [EOL]     assertTypeEquals(NO_OBJECT_TYPE, REGEXP_TYPE.getGreatestSubtype(NO_OBJECT_TYPE)); [EOL]     assertTypeEquals(NO_OBJECT_TYPE, NO_OBJECT_TYPE.getGreatestSubtype(REGEXP_TYPE)); [EOL]     assertTypeEquals(NO_OBJECT_TYPE, ARRAY_TYPE.getGreatestSubtype(STRING_OBJECT_TYPE)); [EOL]     assertTypeEquals(NO_TYPE, ARRAY_TYPE.getGreatestSubtype(NUMBER_TYPE)); [EOL]     assertTypeEquals(NO_OBJECT_TYPE, ARRAY_TYPE.getGreatestSubtype(functionType)); [EOL]     assertTypeEquals(STRING_OBJECT_TYPE, STRING_OBJECT_TYPE.getGreatestSubtype(OBJECT_TYPE)); [EOL]     assertTypeEquals(STRING_OBJECT_TYPE, OBJECT_TYPE.getGreatestSubtype(STRING_OBJECT_TYPE)); [EOL]     assertTypeEquals(NO_OBJECT_TYPE, ARRAY_TYPE.getGreatestSubtype(DATE_TYPE)); [EOL]     assertTypeEquals(NO_OBJECT_TYPE, ARRAY_TYPE.getGreatestSubtype(REGEXP_TYPE)); [EOL]     assertTypeEquals(EVAL_ERROR_TYPE, ERROR_TYPE.getGreatestSubtype(EVAL_ERROR_TYPE)); [EOL]     assertTypeEquals(EVAL_ERROR_TYPE, EVAL_ERROR_TYPE.getGreatestSubtype(ERROR_TYPE)); [EOL]     assertTypeEquals(NO_TYPE, NULL_TYPE.getGreatestSubtype(ERROR_TYPE)); [EOL]     assertTypeEquals(UNKNOWN_TYPE, NUMBER_TYPE.getGreatestSubtype(UNKNOWN_TYPE)); [EOL]     assertTypeEquals(NO_RESOLVED_TYPE, NO_OBJECT_TYPE.getGreatestSubtype(forwardDeclaredNamedType)); [EOL]     assertTypeEquals(NO_RESOLVED_TYPE, forwardDeclaredNamedType.getGreatestSubtype(NO_OBJECT_TYPE)); [EOL] } <line_num>: 4883,4919
public void testSubtypingDerivedExtendsNamedBaseType() throws Exception { [EOL]     ObjectType derived = registry.createObjectType(registry.createObjectType(namedGoogBar)); [EOL]     assertTrue(derived.isSubtype(googBar.getInstanceType())); [EOL] } <line_num>: 4925,4930
public void testNamedSubtypeChain() throws Exception { [EOL]     List<JSType> typeChain = Lists.newArrayList(registry.getNativeType(JSTypeNative.ALL_TYPE), registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE), registry.getNativeType(JSTypeNative.OBJECT_TYPE), googBar.getPrototype(), googBar.getInstanceType(), googSubBar.getPrototype(), googSubBar.getInstanceType(), googSubSubBar.getPrototype(), googSubSubBar.getInstanceType(), registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); [EOL]     verifySubtypeChain(typeChain); [EOL] } <line_num>: 4932,4946
public void testRecordSubtypeChain() throws Exception { [EOL]     RecordTypeBuilder builder = new RecordTypeBuilder(registry); [EOL]     builder.addProperty("a", STRING_TYPE, null); [EOL]     JSType aType = builder.build(); [EOL]     builder = new RecordTypeBuilder(registry); [EOL]     builder.addProperty("a", STRING_TYPE, null); [EOL]     builder.addProperty("b", STRING_TYPE, null); [EOL]     JSType abType = builder.build(); [EOL]     builder = new RecordTypeBuilder(registry); [EOL]     builder.addProperty("a", STRING_TYPE, null); [EOL]     builder.addProperty("c", STRING_TYPE, null); [EOL]     JSType acType = builder.build(); [EOL]     JSType abOrAcType = registry.createUnionType(abType, acType); [EOL]     builder = new RecordTypeBuilder(registry); [EOL]     builder.addProperty("a", STRING_TYPE, null); [EOL]     builder.addProperty("b", STRING_TYPE, null); [EOL]     builder.addProperty("c", NUMBER_TYPE, null); [EOL]     JSType abcType = builder.build(); [EOL]     List<JSType> typeChain = Lists.newArrayList(registry.getNativeType(JSTypeNative.ALL_TYPE), registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE), registry.getNativeType(JSTypeNative.OBJECT_TYPE), aType, abOrAcType, abType, abcType, registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); [EOL]     verifySubtypeChain(typeChain); [EOL] } <line_num>: 4948,4981
public void testRecordAndObjectChain2() throws Exception { [EOL]     RecordTypeBuilder builder = new RecordTypeBuilder(registry); [EOL]     builder.addProperty("date", DATE_TYPE, null); [EOL]     JSType hasDateProperty = builder.build(); [EOL]     List<JSType> typeChain = Lists.newArrayList(registry.getNativeType(JSTypeNative.OBJECT_TYPE), hasDateProperty, googBar.getInstanceType(), registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); [EOL]     verifySubtypeChain(typeChain); [EOL] } <line_num>: 4983,4995
public void testRecordAndObjectChain3() throws Exception { [EOL]     RecordTypeBuilder builder = new RecordTypeBuilder(registry); [EOL]     builder.addProperty("date", UNKNOWN_TYPE, null); [EOL]     JSType hasUnknownDateProperty = builder.build(); [EOL]     List<JSType> typeChain = Lists.newArrayList(registry.getNativeType(JSTypeNative.OBJECT_TYPE), hasUnknownDateProperty, googBar.getInstanceType(), registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); [EOL]     verifySubtypeChain(typeChain); [EOL] } <line_num>: 4997,5009
public void testNullableNamedTypeChain() throws Exception { [EOL]     List<JSType> typeChain = Lists.newArrayList(registry.getNativeType(JSTypeNative.ALL_TYPE), registry.createOptionalNullableType(registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE)), registry.createOptionalNullableType(registry.getNativeType(JSTypeNative.OBJECT_TYPE)), registry.createOptionalNullableType(googBar.getPrototype()), registry.createOptionalNullableType(googBar.getInstanceType()), registry.createNullableType(googSubBar.getPrototype()), registry.createNullableType(googSubBar.getInstanceType()), googSubSubBar.getPrototype(), googSubSubBar.getInstanceType(), registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); [EOL]     verifySubtypeChain(typeChain); [EOL] } <line_num>: 5011,5027
public void testEnumTypeChain() throws Exception { [EOL]     List<JSType> typeChain = Lists.newArrayList(registry.getNativeType(JSTypeNative.ALL_TYPE), registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE), registry.getNativeType(JSTypeNative.OBJECT_TYPE), enumType, registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); [EOL]     verifySubtypeChain(typeChain); [EOL] } <line_num>: 5029,5038
public void testFunctionSubtypeChain() throws Exception { [EOL]     List<JSType> typeChain = Lists.newArrayList(registry.getNativeType(JSTypeNative.ALL_TYPE), registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE), registry.getNativeType(JSTypeNative.OBJECT_TYPE), registry.getNativeType(JSTypeNative.FUNCTION_PROTOTYPE), registry.getNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE), dateMethod, registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE), registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); [EOL]     verifySubtypeChain(typeChain); [EOL] } <line_num>: 5040,5052
public void testFunctionUnionSubtypeChain() throws Exception { [EOL]     List<JSType> typeChain = Lists.newArrayList(createUnionType(OBJECT_TYPE, STRING_TYPE), createUnionType(GREATEST_FUNCTION_TYPE, googBarInst, STRING_TYPE), createUnionType(STRING_TYPE, registry.createFunctionType(createUnionType(STRING_TYPE, NUMBER_TYPE)), googBarInst), createUnionType(registry.createFunctionType(NUMBER_TYPE), googSubBarInst), LEAST_FUNCTION_TYPE, NO_OBJECT_TYPE, NO_TYPE); [EOL]     verifySubtypeChain(typeChain); [EOL] } <line_num>: 5054,5075
public void testConstructorSubtypeChain() throws Exception { [EOL]     List<JSType> typeChain = Lists.newArrayList(registry.getNativeType(JSTypeNative.ALL_TYPE), registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE), registry.getNativeType(JSTypeNative.OBJECT_TYPE), registry.getNativeType(JSTypeNative.FUNCTION_PROTOTYPE), registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE), registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); [EOL]     verifySubtypeChain(typeChain); [EOL] } <line_num>: 5077,5087
public void testGoogBarSubtypeChain() throws Exception { [EOL]     List<JSType> typeChain = Lists.newArrayList(registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE), googBar, googSubBar, googSubSubBar, registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE)); [EOL]     verifySubtypeChain(typeChain, false); [EOL] } <line_num>: 5089,5097
public void testConstructorWithArgSubtypeChain() throws Exception { [EOL]     FunctionType googBarArgConstructor = registry.createConstructorType("barArg", null, registry.createParameters(googBar), null, null); [EOL]     FunctionType googSubBarArgConstructor = registry.createConstructorType("subBarArg", null, registry.createParameters(googSubBar), null, null); [EOL]     List<JSType> typeChain = Lists.newArrayList(registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE), googBarArgConstructor, googSubBarArgConstructor, registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE)); [EOL]     verifySubtypeChain(typeChain, false); [EOL] } <line_num>: 5099,5111
public void testInterfaceInstanceSubtypeChain() throws Exception { [EOL]     List<JSType> typeChain = Lists.newArrayList(ALL_TYPE, OBJECT_TYPE, interfaceInstType, googBar.getPrototype(), googBarInst, googSubBar.getPrototype(), googSubBarInst, registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); [EOL]     verifySubtypeChain(typeChain); [EOL] } <line_num>: 5113,5125
public void testInterfaceInheritanceSubtypeChain() throws Exception { [EOL]     FunctionType tempType = registry.createConstructorType("goog.TempType", null, null, null, null); [EOL]     tempType.setImplementedInterfaces(Lists.<ObjectType>newArrayList(subInterfaceInstType)); [EOL]     List<JSType> typeChain = Lists.newArrayList(ALL_TYPE, OBJECT_TYPE, interfaceInstType, subInterfaceInstType, tempType.getPrototype(), tempType.getInstanceType(), registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); [EOL]     verifySubtypeChain(typeChain); [EOL] } <line_num>: 5127,5142
public void testAnonymousObjectChain() throws Exception { [EOL]     List<JSType> typeChain = Lists.newArrayList(ALL_TYPE, createNullableType(OBJECT_TYPE), OBJECT_TYPE, registry.createAnonymousObjectType(null), registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); [EOL]     verifySubtypeChain(typeChain); [EOL] } <line_num>: 5144,5153
public void testAnonymousEnumElementChain() throws Exception { [EOL]     ObjectType enumElemType = registry.createEnumType("typeB", null, registry.createAnonymousObjectType(null)).getElementsType(); [EOL]     List<JSType> typeChain = Lists.newArrayList(ALL_TYPE, createNullableType(OBJECT_TYPE), OBJECT_TYPE, enumElemType, registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); [EOL]     verifySubtypeChain(typeChain); [EOL] } <line_num>: 5155,5167
public void testParameterizedArrayChain() throws Exception { [EOL]     JSType arrayOfNoType = createParameterizedType(ARRAY_TYPE, NO_TYPE); [EOL]     JSType arrayOfString = createParameterizedType(ARRAY_TYPE, STRING_TYPE); [EOL]     JSType arrayOfStringOrNumber = createParameterizedType(ARRAY_TYPE, createUnionType(STRING_TYPE, NUMBER_TYPE)); [EOL]     JSType arrayOfAllType = createParameterizedType(ARRAY_TYPE, ALL_TYPE); [EOL]     List<JSType> typeChain = Lists.newArrayList(registry.getNativeType(JSTypeNative.ALL_TYPE), registry.getNativeType(JSTypeNative.OBJECT_TYPE), arrayOfAllType, arrayOfStringOrNumber, arrayOfString, arrayOfNoType, registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); [EOL]     verifySubtypeChain(typeChain, false); [EOL] } <line_num>: 5169,5189
public void testParameterizedArrayChain2() throws Exception { [EOL]     JSType arrayOfNoType = createParameterizedType(ARRAY_TYPE, NO_TYPE); [EOL]     JSType arrayOfNoObjectType = createParameterizedType(ARRAY_TYPE, NO_OBJECT_TYPE); [EOL]     JSType arrayOfArray = createParameterizedType(ARRAY_TYPE, ARRAY_TYPE); [EOL]     JSType arrayOfObject = createParameterizedType(ARRAY_TYPE, OBJECT_TYPE); [EOL]     JSType arrayOfAllType = createParameterizedType(ARRAY_TYPE, ALL_TYPE); [EOL]     List<JSType> typeChain = Lists.newArrayList(registry.getNativeType(JSTypeNative.ALL_TYPE), registry.getNativeType(JSTypeNative.OBJECT_TYPE), arrayOfAllType, arrayOfObject, arrayOfArray, arrayOfNoObjectType, arrayOfNoType, registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); [EOL]     verifySubtypeChain(typeChain, false); [EOL] } <line_num>: 5191,5214
public void testParameterizedObjectChain() throws Exception { [EOL]     JSType objectOfNoType = createParameterizedType(OBJECT_TYPE, NO_TYPE); [EOL]     JSType objectOfString = createParameterizedType(OBJECT_TYPE, STRING_TYPE); [EOL]     JSType objectOfStringOrNumber = createParameterizedType(OBJECT_TYPE, createUnionType(STRING_TYPE, NUMBER_TYPE)); [EOL]     JSType objectOfAllType = createParameterizedType(OBJECT_TYPE, ALL_TYPE); [EOL]     List<JSType> typeChain = Lists.newArrayList(registry.getNativeType(JSTypeNative.ALL_TYPE), registry.getNativeType(JSTypeNative.OBJECT_TYPE), objectOfAllType, objectOfStringOrNumber, objectOfString, objectOfNoType, registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); [EOL]     verifySubtypeChain(typeChain, false); [EOL] } <line_num>: 5216,5236
public void testMixedParameterizedTypeChain() throws Exception { [EOL]     JSType arrayOfNoType = createParameterizedType(ARRAY_TYPE, NO_TYPE); [EOL]     JSType arrayOfString = createParameterizedType(ARRAY_TYPE, STRING_TYPE); [EOL]     JSType objectOfString = createParameterizedType(OBJECT_TYPE, STRING_TYPE); [EOL]     JSType objectOfStringOrNumber = createParameterizedType(OBJECT_TYPE, createUnionType(STRING_TYPE, NUMBER_TYPE)); [EOL]     JSType objectOfAllType = createParameterizedType(OBJECT_TYPE, ALL_TYPE); [EOL]     List<JSType> typeChain = Lists.newArrayList(registry.getNativeType(JSTypeNative.ALL_TYPE), registry.getNativeType(JSTypeNative.OBJECT_TYPE), objectOfAllType, objectOfStringOrNumber, objectOfString, arrayOfString, arrayOfNoType, registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); [EOL]     verifySubtypeChain(typeChain, false); [EOL] } <line_num>: 5238,5261
public void testParameterizedTypeSubtypes() { [EOL]     JSType objectOfString = createParameterizedType(OBJECT_TYPE, STRING_TYPE); [EOL]     JSType arrayOfString = createParameterizedType(ARRAY_TYPE, STRING_TYPE); [EOL]     JSType arrayOfNumber = createParameterizedType(ARRAY_TYPE, NUMBER_TYPE); [EOL]     JSType arrayOfUnknown = createParameterizedType(ARRAY_TYPE, UNKNOWN_TYPE); [EOL]     assertFalse(objectOfString.isSubtype(ARRAY_TYPE)); [EOL]     assertTrue(ARRAY_TYPE.isSubtype(objectOfString)); [EOL]     assertFalse(objectOfString.isSubtype(ARRAY_TYPE)); [EOL]     assertTrue(ARRAY_TYPE.isSubtype(objectOfString)); [EOL]     assertTrue(arrayOfString.isSubtype(ARRAY_TYPE)); [EOL]     assertTrue(ARRAY_TYPE.isSubtype(arrayOfString)); [EOL]     assertTrue(arrayOfString.isSubtype(arrayOfUnknown)); [EOL]     assertTrue(arrayOfUnknown.isSubtype(arrayOfString)); [EOL]     assertFalse(arrayOfString.isSubtype(arrayOfNumber)); [EOL]     assertFalse(arrayOfNumber.isSubtype(arrayOfString)); [EOL]     assertTrue(arrayOfNumber.isSubtype(createUnionType(arrayOfNumber, NULL_VOID))); [EOL]     assertFalse(createUnionType(arrayOfNumber, NULL_VOID).isSubtype(arrayOfNumber)); [EOL]     assertFalse(arrayOfString.isSubtype(createUnionType(arrayOfNumber, NULL_VOID))); [EOL] } <line_num>: 5263,5291
public void testParameterizedTypeRelations() throws Exception { [EOL]     JSType objectOfString = createParameterizedType(OBJECT_TYPE, STRING_TYPE); [EOL]     JSType arrayOfString = createParameterizedType(ARRAY_TYPE, STRING_TYPE); [EOL]     JSType arrayOfNumber = createParameterizedType(ARRAY_TYPE, NUMBER_TYPE); [EOL]     JSType arrayOfUnknown = createParameterizedType(ARRAY_TYPE, UNKNOWN_TYPE); [EOL]     assertTypeEquals(OBJECT_TYPE, JSType.getLeastSupertype(arrayOfString, OBJECT_TYPE)); [EOL]     assertTypeEquals(OBJECT_TYPE, JSType.getLeastSupertype(OBJECT_TYPE, arrayOfString)); [EOL]     assertTypeEquals(ARRAY_TYPE, JSType.getLeastSupertype(arrayOfString, ARRAY_TYPE)); [EOL]     assertTypeEquals(ARRAY_TYPE, JSType.getLeastSupertype(ARRAY_TYPE, arrayOfString)); [EOL]     assertEquals("(Array|Object.<string>)", JSType.getLeastSupertype(objectOfString, ARRAY_TYPE).toString()); [EOL]     assertEquals("(Array|Object.<string>)", JSType.getLeastSupertype(ARRAY_TYPE, objectOfString).toString()); [EOL]     assertEquals("Array", JSType.getLeastSupertype(arrayOfString, arrayOfNumber).toString()); [EOL]     assertEquals("Array", JSType.getLeastSupertype(arrayOfNumber, arrayOfString).toString()); [EOL]     assertTypeEquals(arrayOfString, JSType.getLeastSupertype(arrayOfString, arrayOfString)); [EOL]     assertEquals("(Array.<string>|Object.<string>)", JSType.getLeastSupertype(objectOfString, arrayOfString).toString()); [EOL]     assertEquals("(Array.<string>|Object.<string>)", JSType.getLeastSupertype(arrayOfString, objectOfString).toString()); [EOL]     assertTypeEquals(objectOfString, JSType.getGreatestSubtype(OBJECT_TYPE, objectOfString)); [EOL]     assertTypeEquals(objectOfString, JSType.getGreatestSubtype(objectOfString, OBJECT_TYPE)); [EOL]     assertTypeEquals(ARRAY_TYPE, JSType.getGreatestSubtype(objectOfString, ARRAY_TYPE)); [EOL]     assertTypeEquals(JSType.getGreatestSubtype(objectOfString, arrayOfString), NO_OBJECT_TYPE); [EOL]     assertTypeEquals(JSType.getGreatestSubtype(OBJECT_TYPE, arrayOfString), arrayOfString); [EOL] } <line_num>: 5293,5373
public void verifySubtypeChain(List<JSType> typeChain) throws Exception { [EOL]     verifySubtypeChain(typeChain, true); [EOL] } <line_num>: 5384,5386
public void verifySubtypeChain(List<JSType> typeChain, boolean checkSubtyping) throws Exception { [EOL]     for (int i = 0; i < typeChain.size(); i++) { [EOL]         for (int j = 0; j < typeChain.size(); j++) { [EOL]             JSType typeI = typeChain.get(i); [EOL]             JSType typeJ = typeChain.get(j); [EOL]             JSType namedTypeI = getNamedWrapper("TypeI", typeI); [EOL]             JSType namedTypeJ = getNamedWrapper("TypeJ", typeJ); [EOL]             JSType proxyTypeI = new ProxyObjectType(registry, typeI); [EOL]             JSType proxyTypeJ = new ProxyObjectType(registry, typeJ); [EOL]             if (i == j) { [EOL]                 assertTrue(typeI + " should equal itself", typeI.isEquivalentTo(typeI)); [EOL]                 assertTrue("Named " + typeI + " should equal itself", namedTypeI.isEquivalentTo(namedTypeI)); [EOL]                 assertTrue("Proxy " + typeI + " should equal itself", proxyTypeI.isEquivalentTo(proxyTypeI)); [EOL]             } else { [EOL]                 assertFalse(typeI + " should not equal " + typeJ, typeI.isEquivalentTo(typeJ)); [EOL]                 assertFalse("Named " + typeI + " should not equal " + typeJ, namedTypeI.isEquivalentTo(namedTypeJ)); [EOL]                 assertFalse("Proxy " + typeI + " should not equal " + typeJ, proxyTypeI.isEquivalentTo(proxyTypeJ)); [EOL]             } [EOL]             assertTrue(typeJ + " should be castable to " + typeI, typeJ.canCastTo(typeI)); [EOL]             assertTrue(typeJ + " should be castable to Named " + namedTypeI, typeJ.canCastTo(namedTypeI)); [EOL]             assertTrue(typeJ + " should be castable to Proxy " + proxyTypeI, typeJ.canCastTo(proxyTypeI)); [EOL]             assertTrue("Named " + typeJ + " should be castable to " + typeI, namedTypeJ.canCastTo(typeI)); [EOL]             assertTrue("Named " + typeJ + " should be castable to Named " + typeI, namedTypeJ.canCastTo(namedTypeI)); [EOL]             assertTrue("Named " + typeJ + " should be castable to Proxy " + typeI, namedTypeJ.canCastTo(proxyTypeI)); [EOL]             assertTrue("Proxy " + typeJ + " should be castable to " + typeI, proxyTypeJ.canCastTo(typeI)); [EOL]             assertTrue("Proxy " + typeJ + " should be castable to Named " + typeI, proxyTypeJ.canCastTo(namedTypeI)); [EOL]             assertTrue("Proxy " + typeJ + " should be castable to Proxy " + typeI, proxyTypeJ.canCastTo(proxyTypeI)); [EOL]             if (checkSubtyping) { [EOL]                 if (i <= j) { [EOL]                     assertTrue(typeJ + " should be a subtype of " + typeI, typeJ.isSubtype(typeI)); [EOL]                     assertTrue("Named " + typeJ + " should be a subtype of Named " + typeI, namedTypeJ.isSubtype(namedTypeI)); [EOL]                     assertTrue("Proxy " + typeJ + " should be a subtype of Proxy " + typeI, proxyTypeJ.isSubtype(proxyTypeI)); [EOL]                 } else { [EOL]                     assertFalse(typeJ + " should not be a subtype of " + typeI, typeJ.isSubtype(typeI)); [EOL]                     assertFalse("Named " + typeJ + " should not be a subtype of Named " + typeI, namedTypeJ.isSubtype(namedTypeI)); [EOL]                     assertFalse("Named " + typeJ + " should not be a subtype of Named " + typeI, proxyTypeJ.isSubtype(proxyTypeI)); [EOL]                 } [EOL]                 JSType expectedSupremum = i < j ? typeI : typeJ; [EOL]                 JSType expectedInfimum = i > j ? typeI : typeJ; [EOL]                 assertTypeEquals(expectedSupremum + " should be the least supertype of " + typeI + " and " + typeJ, expectedSupremum, typeI.getLeastSupertype(typeJ)); [EOL]                 assertTypeEquals(expectedInfimum + " should be the greatest subtype of " + typeI + " and " + typeJ, expectedInfimum, typeI.getGreatestSubtype(typeJ)); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 5388,5501
JSType getNamedWrapper(String name, JSType jstype) { [EOL]     if (!jstype.isNoType()) { [EOL]         NamedType namedWrapper = new NamedType(registry, name, "[testcode]", -1, -1); [EOL]         namedWrapper.setReferencedType(jstype); [EOL]         return namedWrapper; [EOL]     } else { [EOL]         return jstype; [EOL]     } [EOL] } <line_num>: 5503,5514
@SuppressWarnings("checked") [EOL] public void testRestrictedTypeGivenToBoolean() { [EOL]     assertTypeEquals(BOOLEAN_TYPE, BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true)); [EOL]     assertTypeEquals(BOOLEAN_TYPE, BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false)); [EOL]     assertTypeEquals(NO_TYPE, NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true)); [EOL]     assertTypeEquals(NULL_TYPE, NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false)); [EOL]     assertTypeEquals(NUMBER_TYPE, NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(true)); [EOL]     assertTypeEquals(NUMBER_TYPE, NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(false)); [EOL]     assertTypeEquals(STRING_TYPE, STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(true)); [EOL]     assertTypeEquals(STRING_TYPE, STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(false)); [EOL]     assertTypeEquals(STRING_OBJECT_TYPE, STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true)); [EOL]     assertTypeEquals(NO_TYPE, STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false)); [EOL]     assertTypeEquals(NO_TYPE, VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(true)); [EOL]     assertTypeEquals(VOID_TYPE, VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(false)); [EOL]     assertTypeEquals(NO_OBJECT_TYPE, NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true)); [EOL]     assertTypeEquals(NO_TYPE, NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false)); [EOL]     assertTypeEquals(NO_TYPE, NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(true)); [EOL]     assertTypeEquals(NO_TYPE, NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(false)); [EOL]     assertTypeEquals(ALL_TYPE, ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true)); [EOL]     assertTypeEquals(ALL_TYPE, ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false)); [EOL]     assertTypeEquals(CHECKED_UNKNOWN_TYPE, UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true)); [EOL]     assertTypeEquals(UNKNOWN_TYPE, UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false)); [EOL]     UnionType nullableStringValue = (UnionType) createNullableType(STRING_TYPE); [EOL]     assertTypeEquals(STRING_TYPE, nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(true)); [EOL]     assertTypeEquals(nullableStringValue, nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(false)); [EOL]     UnionType nullableStringObject = (UnionType) createNullableType(STRING_OBJECT_TYPE); [EOL]     assertTypeEquals(STRING_OBJECT_TYPE, nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(true)); [EOL]     assertTypeEquals(NULL_TYPE, nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(false)); [EOL] } <line_num>: 5520,5587
public void testRegisterProperty() { [EOL]     int i = 0; [EOL]     List<JSType> allObjects = Lists.newArrayList(); [EOL]     for (JSType type : types) { [EOL]         String propName = "ALF" + i++; [EOL]         if (type instanceof ObjectType) { [EOL]             ObjectType objType = (ObjectType) type; [EOL]             objType.defineDeclaredProperty(propName, UNKNOWN_TYPE, null); [EOL]             objType.defineDeclaredProperty("allHaz", UNKNOWN_TYPE, null); [EOL]             assertTypeEquals(type, registry.getGreatestSubtypeWithProperty(type, propName)); [EOL]             List<JSType> typesWithProp = Lists.newArrayList(registry.getTypesWithProperty(propName)); [EOL]             String message = type.toString(); [EOL]             assertEquals(message, 1, typesWithProp.size()); [EOL]             assertTypeEquals(type, typesWithProp.get(0)); [EOL]             assertTypeEquals(NO_TYPE, registry.getGreatestSubtypeWithProperty(type, "GRRR")); [EOL]             allObjects.add(type); [EOL]         } [EOL]     } [EOL]     assertTypeListEquals(registry.getTypesWithProperty("GRRR"), Lists.newArrayList(NO_TYPE)); [EOL]     assertTypeListEquals(allObjects, registry.getTypesWithProperty("allHaz")); [EOL] } <line_num>: 5589,5618
public void testRegisterPropertyMemoization() { [EOL]     ObjectType derived1 = registry.createObjectType("d1", null, namedGoogBar); [EOL]     ObjectType derived2 = registry.createObjectType("d2", null, namedGoogBar); [EOL]     derived1.defineDeclaredProperty("propz", UNKNOWN_TYPE, null); [EOL]     assertTypeEquals(derived1, registry.getGreatestSubtypeWithProperty(derived1, "propz")); [EOL]     assertTypeEquals(NO_OBJECT_TYPE, registry.getGreatestSubtypeWithProperty(derived2, "propz")); [EOL]     derived2.defineDeclaredProperty("propz", UNKNOWN_TYPE, null); [EOL]     assertTypeEquals(derived1, registry.getGreatestSubtypeWithProperty(derived1, "propz")); [EOL]     assertTypeEquals(derived2, registry.getGreatestSubtypeWithProperty(derived2, "propz")); [EOL] } <line_num>: 5620,5637
public void testGreatestSubtypeWithProperty() { [EOL]     ObjectType foo = registry.createObjectType("foo", null, OBJECT_TYPE); [EOL]     ObjectType bar = registry.createObjectType("bar", null, namedGoogBar); [EOL]     foo.defineDeclaredProperty("propz", UNKNOWN_TYPE, null); [EOL]     bar.defineDeclaredProperty("propz", UNKNOWN_TYPE, null); [EOL]     assertTypeEquals(bar, registry.getGreatestSubtypeWithProperty(namedGoogBar, "propz")); [EOL] } <line_num>: 5643,5652
public void testGoodSetPrototypeBasedOn() { [EOL]     FunctionType fun = registry.createConstructorType("fun", null, null, null, null); [EOL]     fun.setPrototypeBasedOn(unresolvedNamedType); [EOL]     assertTrue(fun.getInstanceType().isUnknownType()); [EOL] } <line_num>: 5654,5659
public void testLateSetPrototypeBasedOn() { [EOL]     FunctionType fun = registry.createConstructorType("fun", null, null, null, null); [EOL]     assertFalse(fun.getInstanceType().isUnknownType()); [EOL]     fun.setPrototypeBasedOn(unresolvedNamedType); [EOL]     assertTrue(fun.getInstanceType().isUnknownType()); [EOL] } <line_num>: 5661,5668
public void testGetTypeUnderEquality1() { [EOL]     for (JSType type : types) { [EOL]         testGetTypeUnderEquality(type, type, type, type); [EOL]     } [EOL] } <line_num>: 5670,5674
public void testGetTypesUnderEquality2() { [EOL]     testGetTypeUnderEquality(NUMBER_TYPE, OBJECT_TYPE, NUMBER_TYPE, OBJECT_TYPE); [EOL] } <line_num>: 5676,5681
public void testGetTypesUnderEquality3() { [EOL]     testGetTypeUnderEquality(NULL_TYPE, VOID_TYPE, NULL_TYPE, VOID_TYPE); [EOL] } <line_num>: 5683,5688
@SuppressWarnings("checked") [EOL] public void testGetTypesUnderEquality4() { [EOL]     UnionType stringNumber = (UnionType) createUnionType(NUMBER_TYPE, STRING_TYPE); [EOL]     testGetTypeUnderEquality(stringNumber, STRING_TYPE, stringNumber, STRING_TYPE); [EOL]     testGetTypeUnderEquality(stringNumber, NUMBER_TYPE, stringNumber, NUMBER_TYPE); [EOL] } <line_num>: 5690,5701
public void testGetTypesUnderEquality5() { [EOL]     JSType nullUndefined = createUnionType(VOID_TYPE, NULL_TYPE); [EOL]     testGetTypeUnderEquality(nullUndefined, NULL_TYPE, nullUndefined, NULL_TYPE); [EOL]     testGetTypeUnderEquality(nullUndefined, VOID_TYPE, nullUndefined, VOID_TYPE); [EOL] } <line_num>: 5703,5712
public void testGetTypesUnderEquality6() { [EOL]     JSType optNullNumber = createUnionType(VOID_TYPE, NULL_TYPE, NUMBER_TYPE); [EOL]     testGetTypeUnderEquality(optNullNumber, NULL_TYPE, createUnionType(NULL_TYPE, VOID_TYPE), NULL_TYPE); [EOL] } <line_num>: 5714,5720
private void testGetTypeUnderEquality(JSType t1, JSType t2, JSType t1Eq, JSType t2Eq) { [EOL]     TypePair p12 = t1.getTypesUnderEquality(t2); [EOL]     TypePair p21 = t2.getTypesUnderEquality(t1); [EOL]     assertTypeEquals(t1Eq, p12.typeA); [EOL]     assertTypeEquals(t1Eq, p21.typeB); [EOL]     assertTypeEquals(t2Eq, p12.typeB); [EOL]     assertTypeEquals(t2Eq, p21.typeA); [EOL] } <line_num>: 5722,5735
@SuppressWarnings("checked") [EOL] public void testGetTypesUnderInequality1() { [EOL]     UnionType numberObject = (UnionType) createUnionType(NUMBER_TYPE, OBJECT_TYPE); [EOL]     testGetTypesUnderInequality(numberObject, NUMBER_TYPE, numberObject, NUMBER_TYPE); [EOL]     testGetTypesUnderInequality(numberObject, OBJECT_TYPE, numberObject, OBJECT_TYPE); [EOL] } <line_num>: 5737,5748
@SuppressWarnings("checked") [EOL] public void testGetTypesUnderInequality2() { [EOL]     UnionType nullUndefined = (UnionType) createUnionType(VOID_TYPE, NULL_TYPE); [EOL]     testGetTypesUnderInequality(nullUndefined, NULL_TYPE, NO_TYPE, NO_TYPE); [EOL]     testGetTypesUnderInequality(nullUndefined, VOID_TYPE, NO_TYPE, NO_TYPE); [EOL] } <line_num>: 5750,5761
@SuppressWarnings("checked") [EOL] public void testGetTypesUnderInequality3() { [EOL]     UnionType stringNumber = (UnionType) createUnionType(NUMBER_TYPE, STRING_TYPE); [EOL]     testGetTypesUnderInequality(stringNumber, NUMBER_TYPE, stringNumber, NUMBER_TYPE); [EOL]     testGetTypesUnderInequality(stringNumber, STRING_TYPE, stringNumber, STRING_TYPE); [EOL] } <line_num>: 5763,5774
@SuppressWarnings("checked") [EOL] public void testGetTypesUnderInequality4() throws Exception { [EOL]     UnionType nullableOptionalNumber = (UnionType) createUnionType(NULL_TYPE, VOID_TYPE, NUMBER_TYPE); [EOL]     testGetTypesUnderInequality(nullableOptionalNumber, NULL_TYPE, NUMBER_TYPE, NULL_TYPE); [EOL] } <line_num>: 5776,5784
private void testGetTypesUnderInequality(JSType t1, JSType t2, JSType t1Eq, JSType t2Eq) { [EOL]     TypePair p12 = t1.getTypesUnderInequality(t2); [EOL]     TypePair p21 = t2.getTypesUnderInequality(t1); [EOL]     assertTypeEquals(t1Eq, p12.typeA); [EOL]     assertTypeEquals(t1Eq, p21.typeB); [EOL]     assertTypeEquals(t2Eq, p12.typeB); [EOL]     assertTypeEquals(t2Eq, p21.typeA); [EOL] } <line_num>: 5786,5799
public void testCreateRecordType() throws Exception { [EOL]     Map<String, RecordProperty> properties = new HashMap<String, RecordProperty>(); [EOL]     properties.put("hello", new RecordProperty(NUMBER_TYPE, null)); [EOL]     JSType recordType = registry.createRecordType(properties); [EOL]     assertEquals("{hello: number}", recordType.toString()); [EOL] } <line_num>: 5806,5813
public void testCreateOptionalType() throws Exception { [EOL]     UnionType optNumber = (UnionType) registry.createOptionalType(NUMBER_TYPE); [EOL]     assertUnionContains(optNumber, NUMBER_TYPE); [EOL]     assertUnionContains(optNumber, VOID_TYPE); [EOL]     UnionType optUnion = (UnionType) registry.createOptionalType(createUnionType(STRING_OBJECT_TYPE, DATE_TYPE)); [EOL]     assertUnionContains(optUnion, DATE_TYPE); [EOL]     assertUnionContains(optUnion, STRING_OBJECT_TYPE); [EOL]     assertUnionContains(optUnion, VOID_TYPE); [EOL] } <line_num>: 5818,5831
public void assertUnionContains(UnionType union, JSType type) { [EOL]     assertTrue(union + " should contain " + type, union.contains(type)); [EOL] } <line_num>: 5833,5835
public void testCreateAnonymousObjectType() throws Exception { [EOL]     ObjectType anonymous = registry.createAnonymousObjectType(null); [EOL]     assertTypeEquals(OBJECT_TYPE, anonymous.getImplicitPrototype()); [EOL]     assertNull(anonymous.getReferenceName()); [EOL]     assertEquals("{}", anonymous.toString()); [EOL] } <line_num>: 5841,5847
public void testCreateAnonymousObjectType2() throws Exception { [EOL]     ObjectType anonymous = registry.createAnonymousObjectType(null); [EOL]     anonymous.defineDeclaredProperty("a", NUMBER_TYPE, null); [EOL]     anonymous.defineDeclaredProperty("b", NUMBER_TYPE, null); [EOL]     anonymous.defineDeclaredProperty("c", NUMBER_TYPE, null); [EOL]     anonymous.defineDeclaredProperty("d", NUMBER_TYPE, null); [EOL]     anonymous.defineDeclaredProperty("e", NUMBER_TYPE, null); [EOL]     anonymous.defineDeclaredProperty("f", NUMBER_TYPE, null); [EOL]     assertEquals("{a: number, b: number, c: number, d: number, ...}", anonymous.toString()); [EOL] } <line_num>: 5854,5871
public void testCreateObjectType() throws Exception { [EOL]     ObjectType subDate = registry.createObjectType(DATE_TYPE.getImplicitPrototype()); [EOL]     assertTypeEquals(DATE_TYPE.getImplicitPrototype(), subDate.getImplicitPrototype()); [EOL]     assertNull(subDate.getReferenceName()); [EOL]     assertEquals("{...}", subDate.toString()); [EOL]     ObjectType subError = registry.createObjectType("Foo", null, ERROR_TYPE.getImplicitPrototype()); [EOL]     assertTypeEquals(ERROR_TYPE.getImplicitPrototype(), subError.getImplicitPrototype()); [EOL]     assertEquals("Foo", subError.getReferenceName()); [EOL] } <line_num>: 5878,5893
@SuppressWarnings("checked") [EOL] public void testBug903110() throws Exception { [EOL]     UnionType union = (UnionType) createUnionType(U2U_CONSTRUCTOR_TYPE, VOID_TYPE); [EOL]     assertTrue(VOID_TYPE.isSubtype(union)); [EOL]     assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(union)); [EOL]     assertTrue(union.isSubtype(union)); [EOL] } <line_num>: 5898,5905
public void testBug904123() throws Exception { [EOL]     assertTrue(U2U_FUNCTION_TYPE.isSubtype(U2U_CONSTRUCTOR_TYPE)); [EOL]     assertTrue(U2U_FUNCTION_TYPE.isSubtype(createOptionalType(U2U_CONSTRUCTOR_TYPE))); [EOL] } <line_num>: 5911,5915
private void assertTypeCanAssignToItself(JSType type) { [EOL]     assertTrue(type.isSubtype(type)); [EOL] } <line_num>: 5920,5922
public void testHasOwnProperty() throws Exception { [EOL]     ObjectType sup = registry.createObjectType(registry.createAnonymousObjectType(null)); [EOL]     ObjectType sub = registry.createObjectType(sup); [EOL]     sup.defineProperty("base", null, false, null); [EOL]     sub.defineProperty("sub", null, false, null); [EOL]     assertTrue(sup.hasProperty("base")); [EOL]     assertFalse(sup.hasProperty("sub")); [EOL]     assertTrue(sup.hasOwnProperty("base")); [EOL]     assertFalse(sup.hasOwnProperty("sub")); [EOL]     assertFalse(sup.hasOwnProperty("none")); [EOL]     assertTrue(sub.hasProperty("base")); [EOL]     assertTrue(sub.hasProperty("sub")); [EOL]     assertFalse(sub.hasOwnProperty("base")); [EOL]     assertTrue(sub.hasOwnProperty("sub")); [EOL]     assertFalse(sub.hasOwnProperty("none")); [EOL] } <line_num>: 5929,5948
public void testNamedTypeHasOwnProperty() throws Exception { [EOL]     namedGoogBar.getImplicitPrototype().defineProperty("base", null, false, null); [EOL]     namedGoogBar.defineProperty("sub", null, false, null); [EOL]     assertFalse(namedGoogBar.hasOwnProperty("base")); [EOL]     assertTrue(namedGoogBar.hasProperty("base")); [EOL]     assertTrue(namedGoogBar.hasOwnProperty("sub")); [EOL]     assertTrue(namedGoogBar.hasProperty("sub")); [EOL] } <line_num>: 5950,5959
public void testInterfaceHasOwnProperty() throws Exception { [EOL]     interfaceInstType.defineProperty("base", null, false, null); [EOL]     subInterfaceInstType.defineProperty("sub", null, false, null); [EOL]     assertTrue(interfaceInstType.hasProperty("base")); [EOL]     assertFalse(interfaceInstType.hasProperty("sub")); [EOL]     assertTrue(interfaceInstType.hasOwnProperty("base")); [EOL]     assertFalse(interfaceInstType.hasOwnProperty("sub")); [EOL]     assertFalse(interfaceInstType.hasOwnProperty("none")); [EOL]     assertTrue(subInterfaceInstType.hasProperty("base")); [EOL]     assertTrue(subInterfaceInstType.hasProperty("sub")); [EOL]     assertFalse(subInterfaceInstType.hasOwnProperty("base")); [EOL]     assertTrue(subInterfaceInstType.hasOwnProperty("sub")); [EOL]     assertFalse(subInterfaceInstType.hasOwnProperty("none")); [EOL] } <line_num>: 5961,5976
public void testGetPropertyNames() throws Exception { [EOL]     ObjectType sup = registry.createObjectType(registry.createAnonymousObjectType(null)); [EOL]     ObjectType sub = registry.createObjectType(sup); [EOL]     sup.defineProperty("base", null, false, null); [EOL]     sub.defineProperty("sub", null, false, null); [EOL]     assertEquals(Sets.newHashSet("isPrototypeOf", "toLocaleString", "propertyIsEnumerable", "toString", "valueOf", "hasOwnProperty", "constructor", "base", "sub"), sub.getPropertyNames()); [EOL]     assertEquals(Sets.newHashSet("isPrototypeOf", "toLocaleString", "propertyIsEnumerable", "toString", "valueOf", "hasOwnProperty", "constructor", "base"), sup.getPropertyNames()); [EOL]     assertEquals(Sets.newHashSet(), NO_OBJECT_TYPE.getPropertyNames()); [EOL] } <line_num>: 5978,5994
public void testGetAndSetJSDocInfoWithNamedType() throws Exception { [EOL]     JSDocInfo info = new JSDocInfo(); [EOL]     info.setDeprecated(true); [EOL]     assertNull(namedGoogBar.getOwnPropertyJSDocInfo("X")); [EOL]     namedGoogBar.setPropertyJSDocInfo("X", info); [EOL]     assertTrue(namedGoogBar.getOwnPropertyJSDocInfo("X").isDeprecated()); [EOL]     assertPropertyTypeInferred(namedGoogBar, "X"); [EOL]     assertTypeEquals(UNKNOWN_TYPE, namedGoogBar.getPropertyType("X")); [EOL] } <line_num>: 5996,6005
public void testGetAndSetJSDocInfoWithObjectTypes() throws Exception { [EOL]     ObjectType sup = registry.createObjectType(registry.createAnonymousObjectType(null)); [EOL]     ObjectType sub = registry.createObjectType(sup); [EOL]     JSDocInfo deprecated = new JSDocInfo(); [EOL]     deprecated.setDeprecated(true); [EOL]     JSDocInfo privateInfo = new JSDocInfo(); [EOL]     privateInfo.setVisibility(Visibility.PRIVATE); [EOL]     sup.defineProperty("X", NUMBER_TYPE, true, null); [EOL]     sup.setPropertyJSDocInfo("X", privateInfo); [EOL]     sub.defineProperty("X", NUMBER_TYPE, true, null); [EOL]     sub.setPropertyJSDocInfo("X", deprecated); [EOL]     assertFalse(sup.getOwnPropertyJSDocInfo("X").isDeprecated()); [EOL]     assertEquals(Visibility.PRIVATE, sup.getOwnPropertyJSDocInfo("X").getVisibility()); [EOL]     assertTypeEquals(NUMBER_TYPE, sup.getPropertyType("X")); [EOL]     assertTrue(sub.getOwnPropertyJSDocInfo("X").isDeprecated()); [EOL]     assertNull(sub.getOwnPropertyJSDocInfo("X").getVisibility()); [EOL]     assertTypeEquals(NUMBER_TYPE, sub.getPropertyType("X")); [EOL] } <line_num>: 6007,6031
public void testGetAndSetJSDocInfoWithNoType() throws Exception { [EOL]     JSDocInfo deprecated = new JSDocInfo(); [EOL]     deprecated.setDeprecated(true); [EOL]     NO_TYPE.setPropertyJSDocInfo("X", deprecated); [EOL]     assertNull(NO_TYPE.getOwnPropertyJSDocInfo("X")); [EOL] } <line_num>: 6033,6039
public void testObjectGetSubTypes() throws Exception { [EOL]     assertTrue(containsType(OBJECT_FUNCTION_TYPE.getSubTypes(), googBar)); [EOL]     assertTrue(containsType(googBar.getSubTypes(), googSubBar)); [EOL]     assertFalse(containsType(googBar.getSubTypes(), googSubSubBar)); [EOL]     assertFalse(containsType(googSubBar.getSubTypes(), googSubBar)); [EOL]     assertTrue(containsType(googSubBar.getSubTypes(), googSubSubBar)); [EOL] } <line_num>: 6041,6057
public void testImplementingType() throws Exception { [EOL]     assertTrue(containsType(registry.getDirectImplementors(interfaceType.getInstanceType()), googBar)); [EOL] } <line_num>: 6059,6065
public void testIsTemplatedType() throws Exception { [EOL]     assertTrue(new TemplateType(registry, "T").hasAnyTemplateTypes()); [EOL]     assertFalse(ARRAY_TYPE.hasAnyTemplateTypes()); [EOL]     assertTrue(registry.createParameterizedType(ARRAY_TYPE, new TemplateType(registry, "T")).hasAnyTemplateTypes()); [EOL]     assertFalse(registry.createParameterizedType(ARRAY_TYPE, STRING_TYPE).hasAnyTemplateTypes()); [EOL]     assertTrue(new FunctionBuilder(registry).withReturnType(new TemplateType(registry, "T")).build().hasAnyTemplateTypes()); [EOL]     assertTrue(new FunctionBuilder(registry).withTypeOfThis(new TemplateType(registry, "T")).build().hasAnyTemplateTypes()); [EOL]     assertFalse(new FunctionBuilder(registry).withReturnType(STRING_TYPE).build().hasAnyTemplateTypes()); [EOL]     assertTrue(registry.createUnionType(NULL_TYPE, new TemplateType(registry, "T"), STRING_TYPE).hasAnyTemplateTypes()); [EOL]     assertFalse(registry.createUnionType(NULL_TYPE, ARRAY_TYPE, STRING_TYPE).hasAnyTemplateTypes()); [EOL] } <line_num>: 6067,6108
public void testTemplatizedType() throws Exception { [EOL]     FunctionType templatizedCtor = registry.createConstructorType("TestingType", null, null, UNKNOWN_TYPE, ImmutableList.of("A", "B")); [EOL]     JSType templatizedInstance = registry.createTemplatizedType(templatizedCtor.getInstanceType(), ImmutableList.of(NUMBER_TYPE, STRING_TYPE)); [EOL]     assertTrue(templatizedInstance.isTemplatized()); [EOL]     assertTrue(templatizedInstance.hasTemplatizedType("A")); [EOL]     assertTrue(templatizedInstance.hasTemplatizedType("B")); [EOL]     assertFalse(templatizedInstance.hasTemplatizedType("C")); [EOL]     assertEquals(NUMBER_TYPE, templatizedInstance.getTemplatizedType("A")); [EOL]     assertEquals(STRING_TYPE, templatizedInstance.getTemplatizedType("B")); [EOL]     assertEquals(UNKNOWN_TYPE, templatizedInstance.getTemplatizedType("C")); [EOL]     assertEquals("TestingType.<number,string>", templatizedInstance.toString()); [EOL] } <line_num>: 6110,6127
public void testPartiallyTemplatizedType() throws Exception { [EOL]     FunctionType templatizedCtor = registry.createConstructorType("TestingType", null, null, UNKNOWN_TYPE, ImmutableList.of("A", "B")); [EOL]     JSType templatizedInstance = registry.createTemplatizedType(templatizedCtor.getInstanceType(), ImmutableList.of(NUMBER_TYPE)); [EOL]     assertTrue(templatizedInstance.isTemplatized()); [EOL]     assertTrue(templatizedInstance.hasTemplatizedType("A")); [EOL]     assertTrue(templatizedInstance.hasTemplatizedType("B")); [EOL]     assertFalse(templatizedInstance.hasTemplatizedType("C")); [EOL]     assertEquals(NUMBER_TYPE, templatizedInstance.getTemplatizedType("A")); [EOL]     assertEquals(UNKNOWN_TYPE, templatizedInstance.getTemplatizedType("B")); [EOL]     assertEquals(UNKNOWN_TYPE, templatizedInstance.getTemplatizedType("C")); [EOL]     assertEquals("TestingType.<number,?>", templatizedInstance.toString()); [EOL] } <line_num>: 6129,6146
public void testInvalidTemplatizedType() throws Exception { [EOL]     FunctionType templatizedCtor = registry.createConstructorType("TestingType", null, null, UNKNOWN_TYPE, ImmutableList.of("A", "B")); [EOL]     boolean exceptionThrown = false; [EOL]     try { [EOL]         JSType templatizedInstance = registry.createTemplatizedType(templatizedCtor.getInstanceType(), ImmutableList.of(NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE)); [EOL]     } catch (IllegalArgumentException e) { [EOL]         exceptionThrown = true; [EOL]     } [EOL]     assertTrue(exceptionThrown); [EOL] } <line_num>: 6148,6161
public void testCanCastTo() { [EOL]     assertTrue(ALL_TYPE.canCastTo(NULL_TYPE)); [EOL]     assertTrue(ALL_TYPE.canCastTo(VOID_TYPE)); [EOL]     assertTrue(ALL_TYPE.canCastTo(STRING_TYPE)); [EOL]     assertTrue(ALL_TYPE.canCastTo(NUMBER_TYPE)); [EOL]     assertTrue(ALL_TYPE.canCastTo(BOOLEAN_TYPE)); [EOL]     assertTrue(ALL_TYPE.canCastTo(OBJECT_TYPE)); [EOL]     assertFalse(NUMBER_TYPE.canCastTo(NULL_TYPE)); [EOL]     assertFalse(NUMBER_TYPE.canCastTo(VOID_TYPE)); [EOL]     assertFalse(NUMBER_TYPE.canCastTo(STRING_TYPE)); [EOL]     assertTrue(NUMBER_TYPE.canCastTo(NUMBER_TYPE)); [EOL]     assertFalse(NUMBER_TYPE.canCastTo(BOOLEAN_TYPE)); [EOL]     assertFalse(NUMBER_TYPE.canCastTo(OBJECT_TYPE)); [EOL]     assertFalse(STRING_TYPE.canCastTo(NULL_TYPE)); [EOL]     assertFalse(STRING_TYPE.canCastTo(VOID_TYPE)); [EOL]     assertTrue(STRING_TYPE.canCastTo(STRING_TYPE)); [EOL]     assertFalse(STRING_TYPE.canCastTo(NUMBER_TYPE)); [EOL]     assertFalse(STRING_TYPE.canCastTo(BOOLEAN_TYPE)); [EOL]     assertFalse(STRING_TYPE.canCastTo(OBJECT_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.canCastTo(NULL_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.canCastTo(VOID_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.canCastTo(STRING_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.canCastTo(NUMBER_TYPE)); [EOL]     assertTrue(BOOLEAN_TYPE.canCastTo(BOOLEAN_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.canCastTo(OBJECT_TYPE)); [EOL]     assertFalse(OBJECT_TYPE.canCastTo(NULL_TYPE)); [EOL]     assertFalse(OBJECT_TYPE.canCastTo(VOID_TYPE)); [EOL]     assertFalse(OBJECT_TYPE.canCastTo(STRING_TYPE)); [EOL]     assertFalse(OBJECT_TYPE.canCastTo(NUMBER_TYPE)); [EOL]     assertFalse(OBJECT_TYPE.canCastTo(BOOLEAN_TYPE)); [EOL]     assertTrue(OBJECT_TYPE.canCastTo(OBJECT_TYPE)); [EOL]     assertFalse(BOOLEAN_TYPE.canCastTo(OBJECT_NUMBER_STRING)); [EOL]     assertFalse(OBJECT_NUMBER_STRING.canCastTo(BOOLEAN_TYPE)); [EOL]     assertFalse(ARRAY_TYPE.canCastTo(U2U_FUNCTION_TYPE)); [EOL]     assertFalse(U2U_FUNCTION_TYPE.canCastTo(ARRAY_TYPE)); [EOL]     assertFalse(NULL_VOID.canCastTo(ARRAY_TYPE)); [EOL]     assertTrue(NULL_VOID.canCastTo(createUnionType(ARRAY_TYPE, NULL_TYPE))); [EOL]     assertTrue(ARRAY_FUNCTION_TYPE.canCastTo(BOOLEAN_OBJECT_FUNCTION_TYPE)); [EOL] } <line_num>: 6163,6211
private static boolean containsType(Iterable<? extends JSType> types, JSType type) { [EOL]     for (JSType alt : types) { [EOL]         if (alt.isEquivalentTo(type)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 6213,6221
private static boolean assertTypeListEquals(Iterable<? extends JSType> typeListA, Iterable<? extends JSType> typeListB) { [EOL]     for (JSType alt : typeListA) { [EOL]         assertTrue("List : " + typeListA + "\n" + "does not contain: " + alt, containsType(typeListA, alt)); [EOL]     } [EOL]     for (JSType alt : typeListB) { [EOL]         assertTrue("List : " + typeListB + "\n" + "does not contain: " + alt, containsType(typeListB, alt)); [EOL]     } [EOL]     return false; [EOL] } <line_num>: 6223,6239
private ArrowType createArrowType(Node params) { [EOL]     return registry.createArrowType(params); [EOL] } <line_num>: 6241,6243
