public TightenTypesTest() { [EOL]     parseTypeInfo = true; [EOL]     enableTypeCheck(CheckLevel.WARNING); [EOL]     enableNormalize(true); [EOL] } <line_num>: 32,36
@Override [EOL] public CompilerPass getProcessor(Compiler compiler) { [EOL]     return (tt = new TightenTypes(compiler)); [EOL] } <line_num>: 38,41
@Override [EOL] protected int getNumRepetitions() { [EOL]     return 1; [EOL] } <line_num>: 43,46
@Override [EOL] protected CompilerOptions getOptions() { [EOL]     return new CompilerOptions(); [EOL] } <line_num>: 48,51
public void testTopLevelVariables() { [EOL]     testSame("/** @constructor */ function Foo() {}\n" + "var a = new Foo();\n" + "var b = a;\n"); [EOL]     assertTrue(getType("Foo").isFunction()); [EOL]     assertTrue(getType("a").isInstance()); [EOL]     assertType("function (this:Foo): ()", getType("Foo")); [EOL]     assertType("Foo", getType("a")); [EOL]     assertType("Foo", getType("b")); [EOL]     testSame("/** @constructor */ function Foo() {}\n" + "/** @constructor */ function Bar() {}\n" + "var a = new Foo();\n" + "a = new Bar();\n" + "var b = a;\n"); [EOL]     assertTrue(getType("a").isUnion()); [EOL]     assertType("(Bar,Foo)", getType("a")); [EOL]     assertType("Bar", getType("b")); [EOL] } <line_num>: 53,73
public void testNamespacedVariables() { [EOL]     testSame("var goog = goog || {}; goog.foo = {};\n" + "/** @constructor */ goog.foo.Foo = function() {};\n" + "goog.foo.Foo.prototype.blah = function() {};\n" + "/** @constructor */ goog.foo.Bar = function() {};\n" + "goog.foo.Bar.prototype.blah = function() {};\n" + "function bar(a) { a.blah(); }\n" + "var baz = bar;\n" + "bar(new goog.foo.Foo);\n" + "baz(new goog.foo.Bar);\n"); [EOL]     assertType("(goog.foo.Bar,goog.foo.Foo)", getParamType(getType("bar"), 0)); [EOL]     assertType("(goog.foo.Bar,goog.foo.Foo)", getParamType(getType("baz"), 0)); [EOL] } <line_num>: 75,88
public void testReturnSlot() { [EOL]     testSame("/** @constructor */ function Foo() {}\n" + "function bar() {\n" + "  var a = new Foo();\n" + "  return a;\n" + "}\n" + "var b = bar();\n"); [EOL]     assertType("Foo", getType("b")); [EOL] } <line_num>: 90,99
public void testParameterSlots() { [EOL]     testSame("/** @constructor */ function Foo() {}\n" + "/** @constructor */ function Bar() {}\n" + "function bar(a, b) {}\n" + "bar(new Foo, new Foo);\n" + "bar(new Bar, null);\n"); [EOL]     assertType("(Bar,Foo)", getParamType(getType("bar"), 0)); [EOL]     assertType("Foo", getParamType(getType("bar"), 1)); [EOL]     assertNull(getParamVar(getType("bar"), 2)); [EOL] } <line_num>: 101,111
public void testAliasedFunction() { [EOL]     testSame("/** @constructor */ function Foo() {}\n" + "/** @constructor */ function Bar() {}\n" + "function bar(a) {}\n" + "var baz = bar;\n" + "bar(new Foo);\n" + "baz(new Bar);\n"); [EOL]     assertType("(Bar,Foo)", getParamType(getType("bar"), 0)); [EOL]     assertType("(Bar,Foo)", getParamType(getType("baz"), 0)); [EOL] } <line_num>: 113,123
public void testCatchStatement() { [EOL]     testSame(BaseJSTypeTestCase.ALL_NATIVE_EXTERN_TYPES, "/** @constructor */ function Bar() {}\n" + "function bar() { try { } catch (e) { return e; } }\n" + "/** @constructor\n@extends{Error}*/ function ID10TError() {}\n" + "var a = bar(); throw new ID10TError();\n", null, null); [EOL]     assertType("(Error,EvalError,ID10TError,RangeError,ReferenceError," + "SyntaxError,TypeError,URIError)", getType("a")); [EOL] } <line_num>: 125,134
public void testConstructorParameterSlots() { [EOL]     testSame("/** @constructor */ function Foo() {}\n" + "/** @constructor */ function Bar() {}\n" + "/** @constructor */ function Baz(a) {}\n" + "new Baz(new Foo);\n" + "new Baz(new Bar);\n"); [EOL]     assertType("(Bar,Foo)", getParamType(getType("Baz"), 0)); [EOL] } <line_num>: 136,144
public void testCallSlot() { [EOL]     testSame("function foo() {}\n" + "function bar() {}\n" + "function baz() {}\n" + "var a = foo;\n" + "a = bar;\n" + "a();\n"); [EOL]     assertTrue(isCalled(getType("foo"))); [EOL]     assertTrue(isCalled(getType("bar"))); [EOL]     assertFalse(isCalled(getType("baz"))); [EOL] } <line_num>: 146,157
public void testObjectLiteralTraversal() { [EOL]     testSame("var foo = function() {}\n" + "function bar() { return { 'a': foo()} };\n" + "bar();"); [EOL]     assertTrue(isCalled(getType("foo"))); [EOL] } <line_num>: 159,164
public void testThis() { [EOL]     testSame("/** @constructor */ function Foo() {}\n" + "Foo.prototype.foo = function() { return this; }\n" + "var a = new Foo();\n" + "var b = a.foo();\n"); [EOL]     assertType("Foo", getType("a")); [EOL]     assertType("Foo", getType("b")); [EOL] } <line_num>: 166,174
public void testAssign() { [EOL]     testSame("/** @constructor */ function Foo() {}\n" + "/** @constructor */ function Bar() {}\n" + "var a = new Foo();\n" + "var b = a = new Bar();\n"); [EOL]     assertType("(Bar,Foo)", getType("a")); [EOL]     assertType("Bar", getType("b")); [EOL] } <line_num>: 176,184
public void testComma() { [EOL]     testSame("/** @constructor */ function Foo() {b=new Foo()}\n" + "var b;" + "/** @constructor */ function Bar() {}\n" + "var a = (new Foo, new Bar);\n"); [EOL]     assertType("Bar", getType("a")); [EOL]     assertType("Foo", getType("b")); [EOL] } <line_num>: 186,194
public void testAnd() { [EOL]     testSame("/** @constructor */ function Foo() {}\n" + "/** @constructor */ function Bar() {}\n" + "var a = (new Foo && new Bar);\n"); [EOL]     assertType("Bar", getType("a")); [EOL] } <line_num>: 196,202
public void testOr() { [EOL]     testSame("/** @constructor */ function Foo() {}\n" + "/** @constructor */ function Bar() {}\n" + "/** @type {Foo} */ var f = new Foo();\n" + "/** @type {Bar} */ var b = new Bar();\n" + "var a = (f || b);\n"); [EOL]     assertType("(Bar,Foo)", getType("a")); [EOL] } <line_num>: 204,212
public void testHook() { [EOL]     testSame("/** @constructor */ function Foo() {}\n" + "/** @constructor */ function Bar() {}\n" + "var a = (1+1 == 2) ? new Foo : new Bar;\n"); [EOL]     assertType("(Bar,Foo)", getType("a")); [EOL] } <line_num>: 214,220
public void testFunctionLiteral() { [EOL]     testSame("/** @constructor */ function Foo() {}\n" + "var a = (function() { return new Foo; })();\n"); [EOL]     assertType("Foo", getType("a")); [EOL] } <line_num>: 222,227
public void testNameLookup() { [EOL]     testSame("/** @constructor */ function Foo() {}\n" + "var a = new Foo;\n" + "var b = (function() { return a; })();\n"); [EOL]     assertType("Foo", getType("a")); [EOL]     assertType("Foo", getType("b")); [EOL] } <line_num>: 229,236
public void testGetProp() { [EOL]     testSame("/** @constructor */ function Foo() {\n" + "  this.foo = new A();\n" + "}\n" + "/** @constructor */ function Bar() {\n" + "  this.foo = new B();\n" + "}\n" + "/** @constructor */ function Baz() {}\n" + "/** @constructor */ function A() {}\n" + "/** @constructor */ function B() {}\n" + "/** @type {Foo} */ var foo = new Foo();\n" + "/** @type {Bar} */ var bar = new Bar();\n" + "/** @type {Baz} */ var baz = new Baz();\n" + "var a = foo || bar || baz\n" + "var b = a.foo;\n"); [EOL]     assertType("(A,B)", getType("b")); [EOL] } <line_num>: 238,256
public void testGetPrototypeProperty() { [EOL]     testSame("/** @constructor */ function Foo() {};\n" + "/** @constructor */ function Bar() {};\n" + "Bar.prototype.a = new Foo();\n" + "var a = Bar.prototype.a;\n"); [EOL]     assertType("Foo", getType("a")); [EOL] } <line_num>: 258,265
public void testGetElem() { [EOL]     testSame("/**\n" + " * @constructor\n" + " * @extends {Object}\n" + " * @param {...*} var_args\n" + " * @return {!Array}\n" + " */\n" + "function Array(var_args) {}\n", "/** @constructor */ function Foo() {}\n" + "/** @constructor */ function Bar() {}\n" + "var a = [];\n" + "a[0] = new Foo;\n" + "a[1] = new Bar;\n" + "var b = a[0];\n" + "var c = [new Foo, new Bar];\n", null); [EOL]     assertType("Array", getType("a")); [EOL]     assertType("(Array,Bar,Foo)", getType("b")); [EOL]     assertType("Array", getType("c")); [EOL]     testSame("/** @constructor */ function Foo() {}\n" + "/** @constructor */ function Bar() {}\n" + "/** @constructor */ function Baz() {\n" + "  this.arr = [];\n" + "}\n" + "var b = new Baz;\n" + "b.arr[0] = new Foo;\n" + "b.arr[1] = new Bar;\n" + "var c = b.arr;\n"); [EOL]     assertType("Array", getType("c")); [EOL] } <line_num>: 267,299
public void testGetElem3() { [EOL]     testSame(BaseJSTypeTestCase.ALL_NATIVE_EXTERN_TYPES, "/** @constructor */ function Foo() {}\n" + "/** @constructor */ function Bar() {}\n" + "/** @constructor */ function Baz() {\n" + "  this.arr = [];\n" + "}\n" + "function foo(anarr) {" + "}\n" + "var ar = [];\n" + "foo(ar);\n", null); [EOL]     assertType("Array", getType("ar")); [EOL] } <line_num>: 301,314
public void testScopeDiscovery() { [EOL]     testSame("function spam() {}\n" + "function foo() {}\n" + "function bar() {\n" + "  return function() { foo(); };\n" + "}" + "function baz() {\n" + "  return function() { bar()(); };\n" + "}" + "baz()()();\n"); [EOL]     assertFalse(isCalled(getType("spam"))); [EOL]     assertTrue(isCalled(getType("foo"))); [EOL] } <line_num>: 316,329
public void testSheqDiscovery() { [EOL]     testSame("function spam() {}\n" + "/** @constructor */\n" + "function Foo() {}\n" + "Foo.prototype.foo1 = function() { f1(); }\n" + "Foo.prototype.foo2 = function() { f2(); }\n" + "Foo.prototype.foo3 = function() { f3(); }\n" + "function baz(a) {\n" + "  a === null || a instanceof Foo ?\n" + "  Foo.prototype.foo1.call(this) :\n" + "  Foo.prototype.foo2.call(this);\n" + "}\n" + "function f1() {}\n" + "function f2() {}\n" + "function f3() {}\n" + "baz(3);\n"); [EOL]     assertFalse(isCalled(getType("spam"))); [EOL]     assertFalse(isCalled(getType("f3"))); [EOL]     assertTrue(isCalled(getType("f1"))); [EOL]     assertTrue(isCalled(getType("f2"))); [EOL] } <line_num>: 331,352
public void testSubclass() { [EOL]     testSame("/** @constructor */\n" + "function Foo() {}\n" + "Foo.prototype.foo = function() { return this.bar; };\n" + "Foo.prototype.bar = function() { return new A(); };\n" + "/**\n" + " * @constructor\n" + " * @extends Foo\n" + " */\n" + "function Bar() {}\n" + "/** @override */\n" + "Bar.prototype.bar = function() { return new B(); };\n" + "/** @constructor */ function A() {}\n" + "/** @constructor */ function B() {}\n" + "var a = (new Foo()).foo()();\n" + "a = (new Bar()).foo()();\n"); [EOL]     ConcreteType fooType = getPropertyType(getFunctionPrototype(getType("Foo")), "foo"); [EOL]     assertType("(Bar,Foo)", getThisType(fooType)); [EOL]     assertType("(A,B)", getType("a")); [EOL]     testSame("/** @constructor */\n" + "function Foo() {}\n" + "Foo.prototype.foo = function() { return this.bar; };\n" + "Foo.prototype.bar = function() { return new A(); };\n" + "/**\n" + " * @constructor\n" + " * @extends Foo\n" + " */\n" + "function Bar() {}\n" + "/** @override */\n" + "Bar.prototype.bar = function() { return new B(); };\n" + "/** @constructor */ function A() {}\n" + "/** @constructor */ function B() {}\n" + "var a = (new Bar()).foo()();\n"); [EOL]     fooType = getPropertyType(getFunctionPrototype(getType("Foo")), "foo"); [EOL]     assertType("Bar", getThisType(fooType)); [EOL]     assertType("B", getType("a")); [EOL] } <line_num>: 354,394
public void testArrayAssignments() { [EOL]     testSame("/** @constructor */ function Foo() {}\n" + "var a = [];\n" + "function foo() { return []; }\n" + "(a.length == 0 ? a : foo())[0] = new Foo;\n" + "var b = a[0];\n" + "var c = foo()[0];\n"); [EOL]     assertType("(Array,Foo)", getType("b")); [EOL]     assertType("(Array,Foo)", getType("c")); [EOL] } <line_num>: 396,406
public void testAllPropertyReference() { [EOL]     testSame("/** @constructor */ function Foo() {}\n" + "Foo.prototype.prop = function() { this.prop2(); }\n" + "Foo.prototype.prop2 = function() { b = new Foo; }\n" + "var a = new Foo;\n" + "a = [][0];\n" + "function fun(a) {\n" + "  return a.prop();\n" + "}\n" + "var b;\n" + "fun(a);\n"); [EOL]     assertType("Foo", getType("a")); [EOL]     assertType("Foo", getType("b")); [EOL] } <line_num>: 408,423
public void testCallFunction() { [EOL]     testSame("/** @constructor */ function Foo() { this.a = new A; }\n" + "/** @constructor \n @extends Foo */ function Bar() {\n" + "  Foo.call(this);\n" + "}\n" + "/** @constructor */ function A() {};\n" + "new Bar;"); [EOL]     assertTrue(isCalled(getType("Foo"))); [EOL]     assertTrue(isCalled(getType("A"))); [EOL]     ConcreteType fooType = getThisType(getType("Foo")); [EOL]     assertType("A", getPropertyType(fooType, "a")); [EOL]     ConcreteType barType = getThisType(getType("Bar")); [EOL]     assertType("A", getPropertyType(barType, "a")); [EOL] } <line_num>: 425,440
public void testCallFunctionWithArgs() { [EOL]     testSame("/** @constructor */ function Foo(o) { this.a = o; }\n" + "/** @constructor \n @extends Foo */ function Bar() {\n" + "  Foo.call(this, new A());\n" + "}\n" + "/** @constructor */ function A() {};\n" + "var b = new Bar;"); [EOL]     assertTrue(isCalled(getType("Foo"))); [EOL]     assertTrue(isCalled(getType("A"))); [EOL]     ConcreteType barType = getThisType(getType("Bar")); [EOL]     assertType("A", getPropertyType(barType, "a")); [EOL]     ConcreteType fooType = getThisType(getType("Foo")); [EOL]     assertType("A", getPropertyType(fooType, "a")); [EOL] } <line_num>: 442,458
public void testCallPrototypeFunction() { [EOL]     testSame("/** @constructor */ function Foo() {}\n" + "Foo.prototype.a = function() { return new A; }\n" + "Foo.prototype.a = function() { return new A; };\n" + "/** @constructor \n @extends Foo */ function Bar() {}\n" + "/** @override */" + "Bar.prototype.a = function() { return new B; };\n" + "/** @constructor */ function A() {};\n" + "/** @constructor */ function B() {};\n" + "var ret = Foo.prototype.a.call(new Bar);"); [EOL]     assertType("A", getType("ret")); [EOL] } <line_num>: 460,472
public void testCallPrototypeFunctionWithArgs() { [EOL]     testSame("/** @constructor */ function Foo() { this.p = null }\n" + "Foo.prototype.set = function(arg) { this.p = arg; };\n" + "Foo.prototype.get = function() { return this.p; };\n" + "/** @constructor */ function A() {};\n" + "Foo.prototype.set.call(new Foo, new A);\n" + "var ret = Foo.prototype.get.call(new Foo);"); [EOL]     ConcreteType fooP = getFunctionPrototype(getType("Foo")); [EOL]     ConcreteFunctionType gFun = getPropertyType(fooP, "get").toFunction(); [EOL]     ConcreteFunctionType sFun = getPropertyType(fooP, "set").toFunction(); [EOL]     assertTrue(isCalled(sFun)); [EOL]     assertTrue(isCalled(gFun)); [EOL]     assertTrue(isCalled(getType("A"))); [EOL]     assertType("A", getType("ret")); [EOL] } <line_num>: 474,490
public void testSetTimeout() { [EOL]     testSame("/** @constructor */ function Window() {};\n" + "Window.prototype.setTimeout = function(f, t) {};\n" + "/** @type Window */ var window;", "/** @constructor*/ function A() {}\n" + "A.prototype.handle = function() { foo(); };\n" + "function foo() {}\n" + "window.setTimeout((new A).handle, 3);", null); [EOL]     assertTrue(isCalled(getType("foo"))); [EOL] } <line_num>: 492,502
public void testExternType() { [EOL]     testSame("/** @constructor */ function T() {};\n" + "/** @constructor */ function Ext() {};\n" + "/** @return {T} */\n" + "Ext.prototype.getT = function() {};\n" + "/** @type T */ Ext.prototype.prop;\n" + "/** @type Ext */ var ext;", "var b = ext.getT();\n" + "var p = ext.prop;", null); [EOL]     assertType("Ext", getType("ext")); [EOL]     assertType("T", getType("b")); [EOL]     assertType("T", getType("p")); [EOL] } <line_num>: 504,517
public void testExternSubTypes() { [EOL]     testSame("/** @constructor */ function A() {};\n" + "/** @constructor \n@extends A */ function B() {};\n" + "/** @constructor \n@extends A */ function C() {};\n" + "/** @constructor \n@extends B */ function D() {};\n" + "/** @constructor */ function Ext() {};\n" + "/** @type A */ Ext.prototype.a;\n" + "/** @type B */ Ext.prototype.b;\n" + "/** @type D */ Ext.prototype.d;\n" + "/** @return {A} */ Ext.prototype.getA = function() {};\n" + "/** @return {B} */ Ext.prototype.getB = function() {};\n", "var a = (new Ext).a;\n" + "var a2 = (new Ext).getA();\n" + "var b = (new Ext).b;\n" + "var b2 = (new Ext).getB();\n" + "var d = (new Ext).d;\n", null); [EOL]     assertType("(A,B,C,D)", getType("a")); [EOL]     assertType("(A,B,C,D)", getType("a2")); [EOL]     assertType("(B,D)", getType("b")); [EOL]     assertType("(B,D)", getType("b2")); [EOL]     assertType("D", getType("d")); [EOL] } <line_num>: 519,541
public void testExternSubTypesForObject() { [EOL]     testSame(BaseJSTypeTestCase.ALL_NATIVE_EXTERN_TYPES + "/** @constructor */ function A() {};\n" + "/** @constructor \n@extends A */ function B() {};\n" + "/** @return {Object} */ " + "Object.prototype.eval = function(code) {};\n" + "/** @type {Object} */\n" + "A.prototype.a;\n" + "/** @return {Object} */\n" + "A.prototype.b = function(){};\n", "var a = (new A).b()", null, null); [EOL]     assertType("(A,ActiveXObject,Array,B,Boolean,Date,Error,EvalError," + "Function,Number,Object," + "RangeError,ReferenceError,RegExp,String,SyntaxError," + "TypeError,URIError)", getType("a")); [EOL] } <line_num>: 543,558
public void testImplicitPropCall() { [EOL]     testSame("/** @constructor */ function Window() {};\n" + "/** @param {function()} f \n@param {number} */\n" + "Window.prototype.setTimeout = function(f, d) {};", "function foo() {};\n" + "(new Window).setTimeout(foo, 20);", null); [EOL]     assertTrue(isCalled(getType("foo"))); [EOL] } <line_num>: 560,568
public void testImplicitPropCallWithArgs() { [EOL]     testSame("/** @constructor */ function Window() {};\n" + "/** @constructor */ function EventListener() {};\n" + "/** @param {string} t\n" + "  * @param {EventListener|function(Event)} f */\n" + "Window.prototype.addEventListener = function(t, f) {};\n" + "/** @constructor */ function Event() {};", "function foo(evt) {};\n" + "(new Window).addEventListener('click', foo);", null); [EOL]     assertTrue(isCalled(getType("foo"))); [EOL]     assertType("Event", getParamType(getType("foo"), 0)); [EOL] } <line_num>: 570,582
public void testUntypedImplicitCallFromProperty() { [EOL]     testSame("/** @constructor */ function Element() {};\n" + "/** @type {?function(Event)} */Element.prototype.onclick;\n" + "/** @constructor */ function Event() {};" + "/** @return {Event} */ Event.prototype.erv;", " function foo(evt) { return bar(evt); };\n" + "function bar(a) { return a.type() }\n" + "/** @type Object */ var ar = new Element;\n" + "ar.onclick = foo;", null); [EOL]     assertTrue(isCalled(getType("foo"))); [EOL]     assertTrue(isCalled(getType("bar"))); [EOL]     assertType("Event", getParamType(getType("foo"), 0)); [EOL]     assertType("Event", getParamType(getType("bar"), 0)); [EOL]     assertType("Element", getThisType(getType("foo").toFunction())); [EOL] } <line_num>: 584,599
public void testImplicitCallFromProperty() { [EOL]     testSame("/** @constructor */ function Element() {};\n" + "/** @type {function(this:Element,Event)} */\n" + "Element.prototype.onclick;\n" + "/** @constructor */ function Event() {};", "function foo(evt) {};\n" + "(new Element).onclick = foo;", null); [EOL]     assertTrue(isCalled(getType("foo"))); [EOL]     assertType("Event", getParamType(getType("foo"), 0)); [EOL]     assertType("Element", getThisType(getType("foo").toFunction())); [EOL] } <line_num>: 601,612
public void testImplicitCallFromPropertyOfUnion() { [EOL]     testSame("/** @constructor */ function Element() {};\n" + "/** @type {function(this:Element,Event)} */\n" + "Element.prototype.onclick;\n" + "/** @constructor */ function Event() {};", "function foo(evt) {};\n" + "(new Element).onclick = foo;", null); [EOL]     assertTrue(isCalled(getType("foo"))); [EOL]     assertType("Event", getParamType(getType("foo"), 0)); [EOL]     assertType("Element", getThisType(getType("foo").toFunction())); [EOL] } <line_num>: 614,625
public void testImplicitCallFromPropertyOfAllType() { [EOL]     testSame("/** @constructor */ function Element() {};\n" + "/** @type {function(this:Element,Event)} */\n" + "Element.prototype.onclick;\n" + "/** @constructor */ function Event() {};", "function foo(evt) {};\n" + "var elems = [];\n" + "var elem = elems[0];\n" + "elem.onclick = foo;", null); [EOL]     assertTrue(isCalled(getType("foo"))); [EOL]     assertType("Event", getParamType(getType("foo"), 0)); [EOL]     assertType("Element", getThisType(getType("foo").toFunction())); [EOL] } <line_num>: 627,640
public void testRestrictToCast() { [EOL]     testSame("/** @constructor */ function Foo() {};\n" + "var a = [];\n" + "var foo = (/** @type {Foo} */ a[0]);\n" + "var u = a[0];\n" + "new Foo"); [EOL]     assertType("Foo", getType("foo")); [EOL]     assertType("(Array,Foo)", getType("u")); [EOL] } <line_num>: 642,651
public void testRestrictToInterfaceCast() { [EOL]     testSame("/** @constructor \n @implements Int */ function Foo() {};\n" + "/** @interface */ function Int() {};\n" + "var a = [];\n" + "var foo = (/** @type {Int} */ a[0]);\n" + "new Foo"); [EOL]     assertType("Foo", getType("foo")); [EOL] } <line_num>: 653,661
public void testRestrictToCastWithNonInstantiatedTypes() { [EOL]     testSame("/** @constructor */ function Super() {}\n" + "/** @constructor \n @extends {Super} */ function Foo() {};\n" + "Foo.prototype.blah = function() { foofunc() };\n" + "/** @constructor \n @extends {Super} */ function Bar() {};\n" + "Bar.prototype.blah = function() { barfunc() };\n" + "function barfunc() {}\n" + "function foofunc() {}\n" + "var a = [];\n" + "var u = /** @type {Super} */ (a[0]);\n" + "u.blah()\n" + "new Foo"); [EOL]     assertTrue(isCalled(getType("foofunc"))); [EOL]     assertFalse(isCalled(getType("barfunc"))); [EOL]     assertType("Array", getType("a")); [EOL] } <line_num>: 663,680
public void testFunctionToString() { [EOL]     testSame("/** @constructor */ function Foo() {}\n" + "/** @constructor \n * @extends Foo */\n" + "function Bar() { Foo.call(this); }\n" + "var a = function(a) { return new Foo; };\n;" + "a(new Foo);\n" + "a(new Bar);\n" + "new Bar;"); [EOL]     assertType("function ((Bar,Foo)): Foo", getType("a")); [EOL]     assertType("function (this:(Bar,Foo)): ()", getType("Foo")); [EOL]     assertType("function (this:Bar): ()", getType("Bar")); [EOL] } <line_num>: 682,694
private void assertType(String expected, ConcreteType type) { [EOL]     assertEquals(expected, type.toString()); [EOL] } <line_num>: 696,698
private ConcreteType getType(String var) { [EOL]     assertNotNull(tt.getTopScope().getSlot(var)); [EOL]     return tt.getTopScope().getSlot(var).getType(); [EOL] } <line_num>: 701,704
private ConcreteSlot getParamVar(ConcreteType funType, int param) { [EOL]     assertTrue(funType.isFunction()); [EOL]     return (ConcreteSlot) ((ConcreteFunctionType) funType).getParameterSlot(param); [EOL] } <line_num>: 707,711
private ConcreteType getParamType(ConcreteType funType, int param) { [EOL]     ConcreteSlot paramVar = getParamVar(funType, param); [EOL]     return (paramVar != null) ? paramVar.getType() : ConcreteType.NONE; [EOL] } <line_num>: 714,717
private ConcreteSlot getThisSlot(ConcreteType funType) { [EOL]     assertTrue(funType.isFunction()); [EOL]     return (ConcreteSlot) ((ConcreteFunctionType) funType).getThisSlot(); [EOL] } <line_num>: 720,723
private ConcreteType getThisType(ConcreteType funType) { [EOL]     return getThisSlot(funType).getType(); [EOL] } <line_num>: 726,728
private ConcreteType getFunctionPrototype(ConcreteType funType) { [EOL]     assertTrue(funType.isFunction()); [EOL]     return ((ConcreteFunctionType) funType).getPrototypeType(); [EOL] } <line_num>: 731,734
private ConcreteSlot getPropertyVar(ConcreteType instType, String name) { [EOL]     assertTrue(instType.isInstance()); [EOL]     return (ConcreteSlot) ((ConcreteInstanceType) instType).getPropertySlot(name); [EOL] } <line_num>: 740,744
private ConcreteType getPropertyType(ConcreteType instType, String name) { [EOL]     return getPropertyVar(instType, name).getType(); [EOL] } <line_num>: 747,749
private boolean isCalled(ConcreteType funType) { [EOL]     assertTrue(funType.isFunction()); [EOL]     ConcreteSlot callVar = (ConcreteSlot) ((ConcreteFunctionType) funType).getCallSlot(); [EOL]     return !callVar.getType().isNone(); [EOL] } <line_num>: 752,757
