public PruningCallback(Set<Integer> nodeTypes, boolean include) { [EOL]     super(nodeTypes, include); [EOL] } <line_num>: 61,63
public void testPruningCallbackShouldTraverse1() { [EOL]     PruningCallback include = new PruningCallback(ImmutableSet.of(Token.SCRIPT, Token.VAR), true); [EOL]     Node script = new Node(Token.SCRIPT); [EOL]     assertTrue(include.shouldTraverse(null, script, null)); [EOL]     assertTrue(include.shouldTraverse(null, new Node(Token.VAR), null)); [EOL]     assertFalse(include.shouldTraverse(null, new Node(Token.NAME), null)); [EOL]     assertFalse(include.shouldTraverse(null, new Node(Token.ADD), null)); [EOL] } <line_num>: 34,43
public void testPruningCallbackShouldTraverse2() { [EOL]     PruningCallback include = new PruningCallback(ImmutableSet.of(Token.SCRIPT, Token.VAR), false); [EOL]     Node script = new Node(Token.SCRIPT); [EOL]     assertFalse(include.shouldTraverse(null, script, null)); [EOL]     assertFalse(include.shouldTraverse(null, new Node(Token.VAR), null)); [EOL]     assertTrue(include.shouldTraverse(null, new Node(Token.NAME), null)); [EOL]     assertTrue(include.shouldTraverse(null, new Node(Token.ADD), null)); [EOL] } <line_num>: 45,54
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     throw new UnsupportedOperationException(); [EOL] } <line_num>: 65,68
@Override [EOL] public void report(CheckLevel level, JSError error) { [EOL]     errors.add(error); [EOL] } <line_num>: 76,78
@Override [EOL] public void println(CheckLevel level, JSError error) { [EOL] } <line_num>: 80,81
@Override [EOL] protected void printSummary() { [EOL] } <line_num>: 83,84
public void testReport() { [EOL]     final List<JSError> errors = new ArrayList<JSError>(); [EOL]     Compiler compiler = new Compiler(new BasicErrorManager() { [EOL]  [EOL]         @Override [EOL]         public void report(CheckLevel level, JSError error) { [EOL]             errors.add(error); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void println(CheckLevel level, JSError error) { [EOL]         } [EOL]  [EOL]         @Override [EOL]         protected void printSummary() { [EOL]         } [EOL]     }); [EOL]     compiler.initCompilerOptionsIfTesting(); [EOL]     NodeTraversal t = new NodeTraversal(compiler, null); [EOL]     DiagnosticType dt = DiagnosticType.warning("FOO", "{0}, {1} - {2}"); [EOL]     t.report(null, dt, "Foo", "Bar", "Hello"); [EOL]     assertEquals(1, errors.size()); [EOL]     assertEquals("Foo, Bar - Hello", errors.get(0).description); [EOL] } <line_num>: 71,94
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     throw new RuntimeException(TEST_EXCEPTION); [EOL] } <line_num>: 100,103
public void testUnexpectedException() { [EOL]     final String TEST_EXCEPTION = "test me"; [EOL]     NodeTraversal.Callback cb = new NodeTraversal.AbstractPostOrderCallback() { [EOL]  [EOL]         @Override [EOL]         public void visit(NodeTraversal t, Node n, Node parent) { [EOL]             throw new RuntimeException(TEST_EXCEPTION); [EOL]         } [EOL]     }; [EOL]     Compiler compiler = new Compiler(); [EOL]     NodeTraversal t = new NodeTraversal(compiler, cb); [EOL]     String code = "function foo() {}"; [EOL]     Node tree = parse(compiler, code); [EOL]     try { [EOL]         t.traverse(tree); [EOL]         fail("Expected RuntimeException"); [EOL]     } catch (RuntimeException e) { [EOL]         assertTrue(e.getMessage().startsWith("INTERNAL COMPILER ERROR.\n" + "Please report this problem.\n" + "test me")); [EOL]     } [EOL] } <line_num>: 96,120
@Override [EOL] public void enterScope(NodeTraversal t) { [EOL]     Node root1 = t.getScopeRoot(); [EOL]     Node root2 = t.getScope().getRootNode(); [EOL]     assertEquals(root1, root2); [EOL] } <line_num>: 128,133
@Override [EOL] public void exitScope(NodeTraversal t) { [EOL] } <line_num>: 135,137
@Override [EOL] public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { [EOL]     return true; [EOL] } <line_num>: 139,142
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL] } <line_num>: 144,146
public void testGetScopeRoot() { [EOL]     Compiler compiler = new Compiler(); [EOL]     NodeTraversal t = new NodeTraversal(compiler, new NodeTraversal.ScopedCallback() { [EOL]  [EOL]         @Override [EOL]         public void enterScope(NodeTraversal t) { [EOL]             Node root1 = t.getScopeRoot(); [EOL]             Node root2 = t.getScope().getRootNode(); [EOL]             assertEquals(root1, root2); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void exitScope(NodeTraversal t) { [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { [EOL]             return true; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void visit(NodeTraversal t, Node n, Node parent) { [EOL]         } [EOL]     }); [EOL]     String code = "" + "var a; " + "function foo() {" + "  var b" + "}"; [EOL]     Node tree = parse(compiler, code); [EOL]     t.traverse(tree); [EOL] } <line_num>: 123,157
public void testGetCurrentNode() { [EOL]     Compiler compiler = new Compiler(); [EOL]     ScopeCreator creator = new SyntacticScopeCreator(compiler); [EOL]     ExpectNodeOnEnterScope callback = new ExpectNodeOnEnterScope(); [EOL]     NodeTraversal t = new NodeTraversal(compiler, callback, creator); [EOL]     String code = "" + "var a; " + "function foo() {" + "  var b;" + "}"; [EOL]     Node tree = parse(compiler, code); [EOL]     Scope topScope = creator.createScope(tree, null); [EOL]     callback.expect(tree.getFirstChild(), tree); [EOL]     t.traverseWithScope(tree.getFirstChild(), topScope); [EOL]     callback.assertEntered(); [EOL]     callback.expect(tree.getFirstChild(), tree.getFirstChild()); [EOL]     t.traverse(tree.getFirstChild()); [EOL]     callback.assertEntered(); [EOL]     Node fn = tree.getFirstChild().getNext(); [EOL]     Scope fnScope = creator.createScope(fn, topScope); [EOL]     callback.expect(fn, fn); [EOL]     t.traverseAtScope(fnScope); [EOL]     callback.assertEntered(); [EOL] } <line_num>: 159,191
private void expect(Node node, Node scopeRoot) { [EOL]     this.node = node; [EOL]     this.scopeRoot = scopeRoot; [EOL]     entered = false; [EOL] } <line_num>: 201,205
private void assertEntered() { [EOL]     assertTrue(entered); [EOL] } <line_num>: 207,209
@Override [EOL] public void enterScope(NodeTraversal t) { [EOL]     assertEquals(node, t.getCurrentNode()); [EOL]     assertEquals(scopeRoot, t.getScopeRoot()); [EOL]     entered = true; [EOL] } <line_num>: 211,216
@Override [EOL] public void exitScope(NodeTraversal t) { [EOL] } <line_num>: 218,220
@Override [EOL] public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { [EOL]     return true; [EOL] } <line_num>: 222,225
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL] } <line_num>: 227,229
private static Node parse(Compiler compiler, String js) { [EOL]     Node n = compiler.parseTestCode(js); [EOL]     assertEquals(0, compiler.getErrorCount()); [EOL]     return n; [EOL] } <line_num>: 232,236
