TestHelper(ConcatTraversal traversal, String expectedVisited, String shouldTraverseExpected) { [EOL]     this.traversal = traversal; [EOL]     this.expectedVisited = expectedVisited; [EOL]     this.shouldTraverseExpected = shouldTraverseExpected; [EOL] } <line_num>: 141,146
private static Node createPostOrderAlphabet() { [EOL]     Node a = Node.newString("a"); [EOL]     Node b = Node.newString("b"); [EOL]     Node c = Node.newString("c"); [EOL]     Node d = Node.newString("d"); [EOL]     Node e = Node.newString("e"); [EOL]     Node f = Node.newString("f"); [EOL]     Node g = Node.newString("g"); [EOL]     Node h = Node.newString("h"); [EOL]     Node i = Node.newString("i"); [EOL]     Node j = Node.newString("j"); [EOL]     Node k = Node.newString("k"); [EOL]     Node l = Node.newString("l"); [EOL]     Node m = Node.newString("m"); [EOL]     d.addChildToBack(a); [EOL]     d.addChildToBack(b); [EOL]     d.addChildToBack(c); [EOL]     h.addChildrenToBack(e); [EOL]     h.addChildrenToBack(f); [EOL]     h.addChildrenToBack(g); [EOL]     l.addChildToBack(i); [EOL]     l.addChildToBack(j); [EOL]     l.addChildToBack(k); [EOL]     m.addChildToBack(d); [EOL]     m.addChildToBack(h); [EOL]     m.addChildToBack(l); [EOL]     return m; [EOL] } <line_num>: 49,81
@Override [EOL] public void setUp() throws Exception { [EOL]     super.setUp(); [EOL]     compiler = new Compiler(); [EOL] } <line_num>: 83,87
ConcatTraversal ignore(String s) { [EOL]     ignoring.add(s); [EOL]     return this; [EOL] } <line_num>: 99,102
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     assertEquals(Token.STRING, n.getType()); [EOL]     visited.append(n.getString()); [EOL] } <line_num>: 104,108
@Override [EOL] public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { [EOL]     assertEquals(Token.STRING, n.getType()); [EOL]     shouldTraversed.append(n.getString()); [EOL]     return !ignoring.contains(n.getString()); [EOL] } <line_num>: 110,115
String getVisited() { [EOL]     return visited.toString(); [EOL] } <line_num>: 118,120
String getShouldTraversed() { [EOL]     return shouldTraversed.toString(); [EOL] } <line_num>: 123,125
Collection<String> getIgnoring() { [EOL]     return ignoring; [EOL] } <line_num>: 127,129
ConcatTraversal getTraversal() { [EOL]     return traversal; [EOL] } <line_num>: 148,150
void checkResults() { [EOL]     assertEquals("ConcatTraversal ignoring " + traversal.getIgnoring().toString() + " has unexpected visiting order", expectedVisited, traversal.getVisited()); [EOL]     assertEquals("ConcatTraversal ignoring " + traversal.getIgnoring().toString() + " has unexpected traversal order", shouldTraverseExpected, traversal.getShouldTraversed()); [EOL] } <line_num>: 152,162
private static List<TestHelper> createStringTests() { [EOL]     List<TestHelper> tests = Lists.newArrayList(); [EOL]     tests.add(new TestHelper(new ConcatTraversal(), "abcdefghijklm", "mdabchefglijk")); [EOL]     tests.add(new TestHelper(new ConcatTraversal().ignore("d"), "efghijklm", "mdhefglijk")); [EOL]     tests.add(new TestHelper(new ConcatTraversal().ignore("f"), "abcdeghijklm", "mdabchefglijk")); [EOL]     tests.add(new TestHelper(new ConcatTraversal().ignore("m"), "", "m")); [EOL]     return tests; [EOL] } <line_num>: 165,180
public void testIndividualPasses() { [EOL]     for (TestHelper test : createStringTests()) { [EOL]         CombinedCompilerPass pass = new CombinedCompilerPass(compiler, test.getTraversal()); [EOL]         pass.process(null, createPostOrderAlphabet()); [EOL]         test.checkResults(); [EOL]     } [EOL] } <line_num>: 182,189
public void testCombinedPasses() { [EOL]     List<TestHelper> tests = createStringTests(); [EOL]     Callback[] callbacks = new Callback[tests.size()]; [EOL]     int i = 0; [EOL]     for (TestHelper test : tests) { [EOL]         callbacks[i++] = test.getTraversal(); [EOL]     } [EOL]     CombinedCompilerPass pass = new CombinedCompilerPass(compiler, callbacks); [EOL]     pass.process(null, createPostOrderAlphabet()); [EOL]     for (TestHelper test : tests) { [EOL]         test.checkResults(); [EOL]     } [EOL] } <line_num>: 191,204
void ignore(String name) { [EOL]     ignoring.add(name); [EOL] } <line_num>: 215,217
@Override [EOL] public void enterScope(NodeTraversal t) { [EOL]     visitedScopes.add(t.getScopeRoot()); [EOL] } <line_num>: 219,222
@Override [EOL] public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { [EOL]     return !n.isName() || !ignoring.contains(n.getString()); [EOL] } <line_num>: 224,227
Set<Node> getVisitedScopes() { [EOL]     return visitedScopes; [EOL] } <line_num>: 229,231
@Override [EOL] public void exitScope(NodeTraversal t) { [EOL] } <line_num>: 233,235
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL] } <line_num>: 237,239
public void testScopes() { [EOL]     Node root = compiler.parseTestCode("var y = function() { var x = function() { };}"); [EOL]     ScopeRecordingCallback c1 = new ScopeRecordingCallback(); [EOL]     c1.ignore("y"); [EOL]     ScopeRecordingCallback c2 = new ScopeRecordingCallback(); [EOL]     c2.ignore("x"); [EOL]     ScopeRecordingCallback c3 = new ScopeRecordingCallback(); [EOL]     CombinedCompilerPass pass = new CombinedCompilerPass(compiler, c1, c2, c3); [EOL]     pass.process(null, root); [EOL]     assertEquals(1, c1.getVisitedScopes().size()); [EOL]     assertEquals(2, c2.getVisitedScopes().size()); [EOL]     assertEquals(3, c3.getVisitedScopes().size()); [EOL] } <line_num>: 243,259
