@Override [EOL] public void setUp() { [EOL]     externs = DEFAULT_EXTERNS; [EOL]     lastCompiler = null; [EOL]     normalizeResults = false; [EOL] } <line_num>: 58,63
protected void testSame(CompilerOptions options, String original) { [EOL]     testSame(options, new String[] { original }); [EOL] } <line_num>: 65,67
protected void testSame(CompilerOptions options, String[] original) { [EOL]     test(options, original, original); [EOL] } <line_num>: 69,71
protected void test(CompilerOptions options, String original, String compiled) { [EOL]     test(options, new String[] { original }, new String[] { compiled }); [EOL] } <line_num>: 77,80
protected void test(CompilerOptions options, String[] original, String[] compiled) { [EOL]     Compiler compiler = compile(options, original); [EOL]     assertEquals("Expected no warnings or errors\n" + "Errors: \n" + Joiner.on("\n").join(compiler.getErrors()) + "Warnings: \n" + Joiner.on("\n").join(compiler.getWarnings()), 0, compiler.getErrors().length + compiler.getWarnings().length); [EOL]     Node root = compiler.getRoot().getLastChild(); [EOL]     Node expectedRoot = parse(compiled, options, normalizeResults); [EOL]     String explanation = expectedRoot.checkTreeEquals(root); [EOL]     assertNull("\nExpected: " + compiler.toSource(expectedRoot) + "\nResult: " + compiler.toSource(root) + "\n" + explanation, explanation); [EOL] } <line_num>: 86,100
protected void test(CompilerOptions options, String original, DiagnosticType warning) { [EOL]     test(options, new String[] { original }, warning); [EOL] } <line_num>: 106,109
protected void test(CompilerOptions options, String original, String compiled, DiagnosticType warning) { [EOL]     test(options, new String[] { original }, new String[] { compiled }, warning); [EOL] } <line_num>: 111,115
protected void test(CompilerOptions options, String[] original, DiagnosticType warning) { [EOL]     test(options, original, null, warning); [EOL] } <line_num>: 117,120
protected void test(CompilerOptions options, String[] original, String[] compiled, DiagnosticType warning) { [EOL]     Compiler compiler = compile(options, original); [EOL]     checkUnexpectedErrorsOrWarnings(compiler, 1); [EOL]     assertEquals("Expected exactly one warning or error", 1, compiler.getErrors().length + compiler.getWarnings().length); [EOL]     if (compiler.getErrors().length > 0) { [EOL]         assertEquals(warning, compiler.getErrors()[0].getType()); [EOL]     } else { [EOL]         assertEquals(warning, compiler.getWarnings()[0].getType()); [EOL]     } [EOL]     if (compiled != null) { [EOL]         Node root = compiler.getRoot().getLastChild(); [EOL]         Node expectedRoot = parse(compiled, options, normalizeResults); [EOL]         String explanation = expectedRoot.checkTreeEquals(root); [EOL]         assertNull("\nExpected: " + compiler.toSource(expectedRoot) + "\nResult: " + compiler.toSource(root) + "\n" + explanation, explanation); [EOL]     } [EOL] } <line_num>: 126,146
protected void test(CompilerOptions options, String[] original, String[] compiled, DiagnosticType[] warnings) { [EOL]     Compiler compiler = compile(options, original); [EOL]     checkUnexpectedErrorsOrWarnings(compiler, warnings.length); [EOL]     if (compiled != null) { [EOL]         Node root = compiler.getRoot().getLastChild(); [EOL]         Node expectedRoot = parse(compiled, options, normalizeResults); [EOL]         String explanation = expectedRoot.checkTreeEquals(root); [EOL]         assertNull("\nExpected: " + compiler.toSource(expectedRoot) + "\nResult: " + compiler.toSource(root) + "\n" + explanation, explanation); [EOL]     } [EOL] } <line_num>: 152,165
protected void checkUnexpectedErrorsOrWarnings(Compiler compiler, int expected) { [EOL]     int actual = compiler.getErrors().length + compiler.getWarnings().length; [EOL]     if (actual != expected) { [EOL]         String msg = ""; [EOL]         for (JSError err : compiler.getErrors()) { [EOL]             msg += "Error:" + err.toString() + "\n"; [EOL]         } [EOL]         for (JSError err : compiler.getWarnings()) { [EOL]             msg += "Warning:" + err.toString() + "\n"; [EOL]         } [EOL]         assertEquals("Unexpected warnings or errors.\n " + msg, expected, actual); [EOL]     } [EOL] } <line_num>: 167,181
protected Compiler compile(CompilerOptions options, String original) { [EOL]     return compile(options, new String[] { original }); [EOL] } <line_num>: 183,185
protected Compiler compile(CompilerOptions options, String[] original) { [EOL]     Compiler compiler = lastCompiler = new Compiler(); [EOL]     List<SourceFile> inputs = Lists.newArrayList(); [EOL]     for (int i = 0; i < original.length; i++) { [EOL]         inputs.add(SourceFile.fromCode("input" + i, original[i])); [EOL]     } [EOL]     compiler.compileModules(externs, Lists.newArrayList(CompilerTestCase.createModuleChain(original)), options); [EOL]     return compiler; [EOL] } <line_num>: 187,197
protected Node parse(String[] original, CompilerOptions options, boolean normalize) { [EOL]     Compiler compiler = new Compiler(); [EOL]     List<SourceFile> inputs = Lists.newArrayList(); [EOL]     for (int i = 0; i < original.length; i++) { [EOL]         inputs.add(SourceFile.fromCode("input" + i, original[i])); [EOL]     } [EOL]     compiler.init(externs, inputs, options); [EOL]     checkUnexpectedErrorsOrWarnings(compiler, 0); [EOL]     Node all = compiler.parseInputs(); [EOL]     checkUnexpectedErrorsOrWarnings(compiler, 0); [EOL]     Node n = all.getLastChild(); [EOL]     Node externs = all.getFirstChild(); [EOL]     (new CreateSyntheticBlocks(compiler, "synStart", "synEnd")).process(externs, n); [EOL]     if (normalize) { [EOL]         compiler.normalize(); [EOL]     } [EOL]     return n; [EOL] } <line_num>: 199,221
abstract CompilerOptions createCompilerOptions(); <line_num>: 224,224
