public final void testAgainstRegularImplementation() { [EOL]     Random rnd = new Random(SEED); [EOL]     for (int run = 10; --run >= 0; ) { [EOL]         BitSet bs = new BitSet(); [EOL]         for (int i = 0x1000; --i >= 0; ) { [EOL]             bs.set(0x1000 + rnd.nextInt(0x3000)); [EOL]         } [EOL]         int[] members = new int[bs.cardinality()]; [EOL]         for (int i = -1, k = 0; k < members.length; ++k) { [EOL]             members[k] = i = bs.nextSetBit(i + 1); [EOL]         } [EOL]         CharRanges sbs = CharRanges.withMembers(members); [EOL]         for (int i = 0; i < 0x5000; ++i) { [EOL]             if (bs.get(i) != sbs.contains(i)) { [EOL]                 fail("sbs=" + sbs + ", bs=" + bs + ", difference at bit " + i); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 31,55
public final void testEmptyCharRanges() { [EOL]     CharRanges sbs = CharRanges.EMPTY; [EOL]     for (int i = -1000; i < 1000; ++i) { [EOL]         assertFalse(sbs.contains(i)); [EOL]     } [EOL]     assertEquals("[]", sbs.toString()); [EOL] } <line_num>: 57,63
public final void testCharRangesFactories() { [EOL]     CharRanges isbs = CharRanges.withMembers(new int[] { 0, 1, 4, 9 }); [EOL]     CharRanges isbs2 = CharRanges.withMembers(new int[] { 0, 1, 4, 9 }); [EOL]     assertEquals("[0x0-0x1 0x4 0x9]", isbs.toString()); [EOL]     CharRanges esbs = CharRanges.withMembers(new int[0]); [EOL]     assertEquals(isbs, isbs); [EOL]     assertEquals(isbs, isbs2); [EOL]     assertFalse(isbs.equals(esbs)); [EOL]     assertFalse(isbs.equals(null)); [EOL]     assertFalse(isbs.equals(new Object())); [EOL]     assertEquals(isbs.hashCode(), isbs2.hashCode()); [EOL]     assertFalse(isbs.hashCode() == esbs.hashCode()); [EOL] } <line_num>: 65,80
public final void testRangeConstructor() { [EOL]     try { [EOL]         CharRanges.withRanges(new int[] { 1 }); [EOL]         fail("Mismatched ranges"); [EOL]     } catch (IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         CharRanges.withRanges(new int[] { 1, 4, 4, 5 }); [EOL]         fail("Discontiguous ranges"); [EOL]     } catch (IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         CharRanges.withRanges(new int[] { 4, 5, 1, 3 }); [EOL]         fail("Misordered ranges"); [EOL]     } catch (IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         CharRanges.withRanges(new int[] { 0, 0 }); [EOL]         fail("Empty range"); [EOL]     } catch (IllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 82,110
public final void testDupeMembers() { [EOL]     CharRanges sbs1 = CharRanges.withMembers(new int[] { 0, 1, 4, 9 }); [EOL]     assertEquals(sbs1.toString(), "[0x0-0x1 0x4 0x9]", sbs1.toString()); [EOL]     CharRanges sbs2 = CharRanges.withMembers(new int[] { 9, 1, 4, 1, 0 }); [EOL]     assertEquals(sbs2.toString(), "[0x0-0x1 0x4 0x9]", sbs2.toString()); [EOL]     assertEquals(sbs1, sbs2); [EOL]     assertEquals(sbs1.hashCode(), sbs2.hashCode()); [EOL]     for (int i = -10; i < 20; ++i) { [EOL]         assertEquals("" + i, sbs1.contains(i), sbs2.contains(i)); [EOL]     } [EOL] } <line_num>: 112,125
public final void testDifference() { [EOL]     CharRanges a = CharRanges.withRanges(new int[] { 0x03, 0x0C, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1C, 0x1D, 0x1E, 0x21, 0x24, 0x27, 0x28, 0x29, 0x2A, 0x2B }); [EOL]     CharRanges b = CharRanges.withRanges(new int[] { 0x01, 0x04, 0x06, 0x09, 0x0B, 0x0E, 0x0F, 0x12, 0x1A, 0x1B, 0x1C, 0x1D, 0x21, 0x24 }); [EOL]     CharRanges empty = CharRanges.withMembers(new int[0]); [EOL]     assertEquals(empty, empty.union(empty)); [EOL]     assertEquals(a, a.union(empty)); [EOL]     assertEquals(b, empty.union(b)); [EOL]     CharRanges aSb = a.difference(b); [EOL]     assertEquals("[0x4-0x5 0x9-0xa 0x12 0x14 0x16 0x18 0x1e-0x20 0x24-0x26 0x28 0x2a]", aSb.toString()); [EOL]     assertTrue(a.containsAll(aSb)); [EOL]     assertFalse(aSb.containsAll(a)); [EOL]     assertFalse(aSb.containsAll(b)); [EOL]     CharRanges bSa = b.difference(a); [EOL]     assertEquals("[0x1-0x2 0xc-0xd 0xf-0x11 0x1a 0x21-0x23]", bSa.toString()); [EOL]     assertTrue(b.containsAll(bSa)); [EOL]     assertFalse(bSa.containsAll(a)); [EOL]     assertFalse(bSa.containsAll(b)); [EOL]     assertEquals("[0x3-0xb 0x12 0x14 0x16 0x18 0x1c 0x1e-0x20 0x24-0x26 0x28 0x2a]", a.toString()); [EOL]     assertEquals("[0x1-0x3 0x6-0x8 0xb-0xd 0xf-0x11 0x1a 0x1c 0x21-0x23]", b.toString()); [EOL]     CharRanges m = CharRanges.withMembers(0, 1, 2, 3, 6, 9, 0xa, 0xe, 0xf); [EOL]     CharRanges s = CharRanges.withMembers(2, 5, 6, 7, 0xa, 0xb, 0xd, 0xe); [EOL]     CharRanges d = m.difference(s); [EOL]     assertEquals("[0x0-0x1 0x3 0x9 0xf]", d.toString()); [EOL]     assertTrue(m.containsAll(d)); [EOL]     assertFalse(d.containsAll(m)); [EOL]     assertFalse(d.containsAll(s)); [EOL]     assertFalse(s.containsAll(d)); [EOL]     assertTrue(d.containsAll(d)); [EOL] } <line_num>: 127,183
public final void testUnion() { [EOL]     CharRanges a = CharRanges.withRanges(new int[] { 0x03, 0x0C, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1C, 0x1D, 0x1E, 0x21, 0x24, 0x27, 0x28, 0x29, 0x2A, 0x2B }); [EOL]     CharRanges b = CharRanges.withRanges(new int[] { 0x01, 0x04, 0x06, 0x09, 0x0B, 0x0E, 0x0F, 0x12, 0x1A, 0x1B, 0x1C, 0x1D, 0x21, 0x24 }); [EOL]     CharRanges empty = CharRanges.withMembers(new int[0]); [EOL]     assertEquals(empty, empty.union(empty)); [EOL]     assertEquals(a, a.union(empty)); [EOL]     assertEquals(b, empty.union(b)); [EOL]     CharRanges aUb = a.union(b); [EOL]     assertEquals("[0x1-0xd 0xf-0x12 0x14 0x16 0x18 0x1a 0x1c 0x1e-0x26 0x28 0x2a]", aUb.toString()); [EOL]     assertEquals(aUb, b.union(a)); [EOL]     assertTrue(aUb.containsAll(a)); [EOL]     assertTrue(aUb.containsAll(b)); [EOL]     assertFalse(a.containsAll(b)); [EOL]     assertFalse(b.containsAll(a)); [EOL]     assertTrue(a.containsAll(a)); [EOL]     assertTrue(b.containsAll(b)); [EOL]     assertTrue(aUb.containsAll(aUb)); [EOL]     assertEquals("[0x3-0xb 0x12 0x14 0x16 0x18 0x1c 0x1e-0x20 0x24-0x26 0x28 0x2a]", a.toString()); [EOL]     assertEquals("[0x1-0x3 0x6-0x8 0xb-0xd 0xf-0x11 0x1a 0x1c 0x21-0x23]", b.toString()); [EOL] } <line_num>: 185,223
