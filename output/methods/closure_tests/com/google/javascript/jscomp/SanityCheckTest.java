public SanityCheckTest() { [EOL]     super("", false); [EOL] } <line_num>: 30,32
@Override [EOL] public void setUp() { [EOL]     otherPass = null; [EOL] } <line_num>: 34,36
@Override [EOL] protected int getNumRepetitions() { [EOL]     return 1; [EOL] } <line_num>: 38,40
@Override [EOL] public void process(Node externs, Node root) { [EOL]     otherPass.process(externs, root); [EOL]     (new SanityCheck(compiler)).process(externs, root); [EOL] } <line_num>: 44,47
@Override [EOL] public CompilerPass getProcessor(final Compiler compiler) { [EOL]     return new CompilerPass() { [EOL]  [EOL]         @Override [EOL]         public void process(Node externs, Node root) { [EOL]             otherPass.process(externs, root); [EOL]             (new SanityCheck(compiler)).process(externs, root); [EOL]         } [EOL]     }; [EOL] } <line_num>: 42,49
@Override [EOL] public void process(Node externs, Node root) { [EOL]     getLastCompiler().reportCodeChange(); [EOL]     root.getFirstChild().addChildToBack(new Node(Token.IF, new Node(Token.TRUE), new Node(Token.EMPTY))); [EOL] } <line_num>: 53,57
public void testUnnormalizeNodeTypes() throws Exception { [EOL]     otherPass = new CompilerPass() { [EOL]  [EOL]         @Override [EOL]         public void process(Node externs, Node root) { [EOL]             getLastCompiler().reportCodeChange(); [EOL]             root.getFirstChild().addChildToBack(new Node(Token.IF, new Node(Token.TRUE), new Node(Token.EMPTY))); [EOL]         } [EOL]     }; [EOL]     boolean exceptionCaught = false; [EOL]     try { [EOL]         test("var x = 3;", "var x=3;0;0"); [EOL]     } catch (IllegalStateException e) { [EOL]         assertEquals("Expected BLOCK but was EMPTY Reference node EMPTY", e.getMessage()); [EOL]         exceptionCaught = true; [EOL]     } [EOL]     assertTrue(exceptionCaught); [EOL] } <line_num>: 51,69
@Override [EOL] public void process(Node externs, Node root) { [EOL]     getLastCompiler().setLifeCycleStage(LifeCycleStage.NORMALIZED); [EOL] } <line_num>: 73,75
public void testUnnormalized() throws Exception { [EOL]     otherPass = new CompilerPass() { [EOL]  [EOL]         @Override [EOL]         public void process(Node externs, Node root) { [EOL]             getLastCompiler().setLifeCycleStage(LifeCycleStage.NORMALIZED); [EOL]         } [EOL]     }; [EOL]     boolean exceptionCaught = false; [EOL]     try { [EOL]         test("while(1){}", "while(1){}"); [EOL]     } catch (RuntimeException e) { [EOL]         assertTrue(e.getMessage().contains("Normalize constraints violated:\nWHILE node")); [EOL]         exceptionCaught = true; [EOL]     } [EOL]     assertTrue(exceptionCaught); [EOL] } <line_num>: 71,87
@Override [EOL] public void process(Node externs, Node root) { [EOL]     getLastCompiler().reportCodeChange(); [EOL]     Node name = Node.newString(Token.NAME, "x"); [EOL]     name.putBooleanProp(Node.IS_CONSTANT_NAME, true); [EOL]     root.getFirstChild().addChildToBack(new Node(Token.EXPR_RESULT, name)); [EOL]     getLastCompiler().setLifeCycleStage(LifeCycleStage.NORMALIZED); [EOL] } <line_num>: 91,97
public void testConstantAnnotationMismatch() throws Exception { [EOL]     otherPass = new CompilerPass() { [EOL]  [EOL]         @Override [EOL]         public void process(Node externs, Node root) { [EOL]             getLastCompiler().reportCodeChange(); [EOL]             Node name = Node.newString(Token.NAME, "x"); [EOL]             name.putBooleanProp(Node.IS_CONSTANT_NAME, true); [EOL]             root.getFirstChild().addChildToBack(new Node(Token.EXPR_RESULT, name)); [EOL]             getLastCompiler().setLifeCycleStage(LifeCycleStage.NORMALIZED); [EOL]         } [EOL]     }; [EOL]     boolean exceptionCaught = false; [EOL]     try { [EOL]         test("var x;", "var x; x;"); [EOL]     } catch (RuntimeException e) { [EOL]         assertTrue(e.getMessage().contains("The name x is not consistently annotated as constant.")); [EOL]         exceptionCaught = true; [EOL]     } [EOL]     assertTrue(exceptionCaught); [EOL] } <line_num>: 89,109
