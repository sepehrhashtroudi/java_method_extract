FakeScope(FakeScope parent) { [EOL]     this.parent = parent; [EOL] } <line_num>: 328,330
FakeSlot(String name) { [EOL]     this.name = name; [EOL] } <line_num>: 367,369
@Override [EOL] public void setUp() { [EOL]     typeRegistry = new JSTypeRegistry(new TestErrorReporter(null, null)); [EOL]     unknownType = typeRegistry.getNativeType(JSTypeNative.UNKNOWN_TYPE); [EOL]     factory = new FakeFactory(); [EOL] } <line_num>: 59,64
private void checkEquality(List<ConcreteType> types) { [EOL]     for (int i = 0; i < types.size(); ++i) { [EOL]         for (int j = 0; j < types.size(); ++j) { [EOL]             if (i == j) { [EOL]                 assertEquals(types.get(i), types.get(j)); [EOL]             } else { [EOL]                 assertFalse(types.get(i).equals(types.get(j))); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 66,76
public void testEquals() { [EOL]     ConcreteFunctionType fun1 = createFunction("fun1"); [EOL]     ConcreteFunctionType fun2 = createFunction("fun2"); [EOL]     ConcreteType obj1 = fun1.getInstanceType(); [EOL]     ConcreteType obj2 = fun2.getInstanceType(); [EOL]     ConcreteType union1 = new ConcreteUnionType(fun1, fun2); [EOL]     ConcreteType union2 = new ConcreteUnionType(fun1, obj1); [EOL]     ConcreteType union3 = new ConcreteUnionType(fun1, obj1); [EOL]     checkEquality(Lists.newArrayList(fun1, fun2, obj1, obj2, union1, union2)); [EOL]     assertEquals(union2, union3); [EOL] } <line_num>: 78,91
public void testUnionWith() { [EOL]     ConcreteFunctionType fun = createFunction("fun"); [EOL]     ConcreteType obj = fun.getInstanceType(); [EOL]     ConcreteType both = new ConcreteUnionType(fun, obj); [EOL]     assertTrue(fun.isSingleton()); [EOL]     assertTrue(obj.isSingleton()); [EOL]     assertFalse(both.isSingleton()); [EOL]     assertFalse(NONE.isSingleton()); [EOL]     assertFalse(ALL.isSingleton()); [EOL]     checkUnionWith(fun, NONE, fun); [EOL]     checkUnionWith(fun, ALL, ALL); [EOL]     checkUnionWith(fun, obj, both); [EOL]     checkUnionWith(both, NONE, both); [EOL]     checkUnionWith(both, ALL, ALL); [EOL] } <line_num>: 93,110
private void checkUnionWith(ConcreteType a, ConcreteType b, ConcreteType c) { [EOL]     assertEquals(a, a.unionWith(a)); [EOL]     assertEquals(b, b.unionWith(b)); [EOL]     assertEquals(c, a.unionWith(b)); [EOL]     assertEquals(c, b.unionWith(a)); [EOL] } <line_num>: 112,117
public void testIntersectionWith() { [EOL]     ConcreteFunctionType fun = createFunction("fun"); [EOL]     ConcreteFunctionType fun2 = createFunction("fun2"); [EOL]     ConcreteType obj = fun.getInstanceType(); [EOL]     ConcreteType both = new ConcreteUnionType(fun, obj); [EOL]     assertEquals(NONE, fun.intersectWith(obj)); [EOL]     assertEquals(NONE, obj.intersectWith(fun)); [EOL]     assertEquals(fun, both.intersectWith(fun)); [EOL]     assertEquals(fun, fun.intersectWith(both)); [EOL]     assertEquals(NONE, NONE.intersectWith(both)); [EOL]     assertEquals(NONE, both.intersectWith(NONE)); [EOL]     assertEquals(NONE, fun.intersectWith(NONE)); [EOL]     assertEquals(NONE, NONE.intersectWith(fun)); [EOL]     assertEquals(NONE, both.intersectWith(fun2)); [EOL]     assertEquals(both, ALL.intersectWith(both)); [EOL]     assertEquals(both, both.intersectWith(ALL)); [EOL]     assertEquals(fun, ALL.intersectWith(fun)); [EOL]     assertEquals(fun, fun.intersectWith(ALL)); [EOL]     assertEquals(NONE, ALL.intersectWith(NONE)); [EOL]     assertEquals(NONE, NONE.intersectWith(ALL)); [EOL] } <line_num>: 119,144
public void testFunction() { [EOL]     ConcreteFunctionType fun = createFunction("fun", "a", "b"); [EOL]     assertTrue(fun.isFunction()); [EOL]     assertNotNull(fun.getCallSlot()); [EOL]     assertNotNull(fun.getReturnSlot()); [EOL]     assertNotNull(fun.getParameterSlot(0)); [EOL]     assertNotNull(fun.getParameterSlot(1)); [EOL]     assertNull(fun.getParameterSlot(2)); [EOL]     assertTrue(fun.getInstanceType().isInstance()); [EOL] } <line_num>: 146,155
public void testInstance() { [EOL]     ConcreteInstanceType obj = createInstance("MyObj", "a", "b"); [EOL]     assertTrue(obj.isInstance()); [EOL]     assertNotNull(obj.getPropertySlot("a")); [EOL]     assertNotNull(obj.getPropertySlot("b")); [EOL]     assertNull(obj.getPropertySlot("c")); [EOL]     for (int i = 0; i < 3; ++i) { [EOL]         assertNotNull(obj = obj.getImplicitPrototype()); [EOL]         assertTrue(obj.isInstance()); [EOL]     } [EOL]     assertNull(obj.getImplicitPrototype()); [EOL] } <line_num>: 157,171
public void testGetX() { [EOL]     ConcreteFunctionType fun1 = createFunction("fun1"); [EOL]     ConcreteFunctionType fun2 = createFunction("fun2"); [EOL]     ConcreteInstanceType obj1 = fun1.getInstanceType(); [EOL]     ConcreteInstanceType obj2 = fun2.getInstanceType(); [EOL]     ConcreteType union1 = fun1.unionWith(obj1); [EOL]     ConcreteType union2 = union1.unionWith(fun2).unionWith(obj2); [EOL]     assertEqualSets(Lists.newArrayList(), NONE.getFunctions()); [EOL]     assertEqualSets(Lists.newArrayList(), NONE.getInstances()); [EOL]     assertEqualSets(Lists.newArrayList(fun1), fun1.getFunctions()); [EOL]     assertEqualSets(Lists.newArrayList(), fun1.getInstances()); [EOL]     assertEqualSets(Lists.newArrayList(), obj1.getFunctions()); [EOL]     assertEqualSets(Lists.newArrayList(obj1), obj1.getInstances()); [EOL]     assertEqualSets(Lists.newArrayList(fun1), union1.getFunctions()); [EOL]     assertEqualSets(Lists.newArrayList(obj1), union1.getInstances()); [EOL]     assertEqualSets(Lists.newArrayList(fun1, fun2), union2.getFunctions()); [EOL]     assertEqualSets(Lists.newArrayList(obj1, obj2), union2.getInstances()); [EOL] } <line_num>: 173,194
private void assertEqualSets(Collection<?> first, Collection<?> second) { [EOL]     assertEquals(Sets.newHashSet(first), Sets.newHashSet(second)); [EOL] } <line_num>: 197,199
private ConcreteFunctionType createFunction(String name, String... paramNames) { [EOL]     Node args = new Node(Token.PARAM_LIST); [EOL]     for (int i = 0; i < paramNames.length; ++i) { [EOL]         args.addChildToBack(Node.newString(Token.NAME, paramNames[i])); [EOL]     } [EOL]     Node decl = new Node(Token.FUNCTION, Node.newString(Token.NAME, name), args, new Node(Token.BLOCK)); [EOL]     JSType[] paramTypes = new JSType[paramNames.length]; [EOL]     Arrays.fill(paramTypes, unknownType); [EOL]     decl.setJSType(typeRegistry.createConstructorType(name, decl, args, unknownType, null)); [EOL]     return new ConcreteFunctionType(factory, decl, null); [EOL] } <line_num>: 202,220
private ConcreteInstanceType createInstance(String name, String... propNames) { [EOL]     ObjectType objType = typeRegistry.createObjectType(name, null, typeRegistry.createObjectType(name + ".prototype", null, null)); [EOL]     for (int i = 0; i < propNames.length; ++i) { [EOL]         objType.defineDeclaredProperty(propNames[i], unknownType, null); [EOL]     } [EOL]     return new ConcreteInstanceType(factory, objType); [EOL] } <line_num>: 223,231
@Override [EOL] public JSTypeRegistry getTypeRegistry() { [EOL]     return registry; [EOL] } <line_num>: 244,247
@Override [EOL] public ConcreteFunctionType createConcreteFunction(Node decl, StaticScope<ConcreteType> parent) { [EOL]     ConcreteFunctionType funcType = functionByDeclaration.get(decl); [EOL]     if (funcType == null) { [EOL]         functionByDeclaration.put(decl, funcType = new ConcreteFunctionType(this, decl, parent)); [EOL]         if (decl.getJSType() != null) { [EOL]             functionByJSType.put((FunctionType) decl.getJSType(), funcType); [EOL]         } [EOL]     } [EOL]     return funcType; [EOL] } <line_num>: 250,262
@Override [EOL] public ConcreteInstanceType createConcreteInstance(ObjectType instanceType) { [EOL]     ConcreteInstanceType instType = instanceByJSType.get(instanceType); [EOL]     if (instType == null) { [EOL]         instanceByJSType.put(instanceType, instType = new ConcreteInstanceType(this, instanceType)); [EOL]     } [EOL]     return instType; [EOL] } <line_num>: 265,274
@Override [EOL] public ConcreteFunctionType getConcreteFunction(FunctionType functionType) { [EOL]     return functionByJSType.get(functionType); [EOL] } <line_num>: 277,280
@Override [EOL] public ConcreteInstanceType getConcreteInstance(ObjectType instanceType) { [EOL]     return instanceByJSType.get(instanceType); [EOL] } <line_num>: 283,286
@Override [EOL] public StaticScope<ConcreteType> createFunctionScope(Node decl, StaticScope<ConcreteType> parent) { [EOL]     FakeScope scope = new FakeScope((FakeScope) parent); [EOL]     scope.addSlot(ConcreteFunctionType.CALL_SLOT_NAME); [EOL]     scope.addSlot(ConcreteFunctionType.THIS_SLOT_NAME); [EOL]     scope.addSlot(ConcreteFunctionType.RETURN_SLOT_NAME); [EOL]     for (Node n = decl.getFirstChild().getNext().getFirstChild(); n != null; n = n.getNext()) { [EOL]         scope.addSlot(n.getString()); [EOL]     } [EOL]     return scope; [EOL] } <line_num>: 289,302
@Override [EOL] public StaticScope<ConcreteType> createInstanceScope(ObjectType instanceType) { [EOL]     FakeScope parentScope = null; [EOL]     if (instanceType.getImplicitPrototype() != null) { [EOL]         ConcreteInstanceType prototype = createConcreteInstance(instanceType.getImplicitPrototype()); [EOL]         parentScope = (FakeScope) prototype.getScope(); [EOL]     } [EOL]     FakeScope scope = new FakeScope(parentScope); [EOL]     for (String propName : instanceType.getOwnPropertyNames()) { [EOL]         scope.addSlot(propName); [EOL]     } [EOL]     return scope; [EOL] } <line_num>: 305,320
@Override [EOL] public StaticScope<ConcreteType> getParentScope() { [EOL]     return parent; [EOL] } <line_num>: 333,334
@Override [EOL] public StaticSlot<ConcreteType> getOwnSlot(String name) { [EOL]     return slots.get(name); [EOL] } <line_num>: 337,340
@Override [EOL] public StaticSlot<ConcreteType> getSlot(String name) { [EOL]     if (slots.containsKey(name)) { [EOL]         return slots.get(name); [EOL]     } else if (parent != null) { [EOL]         return parent.getSlot(name); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] } <line_num>: 343,352
@Override [EOL] public ConcreteType getTypeOfThis() { [EOL]     return ConcreteType.ALL; [EOL] } <line_num>: 355,356
void addSlot(String name) { [EOL]     slots.put(name, new FakeSlot(name)); [EOL] } <line_num>: 358,360
@Override [EOL] public String getName() { [EOL]     return name; [EOL] } <line_num>: 371,372
@Override [EOL] public ConcreteType getType() { [EOL]     return ConcreteType.ALL; [EOL] } <line_num>: 374,375
@Override [EOL] public boolean isTypeInferred() { [EOL]     return true; [EOL] } <line_num>: 377,378
@Override [EOL] public StaticReference<ConcreteType> getDeclaration() { [EOL]     return null; [EOL] } <line_num>: 380,381
@Override [EOL] public JSDocInfo getJSDocInfo() { [EOL]     return null; [EOL] } <line_num>: 383,384
