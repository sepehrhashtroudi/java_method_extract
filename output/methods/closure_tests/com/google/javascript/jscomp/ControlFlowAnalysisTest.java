private void testCfg(String input, String expected) { [EOL]     testCfg(input, expected, true); [EOL] } <line_num>: 47,49
private static List<DiGraphEdge<Node, Branch>> getAllEdges(ControlFlowGraph<Node> cfg) { [EOL]     List<DiGraphEdge<Node, Branch>> edges = Lists.newArrayList(); [EOL]     for (DiGraphNode<Node, Branch> n : cfg.getDirectedGraphNodes()) { [EOL]         for (DiGraphEdge<Node, Branch> e : cfg.getOutEdges(n.getValue())) { [EOL]             edges.add(e); [EOL]         } [EOL]     } [EOL]     return edges; [EOL] } <line_num>: 54,63
private static List<DiGraphEdge<Node, Branch>> getAllEdges(ControlFlowGraph<Node> cfg, int startToken, int endToken) { [EOL]     List<DiGraphEdge<Node, Branch>> edges = getAllEdges(cfg); [EOL]     Iterator<DiGraphEdge<Node, Branch>> it = edges.iterator(); [EOL]     while (it.hasNext()) { [EOL]         DiGraphEdge<Node, Branch> edge = it.next(); [EOL]         Node startNode = edge.getSource().getValue(); [EOL]         Node endNode = edge.getDestination().getValue(); [EOL]         if (startNode == null || endNode == null || startNode.getType() != startToken || endNode.getType() != endToken) { [EOL]             it.remove(); [EOL]         } [EOL]     } [EOL]     return edges; [EOL] } <line_num>: 69,83
private static List<DiGraphEdge<Node, Branch>> getAllEdges(ControlFlowGraph<Node> cfg, int startToken, int endToken, Branch type) { [EOL]     List<DiGraphEdge<Node, Branch>> edges = getAllEdges(cfg, startToken, endToken); [EOL]     Iterator<DiGraphEdge<Node, Branch>> it = edges.iterator(); [EOL]     while (it.hasNext()) { [EOL]         if (type != it.next().getValue()) { [EOL]             it.remove(); [EOL]         } [EOL]     } [EOL]     return edges; [EOL] } <line_num>: 89,100
private static boolean isAncestor(Node n, Node maybeDescendent) { [EOL]     for (Node current = n.getFirstChild(); current != null; current = current.getNext()) { [EOL]         if (current == maybeDescendent || isAncestor(current, maybeDescendent)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 102,112
private static List<DiGraphEdge<Node, Branch>> getAllDownEdges(ControlFlowGraph<Node> cfg, int startToken, int endToken, Branch type) { [EOL]     List<DiGraphEdge<Node, Branch>> edges = getAllEdges(cfg, startToken, endToken, type); [EOL]     Iterator<DiGraphEdge<Node, Branch>> it = edges.iterator(); [EOL]     while (it.hasNext()) { [EOL]         DiGraphEdge<Node, Branch> edge = it.next(); [EOL]         Node source = edge.getSource().getValue(); [EOL]         Node dest = edge.getDestination().getValue(); [EOL]         if (!isAncestor(source, dest)) { [EOL]             it.remove(); [EOL]         } [EOL]     } [EOL]     return edges; [EOL] } <line_num>: 119,134
private static void assertNoEdge(ControlFlowGraph<Node> cfg, int startToken, int endToken) { [EOL]     assertEquals(0, getAllEdges(cfg, startToken, endToken).size()); [EOL] } <line_num>: 140,143
private static void assertDownEdge(ControlFlowGraph<Node> cfg, int startToken, int endToken, Branch type) { [EOL]     assertTrue("No down edge found", 0 != getAllDownEdges(cfg, startToken, endToken, type).size()); [EOL] } <line_num>: 150,154
private static void assertUpEdge(ControlFlowGraph<Node> cfg, int startToken, int endToken, Branch type) { [EOL]     assertTrue("No up edge found", 0 != getAllDownEdges(cfg, endToken, startToken, type).size()); [EOL] } <line_num>: 161,165
private static void assertCrossEdge(ControlFlowGraph<Node> cfg, int startToken, int endToken, Branch type) { [EOL]     int numDownEdges = getAllDownEdges(cfg, startToken, endToken, type).size(); [EOL]     int numUpEdges = getAllDownEdges(cfg, endToken, startToken, type).size(); [EOL]     int numEdges = getAllEdges(cfg, startToken, endToken, type).size(); [EOL]     assertTrue("No cross edges found", numDownEdges + numUpEdges < numEdges); [EOL] } <line_num>: 172,178
private static void assertReturnEdge(ControlFlowGraph<Node> cfg, int startToken) { [EOL]     List<DiGraphEdge<Node, Branch>> edges = getAllEdges(cfg); [EOL]     for (DiGraphEdge<Node, Branch> edge : edges) { [EOL]         Node source = edge.getSource().getValue(); [EOL]         DiGraphNode<Node, Branch> dest = edge.getDestination(); [EOL]         if (source.getType() == startToken && cfg.isImplicitReturn(dest)) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     fail("No return edge found"); [EOL] } <line_num>: 184,197
private static void assertNoReturnEdge(ControlFlowGraph<Node> cfg, int startToken) { [EOL]     List<DiGraphEdge<Node, Branch>> edges = getAllEdges(cfg); [EOL]     for (DiGraphEdge<Node, Branch> edge : edges) { [EOL]         Node source = edge.getSource().getValue(); [EOL]         DiGraphNode<Node, Branch> dest = edge.getDestination(); [EOL]         if (source.getType() == startToken) { [EOL]             assertTrue("Token " + startToken + " should not have an out going" + " edge to the implicit return", !cfg.isImplicitReturn(dest)); [EOL]             return; [EOL]         } [EOL]     } [EOL] } <line_num>: 203,215
private ControlFlowGraph<Node> createCfg(String input, boolean runSynBlockPass) { [EOL]     Compiler compiler = new Compiler(); [EOL]     ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, true, true); [EOL]     Node root = compiler.parseSyntheticCode("cfgtest", input); [EOL]     if (runSynBlockPass) { [EOL]         CreateSyntheticBlocks pass = new CreateSyntheticBlocks(compiler, "START", "END"); [EOL]         pass.process(null, root); [EOL]     } [EOL]     cfa.process(null, root); [EOL]     return cfa.getCfg(); [EOL] } <line_num>: 222,235
private ControlFlowGraph<Node> createCfg(String input) { [EOL]     return createCfg(input, false); [EOL] } <line_num>: 237,239
private void testCfg(String input, String expected, boolean shouldTraverseFunctions) { [EOL]     Compiler compiler = new Compiler(); [EOL]     ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, shouldTraverseFunctions, true); [EOL]     Node root = compiler.parseSyntheticCode("cfgtest", input); [EOL]     cfa.process(null, root); [EOL]     ControlFlowGraph<Node> cfg = cfa.getCfg(); [EOL]     try { [EOL]         assertEquals(expected, DotFormatter.toDot(root, cfg)); [EOL]     } catch (java.io.IOException e) { [EOL]         fail("Tests failed with IOExceptions"); [EOL]     } [EOL] } <line_num>: 252,266
public void testSimpleStatements() { [EOL]     String src = "var a; a = a; a = a"; [EOL]     ControlFlowGraph<Node> cfg = createCfg(src); [EOL]     assertDownEdge(cfg, Token.SCRIPT, Token.VAR, Branch.UNCOND); [EOL]     assertCrossEdge(cfg, Token.VAR, Token.EXPR_RESULT, Branch.UNCOND); [EOL]     assertCrossEdge(cfg, Token.EXPR_RESULT, Token.EXPR_RESULT, Branch.UNCOND); [EOL] } <line_num>: 268,274
public void testSimpleIf() { [EOL]     String src = "var x; if (x) { x() } else { x() };"; [EOL]     ControlFlowGraph<Node> cfg = createCfg(src); [EOL]     assertDownEdge(cfg, Token.SCRIPT, Token.VAR, Branch.UNCOND); [EOL]     assertCrossEdge(cfg, Token.VAR, Token.IF, Branch.UNCOND); [EOL]     assertDownEdge(cfg, Token.IF, Token.BLOCK, Branch.ON_TRUE); [EOL]     assertDownEdge(cfg, Token.BLOCK, Token.EXPR_RESULT, Branch.UNCOND); [EOL]     assertNoEdge(cfg, Token.EXPR_RESULT, Token.CALL); [EOL]     assertDownEdge(cfg, Token.IF, Token.BLOCK, Branch.ON_FALSE); [EOL]     assertReturnEdge(cfg, Token.EMPTY); [EOL] } <line_num>: 277,287
public void testBreakingBlock() { [EOL]     String src = "X: { while(1) { break } }"; [EOL]     ControlFlowGraph<Node> cfg = createCfg(src); [EOL]     assertUpEdge(cfg, Token.BREAK, Token.BLOCK, Branch.UNCOND); [EOL] } <line_num>: 289,294
public void testBreakingTryBlock() { [EOL]     String src = "a: try { break a; } finally {} if(x) {}"; [EOL]     ControlFlowGraph<Node> cfg = createCfg(src); [EOL]     assertCrossEdge(cfg, Token.BREAK, Token.IF, Branch.UNCOND); [EOL]     src = "a: try {} finally {break a;} if(x) {}"; [EOL]     cfg = createCfg(src); [EOL]     assertCrossEdge(cfg, Token.BREAK, Token.IF, Branch.UNCOND); [EOL]     src = "a: try {} catch(e) {break a;} if(x) {}"; [EOL]     cfg = createCfg(src); [EOL]     assertCrossEdge(cfg, Token.BREAK, Token.IF, Branch.UNCOND); [EOL] } <line_num>: 296,308
public void testWithStatement() { [EOL]     String src = "var x, y; with(x) { y() }"; [EOL]     ControlFlowGraph<Node> cfg = createCfg(src); [EOL]     assertDownEdge(cfg, Token.WITH, Token.BLOCK, Branch.UNCOND); [EOL]     assertNoEdge(cfg, Token.WITH, Token.NAME); [EOL]     assertNoEdge(cfg, Token.NAME, Token.BLOCK); [EOL]     assertDownEdge(cfg, Token.BLOCK, Token.EXPR_RESULT, Branch.UNCOND); [EOL]     assertReturnEdge(cfg, Token.EXPR_RESULT); [EOL] } <line_num>: 310,318
public void testSimpleWhile() { [EOL]     String src = "var x; while (x) { x(); if (x) { break; } x() }"; [EOL]     ControlFlowGraph<Node> cfg = createCfg(src); [EOL]     assertDownEdge(cfg, Token.WHILE, Token.BLOCK, Branch.ON_TRUE); [EOL]     assertDownEdge(cfg, Token.BLOCK, Token.EXPR_RESULT, Branch.UNCOND); [EOL]     assertDownEdge(cfg, Token.IF, Token.BLOCK, Branch.ON_TRUE); [EOL]     assertReturnEdge(cfg, Token.BREAK); [EOL] } <line_num>: 321,328
public void testSimpleSwitch() { [EOL]     String src = "var x; switch(x){ case(1): x(); case('x'): x(); break" + "; default: x();}"; [EOL]     ControlFlowGraph<Node> cfg = createCfg(src); [EOL]     assertCrossEdge(cfg, Token.VAR, Token.SWITCH, Branch.UNCOND); [EOL]     assertNoEdge(cfg, Token.SWITCH, Token.NAME); [EOL]     assertDownEdge(cfg, Token.SWITCH, Token.CASE, Branch.UNCOND); [EOL]     assertCrossEdge(cfg, Token.CASE, Token.CASE, Branch.ON_FALSE); [EOL]     assertCrossEdge(cfg, Token.CASE, Token.DEFAULT_CASE, Branch.ON_FALSE); [EOL]     assertDownEdge(cfg, Token.CASE, Token.BLOCK, Branch.ON_TRUE); [EOL]     assertDownEdge(cfg, Token.BLOCK, Token.EXPR_RESULT, Branch.UNCOND); [EOL]     assertNoEdge(cfg, Token.EXPR_RESULT, Token.CALL); [EOL]     assertNoEdge(cfg, Token.CALL, Token.NAME); [EOL] } <line_num>: 330,345
public void testSimpleNoDefault() { [EOL]     String src = "var x; switch(x){ case(1): break; } x();"; [EOL]     ControlFlowGraph<Node> cfg = createCfg(src); [EOL]     assertCrossEdge(cfg, Token.CASE, Token.EXPR_RESULT, Branch.ON_FALSE); [EOL] } <line_num>: 347,351
public void testSwitchDefaultFirst() { [EOL]     String src = "var x; switch(x){ default: break; case 1: break; }"; [EOL]     ControlFlowGraph<Node> cfg = createCfg(src); [EOL]     assertDownEdge(cfg, Token.SWITCH, Token.CASE, Branch.UNCOND); [EOL]     assertCrossEdge(cfg, Token.CASE, Token.DEFAULT_CASE, Branch.ON_FALSE); [EOL] } <line_num>: 353,359
public void testSwitchDefaultInMiddle() { [EOL]     String src = "var x; switch(x){ case 1: break; default: break; " + "case 2: break; }"; [EOL]     ControlFlowGraph<Node> cfg = createCfg(src); [EOL]     assertDownEdge(cfg, Token.SWITCH, Token.CASE, Branch.UNCOND); [EOL]     assertCrossEdge(cfg, Token.CASE, Token.CASE, Branch.ON_FALSE); [EOL]     assertCrossEdge(cfg, Token.CASE, Token.DEFAULT_CASE, Branch.ON_FALSE); [EOL] } <line_num>: 361,369
public void testSwitchEmpty() { [EOL]     String src = "var x; switch(x){}; x()"; [EOL]     ControlFlowGraph<Node> cfg = createCfg(src); [EOL]     assertCrossEdge(cfg, Token.SWITCH, Token.EMPTY, Branch.UNCOND); [EOL]     assertCrossEdge(cfg, Token.EMPTY, Token.EXPR_RESULT, Branch.UNCOND); [EOL] } <line_num>: 371,377
public void testReturnThrowingException() { [EOL]     String src = "function f() {try { return a(); } catch (e) {e()}}"; [EOL]     ControlFlowGraph<Node> cfg = createCfg(src); [EOL]     assertCrossEdge(cfg, Token.RETURN, Token.BLOCK, Branch.ON_EX); [EOL]     assertDownEdge(cfg, Token.BLOCK, Token.CATCH, Branch.UNCOND); [EOL] } <line_num>: 379,384
public void testSimpleFor() { [EOL]     String src = "var a; for (var x = 0; x < 100; x++) { a(); }"; [EOL]     String expected = "digraph AST {\n" + "  node [color=lightblue2, style=filled];\n" + "  node0 [label=\"SCRIPT\"];\n" + "  node1 [label=\"VAR\"];\n" + "  node0 -> node1 [weight=1];\n" + "  node2 [label=\"NAME\"];\n" + "  node1 -> node2 [weight=1];\n" + "  node3 [label=\"VAR\"];\n" + "  node1 -> node3 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node4 [label=\"FOR\"];\n" + "  node0 -> node4 [weight=1];\n" + "  node4 -> node3 [weight=1];\n" + "  node5 [label=\"NAME\"];\n" + "  node3 -> node5 [weight=1];\n" + "  node6 [label=\"NUMBER\"];\n" + "  node5 -> node6 [weight=1];\n" + "  node3 -> node4 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node7 [label=\"LT\"];\n" + "  node4 -> node7 [weight=1];\n" + "  node8 [label=\"NAME\"];\n" + "  node7 -> node8 [weight=1];\n" + "  node9 [label=\"NUMBER\"];\n" + "  node7 -> node9 [weight=1];\n" + "  node10 [label=\"INC\"];\n" + "  node4 -> node10 [weight=1];\n" + "  node11 [label=\"NAME\"];\n" + "  node10 -> node11 [weight=1];\n" + "  node10 -> node4 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node12 [label=\"BLOCK\"];\n" + "  node4 -> node12 [weight=1];\n" + "  node13 [label=\"EXPR_RESULT\"];\n" + "  node12 -> node13 [weight=1];\n" + "  node14 [label=\"CALL\"];\n" + "  node13 -> node14 [weight=1];\n" + "  node15 [label=\"NAME\"];\n" + "  node14 -> node15 [weight=1];\n" + "  node13 -> node10 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node12 -> node13 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node4 -> RETURN " + "[label=\"ON_FALSE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node4 -> node12 " + "[label=\"ON_TRUE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node0 -> node1 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "}\n"; [EOL]     testCfg(src, expected); [EOL] } <line_num>: 387,440
public void testSimpleForWithContinue() { [EOL]     String src = "var a; for (var x = 0; x < 100; x++) {a();continue;a()}"; [EOL]     String expected = "digraph AST {\n" + "  node [color=lightblue2, style=filled];\n" + "  node0 [label=\"SCRIPT\"];\n" + "  node1 [label=\"VAR\"];\n" + "  node0 -> node1 [weight=1];\n" + "  node2 [label=\"NAME\"];\n" + "  node1 -> node2 [weight=1];\n" + "  node3 [label=\"VAR\"];\n" + "  node1 -> node3 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node4 [label=\"FOR\"];\n" + "  node0 -> node4 [weight=1];\n" + "  node4 -> node3 [weight=1];\n" + "  node5 [label=\"NAME\"];\n" + "  node3 -> node5 [weight=1];\n" + "  node6 [label=\"NUMBER\"];\n" + "  node5 -> node6 [weight=1];\n" + "  node3 -> node4 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node7 [label=\"LT\"];\n" + "  node4 -> node7 [weight=1];\n" + "  node8 [label=\"NAME\"];\n" + "  node7 -> node8 [weight=1];\n" + "  node9 [label=\"NUMBER\"];\n" + "  node7 -> node9 [weight=1];\n" + "  node10 [label=\"INC\"];\n" + "  node4 -> node10 [weight=1];\n" + "  node11 [label=\"NAME\"];\n" + "  node10 -> node11 [weight=1];\n" + "  node10 -> node4 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node12 [label=\"BLOCK\"];\n" + "  node4 -> node12 [weight=1];\n" + "  node13 [label=\"EXPR_RESULT\"];\n" + "  node12 -> node13 [weight=1];\n" + "  node14 [label=\"CALL\"];\n" + "  node13 -> node14 [weight=1];\n" + "  node15 [label=\"NAME\"];\n" + "  node14 -> node15 [weight=1];\n" + "  node16 [label=\"CONTINUE\"];\n" + "  node13 -> node16 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node12 -> node16 [weight=1];\n" + "  node16 -> node10 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node17 [label=\"EXPR_RESULT\"];\n" + "  node12 -> node17 [weight=1];\n" + "  node18 [label=\"CALL\"];\n" + "  node17 -> node18 [weight=1];\n" + "  node19 [label=\"NAME\"];\n" + "  node18 -> node19 [weight=1];\n" + "  node17 -> node10 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node12 -> node13 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node4 -> RETURN " + "[label=\"ON_FALSE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node4 -> node12 " + "[label=\"ON_TRUE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node0 -> node1 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "}\n"; [EOL]     testCfg(src, expected); [EOL] } <line_num>: 442,507
public void testNestedFor() { [EOL]     String src = "var a,b;a();for(var x=0;x<100;x++){for(var y=0;y<100;y++){" + "continue;b();}}"; [EOL]     String expected = "digraph AST {\n" + "  node [color=lightblue2, style=filled];\n" + "  node0 [label=\"SCRIPT\"];\n" + "  node1 [label=\"VAR\"];\n" + "  node0 -> node1 [weight=1];\n" + "  node2 [label=\"NAME\"];\n" + "  node1 -> node2 [weight=1];\n" + "  node3 [label=\"NAME\"];\n" + "  node1 -> node3 [weight=1];\n" + "  node4 [label=\"EXPR_RESULT\"];\n" + "  node1 -> node4 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node0 -> node4 [weight=1];\n" + "  node5 [label=\"CALL\"];\n" + "  node4 -> node5 [weight=1];\n" + "  node6 [label=\"NAME\"];\n" + "  node5 -> node6 [weight=1];\n" + "  node7 [label=\"VAR\"];\n" + "  node4 -> node7 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node8 [label=\"FOR\"];\n" + "  node0 -> node8 [weight=1];\n" + "  node8 -> node7 [weight=1];\n" + "  node9 [label=\"NAME\"];\n" + "  node7 -> node9 [weight=1];\n" + "  node10 [label=\"NUMBER\"];\n" + "  node9 -> node10 [weight=1];\n" + "  node7 -> node8 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node11 [label=\"LT\"];\n" + "  node8 -> node11 [weight=1];\n" + "  node12 [label=\"NAME\"];\n" + "  node11 -> node12 [weight=1];\n" + "  node13 [label=\"NUMBER\"];\n" + "  node11 -> node13 [weight=1];\n" + "  node14 [label=\"INC\"];\n" + "  node8 -> node14 [weight=1];\n" + "  node15 [label=\"NAME\"];\n" + "  node14 -> node15 [weight=1];\n" + "  node14 -> node8 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node16 [label=\"BLOCK\"];\n" + "  node8 -> node16 [weight=1];\n" + "  node17 [label=\"FOR\"];\n" + "  node16 -> node17 [weight=1];\n" + "  node18 [label=\"VAR\"];\n" + "  node17 -> node18 [weight=1];\n" + "  node19 [label=\"NAME\"];\n" + "  node18 -> node19 [weight=1];\n" + "  node20 [label=\"NUMBER\"];\n" + "  node19 -> node20 [weight=1];\n" + "  node18 -> node17 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node21 [label=\"LT\"];\n" + "  node17 -> node21 [weight=1];\n" + "  node22 [label=\"NAME\"];\n" + "  node21 -> node22 [weight=1];\n" + "  node23 [label=\"NUMBER\"];\n" + "  node21 -> node23 [weight=1];\n" + "  node24 [label=\"INC\"];\n" + "  node17 -> node24 [weight=1];\n" + "  node25 [label=\"NAME\"];\n" + "  node24 -> node25 [weight=1];\n" + "  node24 -> node17 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node26 [label=\"BLOCK\"];\n" + "  node17 -> node26 [weight=1];\n" + "  node27 [label=\"CONTINUE\"];\n" + "  node26 -> node27 [weight=1];\n" + "  node27 -> node24 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node28 [label=\"EXPR_RESULT\"];\n" + "  node26 -> node28 [weight=1];\n" + "  node29 [label=\"CALL\"];\n" + "  node28 -> node29 [weight=1];\n" + "  node30 [label=\"NAME\"];\n" + "  node29 -> node30 [weight=1];\n" + "  node28 -> node24 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node26 -> node27 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node17 -> node14 " + "[label=\"ON_FALSE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node17 -> node26 " + "[label=\"ON_TRUE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node16 -> node18 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node8 -> RETURN " + "[label=\"ON_FALSE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node8 -> node16 " + "[label=\"ON_TRUE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node0 -> node1 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "}\n"; [EOL]     testCfg(src, expected); [EOL] } <line_num>: 509,608
public void testNestedDoWithBreak() { [EOL]     String src = "var a;do{do{break}while(a);do{a()}while(a)}while(a);"; [EOL]     String expected = "digraph AST {\n" + "  node [color=lightblue2, style=filled];\n" + "  node0 [label=\"SCRIPT\"];\n" + "  node1 [label=\"VAR\"];\n" + "  node0 -> node1 [weight=1];\n" + "  node2 [label=\"NAME\"];\n" + "  node1 -> node2 [weight=1];\n" + "  node3 [label=\"BLOCK\"];\n" + "  node1 -> node3 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node4 [label=\"DO\"];\n" + "  node0 -> node4 [weight=1];\n" + "  node4 -> node3 [weight=1];\n" + "  node5 [label=\"DO\"];\n" + "  node3 -> node5 [weight=1];\n" + "  node6 [label=\"BLOCK\"];\n" + "  node5 -> node6 [weight=1];\n" + "  node7 [label=\"BREAK\"];\n" + "  node6 -> node7 [weight=1];\n" + "  node8 [label=\"BLOCK\"];\n" + "  node7 -> node8 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node6 -> node7 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node9 [label=\"NAME\"];\n" + "  node5 -> node9 [weight=1];\n" + "  node5 -> node6 " + "[label=\"ON_TRUE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node5 -> node8 " + "[label=\"ON_FALSE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node10 [label=\"DO\"];\n" + "  node3 -> node10 [weight=1];\n" + "  node10 -> node8 [weight=1];\n" + "  node11 [label=\"EXPR_RESULT\"];\n" + "  node8 -> node11 [weight=1];\n" + "  node12 [label=\"CALL\"];\n" + "  node11 -> node12 [weight=1];\n" + "  node13 [label=\"NAME\"];\n" + "  node12 -> node13 [weight=1];\n" + "  node11 -> node10 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node8 -> node11 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node14 [label=\"NAME\"];\n" + "  node10 -> node14 [weight=1];\n" + "  node10 -> node4 " + "[label=\"ON_FALSE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node10 -> node8 " + "[label=\"ON_TRUE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node3 -> node6 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node15 [label=\"NAME\"];\n" + "  node4 -> node15 [weight=1];\n" + "  node4 -> RETURN " + "[label=\"ON_FALSE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node4 -> node3 " + "[label=\"ON_TRUE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node0 -> node1 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "}\n"; [EOL]     testCfg(src, expected); [EOL] } <line_num>: 610,674
public void testForIn() { [EOL]     String src = "var a,b;for(a in b){a()};"; [EOL]     String expected = "digraph AST {\n" + "  node [color=lightblue2, style=filled];\n" + "  node0 [label=\"SCRIPT\"];\n" + "  node1 [label=\"VAR\"];\n" + "  node0 -> node1 [weight=1];\n" + "  node2 [label=\"NAME\"];\n" + "  node1 -> node2 [weight=1];\n" + "  node3 [label=\"NAME\"];\n" + "  node1 -> node3 [weight=1];\n" + "  node4 [label=\"NAME\"];\n" + "  node1 -> node4 [label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node5 [label=\"FOR\"];\n" + "  node0 -> node5 [weight=1];\n" + "  node6 [label=\"NAME\"];\n" + "  node5 -> node6 [weight=1];\n" + "  node5 -> node4 [weight=1];\n" + "  node4 -> node5 [label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node7 [label=\"BLOCK\"];\n" + "  node5 -> node7 [weight=1];\n" + "  node8 [label=\"EXPR_RESULT\"];\n" + "  node7 -> node8 [weight=1];\n" + "  node9 [label=\"CALL\"];\n" + "  node8 -> node9 [weight=1];\n" + "  node10 [label=\"NAME\"];\n" + "  node9 -> node10 [weight=1];\n" + "  node8 -> node5 [label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node7 -> node8 [label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node11 [label=\"EMPTY\"];\n" + "  node5 -> node11 [label=\"ON_FALSE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node5 -> node7 [label=\"ON_TRUE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node0 -> node11 [weight=1];\n" + "  node11 -> RETURN [label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node0 -> node1 [label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "}\n"; [EOL]     testCfg(src, expected); [EOL] } <line_num>: 676,713
public void testThrow() { [EOL]     String src = "function f() { throw 1; f() }"; [EOL]     String expected = "digraph AST {\n" + "  node [color=lightblue2, style=filled];\n" + "  node0 [label=\"SCRIPT\"];\n" + "  node1 [label=\"FUNCTION\"];\n" + "  node0 -> node1 [weight=1];\n" + "  node2 [label=\"NAME\"];\n" + "  node1 -> node2 [weight=1];\n" + "  node3 [label=\"PARAM_LIST\"];\n" + "  node1 -> node3 [weight=1];\n" + "  node4 [label=\"BLOCK\"];\n" + "  node1 -> node4 [weight=1];\n" + "  node5 [label=\"THROW\"];\n" + "  node4 -> node5 [weight=1];\n" + "  node6 [label=\"NUMBER\"];\n" + "  node5 -> node6 [weight=1];\n" + "  node7 [label=\"EXPR_RESULT\"];\n" + "  node4 -> node7 [weight=1];\n" + "  node8 [label=\"CALL\"];\n" + "  node7 -> node8 [weight=1];\n" + "  node9 [label=\"NAME\"];\n" + "  node8 -> node9 [weight=1];\n" + "  node7 -> RETURN " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node4 -> node5 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node1 -> node4 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node0 -> RETURN " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "}\n"; [EOL]     testCfg(src, expected); [EOL] } <line_num>: 715,748
public void testSimpleFunction() { [EOL]     String src = "function f() { f() } f()"; [EOL]     String expected = "digraph AST {\n" + "  node [color=lightblue2, style=filled];\n" + "  node0 [label=\"SCRIPT\"];\n" + "  node1 [label=\"FUNCTION\"];\n" + "  node0 -> node1 [weight=1];\n" + "  node2 [label=\"NAME\"];\n" + "  node1 -> node2 [weight=1];\n" + "  node3 [label=\"PARAM_LIST\"];\n" + "  node1 -> node3 [weight=1];\n" + "  node4 [label=\"BLOCK\"];\n" + "  node1 -> node4 [weight=1];\n" + "  node5 [label=\"EXPR_RESULT\"];\n" + "  node4 -> node5 [weight=1];\n" + "  node6 [label=\"CALL\"];\n" + "  node5 -> node6 [weight=1];\n" + "  node7 [label=\"NAME\"];\n" + "  node6 -> node7 [weight=1];\n" + "  node5 -> RETURN " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node4 -> node5 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node1 -> node4 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node8 [label=\"EXPR_RESULT\"];\n" + "  node0 -> node8 [weight=1];\n" + "  node9 [label=\"CALL\"];\n" + "  node8 -> node9 [weight=1];\n" + "  node10 [label=\"NAME\"];\n" + "  node9 -> node10 [weight=1];\n" + "  node8 -> RETURN " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node0 -> node8 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "}\n"; [EOL]     testCfg(src, expected); [EOL] } <line_num>: 751,788
public void testSimpleCatch() { [EOL]     String src = "try{ throw x; x(); x['stuff']; x.x; x} catch (e) { e() }"; [EOL]     String expected = "digraph AST {\n" + "  node [color=lightblue2, style=filled];\n" + "  node0 [label=\"SCRIPT\"];\n" + "  node1 [label=\"TRY\"];\n" + "  node0 -> node1 [weight=1];\n" + "  node2 [label=\"BLOCK\"];\n" + "  node1 -> node2 [weight=1];\n" + "  node3 [label=\"THROW\"];\n" + "  node2 -> node3 [weight=1];\n" + "  node4 [label=\"NAME\"];\n" + "  node3 -> node4 [weight=1];\n" + "  node5 [label=\"BLOCK\"];\n" + "  node3 -> node5 [label=\"ON_EX\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node6 [label=\"EXPR_RESULT\"];\n" + "  node2 -> node6 [weight=1];\n" + "  node7 [label=\"CALL\"];\n" + "  node6 -> node7 [weight=1];\n" + "  node8 [label=\"NAME\"];\n" + "  node7 -> node8 [weight=1];\n" + "  node9 [label=\"EXPR_RESULT\"];\n" + "  node6 -> node5 [label=\"ON_EX\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node6 -> node9 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node2 -> node9 [weight=1];\n" + "  node10 [label=\"GETELEM\"];\n" + "  node9 -> node10 [weight=1];\n" + "  node11 [label=\"NAME\"];\n" + "  node10 -> node11 [weight=1];\n" + "  node12 [label=\"STRING\"];\n" + "  node10 -> node12 [weight=1];\n" + "  node13 [label=\"EXPR_RESULT\"];\n" + "  node9 -> node13 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node9 -> node5 [label=\"ON_EX\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node2 -> node13 [weight=1];\n" + "  node14 [label=\"GETPROP\"];\n" + "  node13 -> node14 [weight=1];\n" + "  node15 [label=\"NAME\"];\n" + "  node14 -> node15 [weight=1];\n" + "  node16 [label=\"STRING\"];\n" + "  node14 -> node16 [weight=1];\n" + "  node17 [label=\"EXPR_RESULT\"];\n" + "  node13 -> node17 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node13 -> node5 [label=\"ON_EX\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node2 -> node17 [weight=1];\n" + "  node18 [label=\"NAME\"];\n" + "  node17 -> node18 [weight=1];\n" + "  node17 -> RETURN [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node2 -> node3 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node1 -> node5 [weight=1];\n" + "  node19 [label=\"CATCH\"];\n" + "  node5 -> node19 [weight=1];\n" + "  node20 [label=\"NAME\"];\n" + "  node19 -> node20 [weight=1];\n" + "  node21 [label=\"BLOCK\"];\n" + "  node19 -> node21 [weight=1];\n" + "  node22 [label=\"EXPR_RESULT\"];\n" + "  node21 -> node22 [weight=1];\n" + "  node23 [label=\"CALL\"];\n" + "  node22 -> node23 [weight=1];\n" + "  node24 [label=\"NAME\"];\n" + "  node23 -> node24 [weight=1];\n" + "  node22 -> RETURN [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node21 -> node22 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node19 -> node21 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node5 -> node19 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node1 -> node2 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node0 -> node1 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "}\n"; [EOL]     testCfg(src, expected); [EOL] } <line_num>: 790,875
public void testFunctionWithinTry() { [EOL]     String src = "try { function f() {throw 1;} } catch (e) { }"; [EOL]     String expected = "digraph AST {\n" + "  node [color=lightblue2, style=filled];\n" + "  node0 [label=\"SCRIPT\"];\n" + "  node1 [label=\"TRY\"];\n" + "  node0 -> node1 [weight=1];\n" + "  node2 [label=\"BLOCK\"];\n" + "  node1 -> node2 [weight=1];\n" + "  node3 [label=\"FUNCTION\"];\n" + "  node2 -> node3 [weight=1];\n" + "  node4 [label=\"NAME\"];\n" + "  node3 -> node4 [weight=1];\n" + "  node5 [label=\"PARAM_LIST\"];\n" + "  node3 -> node5 [weight=1];\n" + "  node6 [label=\"BLOCK\"];\n" + "  node3 -> node6 [weight=1];\n" + "  node7 [label=\"THROW\"];\n" + "  node6 -> node7 [weight=1];\n" + "  node8 [label=\"NUMBER\"];\n" + "  node7 -> node8 [weight=1];\n" + "  node6 -> node7 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node3 -> node6 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node2 -> RETURN [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node9 [label=\"BLOCK\"];\n" + "  node1 -> node9 [weight=1];\n" + "  node10 [label=\"CATCH\"];\n" + "  node9 -> node10 [weight=1];\n" + "  node11 [label=\"NAME\"];\n" + "  node10 -> node11 [weight=1];\n" + "  node12 [label=\"BLOCK\"];\n" + "  node10 -> node12 [weight=1];\n" + "  node12 -> RETURN [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node10 -> node12 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node9 -> node10 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node1 -> node2 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node0 -> node1 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "}\n"; [EOL]     testCfg(src, expected); [EOL] } <line_num>: 877,925
public void testNestedCatch() { [EOL]     String src = "try{try{throw 1;}catch(e){throw 2}}catch(f){}"; [EOL]     String expected = "digraph AST {\n" + "  node [color=lightblue2, style=filled];\n" + "  node0 [label=\"SCRIPT\"];\n" + "  node1 [label=\"TRY\"];\n" + "  node0 -> node1 [weight=1];\n" + "  node2 [label=\"BLOCK\"];\n" + "  node1 -> node2 [weight=1];\n" + "  node3 [label=\"TRY\"];\n" + "  node2 -> node3 [weight=1];\n" + "  node4 [label=\"BLOCK\"];\n" + "  node3 -> node4 [weight=1];\n" + "  node5 [label=\"THROW\"];\n" + "  node4 -> node5 [weight=1];\n" + "  node6 [label=\"NUMBER\"];\n" + "  node5 -> node6 [weight=1];\n" + "  node7 [label=\"BLOCK\"];\n" + "  node5 -> node7 [label=\"ON_EX\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node4 -> node5 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node3 -> node7 [weight=1];\n" + "  node8 [label=\"CATCH\"];\n" + "  node7 -> node8 [weight=1];\n" + "  node9 [label=\"NAME\"];\n" + "  node8 -> node9 [weight=1];\n" + "  node10 [label=\"BLOCK\"];\n" + "  node8 -> node10 [weight=1];\n" + "  node11 [label=\"THROW\"];\n" + "  node10 -> node11 [weight=1];\n" + "  node12 [label=\"NUMBER\"];\n" + "  node11 -> node12 [weight=1];\n" + "  node13 [label=\"BLOCK\"];\n" + "  node11 -> node13 [label=\"ON_EX\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node10 -> node11 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node8 -> node10 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node7 -> node8 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node3 -> node4 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node2 -> node3 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node1 -> node13 [weight=1];\n" + "  node14 [label=\"CATCH\"];\n" + "  node13 -> node14 [weight=1];\n" + "  node15 [label=\"NAME\"];\n" + "  node14 -> node15 [weight=1];\n" + "  node16 [label=\"BLOCK\"];\n" + "  node14 -> node16 [weight=1];\n" + "  node16 -> RETURN [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node14 -> node16 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node13 -> node14 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node1 -> node2 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node0 -> node1 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "}\n"; [EOL]     testCfg(src, expected); [EOL] } <line_num>: 927,993
public void testSimpleFinally() { [EOL]     String src = "try{var x; foo()}finally{}"; [EOL]     ControlFlowGraph<Node> cfg = createCfg(src); [EOL]     assertDownEdge(cfg, Token.TRY, Token.BLOCK, Branch.UNCOND); [EOL]     assertDownEdge(cfg, Token.BLOCK, Token.VAR, Branch.UNCOND); [EOL]     assertCrossEdge(cfg, Token.EXPR_RESULT, Token.BLOCK, Branch.UNCOND); [EOL]     assertNoEdge(cfg, Token.BLOCK, Token.BLOCK); [EOL] } <line_num>: 995,1004
public void testSimpleCatchFinally() { [EOL]     String src = "try{ if(a){throw 1}else{a} } catch(e){a}finally{a}"; [EOL]     String expected = "digraph AST {\n" + "  node [color=lightblue2, style=filled];\n" + "  node0 [label=\"SCRIPT\"];\n" + "  node1 [label=\"TRY\"];\n" + "  node0 -> node1 [weight=1];\n" + "  node2 [label=\"BLOCK\"];\n" + "  node1 -> node2 [weight=1];\n" + "  node3 [label=\"IF\"];\n" + "  node2 -> node3 [weight=1];\n" + "  node4 [label=\"NAME\"];\n" + "  node3 -> node4 [weight=1];\n" + "  node5 [label=\"BLOCK\"];\n" + "  node3 -> node5 [weight=1];\n" + "  node6 [label=\"THROW\"];\n" + "  node5 -> node6 [weight=1];\n" + "  node7 [label=\"NUMBER\"];\n" + "  node6 -> node7 [weight=1];\n" + "  node8 [label=\"BLOCK\"];\n" + "  node6 -> node8 [label=\"ON_EX\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node5 -> node6 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node9 [label=\"BLOCK\"];\n" + "  node3 -> node9 [weight=1];\n" + "  node10 [label=\"EXPR_RESULT\"];\n" + "  node9 -> node10 [weight=1];\n" + "  node11 [label=\"NAME\"];\n" + "  node10 -> node11 [weight=1];\n" + "  node12 [label=\"BLOCK\"];\n" + "  node10 -> node12 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node9 -> node10 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node3 -> node5 [label=\"ON_TRUE\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node3 -> node9 [label=\"ON_FALSE\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node2 -> node3 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node1 -> node8 [weight=1];\n" + "  node13 [label=\"CATCH\"];\n" + "  node8 -> node13 [weight=1];\n" + "  node14 [label=\"NAME\"];\n" + "  node13 -> node14 [weight=1];\n" + "  node15 [label=\"BLOCK\"];\n" + "  node13 -> node15 [weight=1];\n" + "  node16 [label=\"EXPR_RESULT\"];\n" + "  node15 -> node16 [weight=1];\n" + "  node17 [label=\"NAME\"];\n" + "  node16 -> node17 [weight=1];\n" + "  node16 -> node12 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node15 -> node16 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node13 -> node15 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node8 -> node13 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node1 -> node12 [weight=1];\n" + "  node18 [label=\"EXPR_RESULT\"];\n" + "  node12 -> node18 [weight=1];\n" + "  node19 [label=\"NAME\"];\n" + "  node18 -> node19 [weight=1];\n" + "  node18 -> RETURN [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node12 -> node18 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node1 -> node2 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node0 -> node1 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "}\n"; [EOL]     testCfg(src, expected); [EOL] } <line_num>: 1006,1082
public void testComplicatedFinally2() { [EOL]     String src = "while(1){try{" + "if(a){a;continue;}else if(b){b;break;} else if(c) throw 1; else a}" + "catch(e){}finally{c()}bar}foo"; [EOL]     ControlFlowGraph<Node> cfg = createCfg(src); [EOL]     assertCrossEdge(cfg, Token.CONTINUE, Token.BLOCK, Branch.UNCOND); [EOL]     assertCrossEdge(cfg, Token.BREAK, Token.BLOCK, Branch.UNCOND); [EOL]     assertCrossEdge(cfg, Token.THROW, Token.BLOCK, Branch.ON_EX); [EOL] } <line_num>: 1084,1095
public void testDeepNestedBreakwithFinally() { [EOL]     String src = "X:while(1){try{while(2){try{var a;break X;}" + "finally{}}}finally{}}"; [EOL]     ControlFlowGraph<Node> cfg = createCfg(src); [EOL]     assertDownEdge(cfg, Token.WHILE, Token.BLOCK, Branch.ON_TRUE); [EOL]     assertDownEdge(cfg, Token.BLOCK, Token.TRY, Branch.UNCOND); [EOL]     assertDownEdge(cfg, Token.BLOCK, Token.VAR, Branch.UNCOND); [EOL]     assertCrossEdge(cfg, Token.BREAK, Token.BLOCK, Branch.UNCOND); [EOL]     assertCrossEdge(cfg, Token.BLOCK, Token.BLOCK, Branch.ON_EX); [EOL]     assertCrossEdge(cfg, Token.WHILE, Token.BLOCK, Branch.ON_FALSE); [EOL]     assertReturnEdge(cfg, Token.BLOCK); [EOL] } <line_num>: 1097,1110
public void testDeepNestedFinally() { [EOL]     String src = "try{try{try{throw 1}" + "finally{1;var a}}finally{2;if(a);}}finally{3;a()}"; [EOL]     ControlFlowGraph<Node> cfg = createCfg(src); [EOL]     assertCrossEdge(cfg, Token.THROW, Token.BLOCK, Branch.ON_EX); [EOL]     assertCrossEdge(cfg, Token.VAR, Token.BLOCK, Branch.UNCOND); [EOL]     assertCrossEdge(cfg, Token.IF, Token.BLOCK, Branch.ON_EX); [EOL] } <line_num>: 1112,1119
public void testReturn() { [EOL]     String src = "function f() { return; }"; [EOL]     ControlFlowGraph<Node> cfg = createCfg(src); [EOL]     assertReturnEdge(cfg, Token.RETURN); [EOL] } <line_num>: 1121,1125
public void testReturnInFinally() { [EOL]     String src = "function f(x){ try{} finally {return x;} }"; [EOL]     ControlFlowGraph<Node> cfg = createCfg(src); [EOL]     assertReturnEdge(cfg, Token.RETURN); [EOL] } <line_num>: 1127,1131
public void testReturnInFinally2() { [EOL]     String src = "function f(x){" + " try{ try{}finally{var dummy; return x;} } finally {} }"; [EOL]     ControlFlowGraph<Node> cfg = createCfg(src); [EOL]     assertCrossEdge(cfg, Token.VAR, Token.RETURN, Branch.UNCOND); [EOL]     assertCrossEdge(cfg, Token.RETURN, Token.BLOCK, Branch.UNCOND); [EOL]     assertReturnEdge(cfg, Token.BLOCK); [EOL]     assertNoReturnEdge(cfg, Token.RETURN); [EOL] } <line_num>: 1133,1141
public void testReturnInTry() { [EOL]     String src = "function f(x){ try{x; return x()} finally {} var y;}"; [EOL]     ControlFlowGraph<Node> cfg = createCfg(src); [EOL]     assertCrossEdge(cfg, Token.EXPR_RESULT, Token.RETURN, Branch.UNCOND); [EOL]     assertCrossEdge(cfg, Token.RETURN, Token.BLOCK, Branch.UNCOND); [EOL]     assertCrossEdge(cfg, Token.BLOCK, Token.VAR, Branch.UNCOND); [EOL]     assertReturnEdge(cfg, Token.VAR); [EOL]     assertReturnEdge(cfg, Token.BLOCK); [EOL]     assertNoReturnEdge(cfg, Token.RETURN); [EOL] } <line_num>: 1143,1152
public void testOptionNotToTraverseFunctions() { [EOL]     String src = "var x = 1; function f() { x = null; }"; [EOL]     String expectedWhenNotTraversingFunctions = "digraph AST {\n" + "  node [color=lightblue2, style=filled];\n" + "  node0 [label=\"SCRIPT\"];\n" + "  node1 [label=\"VAR\"];\n" + "  node0 -> node1 [weight=1];\n" + "  node2 [label=\"NAME\"];\n" + "  node1 -> node2 [weight=1];\n" + "  node3 [label=\"NUMBER\"];\n" + "  node2 -> node3 [weight=1];\n" + "  node1 -> RETURN " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node4 [label=\"FUNCTION\"];\n" + "  node0 -> node4 [weight=1];\n" + "  node5 [label=\"NAME\"];\n" + "  node4 -> node5 [weight=1];\n" + "  node6 [label=\"PARAM_LIST\"];\n" + "  node4 -> node6 [weight=1];\n" + "  node7 [label=\"BLOCK\"];\n" + "  node4 -> node7 [weight=1];\n" + "  node8 [label=\"EXPR_RESULT\"];\n" + "  node7 -> node8 [weight=1];\n" + "  node9 [label=\"ASSIGN\"];\n" + "  node8 -> node9 [weight=1];\n" + "  node10 [label=\"NAME\"];\n" + "  node9 -> node10 [weight=1];\n" + "  node11 [label=\"NULL\"];\n" + "  node9 -> node11 [weight=1];\n" + "  node0 -> node1 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "}\n"; [EOL]     String expected = "digraph AST {\n" + "  node [color=lightblue2, style=filled];\n" + "  node0 [label=\"SCRIPT\"];\n" + "  node1 [label=\"VAR\"];\n" + "  node0 -> node1 [weight=1];\n" + "  node2 [label=\"NAME\"];\n" + "  node1 -> node2 [weight=1];\n" + "  node3 [label=\"NUMBER\"];\n" + "  node2 -> node3 [weight=1];\n" + "  node1 -> RETURN " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node4 [label=\"FUNCTION\"];\n" + "  node0 -> node4 [weight=1];\n" + "  node5 [label=\"NAME\"];\n" + "  node4 -> node5 [weight=1];\n" + "  node6 [label=\"PARAM_LIST\"];\n" + "  node4 -> node6 [weight=1];\n" + "  node7 [label=\"BLOCK\"];\n" + "  node4 -> node7 [weight=1];\n" + "  node8 [label=\"EXPR_RESULT\"];\n" + "  node7 -> node8 [weight=1];\n" + "  node9 [label=\"ASSIGN\"];\n" + "  node8 -> node9 [weight=1];\n" + "  node10 [label=\"NAME\"];\n" + "  node9 -> node10 [weight=1];\n" + "  node11 [label=\"NULL\"];\n" + "  node9 -> node11 [weight=1];\n" + "  node8 -> RETURN " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node7 -> node8 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node4 -> node7 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node0 -> node1 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "}\n"; [EOL]     testCfg(src, expected); [EOL]     testCfg(src, expectedWhenNotTraversingFunctions, false); [EOL] } <line_num>: 1154,1224
public void testInstanceOf() { [EOL]     String src = "try { x instanceof 'x' } catch (e) { }"; [EOL]     ControlFlowGraph<Node> cfg = createCfg(src, true); [EOL]     assertCrossEdge(cfg, Token.EXPR_RESULT, Token.BLOCK, Branch.ON_EX); [EOL] } <line_num>: 1226,1230
public void testSynBlock() { [EOL]     String src = "START(); var x; END(); var y;"; [EOL]     ControlFlowGraph<Node> cfg = createCfg(src, true); [EOL]     assertCrossEdge(cfg, Token.BLOCK, Token.EXPR_RESULT, Branch.SYN_BLOCK); [EOL] } <line_num>: 1232,1236
public void testPartialTraversalOfScope() { [EOL]     Compiler compiler = new Compiler(); [EOL]     ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, true, true); [EOL]     Node script1 = compiler.parseSyntheticCode("cfgtest", "var foo;"); [EOL]     Node script2 = compiler.parseSyntheticCode("cfgtest2", "var bar;"); [EOL]     Node root = new Node(Token.BLOCK, script1, script2); [EOL]     cfa.process(null, script1); [EOL]     ControlFlowGraph<Node> cfg = cfa.getCfg(); [EOL]     assertNotNull(cfg.getNode(script1)); [EOL]     assertNull(cfg.getNode(script2)); [EOL] } <line_num>: 1238,1251
public void testForLoopOrder() { [EOL]     assertNodeOrder(createCfg("for (var i = 0; i < 5; i++) { var x = 3; } if (true) {}"), Lists.newArrayList(Token.SCRIPT, Token.VAR, Token.FOR, Token.BLOCK, Token.VAR, Token.INC, Token.IF, Token.BLOCK)); [EOL] } <line_num>: 1253,1260
public void testLabelledForInLoopOrder() { [EOL]     assertNodeOrder(createCfg("var i = 0; var y = {}; " + "label: for (var x in y) { " + "    if (x) { break label; } else { i++ } x(); }"), Lists.newArrayList(Token.SCRIPT, Token.VAR, Token.VAR, Token.NAME, Token.FOR, Token.BLOCK, Token.IF, Token.BLOCK, Token.BREAK, Token.BLOCK, Token.EXPR_RESULT, Token.EXPR_RESULT)); [EOL] } <line_num>: 1262,1272
public void testLocalFunctionOrder() { [EOL]     ControlFlowGraph<Node> cfg = createCfg("function f() { while (x) { x++; } } var x = 3;"); [EOL]     assertNodeOrder(cfg, Lists.newArrayList(Token.SCRIPT, Token.VAR, Token.FUNCTION, Token.BLOCK, Token.WHILE, Token.BLOCK, Token.EXPR_RESULT)); [EOL] } <line_num>: 1274,1284
public void testDoWhileOrder() { [EOL]     assertNodeOrder(createCfg("do { var x = 3; } while (true); void x;"), Lists.newArrayList(Token.SCRIPT, Token.BLOCK, Token.VAR, Token.DO, Token.EXPR_RESULT)); [EOL] } <line_num>: 1286,1291
public void testBreakInFinally1() { [EOL]     String src = "f = function() {\n" + "  var action;\n" + "  a: {\n" + "    var proto = null;\n" + "    try {\n" + "      proto = new Proto\n" + "    } finally {\n" + "      action = proto;\n" + "      break a\n" + "    }\n" + "  }\n" + "  alert(action)\n" + "};"; [EOL]     String expected = "digraph AST {\n" + "  node [color=lightblue2, style=filled];\n" + "  node0 [label=\"SCRIPT\"];\n" + "  node1 [label=\"EXPR_RESULT\"];\n" + "  node0 -> node1 [weight=1];\n" + "  node2 [label=\"ASSIGN\"];\n" + "  node1 -> node2 [weight=1];\n" + "  node3 [label=\"NAME\"];\n" + "  node2 -> node3 [weight=1];\n" + "  node4 [label=\"FUNCTION\"];\n" + "  node2 -> node4 [weight=1];\n" + "  node5 [label=\"NAME\"];\n" + "  node4 -> node5 [weight=1];\n" + "  node6 [label=\"PARAM_LIST\"];\n" + "  node4 -> node6 [weight=1];\n" + "  node7 [label=\"BLOCK\"];\n" + "  node4 -> node7 [weight=1];\n" + "  node8 [label=\"VAR\"];\n" + "  node7 -> node8 [weight=1];\n" + "  node9 [label=\"NAME\"];\n" + "  node8 -> node9 [weight=1];\n" + "  node10 [label=\"LABEL\"];\n" + "  node7 -> node10 [weight=1];\n" + "  node11 [label=\"LABEL_NAME\"];\n" + "  node10 -> node11 [weight=1];\n" + "  node12 [label=\"BLOCK\"];\n" + "  node10 -> node12 [weight=1];\n" + "  node13 [label=\"VAR\"];\n" + "  node12 -> node13 [weight=1];\n" + "  node14 [label=\"NAME\"];\n" + "  node13 -> node14 [weight=1];\n" + "  node15 [label=\"NULL\"];\n" + "  node14 -> node15 [weight=1];\n" + "  node16 [label=\"TRY\"];\n" + "  node12 -> node16 [weight=1];\n" + "  node17 [label=\"BLOCK\"];\n" + "  node16 -> node17 [weight=1];\n" + "  node18 [label=\"EXPR_RESULT\"];\n" + "  node17 -> node18 [weight=1];\n" + "  node19 [label=\"ASSIGN\"];\n" + "  node18 -> node19 [weight=1];\n" + "  node20 [label=\"NAME\"];\n" + "  node19 -> node20 [weight=1];\n" + "  node21 [label=\"NEW\"];\n" + "  node19 -> node21 [weight=1];\n" + "  node22 [label=\"NAME\"];\n" + "  node21 -> node22 [weight=1];\n" + "  node23 [label=\"BLOCK\"];\n" + "  node16 -> node23 [weight=1];\n" + "  node24 [label=\"BLOCK\"];\n" + "  node16 -> node24 [weight=1];\n" + "  node25 [label=\"EXPR_RESULT\"];\n" + "  node24 -> node25 [weight=1];\n" + "  node26 [label=\"ASSIGN\"];\n" + "  node25 -> node26 [weight=1];\n" + "  node27 [label=\"NAME\"];\n" + "  node26 -> node27 [weight=1];\n" + "  node28 [label=\"NAME\"];\n" + "  node26 -> node28 [weight=1];\n" + "  node29 [label=\"BREAK\"];\n" + "  node24 -> node29 [weight=1];\n" + "  node30 [label=\"LABEL_NAME\"];\n" + "  node29 -> node30 [weight=1];\n" + "  node31 [label=\"EXPR_RESULT\"];\n" + "  node7 -> node31 [weight=1];\n" + "  node32 [label=\"CALL\"];\n" + "  node31 -> node32 [weight=1];\n" + "  node33 [label=\"NAME\"];\n" + "  node32 -> node33 [weight=1];\n" + "  node34 [label=\"NAME\"];\n" + "  node32 -> node34 [weight=1];\n" + "  node1 -> RETURN [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "  node0 -> node1 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "}\n"; [EOL]     testCfg(src, expected); [EOL] } <line_num>: 1293,1386
public void testBreakInFinally2() { [EOL]     String src = "var action;\n" + "a: {\n" + "  var proto = null;\n" + "  try {\n" + "    proto = new Proto\n" + "  } finally {\n" + "    action = proto;\n" + "    break a\n" + "  }\n" + "}\n" + "alert(action)\n"; [EOL]     ControlFlowGraph<Node> cfg = createCfg(src); [EOL]     assertCrossEdge(cfg, Token.BREAK, Token.EXPR_RESULT, Branch.UNCOND); [EOL]     assertNoEdge(cfg, Token.BREAK, Token.BLOCK); [EOL] } <line_num>: 1388,1405
private void assertNodeOrder(ControlFlowGraph<Node> cfg, List<Integer> nodeTypes) { [EOL]     List<DiGraphNode<Node, Branch>> cfgNodes = Lists.newArrayList(cfg.getDirectedGraphNodes()); [EOL]     Collections.sort(cfgNodes, cfg.getOptionalNodeComparator(true)); [EOL]     Node implicitReturn = cfgNodes.remove(cfgNodes.size() - 1).getValue(); [EOL]     assertNull(implicitReturn == null ? "null" : implicitReturn.toStringTree(), implicitReturn); [EOL]     assertEquals("Wrong number of CFG nodes", nodeTypes.size(), cfgNodes.size()); [EOL]     for (int i = 0; i < cfgNodes.size(); i++) { [EOL]         int expectedType = nodeTypes.get(i); [EOL]         int actualType = cfgNodes.get(i).getValue().getType(); [EOL]         assertEquals("node type mismatch at " + i + ".\n" + "found   : " + Token.name(actualType) + "\n" + "required: " + Token.name(expectedType) + "\n", expectedType, actualType); [EOL]     } [EOL] } <line_num>: 1418,1440
