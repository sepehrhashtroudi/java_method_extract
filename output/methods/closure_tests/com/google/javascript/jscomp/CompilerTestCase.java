protected CompilerTestCase(String externs, boolean compareAsTree) { [EOL]     this.externsInputs = ImmutableList.of(SourceFile.fromCode("externs", externs)); [EOL]     this.compareAsTree = compareAsTree; [EOL]     this.parseTypeInfo = false; [EOL] } <line_num>: 126,131
protected CompilerTestCase(String externs) { [EOL]     this(externs, true); [EOL] } <line_num>: 137,139
protected CompilerTestCase() { [EOL]     this("", true); [EOL] } <line_num>: 144,146
private BlackHoleErrorManager(Compiler compiler) { [EOL]     compiler.setErrorManager(this); [EOL] } <line_num>: 1060,1062
protected abstract CompilerPass getProcessor(Compiler compiler); <line_num>: 154,154
protected CompilerOptions getOptions() { [EOL]     return getOptions(new CompilerOptions()); [EOL] } <line_num>: 161,163
protected CompilerOptions getOptions(CompilerOptions options) { [EOL]     if (this.acceptES5) { [EOL]         options.setLanguageIn(LanguageMode.ECMASCRIPT5); [EOL]     } [EOL]     options.checkSymbols = true; [EOL]     options.setWarningLevel(DiagnosticGroups.MISSING_PROPERTIES, CheckLevel.WARNING); [EOL]     options.setWarningLevel(DiagnosticGroups.CAST, CheckLevel.WARNING); [EOL]     options.setCodingConvention(getCodingConvention()); [EOL]     return options; [EOL] } <line_num>: 169,184
protected CodingConvention getCodingConvention() { [EOL]     return new GoogleCodingConvention(); [EOL] } <line_num>: 186,188
public void setFilename(String filename) { [EOL]     this.filename = filename; [EOL] } <line_num>: 190,192
protected int getNumRepetitions() { [EOL]     return 2; [EOL] } <line_num>: 198,202
void allowSourcelessWarnings() { [EOL]     allowSourcelessWarnings = true; [EOL] } <line_num>: 205,207
Compiler getLastCompiler() { [EOL]     return lastCompiler; [EOL] } <line_num>: 210,212
protected void enableEcmaScript5(boolean acceptES5) { [EOL]     this.acceptES5 = acceptES5; [EOL] } <line_num>: 217,219
protected void allowExternsChanges(boolean allowExternsChanges) { [EOL]     this.allowExternsChanges = allowExternsChanges; [EOL] } <line_num>: 224,226
public void enableTypeCheck(CheckLevel level) { [EOL]     typeCheckEnabled = true; [EOL]     typeCheckLevel = level; [EOL] } <line_num>: 236,239
public void enableLineNumberCheck(boolean newVal) { [EOL]     checkLineNumbers = newVal; [EOL] } <line_num>: 244,246
void disableTypeCheck() { [EOL]     typeCheckEnabled = false; [EOL] } <line_num>: 253,255
void enableClosurePass() { [EOL]     closurePassEnabled = true; [EOL] } <line_num>: 261,263
protected void enableNormalize() { [EOL]     enableNormalize(true); [EOL] } <line_num>: 271,273
protected void enableNormalize(boolean normalizeExpected) { [EOL]     normalizeEnabled = true; [EOL]     this.normalizeExpected = normalizeExpected; [EOL] } <line_num>: 283,286
protected void disableNormalize() { [EOL]     normalizeEnabled = false; [EOL] } <line_num>: 292,294
void enableMarkNoSideEffects() { [EOL]     markNoSideEffects = true; [EOL] } <line_num>: 301,303
protected void enableAstValidation(boolean validate) { [EOL]     astValidationEnabled = validate; [EOL] } <line_num>: 308,310
private static TypeCheck createTypeCheck(Compiler compiler, CheckLevel level) { [EOL]     ReverseAbstractInterpreter rai = new SemanticReverseAbstractInterpreter(compiler.getCodingConvention(), compiler.getTypeRegistry()); [EOL]     return new TypeCheck(compiler, rai, compiler.getTypeRegistry(), level, CheckLevel.OFF); [EOL] } <line_num>: 313,321
public void test(String js, String expected) { [EOL]     test(js, expected, (DiagnosticType) null); [EOL] } <line_num>: 329,331
public void test(String js, String expected, DiagnosticType error) { [EOL]     test(js, expected, error, null); [EOL] } <line_num>: 341,343
public void test(String js, String expected, DiagnosticType error, DiagnosticType warning, String description) { [EOL]     test(externsInputs, js, expected, error, warning, description); [EOL] } <line_num>: 356,359
public void test(String js, String expected, DiagnosticType error, DiagnosticType warning) { [EOL]     test(externsInputs, js, expected, error, warning, null); [EOL] } <line_num>: 371,374
public void test(String externs, String js, String expected, DiagnosticType error, DiagnosticType warning) { [EOL]     test(externs, js, expected, error, warning, null); [EOL] } <line_num>: 387,390
public void test(String externs, String js, String expected, DiagnosticType error, DiagnosticType warning, String description) { [EOL]     List<SourceFile> externsInputs = ImmutableList.of(SourceFile.fromCode("externs", externs)); [EOL]     test(externsInputs, js, expected, error, warning, description); [EOL] } <line_num>: 406,412
public void test(List<SourceFile> externs, String js, String expected, DiagnosticType error, DiagnosticType warning, String description) { [EOL]     Compiler compiler = createCompiler(); [EOL]     lastCompiler = compiler; [EOL]     CompilerOptions options = getOptions(); [EOL]     if (this.acceptES5) { [EOL]         options.setLanguageIn(LanguageMode.ECMASCRIPT5); [EOL]     } [EOL]     options.checkTypes = parseTypeInfo; [EOL]     compiler.init(externs, ImmutableList.of(SourceFile.fromCode(filename, js)), options); [EOL]     BaseJSTypeTestCase.addNativeProperties(compiler.getTypeRegistry()); [EOL]     test(compiler, maybeCreateArray(expected), error, warning, description); [EOL] } <line_num>: 428,448
private String[] maybeCreateArray(String expected) { [EOL]     if (expected != null) { [EOL]         return new String[] { expected }; [EOL]     } [EOL]     return null; [EOL] } <line_num>: 450,455
public void test(String[] js, String[] expected) { [EOL]     test(js, expected, null); [EOL] } <line_num>: 463,465
public void test(String[] js, String[] expected, DiagnosticType error) { [EOL]     test(js, expected, error, null); [EOL] } <line_num>: 475,477
public void test(String[] js, String[] expected, DiagnosticType error, DiagnosticType warning) { [EOL]     test(js, expected, error, warning, null); [EOL] } <line_num>: 489,492
public void test(String[] js, String[] expected, DiagnosticType error, DiagnosticType warning, String description) { [EOL]     Compiler compiler = createCompiler(); [EOL]     lastCompiler = compiler; [EOL]     List<SourceFile> inputs = Lists.newArrayList(); [EOL]     for (int i = 0; i < js.length; i++) { [EOL]         inputs.add(SourceFile.fromCode("input" + i, js[i])); [EOL]     } [EOL]     compiler.init(externsInputs, inputs, getOptions()); [EOL]     test(compiler, expected, error, warning, description); [EOL] } <line_num>: 507,518
public void test(JSModule[] modules, String[] expected) { [EOL]     test(modules, expected, null); [EOL] } <line_num>: 526,528
public void test(JSModule[] modules, String[] expected, DiagnosticType error) { [EOL]     test(modules, expected, error, null); [EOL] } <line_num>: 538,541
public void test(JSModule[] modules, String[] expected, DiagnosticType error, DiagnosticType warning) { [EOL]     Compiler compiler = createCompiler(); [EOL]     lastCompiler = compiler; [EOL]     compiler.initModules(externsInputs, Lists.newArrayList(modules), getOptions()); [EOL]     test(compiler, expected, error, warning); [EOL] } <line_num>: 553,561
public void testSame(String js) { [EOL]     test(js, js); [EOL] } <line_num>: 568,570
public void testSame(String js, DiagnosticType warning) { [EOL]     test(js, js, null, warning); [EOL] } <line_num>: 579,581
public void testSame(String js, DiagnosticType diag, boolean error) { [EOL]     if (error) { [EOL]         test(js, js, diag); [EOL]     } else { [EOL]         test(js, js, null, diag); [EOL]     } [EOL] } <line_num>: 591,597
public void testSame(String externs, String js, DiagnosticType warning) { [EOL]     testSame(externs, js, warning, null); [EOL] } <line_num>: 607,609
public void testSame(String externs, String js, DiagnosticType diag, boolean error) { [EOL]     if (error) { [EOL]         test(externs, js, js, diag, null); [EOL]     } else { [EOL]         test(externs, js, js, null, diag); [EOL]     } [EOL] } <line_num>: 620,627
public void testSame(String externs, String js, DiagnosticType warning, String description) { [EOL]     List<SourceFile> externsInputs = ImmutableList.of(SourceFile.fromCode("externs", externs)); [EOL]     test(externsInputs, js, js, null, warning, description); [EOL] } <line_num>: 640,645
public void testSame(String[] js) { [EOL]     test(js, js); [EOL] } <line_num>: 652,654
public void testSame(String[] js, DiagnosticType error) { [EOL]     test(js, js, error); [EOL] } <line_num>: 663,665
public void testSame(String[] js, DiagnosticType error, DiagnosticType warning) { [EOL]     test(js, js, error, warning); [EOL] } <line_num>: 675,678
public void testSame(JSModule[] modules) { [EOL]     testSame(modules, null); [EOL] } <line_num>: 685,687
public void testSame(JSModule[] modules, DiagnosticType warning) { [EOL]     try { [EOL]         String[] expected = new String[modules.length]; [EOL]         for (int i = 0; i < modules.length; i++) { [EOL]             expected[i] = ""; [EOL]             for (CompilerInput input : modules[i].getInputs()) { [EOL]                 expected[i] += input.getSourceFile().getCode(); [EOL]             } [EOL]         } [EOL]         test(modules, expected, null, warning); [EOL]     } catch (IOException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL] } <line_num>: 695,708
protected void test(Compiler compiler, String[] expected, DiagnosticType error, DiagnosticType warning) { [EOL]     test(compiler, expected, error, warning, null); [EOL] } <line_num>: 721,724
private void test(Compiler compiler, String[] expected, DiagnosticType error, DiagnosticType warning, String description) { [EOL]     RecentChange recentChange = new RecentChange(); [EOL]     compiler.addChangeHandler(recentChange); [EOL]     Node root = compiler.parseInputs(); [EOL]     assertTrue("Unexpected parse error(s): " + Joiner.on("\n").join(compiler.getErrors()), root != null); [EOL]     if (astValidationEnabled) { [EOL]         (new AstValidator()).validateRoot(root); [EOL]     } [EOL]     Node externsRoot = root.getFirstChild(); [EOL]     Node mainRoot = root.getLastChild(); [EOL]     Node rootClone = root.cloneTree(); [EOL]     Node externsRootClone = rootClone.getFirstChild(); [EOL]     Node mainRootClone = rootClone.getLastChild(); [EOL]     int numRepetitions = getNumRepetitions(); [EOL]     ErrorManager[] errorManagers = new ErrorManager[numRepetitions]; [EOL]     int aggregateWarningCount = 0; [EOL]     List<JSError> aggregateWarnings = Lists.newArrayList(); [EOL]     boolean hasCodeChanged = false; [EOL]     assertFalse("Code should not change before processing", recentChange.hasCodeChanged()); [EOL]     for (int i = 0; i < numRepetitions; ++i) { [EOL]         if (compiler.getErrorCount() == 0) { [EOL]             errorManagers[i] = new BlackHoleErrorManager(compiler); [EOL]             if (closurePassEnabled && i == 0) { [EOL]                 recentChange.reset(); [EOL]                 new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR).process(null, mainRoot); [EOL]                 hasCodeChanged = hasCodeChanged || recentChange.hasCodeChanged(); [EOL]             } [EOL]             if (typeCheckEnabled && i == 0) { [EOL]                 TypeCheck check = createTypeCheck(compiler, typeCheckLevel); [EOL]                 check.processForTesting(externsRoot, mainRoot); [EOL]             } [EOL]             if (normalizeEnabled && i == 0) { [EOL]                 normalizeActualCode(compiler, externsRoot, mainRoot); [EOL]             } [EOL]             if (markNoSideEffects && i == 0) { [EOL]                 MarkNoSideEffectCalls mark = new MarkNoSideEffectCalls(compiler); [EOL]                 mark.process(externsRoot, mainRoot); [EOL]             } [EOL]             recentChange.reset(); [EOL]             getProcessor(compiler).process(externsRoot, mainRoot); [EOL]             if (astValidationEnabled) { [EOL]                 (new AstValidator()).validateRoot(root); [EOL]             } [EOL]             if (checkLineNumbers) { [EOL]                 (new LineNumberCheck(compiler)).process(externsRoot, mainRoot); [EOL]             } [EOL]             hasCodeChanged = hasCodeChanged || recentChange.hasCodeChanged(); [EOL]             aggregateWarningCount += errorManagers[i].getWarningCount(); [EOL]             aggregateWarnings.addAll(Lists.newArrayList(compiler.getWarnings())); [EOL]             if (normalizeEnabled) { [EOL]                 boolean verifyDeclaredConstants = true; [EOL]                 new Normalize.VerifyConstants(compiler, verifyDeclaredConstants).process(externsRoot, mainRoot); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (error == null) { [EOL]         assertEquals("Unexpected error(s): " + Joiner.on("\n").join(compiler.getErrors()), 0, compiler.getErrorCount()); [EOL]         ErrorManager symbolTableErrorManager = new BlackHoleErrorManager(compiler); [EOL]         Node expectedRoot = null; [EOL]         if (expected != null) { [EOL]             expectedRoot = parseExpectedJs(expected); [EOL]             expectedRoot.detachFromParent(); [EOL]         } [EOL]         JSError[] stErrors = symbolTableErrorManager.getErrors(); [EOL]         if (expectedSymbolTableError != null) { [EOL]             assertEquals("There should be one error.", 1, stErrors.length); [EOL]             assertEquals(expectedSymbolTableError, stErrors[0].getType()); [EOL]         } else { [EOL]             assertEquals("Unexpected symbol table error(s): " + Joiner.on("\n").join(stErrors), 0, stErrors.length); [EOL]         } [EOL]         if (warning == null) { [EOL]             assertEquals("Unexpected warning(s): " + Joiner.on("\n").join(aggregateWarnings), 0, aggregateWarningCount); [EOL]         } else { [EOL]             assertEquals("There should be one warning, repeated " + numRepetitions + " time(s).", numRepetitions, aggregateWarningCount); [EOL]             for (int i = 0; i < numRepetitions; ++i) { [EOL]                 JSError[] warnings = errorManagers[i].getWarnings(); [EOL]                 JSError actual = warnings[0]; [EOL]                 assertEquals(warning, actual.getType()); [EOL]                 if (!allowSourcelessWarnings) { [EOL]                     assertTrue("Missing source file name in warning", actual.sourceName != null && !actual.sourceName.isEmpty()); [EOL]                     assertTrue("Missing line number in warning", -1 != actual.lineNumber); [EOL]                     assertTrue("Missing char number in warning", -1 != actual.getCharno()); [EOL]                 } [EOL]                 if (description != null) { [EOL]                     assertEquals(description, actual.description); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (normalizeEnabled) { [EOL]             normalizeActualCode(compiler, externsRootClone, mainRootClone); [EOL]         } [EOL]         boolean codeChange = !mainRootClone.isEquivalentTo(mainRoot); [EOL]         boolean externsChange = !externsRootClone.isEquivalentTo(externsRoot); [EOL]         if (externsChange && !allowExternsChanges) { [EOL]             String explanation = externsRootClone.checkTreeEquals(externsRoot); [EOL]             fail("Unexpected changes to externs" + "\nExpected: " + compiler.toSource(externsRootClone) + "\nResult: " + compiler.toSource(externsRoot) + "\n" + explanation); [EOL]         } [EOL]         if (!codeChange && !externsChange) { [EOL]             assertFalse("compiler.reportCodeChange() was called " + "even though nothing changed", hasCodeChanged); [EOL]         } else { [EOL]             assertTrue("compiler.reportCodeChange() should have been called", hasCodeChanged); [EOL]         } [EOL]         if (expected != null) { [EOL]             if (compareAsTree) { [EOL]                 String explanation = expectedRoot.checkTreeEquals(mainRoot); [EOL]                 assertNull("\nExpected: " + compiler.toSource(expectedRoot) + "\nResult: " + compiler.toSource(mainRoot) + "\n" + explanation, explanation); [EOL]             } else if (expected != null) { [EOL]                 assertEquals(Joiner.on("").join(expected), compiler.toSource(mainRoot)); [EOL]             } [EOL]         } [EOL]         Node normalizeCheckRootClone = root.cloneTree(); [EOL]         Node normalizeCheckExternsRootClone = root.getFirstChild(); [EOL]         Node normalizeCheckMainRootClone = root.getLastChild(); [EOL]         new PrepareAst(compiler).process(normalizeCheckExternsRootClone, normalizeCheckMainRootClone); [EOL]         String explanation = normalizeCheckMainRootClone.checkTreeEquals(mainRoot); [EOL]         assertNull("Node structure normalization invalidated.\nExpected: " + compiler.toSource(normalizeCheckMainRootClone) + "\nResult: " + compiler.toSource(mainRoot) + "\n" + explanation, explanation); [EOL]         if (normalizeEnabled) { [EOL]             new Normalize(compiler, true).process(normalizeCheckExternsRootClone, normalizeCheckMainRootClone); [EOL]             explanation = normalizeCheckMainRootClone.checkTreeEquals(mainRoot); [EOL]             assertNull("Normalization invalidated.\nExpected: " + compiler.toSource(normalizeCheckMainRootClone) + "\nResult: " + compiler.toSource(mainRoot) + "\n" + explanation, explanation); [EOL]         } [EOL]     } else { [EOL]         String errors = ""; [EOL]         for (JSError actualError : compiler.getErrors()) { [EOL]             errors += actualError.description + "\n"; [EOL]         } [EOL]         assertEquals("There should be one error. " + errors, 1, compiler.getErrorCount()); [EOL]         assertEquals(errors, error, compiler.getErrors()[0].getType()); [EOL]         if (warning != null) { [EOL]             String warnings = ""; [EOL]             for (JSError actualError : compiler.getWarnings()) { [EOL]                 warnings += actualError.description + "\n"; [EOL]             } [EOL]             assertEquals("There should be one warning. " + warnings, 1, compiler.getWarningCount()); [EOL]             assertEquals(warnings, warning, compiler.getWarnings()[0].getType()); [EOL]         } [EOL]     } [EOL] } <line_num>: 741,960
private void normalizeActualCode(Compiler compiler, Node externsRoot, Node mainRoot) { [EOL]     Normalize normalize = new Normalize(compiler, false); [EOL]     normalize.process(externsRoot, mainRoot); [EOL] } <line_num>: 962,966
protected Node parseExpectedJs(String[] expected) { [EOL]     Compiler compiler = createCompiler(); [EOL]     List<SourceFile> inputs = Lists.newArrayList(); [EOL]     for (int i = 0; i < expected.length; i++) { [EOL]         inputs.add(SourceFile.fromCode("expected" + i, expected[i])); [EOL]     } [EOL]     compiler.init(externsInputs, inputs, getOptions()); [EOL]     Node root = compiler.parseInputs(); [EOL]     assertTrue("Unexpected parse error(s): " + Joiner.on("\n").join(compiler.getErrors()), root != null); [EOL]     Node externsRoot = root.getFirstChild(); [EOL]     Node mainRoot = externsRoot.getNext(); [EOL]     if (normalizeEnabled && normalizeExpected && !compiler.hasErrors()) { [EOL]         Normalize normalize = new Normalize(compiler, false); [EOL]         normalize.process(externsRoot, mainRoot); [EOL]     } [EOL]     return mainRoot; [EOL] } <line_num>: 971,989
protected Node parseExpectedJs(String expected) { [EOL]     return parseExpectedJs(new String[] { expected }); [EOL] } <line_num>: 991,993
static JSModule[] createModuleChain(String... inputs) { [EOL]     JSModule[] modules = createModules(inputs); [EOL]     for (int i = 1; i < modules.length; i++) { [EOL]         modules[i].addDependency(modules[i - 1]); [EOL]     } [EOL]     return modules; [EOL] } <line_num>: 999,1005
static JSModule[] createModuleStar(String... inputs) { [EOL]     JSModule[] modules = createModules(inputs); [EOL]     for (int i = 1; i < modules.length; i++) { [EOL]         modules[i].addDependency(modules[0]); [EOL]     } [EOL]     return modules; [EOL] } <line_num>: 1011,1017
static JSModule[] createModuleBush(String... inputs) { [EOL]     Preconditions.checkState(inputs.length > 2); [EOL]     JSModule[] modules = createModules(inputs); [EOL]     for (int i = 1; i < modules.length; i++) { [EOL]         modules[i].addDependency(modules[i == 1 ? 0 : 1]); [EOL]     } [EOL]     return modules; [EOL] } <line_num>: 1024,1031
static JSModule[] createModuleTree(String... inputs) { [EOL]     JSModule[] modules = createModules(inputs); [EOL]     for (int i = 1; i < modules.length; i++) { [EOL]         modules[i].addDependency(modules[(i - 1) / 2]); [EOL]     } [EOL]     return modules; [EOL] } <line_num>: 1038,1044
static JSModule[] createModules(String... inputs) { [EOL]     JSModule[] modules = new JSModule[inputs.length]; [EOL]     for (int i = 0; i < inputs.length; i++) { [EOL]         JSModule module = modules[i] = new JSModule("m" + i); [EOL]         module.add(SourceFile.fromCode("i" + i, inputs[i])); [EOL]     } [EOL]     return modules; [EOL] } <line_num>: 1050,1057
@Override [EOL] public void println(CheckLevel level, JSError error) { [EOL] } <line_num>: 1064,1065
@Override [EOL] public void printSummary() { [EOL] } <line_num>: 1067,1068
Compiler createCompiler() { [EOL]     Compiler compiler = new Compiler(); [EOL]     return compiler; [EOL] } <line_num>: 1071,1074
protected void setExpectedSymbolTableError(DiagnosticType type) { [EOL]     this.expectedSymbolTableError = type; [EOL] } <line_num>: 1076,1078
@Override [EOL] public void visit(Node n) { [EOL]     if (name.equals(n.getQualifiedName())) { [EOL]         matches.add(n); [EOL]     } [EOL] } <line_num>: 1085,1089
protected final Node findQualifiedNameNode(final String name, Node root) { [EOL]     final List<Node> matches = Lists.newArrayList(); [EOL]     NodeUtil.visitPostOrder(root, new NodeUtil.Visitor() { [EOL]  [EOL]         @Override [EOL]         public void visit(Node n) { [EOL]             if (name.equals(n.getQualifiedName())) { [EOL]                 matches.add(n); [EOL]             } [EOL]         } [EOL]     }, Predicates.<Node>alwaysTrue()); [EOL]     return matches.get(0); [EOL] } <line_num>: 1081,1093
