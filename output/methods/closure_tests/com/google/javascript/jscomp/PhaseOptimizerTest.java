@Override [EOL] public void setUp() { [EOL]     passesRun.clear(); [EOL]     compiler = new Compiler(); [EOL]     compiler.initCompilerOptionsIfTesting(); [EOL]     tracker = new PerformanceTracker(new Node(Token.BLOCK), TracerMode.TIMING_ONLY); [EOL]     optimizer = new PhaseOptimizer(compiler, tracker, null); [EOL] } <line_num>: 40,48
public void testOneRun() { [EOL]     addOneTimePass("x"); [EOL]     assertPasses("x"); [EOL] } <line_num>: 50,53
public void testLoop1() { [EOL]     Loop loop = optimizer.addFixedPointLoop(); [EOL]     addLoopedPass(loop, "x", 0); [EOL]     assertPasses("x"); [EOL] } <line_num>: 55,59
public void testLoop2() { [EOL]     Loop loop = optimizer.addFixedPointLoop(); [EOL]     addLoopedPass(loop, "x", 3); [EOL]     assertPasses("x", "x", "x", "x"); [EOL] } <line_num>: 61,65
public void testLoop3() { [EOL]     Loop loop = optimizer.addFixedPointLoop(); [EOL]     addLoopedPass(loop, "x", 3); [EOL]     addLoopedPass(loop, "y", 1); [EOL]     assertPasses("x", "y", "x", "y", "x", "x", "y"); [EOL] } <line_num>: 67,72
public void testNotInfiniteLoop() { [EOL]     Loop loop = optimizer.addFixedPointLoop(); [EOL]     addLoopedPass(loop, "x", PhaseOptimizer.MAX_LOOPS - 1); [EOL]     optimizer.process(null, null); [EOL]     assertEquals("There should be no errors.", 0, compiler.getErrorCount()); [EOL] } <line_num>: 74,79
public void testInfiniteLoop() { [EOL]     Loop loop = optimizer.addFixedPointLoop(); [EOL]     addLoopedPass(loop, "x", PhaseOptimizer.MAX_LOOPS + 1); [EOL]     try { [EOL]         optimizer.process(null, null); [EOL]         fail("Expected RuntimeException"); [EOL]     } catch (RuntimeException e) { [EOL]         assertTrue(e.getMessage().contains(PhaseOptimizer.OPTIMIZE_LOOP_ERROR)); [EOL]     } [EOL] } <line_num>: 81,90
public void testCombined() { [EOL]     addOneTimePass("a"); [EOL]     Loop loop = optimizer.addFixedPointLoop(); [EOL]     addLoopedPass(loop, "x", 3); [EOL]     addLoopedPass(loop, "y", 1); [EOL]     addOneTimePass("z"); [EOL]     assertPasses("a", "x", "y", "x", "y", "x", "x", "y", "z"); [EOL] } <line_num>: 92,99
public void testSanityCheck() { [EOL]     Loop loop = optimizer.addFixedPointLoop(); [EOL]     addLoopedPass(loop, "x", 1); [EOL]     addOneTimePass("z"); [EOL]     optimizer.setSanityCheck(createPassFactory("sanity", createPass("sanity", 0), false)); [EOL]     assertPasses("x", "sanity", "x", "sanity", "z", "sanity"); [EOL] } <line_num>: 101,108
public void testConsumption1() { [EOL]     optimizer.consume(Lists.newArrayList(createPassFactory("a", 0, true), createPassFactory("b", 1, false), createPassFactory("c", 2, false), createPassFactory("d", 1, false), createPassFactory("e", 1, true), createPassFactory("f", 0, true))); [EOL]     assertPasses("a", "b", "c", "d", "b", "c", "d", "c", "b", "d", "e", "f"); [EOL] } <line_num>: 110,120
public void testConsumption2() { [EOL]     optimizer.consume(Lists.newArrayList(createPassFactory("a", 2, false), createPassFactory("b", 1, true), createPassFactory("c", 1, false))); [EOL]     assertPasses("a", "a", "a", "b", "c", "c"); [EOL] } <line_num>: 122,129
public void testConsumption3() { [EOL]     optimizer.consume(Lists.newArrayList(createPassFactory("a", 2, true), createPassFactory("b", 0, false), createPassFactory("c", 0, false))); [EOL]     assertPasses("a", "b", "c"); [EOL] } <line_num>: 131,138
public void testDuplicateLoop() { [EOL]     Loop loop = optimizer.addFixedPointLoop(); [EOL]     addLoopedPass(loop, "x", 1); [EOL]     try { [EOL]         addLoopedPass(loop, "x", 1); [EOL]         fail("Expected exception"); [EOL]     } catch (IllegalArgumentException e) { [EOL]     } [EOL] } <line_num>: 140,147
public void testPassOrdering() { [EOL]     Loop loop = optimizer.addFixedPointLoop(); [EOL]     List<String> optimalOrder = Lists.newArrayList(PhaseOptimizer.OPTIMAL_ORDER); [EOL]     Random random = new Random(); [EOL]     while (optimalOrder.size() > 0) { [EOL]         addLoopedPass(loop, optimalOrder.remove(random.nextInt(optimalOrder.size())), 0); [EOL]     } [EOL]     optimizer.process(null, null); [EOL]     assertEquals(PhaseOptimizer.OPTIMAL_ORDER, passesRun); [EOL] } <line_num>: 149,160
@Override [EOL] void setProgress(double p, String name) { [EOL]     progressList.add(p); [EOL] } <line_num>: 165,167
public void testProgress() { [EOL]     final List<Double> progressList = Lists.newArrayList(); [EOL]     compiler = new Compiler() { [EOL]  [EOL]         @Override [EOL]         void setProgress(double p, String name) { [EOL]             progressList.add(p); [EOL]         } [EOL]     }; [EOL]     compiler.initCompilerOptionsIfTesting(); [EOL]     optimizer = new PhaseOptimizer(compiler, null, new PhaseOptimizer.ProgressRange(0, 100)); [EOL]     addOneTimePass("x1"); [EOL]     addOneTimePass("x2"); [EOL]     addOneTimePass("x3"); [EOL]     addOneTimePass("x4"); [EOL]     optimizer.process(null, null); [EOL]     assertEquals(4, progressList.size()); [EOL]     assertEquals(25, Math.round(progressList.get(0))); [EOL]     assertEquals(50, Math.round(progressList.get(1))); [EOL]     assertEquals(75, Math.round(progressList.get(2))); [EOL]     assertEquals(100, Math.round(progressList.get(3))); [EOL] } <line_num>: 162,182
public void assertPasses(String... names) { [EOL]     optimizer.process(null, null); [EOL]     assertEquals(Lists.newArrayList(names), passesRun); [EOL] } <line_num>: 184,187
private void addOneTimePass(String name) { [EOL]     optimizer.addOneTimePass(createPassFactory(name, 0, true)); [EOL] } <line_num>: 189,192
private void addLoopedPass(Loop loop, String name, int numChanges) { [EOL]     loop.addLoopedPass(createPassFactory(name, numChanges, false)); [EOL] } <line_num>: 194,197
private PassFactory createPassFactory(String name, int numChanges, boolean isOneTime) { [EOL]     return createPassFactory(name, createPass(name, numChanges), isOneTime); [EOL] } <line_num>: 199,202
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return pass; [EOL] } <line_num>: 207,210
private PassFactory createPassFactory(String name, final CompilerPass pass, boolean isOneTime) { [EOL]     return new PassFactory(name, isOneTime) { [EOL]  [EOL]         @Override [EOL]         protected CompilerPass create(AbstractCompiler compiler) { [EOL]             return pass; [EOL]         } [EOL]     }; [EOL] } <line_num>: 204,212
@Override [EOL] public void process(Node externs, Node root) { [EOL]     passesRun.add(name); [EOL]     if (numChangesClosure[0] > 0) { [EOL]         compiler.reportCodeChange(); [EOL]         numChangesClosure[0] = numChangesClosure[0] - 1; [EOL]     } [EOL] } <line_num>: 217,223
private CompilerPass createPass(final String name, int numChanges) { [EOL]     final int[] numChangesClosure = new int[] { numChanges }; [EOL]     return new CompilerPass() { [EOL]  [EOL]         @Override [EOL]         public void process(Node externs, Node root) { [EOL]             passesRun.add(name); [EOL]             if (numChangesClosure[0] > 0) { [EOL]                 compiler.reportCodeChange(); [EOL]                 numChangesClosure[0] = numChangesClosure[0] - 1; [EOL]             } [EOL]         } [EOL]     }; [EOL] } <line_num>: 214,225
