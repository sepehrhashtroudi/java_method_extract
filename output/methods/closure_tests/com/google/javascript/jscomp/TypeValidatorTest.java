public TypeValidatorTest() { [EOL]     enableTypeCheck(CheckLevel.ERROR); [EOL] } <line_num>: 43,45
@Override [EOL] public void process(Node externs, Node n) { [EOL] } <line_num>: 51,54
@Override [EOL] protected CompilerPass getProcessor(final Compiler compiler) { [EOL]     this.compiler = compiler; [EOL]     return new CompilerPass() { [EOL]  [EOL]         @Override [EOL]         public void process(Node externs, Node n) { [EOL]         } [EOL]     }; [EOL] } <line_num>: 47,56
@Override [EOL] public int getNumRepetitions() { [EOL]     return 1; [EOL] } <line_num>: 58,58
public void testBasicMismatch() throws Exception { [EOL]     testSame("/** @param {number} x */ function f(x) {} f('a');", TYPE_MISMATCH_WARNING); [EOL]     assertMismatches(Lists.newArrayList(fromNatives(STRING_TYPE, NUMBER_TYPE))); [EOL] } <line_num>: 60,64
public void testFunctionMismatch() throws Exception { [EOL]     testSame("/** \n" + " * @param {function(string): number} x \n" + " * @return {function(boolean): string} \n" + " */ function f(x) { return x; }", TYPE_MISMATCH_WARNING); [EOL]     JSTypeRegistry registry = compiler.getTypeRegistry(); [EOL]     JSType string = registry.getNativeType(STRING_TYPE); [EOL]     JSType bool = registry.getNativeType(BOOLEAN_TYPE); [EOL]     JSType number = registry.getNativeType(NUMBER_TYPE); [EOL]     JSType firstFunction = registry.createFunctionType(number, string); [EOL]     JSType secondFunction = registry.createFunctionType(string, bool); [EOL]     assertMismatches(Lists.newArrayList(new TypeMismatch(firstFunction, secondFunction, null), fromNatives(STRING_TYPE, BOOLEAN_TYPE), fromNatives(NUMBER_TYPE, STRING_TYPE))); [EOL] } <line_num>: 66,86
public void testFunctionMismatch2() throws Exception { [EOL]     testSame("/** \n" + " * @param {function(string): number} x \n" + " * @return {function(boolean): number} \n" + " */ function f(x) { return x; }", TYPE_MISMATCH_WARNING); [EOL]     JSTypeRegistry registry = compiler.getTypeRegistry(); [EOL]     JSType string = registry.getNativeType(STRING_TYPE); [EOL]     JSType bool = registry.getNativeType(BOOLEAN_TYPE); [EOL]     JSType number = registry.getNativeType(NUMBER_TYPE); [EOL]     JSType firstFunction = registry.createFunctionType(number, string); [EOL]     JSType secondFunction = registry.createFunctionType(number, bool); [EOL]     assertMismatches(Lists.newArrayList(new TypeMismatch(firstFunction, secondFunction, null), fromNatives(STRING_TYPE, BOOLEAN_TYPE))); [EOL] } <line_num>: 88,107
public void testNullUndefined() { [EOL]     testSame("/** @param {string} x */ function f(x) {}\n" + "f(/** @type {string|null|undefined} */ ('a'));", TYPE_MISMATCH_WARNING); [EOL]     assertMismatches(Collections.<TypeMismatch>emptyList()); [EOL] } <line_num>: 109,114
public void testSubclass() { [EOL]     testSame("/** @constructor */\n" + "function Super() {}\n" + "/**\n" + " * @constructor\n" + " * @extends {Super}\n" + " */\n" + "function Sub() {}\n" + "/** @param {Sub} x */ function f(x) {}\n" + "f(/** @type {Super} */ (new Sub));", TYPE_MISMATCH_WARNING); [EOL]     assertMismatches(Collections.<TypeMismatch>emptyList()); [EOL] } <line_num>: 116,128
private TypeMismatch fromNatives(JSTypeNative a, JSTypeNative b) { [EOL]     JSTypeRegistry registry = compiler.getTypeRegistry(); [EOL]     return new TypeMismatch(registry.getNativeType(a), registry.getNativeType(b), null); [EOL] } <line_num>: 130,134
private void assertMismatches(List<TypeMismatch> expected) { [EOL]     List<TypeMismatch> actual = Lists.newArrayList(compiler.getTypeValidator().getMismatches()); [EOL]     assertEquals(expected, actual); [EOL] } <line_num>: 136,140
