public void testStraightLine() { [EOL]     assertMatch("D:var x=1; U: x"); [EOL]     assertMatch("var x; D:x=1; U: x"); [EOL]     assertNotMatch("D:var x=1; x = 2; U: x"); [EOL]     assertMatch("var x=1; D:x=2; U: x"); [EOL]     assertNotMatch("U:x; D:var x = 1"); [EOL]     assertNotMatch("D:var x; U:x; x=1"); [EOL]     assertNotMatch("D:var x; U:x; x=1; x"); [EOL]     assertMatch("D: var x = 1; var y = 2; y; U:x"); [EOL] } <line_num>: 35,44
public void testIf() { [EOL]     assertNotMatch("var x; if(a){ D:x=1 } else { x=2 }; U:x"); [EOL]     assertNotMatch("var x; if(a){ x=1 } else { D:x=2 }; U:x"); [EOL]     assertMatch("D:var x=1; if(a){ U:x } else { x };"); [EOL]     assertMatch("D:var x=1; if(a){ x } else { U:x };"); [EOL]     assertNotMatch("var x; if(a) { D: x = 1 }; U:x;"); [EOL] } <line_num>: 46,52
public void testLoops() { [EOL]     assertNotMatch("var x=0; while(a){ D:x=1 }; U:x"); [EOL]     assertNotMatch("var x=0; for(;;) { D:x=1 }; U:x"); [EOL]     assertMatch("D:var x=1; while(a) { U:x }"); [EOL]     assertMatch("D:var x=1; for(;;)  { U:x }"); [EOL] } <line_num>: 54,59
public void testConditional() { [EOL]     assertMatch("var x=0,y; D:(x=1)&&y; U:x"); [EOL]     assertNotMatch("var x=0,y; D:y&&(x=1); U:x"); [EOL] } <line_num>: 61,64
public void testUseAndDefInSameInstruction() { [EOL]     assertMatch("D:var x=0; U:x=1,x"); [EOL]     assertMatch("D:var x=0; U:x,x=1"); [EOL] } <line_num>: 66,69
public void testAssignmentInExpressions() { [EOL]     assertMatch("var x=0; D:foo(bar(x=1)); U:x"); [EOL]     assertMatch("var x=0; D:foo(bar + (x = 1)); U:x"); [EOL] } <line_num>: 71,74
public void testHook() { [EOL]     assertNotMatch("var x=0; D:foo() ? x=1 : bar(); U:x"); [EOL]     assertNotMatch("var x=0; D:foo() ? x=1 : x=2; U:x"); [EOL] } <line_num>: 76,79
public void testExpressionVariableReassignment() { [EOL]     assertMatch("var a,b; D: var x = a + b; U:x"); [EOL]     assertNotMatch("var a,b,c; D: var x = a + b; a = 1; U:x"); [EOL]     assertNotMatch("var a,b,c; D: var x = a + b; f(b = 1); U:x"); [EOL]     assertMatch("var a,b,c; D: var x = a + b; c = 1; U:x"); [EOL]     assertNotMatch("var a,b,c; D: var x = a + b; c ? a = 1 : 0; U:x"); [EOL] } <line_num>: 81,89
public void testMergeDefinitions() { [EOL]     assertNotMatch("var x,y; D: y = x + x; if(x) { x = 1 }; U:y"); [EOL] } <line_num>: 91,93
public void testMergesWithOneDefinition() { [EOL]     assertNotMatch("var x,y; while(y) { if (y) { print(x) } else { D: x = 1 } } U:x"); [EOL] } <line_num>: 95,98
public void testRedefinitionUsingItself() { [EOL]     assertMatch("var x = 1; D: x = x + 1; U:x;"); [EOL]     assertNotMatch("var x = 1; D: x = x + 1; x = 1; U:x;"); [EOL] } <line_num>: 100,103
public void testMultipleDefinitionsWithDependence() { [EOL]     assertMatch("var x, a, b; D: x = a, x = b; U: x"); [EOL]     assertMatch("var x, a, b; D: x = a, x = b; a = 1; U: x"); [EOL]     assertNotMatch("var x, a, b; D: x = a, x = b; b = 1; U: x"); [EOL] } <line_num>: 105,109
public void testExterns() { [EOL]     assertNotMatch("D: goog = {}; U: goog"); [EOL] } <line_num>: 111,113
public void testAssignmentOp() { [EOL]     assertMatch("var x = 0; D: x += 1; U: x"); [EOL]     assertMatch("var x = 0; D: x *= 1; U: x"); [EOL]     assertNotMatch("D: var x = 0; x += 1; U: x"); [EOL] } <line_num>: 115,119
public void testIncAndDec() { [EOL]     assertMatch("var x; D: x++; U: x"); [EOL]     assertMatch("var x; D: x--; U: x"); [EOL] } <line_num>: 121,124
public void testFunctionParams1() { [EOL]     computeDefUse("if (param2) { D: param1 = 1; U: param1 }"); [EOL]     assertSame(def, defUse.getDefNode("param1", use)); [EOL] } <line_num>: 126,129
public void testFunctionParams2() { [EOL]     computeDefUse("if (param2) { D: param1 = 1} U: param1"); [EOL]     assertNotSame(def, defUse.getDefNode("param1", use)); [EOL] } <line_num>: 131,134
public void testArgumentsObjectModifications() { [EOL]     computeDefUse("D: param1 = 1; arguments[0] = 2; U: param1"); [EOL]     assertNotSame(def, defUse.getDefNode("param1", use)); [EOL] } <line_num>: 136,139
public void testArgumentsObjectEscaped() { [EOL]     computeDefUse("D: param1 = 1; var x = arguments; x[0] = 2; U: param1"); [EOL]     assertNotSame(def, defUse.getDefNode("param1", use)); [EOL] } <line_num>: 141,144
public void testArgumentsObjectEscapedDependents() { [EOL]     assertNotMatch("param1=1; var x; D:x=param1; var y=arguments; U:x"); [EOL] } <line_num>: 146,148
private void assertMatch(String src) { [EOL]     computeDefUse(src); [EOL]     assertSame(def, defUse.getDefNode("x", use)); [EOL] } <line_num>: 153,156
private void assertNotMatch(String src) { [EOL]     computeDefUse(src); [EOL]     assertNotSame(def, defUse.getDefNode("x", use)); [EOL] } <line_num>: 161,164
private void computeDefUse(String src) { [EOL]     Compiler compiler = new Compiler(); [EOL]     src = "function _FUNCTION(param1, param2){" + src + "}"; [EOL]     Node externs = compiler.parseTestCode(EXTERNS); [EOL]     Node root = compiler.parseTestCode(src).getFirstChild(); [EOL]     assertEquals(0, compiler.getErrorCount()); [EOL]     Scope scope = new SyntacticScopeCreator(compiler).createScope(root, null); [EOL]     ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true); [EOL]     cfa.process(null, root); [EOL]     ControlFlowGraph<Node> cfg = cfa.getCfg(); [EOL]     defUse = new MustBeReachingVariableDef(cfg, scope, compiler); [EOL]     defUse.analyze(); [EOL]     def = null; [EOL]     use = null; [EOL]     new NodeTraversal(compiler, new LabelFinder()).traverse(root); [EOL]     assertNotNull("Code should have an instruction labeled D", def); [EOL]     assertNotNull("Code should have an instruction labeled U", use); [EOL] } <line_num>: 169,186
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (n.isLabel()) { [EOL]         if (n.getFirstChild().getString().equals("D")) { [EOL]             def = n.getLastChild(); [EOL]         } else if (n.getFirstChild().getString().equals("U")) { [EOL]             use = n.getLastChild(); [EOL]         } [EOL]     } [EOL] } <line_num>: 192,201
