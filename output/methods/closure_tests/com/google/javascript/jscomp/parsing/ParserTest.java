private ParserResult(String code, Node node) { [EOL]     this.code = code; [EOL]     this.node = node; [EOL] } <line_num>: 1090,1093
@Override [EOL] protected void setUp() throws Exception { [EOL]     super.setUp(); [EOL]     mode = LanguageMode.ECMASCRIPT3; [EOL]     isIdeMode = false; [EOL] } <line_num>: 55,60
public void testLinenoCharnoAssign1() throws Exception { [EOL]     Node assign = parse("a = b").getFirstChild().getFirstChild(); [EOL]     assertEquals(Token.ASSIGN, assign.getType()); [EOL]     assertEquals(1, assign.getLineno()); [EOL]     assertEquals(0, assign.getCharno()); [EOL] } <line_num>: 62,68
public void testLinenoCharnoAssign2() throws Exception { [EOL]     Node assign = parse("\n a.g.h.k    =  45").getFirstChild().getFirstChild(); [EOL]     assertEquals(Token.ASSIGN, assign.getType()); [EOL]     assertEquals(2, assign.getLineno()); [EOL]     assertEquals(1, assign.getCharno()); [EOL] } <line_num>: 70,76
public void testLinenoCharnoCall() throws Exception { [EOL]     Node call = parse("\n foo(123);").getFirstChild().getFirstChild(); [EOL]     assertEquals(Token.CALL, call.getType()); [EOL]     assertEquals(2, call.getLineno()); [EOL]     assertEquals(1, call.getCharno()); [EOL] } <line_num>: 78,84
public void testLinenoCharnoGetProp1() throws Exception { [EOL]     Node getprop = parse("\n foo.bar").getFirstChild().getFirstChild(); [EOL]     assertEquals(Token.GETPROP, getprop.getType()); [EOL]     assertEquals(2, getprop.getLineno()); [EOL]     assertEquals(1, getprop.getCharno()); [EOL]     Node name = getprop.getFirstChild().getNext(); [EOL]     assertEquals(Token.STRING, name.getType()); [EOL]     assertEquals(2, name.getLineno()); [EOL]     assertEquals(5, name.getCharno()); [EOL] } <line_num>: 86,97
public void testLinenoCharnoGetProp2() throws Exception { [EOL]     Node getprop = parse("\n foo.\nbar").getFirstChild().getFirstChild(); [EOL]     assertEquals(Token.GETPROP, getprop.getType()); [EOL]     assertEquals(2, getprop.getLineno()); [EOL]     assertEquals(1, getprop.getCharno()); [EOL]     Node name = getprop.getFirstChild().getNext(); [EOL]     assertEquals(Token.STRING, name.getType()); [EOL]     assertEquals(3, name.getLineno()); [EOL]     assertEquals(0, name.getCharno()); [EOL] } <line_num>: 99,110
public void testLinenoCharnoGetelem1() throws Exception { [EOL]     Node call = parse("\n foo[123]").getFirstChild().getFirstChild(); [EOL]     assertEquals(Token.GETELEM, call.getType()); [EOL]     assertEquals(2, call.getLineno()); [EOL]     assertEquals(1, call.getCharno()); [EOL] } <line_num>: 112,118
public void testLinenoCharnoGetelem2() throws Exception { [EOL]     Node call = parse("\n   \n foo()[123]").getFirstChild().getFirstChild(); [EOL]     assertEquals(Token.GETELEM, call.getType()); [EOL]     assertEquals(3, call.getLineno()); [EOL]     assertEquals(1, call.getCharno()); [EOL] } <line_num>: 120,126
public void testLinenoCharnoGetelem3() throws Exception { [EOL]     Node call = parse("\n   \n (8 + kl)[123]").getFirstChild().getFirstChild(); [EOL]     assertEquals(Token.GETELEM, call.getType()); [EOL]     assertEquals(3, call.getLineno()); [EOL]     assertEquals(2, call.getCharno()); [EOL] } <line_num>: 128,134
public void testLinenoCharnoForComparison() throws Exception { [EOL]     Node lt = parse("for (; i < j;){}").getFirstChild().getFirstChild().getNext(); [EOL]     assertEquals(Token.LT, lt.getType()); [EOL]     assertEquals(1, lt.getLineno()); [EOL]     assertEquals(7, lt.getCharno()); [EOL] } <line_num>: 136,143
public void testLinenoCharnoHook() throws Exception { [EOL]     Node n = parse("\n a ? 9 : 0").getFirstChild().getFirstChild(); [EOL]     assertEquals(Token.HOOK, n.getType()); [EOL]     assertEquals(2, n.getLineno()); [EOL]     assertEquals(1, n.getCharno()); [EOL] } <line_num>: 145,151
public void testLinenoCharnoArrayLiteral() throws Exception { [EOL]     Node n = parse("\n  [8, 9]").getFirstChild().getFirstChild(); [EOL]     assertEquals(Token.ARRAYLIT, n.getType()); [EOL]     assertEquals(2, n.getLineno()); [EOL]     assertEquals(2, n.getCharno()); [EOL]     n = n.getFirstChild(); [EOL]     assertEquals(Token.NUMBER, n.getType()); [EOL]     assertEquals(2, n.getLineno()); [EOL]     assertEquals(3, n.getCharno()); [EOL]     n = n.getNext(); [EOL]     assertEquals(Token.NUMBER, n.getType()); [EOL]     assertEquals(2, n.getLineno()); [EOL]     assertEquals(6, n.getCharno()); [EOL] } <line_num>: 153,171
public void testLinenoCharnoObjectLiteral() throws Exception { [EOL]     Node n = parse("\n\n var a = {a:0\n,b :1};").getFirstChild().getFirstChild().getFirstChild(); [EOL]     assertEquals(Token.OBJECTLIT, n.getType()); [EOL]     assertEquals(3, n.getLineno()); [EOL]     assertEquals(9, n.getCharno()); [EOL]     Node key = n.getFirstChild(); [EOL]     assertEquals(Token.STRING_KEY, key.getType()); [EOL]     assertEquals(3, key.getLineno()); [EOL]     assertEquals(10, key.getCharno()); [EOL]     Node value = key.getFirstChild(); [EOL]     assertEquals(Token.NUMBER, value.getType()); [EOL]     assertEquals(3, value.getLineno()); [EOL]     assertEquals(12, value.getCharno()); [EOL]     key = key.getNext(); [EOL]     assertEquals(Token.STRING_KEY, key.getType()); [EOL]     assertEquals(4, key.getLineno()); [EOL]     assertEquals(1, key.getCharno()); [EOL]     value = key.getFirstChild(); [EOL]     assertEquals(Token.NUMBER, value.getType()); [EOL]     assertEquals(4, value.getLineno()); [EOL]     assertEquals(4, value.getCharno()); [EOL] } <line_num>: 173,204
public void testLinenoCharnoAdd() throws Exception { [EOL]     testLinenoCharnoBinop("+"); [EOL] } <line_num>: 206,208
public void testLinenoCharnoSub() throws Exception { [EOL]     testLinenoCharnoBinop("-"); [EOL] } <line_num>: 210,212
public void testLinenoCharnoMul() throws Exception { [EOL]     testLinenoCharnoBinop("*"); [EOL] } <line_num>: 214,216
public void testLinenoCharnoDiv() throws Exception { [EOL]     testLinenoCharnoBinop("/"); [EOL] } <line_num>: 218,220
public void testLinenoCharnoMod() throws Exception { [EOL]     testLinenoCharnoBinop("%"); [EOL] } <line_num>: 222,224
public void testLinenoCharnoShift() throws Exception { [EOL]     testLinenoCharnoBinop("<<"); [EOL] } <line_num>: 226,228
public void testLinenoCharnoBinaryAnd() throws Exception { [EOL]     testLinenoCharnoBinop("&"); [EOL] } <line_num>: 230,232
public void testLinenoCharnoAnd() throws Exception { [EOL]     testLinenoCharnoBinop("&&"); [EOL] } <line_num>: 234,236
public void testLinenoCharnoBinaryOr() throws Exception { [EOL]     testLinenoCharnoBinop("|"); [EOL] } <line_num>: 238,240
public void testLinenoCharnoOr() throws Exception { [EOL]     testLinenoCharnoBinop("||"); [EOL] } <line_num>: 242,244
public void testLinenoCharnoLt() throws Exception { [EOL]     testLinenoCharnoBinop("<"); [EOL] } <line_num>: 246,248
public void testLinenoCharnoLe() throws Exception { [EOL]     testLinenoCharnoBinop("<="); [EOL] } <line_num>: 250,252
public void testLinenoCharnoGt() throws Exception { [EOL]     testLinenoCharnoBinop(">"); [EOL] } <line_num>: 254,256
public void testLinenoCharnoGe() throws Exception { [EOL]     testLinenoCharnoBinop(">="); [EOL] } <line_num>: 258,260
private void testLinenoCharnoBinop(String binop) { [EOL]     Node op = parse("var a = 89 " + binop + " 76").getFirstChild().getFirstChild().getFirstChild(); [EOL]     assertEquals(1, op.getLineno()); [EOL]     assertEquals(8, op.getCharno()); [EOL] } <line_num>: 262,268
public void testJSDocAttachment1() { [EOL]     Node varNode = parse("/** @type number */var a;").getFirstChild(); [EOL]     assertEquals(Token.VAR, varNode.getType()); [EOL]     JSDocInfo info = varNode.getJSDocInfo(); [EOL]     assertNotNull(info); [EOL]     assertTypeEquals(NUMBER_TYPE, info.getType()); [EOL]     Node nameNode = varNode.getFirstChild(); [EOL]     assertEquals(Token.NAME, nameNode.getType()); [EOL]     assertNull(nameNode.getJSDocInfo()); [EOL] } <line_num>: 270,283
public void testJSDocAttachment2() { [EOL]     Node varNode = parse("/** @type number */var a,b;").getFirstChild(); [EOL]     assertEquals(Token.VAR, varNode.getType()); [EOL]     JSDocInfo info = varNode.getJSDocInfo(); [EOL]     assertNotNull(info); [EOL]     assertTypeEquals(NUMBER_TYPE, info.getType()); [EOL]     Node nameNode1 = varNode.getFirstChild(); [EOL]     assertEquals(Token.NAME, nameNode1.getType()); [EOL]     assertNull(nameNode1.getJSDocInfo()); [EOL]     Node nameNode2 = nameNode1.getNext(); [EOL]     assertEquals(Token.NAME, nameNode2.getType()); [EOL]     assertNull(nameNode2.getJSDocInfo()); [EOL] } <line_num>: 285,303
public void testJSDocAttachment3() { [EOL]     Node assignNode = parse("/** @type number */goog.FOO = 5;").getFirstChild().getFirstChild(); [EOL]     assertEquals(Token.ASSIGN, assignNode.getType()); [EOL]     JSDocInfo info = assignNode.getJSDocInfo(); [EOL]     assertNotNull(info); [EOL]     assertTypeEquals(NUMBER_TYPE, info.getType()); [EOL] } <line_num>: 305,314
public void testJSDocAttachment4() { [EOL]     Node varNode = parse("var a, /** @define {number} */b = 5;").getFirstChild(); [EOL]     assertEquals(Token.VAR, varNode.getType()); [EOL]     assertNull(varNode.getJSDocInfo()); [EOL]     Node a = varNode.getFirstChild(); [EOL]     assertNull(a.getJSDocInfo()); [EOL]     Node b = a.getNext(); [EOL]     JSDocInfo info = b.getJSDocInfo(); [EOL]     assertNotNull(info); [EOL]     assertTrue(info.isDefine()); [EOL]     assertTypeEquals(NUMBER_TYPE, info.getType()); [EOL] } <line_num>: 316,334
public void testJSDocAttachment5() { [EOL]     Node varNode = parse("var /** @type number */a, /** @define {number} */b = 5;").getFirstChild(); [EOL]     assertEquals(Token.VAR, varNode.getType()); [EOL]     assertNull(varNode.getJSDocInfo()); [EOL]     Node a = varNode.getFirstChild(); [EOL]     assertNotNull(a.getJSDocInfo()); [EOL]     JSDocInfo info = a.getJSDocInfo(); [EOL]     assertNotNull(info); [EOL]     assertFalse(info.isDefine()); [EOL]     assertTypeEquals(NUMBER_TYPE, info.getType()); [EOL]     Node b = a.getNext(); [EOL]     info = b.getJSDocInfo(); [EOL]     assertNotNull(info); [EOL]     assertTrue(info.isDefine()); [EOL]     assertTypeEquals(NUMBER_TYPE, info.getType()); [EOL] } <line_num>: 336,359
public void testJSDocAttachment6() throws Exception { [EOL]     Node functionNode = parse("var a = /** @param {number} index */5;" + "/** @return boolean */function f(index){}").getFirstChild().getNext(); [EOL]     assertEquals(Token.FUNCTION, functionNode.getType()); [EOL]     JSDocInfo info = functionNode.getJSDocInfo(); [EOL]     assertNotNull(info); [EOL]     assertFalse(info.hasParameter("index")); [EOL]     assertTrue(info.hasReturnType()); [EOL]     assertTypeEquals(UNKNOWN_TYPE, info.getReturnType()); [EOL] } <line_num>: 365,377
public void testJSDocAttachment7() { [EOL]     Node varNode = parse("/** */var a;").getFirstChild(); [EOL]     assertEquals(Token.VAR, varNode.getType()); [EOL]     Node nameNode = varNode.getFirstChild(); [EOL]     assertEquals(Token.NAME, nameNode.getType()); [EOL]     assertNull(nameNode.getJSDocInfo()); [EOL] } <line_num>: 379,389
public void testJSDocAttachment8() { [EOL]     Node varNode = parse("/** x */var a;").getFirstChild(); [EOL]     assertEquals(Token.VAR, varNode.getType()); [EOL]     Node nameNode = varNode.getFirstChild(); [EOL]     assertEquals(Token.NAME, nameNode.getType()); [EOL]     assertNull(nameNode.getJSDocInfo()); [EOL] } <line_num>: 391,401
public void testJSDocAttachment9() { [EOL]     Node varNode = parse("/** \n x */var a;").getFirstChild(); [EOL]     assertEquals(Token.VAR, varNode.getType()); [EOL]     Node nameNode = varNode.getFirstChild(); [EOL]     assertEquals(Token.NAME, nameNode.getType()); [EOL]     assertNull(nameNode.getJSDocInfo()); [EOL] } <line_num>: 403,413
public void testJSDocAttachment10() { [EOL]     Node varNode = parse("/** x\n */var a;").getFirstChild(); [EOL]     assertEquals(Token.VAR, varNode.getType()); [EOL]     Node nameNode = varNode.getFirstChild(); [EOL]     assertEquals(Token.NAME, nameNode.getType()); [EOL]     assertNull(nameNode.getJSDocInfo()); [EOL] } <line_num>: 415,425
public void testJSDocAttachment11() { [EOL]     Node varNode = parse("/** @type {{x : number, 'y' : string, z}} */var a;").getFirstChild(); [EOL]     assertEquals(Token.VAR, varNode.getType()); [EOL]     JSDocInfo info = varNode.getJSDocInfo(); [EOL]     assertNotNull(info); [EOL]     assertTypeEquals(createRecordTypeBuilder().addProperty("x", NUMBER_TYPE, null).addProperty("y", STRING_TYPE, null).addProperty("z", UNKNOWN_TYPE, null).build(), info.getType()); [EOL]     Node nameNode = varNode.getFirstChild(); [EOL]     assertEquals(Token.NAME, nameNode.getType()); [EOL]     assertNull(nameNode.getJSDocInfo()); [EOL] } <line_num>: 427,448
public void testJSDocAttachment12() { [EOL]     Node varNode = parse("var a = {/** @type {Object} */ b: c};").getFirstChild(); [EOL]     Node objectLitNode = varNode.getFirstChild().getFirstChild(); [EOL]     assertEquals(Token.OBJECTLIT, objectLitNode.getType()); [EOL]     assertNotNull(objectLitNode.getFirstChild().getJSDocInfo()); [EOL] } <line_num>: 450,457
public void testJSDocAttachment13() { [EOL]     Node varNode = parse("/** foo */ var a;").getFirstChild(); [EOL]     assertNotNull(varNode.getJSDocInfo()); [EOL] } <line_num>: 459,462
public void testJSDocAttachment14() { [EOL]     Node varNode = parse("/** */ var a;").getFirstChild(); [EOL]     assertNull(varNode.getJSDocInfo()); [EOL] } <line_num>: 464,467
public void testJSDocAttachment15() { [EOL]     Node varNode = parse("/** \n * \n */ var a;").getFirstChild(); [EOL]     assertNull(varNode.getJSDocInfo()); [EOL] } <line_num>: 469,472
public void testJSDocAttachment16() { [EOL]     Node exprCall = parse("/** @private */ x(); function f() {};").getFirstChild(); [EOL]     assertEquals(Token.EXPR_RESULT, exprCall.getType()); [EOL]     assertNull(exprCall.getNext().getJSDocInfo()); [EOL]     assertNotNull(exprCall.getFirstChild().getJSDocInfo()); [EOL] } <line_num>: 474,480
public void testIncorrectJSDocDoesNotAlterJSParsing1() throws Exception { [EOL]     assertNodeEquality(parse("var a = [1,2]"), parse("/** @type Array.<number*/var a = [1,2]", MISSING_GT_MESSAGE)); [EOL] } <line_num>: 482,487
public void testIncorrectJSDocDoesNotAlterJSParsing2() throws Exception { [EOL]     assertNodeEquality(parse("var a = [1,2]"), parse("/** @type {Array.<number}*/var a = [1,2]", MISSING_GT_MESSAGE)); [EOL] } <line_num>: 489,494
public void testIncorrectJSDocDoesNotAlterJSParsing3() throws Exception { [EOL]     assertNodeEquality(parse("C.prototype.say=function(nums) {alert(nums.join(','));};"), parse("/** @param {Array.<number} nums */" + "C.prototype.say=function(nums) {alert(nums.join(','));};", MISSING_GT_MESSAGE)); [EOL] } <line_num>: 496,502
public void testIncorrectJSDocDoesNotAlterJSParsing4() throws Exception { [EOL]     assertNodeEquality(parse("C.prototype.say=function(nums) {alert(nums.join(','));};"), parse("/** @return boolean */" + "C.prototype.say=function(nums) {alert(nums.join(','));};")); [EOL] } <line_num>: 504,509
public void testIncorrectJSDocDoesNotAlterJSParsing5() throws Exception { [EOL]     assertNodeEquality(parse("C.prototype.say=function(nums) {alert(nums.join(','));};"), parse("/** @param boolean this is some string*/" + "C.prototype.say=function(nums) {alert(nums.join(','));};")); [EOL] } <line_num>: 511,516
public void testIncorrectJSDocDoesNotAlterJSParsing6() throws Exception { [EOL]     assertNodeEquality(parse("C.prototype.say=function(nums) {alert(nums.join(','));};"), parse("/** @param {bool!*%E$} */" + "C.prototype.say=function(nums) {alert(nums.join(','));};", "Bad type annotation. expected closing }", "Bad type annotation. expecting a variable name in a @param tag")); [EOL] } <line_num>: 518,525
public void testIncorrectJSDocDoesNotAlterJSParsing7() throws Exception { [EOL]     assertNodeEquality(parse("C.prototype.say=function(nums) {alert(nums.join(','));};"), parse("/** @see */" + "C.prototype.say=function(nums) {alert(nums.join(','));};", "@see tag missing description")); [EOL] } <line_num>: 527,533
public void testIncorrectJSDocDoesNotAlterJSParsing8() throws Exception { [EOL]     assertNodeEquality(parse("C.prototype.say=function(nums) {alert(nums.join(','));};"), parse("/** @author */" + "C.prototype.say=function(nums) {alert(nums.join(','));};", "@author tag missing author")); [EOL] } <line_num>: 535,541
public void testIncorrectJSDocDoesNotAlterJSParsing9() throws Exception { [EOL]     assertNodeEquality(parse("C.prototype.say=function(nums) {alert(nums.join(','));};"), parse("/** @someillegaltag */" + "C.prototype.say=function(nums) {alert(nums.join(','));};", "illegal use of unknown JSDoc tag \"someillegaltag\";" + " ignoring it")); [EOL] } <line_num>: 543,550
public void testUnescapedSlashInRegexpCharClass() throws Exception { [EOL]     parse("var foo = /[/]/;"); [EOL]     parse("var foo = /[hi there/]/;"); [EOL]     parse("var foo = /[/yo dude]/;"); [EOL]     parse("var foo = /\\/[@#$/watashi/wa/suteevu/desu]/;"); [EOL] } <line_num>: 552,558
private void assertNodeEquality(Node expected, Node found) { [EOL]     String message = expected.checkTreeEquals(found); [EOL]     if (message != null) { [EOL]         fail(message); [EOL]     } [EOL] } <line_num>: 560,565
@SuppressWarnings("unchecked") [EOL] public void testParse() { [EOL]     Node a = Node.newString(Token.NAME, "a"); [EOL]     a.addChildToFront(Node.newString(Token.NAME, "b")); [EOL]     List<ParserResult> testCases = ImmutableList.of(new ParserResult("3;", createScript(new Node(Token.EXPR_RESULT, Node.newNumber(3.0)))), new ParserResult("var a = b;", createScript(new Node(Token.VAR, a))), new ParserResult("\"hell\\\no\\ world\\\n\\\n!\"", createScript(new Node(Token.EXPR_RESULT, Node.newString(Token.STRING, "hello world!"))))); [EOL]     for (ParserResult testCase : testCases) { [EOL]         assertNodeEquality(testCase.node, parse(testCase.code)); [EOL]     } [EOL] } <line_num>: 567,586
private Node createScript(Node n) { [EOL]     Node script = new Node(Token.SCRIPT); [EOL]     script.addChildToBack(n); [EOL]     return script; [EOL] } <line_num>: 588,592
public void testTrailingCommaWarning1() { [EOL]     parse("var a = ['foo', 'bar'];"); [EOL] } <line_num>: 594,596
public void testTrailingCommaWarning2() { [EOL]     parse("var a = ['foo',,'bar'];"); [EOL] } <line_num>: 598,600
public void testTrailingCommaWarning3() { [EOL]     parse("var a = ['foo', 'bar',];", TRAILING_COMMA_MESSAGE); [EOL]     mode = LanguageMode.ECMASCRIPT5; [EOL]     parse("var a = ['foo', 'bar',];"); [EOL] } <line_num>: 602,606
public void testTrailingCommaWarning4() { [EOL]     parse("var a = [,];", TRAILING_COMMA_MESSAGE); [EOL]     mode = LanguageMode.ECMASCRIPT5; [EOL]     parse("var a = [,];"); [EOL] } <line_num>: 608,612
public void testTrailingCommaWarning5() { [EOL]     parse("var a = {'foo': 'bar'};"); [EOL] } <line_num>: 614,616
public void testTrailingCommaWarning6() { [EOL]     parse("var a = {'foo': 'bar',};", TRAILING_COMMA_MESSAGE); [EOL]     mode = LanguageMode.ECMASCRIPT5; [EOL]     parse("var a = {'foo': 'bar',};"); [EOL] } <line_num>: 618,622
public void testTrailingCommaWarning7() { [EOL]     parseError("var a = {,};", BAD_PROPERTY_MESSAGE); [EOL] } <line_num>: 624,626
public void testSuspiciousBlockCommentWarning1() { [EOL]     parse("/* @type {number} */ var x = 3;", SUSPICIOUS_COMMENT_WARNING); [EOL] } <line_num>: 628,630
public void testSuspiciousBlockCommentWarning2() { [EOL]     parse("/* \n * @type {number} */ var x = 3;", SUSPICIOUS_COMMENT_WARNING); [EOL] } <line_num>: 632,634
public void testCatchClauseForbidden() { [EOL]     parseError("try { } catch (e if true) {}", "Catch clauses are not supported"); [EOL] } <line_num>: 636,639
public void testConstForbidden() { [EOL]     parseError("const x = 3;", "Unsupported syntax: CONST"); [EOL] } <line_num>: 641,643
public void testDestructuringAssignForbidden() { [EOL]     parseError("var [x, y] = foo();", "destructuring assignment forbidden"); [EOL] } <line_num>: 645,647
public void testDestructuringAssignForbidden2() { [EOL]     parseError("var {x, y} = foo();", "missing : after property id"); [EOL] } <line_num>: 649,651
public void testDestructuringAssignForbidden3() { [EOL]     parseError("var {x: x, y: y} = foo();", "destructuring assignment forbidden"); [EOL] } <line_num>: 653,656
public void testDestructuringAssignForbidden4() { [EOL]     parseError("[x, y] = foo();", "destructuring assignment forbidden", "invalid assignment target"); [EOL] } <line_num>: 658,662
public void testLetForbidden() { [EOL]     parseError("function f() { let (x = 3) { alert(x); }; }", "missing ; before statement", "syntax error"); [EOL] } <line_num>: 664,667
public void testYieldForbidden() { [EOL]     parseError("function f() { yield 3; }", "missing ; before statement"); [EOL] } <line_num>: 669,671
public void testBracelessFunctionForbidden() { [EOL]     parseError("var sq = function(x) x * x;", "missing { before function body"); [EOL] } <line_num>: 673,676
public void testGeneratorsForbidden() { [EOL]     parseError("var i = (x for (x in obj));", "Unsupported syntax: GENEXPR"); [EOL] } <line_num>: 678,681
public void testGettersForbidden1() { [EOL]     parseError("var x = {get foo() { return 3; }};", IRFactory.GETTER_ERROR_MESSAGE); [EOL] } <line_num>: 683,686
public void testGettersForbidden2() { [EOL]     parseError("var x = {get foo bar() { return 3; }};", "invalid property id"); [EOL] } <line_num>: 688,691
public void testGettersForbidden3() { [EOL]     parseError("var x = {a getter:function b() { return 3; }};", "missing : after property id", "syntax error"); [EOL] } <line_num>: 693,696
public void testGettersForbidden4() { [EOL]     parseError("var x = {\"a\" getter:function b() { return 3; }};", "missing : after property id", "syntax error"); [EOL] } <line_num>: 698,701
public void testGettersForbidden5() { [EOL]     parseError("var x = {a: 2, get foo() { return 3; }};", IRFactory.GETTER_ERROR_MESSAGE); [EOL] } <line_num>: 703,706
public void testSettersForbidden() { [EOL]     parseError("var x = {set foo() { return 3; }};", IRFactory.SETTER_ERROR_MESSAGE); [EOL] } <line_num>: 708,711
public void testSettersForbidden2() { [EOL]     parseError("var x = {a setter:function b() { return 3; }};", "missing : after property id", "syntax error"); [EOL] } <line_num>: 713,716
public void testFileOverviewJSDoc1() { [EOL]     Node n = parse("/** @fileoverview Hi mom! */ function Foo() {}"); [EOL]     assertEquals(Token.FUNCTION, n.getFirstChild().getType()); [EOL]     assertTrue(n.getJSDocInfo() != null); [EOL]     assertNull(n.getFirstChild().getJSDocInfo()); [EOL]     assertEquals("Hi mom!", n.getJSDocInfo().getFileOverview()); [EOL] } <line_num>: 718,725
public void testFileOverviewJSDocDoesNotHoseParsing() { [EOL]     assertEquals(Token.FUNCTION, parse("/** @fileoverview Hi mom! \n */ function Foo() {}").getFirstChild().getType()); [EOL]     assertEquals(Token.FUNCTION, parse("/** @fileoverview Hi mom! \n * * * */ function Foo() {}").getFirstChild().getType()); [EOL]     assertEquals(Token.FUNCTION, parse("/** @fileoverview \n * x */ function Foo() {}").getFirstChild().getType()); [EOL]     assertEquals(Token.FUNCTION, parse("/** @fileoverview \n * x \n */ function Foo() {}").getFirstChild().getType()); [EOL] } <line_num>: 727,744
public void testFileOverviewJSDoc2() { [EOL]     Node n = parse("/** @fileoverview Hi mom! */ " + "/** @constructor */ function Foo() {}"); [EOL]     assertTrue(n.getJSDocInfo() != null); [EOL]     assertEquals("Hi mom!", n.getJSDocInfo().getFileOverview()); [EOL]     assertTrue(n.getFirstChild().getJSDocInfo() != null); [EOL]     assertFalse(n.getFirstChild().getJSDocInfo().hasFileOverview()); [EOL]     assertTrue(n.getFirstChild().getJSDocInfo().isConstructor()); [EOL] } <line_num>: 746,754
public void testObjectLiteralDoc1() { [EOL]     Node n = parse("var x = {/** @type {number} */ 1: 2};"); [EOL]     Node objectLit = n.getFirstChild().getFirstChild().getFirstChild(); [EOL]     assertEquals(Token.OBJECTLIT, objectLit.getType()); [EOL]     Node number = objectLit.getFirstChild(); [EOL]     assertEquals(Token.STRING_KEY, number.getType()); [EOL]     assertNotNull(number.getJSDocInfo()); [EOL] } <line_num>: 756,765
public void testDuplicatedParam() { [EOL]     parse("function foo(x, x) {}", "Duplicate parameter name \"x\"."); [EOL] } <line_num>: 767,769
public void testGetter() { [EOL]     mode = LanguageMode.ECMASCRIPT3; [EOL]     parseError("var x = {get 1(){}};", IRFactory.GETTER_ERROR_MESSAGE); [EOL]     parseError("var x = {get 'a'(){}};", IRFactory.GETTER_ERROR_MESSAGE); [EOL]     parseError("var x = {get a(){}};", IRFactory.GETTER_ERROR_MESSAGE); [EOL]     mode = LanguageMode.ECMASCRIPT5; [EOL]     parse("var x = {get 1(){}};"); [EOL]     parse("var x = {get 'a'(){}};"); [EOL]     parse("var x = {get a(){}};"); [EOL]     parseError("var x = {get a(b){}};", "getters may not have parameters"); [EOL] } <line_num>: 771,784
public void testSetter() { [EOL]     mode = LanguageMode.ECMASCRIPT3; [EOL]     parseError("var x = {set 1(x){}};", IRFactory.SETTER_ERROR_MESSAGE); [EOL]     parseError("var x = {set 'a'(x){}};", IRFactory.SETTER_ERROR_MESSAGE); [EOL]     parseError("var x = {set a(x){}};", IRFactory.SETTER_ERROR_MESSAGE); [EOL]     mode = LanguageMode.ECMASCRIPT5; [EOL]     parse("var x = {set 1(x){}};"); [EOL]     parse("var x = {set 'a'(x){}};"); [EOL]     parse("var x = {set a(x){}};"); [EOL]     parseError("var x = {set a(){}};", "setters must have exactly one parameter"); [EOL] } <line_num>: 786,800
public void testLamestWarningEver() { [EOL]     parse("var x = /** @type {undefined} */ (y);"); [EOL]     parse("var x = /** @type {void} */ (y);"); [EOL] } <line_num>: 802,806
public void testUnfinishedComment() { [EOL]     parseError("/** this is a comment ", "unterminated comment"); [EOL] } <line_num>: 808,810
public void testParseBlockDescription() { [EOL]     Node n = parse("/** This is a variable. */ var x;"); [EOL]     Node var = n.getFirstChild(); [EOL]     assertNotNull(var.getJSDocInfo()); [EOL]     assertEquals("This is a variable.", var.getJSDocInfo().getBlockDescription()); [EOL] } <line_num>: 812,818
public void testUnnamedFunctionStatement() { [EOL]     parseError("function() {};", "unnamed function statement"); [EOL]     parseError("if (true) { function() {}; }", "unnamed function statement"); [EOL]     parse("function f() {};"); [EOL]     parse("(function f() {});"); [EOL]     parse("(function () {});"); [EOL] } <line_num>: 820,828
public void testReservedKeywords() { [EOL]     boolean isIdeMode = false; [EOL]     mode = LanguageMode.ECMASCRIPT3; [EOL]     parseError("var boolean;", "missing variable name"); [EOL]     parseError("function boolean() {};", "missing ( before function parameters."); [EOL]     parseError("boolean = 1;", "identifier is a reserved word"); [EOL]     parseError("class = 1;", "identifier is a reserved word"); [EOL]     parseError("public = 2;", "identifier is a reserved word"); [EOL]     mode = LanguageMode.ECMASCRIPT5; [EOL]     parse("var boolean;"); [EOL]     parse("function boolean() {};"); [EOL]     parse("boolean = 1;"); [EOL]     parseError("class = 1;", "identifier is a reserved word"); [EOL]     parse("public = 2;"); [EOL]     mode = LanguageMode.ECMASCRIPT5_STRICT; [EOL]     parse("var boolean;"); [EOL]     parse("function boolean() {};"); [EOL]     parse("boolean = 1;"); [EOL]     parseError("class = 1;", "identifier is a reserved word"); [EOL]     parseError("public = 2;", "identifier is a reserved word"); [EOL] } <line_num>: 830,857
public void testKeywordsAsProperties() { [EOL]     boolean isIdeMode = false; [EOL]     mode = LanguageMode.ECMASCRIPT3; [EOL]     parseError("var x = {function: 1};", "invalid property id"); [EOL]     parseError("x.function;", "missing name after . operator"); [EOL]     parseError("var x = {get x(){} };", IRFactory.GETTER_ERROR_MESSAGE); [EOL]     parseError("var x = {get function(){} };", "invalid property id"); [EOL]     parseError("var x = {get 'function'(){} };", IRFactory.GETTER_ERROR_MESSAGE); [EOL]     parseError("var x = {get 1(){} };", IRFactory.GETTER_ERROR_MESSAGE); [EOL]     parseError("var x = {set function(a){} };", "invalid property id"); [EOL]     parseError("var x = {set 'function'(a){} };", IRFactory.SETTER_ERROR_MESSAGE); [EOL]     parseError("var x = {set 1(a){} };", IRFactory.SETTER_ERROR_MESSAGE); [EOL]     parseError("var x = {class: 1};", "invalid property id"); [EOL]     parseError("x.class;", "missing name after . operator"); [EOL]     parse("var x = {let: 1};"); [EOL]     parse("x.let;"); [EOL]     parse("var x = {yield: 1};"); [EOL]     parse("x.yield;"); [EOL]     mode = LanguageMode.ECMASCRIPT5; [EOL]     parse("var x = {function: 1};"); [EOL]     parse("x.function;"); [EOL]     parse("var x = {get function(){} };"); [EOL]     parse("var x = {get 'function'(){} };"); [EOL]     parse("var x = {get 1(){} };"); [EOL]     parse("var x = {set function(a){} };"); [EOL]     parse("var x = {set 'function'(a){} };"); [EOL]     parse("var x = {set 1(a){} };"); [EOL]     parse("var x = {class: 1};"); [EOL]     parse("x.class;"); [EOL]     parse("var x = {let: 1};"); [EOL]     parse("x.let;"); [EOL]     parse("var x = {yield: 1};"); [EOL]     parse("x.yield;"); [EOL]     mode = LanguageMode.ECMASCRIPT5_STRICT; [EOL]     parse("var x = {function: 1};"); [EOL]     parse("x.function;"); [EOL]     parse("var x = {get function(){} };"); [EOL]     parse("var x = {get 'function'(){} };"); [EOL]     parse("var x = {get 1(){} };"); [EOL]     parse("var x = {set function(a){} };"); [EOL]     parse("var x = {set 'function'(a){} };"); [EOL]     parse("var x = {set 1(a){} };"); [EOL]     parse("var x = {class: 1};"); [EOL]     parse("x.class;"); [EOL]     parse("var x = {let: 1};"); [EOL]     parse("x.let;"); [EOL]     parse("var x = {yield: 1};"); [EOL]     parse("x.yield;"); [EOL] } <line_num>: 859,918
public void testGetPropFunctionName() { [EOL]     parseError("function a.b() {}", "missing ( before function parameters."); [EOL]     parseError("var x = function a.b() {}", "missing ( before function parameters."); [EOL] } <line_num>: 920,925
public void testGetPropFunctionNameIdeMode() { [EOL]     isIdeMode = true; [EOL]     parseError("function a.b() {}", "missing ( before function parameters.", "missing formal parameter", "missing ) after formal parameters", "missing { before function body", "syntax error", "missing ; before statement", "missing ; before statement", "missing } after function body", "Unsupported syntax: ERROR", "Unsupported syntax: ERROR"); [EOL]     parseError("var x = function a.b() {}", "missing ( before function parameters.", "missing formal parameter", "missing ) after formal parameters", "missing { before function body", "syntax error", "missing ; before statement", "missing ; before statement", "missing } after function body", "Unsupported syntax: ERROR", "Unsupported syntax: ERROR"); [EOL] } <line_num>: 927,953
public void testIdeModePartialTree() { [EOL]     Node partialTree = parseError("function Foo() {} f.", "missing name after . operator"); [EOL]     assertNull(partialTree); [EOL]     isIdeMode = true; [EOL]     partialTree = parseError("function Foo() {} f.", "missing name after . operator"); [EOL]     assertNotNull(partialTree); [EOL] } <line_num>: 955,964
public void testForEach() { [EOL]     parseError("function f(stamp, status) {\n" + "  for each ( var curTiming in this.timeLog.timings ) {\n" + "    if ( curTiming.callId == stamp ) {\n" + "      curTiming.flag = status;\n" + "      break;\n" + "    }\n" + "  }\n" + "};", "unsupported language extension: for each"); [EOL] } <line_num>: 966,977
public void testMisplacedTypeAnnotation1() { [EOL]     parse("var o = {};" + "/** @type {string} */ o.prop1 = 1, o.prop2 = 2;", MISPLACED_TYPE_ANNOTATION); [EOL] } <line_num>: 979,985
public void testMisplacedTypeAnnotation2() { [EOL]     parse("var o = /** @type {string} */ getValue();", MISPLACED_TYPE_ANNOTATION); [EOL] } <line_num>: 987,992
public void testMisplacedTypeAnnotation3() { [EOL]     parse("var o = 1 + /** @type {string} */ value;", MISPLACED_TYPE_ANNOTATION); [EOL] } <line_num>: 994,999
public void testMisplacedTypeAnnotation4() { [EOL]     parse("var o = /** @type {!Array.<string>} */ ['hello', 'you'];", MISPLACED_TYPE_ANNOTATION); [EOL] } <line_num>: 1001,1006
public void testMisplacedTypeAnnotation5() { [EOL]     parse("var o = (/** @type {!Foo} */ {});", MISPLACED_TYPE_ANNOTATION); [EOL] } <line_num>: 1008,1013
public void testMisplacedTypeAnnotation6() { [EOL]     parse("var o = /** @type {function():string} */ function() {return 'str';}", MISPLACED_TYPE_ANNOTATION); [EOL] } <line_num>: 1015,1018
public void testValidTypeAnnotation1() { [EOL]     parse("/** @type {string} */ var o = 'str';"); [EOL]     parse("var /** @type {string} */ o = 'str', /** @type {number} */ p = 0;"); [EOL]     parse("/** @type {function():string} */ function o() { return 'str'; }"); [EOL]     parse("var o = {}; /** @type {string} */ o.prop = 'str';"); [EOL]     parse("var o = {}; /** @type {string} */ o['prop'] = 'str';"); [EOL]     parse("var o = { /** @type {string} */ prop : 'str' };"); [EOL]     parse("var o = { /** @type {string} */ 'prop' : 'str' };"); [EOL]     parse("var o = { /** @type {string} */ 1 : 'str' };"); [EOL] } <line_num>: 1020,1029
public void testValidTypeAnnotation2() { [EOL]     mode = LanguageMode.ECMASCRIPT5; [EOL]     parse("var o = { /** @type {string} */ get prop() { return 'str' }};"); [EOL]     parse("var o = { /** @type {string} */ set prop(s) {}};"); [EOL] } <line_num>: 1031,1035
public void testValidTypeAnnotation3() { [EOL]     parse("try {} catch (/** @type {Error} */ e) {}"); [EOL]     parse("function f(/** @type {string} */ a) {}"); [EOL] } <line_num>: 1037,1042
private Node parseError(String string, String... errors) { [EOL]     TestErrorReporter testErrorReporter = new TestErrorReporter(errors, null); [EOL]     Node script = null; [EOL]     try { [EOL]         StaticSourceFile file = new SimpleSourceFile("input", false); [EOL]         script = ParserRunner.parse(file, string, ParserRunner.createConfig(isIdeMode, mode, false), testErrorReporter, Logger.getAnonymousLogger()).ast; [EOL]     } catch (IOException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL]     assertTrue(testErrorReporter.hasEncounteredAllErrors()); [EOL]     assertTrue(testErrorReporter.hasEncounteredAllWarnings()); [EOL]     return script; [EOL] } <line_num>: 1048,1065
private Node parse(String string, String... warnings) { [EOL]     TestErrorReporter testErrorReporter = new TestErrorReporter(null, warnings); [EOL]     Node script = null; [EOL]     try { [EOL]         StaticSourceFile file = new SimpleSourceFile("input", false); [EOL]         script = ParserRunner.parse(file, string, ParserRunner.createConfig(true, mode, false), testErrorReporter, Logger.getAnonymousLogger()).ast; [EOL]     } catch (IOException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL]     assertTrue(testErrorReporter.hasEncounteredAllErrors()); [EOL]     assertTrue(testErrorReporter.hasEncounteredAllWarnings()); [EOL]     return script; [EOL] } <line_num>: 1067,1084
