@Override [EOL] public void setUp() throws Exception { [EOL]     super.setUp(); [EOL]     extraAnnotations = Sets.newHashSet(ParserRunner.createConfig(true, LanguageMode.ECMASCRIPT3, false).annotationNames.keySet()); [EOL]     extraSuppressions = Sets.newHashSet(ParserRunner.createConfig(true, LanguageMode.ECMASCRIPT3, false).suppressionNames); [EOL]     extraSuppressions.add("x"); [EOL]     extraSuppressions.add("y"); [EOL]     extraSuppressions.add("z"); [EOL] } <line_num>: 49,64
public void testParseTypeViaStatic1() throws Exception { [EOL]     Node typeNode = parseType("null"); [EOL]     assertTypeEquals(NULL_TYPE, typeNode); [EOL] } <line_num>: 66,69
public void testParseTypeViaStatic2() throws Exception { [EOL]     Node typeNode = parseType("string"); [EOL]     assertTypeEquals(STRING_TYPE, typeNode); [EOL] } <line_num>: 71,74
public void testParseTypeViaStatic3() throws Exception { [EOL]     Node typeNode = parseType("!Date"); [EOL]     assertTypeEquals(DATE_TYPE, typeNode); [EOL] } <line_num>: 76,79
public void testParseTypeViaStatic4() throws Exception { [EOL]     Node typeNode = parseType("boolean|string"); [EOL]     assertTypeEquals(createUnionType(BOOLEAN_TYPE, STRING_TYPE), typeNode); [EOL] } <line_num>: 81,84
public void testParseInvalidTypeViaStatic() throws Exception { [EOL]     Node typeNode = parseType("sometype.<anothertype"); [EOL]     assertNull(typeNode); [EOL] } <line_num>: 86,89
public void testParseInvalidTypeViaStatic2() throws Exception { [EOL]     Node typeNode = parseType(""); [EOL]     assertNull(typeNode); [EOL] } <line_num>: 91,94
public void testParseNamedType1() throws Exception { [EOL]     assertNull(parse("@type null", "Unexpected end of file")); [EOL] } <line_num>: 96,98
public void testParseNamedType2() throws Exception { [EOL]     JSDocInfo info = parse("@type null*/"); [EOL]     assertTypeEquals(NULL_TYPE, info.getType()); [EOL] } <line_num>: 100,103
public void testParseNamedType3() throws Exception { [EOL]     JSDocInfo info = parse("@type {string}*/"); [EOL]     assertTypeEquals(STRING_TYPE, info.getType()); [EOL] } <line_num>: 105,108
public void testParseNamedType4() throws Exception { [EOL]     JSDocInfo info = parse("@type \n {string}*/"); [EOL]     assertTypeEquals(STRING_TYPE, info.getType()); [EOL] } <line_num>: 110,114
public void testParseNamedType5() throws Exception { [EOL]     JSDocInfo info = parse("@type {!goog.\nBar}*/"); [EOL]     assertTypeEquals(registry.createNamedType("goog.Bar", null, -1, -1), info.getType()); [EOL] } <line_num>: 116,121
public void testParseNamedType6() throws Exception { [EOL]     JSDocInfo info = parse("@type {!goog.\n * Bar.\n * Baz}*/"); [EOL]     assertTypeEquals(registry.createNamedType("goog.Bar.Baz", null, -1, -1), info.getType()); [EOL] } <line_num>: 123,128
public void testParseNamedTypeError1() throws Exception { [EOL]     parse("@type {!goog\n * .Bar} */", "Bad type annotation. expected closing }"); [EOL] } <line_num>: 130,135
public void testParseNamedTypeError2() throws Exception { [EOL]     parse("@type {!goog.\n * Bar\n * .Baz} */", "Bad type annotation. expected closing }"); [EOL] } <line_num>: 137,140
public void testTypedefType1() throws Exception { [EOL]     JSDocInfo info = parse("@typedef string */"); [EOL]     assertTrue(info.hasTypedefType()); [EOL]     assertTypeEquals(STRING_TYPE, info.getTypedefType()); [EOL] } <line_num>: 142,146
public void testTypedefType2() throws Exception { [EOL]     JSDocInfo info = parse("@typedef \n {string}*/"); [EOL]     assertTrue(info.hasTypedefType()); [EOL]     assertTypeEquals(STRING_TYPE, info.getTypedefType()); [EOL] } <line_num>: 148,152
public void testTypedefType3() throws Exception { [EOL]     JSDocInfo info = parse("@typedef \n {(string|number)}*/"); [EOL]     assertTrue(info.hasTypedefType()); [EOL]     assertTypeEquals(createUnionType(NUMBER_TYPE, STRING_TYPE), info.getTypedefType()); [EOL] } <line_num>: 154,160
public void testParseStringType1() throws Exception { [EOL]     assertTypeEquals(STRING_TYPE, parse("@type {string}*/").getType()); [EOL] } <line_num>: 162,164
public void testParseStringType2() throws Exception { [EOL]     assertTypeEquals(STRING_OBJECT_TYPE, parse("@type {!String}*/").getType()); [EOL] } <line_num>: 166,168
public void testParseBooleanType1() throws Exception { [EOL]     assertTypeEquals(BOOLEAN_TYPE, parse("@type {boolean}*/").getType()); [EOL] } <line_num>: 170,172
public void testParseBooleanType2() throws Exception { [EOL]     assertTypeEquals(BOOLEAN_OBJECT_TYPE, parse("@type {!Boolean}*/").getType()); [EOL] } <line_num>: 174,177
public void testParseNumberType1() throws Exception { [EOL]     assertTypeEquals(NUMBER_TYPE, parse("@type {number}*/").getType()); [EOL] } <line_num>: 179,181
public void testParseNumberType2() throws Exception { [EOL]     assertTypeEquals(NUMBER_OBJECT_TYPE, parse("@type {!Number}*/").getType()); [EOL] } <line_num>: 183,185
public void testParseNullType1() throws Exception { [EOL]     assertTypeEquals(NULL_TYPE, parse("@type {null}*/").getType()); [EOL] } <line_num>: 187,189
public void testParseNullType2() throws Exception { [EOL]     assertTypeEquals(NULL_TYPE, parse("@type {Null}*/").getType()); [EOL] } <line_num>: 191,193
public void testParseAllType1() throws Exception { [EOL]     testParseType("*"); [EOL] } <line_num>: 195,197
public void testParseAllType2() throws Exception { [EOL]     testParseType("*?", "*"); [EOL] } <line_num>: 199,201
public void testParseObjectType() throws Exception { [EOL]     assertTypeEquals(OBJECT_TYPE, parse("@type {!Object}*/").getType()); [EOL] } <line_num>: 203,205
public void testParseDateType() throws Exception { [EOL]     assertTypeEquals(DATE_TYPE, parse("@type {!Date}*/").getType()); [EOL] } <line_num>: 207,209
public void testParseFunctionType() throws Exception { [EOL]     assertTypeEquals(createNullableType(U2U_CONSTRUCTOR_TYPE), parse("@type {Function}*/").getType()); [EOL] } <line_num>: 211,215
public void testParseRegExpType() throws Exception { [EOL]     assertTypeEquals(REGEXP_TYPE, parse("@type {!RegExp}*/").getType()); [EOL] } <line_num>: 217,219
public void testParseErrorTypes() throws Exception { [EOL]     assertTypeEquals(ERROR_TYPE, parse("@type {!Error}*/").getType()); [EOL]     assertTypeEquals(URI_ERROR_TYPE, parse("@type {!URIError}*/").getType()); [EOL]     assertTypeEquals(EVAL_ERROR_TYPE, parse("@type {!EvalError}*/").getType()); [EOL]     assertTypeEquals(REFERENCE_ERROR_TYPE, parse("@type {!ReferenceError}*/").getType()); [EOL]     assertTypeEquals(TYPE_ERROR_TYPE, parse("@type {!TypeError}*/").getType()); [EOL]     assertTypeEquals(RANGE_ERROR_TYPE, parse("@type {!RangeError}*/").getType()); [EOL]     assertTypeEquals(SYNTAX_ERROR_TYPE, parse("@type {!SyntaxError}*/").getType()); [EOL] } <line_num>: 221,232
public void testParseUndefinedType1() throws Exception { [EOL]     assertTypeEquals(VOID_TYPE, parse("@type {undefined}*/").getType()); [EOL] } <line_num>: 234,236
public void testParseUndefinedType2() throws Exception { [EOL]     assertTypeEquals(VOID_TYPE, parse("@type {Undefined}*/").getType()); [EOL] } <line_num>: 238,240
public void testParseUndefinedType3() throws Exception { [EOL]     assertTypeEquals(VOID_TYPE, parse("@type {void}*/").getType()); [EOL] } <line_num>: 242,244
public void testParseParametrizedType1() throws Exception { [EOL]     JSDocInfo info = parse("@type !Array.<number> */"); [EOL]     assertTypeEquals(parameterize(ARRAY_TYPE, NUMBER_TYPE), info.getType()); [EOL] } <line_num>: 246,249
public void testParseParametrizedType2() throws Exception { [EOL]     JSDocInfo info = parse("@type {!Array.<number>}*/"); [EOL]     assertTypeEquals(parameterize(ARRAY_TYPE, NUMBER_TYPE), info.getType()); [EOL] } <line_num>: 251,254
public void testParseParametrizedType3() throws Exception { [EOL]     JSDocInfo info = parse("@type !Array.<(number,null)>*/"); [EOL]     assertTypeEquals(parameterize(ARRAY_TYPE, createUnionType(NUMBER_TYPE, NULL_TYPE)), info.getType()); [EOL] } <line_num>: 256,261
public void testParseParametrizedType4() throws Exception { [EOL]     JSDocInfo info = parse("@type {!Array.<(number|null)>}*/"); [EOL]     assertTypeEquals(parameterize(ARRAY_TYPE, createUnionType(NUMBER_TYPE, NULL_TYPE)), info.getType()); [EOL] } <line_num>: 263,268
public void testParseParametrizedType5() throws Exception { [EOL]     JSDocInfo info = parse("@type {!Array.<Array.<(number|null)>>}*/"); [EOL]     assertTypeEquals(parameterize(ARRAY_TYPE, createUnionType(NULL_TYPE, parameterize(ARRAY_TYPE, createUnionType(NUMBER_TYPE, NULL_TYPE)))), info.getType()); [EOL] } <line_num>: 270,278
public void testParseParametrizedType6() throws Exception { [EOL]     JSDocInfo info = parse("@type {!Array.<!Array.<(number|null)>>}*/"); [EOL]     assertTypeEquals(parameterize(ARRAY_TYPE, parameterize(ARRAY_TYPE, createUnionType(NUMBER_TYPE, NULL_TYPE))), info.getType()); [EOL] } <line_num>: 280,287
public void testParseParametrizedType7() throws Exception { [EOL]     JSDocInfo info = parse("@type {!Array.<function():Date>}*/"); [EOL]     assertTypeEquals(parameterize(ARRAY_TYPE, registry.createFunctionType(createUnionType(DATE_TYPE, NULL_TYPE))), info.getType()); [EOL] } <line_num>: 289,296
public void testParseParametrizedType8() throws Exception { [EOL]     JSDocInfo info = parse("@type {!Array.<function():!Date>}*/"); [EOL]     assertTypeEquals(parameterize(ARRAY_TYPE, registry.createFunctionType(DATE_TYPE)), info.getType()); [EOL] } <line_num>: 298,304
public void testParseParametrizedType9() throws Exception { [EOL]     JSDocInfo info = parse("@type {!Array.<Date|number>}*/"); [EOL]     assertTypeEquals(parameterize(ARRAY_TYPE, createUnionType(DATE_TYPE, NUMBER_TYPE, NULL_TYPE)), info.getType()); [EOL] } <line_num>: 306,312
public void testParseParametrizedType10() throws Exception { [EOL]     JSDocInfo info = parse("@type {!Array.<Date|number|boolean>}*/"); [EOL]     assertTypeEquals(parameterize(ARRAY_TYPE, createUnionType(DATE_TYPE, NUMBER_TYPE, BOOLEAN_TYPE, NULL_TYPE)), info.getType()); [EOL] } <line_num>: 314,320
public void testParseParameterizedType11() throws Exception { [EOL]     JSDocInfo info = parse("@type {!Object.<number>}*/"); [EOL]     assertTypeEquals(parameterize(OBJECT_TYPE, NUMBER_TYPE), info.getType()); [EOL]     assertParameterTypeEquals(NUMBER_TYPE, info.getType()); [EOL] } <line_num>: 322,328
public void testParseParameterizedType12() throws Exception { [EOL]     JSDocInfo info = parse("@type {!Object.<string,number>}*/"); [EOL]     assertTypeEquals(parameterize(OBJECT_TYPE, NUMBER_TYPE), info.getType()); [EOL]     assertParameterTypeEquals(NUMBER_TYPE, info.getType()); [EOL]     assertIndexTypeEquals(STRING_TYPE, info.getType()); [EOL] } <line_num>: 330,336
public void testParseParametrizedType13() throws Exception { [EOL]     JSDocInfo info = parse("@type !Array.<?> */"); [EOL]     assertTypeEquals(parameterize(ARRAY_TYPE, UNKNOWN_TYPE), info.getType()); [EOL] } <line_num>: 338,341
public void testParseUnionType1() throws Exception { [EOL]     JSDocInfo info = parse("@type {(boolean,null)}*/"); [EOL]     assertTypeEquals(createUnionType(BOOLEAN_TYPE, NULL_TYPE), info.getType()); [EOL] } <line_num>: 343,346
public void testParseUnionType2() throws Exception { [EOL]     JSDocInfo info = parse("@type {boolean|null}*/"); [EOL]     assertTypeEquals(createUnionType(BOOLEAN_TYPE, NULL_TYPE), info.getType()); [EOL] } <line_num>: 348,351
public void testParseUnionType3() throws Exception { [EOL]     JSDocInfo info = parse("@type {boolean||null}*/"); [EOL]     assertTypeEquals(createUnionType(BOOLEAN_TYPE, NULL_TYPE), info.getType()); [EOL] } <line_num>: 353,356
public void testParseUnionType4() throws Exception { [EOL]     JSDocInfo info = parse("@type {(Array.<boolean>,null)}*/"); [EOL]     assertTypeEquals(createUnionType(parameterize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType()); [EOL] } <line_num>: 358,362
public void testParseUnionType5() throws Exception { [EOL]     JSDocInfo info = parse("@type {(null, Array.<boolean>)}*/"); [EOL]     assertTypeEquals(createUnionType(parameterize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType()); [EOL] } <line_num>: 364,368
public void testParseUnionType6() throws Exception { [EOL]     JSDocInfo info = parse("@type {Array.<boolean>|null}*/"); [EOL]     assertTypeEquals(createUnionType(parameterize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType()); [EOL] } <line_num>: 370,374
public void testParseUnionType7() throws Exception { [EOL]     JSDocInfo info = parse("@type {null|Array.<boolean>}*/"); [EOL]     assertTypeEquals(createUnionType(parameterize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType()); [EOL] } <line_num>: 376,380
public void testParseUnionType8() throws Exception { [EOL]     JSDocInfo info = parse("@type {null||Array.<boolean>}*/"); [EOL]     assertTypeEquals(createUnionType(parameterize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType()); [EOL] } <line_num>: 382,386
public void testParseUnionType9() throws Exception { [EOL]     JSDocInfo info = parse("@type {Array.<boolean>||null}*/"); [EOL]     assertTypeEquals(createUnionType(parameterize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType()); [EOL] } <line_num>: 388,392
public void testParseUnionType10() throws Exception { [EOL]     parse("@type {string|}*/", "Bad type annotation. type not recognized due to syntax error"); [EOL] } <line_num>: 394,397
public void testParseUnionType11() throws Exception { [EOL]     parse("@type {(string,)}*/", "Bad type annotation. type not recognized due to syntax error"); [EOL] } <line_num>: 399,402
public void testParseUnionType12() throws Exception { [EOL]     parse("@type {()}*/", "Bad type annotation. type not recognized due to syntax error"); [EOL] } <line_num>: 404,407
public void testParseUnionType13() throws Exception { [EOL]     testParseType("(function(this:Date),function(this:String):number)", "Function"); [EOL] } <line_num>: 409,413
public void testParseUnionType14() throws Exception { [EOL]     testParseType("(function(...[function(number):boolean]):number)|" + "function(this:String, string):number", "Function"); [EOL] } <line_num>: 415,420
public void testParseUnionType15() throws Exception { [EOL]     testParseType("*|number", "*"); [EOL] } <line_num>: 422,424
public void testParseUnionType16() throws Exception { [EOL]     testParseType("number|*", "*"); [EOL] } <line_num>: 426,428
public void testParseUnionType17() throws Exception { [EOL]     testParseType("string|number|*", "*"); [EOL] } <line_num>: 430,432
public void testParseUnionType18() throws Exception { [EOL]     testParseType("(string,*,number)", "*"); [EOL] } <line_num>: 434,436
public void testParseUnionTypeError1() throws Exception { [EOL]     parse("@type {(string,|number)} */", "Bad type annotation. type not recognized due to syntax error"); [EOL] } <line_num>: 438,441
public void testParseUnknownType1() throws Exception { [EOL]     testParseType("?"); [EOL] } <line_num>: 443,445
public void testParseUnknownType2() throws Exception { [EOL]     testParseType("(?|number)", "?"); [EOL] } <line_num>: 447,449
public void testParseUnknownType3() throws Exception { [EOL]     testParseType("(number|?)", "?"); [EOL] } <line_num>: 451,453
public void testParseFunctionalType1() throws Exception { [EOL]     testParseType("function (): number"); [EOL] } <line_num>: 455,457
public void testParseFunctionalType2() throws Exception { [EOL]     testParseType("function (number, string): boolean"); [EOL] } <line_num>: 459,461
public void testParseFunctionalType3() throws Exception { [EOL]     testParseType("function(this:Array)", "function (this:Array): ?"); [EOL] } <line_num>: 463,466
public void testParseFunctionalType4() throws Exception { [EOL]     testParseType("function (...[number]): boolean"); [EOL] } <line_num>: 468,470
public void testParseFunctionalType5() throws Exception { [EOL]     testParseType("function (number, ...[string]): boolean"); [EOL] } <line_num>: 472,474
public void testParseFunctionalType6() throws Exception { [EOL]     testParseType("function (this:Date, number): (boolean|number|string)"); [EOL] } <line_num>: 476,479
public void testParseFunctionalType7() throws Exception { [EOL]     testParseType("function()", "function (): ?"); [EOL] } <line_num>: 481,483
public void testParseFunctionalType8() throws Exception { [EOL]     testParseType("function(this:Array,...[boolean])", "function (this:Array, ...[boolean]): ?"); [EOL] } <line_num>: 485,489
public void testParseFunctionalType9() throws Exception { [EOL]     testParseType("function(this:Array,!Date,...[boolean?])", "function (this:Array, Date, ...[(boolean|null)]): ?"); [EOL] } <line_num>: 491,495
public void testParseFunctionalType10() throws Exception { [EOL]     testParseType("function(...[Object?]):boolean?", "function (...[(Object|null)]): (boolean|null)"); [EOL] } <line_num>: 497,501
public void testParseFunctionalType11() throws Exception { [EOL]     testParseType("function(...[[number]]):[number?]", "function (...[Array]): Array"); [EOL] } <line_num>: 503,507
public void testParseFunctionalType12() throws Exception { [EOL]     testParseType("function(...)", "function (...[?]): ?"); [EOL] } <line_num>: 509,513
public void testParseFunctionalType13() throws Exception { [EOL]     testParseType("function(...): void", "function (...[?]): undefined"); [EOL] } <line_num>: 515,519
public void testParseFunctionalType14() throws Exception { [EOL]     testParseType("function (*, string, number): boolean"); [EOL] } <line_num>: 521,523
public void testParseFunctionalType15() throws Exception { [EOL]     testParseType("function (?, string): boolean"); [EOL] } <line_num>: 525,527
public void testParseFunctionalType16() throws Exception { [EOL]     testParseType("function (string, ?): ?"); [EOL] } <line_num>: 529,531
public void testParseFunctionalType17() throws Exception { [EOL]     testParseType("(function (?): ?|number)"); [EOL] } <line_num>: 533,535
public void testParseFunctionalType18() throws Exception { [EOL]     testParseType("function (?): (?|number)", "function (?): ?"); [EOL] } <line_num>: 537,539
public void testParseFunctionalType19() throws Exception { [EOL]     testParseType("function(...[?]): void", "function (...[?]): undefined"); [EOL] } <line_num>: 541,545
public void testStructuralConstructor() throws Exception { [EOL]     JSType type = testParseType("function (new:Object)", "function (new:Object): ?"); [EOL]     assertTrue(type.isConstructor()); [EOL]     assertFalse(type.isNominalConstructor()); [EOL] } <line_num>: 547,552
public void testNominalConstructor() throws Exception { [EOL]     ObjectType type = testParseType("Array", "(Array|null)").dereference(); [EOL]     assertTrue(type.getConstructor().isNominalConstructor()); [EOL] } <line_num>: 554,557
public void testBug1419535() throws Exception { [EOL]     parse("@type {function(Object, string, *)?} */"); [EOL]     parse("@type {function(Object, string, *)|null} */"); [EOL] } <line_num>: 559,562
public void testIssue477() throws Exception { [EOL]     parse("@type function */", "Bad type annotation. missing opening ("); [EOL] } <line_num>: 564,567
public void testMalformedThisAnnotation() throws Exception { [EOL]     parse("@this */", "Bad type annotation. type not recognized due to syntax error"); [EOL] } <line_num>: 569,572
public void testParseFunctionalTypeError1() throws Exception { [EOL]     parse("@type {function number):string}*/", "Bad type annotation. missing opening ("); [EOL] } <line_num>: 574,577
public void testParseFunctionalTypeError2() throws Exception { [EOL]     parse("@type {function( number}*/", "Bad type annotation. missing closing )"); [EOL] } <line_num>: 579,582
public void testParseFunctionalTypeError3() throws Exception { [EOL]     parse("@type {function(...[number], string)}*/", "Bad type annotation. variable length argument must be last"); [EOL] } <line_num>: 584,587
public void testParseFunctionalTypeError4() throws Exception { [EOL]     parse("@type {function(string, ...[number], boolean):string}*/", "Bad type annotation. variable length argument must be last"); [EOL] } <line_num>: 589,592
public void testParseFunctionalTypeError5() throws Exception { [EOL]     parse("@type {function (thi:Array)}*/", "Bad type annotation. missing closing )"); [EOL] } <line_num>: 594,597
public void testParseFunctionalTypeError6() throws Exception { [EOL]     resolve(parse("@type {function (this:number)}*/").getType(), "this type must be an object type"); [EOL] } <line_num>: 599,602
public void testParseFunctionalTypeError7() throws Exception { [EOL]     parse("@type {function(...[number)}*/", "Bad type annotation. missing closing ]"); [EOL] } <line_num>: 604,607
public void testParseFunctionalTypeError8() throws Exception { [EOL]     parse("@type {function(...number])}*/", "Bad type annotation. missing opening ["); [EOL] } <line_num>: 609,612
public void testParseFunctionalTypeError9() throws Exception { [EOL]     parse("@type {function (new:Array, this:Object)} */", "Bad type annotation. missing closing )"); [EOL] } <line_num>: 614,617
public void testParseFunctionalTypeError10() throws Exception { [EOL]     parse("@type {function (this:Array, new:Object)} */", "Bad type annotation. missing closing )"); [EOL] } <line_num>: 619,622
public void testParseFunctionalTypeError11() throws Exception { [EOL]     parse("@type {function (Array, new:Object)} */", "Bad type annotation. missing closing )"); [EOL] } <line_num>: 624,627
public void testParseFunctionalTypeError12() throws Exception { [EOL]     resolve(parse("@type {function (new:number)}*/").getType(), "constructed type must be an object type"); [EOL] } <line_num>: 629,632
public void testParseArrayType1() throws Exception { [EOL]     testParseType("[number]", "Array"); [EOL] } <line_num>: 634,636
public void testParseArrayType2() throws Exception { [EOL]     testParseType("[(number,boolean,[Object?])]", "Array"); [EOL] } <line_num>: 638,640
public void testParseArrayType3() throws Exception { [EOL]     testParseType("[[number],[string]]?", "(Array|null)"); [EOL] } <line_num>: 642,644
public void testParseArrayTypeError1() throws Exception { [EOL]     parse("@type {[number}*/", "Bad type annotation. missing closing ]"); [EOL] } <line_num>: 646,649
public void testParseArrayTypeError2() throws Exception { [EOL]     parse("@type {number]}*/", "Bad type annotation. expected closing }"); [EOL] } <line_num>: 651,654
public void testParseArrayTypeError3() throws Exception { [EOL]     parse("@type {[(number,boolean,Object?])]}*/", "Bad type annotation. missing closing )"); [EOL] } <line_num>: 656,659
public void testParseArrayTypeError4() throws Exception { [EOL]     parse("@type {(number,boolean,[Object?)]}*/", "Bad type annotation. missing closing ]"); [EOL] } <line_num>: 661,664
private JSType testParseType(String type) throws Exception { [EOL]     return testParseType(type, type); [EOL] } <line_num>: 666,668
private JSType testParseType(String type, String typeExpected) throws Exception { [EOL]     JSDocInfo info = parse("@type {" + type + "}*/"); [EOL]     assertNotNull(info); [EOL]     assertTrue(info.hasType()); [EOL]     JSType actual = resolve(info.getType()); [EOL]     assertEquals(typeExpected, actual.toString()); [EOL]     return actual; [EOL] } <line_num>: 670,680
public void testParseNullableModifiers1() throws Exception { [EOL]     JSDocInfo info = parse("@type {string?}*/"); [EOL]     assertTypeEquals(createNullableType(STRING_TYPE), info.getType()); [EOL] } <line_num>: 682,685
public void testParseNullableModifiers2() throws Exception { [EOL]     JSDocInfo info = parse("@type {!Array.<string?>}*/"); [EOL]     assertTypeEquals(parameterize(ARRAY_TYPE, createUnionType(STRING_TYPE, NULL_TYPE)), info.getType()); [EOL] } <line_num>: 687,692
public void testParseNullableModifiers3() throws Exception { [EOL]     JSDocInfo info = parse("@type {Array.<boolean>?}*/"); [EOL]     assertTypeEquals(createNullableType(parameterize(ARRAY_TYPE, BOOLEAN_TYPE)), info.getType()); [EOL] } <line_num>: 694,699
public void testParseNullableModifiers4() throws Exception { [EOL]     JSDocInfo info = parse("@type {(string,boolean)?}*/"); [EOL]     assertTypeEquals(createNullableType(createUnionType(STRING_TYPE, BOOLEAN_TYPE)), info.getType()); [EOL] } <line_num>: 701,706
public void testParseNullableModifiers5() throws Exception { [EOL]     JSDocInfo info = parse("@type {(string?,boolean)}*/"); [EOL]     assertTypeEquals(createUnionType(createNullableType(STRING_TYPE), BOOLEAN_TYPE), info.getType()); [EOL] } <line_num>: 708,713
public void testParseNullableModifiers6() throws Exception { [EOL]     JSDocInfo info = parse("@type {(string,boolean?)}*/"); [EOL]     assertTypeEquals(createUnionType(STRING_TYPE, createNullableType(BOOLEAN_TYPE)), info.getType()); [EOL] } <line_num>: 715,720
public void testParseNullableModifiers7() throws Exception { [EOL]     JSDocInfo info = parse("@type {string?|boolean}*/"); [EOL]     assertTypeEquals(createUnionType(createNullableType(STRING_TYPE), BOOLEAN_TYPE), info.getType()); [EOL] } <line_num>: 722,727
public void testParseNullableModifiers8() throws Exception { [EOL]     JSDocInfo info = parse("@type {string|boolean?}*/"); [EOL]     assertTypeEquals(createUnionType(STRING_TYPE, createNullableType(BOOLEAN_TYPE)), info.getType()); [EOL] } <line_num>: 729,734
public void testParseNullableModifiers9() throws Exception { [EOL]     JSDocInfo info = parse("@type {foo.Hello.World?}*/"); [EOL]     assertTypeEquals(createNullableType(registry.createNamedType("foo.Hello.World", null, -1, -1)), info.getType()); [EOL] } <line_num>: 736,743
public void testParseOptionalModifier() throws Exception { [EOL]     JSDocInfo info = parse("@type {function(number=)}*/"); [EOL]     assertTypeEquals(registry.createFunctionType(UNKNOWN_TYPE, registry.createOptionalParameters(NUMBER_TYPE)), info.getType()); [EOL] } <line_num>: 745,751
public void testParseNewline1() throws Exception { [EOL]     JSDocInfo info = parse("@type {string\n* }\n*/"); [EOL]     assertTypeEquals(STRING_TYPE, info.getType()); [EOL] } <line_num>: 753,756
public void testParseNewline2() throws Exception { [EOL]     JSDocInfo info = parse("@type !Array.<\n* number\n* > */"); [EOL]     assertTypeEquals(parameterize(ARRAY_TYPE, NUMBER_TYPE), info.getType()); [EOL] } <line_num>: 758,761
public void testParseNewline3() throws Exception { [EOL]     JSDocInfo info = parse("@type !Array.<(number,\n* null)>*/"); [EOL]     assertTypeEquals(parameterize(ARRAY_TYPE, createUnionType(NUMBER_TYPE, NULL_TYPE)), info.getType()); [EOL] } <line_num>: 763,768
public void testParseNewline4() throws Exception { [EOL]     JSDocInfo info = parse("@type !Array.<(number|\n* null)>*/"); [EOL]     assertTypeEquals(parameterize(ARRAY_TYPE, createUnionType(NUMBER_TYPE, NULL_TYPE)), info.getType()); [EOL] } <line_num>: 770,775
public void testParseNewline5() throws Exception { [EOL]     JSDocInfo info = parse("@type !Array.<function(\n* )\n* :\n* Date>*/"); [EOL]     assertTypeEquals(parameterize(ARRAY_TYPE, registry.createFunctionType(createUnionType(DATE_TYPE, NULL_TYPE))), info.getType()); [EOL] } <line_num>: 777,784
public void testParseReturnType1() throws Exception { [EOL]     JSDocInfo info = parse("@return {null|string|Array.<boolean>}*/"); [EOL]     assertTypeEquals(createUnionType(parameterize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE, STRING_TYPE), info.getReturnType()); [EOL] } <line_num>: 786,793
public void testParseReturnType2() throws Exception { [EOL]     JSDocInfo info = parse("@returns {null|(string,Array.<boolean>)}*/"); [EOL]     assertTypeEquals(createUnionType(parameterize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE, STRING_TYPE), info.getReturnType()); [EOL] } <line_num>: 795,802
public void testParseReturnType3() throws Exception { [EOL]     JSDocInfo info = parse("@return {((null||Array.<boolean>,string),boolean)}*/"); [EOL]     assertTypeEquals(createUnionType(parameterize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE, STRING_TYPE, BOOLEAN_TYPE), info.getReturnType()); [EOL] } <line_num>: 804,811
public void testParseThisType1() throws Exception { [EOL]     JSDocInfo info = parse("@this {goog.foo.Bar}*/"); [EOL]     assertTypeEquals(registry.createNamedType("goog.foo.Bar", null, -1, -1), info.getThisType()); [EOL] } <line_num>: 813,819
public void testParseThisType2() throws Exception { [EOL]     JSDocInfo info = parse("@this goog.foo.Bar*/"); [EOL]     assertTypeEquals(registry.createNamedType("goog.foo.Bar", null, -1, -1), info.getThisType()); [EOL] } <line_num>: 821,827
public void testParseThisType3() throws Exception { [EOL]     parse("@type {number}\n@this goog.foo.Bar*/", "Bad type annotation. type annotation incompatible " + "with other annotations"); [EOL] } <line_num>: 829,833
public void testParseThisType4() throws Exception { [EOL]     resolve(parse("@this number*/").getThisType(), "@this must specify an object type"); [EOL] } <line_num>: 835,838
public void testParseThisType5() throws Exception { [EOL]     parse("@this {Date|Error}*/"); [EOL] } <line_num>: 840,842
public void testParseThisType6() throws Exception { [EOL]     resolve(parse("@this {Date|number}*/").getThisType(), "@this must specify an object type"); [EOL] } <line_num>: 844,847
public void testParseParam1() throws Exception { [EOL]     JSDocInfo info = parse("@param {number} index*/"); [EOL]     assertEquals(1, info.getParameterCount()); [EOL]     assertTypeEquals(NUMBER_TYPE, info.getParameterType("index")); [EOL] } <line_num>: 849,853
public void testParseParam2() throws Exception { [EOL]     JSDocInfo info = parse("@param index*/"); [EOL]     assertEquals(1, info.getParameterCount()); [EOL]     assertEquals(null, info.getParameterType("index")); [EOL] } <line_num>: 855,859
public void testParseParam3() throws Exception { [EOL]     JSDocInfo info = parse("@param {number} index useful comments*/"); [EOL]     assertEquals(1, info.getParameterCount()); [EOL]     assertTypeEquals(NUMBER_TYPE, info.getParameterType("index")); [EOL] } <line_num>: 861,865
public void testParseParam4() throws Exception { [EOL]     JSDocInfo info = parse("@param index useful comments*/"); [EOL]     assertEquals(1, info.getParameterCount()); [EOL]     assertEquals(null, info.getParameterType("index")); [EOL] } <line_num>: 867,871
public void testParseParam5() throws Exception { [EOL]     JSDocInfo info = parse("@param {number} \n index */"); [EOL]     assertEquals(1, info.getParameterCount()); [EOL]     assertTypeEquals(NUMBER_TYPE, info.getParameterType("index")); [EOL] } <line_num>: 873,878
public void testParseParam6() throws Exception { [EOL]     JSDocInfo info = parse("@param {number} \n * index */"); [EOL]     assertEquals(1, info.getParameterCount()); [EOL]     assertTypeEquals(NUMBER_TYPE, info.getParameterType("index")); [EOL] } <line_num>: 880,885
public void testParseParam7() throws Exception { [EOL]     JSDocInfo info = parse("@param {number=} index */"); [EOL]     assertTypeEquals(registry.createOptionalType(NUMBER_TYPE), info.getParameterType("index")); [EOL] } <line_num>: 887,893
public void testParseParam8() throws Exception { [EOL]     JSDocInfo info = parse("@param {...number} index */"); [EOL]     assertTypeEquals(registry.createOptionalType(NUMBER_TYPE), info.getParameterType("index")); [EOL] } <line_num>: 895,901
public void testParseParam9() throws Exception { [EOL]     parse("@param {...number=} index */", "Bad type annotation. expected closing }", "Bad type annotation. expecting a variable name in a @param tag"); [EOL] } <line_num>: 903,907
public void testParseParam10() throws Exception { [EOL]     parse("@param {...number index */", "Bad type annotation. expected closing }"); [EOL] } <line_num>: 909,912
public void testParseParam11() throws Exception { [EOL]     parse("@param {number= index */", "Bad type annotation. expected closing }"); [EOL] } <line_num>: 914,917
public void testParseParam12() throws Exception { [EOL]     JSDocInfo info = parse("@param {...number|string} index */"); [EOL]     assertTypeEquals(registry.createOptionalType(registry.createUnionType(STRING_TYPE, NUMBER_TYPE)), info.getParameterType("index")); [EOL] } <line_num>: 919,925
public void testParseParam13() throws Exception { [EOL]     JSDocInfo info = parse("@param {...(number|string)} index */"); [EOL]     assertTypeEquals(registry.createOptionalType(registry.createUnionType(STRING_TYPE, NUMBER_TYPE)), info.getParameterType("index")); [EOL] } <line_num>: 927,933
public void testParseParam14() throws Exception { [EOL]     JSDocInfo info = parse("@param {string} [index] */"); [EOL]     assertEquals(1, info.getParameterCount()); [EOL]     assertTypeEquals(registry.createOptionalType(STRING_TYPE), info.getParameterType("index")); [EOL] } <line_num>: 935,941
public void testParseParam15() throws Exception { [EOL]     JSDocInfo info = parse("@param {string} [index */", "Bad type annotation. missing closing ]"); [EOL]     assertEquals(1, info.getParameterCount()); [EOL]     assertTypeEquals(STRING_TYPE, info.getParameterType("index")); [EOL] } <line_num>: 943,948
public void testParseParam16() throws Exception { [EOL]     JSDocInfo info = parse("@param {string} index] */"); [EOL]     assertEquals(1, info.getParameterCount()); [EOL]     assertTypeEquals(STRING_TYPE, info.getParameterType("index")); [EOL] } <line_num>: 950,954
public void testParseParam17() throws Exception { [EOL]     JSDocInfo info = parse("@param {string=} [index] */"); [EOL]     assertEquals(1, info.getParameterCount()); [EOL]     assertTypeEquals(registry.createOptionalType(STRING_TYPE), info.getParameterType("index")); [EOL] } <line_num>: 956,962
public void testParseParam18() throws Exception { [EOL]     JSDocInfo info = parse("@param {...string} [index] */"); [EOL]     assertEquals(1, info.getParameterCount()); [EOL]     assertTypeEquals(registry.createOptionalType(STRING_TYPE), info.getParameterType("index")); [EOL] } <line_num>: 964,970
public void testParseParam19() throws Exception { [EOL]     JSDocInfo info = parse("@param {...} [index] */"); [EOL]     assertEquals(1, info.getParameterCount()); [EOL]     assertTypeEquals(registry.createOptionalType(UNKNOWN_TYPE), info.getParameterType("index")); [EOL]     assertTrue(info.getParameterType("index").isVarArgs()); [EOL] } <line_num>: 972,979
public void testParseParam20() throws Exception { [EOL]     JSDocInfo info = parse("@param {?=} index */"); [EOL]     assertEquals(1, info.getParameterCount()); [EOL]     assertTypeEquals(UNKNOWN_TYPE, info.getParameterType("index")); [EOL] } <line_num>: 981,986
public void testParseParam21() throws Exception { [EOL]     JSDocInfo info = parse("@param {...?} index */"); [EOL]     assertEquals(1, info.getParameterCount()); [EOL]     assertTypeEquals(UNKNOWN_TYPE, info.getParameterType("index")); [EOL]     assertTrue(info.getParameterType("index").isVarArgs()); [EOL] } <line_num>: 988,994
public void testParseThrows1() throws Exception { [EOL]     JSDocInfo info = parse("@throws {number} Some number */"); [EOL]     assertEquals(1, info.getThrownTypes().size()); [EOL]     assertTypeEquals(NUMBER_TYPE, info.getThrownTypes().get(0)); [EOL] } <line_num>: 996,1000
public void testParseThrows2() throws Exception { [EOL]     JSDocInfo info = parse("@throws {number} Some number\n " + "*@throws {String} A string */"); [EOL]     assertEquals(2, info.getThrownTypes().size()); [EOL]     assertTypeEquals(NUMBER_TYPE, info.getThrownTypes().get(0)); [EOL] } <line_num>: 1002,1007
public void testParseRecordType1() throws Exception { [EOL]     parseFull("/** @param {{x}} n\n*/"); [EOL] } <line_num>: 1009,1011
public void testParseRecordType2() throws Exception { [EOL]     parseFull("/** @param {{z, y}} n\n*/"); [EOL] } <line_num>: 1013,1015
public void testParseRecordType3() throws Exception { [EOL]     parseFull("/** @param {{z, y, x, q, hello, thisisatest}} n\n*/"); [EOL] } <line_num>: 1017,1019
public void testParseRecordType4() throws Exception { [EOL]     parseFull("/** @param {{a, 'a', 'hello', 2, this, do, while, for}} n\n*/"); [EOL] } <line_num>: 1021,1023
public void testParseRecordType5() throws Exception { [EOL]     parseFull("/** @param {{x : hello}} n\n*/"); [EOL] } <line_num>: 1025,1027
public void testParseRecordType6() throws Exception { [EOL]     parseFull("/** @param {{'x' : hello}} n\n*/"); [EOL] } <line_num>: 1029,1031
public void testParseRecordType7() throws Exception { [EOL]     parseFull("/** @param {{'x' : !hello}} n\n*/"); [EOL] } <line_num>: 1033,1035
public void testParseRecordType8() throws Exception { [EOL]     parseFull("/** @param {{'x' : !hello, y : bar}} n\n*/"); [EOL] } <line_num>: 1037,1039
public void testParseRecordType9() throws Exception { [EOL]     parseFull("/** @param {{'x' : !hello, y : {z : bar, 3 : meh}}} n\n*/"); [EOL] } <line_num>: 1041,1043
public void testParseRecordType10() throws Exception { [EOL]     parseFull("/** @param {{__proto__ : moo}} n\n*/"); [EOL] } <line_num>: 1045,1047
public void testParseRecordType11() throws Exception { [EOL]     parseFull("/** @param {{a : b} n\n*/", "Bad type annotation. expected closing }"); [EOL] } <line_num>: 1049,1052
public void testParseRecordType12() throws Exception { [EOL]     parseFull("/** @param {{!hello : hey}} n\n*/", "Bad type annotation. type not recognized due to syntax error"); [EOL] } <line_num>: 1054,1057
public void testParseRecordType13() throws Exception { [EOL]     parseFull("/** @param {{x}|number} n\n*/"); [EOL] } <line_num>: 1059,1061
public void testParseRecordType14() throws Exception { [EOL]     parseFull("/** @param {{x : y}|number} n\n*/"); [EOL] } <line_num>: 1063,1065
public void testParseRecordType15() throws Exception { [EOL]     parseFull("/** @param {{'x' : y}|number} n\n*/"); [EOL] } <line_num>: 1067,1069
public void testParseRecordType16() throws Exception { [EOL]     parseFull("/** @param {{x, y}|number} n\n*/"); [EOL] } <line_num>: 1071,1073
public void testParseRecordType17() throws Exception { [EOL]     parseFull("/** @param {{x : hello, 'y'}|number} n\n*/"); [EOL] } <line_num>: 1075,1077
public void testParseRecordType18() throws Exception { [EOL]     parseFull("/** @param {number|{x : hello, 'y'}} n\n*/"); [EOL] } <line_num>: 1079,1081
public void testParseRecordType19() throws Exception { [EOL]     parseFull("/** @param {?{x : hello, 'y'}} n\n*/"); [EOL] } <line_num>: 1083,1085
public void testParseRecordType20() throws Exception { [EOL]     parseFull("/** @param {!{x : hello, 'y'}} n\n*/"); [EOL] } <line_num>: 1087,1089
public void testParseRecordType21() throws Exception { [EOL]     parseFull("/** @param {{x : hello, 'y'}|boolean} n\n*/"); [EOL] } <line_num>: 1091,1093
public void testParseRecordType22() throws Exception { [EOL]     parseFull("/** @param {{x : hello, 'y'}|function()} n\n*/"); [EOL] } <line_num>: 1095,1097
public void testParseRecordType23() throws Exception { [EOL]     parseFull("/** @param {{x : function(), 'y'}|function()} n\n*/"); [EOL] } <line_num>: 1099,1101
public void testParseParamError1() throws Exception { [EOL]     parseFull("/** @param\n*/", "Bad type annotation. expecting a variable name in a @param tag"); [EOL] } <line_num>: 1103,1106
public void testParseParamError2() throws Exception { [EOL]     parseFull("/** @param {Number}*/", "Bad type annotation. expecting a variable name in a @param tag"); [EOL] } <line_num>: 1108,1111
public void testParseParamError3() throws Exception { [EOL]     parseFull("/** @param {Number}\n*/", "Bad type annotation. expecting a variable name in a @param tag"); [EOL] } <line_num>: 1113,1116
public void testParseParamError4() throws Exception { [EOL]     parseFull("/** @param {Number}\n* * num */", "Bad type annotation. expecting a variable name in a @param tag"); [EOL] } <line_num>: 1118,1121
public void testParseParamError5() throws Exception { [EOL]     parse("@param {number} x \n * @param {string} x */", "Bad type annotation. duplicate variable name \"x\""); [EOL] } <line_num>: 1123,1126
public void testParseExtends1() throws Exception { [EOL]     assertTypeEquals(STRING_OBJECT_TYPE, parse("@extends String*/").getBaseType()); [EOL] } <line_num>: 1128,1131
public void testParseExtends2() throws Exception { [EOL]     JSDocInfo info = parse("@extends com.google.Foo.Bar.Hello.World*/"); [EOL]     assertTypeEquals(registry.createNamedType("com.google.Foo.Bar.Hello.World", null, -1, -1), info.getBaseType()); [EOL] } <line_num>: 1133,1139
public void testParseExtendsGenerics() throws Exception { [EOL]     JSDocInfo info = parse("@extends com.google.Foo.Bar.Hello.World.<Boolean,number>*/"); [EOL]     assertTypeEquals(registry.createNamedType("com.google.Foo.Bar.Hello.World", null, -1, -1), info.getBaseType()); [EOL] } <line_num>: 1141,1148
public void testParseImplementsGenerics() throws Exception { [EOL]     List<JSTypeExpression> interfaces = parse("@implements {SomeInterface.<*>} */").getImplementedInterfaces(); [EOL]     assertEquals(1, interfaces.size()); [EOL]     assertTypeEquals(registry.createNamedType("SomeInterface", null, -1, -1), interfaces.get(0)); [EOL] } <line_num>: 1150,1158
public void testParseExtends4() throws Exception { [EOL]     assertTypeEquals(STRING_OBJECT_TYPE, parse("@extends {String}*/").getBaseType()); [EOL] } <line_num>: 1160,1163
public void testParseExtends5() throws Exception { [EOL]     assertTypeEquals(STRING_OBJECT_TYPE, parse("@extends {String*/", "Bad type annotation. expected closing }").getBaseType()); [EOL] } <line_num>: 1165,1169
public void testParseExtends6() throws Exception { [EOL]     assertTypeEquals(STRING_OBJECT_TYPE, parse("@extends \n * {String}*/").getBaseType()); [EOL] } <line_num>: 1171,1175
public void testParseExtendsInvalidName() throws Exception { [EOL]     assertTypeEquals(registry.createNamedType("some_++#%$%_UglyString", null, -1, -1), parse("@extends {some_++#%$%_UglyString} */").getBaseType()); [EOL] } <line_num>: 1177,1185
public void testParseExtendsNullable1() throws Exception { [EOL]     parse("@extends {Base?} */", "Bad type annotation. expected closing }"); [EOL] } <line_num>: 1187,1189
public void testParseExtendsNullable2() throws Exception { [EOL]     parse("@extends Base? */", "Bad type annotation. expected end of line or comment"); [EOL] } <line_num>: 1191,1194
public void testParseEnum1() throws Exception { [EOL]     assertTypeEquals(NUMBER_TYPE, parse("@enum*/").getEnumParameterType()); [EOL] } <line_num>: 1196,1198
public void testParseEnum2() throws Exception { [EOL]     assertTypeEquals(STRING_TYPE, parse("@enum {string}*/").getEnumParameterType()); [EOL] } <line_num>: 1200,1203
public void testParseEnum3() throws Exception { [EOL]     assertTypeEquals(STRING_TYPE, parse("@enum string*/").getEnumParameterType()); [EOL] } <line_num>: 1205,1208
public void testParseDesc1() throws Exception { [EOL]     assertEquals("hello world!", parse("@desc hello world!*/").getDescription()); [EOL] } <line_num>: 1210,1213
public void testParseDesc2() throws Exception { [EOL]     assertEquals("hello world!", parse("@desc hello world!\n*/").getDescription()); [EOL] } <line_num>: 1215,1218
public void testParseDesc3() throws Exception { [EOL]     assertEquals("", parse("@desc*/").getDescription()); [EOL] } <line_num>: 1220,1222
public void testParseDesc4() throws Exception { [EOL]     assertEquals("", parse("@desc\n*/").getDescription()); [EOL] } <line_num>: 1224,1226
public void testParseDesc5() throws Exception { [EOL]     assertEquals("hello world!", parse("@desc hello\nworld!\n*/").getDescription()); [EOL] } <line_num>: 1228,1231
public void testParseDesc6() throws Exception { [EOL]     assertEquals("hello world!", parse("@desc hello\n* world!\n*/").getDescription()); [EOL] } <line_num>: 1233,1236
public void testParseDesc7() throws Exception { [EOL]     assertEquals("a b c", parse("@desc a\n\nb\nc*/").getDescription()); [EOL] } <line_num>: 1238,1240
public void testParseDesc8() throws Exception { [EOL]     assertEquals("a b c d", parse("@desc a\n      *b\n\n  *c\n\nd*/").getDescription()); [EOL] } <line_num>: 1242,1245
public void testParseDesc9() throws Exception { [EOL]     String comment = "@desc\n.\n,\n{\n)\n}\n|\n.<\n>\n<\n?\n~\n+\n-\n;\n:\n*/"; [EOL]     assertEquals(". , { ) } | .< > < ? ~ + - ; :", parse(comment).getDescription()); [EOL] } <line_num>: 1247,1252
public void testParseDesc10() throws Exception { [EOL]     String comment = "@desc\n?\n?\n?\n?*/"; [EOL]     assertEquals("? ? ? ?", parse(comment).getDescription()); [EOL] } <line_num>: 1254,1258
public void testParseDesc11() throws Exception { [EOL]     String comment = "@desc :[]*/"; [EOL]     assertEquals(":[]", parse(comment).getDescription()); [EOL] } <line_num>: 1260,1264
public void testParseDesc12() throws Exception { [EOL]     String comment = "@desc\n:\n[\n]\n...*/"; [EOL]     assertEquals(": [ ] ...", parse(comment).getDescription()); [EOL] } <line_num>: 1266,1270
public void testParseMeaning1() throws Exception { [EOL]     assertEquals("tigers", parse("@meaning tigers   */").getMeaning()); [EOL] } <line_num>: 1272,1275
public void testParseMeaning2() throws Exception { [EOL]     assertEquals("tigers and lions and bears", parse("@meaning tigers\n * and lions\n * and bears */").getMeaning()); [EOL] } <line_num>: 1277,1280
public void testParseMeaning3() throws Exception { [EOL]     JSDocInfo info = parse("@meaning  tigers\n * and lions\n * @desc  and bears */"); [EOL]     assertEquals("tigers and lions", info.getMeaning()); [EOL]     assertEquals("and bears", info.getDescription()); [EOL] } <line_num>: 1282,1287
public void testParseMeaning4() throws Exception { [EOL]     parse("@meaning  tigers\n * @meaning and lions  */", "extra @meaning tag"); [EOL] } <line_num>: 1289,1292
public void testParseLends1() throws Exception { [EOL]     JSDocInfo info = parse("@lends {name} */"); [EOL]     assertEquals("name", info.getLendsName()); [EOL] } <line_num>: 1294,1297
public void testParseLends2() throws Exception { [EOL]     JSDocInfo info = parse("@lends   foo.bar  */"); [EOL]     assertEquals("foo.bar", info.getLendsName()); [EOL] } <line_num>: 1299,1302
public void testParseLends3() throws Exception { [EOL]     parse("@lends {name */", "Bad type annotation. expected closing }"); [EOL] } <line_num>: 1304,1306
public void testParseLends4() throws Exception { [EOL]     parse("@lends {} */", "Bad type annotation. missing object name in @lends tag"); [EOL] } <line_num>: 1308,1311
public void testParseLends5() throws Exception { [EOL]     parse("@lends } */", "Bad type annotation. missing object name in @lends tag"); [EOL] } <line_num>: 1313,1316
public void testParseLends6() throws Exception { [EOL]     parse("@lends {string} \n * @lends {string} */", "Bad type annotation. @lends tag incompatible with other annotations"); [EOL] } <line_num>: 1318,1321
public void testParseLends7() throws Exception { [EOL]     parse("@type {string} \n * @lends {string} */", "Bad type annotation. @lends tag incompatible with other annotations"); [EOL] } <line_num>: 1323,1326
public void testParsePreserve() throws Exception { [EOL]     Node node = new Node(1); [EOL]     this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode(); [EOL]     String comment = "@preserve Foo\nBar\n\nBaz*/"; [EOL]     parse(comment); [EOL]     assertEquals(" Foo\nBar\n\nBaz", node.getJSDocInfo().getLicense()); [EOL] } <line_num>: 1328,1334
public void testParseLicense() throws Exception { [EOL]     Node node = new Node(1); [EOL]     this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode(); [EOL]     String comment = "@license Foo\nBar\n\nBaz*/"; [EOL]     parse(comment); [EOL]     assertEquals(" Foo\nBar\n\nBaz", node.getJSDocInfo().getLicense()); [EOL] } <line_num>: 1336,1342
public void testParseLicenseAscii() throws Exception { [EOL]     Node node = new Node(1); [EOL]     this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode(); [EOL]     String comment = "@license Foo\n *   Bar\n\n  Baz*/"; [EOL]     parse(comment); [EOL]     assertEquals(" Foo\n   Bar\n\n  Baz", node.getJSDocInfo().getLicense()); [EOL] } <line_num>: 1344,1350
public void testParseLicenseWithAnnotation() throws Exception { [EOL]     Node node = new Node(1); [EOL]     this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode(); [EOL]     String comment = "@license Foo \n * @author Charlie Brown */"; [EOL]     parse(comment); [EOL]     assertEquals(" Foo \n @author Charlie Brown ", node.getJSDocInfo().getLicense()); [EOL] } <line_num>: 1352,1359
public void testParseDefine1() throws Exception { [EOL]     assertTypeEquals(STRING_TYPE, parse("@define {string}*/").getType()); [EOL] } <line_num>: 1361,1364
public void testParseDefine2() throws Exception { [EOL]     assertTypeEquals(STRING_TYPE, parse("@define {string*/", "Bad type annotation. expected closing }").getType()); [EOL] } <line_num>: 1366,1370
public void testParseDefine3() throws Exception { [EOL]     JSDocInfo info = parse("@define {boolean}*/"); [EOL]     assertTrue(info.isConstant()); [EOL]     assertTrue(info.isDefine()); [EOL]     assertTypeEquals(BOOLEAN_TYPE, info.getType()); [EOL] } <line_num>: 1372,1377
public void testParseDefine4() throws Exception { [EOL]     assertTypeEquals(NUMBER_TYPE, parse("@define {number}*/").getType()); [EOL] } <line_num>: 1379,1381
public void testParseDefine5() throws Exception { [EOL]     assertTypeEquals(createUnionType(NUMBER_TYPE, BOOLEAN_TYPE), parse("@define {number|boolean}*/").getType()); [EOL] } <line_num>: 1383,1386
public void testParseDefineErrors1() throws Exception { [EOL]     parse("@enum {string}\n @define {string} */", "conflicting @define tag"); [EOL] } <line_num>: 1388,1390
public void testParseDefineErrors2() throws Exception { [EOL]     parse("@define {string}\n @enum {string} */", "Bad type annotation. " + "type annotation incompatible with other annotations"); [EOL] } <line_num>: 1392,1396
public void testParseDefineErrors3() throws Exception { [EOL]     parse("@const\n @define {string} */", "conflicting @define tag"); [EOL] } <line_num>: 1398,1400
public void testParseDefineErrors4() throws Exception { [EOL]     parse("@type string \n @define {string} */", "conflicting @define tag"); [EOL] } <line_num>: 1402,1404
public void testParseDefineErrors5() throws Exception { [EOL]     parse("@return {string}\n @define {string} */", "conflicting @define tag"); [EOL] } <line_num>: 1406,1408
public void testParseDefineErrors7() throws Exception { [EOL]     parse("@define {string}\n @const */", "conflicting @const tag"); [EOL] } <line_num>: 1410,1412
public void testParseDefineErrors8() throws Exception { [EOL]     parse("@define {string}\n @type string */", "Bad type annotation. " + "type annotation incompatible with other annotations"); [EOL] } <line_num>: 1414,1418
public void testParseNoCheck1() throws Exception { [EOL]     assertTrue(parse("@notypecheck*/").isNoTypeCheck()); [EOL] } <line_num>: 1420,1422
public void testParseNoCheck2() throws Exception { [EOL]     parse("@notypecheck\n@notypecheck*/", "extra @notypecheck tag"); [EOL] } <line_num>: 1424,1426
public void testParseOverride1() throws Exception { [EOL]     assertTrue(parse("@override*/").isOverride()); [EOL] } <line_num>: 1428,1430
public void testParseOverride2() throws Exception { [EOL]     parse("@override\n@override*/", "Bad type annotation. extra @override/@inheritDoc tag"); [EOL] } <line_num>: 1432,1435
public void testParseInheritDoc1() throws Exception { [EOL]     assertTrue(parse("@inheritDoc*/").isOverride()); [EOL] } <line_num>: 1437,1439
public void testParseInheritDoc2() throws Exception { [EOL]     parse("@override\n@inheritDoc*/", "Bad type annotation. extra @override/@inheritDoc tag"); [EOL] } <line_num>: 1441,1444
public void testParseInheritDoc3() throws Exception { [EOL]     parse("@inheritDoc\n@inheritDoc*/", "Bad type annotation. extra @override/@inheritDoc tag"); [EOL] } <line_num>: 1446,1449
public void testParseNoAlias1() throws Exception { [EOL]     assertTrue(parse("@noalias*/").isNoAlias()); [EOL] } <line_num>: 1451,1453
public void testParseNoAlias2() throws Exception { [EOL]     parse("@noalias\n@noalias*/", "extra @noalias tag"); [EOL] } <line_num>: 1455,1457
public void testParseDeprecated1() throws Exception { [EOL]     assertTrue(parse("@deprecated*/").isDeprecated()); [EOL] } <line_num>: 1459,1461
public void testParseDeprecated2() throws Exception { [EOL]     parse("@deprecated\n@deprecated*/", "extra @deprecated tag"); [EOL] } <line_num>: 1463,1465
public void testParseExport1() throws Exception { [EOL]     assertTrue(parse("@export*/").isExport()); [EOL] } <line_num>: 1467,1469
public void testParseExport2() throws Exception { [EOL]     parse("@export\n@export*/", "extra @export tag"); [EOL] } <line_num>: 1471,1473
public void testParseExpose1() throws Exception { [EOL]     assertTrue(parse("@expose*/").isExpose()); [EOL] } <line_num>: 1475,1477
public void testParseExpose2() throws Exception { [EOL]     parse("@expose\n@expose*/", "extra @expose tag"); [EOL] } <line_num>: 1479,1481
public void testParseExterns1() throws Exception { [EOL]     assertTrue(parseFileOverview("@externs*/").isExterns()); [EOL] } <line_num>: 1483,1485
public void testParseExterns2() throws Exception { [EOL]     parseFileOverview("@externs\n@externs*/", "extra @externs tag"); [EOL] } <line_num>: 1487,1489
public void testParseExterns3() throws Exception { [EOL]     assertNull(parse("@externs*/")); [EOL] } <line_num>: 1491,1493
public void testParseJavaDispatch1() throws Exception { [EOL]     assertTrue(parse("@javadispatch*/").isJavaDispatch()); [EOL] } <line_num>: 1495,1497
public void testParseJavaDispatch2() throws Exception { [EOL]     parse("@javadispatch\n@javadispatch*/", "extra @javadispatch tag"); [EOL] } <line_num>: 1499,1502
public void testParseJavaDispatch3() throws Exception { [EOL]     assertNull(parseFileOverview("@javadispatch*/")); [EOL] } <line_num>: 1504,1506
public void testParseNoCompile1() throws Exception { [EOL]     assertTrue(parseFileOverview("@nocompile*/").isNoCompile()); [EOL] } <line_num>: 1508,1510
public void testParseNoCompile2() throws Exception { [EOL]     parseFileOverview("@nocompile\n@nocompile*/", "extra @nocompile tag"); [EOL] } <line_num>: 1512,1514
public void testBugAnnotation() throws Exception { [EOL]     parse("@bug */"); [EOL] } <line_num>: 1516,1518
public void testDescriptionAnnotation() throws Exception { [EOL]     parse("@description */"); [EOL] } <line_num>: 1520,1522
public void testRegression1() throws Exception { [EOL]     String comment = " * @param {number} index the index of blah\n" + " * @return {boolean} whatever\n" + " * @private\n" + " */"; [EOL]     JSDocInfo info = parse(comment); [EOL]     assertEquals(1, info.getParameterCount()); [EOL]     assertTypeEquals(NUMBER_TYPE, info.getParameterType("index")); [EOL]     assertTypeEquals(BOOLEAN_TYPE, info.getReturnType()); [EOL]     assertEquals(Visibility.PRIVATE, info.getVisibility()); [EOL] } <line_num>: 1524,1536
public void testRegression2() throws Exception { [EOL]     String comment = " * @return {boolean} whatever\n" + " * but important\n" + " *\n" + " * @param {number} index the index of blah\n" + " * some more comments here\n" + " * @param name the name of the guy\n" + " *\n" + " * @protected\n" + " */"; [EOL]     JSDocInfo info = parse(comment); [EOL]     assertEquals(2, info.getParameterCount()); [EOL]     assertTypeEquals(NUMBER_TYPE, info.getParameterType("index")); [EOL]     assertEquals(null, info.getParameterType("name")); [EOL]     assertTypeEquals(BOOLEAN_TYPE, info.getReturnType()); [EOL]     assertEquals(Visibility.PROTECTED, info.getVisibility()); [EOL] } <line_num>: 1538,1556
public void testRegression3() throws Exception { [EOL]     String comment = " * @param mediaTag this specified whether the @media tag is ....\n" + " *\n" + "\n" + "@public\n" + " *\n" + "\n" + " **********\n" + " * @final\n" + " */"; [EOL]     JSDocInfo info = parse(comment); [EOL]     assertEquals(1, info.getParameterCount()); [EOL]     assertEquals(null, info.getParameterType("mediaTag")); [EOL]     assertEquals(Visibility.PUBLIC, info.getVisibility()); [EOL]     assertTrue(info.isConstant()); [EOL] } <line_num>: 1558,1575
public void testRegression4() throws Exception { [EOL]     String comment = " * @const\n" + " * @hidden\n" + " * @preserveTry\n" + " * @constructor\n" + " */"; [EOL]     JSDocInfo info = parse(comment); [EOL]     assertTrue(info.isConstant()); [EOL]     assertFalse(info.isDefine()); [EOL]     assertTrue(info.isConstructor()); [EOL]     assertTrue(info.isHidden()); [EOL]     assertTrue(info.shouldPreserveTry()); [EOL] } <line_num>: 1577,1591
public void testRegression5() throws Exception { [EOL]     String comment = "@const\n@enum {string}\n@public*/"; [EOL]     JSDocInfo info = parse(comment); [EOL]     assertTrue(info.isConstant()); [EOL]     assertFalse(info.isDefine()); [EOL]     assertTypeEquals(STRING_TYPE, info.getEnumParameterType()); [EOL]     assertEquals(Visibility.PUBLIC, info.getVisibility()); [EOL] } <line_num>: 1593,1601
public void testRegression6() throws Exception { [EOL]     String comment = "@hidden\n@enum\n@public*/"; [EOL]     JSDocInfo info = parse(comment); [EOL]     assertTrue(info.isHidden()); [EOL]     assertTypeEquals(NUMBER_TYPE, info.getEnumParameterType()); [EOL]     assertEquals(Visibility.PUBLIC, info.getVisibility()); [EOL] } <line_num>: 1603,1610
public void testRegression7() throws Exception { [EOL]     String comment = " * @desc description here\n" + " * @param {boolean} flag and some more description\n" + " *     nicely formatted\n" + " */"; [EOL]     JSDocInfo info = parse(comment); [EOL]     assertEquals(1, info.getParameterCount()); [EOL]     assertTypeEquals(BOOLEAN_TYPE, info.getParameterType("flag")); [EOL]     assertEquals("description here", info.getDescription()); [EOL] } <line_num>: 1612,1623
public void testRegression8() throws Exception { [EOL]     String comment = " * @name random tag here\n" + " * @desc description here\n" + " *\n" + " * @param {boolean} flag and some more description\n" + " *     nicely formatted\n" + " */"; [EOL]     JSDocInfo info = parse(comment); [EOL]     assertEquals(1, info.getParameterCount()); [EOL]     assertTypeEquals(BOOLEAN_TYPE, info.getParameterType("flag")); [EOL]     assertEquals("description here", info.getDescription()); [EOL] } <line_num>: 1625,1638
public void testRegression9() throws Exception { [EOL]     JSDocInfo jsdoc = parse(" * @param {string} p0 blah blah blah\n" + " */"); [EOL]     assertNull(jsdoc.getBaseType()); [EOL]     assertFalse(jsdoc.isConstant()); [EOL]     assertNull(jsdoc.getDescription()); [EOL]     assertNull(jsdoc.getEnumParameterType()); [EOL]     assertFalse(jsdoc.isHidden()); [EOL]     assertEquals(1, jsdoc.getParameterCount()); [EOL]     assertTypeEquals(STRING_TYPE, jsdoc.getParameterType("p0")); [EOL]     assertNull(jsdoc.getReturnType()); [EOL]     assertNull(jsdoc.getType()); [EOL]     assertEquals(Visibility.INHERITED, jsdoc.getVisibility()); [EOL] } <line_num>: 1640,1655
public void testRegression10() throws Exception { [EOL]     JSDocInfo jsdoc = parse(" * @param {!String} p0 blah blah blah\n" + " * @param {boolean} p1 fobar\n" + " * @return {!Date} jksjkash dshad\n" + " */"); [EOL]     assertNull(jsdoc.getBaseType()); [EOL]     assertFalse(jsdoc.isConstant()); [EOL]     assertNull(jsdoc.getDescription()); [EOL]     assertNull(jsdoc.getEnumParameterType()); [EOL]     assertFalse(jsdoc.isHidden()); [EOL]     assertEquals(2, jsdoc.getParameterCount()); [EOL]     assertTypeEquals(STRING_OBJECT_TYPE, jsdoc.getParameterType("p0")); [EOL]     assertTypeEquals(BOOLEAN_TYPE, jsdoc.getParameterType("p1")); [EOL]     assertTypeEquals(DATE_TYPE, jsdoc.getReturnType()); [EOL]     assertNull(jsdoc.getType()); [EOL]     assertEquals(Visibility.INHERITED, jsdoc.getVisibility()); [EOL] } <line_num>: 1657,1675
public void testRegression11() throws Exception { [EOL]     JSDocInfo jsdoc = parse(" * @constructor\n" + " */"); [EOL]     assertNull(jsdoc.getBaseType()); [EOL]     assertFalse(jsdoc.isConstant()); [EOL]     assertNull(jsdoc.getDescription()); [EOL]     assertNull(jsdoc.getEnumParameterType()); [EOL]     assertFalse(jsdoc.isHidden()); [EOL]     assertEquals(0, jsdoc.getParameterCount()); [EOL]     assertNull(jsdoc.getReturnType()); [EOL]     assertNull(jsdoc.getType()); [EOL]     assertEquals(Visibility.INHERITED, jsdoc.getVisibility()); [EOL] } <line_num>: 1677,1691
public void testRegression12() throws Exception { [EOL]     JSDocInfo jsdoc = parse(" * @extends FooBar\n" + " */"); [EOL]     assertTypeEquals(registry.createNamedType("FooBar", null, 0, 0), jsdoc.getBaseType()); [EOL]     assertFalse(jsdoc.isConstant()); [EOL]     assertNull(jsdoc.getDescription()); [EOL]     assertNull(jsdoc.getEnumParameterType()); [EOL]     assertFalse(jsdoc.isHidden()); [EOL]     assertEquals(0, jsdoc.getParameterCount()); [EOL]     assertNull(jsdoc.getReturnType()); [EOL]     assertNull(jsdoc.getType()); [EOL]     assertEquals(Visibility.INHERITED, jsdoc.getVisibility()); [EOL] } <line_num>: 1693,1708
public void testRegression13() throws Exception { [EOL]     JSDocInfo jsdoc = parse(" * @type {!RegExp}\n" + " * @protected\n" + " */"); [EOL]     assertNull(jsdoc.getBaseType()); [EOL]     assertFalse(jsdoc.isConstant()); [EOL]     assertNull(jsdoc.getDescription()); [EOL]     assertNull(jsdoc.getEnumParameterType()); [EOL]     assertFalse(jsdoc.isHidden()); [EOL]     assertEquals(0, jsdoc.getParameterCount()); [EOL]     assertNull(jsdoc.getReturnType()); [EOL]     assertTypeEquals(REGEXP_TYPE, jsdoc.getType()); [EOL]     assertEquals(Visibility.PROTECTED, jsdoc.getVisibility()); [EOL] } <line_num>: 1710,1725
public void testRegression14() throws Exception { [EOL]     JSDocInfo jsdoc = parse(" * @const\n" + " * @private\n" + " */"); [EOL]     assertNull(jsdoc.getBaseType()); [EOL]     assertTrue(jsdoc.isConstant()); [EOL]     assertNull(jsdoc.getDescription()); [EOL]     assertNull(jsdoc.getEnumParameterType()); [EOL]     assertFalse(jsdoc.isHidden()); [EOL]     assertEquals(0, jsdoc.getParameterCount()); [EOL]     assertNull(jsdoc.getReturnType()); [EOL]     assertNull(jsdoc.getType()); [EOL]     assertEquals(Visibility.PRIVATE, jsdoc.getVisibility()); [EOL] } <line_num>: 1727,1742
public void testRegression15() throws Exception { [EOL]     JSDocInfo jsdoc = parse(" * @desc Hello,\n" + " * World!\n" + " */"); [EOL]     assertNull(jsdoc.getBaseType()); [EOL]     assertFalse(jsdoc.isConstant()); [EOL]     assertEquals("Hello, World!", jsdoc.getDescription()); [EOL]     assertNull(jsdoc.getEnumParameterType()); [EOL]     assertFalse(jsdoc.isHidden()); [EOL]     assertEquals(0, jsdoc.getParameterCount()); [EOL]     assertNull(jsdoc.getReturnType()); [EOL]     assertNull(jsdoc.getType()); [EOL]     assertEquals(Visibility.INHERITED, jsdoc.getVisibility()); [EOL]     assertFalse(jsdoc.isExport()); [EOL] } <line_num>: 1744,1760
public void testRegression16() throws Exception { [EOL]     JSDocInfo jsdoc = parse(" Email is plp@foo.bar\n" + " @type {string}\n" + " */"); [EOL]     assertNull(jsdoc.getBaseType()); [EOL]     assertFalse(jsdoc.isConstant()); [EOL]     assertTypeEquals(STRING_TYPE, jsdoc.getType()); [EOL]     assertFalse(jsdoc.isHidden()); [EOL]     assertEquals(0, jsdoc.getParameterCount()); [EOL]     assertNull(jsdoc.getReturnType()); [EOL]     assertEquals(Visibility.INHERITED, jsdoc.getVisibility()); [EOL] } <line_num>: 1762,1775
public void testRegression17() throws Exception { [EOL]     assertNull(parse("@private*/").getDescription()); [EOL] } <line_num>: 1777,1780
public void testFullRegression1() throws Exception { [EOL]     parseFull("/** @param (string,number) foo*/function bar(foo){}", "Bad type annotation. expecting a variable name in a @param tag"); [EOL] } <line_num>: 1782,1785
public void testFullRegression2() throws Exception { [EOL]     parseFull("/** @param {string,number) foo*/function bar(foo){}", "Bad type annotation. expected closing }", "Bad type annotation. expecting a variable name in a @param tag"); [EOL] } <line_num>: 1787,1791
public void testFullRegression3() throws Exception { [EOL]     parseFull("/**..\n*/"); [EOL] } <line_num>: 1793,1795
public void testBug907488() throws Exception { [EOL]     parse("@type {number,null} */", "Bad type annotation. expected closing }"); [EOL] } <line_num>: 1797,1800
public void testBug907494() throws Exception { [EOL]     parse("@return {Object,undefined} */", "Bad type annotation. expected closing }"); [EOL] } <line_num>: 1802,1805
public void testBug909468() throws Exception { [EOL]     parse("@extends {(x)}*/", "Bad type annotation. expecting a type name"); [EOL] } <line_num>: 1807,1810
public void testParseInterface() throws Exception { [EOL]     assertTrue(parse("@interface*/").isInterface()); [EOL] } <line_num>: 1812,1814
public void testParseImplicitCast1() throws Exception { [EOL]     assertTrue(parse("@type {string} \n * @implicitCast*/").isImplicitCast()); [EOL] } <line_num>: 1816,1818
public void testParseImplicitCast2() throws Exception { [EOL]     assertFalse(parse("@type {string}*/").isImplicitCast()); [EOL] } <line_num>: 1820,1822
public void testParseDuplicateImplicitCast() throws Exception { [EOL]     parse("@type {string} \n * @implicitCast \n * @implicitCast*/", "Bad type annotation. extra @implicitCast tag"); [EOL] } <line_num>: 1824,1827
public void testParseInterfaceDoubled() throws Exception { [EOL]     parse("* @interface\n" + "* @interface\n" + "*/", "Bad type annotation. " + "type annotation incompatible with other annotations"); [EOL] } <line_num>: 1829,1836
public void testParseImplements() throws Exception { [EOL]     List<JSTypeExpression> interfaces = parse("@implements {SomeInterface}*/").getImplementedInterfaces(); [EOL]     assertEquals(1, interfaces.size()); [EOL]     assertTypeEquals(registry.createNamedType("SomeInterface", null, -1, -1), interfaces.get(0)); [EOL] } <line_num>: 1838,1844
public void testParseImplementsTwo() throws Exception { [EOL]     List<JSTypeExpression> interfaces = parse("* @implements {SomeInterface1}\n" + "* @implements {SomeInterface2}\n" + "*/").getImplementedInterfaces(); [EOL]     assertEquals(2, interfaces.size()); [EOL]     assertTypeEquals(registry.createNamedType("SomeInterface1", null, -1, -1), interfaces.get(0)); [EOL]     assertTypeEquals(registry.createNamedType("SomeInterface2", null, -1, -1), interfaces.get(1)); [EOL] } <line_num>: 1846,1858
public void testParseImplementsSameTwice() throws Exception { [EOL]     parse("* @implements {Smth}\n" + "* @implements {Smth}\n" + "*/", "Bad type annotation. duplicate @implements tag"); [EOL] } <line_num>: 1860,1866
public void testParseImplementsNoName() throws Exception { [EOL]     parse("* @implements {} */", "Bad type annotation. expecting a type name"); [EOL] } <line_num>: 1868,1871
public void testParseImplementsMissingRC() throws Exception { [EOL]     parse("* @implements {Smth */", "Bad type annotation. expected closing }"); [EOL] } <line_num>: 1873,1876
public void testParseImplementsNullable1() throws Exception { [EOL]     parse("@implements {Base?} */", "Bad type annotation. expected closing }"); [EOL] } <line_num>: 1878,1880
public void testParseImplementsNullable2() throws Exception { [EOL]     parse("@implements Base? */", "Bad type annotation. expected end of line or comment"); [EOL] } <line_num>: 1882,1885
public void testInterfaceExtends() throws Exception { [EOL]     JSDocInfo jsdoc = parse(" * @interface \n" + " * @extends {Extended} */"); [EOL]     assertTrue(jsdoc.isInterface()); [EOL]     assertEquals(1, jsdoc.getExtendedInterfacesCount()); [EOL]     List<JSTypeExpression> types = jsdoc.getExtendedInterfaces(); [EOL]     assertTypeEquals(registry.createNamedType("Extended", null, -1, -1), types.get(0)); [EOL] } <line_num>: 1887,1896
public void testInterfaceMultiExtends1() throws Exception { [EOL]     JSDocInfo jsdoc = parse(" * @interface \n" + " * @extends {Extended1} \n" + " * @extends {Extended2} */"); [EOL]     assertTrue(jsdoc.isInterface()); [EOL]     assertNull(jsdoc.getBaseType()); [EOL]     assertEquals(2, jsdoc.getExtendedInterfacesCount()); [EOL]     List<JSTypeExpression> types = jsdoc.getExtendedInterfaces(); [EOL]     assertTypeEquals(registry.createNamedType("Extended1", null, -1, -1), types.get(0)); [EOL]     assertTypeEquals(registry.createNamedType("Extended2", null, -1, -1), types.get(1)); [EOL] } <line_num>: 1898,1911
public void testInterfaceMultiExtends2() throws Exception { [EOL]     JSDocInfo jsdoc = parse(" * @extends {Extended1} \n" + " * @interface \n" + " * @extends {Extended2} \n" + " * @extends {Extended3} */"); [EOL]     assertTrue(jsdoc.isInterface()); [EOL]     assertNull(jsdoc.getBaseType()); [EOL]     assertEquals(3, jsdoc.getExtendedInterfacesCount()); [EOL]     List<JSTypeExpression> types = jsdoc.getExtendedInterfaces(); [EOL]     assertTypeEquals(registry.createNamedType("Extended1", null, -1, -1), types.get(0)); [EOL]     assertTypeEquals(registry.createNamedType("Extended2", null, -1, -1), types.get(1)); [EOL]     assertTypeEquals(registry.createNamedType("Extended3", null, -1, -1), types.get(2)); [EOL] } <line_num>: 1913,1929
public void testBadClassMultiExtends() throws Exception { [EOL]     parse(" * @extends {Extended1} \n" + " * @constructor \n" + " * @extends {Extended2} */", "Bad type annotation. type annotation incompatible with other " + "annotations"); [EOL] } <line_num>: 1931,1937
public void testBadExtendsWithNullable() throws Exception { [EOL]     JSDocInfo jsdoc = parse("@constructor\n * @extends {Object?} */", "Bad type annotation. expected closing }"); [EOL]     assertTrue(jsdoc.isConstructor()); [EOL]     assertTypeEquals(OBJECT_TYPE, jsdoc.getBaseType()); [EOL] } <line_num>: 1939,1944
public void testBadImplementsWithNullable() throws Exception { [EOL]     JSDocInfo jsdoc = parse("@implements {Disposable?}\n * @constructor */", "Bad type annotation. expected closing }"); [EOL]     assertTrue(jsdoc.isConstructor()); [EOL]     assertTypeEquals(registry.createNamedType("Disposable", null, -1, -1), jsdoc.getImplementedInterfaces().get(0)); [EOL] } <line_num>: 1946,1952
public void testBadTypeDefInterfaceAndConstructor1() throws Exception { [EOL]     JSDocInfo jsdoc = parse("@interface\n@constructor*/", "Bad type annotation. cannot be both an interface and a constructor"); [EOL]     assertTrue(jsdoc.isInterface()); [EOL] } <line_num>: 1954,1958
public void testBadTypeDefInterfaceAndConstructor2() throws Exception { [EOL]     JSDocInfo jsdoc = parse("@constructor\n@interface*/", "Bad type annotation. cannot be both an interface and a constructor"); [EOL]     assertTrue(jsdoc.isConstructor()); [EOL] } <line_num>: 1960,1964
public void testDocumentationParameter() throws Exception { [EOL]     JSDocInfo jsdoc = parse("@param {Number} number42 This is a description.*/", true); [EOL]     assertTrue(jsdoc.hasDescriptionForParameter("number42")); [EOL]     assertEquals("This is a description.", jsdoc.getDescriptionForParameter("number42")); [EOL] } <line_num>: 1966,1973
public void testMultilineDocumentationParameter() throws Exception { [EOL]     JSDocInfo jsdoc = parse("@param {Number} number42 This is a description" + "\n* on multiple \n* lines.*/", true); [EOL]     assertTrue(jsdoc.hasDescriptionForParameter("number42")); [EOL]     assertEquals("This is a description on multiple lines.", jsdoc.getDescriptionForParameter("number42")); [EOL] } <line_num>: 1975,1984
public void testDocumentationMultipleParameter() throws Exception { [EOL]     JSDocInfo jsdoc = parse("@param {Number} number42 This is a description." + "\n* @param {Integer} number87 This is another description.*/", true); [EOL]     assertTrue(jsdoc.hasDescriptionForParameter("number42")); [EOL]     assertEquals("This is a description.", jsdoc.getDescriptionForParameter("number42")); [EOL]     assertTrue(jsdoc.hasDescriptionForParameter("number87")); [EOL]     assertEquals("This is another description.", jsdoc.getDescriptionForParameter("number87")); [EOL] } <line_num>: 1986,1999
public void testDocumentationMultipleParameter2() throws Exception { [EOL]     JSDocInfo jsdoc = parse("@param {number} delta = 0 results in a redraw\n" + "  != 0 ..... */", true); [EOL]     assertTrue(jsdoc.hasDescriptionForParameter("delta")); [EOL]     assertEquals("= 0 results in a redraw != 0 .....", jsdoc.getDescriptionForParameter("delta")); [EOL] } <line_num>: 2001,2008
public void testAuthors() throws Exception { [EOL]     JSDocInfo jsdoc = parse("@param {Number} number42 This is a description." + "\n* @param {Integer} number87 This is another description." + "\n* @author a@google.com (A Person)" + "\n* @author b@google.com (B Person)" + "\n* @author c@google.com (C Person)*/", true); [EOL]     Collection<String> authors = jsdoc.getAuthors(); [EOL]     assertTrue(authors != null); [EOL]     assertTrue(authors.size() == 3); [EOL]     assertContains(authors, "a@google.com (A Person)"); [EOL]     assertContains(authors, "b@google.com (B Person)"); [EOL]     assertContains(authors, "c@google.com (C Person)"); [EOL] } <line_num>: 2011,2028
public void testSuppress1() throws Exception { [EOL]     JSDocInfo info = parse("@suppress {x} */"); [EOL]     assertEquals(Sets.newHashSet("x"), info.getSuppressions()); [EOL] } <line_num>: 2030,2033
public void testSuppress2() throws Exception { [EOL]     JSDocInfo info = parse("@suppress {x|y|x|z} */"); [EOL]     assertEquals(Sets.newHashSet("x", "y", "z"), info.getSuppressions()); [EOL] } <line_num>: 2035,2038
public void testBadSuppress1() throws Exception { [EOL]     parse("@suppress {} */", "malformed @suppress tag"); [EOL] } <line_num>: 2040,2042
public void testBadSuppress2() throws Exception { [EOL]     parse("@suppress {x|} */", "malformed @suppress tag"); [EOL] } <line_num>: 2044,2046
public void testBadSuppress3() throws Exception { [EOL]     parse("@suppress {|x} */", "malformed @suppress tag"); [EOL] } <line_num>: 2048,2050
public void testBadSuppress4() throws Exception { [EOL]     parse("@suppress {x|y */", "malformed @suppress tag"); [EOL] } <line_num>: 2052,2054
public void testBadSuppress5() throws Exception { [EOL]     parse("@suppress {x,y} */", "malformed @suppress tag"); [EOL] } <line_num>: 2056,2058
public void testBadSuppress6() throws Exception { [EOL]     parse("@suppress {x} \n * @suppress {y} */", "duplicate @suppress tag"); [EOL] } <line_num>: 2060,2062
public void testBadSuppress7() throws Exception { [EOL]     parse("@suppress {impossible} */", "unknown @suppress parameter: impossible"); [EOL] } <line_num>: 2064,2067
public void testModifies1() throws Exception { [EOL]     JSDocInfo info = parse("@modifies {this} */"); [EOL]     assertEquals(Sets.newHashSet("this"), info.getModifies()); [EOL] } <line_num>: 2069,2072
public void testModifies2() throws Exception { [EOL]     JSDocInfo info = parse("@modifies {arguments} */"); [EOL]     assertEquals(Sets.newHashSet("arguments"), info.getModifies()); [EOL] } <line_num>: 2074,2077
public void testModifies3() throws Exception { [EOL]     JSDocInfo info = parse("@modifies {this|arguments} */"); [EOL]     assertEquals(Sets.newHashSet("this", "arguments"), info.getModifies()); [EOL] } <line_num>: 2079,2082
public void testModifies4() throws Exception { [EOL]     JSDocInfo info = parse("@param {*} x\n * @modifies {x} */"); [EOL]     assertEquals(Sets.newHashSet("x"), info.getModifies()); [EOL] } <line_num>: 2084,2087
public void testModifies5() throws Exception { [EOL]     JSDocInfo info = parse("@param {*} x\n" + " * @param {*} y\n" + " * @modifies {x} */"); [EOL]     assertEquals(Sets.newHashSet("x"), info.getModifies()); [EOL] } <line_num>: 2089,2095
public void testModifies6() throws Exception { [EOL]     JSDocInfo info = parse("@param {*} x\n" + " * @param {*} y\n" + " * @modifies {x|y} */"); [EOL]     assertEquals(Sets.newHashSet("x", "y"), info.getModifies()); [EOL] } <line_num>: 2097,2103
public void testBadModifies1() throws Exception { [EOL]     parse("@modifies {} */", "malformed @modifies tag"); [EOL] } <line_num>: 2106,2108
public void testBadModifies2() throws Exception { [EOL]     parse("@modifies {this|} */", "malformed @modifies tag"); [EOL] } <line_num>: 2110,2112
public void testBadModifies3() throws Exception { [EOL]     parse("@modifies {|this} */", "malformed @modifies tag"); [EOL] } <line_num>: 2114,2116
public void testBadModifies4() throws Exception { [EOL]     parse("@modifies {this|arguments */", "malformed @modifies tag"); [EOL] } <line_num>: 2118,2120
public void testBadModifies5() throws Exception { [EOL]     parse("@modifies {this,arguments} */", "malformed @modifies tag"); [EOL] } <line_num>: 2122,2124
public void testBadModifies6() throws Exception { [EOL]     parse("@modifies {this} \n * @modifies {this} */", "conflicting @modifies tag"); [EOL] } <line_num>: 2126,2129
public void testBadModifies7() throws Exception { [EOL]     parse("@modifies {impossible} */", "unknown @modifies parameter: impossible"); [EOL] } <line_num>: 2131,2134
public void testBadModifies8() throws Exception { [EOL]     parse("@modifies {this}\n" + "@nosideeffects */", "conflicting @nosideeffects tag"); [EOL] } <line_num>: 2136,2139
public void testBadModifies9() throws Exception { [EOL]     parse("@nosideeffects\n" + "@modifies {this} */", "conflicting @modifies tag"); [EOL] } <line_num>: 2141,2144
public void testFileOverviewSingleLine() throws Exception { [EOL]     JSDocInfo jsdoc = parseFileOverview("@fileoverview Hi mom! */"); [EOL]     assertEquals("Hi mom!", jsdoc.getFileOverview()); [EOL] } <line_num>: 2152,2155
public void testFileOverviewMultiLine() throws Exception { [EOL]     JSDocInfo jsdoc = parseFileOverview("@fileoverview Pie is \n * good! */"); [EOL]     assertEquals("Pie is\n good!", jsdoc.getFileOverview()); [EOL] } <line_num>: 2157,2160
public void testFileOverviewDuplicate() throws Exception { [EOL]     JSDocInfo jsdoc = parseFileOverview("@fileoverview Pie \n * @fileoverview Cake */", "extra @fileoverview tag"); [EOL] } <line_num>: 2162,2166
public void testReferences() throws Exception { [EOL]     JSDocInfo jsdoc = parse("@see A cool place!" + "\n* @see The world." + "\n* @see SomeClass#SomeMember" + "\n* @see A boring test case*/", true); [EOL]     Collection<String> references = jsdoc.getReferences(); [EOL]     assertTrue(references != null); [EOL]     assertTrue(references.size() == 4); [EOL]     assertContains(references, "A cool place!"); [EOL]     assertContains(references, "The world."); [EOL]     assertContains(references, "SomeClass#SomeMember"); [EOL]     assertContains(references, "A boring test case"); [EOL] } <line_num>: 2168,2185
public void testSingleTags() throws Exception { [EOL]     JSDocInfo jsdoc = parse("@version Some old version" + "\n* @deprecated In favor of the new one!" + "\n* @return {SomeType} The most important object :-)*/", true); [EOL]     assertTrue(jsdoc.isDeprecated()); [EOL]     assertEquals("In favor of the new one!", jsdoc.getDeprecationReason()); [EOL]     assertEquals("Some old version", jsdoc.getVersion()); [EOL]     assertEquals("The most important object :-)", jsdoc.getReturnDescription()); [EOL] } <line_num>: 2187,2198
public void testSingleTagsReordered() throws Exception { [EOL]     JSDocInfo jsdoc = parse("@deprecated In favor of the new one!" + "\n * @return {SomeType} The most important object :-)" + "\n * @version Some old version*/", true); [EOL]     assertTrue(jsdoc.isDeprecated()); [EOL]     assertEquals("In favor of the new one!", jsdoc.getDeprecationReason()); [EOL]     assertEquals("Some old version", jsdoc.getVersion()); [EOL]     assertEquals("The most important object :-)", jsdoc.getReturnDescription()); [EOL] } <line_num>: 2200,2211
public void testVersionDuplication() throws Exception { [EOL]     parse("* @version Some old version" + "\n* @version Another version*/", true, "conflicting @version tag"); [EOL] } <line_num>: 2213,2217
public void testVersionMissing() throws Exception { [EOL]     parse("* @version */", true, "@version tag missing version information"); [EOL] } <line_num>: 2219,2222
public void testAuthorMissing() throws Exception { [EOL]     parse("* @author */", true, "@author tag missing author"); [EOL] } <line_num>: 2224,2227
public void testSeeMissing() throws Exception { [EOL]     parse("* @see */", true, "@see tag missing description"); [EOL] } <line_num>: 2229,2232
public void testSourceName() throws Exception { [EOL]     JSDocInfo jsdoc = parse("@deprecated */", true); [EOL]     assertEquals("testcode", jsdoc.getAssociatedNode().getSourceFileName()); [EOL] } <line_num>: 2234,2237
public void testParseBlockComment() throws Exception { [EOL]     JSDocInfo jsdoc = parse("this is a nice comment\n " + "* that is multiline \n" + "* @author abc@google.com */", true); [EOL]     assertEquals("this is a nice comment\nthat is multiline", jsdoc.getBlockDescription()); [EOL]     assertDocumentationInMarker(assertAnnotationMarker(jsdoc, "author", 2, 2), "abc@google.com", 9, 2, 23); [EOL] } <line_num>: 2239,2250
public void testParseBlockComment2() throws Exception { [EOL]     JSDocInfo jsdoc = parse("this is a nice comment\n " + "* that is *** multiline \n" + "* @author abc@google.com */", true); [EOL]     assertEquals("this is a nice comment\nthat is *** multiline", jsdoc.getBlockDescription()); [EOL]     assertDocumentationInMarker(assertAnnotationMarker(jsdoc, "author", 2, 2), "abc@google.com", 9, 2, 23); [EOL] } <line_num>: 2252,2263
public void testParseBlockComment3() throws Exception { [EOL]     JSDocInfo jsdoc = parse("\n " + "* hello world \n" + "* @author abc@google.com */", true); [EOL]     assertEquals("hello world", jsdoc.getBlockDescription()); [EOL]     assertDocumentationInMarker(assertAnnotationMarker(jsdoc, "author", 2, 2), "abc@google.com", 9, 2, 23); [EOL] } <line_num>: 2265,2275
public void testParseWithMarkers1() throws Exception { [EOL]     JSDocInfo jsdoc = parse("@author abc@google.com */", true); [EOL]     assertDocumentationInMarker(assertAnnotationMarker(jsdoc, "author", 0, 0), "abc@google.com", 7, 0, 21); [EOL] } <line_num>: 2277,2283
public void testParseWithMarkers2() throws Exception { [EOL]     JSDocInfo jsdoc = parse("@param {Foo} somename abc@google.com */", true); [EOL]     assertDocumentationInMarker(assertAnnotationMarker(jsdoc, "param", 0, 0), "abc@google.com", 21, 0, 37); [EOL] } <line_num>: 2285,2291
public void testParseWithMarkers3() throws Exception { [EOL]     JSDocInfo jsdoc = parse("@return {Foo} some long \n * multiline" + " \n * description */", true); [EOL]     JSDocInfo.Marker returnDoc = assertAnnotationMarker(jsdoc, "return", 0, 0); [EOL]     assertDocumentationInMarker(returnDoc, "some long multiline description", 13, 2, 15); [EOL]     assertEquals(8, returnDoc.getType().getPositionOnStartLine()); [EOL]     assertEquals(12, returnDoc.getType().getPositionOnEndLine()); [EOL] } <line_num>: 2293,2304
public void testParseWithMarkers4() throws Exception { [EOL]     JSDocInfo jsdoc = parse("@author foobar \n * @param {Foo} somename abc@google.com */", true); [EOL]     assertAnnotationMarker(jsdoc, "author", 0, 0); [EOL]     assertAnnotationMarker(jsdoc, "param", 1, 3); [EOL] } <line_num>: 2306,2313
public void testParseWithMarkers5() throws Exception { [EOL]     JSDocInfo jsdoc = parse("@return some long \n * multiline" + " \n * description */", true); [EOL]     assertDocumentationInMarker(assertAnnotationMarker(jsdoc, "return", 0, 0), "some long multiline description", 8, 2, 15); [EOL] } <line_num>: 2315,2323
public void testParseWithMarkers6() throws Exception { [EOL]     JSDocInfo jsdoc = parse("@param x some long \n * multiline" + " \n * description */", true); [EOL]     assertDocumentationInMarker(assertAnnotationMarker(jsdoc, "param", 0, 0), "some long multiline description", 8, 2, 15); [EOL] } <line_num>: 2325,2333
public void testParseWithMarkerNames1() throws Exception { [EOL]     JSDocInfo jsdoc = parse("@param {SomeType} name somedescription */", true); [EOL]     assertNameInMarker(assertAnnotationMarker(jsdoc, "param", 0, 0), "name", 0, 18); [EOL] } <line_num>: 2335,2341
public void testParseWithMarkerNames2() throws Exception { [EOL]     JSDocInfo jsdoc = parse("@param {SomeType} name somedescription \n" + "* @param {AnotherType} anothername des */", true); [EOL]     assertTypeInMarker(assertNameInMarker(assertAnnotationMarker(jsdoc, "param", 0, 0, 0), "name", 0, 18), "SomeType", 0, 7, 0, 16, true); [EOL]     assertTypeInMarker(assertNameInMarker(assertAnnotationMarker(jsdoc, "param", 1, 2, 1), "anothername", 1, 23), "AnotherType", 1, 9, 1, 21, true); [EOL] } <line_num>: 2343,2358
public void testParseWithMarkerNames3() throws Exception { [EOL]     JSDocInfo jsdoc = parse("@param {Some.Long.Type.\n *  Name} name somedescription */", true); [EOL]     assertTypeInMarker(assertNameInMarker(assertAnnotationMarker(jsdoc, "param", 0, 0, 0), "name", 1, 10), "Some.Long.Type.Name", 0, 7, 1, 8, true); [EOL] } <line_num>: 2360,2369
@SuppressWarnings("deprecation") [EOL] public void testParseWithoutMarkerName() throws Exception { [EOL]     JSDocInfo jsdoc = parse("@author helloworld*/", true); [EOL]     assertNull(assertAnnotationMarker(jsdoc, "author", 0, 0).getName()); [EOL] } <line_num>: 2371,2375
public void testParseWithMarkerType() throws Exception { [EOL]     JSDocInfo jsdoc = parse("@extends {FooBar}*/", true); [EOL]     assertTypeInMarker(assertAnnotationMarker(jsdoc, "extends", 0, 0), "FooBar", 0, 9, 0, 16, true); [EOL] } <line_num>: 2377,2383
public void testParseWithMarkerType2() throws Exception { [EOL]     JSDocInfo jsdoc = parse("@extends FooBar*/", true); [EOL]     assertTypeInMarker(assertAnnotationMarker(jsdoc, "extends", 0, 0), "FooBar", 0, 9, 0, 15, false); [EOL] } <line_num>: 2385,2391
public void testTypeTagConflict1() throws Exception { [EOL]     parse("@constructor \n * @constructor */", "Bad type annotation. " + "type annotation incompatible with other annotations"); [EOL] } <line_num>: 2393,2397
public void testTypeTagConflict2() throws Exception { [EOL]     parse("@interface \n * @interface */", "Bad type annotation. " + "type annotation incompatible with other annotations"); [EOL] } <line_num>: 2399,2403
public void testTypeTagConflict3() throws Exception { [EOL]     parse("@constructor \n * @interface */", "Bad type annotation. cannot be both an interface and a constructor"); [EOL] } <line_num>: 2405,2408
public void testTypeTagConflict4() throws Exception { [EOL]     parse("@interface \n * @constructor */", "Bad type annotation. cannot be both an interface and a constructor"); [EOL] } <line_num>: 2410,2413
public void testTypeTagConflict5() throws Exception { [EOL]     parse("@interface \n * @type {string} */", "Bad type annotation. " + "type annotation incompatible with other annotations"); [EOL] } <line_num>: 2415,2419
public void testTypeTagConflict6() throws Exception { [EOL]     parse("@typedef {string} \n * @type {string} */", "Bad type annotation. " + "type annotation incompatible with other annotations"); [EOL] } <line_num>: 2421,2425
public void testTypeTagConflict7() throws Exception { [EOL]     parse("@typedef {string} \n * @constructor */", "Bad type annotation. " + "type annotation incompatible with other annotations"); [EOL] } <line_num>: 2427,2431
public void testTypeTagConflict8() throws Exception { [EOL]     parse("@typedef {string} \n * @return {boolean} */", "Bad type annotation. " + "type annotation incompatible with other annotations"); [EOL] } <line_num>: 2433,2437
public void testTypeTagConflict9() throws Exception { [EOL]     parse("@enum {string} \n * @return {boolean} */", "Bad type annotation. " + "type annotation incompatible with other annotations"); [EOL] } <line_num>: 2439,2443
public void testTypeTagConflict10() throws Exception { [EOL]     parse("@this {Object} \n * @enum {boolean} */", "Bad type annotation. " + "type annotation incompatible with other annotations"); [EOL] } <line_num>: 2445,2449
public void testTypeTagConflict11() throws Exception { [EOL]     parse("@param {Object} x \n * @type {boolean} */", "Bad type annotation. " + "type annotation incompatible with other annotations"); [EOL] } <line_num>: 2451,2455
public void testTypeTagConflict12() throws Exception { [EOL]     parse("@typedef {boolean} \n * @param {Object} x */", "Bad type annotation. " + "type annotation incompatible with other annotations"); [EOL] } <line_num>: 2457,2461
public void testTypeTagConflict13() throws Exception { [EOL]     parse("@typedef {boolean} \n * @extends {Object} */", "Bad type annotation. " + "type annotation incompatible with other annotations"); [EOL] } <line_num>: 2463,2467
public void testTypeTagConflict14() throws Exception { [EOL]     parse("@return x \n * @return y */", "Bad type annotation. " + "type annotation incompatible with other annotations"); [EOL] } <line_num>: 2469,2473
public void testTypeTagConflict15() throws Exception { [EOL]     parse("/**\n" + " * @struct\n" + " * @struct\n" + " */\n" + "function StrStr() {}", "Bad type annotation. " + "type annotation incompatible with other annotations"); [EOL] } <line_num>: 2475,2483
public void testTypeTagConflict16() throws Exception { [EOL]     parse("/**\n" + " * @struct\n" + " * @interface\n" + " */\n" + "function StrIntf() {}", "Bad type annotation. " + "type annotation incompatible with other annotations"); [EOL] } <line_num>: 2485,2493
public void testTypeTagConflict17() throws Exception { [EOL]     parse("/**\n" + " * @interface\n" + " * @struct\n" + " */\n" + "function StrIntf() {}", "Bad type annotation. " + "type annotation incompatible with other annotations"); [EOL] } <line_num>: 2495,2503
public void testTypeTagConflict18() throws Exception { [EOL]     parse("/**\n" + " * @dict\n" + " * @dict\n" + " */\n" + "function DictDict() {}", "Bad type annotation. " + "type annotation incompatible with other annotations"); [EOL] } <line_num>: 2505,2513
public void testTypeTagConflict19() throws Exception { [EOL]     parse("/**\n" + " * @dict\n" + " * @interface\n" + " */\n" + "function DictDict() {}", "Bad type annotation. " + "type annotation incompatible with other annotations"); [EOL] } <line_num>: 2515,2523
public void testTypeTagConflict20() throws Exception { [EOL]     parse("/**\n" + " * @interface\n" + " * @dict\n" + " */\n" + "function DictDict() {}", "Bad type annotation. " + "type annotation incompatible with other annotations"); [EOL] } <line_num>: 2525,2533
public void testTypeTagConflict21() throws Exception { [EOL]     parse("/**\n" + " * @private {string}\n" + " * @type {number}\n" + " */\n" + "function DictDict() {}", "Bad type annotation. " + "type annotation incompatible with other annotations"); [EOL] } <line_num>: 2535,2543
public void testTypeTagConflict22() throws Exception { [EOL]     parse("/**\n" + " * @protected {string}\n" + " * @param {string} x\n" + " */\n" + "function DictDict(x) {}", "Bad type annotation. " + "type annotation incompatible with other annotations"); [EOL] } <line_num>: 2545,2553
public void testTypeTagConflict23() throws Exception { [EOL]     parse("/**\n" + " * @public {string}\n" + " * @return {string} x\n" + " */\n" + "function DictDict() {}", "Bad type annotation. " + "type annotation incompatible with other annotations"); [EOL] } <line_num>: 2555,2563
public void testTypeTagConflict24() throws Exception { [EOL]     parse("/**\n" + " * @const {string}\n" + " * @return {string} x\n" + " */\n" + "function DictDict() {}", "Bad type annotation. " + "type annotation incompatible with other annotations"); [EOL] } <line_num>: 2565,2573
public void testPrivateType() throws Exception { [EOL]     JSDocInfo jsdoc = parse("@private {string} */"); [EOL]     assertTypeEquals(STRING_TYPE, jsdoc.getType()); [EOL] } <line_num>: 2575,2578
public void testProtectedType() throws Exception { [EOL]     JSDocInfo jsdoc = parse("@protected {string} */"); [EOL]     assertTypeEquals(STRING_TYPE, jsdoc.getType()); [EOL] } <line_num>: 2580,2583
public void testPublicType() throws Exception { [EOL]     JSDocInfo jsdoc = parse("@public {string} */"); [EOL]     assertTypeEquals(STRING_TYPE, jsdoc.getType()); [EOL] } <line_num>: 2585,2588
public void testConstType() throws Exception { [EOL]     JSDocInfo jsdoc = parse("@const {string} */"); [EOL]     assertTypeEquals(STRING_TYPE, jsdoc.getType()); [EOL] } <line_num>: 2590,2593
public void testStableIdGeneratorConflict() throws Exception { [EOL]     parse("/**\n" + " * @stableIdGenerator\n" + " * @stableIdGenerator\n" + " */\n" + "function getId() {}", "extra @stableIdGenerator tag"); [EOL] } <line_num>: 2595,2602
public void testParserWithTemplateTypeNameMissing() { [EOL]     parse("@template */", "Bad type annotation. @template tag missing type name"); [EOL] } <line_num>: 2604,2607
public void testParserWithTemplateDuplicated() { [EOL]     parse("@template T\n@template V */", "Bad type annotation. @template tag at most once"); [EOL] } <line_num>: 2609,2612
public void testParserWithTwoTemplates() { [EOL]     parse("@template T,V */"); [EOL] } <line_num>: 2614,2616
public void testWhitelistedNewAnnotations() { [EOL]     parse("@foobar */", "illegal use of unknown JSDoc tag \"foobar\"; ignoring it"); [EOL]     extraAnnotations.add("foobar"); [EOL]     parse("@foobar */"); [EOL] } <line_num>: 2618,2623
public void testWhitelistedConflictingAnnotation() { [EOL]     extraAnnotations.add("param"); [EOL]     JSDocInfo info = parse("@param {number} index */"); [EOL]     assertTypeEquals(NUMBER_TYPE, info.getParameterType("index")); [EOL] } <line_num>: 2625,2629
public void testNonIdentifierAnnotation() { [EOL]     extraAnnotations.add("123"); [EOL]     parse("@123 */", "illegal use of unknown JSDoc tag \"\"; ignoring it"); [EOL] } <line_num>: 2631,2636
public void testUnsupportedJsDocSyntax1() { [EOL]     JSDocInfo info = parse("@param {string} [accessLevel=\"author\"] The user level */", true); [EOL]     assertEquals(1, info.getParameterCount()); [EOL]     assertTypeEquals(registry.createOptionalType(STRING_TYPE), info.getParameterType("accessLevel")); [EOL]     assertEquals("The user level", info.getDescriptionForParameter("accessLevel")); [EOL] } <line_num>: 2638,2648
public void testUnsupportedJsDocSyntax2() { [EOL]     JSDocInfo info = parse("@param userInfo The user info. \n" + " * @param userInfo.name The name of the user */", true); [EOL]     assertEquals(1, info.getParameterCount()); [EOL]     assertEquals("The user info.", info.getDescriptionForParameter("userInfo")); [EOL] } <line_num>: 2650,2657
public void testWhitelistedAnnotations() { [EOL]     parse("* @addon \n" + "* @augments \n" + "* @base \n" + "* @borrows \n" + "* @bug \n" + "* @class \n" + "* @config \n" + "* @constructs \n" + "* @default \n" + "* @description \n" + "* @event \n" + "* @example \n" + "* @exception \n" + "* @exec \n" + "* @externs \n" + "* @field \n" + "* @function \n" + "* @id \n" + "* @ignore \n" + "* @inner \n" + "* @lends {string} \n" + "* @link \n" + "* @member \n" + "* @memberOf \n" + "* @modName \n" + "* @mods \n" + "* @name \n" + "* @namespace \n" + "* @nocompile \n" + "* @property \n" + "* @requires \n" + "* @since \n" + "* @static \n" + "* @supported */"); [EOL] } <line_num>: 2659,2695
public void testGetOriginalCommentString() throws Exception { [EOL]     String comment = "* @desc This is a comment */"; [EOL]     JSDocInfo info = parse(comment); [EOL]     assertNull(info.getOriginalCommentString()); [EOL]     info = parse(comment, true); [EOL]     assertEquals(comment, info.getOriginalCommentString()); [EOL] } <line_num>: 2697,2703
private JSDocInfo.Marker assertDocumentationInMarker(JSDocInfo.Marker marker, String description, int startCharno, int endLineno, int endCharno) { [EOL]     assertTrue(marker.getDescription() != null); [EOL]     assertEquals(description, marker.getDescription().getItem()); [EOL]     assertEquals(marker.getAnnotation().getStartLine(), marker.getDescription().getStartLine()); [EOL]     assertEquals(startCharno, marker.getDescription().getPositionOnStartLine()); [EOL]     assertEquals(endLineno, marker.getDescription().getEndLine()); [EOL]     assertEquals(endCharno, marker.getDescription().getPositionOnEndLine()); [EOL]     return marker; [EOL] } <line_num>: 2714,2730
private JSDocInfo.Marker assertTypeInMarker(JSDocInfo.Marker marker, String typeName, int startLineno, int startCharno, int endLineno, int endCharno, boolean hasBrackets) { [EOL]     assertTrue(marker.getType() != null); [EOL]     assertTrue(marker.getType().getItem().isString()); [EOL]     String foundName = marker.getType().getItem().getString(); [EOL]     assertEquals(typeName, foundName); [EOL]     assertEquals(hasBrackets, marker.getType().hasBrackets()); [EOL]     assertEquals(startCharno, marker.getType().getPositionOnStartLine()); [EOL]     assertEquals(endCharno, marker.getType().getPositionOnEndLine()); [EOL]     assertEquals(startLineno, marker.getType().getStartLine()); [EOL]     assertEquals(endLineno, marker.getType().getEndLine()); [EOL]     return marker; [EOL] } <line_num>: 2741,2762
@SuppressWarnings("deprecation") [EOL] private JSDocInfo.Marker assertNameInMarker(JSDocInfo.Marker marker, String name, int startLine, int startCharno) { [EOL]     assertTrue(marker.getName() != null); [EOL]     assertEquals(name, marker.getName().getItem()); [EOL]     assertEquals(startCharno, marker.getName().getPositionOnStartLine()); [EOL]     assertEquals(startCharno + name.length(), marker.getName().getPositionOnEndLine()); [EOL]     assertEquals(startLine, marker.getName().getStartLine()); [EOL]     assertEquals(startLine, marker.getName().getEndLine()); [EOL]     return marker; [EOL] } <line_num>: 2771,2785
private JSDocInfo.Marker assertAnnotationMarker(JSDocInfo jsdoc, String annotationName, int startLineno, int startCharno) { [EOL]     return assertAnnotationMarker(jsdoc, annotationName, startLineno, startCharno, 0); [EOL] } <line_num>: 2798,2804
private JSDocInfo.Marker assertAnnotationMarker(JSDocInfo jsdoc, String annotationName, int startLineno, int startCharno, int index) { [EOL]     Collection<JSDocInfo.Marker> markers = jsdoc.getMarkers(); [EOL]     assertTrue(markers.size() > 0); [EOL]     int counter = 0; [EOL]     for (JSDocInfo.Marker marker : markers) { [EOL]         if (marker.getAnnotation() != null) { [EOL]             if (annotationName.equals(marker.getAnnotation().getItem())) { [EOL]                 if (counter == index) { [EOL]                     assertEquals(startLineno, marker.getAnnotation().getStartLine()); [EOL]                     assertEquals(startCharno, marker.getAnnotation().getPositionOnStartLine()); [EOL]                     assertEquals(startLineno, marker.getAnnotation().getEndLine()); [EOL]                     assertEquals(startCharno + annotationName.length(), marker.getAnnotation().getPositionOnEndLine()); [EOL]                     return marker; [EOL]                 } [EOL]                 counter++; [EOL]             } [EOL]         } [EOL]     } [EOL]     fail("No marker found"); [EOL]     return null; [EOL] } <line_num>: 2818,2852
private <T> void assertContains(Collection<T> collection, T item) { [EOL]     assertTrue(collection.contains(item)); [EOL] } <line_num>: 2854,2856
private void parseFull(String code, String... warnings) { [EOL]     CompilerEnvirons environment = new CompilerEnvirons(); [EOL]     TestErrorReporter testErrorReporter = new TestErrorReporter(null, warnings); [EOL]     environment.setErrorReporter(testErrorReporter); [EOL]     environment.setRecordingComments(true); [EOL]     environment.setRecordingLocalJsDocComments(true); [EOL]     Parser p = new Parser(environment, testErrorReporter); [EOL]     AstRoot script = p.parse(code, null, 0); [EOL]     Config config = new Config(extraAnnotations, extraSuppressions, true, LanguageMode.ECMASCRIPT3, false); [EOL]     StaticSourceFile file = new SimpleSourceFile(script.getSourceName(), false); [EOL]     for (Comment comment : script.getComments()) { [EOL]         JsDocInfoParser jsdocParser = new JsDocInfoParser(new JsDocTokenStream(comment.getValue().substring(3), comment.getLineno()), comment, null, config, testErrorReporter); [EOL]         jsdocParser.parse(); [EOL]         jsdocParser.retrieveAndResetParsedJSDocInfo(); [EOL]     } [EOL]     assertTrue("some expected warnings were not reported", testErrorReporter.hasEncounteredAllWarnings()); [EOL] } <line_num>: 2858,2889
@SuppressWarnings("unused") [EOL] private JSDocInfo parseFileOverviewWithoutDoc(String comment, String... warnings) { [EOL]     return parse(comment, false, true, warnings); [EOL] } <line_num>: 2891,2895
private JSDocInfo parseFileOverview(String comment, String... warnings) { [EOL]     return parse(comment, true, true, warnings); [EOL] } <line_num>: 2897,2899
private JSDocInfo parse(String comment, String... warnings) { [EOL]     return parse(comment, false, warnings); [EOL] } <line_num>: 2901,2903
private JSDocInfo parse(String comment, boolean parseDocumentation, String... warnings) { [EOL]     return parse(comment, parseDocumentation, false, warnings); [EOL] } <line_num>: 2905,2908
private JSDocInfo parse(String comment, boolean parseDocumentation, boolean parseFileOverview, String... warnings) { [EOL]     TestErrorReporter errorReporter = new TestErrorReporter(null, warnings); [EOL]     Config config = new Config(extraAnnotations, extraSuppressions, parseDocumentation, LanguageMode.ECMASCRIPT3, false); [EOL]     StaticSourceFile file = new SimpleSourceFile("testcode", false); [EOL]     Node associatedNode = new Node(Token.SCRIPT); [EOL]     associatedNode.setInputId(new InputId(file.getName())); [EOL]     associatedNode.setStaticSourceFile(file); [EOL]     JsDocInfoParser jsdocParser = new JsDocInfoParser(stream(comment), new Comment(0, 0, CommentType.JSDOC, comment), associatedNode, config, errorReporter); [EOL]     if (fileLevelJsDocBuilder != null) { [EOL]         jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder); [EOL]     } [EOL]     jsdocParser.parse(); [EOL]     assertTrue("expected warnings were not reported", errorReporter.hasEncounteredAllWarnings()); [EOL]     if (parseFileOverview) { [EOL]         return jsdocParser.getFileOverviewJSDocInfo(); [EOL]     } else { [EOL]         return jsdocParser.retrieveAndResetParsedJSDocInfo(); [EOL]     } [EOL] } <line_num>: 2910,2940
private Node parseType(String typeComment) { [EOL]     return JsDocInfoParser.parseTypeString(typeComment); [EOL] } <line_num>: 2942,2944
private JsDocTokenStream stream(String source) { [EOL]     return new JsDocTokenStream(source, 0); [EOL] } <line_num>: 2946,2948
private void assertParameterTypeEquals(JSType expected, JSTypeExpression te) { [EOL]     assertEquals(expected, ((ObjectType) resolve(te)).getParameterType()); [EOL] } <line_num>: 2950,2952
private void assertIndexTypeEquals(JSType expected, JSTypeExpression te) { [EOL]     assertEquals(expected, ((ObjectType) resolve(te)).getIndexType()); [EOL] } <line_num>: 2954,2956
