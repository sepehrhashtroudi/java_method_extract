private PeepholeFoldConstantsTest(boolean compareAsTree) { [EOL]     super("", compareAsTree); [EOL] } <line_num>: 39,41
public PeepholeFoldConstantsTest() { [EOL]     super(""); [EOL] } <line_num>: 43,45
@Override [EOL] public void setUp() { [EOL]     late = false; [EOL]     enableLineNumberCheck(true); [EOL] } <line_num>: 47,51
@Override [EOL] public CompilerPass getProcessor(final Compiler compiler) { [EOL]     CompilerPass peepholePass = new PeepholeOptimizationsPass(compiler, new PeepholeFoldConstants(late)); [EOL]     return peepholePass; [EOL] } <line_num>: 53,58
@Override [EOL] protected int getNumRepetitions() { [EOL]     return 2; [EOL] } <line_num>: 60,64
private void foldSame(String js) { [EOL]     testSame(js); [EOL] } <line_num>: 66,68
private void fold(String js, String expected) { [EOL]     test(js, expected); [EOL] } <line_num>: 70,72
private void fold(String js, String expected, DiagnosticType warning) { [EOL]     test(js, expected, null, warning); [EOL] } <line_num>: 74,76
private void assertResultString(String js, String expected) { [EOL]     PeepholeFoldConstantsTest scTest = new PeepholeFoldConstantsTest(false); [EOL]     scTest.test(js, expected); [EOL] } <line_num>: 80,84
public void testUndefinedComparison1() { [EOL]     fold("undefined == undefined", "true"); [EOL]     fold("undefined == null", "true"); [EOL]     fold("undefined == void 0", "true"); [EOL]     fold("undefined == 0", "false"); [EOL]     fold("undefined == 1", "false"); [EOL]     fold("undefined == 'hi'", "false"); [EOL]     fold("undefined == true", "false"); [EOL]     fold("undefined == false", "false"); [EOL]     fold("undefined === undefined", "true"); [EOL]     fold("undefined === null", "false"); [EOL]     fold("undefined === void 0", "true"); [EOL]     foldSame("undefined == this"); [EOL]     foldSame("undefined == x"); [EOL]     fold("undefined != undefined", "false"); [EOL]     fold("undefined != null", "false"); [EOL]     fold("undefined != void 0", "false"); [EOL]     fold("undefined != 0", "true"); [EOL]     fold("undefined != 1", "true"); [EOL]     fold("undefined != 'hi'", "true"); [EOL]     fold("undefined != true", "true"); [EOL]     fold("undefined != false", "true"); [EOL]     fold("undefined !== undefined", "false"); [EOL]     fold("undefined !== void 0", "false"); [EOL]     fold("undefined !== null", "true"); [EOL]     foldSame("undefined != this"); [EOL]     foldSame("undefined != x"); [EOL]     fold("undefined < undefined", "false"); [EOL]     fold("undefined > undefined", "false"); [EOL]     fold("undefined >= undefined", "false"); [EOL]     fold("undefined <= undefined", "false"); [EOL]     fold("0 < undefined", "false"); [EOL]     fold("true > undefined", "false"); [EOL]     fold("'hi' >= undefined", "false"); [EOL]     fold("null <= undefined", "false"); [EOL]     fold("undefined < 0", "false"); [EOL]     fold("undefined > true", "false"); [EOL]     fold("undefined >= 'hi'", "false"); [EOL]     fold("undefined <= null", "false"); [EOL]     fold("null == undefined", "true"); [EOL]     fold("0 == undefined", "false"); [EOL]     fold("1 == undefined", "false"); [EOL]     fold("'hi' == undefined", "false"); [EOL]     fold("true == undefined", "false"); [EOL]     fold("false == undefined", "false"); [EOL]     fold("null === undefined", "false"); [EOL]     fold("void 0 === undefined", "true"); [EOL]     fold("undefined == NaN", "false"); [EOL]     fold("NaN == undefined", "false"); [EOL]     fold("undefined == Infinity", "false"); [EOL]     fold("Infinity == undefined", "false"); [EOL]     fold("undefined == -Infinity", "false"); [EOL]     fold("-Infinity == undefined", "false"); [EOL]     fold("({}) == undefined", "false"); [EOL]     fold("undefined == ({})", "false"); [EOL]     fold("([]) == undefined", "false"); [EOL]     fold("undefined == ([])", "false"); [EOL]     fold("(/a/g) == undefined", "false"); [EOL]     fold("undefined == (/a/g)", "false"); [EOL]     fold("(function(){}) == undefined", "false"); [EOL]     fold("undefined == (function(){})", "false"); [EOL]     fold("undefined != NaN", "true"); [EOL]     fold("NaN != undefined", "true"); [EOL]     fold("undefined != Infinity", "true"); [EOL]     fold("Infinity != undefined", "true"); [EOL]     fold("undefined != -Infinity", "true"); [EOL]     fold("-Infinity != undefined", "true"); [EOL]     fold("({}) != undefined", "true"); [EOL]     fold("undefined != ({})", "true"); [EOL]     fold("([]) != undefined", "true"); [EOL]     fold("undefined != ([])", "true"); [EOL]     fold("(/a/g) != undefined", "true"); [EOL]     fold("undefined != (/a/g)", "true"); [EOL]     fold("(function(){}) != undefined", "true"); [EOL]     fold("undefined != (function(){})", "true"); [EOL]     foldSame("this == undefined"); [EOL]     foldSame("x == undefined"); [EOL] } <line_num>: 86,177
public void testUndefinedComparison2() { [EOL]     fold("\"123\" !== void 0", "true"); [EOL]     fold("\"123\" === void 0", "false"); [EOL]     fold("void 0 !== \"123\"", "true"); [EOL]     fold("void 0 === \"123\"", "false"); [EOL] } <line_num>: 179,185
public void testUndefinedComparison3() { [EOL]     fold("\"123\" !== undefined", "true"); [EOL]     fold("\"123\" === undefined", "false"); [EOL]     fold("undefined !== \"123\"", "true"); [EOL]     fold("undefined === \"123\"", "false"); [EOL] } <line_num>: 187,193
public void testUndefinedComparison4() { [EOL]     fold("1 !== void 0", "true"); [EOL]     fold("1 === void 0", "false"); [EOL]     fold("null !== void 0", "true"); [EOL]     fold("null === void 0", "false"); [EOL]     fold("undefined !== void 0", "false"); [EOL]     fold("undefined === void 0", "true"); [EOL] } <line_num>: 195,204
public void testNullComparison1() { [EOL]     fold("null == undefined", "true"); [EOL]     fold("null == null", "true"); [EOL]     fold("null == void 0", "true"); [EOL]     fold("null == 0", "false"); [EOL]     fold("null == 1", "false"); [EOL]     fold("null == 'hi'", "false"); [EOL]     fold("null == true", "false"); [EOL]     fold("null == false", "false"); [EOL]     fold("null === undefined", "false"); [EOL]     fold("null === null", "true"); [EOL]     fold("null === void 0", "false"); [EOL]     foldSame("null == this"); [EOL]     foldSame("null == x"); [EOL]     fold("null != undefined", "false"); [EOL]     fold("null != null", "false"); [EOL]     fold("null != void 0", "false"); [EOL]     fold("null != 0", "true"); [EOL]     fold("null != 1", "true"); [EOL]     fold("null != 'hi'", "true"); [EOL]     fold("null != true", "true"); [EOL]     fold("null != false", "true"); [EOL]     fold("null !== undefined", "true"); [EOL]     fold("null !== void 0", "true"); [EOL]     fold("null !== null", "false"); [EOL]     foldSame("null != this"); [EOL]     foldSame("null != x"); [EOL]     fold("null < null", "false"); [EOL]     fold("null > null", "false"); [EOL]     fold("null >= null", "true"); [EOL]     fold("null <= null", "true"); [EOL]     foldSame("0 < null"); [EOL]     fold("true > null", "true"); [EOL]     foldSame("'hi' >= null"); [EOL]     fold("null <= null", "true"); [EOL]     foldSame("null < 0"); [EOL]     fold("null > true", "false"); [EOL]     foldSame("null >= 'hi'"); [EOL]     fold("null <= null", "true"); [EOL]     fold("null == null", "true"); [EOL]     fold("0 == null", "false"); [EOL]     fold("1 == null", "false"); [EOL]     fold("'hi' == null", "false"); [EOL]     fold("true == null", "false"); [EOL]     fold("false == null", "false"); [EOL]     fold("null === null", "true"); [EOL]     fold("void 0 === null", "false"); [EOL]     fold("null == NaN", "false"); [EOL]     fold("NaN == null", "false"); [EOL]     fold("null == Infinity", "false"); [EOL]     fold("Infinity == null", "false"); [EOL]     fold("null == -Infinity", "false"); [EOL]     fold("-Infinity == null", "false"); [EOL]     fold("({}) == null", "false"); [EOL]     fold("null == ({})", "false"); [EOL]     fold("([]) == null", "false"); [EOL]     fold("null == ([])", "false"); [EOL]     fold("(/a/g) == null", "false"); [EOL]     fold("null == (/a/g)", "false"); [EOL]     fold("(function(){}) == null", "false"); [EOL]     fold("null == (function(){})", "false"); [EOL]     fold("null != NaN", "true"); [EOL]     fold("NaN != null", "true"); [EOL]     fold("null != Infinity", "true"); [EOL]     fold("Infinity != null", "true"); [EOL]     fold("null != -Infinity", "true"); [EOL]     fold("-Infinity != null", "true"); [EOL]     fold("({}) != null", "true"); [EOL]     fold("null != ({})", "true"); [EOL]     fold("([]) != null", "true"); [EOL]     fold("null != ([])", "true"); [EOL]     fold("(/a/g) != null", "true"); [EOL]     fold("null != (/a/g)", "true"); [EOL]     fold("(function(){}) != null", "true"); [EOL]     fold("null != (function(){})", "true"); [EOL]     foldSame("({a:f()}) == null"); [EOL]     foldSame("null == ({a:f()})"); [EOL]     foldSame("([f()]) == null"); [EOL]     foldSame("null == ([f()])"); [EOL]     foldSame("this == null"); [EOL]     foldSame("x == null"); [EOL] } <line_num>: 206,302
public void testUnaryOps() { [EOL]     foldSame("!foo()"); [EOL]     foldSame("~foo()"); [EOL]     foldSame("-foo()"); [EOL]     fold("a=!true", "a=false"); [EOL]     fold("a=!10", "a=false"); [EOL]     fold("a=!false", "a=true"); [EOL]     fold("a=!foo()", "a=!foo()"); [EOL]     fold("a=-0", "a=-0.0"); [EOL]     fold("a=-(0)", "a=-0.0"); [EOL]     fold("a=-Infinity", "a=-Infinity"); [EOL]     fold("a=-NaN", "a=NaN"); [EOL]     fold("a=-foo()", "a=-foo()"); [EOL]     fold("a=~~0", "a=0"); [EOL]     fold("a=~~10", "a=10"); [EOL]     fold("a=~-7", "a=6"); [EOL]     fold("a=+true", "a=1"); [EOL]     fold("a=+10", "a=10"); [EOL]     fold("a=+false", "a=0"); [EOL]     foldSame("a=+foo()"); [EOL]     foldSame("a=+f"); [EOL]     fold("a=+(f?true:false)", "a=+(f?1:0)"); [EOL]     fold("a=+0", "a=0"); [EOL]     fold("a=+Infinity", "a=Infinity"); [EOL]     fold("a=+NaN", "a=NaN"); [EOL]     fold("a=+-7", "a=-7"); [EOL]     fold("a=+.5", "a=.5"); [EOL]     fold("a=~0x100000000", "a=~0x100000000", PeepholeFoldConstants.BITWISE_OPERAND_OUT_OF_RANGE); [EOL]     fold("a=~-0x100000000", "a=~-0x100000000", PeepholeFoldConstants.BITWISE_OPERAND_OUT_OF_RANGE); [EOL]     testSame("a=~.5", PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND); [EOL] } <line_num>: 304,341
public void testUnaryOpsStringCompare() { [EOL]     assertResultString("a=-1", "a=-1"); [EOL]     assertResultString("a=~0", "a=-1"); [EOL]     assertResultString("a=~1", "a=-2"); [EOL]     assertResultString("a=~101", "a=-102"); [EOL] } <line_num>: 343,349
public void testFoldLogicalOp() { [EOL]     fold("x = true && x", "x = x"); [EOL]     foldSame("x = [foo()] && x"); [EOL]     fold("x = false && x", "x = false"); [EOL]     fold("x = true || x", "x = true"); [EOL]     fold("x = false || x", "x = x"); [EOL]     fold("x = 0 && x", "x = 0"); [EOL]     fold("x = 3 || x", "x = 3"); [EOL]     fold("x = false || 0", "x = 0"); [EOL]     fold("a = x && true", "a=x&&true"); [EOL]     fold("a = x && false", "a=x&&false"); [EOL]     fold("a = x || 3", "a=x||3"); [EOL]     fold("a = x || false", "a=x||false"); [EOL]     fold("a = b ? c : x || false", "a=b?c:x||false"); [EOL]     fold("a = b ? x || false : c", "a=b?x||false:c"); [EOL]     fold("a = b ? c : x && true", "a=b?c:x&&true"); [EOL]     fold("a = b ? x && true : c", "a=b?x&&true:c"); [EOL]     foldSame("a = x || false ? b : c"); [EOL]     foldSame("a = x && true ? b : c"); [EOL]     fold("x = foo() || true || bar()", "x = foo()||true"); [EOL]     fold("x = foo() || false || bar()", "x = foo()||bar()"); [EOL]     fold("x = foo() || true && bar()", "x = foo()||bar()"); [EOL]     fold("x = foo() || false && bar()", "x = foo()||false"); [EOL]     fold("x = foo() && false && bar()", "x = foo()&&false"); [EOL]     fold("x = foo() && true && bar()", "x = foo()&&bar()"); [EOL]     fold("x = foo() && false || bar()", "x = foo()&&false||bar()"); [EOL]     fold("1 && b()", "b()"); [EOL]     fold("a() && (1 && b())", "a() && b()"); [EOL]     fold("(a() && 1) && b()", "(a() && 1) && b()"); [EOL]     foldSame("x = foo() && true || bar()"); [EOL]     foldSame("foo() && true || bar()"); [EOL] } <line_num>: 351,395
public void testFoldBitwiseOp() { [EOL]     fold("x = 1 & 1", "x = 1"); [EOL]     fold("x = 1 & 2", "x = 0"); [EOL]     fold("x = 3 & 1", "x = 1"); [EOL]     fold("x = 3 & 3", "x = 3"); [EOL]     fold("x = 1 | 1", "x = 1"); [EOL]     fold("x = 1 | 2", "x = 3"); [EOL]     fold("x = 3 | 1", "x = 3"); [EOL]     fold("x = 3 | 3", "x = 3"); [EOL]     fold("x = 1 ^ 1", "x = 0"); [EOL]     fold("x = 1 ^ 2", "x = 3"); [EOL]     fold("x = 3 ^ 1", "x = 2"); [EOL]     fold("x = 3 ^ 3", "x = 0"); [EOL]     fold("x = -1 & 0", "x = 0"); [EOL]     fold("x = 0 & -1", "x = 0"); [EOL]     fold("x = 1 & 4", "x = 0"); [EOL]     fold("x = 2 & 3", "x = 2"); [EOL]     fold("x = 1 & 1.1", "x = 1"); [EOL]     fold("x = 1.1 & 1", "x = 1"); [EOL]     fold("x = 1 & 3000000000", "x = 0"); [EOL]     fold("x = 3000000000 & 1", "x = 0"); [EOL]     fold("x = 1 | 4", "x = 5"); [EOL]     fold("x = 1 | 3", "x = 3"); [EOL]     fold("x = 1 | 1.1", "x = 1"); [EOL]     foldSame("x = 1 | 3E9"); [EOL]     fold("x = 1 | 3000000001", "x = -1294967295"); [EOL] } <line_num>: 397,431
public void testFoldBitwiseOp2() { [EOL]     fold("x = y & 1 & 1", "x = y & 1"); [EOL]     fold("x = y & 1 & 2", "x = y & 0"); [EOL]     fold("x = y & 3 & 1", "x = y & 1"); [EOL]     fold("x = 3 & y & 1", "x = y & 1"); [EOL]     fold("x = y & 3 & 3", "x = y & 3"); [EOL]     fold("x = 3 & y & 3", "x = y & 3"); [EOL]     fold("x = y | 1 | 1", "x = y | 1"); [EOL]     fold("x = y | 1 | 2", "x = y | 3"); [EOL]     fold("x = y | 3 | 1", "x = y | 3"); [EOL]     fold("x = 3 | y | 1", "x = y | 3"); [EOL]     fold("x = y | 3 | 3", "x = y | 3"); [EOL]     fold("x = 3 | y | 3", "x = y | 3"); [EOL]     fold("x = y ^ 1 ^ 1", "x = y ^ 0"); [EOL]     fold("x = y ^ 1 ^ 2", "x = y ^ 3"); [EOL]     fold("x = y ^ 3 ^ 1", "x = y ^ 2"); [EOL]     fold("x = 3 ^ y ^ 1", "x = y ^ 2"); [EOL]     fold("x = y ^ 3 ^ 3", "x = y ^ 0"); [EOL]     fold("x = 3 ^ y ^ 3", "x = y ^ 0"); [EOL]     fold("x = Infinity | NaN", "x=0"); [EOL]     fold("x = 12 | NaN", "x=12"); [EOL] } <line_num>: 433,457
public void testFoldingMixTypesLate() { [EOL]     late = true; [EOL]     fold("x = x + '2'", "x+='2'"); [EOL]     fold("x = +x + +'2'", "x = +x + 2"); [EOL]     fold("x = x - '2'", "x-=2"); [EOL]     fold("x = x ^ '2'", "x^=2"); [EOL]     fold("x = '2' ^ x", "x^=2"); [EOL]     fold("x = '2' & x", "x&=2"); [EOL]     fold("x = '2' | x", "x|=2"); [EOL]     fold("x = '2' | y", "x=2|y"); [EOL]     fold("x = y | '2'", "x=y|2"); [EOL]     fold("x = y | (a && '2')", "x=y|(a&&2)"); [EOL]     fold("x = y | (a,'2')", "x=y|(a,2)"); [EOL]     fold("x = y | (a?'1':'2')", "x=y|(a?1:2)"); [EOL]     fold("x = y | ('x'?'1':'2')", "x=y|('x'?1:2)"); [EOL] } <line_num>: 459,475
public void testFoldingMixTypesEarly() { [EOL]     late = false; [EOL]     foldSame("x = x + '2'"); [EOL]     fold("x = +x + +'2'", "x = +x + 2"); [EOL]     fold("x = x - '2'", "x = x - 2"); [EOL]     fold("x = x ^ '2'", "x = x ^ 2"); [EOL]     fold("x = '2' ^ x", "x = 2 ^ x"); [EOL]     fold("x = '2' & x", "x = 2 & x"); [EOL]     fold("x = '2' | x", "x = 2 | x"); [EOL]     fold("x = '2' | y", "x=2|y"); [EOL]     fold("x = y | '2'", "x=y|2"); [EOL]     fold("x = y | (a && '2')", "x=y|(a&&2)"); [EOL]     fold("x = y | (a,'2')", "x=y|(a,2)"); [EOL]     fold("x = y | (a?'1':'2')", "x=y|(a?1:2)"); [EOL]     fold("x = y | ('x'?'1':'2')", "x=y|('x'?1:2)"); [EOL] } <line_num>: 477,493
public void testFoldingAdd() { [EOL]     fold("x = null + true", "x=1"); [EOL]     foldSame("x = a + true"); [EOL] } <line_num>: 495,498
public void testFoldBitwiseOpStringCompare() { [EOL]     assertResultString("x = -1 | 0", "x=-1"); [EOL] } <line_num>: 500,503
public void testFoldBitShifts() { [EOL]     fold("x = 1 << 0", "x = 1"); [EOL]     fold("x = -1 << 0", "x = -1"); [EOL]     fold("x = 1 << 1", "x = 2"); [EOL]     fold("x = 3 << 1", "x = 6"); [EOL]     fold("x = 1 << 8", "x = 256"); [EOL]     fold("x = 1 >> 0", "x = 1"); [EOL]     fold("x = -1 >> 0", "x = -1"); [EOL]     fold("x = 1 >> 1", "x = 0"); [EOL]     fold("x = 2 >> 1", "x = 1"); [EOL]     fold("x = 5 >> 1", "x = 2"); [EOL]     fold("x = 127 >> 3", "x = 15"); [EOL]     fold("x = 3 >> 1", "x = 1"); [EOL]     fold("x = 3 >> 2", "x = 0"); [EOL]     fold("x = 10 >> 1", "x = 5"); [EOL]     fold("x = 10 >> 2", "x = 2"); [EOL]     fold("x = 10 >> 5", "x = 0"); [EOL]     fold("x = 10 >>> 1", "x = 5"); [EOL]     fold("x = 10 >>> 2", "x = 2"); [EOL]     fold("x = 10 >>> 5", "x = 0"); [EOL]     fold("x = -1 >>> 1", "x = 2147483647"); [EOL]     fold("x = -1 >>> 0", "x = 4294967295"); [EOL]     fold("x = -2 >>> 0", "x = 4294967294"); [EOL]     testSame("3000000000 << 1", PeepholeFoldConstants.BITWISE_OPERAND_OUT_OF_RANGE); [EOL]     testSame("1 << 32", PeepholeFoldConstants.SHIFT_AMOUNT_OUT_OF_BOUNDS); [EOL]     testSame("1 << -1", PeepholeFoldConstants.SHIFT_AMOUNT_OUT_OF_BOUNDS); [EOL]     testSame("3000000000 >> 1", PeepholeFoldConstants.BITWISE_OPERAND_OUT_OF_RANGE); [EOL]     testSame("1 >> 32", PeepholeFoldConstants.SHIFT_AMOUNT_OUT_OF_BOUNDS); [EOL]     testSame("1.5 << 0", PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND); [EOL]     testSame("1 << .5", PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND); [EOL]     testSame("1.5 >>> 0", PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND); [EOL]     testSame("1 >>> .5", PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND); [EOL]     testSame("1.5 >> 0", PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND); [EOL]     testSame("1 >> .5", PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND); [EOL] } <line_num>: 505,553
public void testFoldBitShiftsStringCompare() { [EOL]     assertResultString("x = -1 << 1", "x=-2"); [EOL]     assertResultString("x = -1 << 8", "x=-256"); [EOL]     assertResultString("x = -1 >> 1", "x=-1"); [EOL]     assertResultString("x = -2 >> 1", "x=-1"); [EOL]     assertResultString("x = -1 >> 0", "x=-1"); [EOL] } <line_num>: 555,562
public void testStringAdd() { [EOL]     fold("x = 'a' + \"bc\"", "x = \"abc\""); [EOL]     fold("x = 'a' + 5", "x = \"a5\""); [EOL]     fold("x = 5 + 'a'", "x = \"5a\""); [EOL]     fold("x = 'a' + ''", "x = \"a\""); [EOL]     fold("x = \"a\" + foo()", "x = \"a\"+foo()"); [EOL]     fold("x = foo() + 'a' + 'b'", "x = foo()+\"ab\""); [EOL]     fold("x = (foo() + 'a') + 'b'", "x = foo()+\"ab\""); [EOL]     fold("x = foo() + 'a' + 'b' + 'cd' + bar()", "x = foo()+\"abcd\"+bar()"); [EOL]     fold("x = foo() + 2 + 'b'", "x = foo()+2+\"b\""); [EOL]     fold("x = foo() + 'a' + 2", "x = foo()+\"a2\""); [EOL]     fold("x = '' + null", "x = \"null\""); [EOL]     fold("x = true + '' + false", "x = \"truefalse\""); [EOL]     fold("x = '' + []", "x = ''"); [EOL] } <line_num>: 564,578
public void testIssue821() { [EOL]     foldSame("var a =(Math.random()>0.5? '1' : 2 ) + 3 + 4;"); [EOL]     foldSame("var a = ((Math.random() ? 0 : 1) ||" + "(Math.random()>0.5? '1' : 2 )) + 3 + 4;"); [EOL] } <line_num>: 580,584
public void testFoldConstructor() { [EOL]     fold("x = this[new String('a')]", "x = this['a']"); [EOL]     fold("x = ob[new String(12)]", "x = ob['12']"); [EOL]     fold("x = ob[new String(false)]", "x = ob['false']"); [EOL]     fold("x = ob[new String(null)]", "x = ob['null']"); [EOL]     fold("x = 'a' + new String('b')", "x = 'ab'"); [EOL]     fold("x = 'a' + new String(23)", "x = 'a23'"); [EOL]     fold("x = 2 + new String(1)", "x = '21'"); [EOL]     foldSame("x = ob[new String(a)]"); [EOL]     foldSame("x = new String('a')"); [EOL]     foldSame("x = (new String('a'))[3]"); [EOL] } <line_num>: 586,597
public void testFoldArithmetic() { [EOL]     fold("x = 10 + 20", "x = 30"); [EOL]     fold("x = 2 / 4", "x = 0.5"); [EOL]     fold("x = 2.25 * 3", "x = 6.75"); [EOL]     fold("z = x * y", "z = x * y"); [EOL]     fold("x = y * 5", "x = y * 5"); [EOL]     fold("x = 1 / 0", "x = 1 / 0"); [EOL]     fold("x = 3 % 2", "x = 1"); [EOL]     fold("x = 3 % -2", "x = 1"); [EOL]     fold("x = -1 % 3", "x = -1"); [EOL]     fold("x = 1 % 0", "x = 1 % 0"); [EOL] } <line_num>: 599,610
public void testFoldArithmetic2() { [EOL]     foldSame("x = y + 10 + 20"); [EOL]     foldSame("x = y / 2 / 4"); [EOL]     fold("x = y * 2.25 * 3", "x = y * 6.75"); [EOL]     fold("z = x * y", "z = x * y"); [EOL]     fold("x = y * 5", "x = y * 5"); [EOL]     fold("x = y + (z * 24 * 60 * 60 * 1000)", "x = y + z * 864E5"); [EOL] } <line_num>: 612,619
public void testFoldArithmetic3() { [EOL]     fold("x = null * undefined", "x = NaN"); [EOL]     fold("x = null * 1", "x = 0"); [EOL]     fold("x = (null - 1) * 2", "x = -2"); [EOL]     fold("x = (null + 1) * 2", "x = 2"); [EOL] } <line_num>: 621,626
public void testFoldArithmeticInfinity() { [EOL]     fold("x=-Infinity-2", "x=-Infinity"); [EOL]     fold("x=Infinity-2", "x=Infinity"); [EOL]     fold("x=Infinity*5", "x=Infinity"); [EOL] } <line_num>: 628,632
public void testFoldArithmeticStringComp() { [EOL]     assertResultString("x = 10 - 20", "x=-10"); [EOL] } <line_num>: 634,637
public void testFoldComparison() { [EOL]     fold("x = 0 == 0", "x = true"); [EOL]     fold("x = 1 == 2", "x = false"); [EOL]     fold("x = 'abc' == 'def'", "x = false"); [EOL]     fold("x = 'abc' == 'abc'", "x = true"); [EOL]     fold("x = \"\" == ''", "x = true"); [EOL]     fold("x = foo() == bar()", "x = foo()==bar()"); [EOL]     fold("x = 1 != 0", "x = true"); [EOL]     fold("x = 'abc' != 'def'", "x = true"); [EOL]     fold("x = 'a' != 'a'", "x = false"); [EOL]     fold("x = 1 < 20", "x = true"); [EOL]     fold("x = 3 < 3", "x = false"); [EOL]     fold("x = 10 > 1.0", "x = true"); [EOL]     fold("x = 10 > 10.25", "x = false"); [EOL]     fold("x = y == y", "x = y==y"); [EOL]     fold("x = y < y", "x = false"); [EOL]     fold("x = y > y", "x = false"); [EOL]     fold("x = 1 <= 1", "x = true"); [EOL]     fold("x = 1 <= 0", "x = false"); [EOL]     fold("x = 0 >= 0", "x = true"); [EOL]     fold("x = -1 >= 9", "x = false"); [EOL]     fold("x = true == true", "x = true"); [EOL]     fold("x = false == false", "x = true"); [EOL]     fold("x = false == null", "x = false"); [EOL]     fold("x = false == true", "x = false"); [EOL]     fold("x = true == null", "x = false"); [EOL]     fold("0 == 0", "true"); [EOL]     fold("1 == 2", "false"); [EOL]     fold("'abc' == 'def'", "false"); [EOL]     fold("'abc' == 'abc'", "true"); [EOL]     fold("\"\" == ''", "true"); [EOL]     foldSame("foo() == bar()"); [EOL]     fold("1 != 0", "true"); [EOL]     fold("'abc' != 'def'", "true"); [EOL]     fold("'a' != 'a'", "false"); [EOL]     fold("1 < 20", "true"); [EOL]     fold("3 < 3", "false"); [EOL]     fold("10 > 1.0", "true"); [EOL]     fold("10 > 10.25", "false"); [EOL]     foldSame("x == x"); [EOL]     fold("x < x", "false"); [EOL]     fold("x > x", "false"); [EOL]     fold("1 <= 1", "true"); [EOL]     fold("1 <= 0", "false"); [EOL]     fold("0 >= 0", "true"); [EOL]     fold("-1 >= 9", "false"); [EOL]     fold("true == true", "true"); [EOL]     fold("false == null", "false"); [EOL]     fold("false == true", "false"); [EOL]     fold("true == null", "false"); [EOL] } <line_num>: 639,696
public void testFoldComparison2() { [EOL]     fold("x = 0 === 0", "x = true"); [EOL]     fold("x = 1 === 2", "x = false"); [EOL]     fold("x = 'abc' === 'def'", "x = false"); [EOL]     fold("x = 'abc' === 'abc'", "x = true"); [EOL]     fold("x = \"\" === ''", "x = true"); [EOL]     fold("x = foo() === bar()", "x = foo()===bar()"); [EOL]     fold("x = 1 !== 0", "x = true"); [EOL]     fold("x = 'abc' !== 'def'", "x = true"); [EOL]     fold("x = 'a' !== 'a'", "x = false"); [EOL]     fold("x = y === y", "x = y===y"); [EOL]     fold("x = true === true", "x = true"); [EOL]     fold("x = false === false", "x = true"); [EOL]     fold("x = false === null", "x = false"); [EOL]     fold("x = false === true", "x = false"); [EOL]     fold("x = true === null", "x = false"); [EOL]     fold("0 === 0", "true"); [EOL]     fold("1 === 2", "false"); [EOL]     fold("'abc' === 'def'", "false"); [EOL]     fold("'abc' === 'abc'", "true"); [EOL]     fold("\"\" === ''", "true"); [EOL]     foldSame("foo() === bar()"); [EOL]     foldSame("1 === '1'"); [EOL]     foldSame("1 === true"); [EOL]     foldSame("1 !== '1'"); [EOL]     foldSame("1 !== true"); [EOL]     fold("1 !== 0", "true"); [EOL]     fold("'abc' !== 'def'", "true"); [EOL]     fold("'a' !== 'a'", "false"); [EOL]     foldSame("x === x"); [EOL]     fold("true === true", "true"); [EOL]     fold("false === null", "false"); [EOL]     fold("false === true", "false"); [EOL]     fold("true === null", "false"); [EOL] } <line_num>: 699,742
public void testFoldComparison3() { [EOL]     fold("x = !1 == !0", "x = false"); [EOL]     fold("x = !0 == !0", "x = true"); [EOL]     fold("x = !1 == !1", "x = true"); [EOL]     fold("x = !1 == null", "x = false"); [EOL]     fold("x = !1 == !0", "x = false"); [EOL]     fold("x = !0 == null", "x = false"); [EOL]     fold("!0 == !0", "true"); [EOL]     fold("!1 == null", "false"); [EOL]     fold("!1 == !0", "false"); [EOL]     fold("!0 == null", "false"); [EOL]     fold("x = !0 === !0", "x = true"); [EOL]     fold("x = !1 === !1", "x = true"); [EOL]     fold("x = !1 === null", "x = false"); [EOL]     fold("x = !1 === !0", "x = false"); [EOL]     fold("x = !0 === null", "x = false"); [EOL]     fold("!0 === !0", "true"); [EOL]     fold("!1 === null", "false"); [EOL]     fold("!1 === !0", "false"); [EOL]     fold("!0 === null", "false"); [EOL] } <line_num>: 744,768
public void testFoldGetElem() { [EOL]     fold("x = [,10][0]", "x = void 0"); [EOL]     fold("x = [10, 20][0]", "x = 10"); [EOL]     fold("x = [10, 20][1]", "x = 20"); [EOL]     testSame("x = [10, 20][0.5]", PeepholeFoldConstants.INVALID_GETELEM_INDEX_ERROR); [EOL]     testSame("x = [10, 20][-1]", PeepholeFoldConstants.INDEX_OUT_OF_BOUNDS_ERROR); [EOL]     testSame("x = [10, 20][2]", PeepholeFoldConstants.INDEX_OUT_OF_BOUNDS_ERROR); [EOL]     foldSame("x = [foo(), 0][1]"); [EOL]     fold("x = [0, foo()][1]", "x = foo()"); [EOL]     foldSame("x = [0, foo()][0]"); [EOL] } <line_num>: 770,785
public void testFoldComplex() { [EOL]     fold("x = (3 / 1.0) + (1 * 2)", "x = 5"); [EOL]     fold("x = (1 == 1.0) && foo() && true", "x = foo()&&true"); [EOL]     fold("x = 'abc' + 5 + 10", "x = \"abc510\""); [EOL] } <line_num>: 787,791
public void testFoldLeft() { [EOL]     foldSame("(+x - 1) + 2"); [EOL]     fold("(+x + 1) + 2", "+x + 3"); [EOL] } <line_num>: 793,796
public void testFoldArrayLength() { [EOL]     fold("x = [].length", "x = 0"); [EOL]     fold("x = [1,2,3].length", "x = 3"); [EOL]     fold("x = [a,b].length", "x = 2"); [EOL]     fold("x = [,,1].length", "x = 3"); [EOL]     fold("x = [foo(), 0].length", "x = [foo(),0].length"); [EOL]     fold("x = y.length", "x = y.length"); [EOL] } <line_num>: 798,810
public void testFoldStringLength() { [EOL]     fold("x = ''.length", "x = 0"); [EOL]     fold("x = '123'.length", "x = 3"); [EOL]     fold("x = '123\u01dc'.length", "x = 4"); [EOL] } <line_num>: 812,819
public void testFoldTypeof() { [EOL]     fold("x = typeof 1", "x = \"number\""); [EOL]     fold("x = typeof 'foo'", "x = \"string\""); [EOL]     fold("x = typeof true", "x = \"boolean\""); [EOL]     fold("x = typeof false", "x = \"boolean\""); [EOL]     fold("x = typeof null", "x = \"object\""); [EOL]     fold("x = typeof undefined", "x = \"undefined\""); [EOL]     fold("x = typeof void 0", "x = \"undefined\""); [EOL]     fold("x = typeof []", "x = \"object\""); [EOL]     fold("x = typeof [1]", "x = \"object\""); [EOL]     fold("x = typeof [1,[]]", "x = \"object\""); [EOL]     fold("x = typeof {}", "x = \"object\""); [EOL]     fold("x = typeof function() {}", "x = 'function'"); [EOL]     foldSame("x = typeof[1,[foo()]]"); [EOL]     foldSame("x = typeof{bathwater:baby()}"); [EOL] } <line_num>: 821,837
public void testFoldInstanceOf() { [EOL]     fold("64 instanceof Object", "false"); [EOL]     fold("64 instanceof Number", "false"); [EOL]     fold("'' instanceof Object", "false"); [EOL]     fold("'' instanceof String", "false"); [EOL]     fold("true instanceof Object", "false"); [EOL]     fold("true instanceof Boolean", "false"); [EOL]     fold("!0 instanceof Object", "false"); [EOL]     fold("!0 instanceof Boolean", "false"); [EOL]     fold("false instanceof Object", "false"); [EOL]     fold("null instanceof Object", "false"); [EOL]     fold("undefined instanceof Object", "false"); [EOL]     fold("NaN instanceof Object", "false"); [EOL]     fold("Infinity instanceof Object", "false"); [EOL]     fold("[] instanceof Object", "true"); [EOL]     fold("({}) instanceof Object", "true"); [EOL]     foldSame("new Foo() instanceof Object"); [EOL]     foldSame("[] instanceof Foo"); [EOL]     foldSame("({}) instanceof Foo"); [EOL]     fold("(function() {}) instanceof Object", "true"); [EOL]     foldSame("x instanceof Foo"); [EOL] } <line_num>: 839,869
public void testDivision() { [EOL]     fold("print(1/3)", "print(1/3)"); [EOL]     fold("print(1/2)", "print(0.5)"); [EOL] } <line_num>: 871,878
public void testAssignOpsLate() { [EOL]     late = true; [EOL]     fold("x=x+y", "x+=y"); [EOL]     foldSame("x=y+x"); [EOL]     fold("x=x*y", "x*=y"); [EOL]     fold("x=y*x", "x*=y"); [EOL]     fold("x.y=x.y+z", "x.y+=z"); [EOL]     foldSame("next().x = next().x + 1"); [EOL]     fold("x=x-y", "x-=y"); [EOL]     foldSame("x=y-x"); [EOL]     fold("x=x|y", "x|=y"); [EOL]     fold("x=y|x", "x|=y"); [EOL]     fold("x=x*y", "x*=y"); [EOL]     fold("x=y*x", "x*=y"); [EOL]     fold("x.y=x.y+z", "x.y+=z"); [EOL]     foldSame("next().x = next().x + 1"); [EOL]     fold("({a:1}).a = ({a:1}).a + 1", "({a:1}).a = 2"); [EOL] } <line_num>: 880,899
public void testAssignOpsEarly() { [EOL]     late = false; [EOL]     foldSame("x=x+y"); [EOL]     foldSame("x=y+x"); [EOL]     foldSame("x=x*y"); [EOL]     foldSame("x=y*x"); [EOL]     foldSame("x.y=x.y+z"); [EOL]     foldSame("next().x = next().x + 1"); [EOL]     foldSame("x=x-y"); [EOL]     foldSame("x=y-x"); [EOL]     foldSame("x=x|y"); [EOL]     foldSame("x=y|x"); [EOL]     foldSame("x=x*y"); [EOL]     foldSame("x=y*x"); [EOL]     foldSame("x.y=x.y+z"); [EOL]     foldSame("next().x = next().x + 1"); [EOL]     fold("({a:1}).a = ({a:1}).a + 1", "({a:1}).a = 2"); [EOL] } <line_num>: 901,920
public void testFoldAdd1() { [EOL]     fold("x=false+1", "x=1"); [EOL]     fold("x=true+1", "x=2"); [EOL]     fold("x=1+false", "x=1"); [EOL]     fold("x=1+true", "x=2"); [EOL] } <line_num>: 922,927
public void testFoldLiteralNames() { [EOL]     foldSame("NaN == NaN"); [EOL]     foldSame("Infinity == Infinity"); [EOL]     foldSame("Infinity == NaN"); [EOL]     fold("undefined == NaN", "false"); [EOL]     fold("undefined == Infinity", "false"); [EOL]     foldSame("Infinity >= Infinity"); [EOL]     foldSame("NaN >= NaN"); [EOL] } <line_num>: 929,938
public void testFoldLiteralsTypeMismatches() { [EOL]     fold("true == true", "true"); [EOL]     fold("true == false", "false"); [EOL]     fold("true == null", "false"); [EOL]     fold("false == null", "false"); [EOL]     fold("null <= null", "true"); [EOL]     fold("null >= null", "true"); [EOL]     fold("null > null", "false"); [EOL]     fold("null < null", "false"); [EOL]     fold("false >= null", "true"); [EOL]     fold("false <= null", "true"); [EOL]     fold("false > null", "false"); [EOL]     fold("false < null", "false"); [EOL]     fold("true >= null", "true"); [EOL]     fold("true <= null", "false"); [EOL]     fold("true > null", "true"); [EOL]     fold("true < null", "false"); [EOL]     fold("true >= false", "true"); [EOL]     fold("true <= false", "false"); [EOL]     fold("true > false", "true"); [EOL]     fold("true < false", "false"); [EOL] } <line_num>: 940,966
public void testFoldLeftChildConcat() { [EOL]     foldSame("x +5 + \"1\""); [EOL]     fold("x+\"5\" + \"1\"", "x + \"51\""); [EOL]     fold("\"a\"+(\"b\"+c)", "\"ab\"+c"); [EOL] } <line_num>: 968,973
public void testFoldLeftChildOp() { [EOL]     fold("x * Infinity * 2", "x * Infinity"); [EOL]     foldSame("x - Infinity - 2"); [EOL]     foldSame("x - 1 + Infinity"); [EOL]     foldSame("x - 2 + 1"); [EOL]     foldSame("x - 2 + 3"); [EOL]     foldSame("1 + x - 2 + 1"); [EOL]     foldSame("1 + x - 2 + 3"); [EOL]     foldSame("1 + x - 2 + 3 - 1"); [EOL]     foldSame("f(x)-0"); [EOL]     foldSame("x-0-0"); [EOL]     foldSame("x+2-2+2"); [EOL]     foldSame("x+2-2+2-2"); [EOL]     foldSame("x-2+2"); [EOL]     foldSame("x-2+2-2"); [EOL]     foldSame("x-2+2-2+2"); [EOL]     foldSame("1+x-0-NaN"); [EOL]     foldSame("1+f(x)-0-NaN"); [EOL]     foldSame("1+x-0+NaN"); [EOL]     foldSame("1+f(x)-0+NaN"); [EOL]     foldSame("1+x+NaN"); [EOL]     foldSame("x+2-2"); [EOL]     foldSame("x+2"); [EOL]     foldSame("x-2"); [EOL] } <line_num>: 975,1001
public void testFoldSimpleArithmeticOp() { [EOL]     foldSame("x*NaN"); [EOL]     foldSame("NaN/y"); [EOL]     foldSame("f(x)-0"); [EOL]     foldSame("f(x)*1"); [EOL]     foldSame("1*f(x)"); [EOL]     foldSame("0+a+b"); [EOL]     foldSame("0-a-b"); [EOL]     foldSame("a+b-0"); [EOL]     foldSame("(1+x)*NaN"); [EOL]     foldSame("(1+f(x))*NaN"); [EOL] } <line_num>: 1003,1015
public void testFoldLiteralsAsNumbers() { [EOL]     fold("x/'12'", "x/12"); [EOL]     fold("x/('12'+'6')", "x/126"); [EOL]     fold("true*x", "1*x"); [EOL]     fold("x/false", "x/0"); [EOL] } <line_num>: 1017,1022
public void testNotFoldBackToTrueFalse() { [EOL]     late = false; [EOL]     fold("!0", "true"); [EOL]     fold("!1", "false"); [EOL]     fold("!3", "false"); [EOL]     late = true; [EOL]     foldSame("!0"); [EOL]     foldSame("!1"); [EOL]     fold("!3", "false"); [EOL]     foldSame("false"); [EOL]     foldSame("true"); [EOL] } <line_num>: 1024,1036
public void testFoldBangConstants() { [EOL]     fold("1 + !0", "2"); [EOL]     fold("1 + !1", "1"); [EOL]     fold("'a ' + !1", "'a false'"); [EOL]     fold("'a ' + !0", "'a true'"); [EOL] } <line_num>: 1038,1043
public void testFoldMixed() { [EOL]     fold("''+[1]", "'1'"); [EOL]     foldSame("false+[]"); [EOL] } <line_num>: 1045,1048
public void testFoldVoid() { [EOL]     foldSame("void 0"); [EOL]     fold("void 1", "void 0"); [EOL]     fold("void x", "void 0"); [EOL]     fold("void x()", "void x()"); [EOL] } <line_num>: 1050,1055
public void testObjectLiteral() { [EOL]     test("(!{})", "false"); [EOL]     test("(!{a:1})", "false"); [EOL]     testSame("(!{a:foo()})"); [EOL]     testSame("(!{'a':foo()})"); [EOL] } <line_num>: 1057,1062
public void testArrayLiteral() { [EOL]     test("(![])", "false"); [EOL]     test("(![1])", "false"); [EOL]     test("(![a])", "false"); [EOL]     testSame("(![foo()])"); [EOL] } <line_num>: 1064,1069
public void testIssue601() { [EOL]     testSame("'\\v' == 'v'"); [EOL]     testSame("'v' == '\\v'"); [EOL]     testSame("'\\u000B' == '\\v'"); [EOL] } <line_num>: 1071,1075
public void testFoldObjectLiteralRef1() { [EOL]     testSame("var x = ({a:foo(),b:bar()}).a"); [EOL]     testSame("var x = ({a:1,b:bar()}).a"); [EOL]     testSame("function f() { return {b:foo(), a:2}.a; }"); [EOL]     testSame("({a:x}).a = 1"); [EOL]     test("({a:x}).a += 1", "({a:x}).a = x + 1"); [EOL]     testSame("({a:x}).a ++"); [EOL]     testSame("({a:x}).a --"); [EOL]     testSame("({a:function(){return this}}).a"); [EOL]     testSame("({get a() {return this}}).a"); [EOL]     testSame("({set a(b) {return this}}).a"); [EOL]     testSame("({}).a"); [EOL]     testSame("({}).a"); [EOL]     testSame("({set a(b) {}}).a"); [EOL]     test("({a:1,set a(b) {}}).a", "1"); [EOL]     test("({get a() {}}).a", "(function (){})()"); [EOL]     test("({get a() {},set a(b) {}}).a", "(function (){})()"); [EOL]     test("var x = ({a:function(){return 1}}).a", "var x = function(){return 1}"); [EOL]     test("var x = ({a:1}).a", "var x = 1"); [EOL]     test("var x = ({a:1, a:2}).a", "var x = 2"); [EOL]     test("var x = ({a:1, a:foo()}).a", "var x = foo()"); [EOL]     test("var x = ({a:foo()}).a", "var x = foo()"); [EOL]     test("function f() { return {a:1, b:2}.a; }", "function f() { return 1; }"); [EOL]     test("var x = ({'a':1})['a']", "var x = 1"); [EOL] } <line_num>: 1077,1122
public void testFoldObjectLiteralRef2() { [EOL]     late = false; [EOL]     test("({a:x}).a += 1", "({a:x}).a = x + 1"); [EOL]     late = true; [EOL]     testSame("({a:x}).a += 1"); [EOL] } <line_num>: 1124,1129
public void testIEString() { [EOL]     testSame("!+'\\v1'"); [EOL] } <line_num>: 1131,1133
public void testIssue522() { [EOL]     testSame("[][1] = 1;"); [EOL] } <line_num>: 1135,1137
public void testInvertibleOperators() { [EOL]     Map<String, String> inverses = ImmutableMap.<String, String>builder().put("==", "!=").put("===", "!==").put("<=", ">").put("<", ">=").put(">=", "<").put(">", "<=").put("!=", "==").put("!==", "===").build(); [EOL]     Set<String> comparators = ImmutableSet.of("<=", "<", ">=", ">"); [EOL]     Set<String> equalitors = ImmutableSet.of("==", "==="); [EOL]     Set<String> uncomparables = ImmutableSet.of("undefined", "void 0"); [EOL]     List<String> operators = ImmutableList.copyOf(inverses.values()); [EOL]     for (int iOperandA = 0; iOperandA < LITERAL_OPERANDS.size(); iOperandA++) { [EOL]         for (int iOperandB = 0; iOperandB < LITERAL_OPERANDS.size(); iOperandB++) { [EOL]             for (int iOp = 0; iOp < operators.size(); iOp++) { [EOL]                 String a = LITERAL_OPERANDS.get(iOperandA); [EOL]                 String b = LITERAL_OPERANDS.get(iOperandB); [EOL]                 String op = operators.get(iOp); [EOL]                 String inverse = inverses.get(op); [EOL]                 if (comparators.contains(op) && (uncomparables.contains(a) || uncomparables.contains(b))) { [EOL]                     assertSameResults(join(a, op, b), "false"); [EOL]                     assertSameResults(join(a, inverse, b), "false"); [EOL]                 } else if (a.equals(b) && equalitors.contains(op)) { [EOL]                     if (a.equals("NaN") || a.equals("Infinity") || a.equals("-Infinity")) { [EOL]                         foldSame(join(a, op, b)); [EOL]                         foldSame(join(a, inverse, b)); [EOL]                     } else { [EOL]                         assertSameResults(join(a, op, b), "true"); [EOL]                         assertSameResults(join(a, inverse, b), "false"); [EOL]                     } [EOL]                 } else { [EOL]                     assertNotSameResults(join(a, op, b), join(a, inverse, b)); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 1165,1211
public void testCommutativeOperators() { [EOL]     late = true; [EOL]     List<String> operators = ImmutableList.of("==", "!=", "===", "!==", "*", "|", "&", "^"); [EOL]     for (int iOperandA = 0; iOperandA < LITERAL_OPERANDS.size(); iOperandA++) { [EOL]         for (int iOperandB = iOperandA; iOperandB < LITERAL_OPERANDS.size(); iOperandB++) { [EOL]             for (int iOp = 0; iOp < operators.size(); iOp++) { [EOL]                 String a = LITERAL_OPERANDS.get(iOperandA); [EOL]                 String b = LITERAL_OPERANDS.get(iOperandB); [EOL]                 String op = operators.get(iOp); [EOL]                 assertSameResultsOrUncollapsed(join(a, op, b), join(b, op, a)); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 1213,1240
public void testConvertToNumberNegativeInf() { [EOL]     foldSame("var x = 3 * (r ? Infinity : -Infinity);"); [EOL] } <line_num>: 1242,1244
private String join(String operandA, String op, String operandB) { [EOL]     return operandA + " " + op + " " + operandB; [EOL] } <line_num>: 1246,1248
private void assertSameResultsOrUncollapsed(String exprA, String exprB) { [EOL]     String resultA = process(exprA); [EOL]     String resultB = process(exprB); [EOL]     if (resultA.equals(print(exprA))) { [EOL]         foldSame(exprA); [EOL]         foldSame(exprB); [EOL]     } else { [EOL]         assertSameResults(exprA, exprB); [EOL]     } [EOL] } <line_num>: 1250,1259
private void assertSameResults(String exprA, String exprB) { [EOL]     assertEquals("Expressions did not fold the same\nexprA: " + exprA + "\nexprB: " + exprB, process(exprA), process(exprB)); [EOL] } <line_num>: 1261,1266
private void assertNotSameResults(String exprA, String exprB) { [EOL]     assertFalse("Expressions folded the same\nexprA: " + exprA + "\nexprB: " + exprB, process(exprA).equals(process(exprB))); [EOL] } <line_num>: 1268,1273
private String process(String js) { [EOL]     return printHelper(js, true); [EOL] } <line_num>: 1275,1277
private String print(String js) { [EOL]     return printHelper(js, false); [EOL] } <line_num>: 1279,1281
private String printHelper(String js, boolean runProcessor) { [EOL]     Compiler compiler = createCompiler(); [EOL]     CompilerOptions options = getOptions(); [EOL]     compiler.init(ImmutableList.<SourceFile>of(), ImmutableList.of(SourceFile.fromCode("testcode", js)), options); [EOL]     Node root = compiler.parseInputs(); [EOL]     assertTrue("Unexpected parse error(s): " + Joiner.on("\n").join(compiler.getErrors()) + "\nEXPR: " + js, root != null); [EOL]     Node externsRoot = root.getFirstChild(); [EOL]     Node mainRoot = externsRoot.getNext(); [EOL]     if (runProcessor) { [EOL]         getProcessor(compiler).process(externsRoot, mainRoot); [EOL]     } [EOL]     return compiler.toSource(mainRoot); [EOL] } <line_num>: 1283,1301
