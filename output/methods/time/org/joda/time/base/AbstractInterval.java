protected AbstractInterval() { [EOL]     super(); [EOL] } <line_num>: 49,51
protected void checkInterval(long start, long end) { [EOL]     if (end < start) { [EOL]         throw new IllegalArgumentException("The end instant must be greater or equal to the start"); [EOL]     } [EOL] } <line_num>: 61,65
public DateTime getStart() { [EOL]     return new DateTime(getStartMillis(), getChronology()); [EOL] } <line_num>: 73,75
public DateTime getEnd() { [EOL]     return new DateTime(getEndMillis(), getChronology()); [EOL] } <line_num>: 82,84
public boolean contains(long millisInstant) { [EOL]     long thisStart = getStartMillis(); [EOL]     long thisEnd = getEndMillis(); [EOL]     return (millisInstant >= thisStart && millisInstant < thisEnd); [EOL] } <line_num>: 97,101
public boolean containsNow() { [EOL]     return contains(DateTimeUtils.currentTimeMillis()); [EOL] } <line_num>: 111,113
public boolean contains(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return containsNow(); [EOL]     } [EOL]     return contains(instant.getMillis()); [EOL] } <line_num>: 137,142
public boolean contains(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         return containsNow(); [EOL]     } [EOL]     long otherStart = interval.getStartMillis(); [EOL]     long otherEnd = interval.getEndMillis(); [EOL]     long thisStart = getStartMillis(); [EOL]     long thisEnd = getEndMillis(); [EOL]     return (thisStart <= otherStart && otherStart < thisEnd && otherEnd <= thisEnd); [EOL] } <line_num>: 178,187
public boolean overlaps(ReadableInterval interval) { [EOL]     long thisStart = getStartMillis(); [EOL]     long thisEnd = getEndMillis(); [EOL]     if (interval == null) { [EOL]         long now = DateTimeUtils.currentTimeMillis(); [EOL]         return (thisStart < now && now < thisEnd); [EOL]     } else { [EOL]         long otherStart = interval.getStartMillis(); [EOL]         long otherEnd = interval.getEndMillis(); [EOL]         return (thisStart < otherEnd && otherStart < thisEnd); [EOL]     } [EOL] } <line_num>: 230,241
public boolean isEqual(ReadableInterval other) { [EOL]     return getStartMillis() == other.getStartMillis() && getEndMillis() == other.getEndMillis(); [EOL] } <line_num>: 253,256
public boolean isBefore(long millisInstant) { [EOL]     return (getEndMillis() <= millisInstant); [EOL] } <line_num>: 267,269
public boolean isBeforeNow() { [EOL]     return isBefore(DateTimeUtils.currentTimeMillis()); [EOL] } <line_num>: 278,280
public boolean isBefore(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return isBeforeNow(); [EOL]     } [EOL]     return isBefore(instant.getMillis()); [EOL] } <line_num>: 290,295
public boolean isBefore(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         return isBeforeNow(); [EOL]     } [EOL]     return isBefore(interval.getStartMillis()); [EOL] } <line_num>: 305,310
public boolean isAfter(long millisInstant) { [EOL]     return (getStartMillis() > millisInstant); [EOL] } <line_num>: 322,324
public boolean isAfterNow() { [EOL]     return isAfter(DateTimeUtils.currentTimeMillis()); [EOL] } <line_num>: 333,335
public boolean isAfter(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return isAfterNow(); [EOL]     } [EOL]     return isAfter(instant.getMillis()); [EOL] } <line_num>: 345,350
public boolean isAfter(ReadableInterval interval) { [EOL]     long endMillis; [EOL]     if (interval == null) { [EOL]         endMillis = DateTimeUtils.currentTimeMillis(); [EOL]     } else { [EOL]         endMillis = interval.getEndMillis(); [EOL]     } [EOL]     return (getStartMillis() >= endMillis); [EOL] } <line_num>: 361,369
public Interval toInterval() { [EOL]     return new Interval(getStartMillis(), getEndMillis(), getChronology()); [EOL] } <line_num>: 377,379
public MutableInterval toMutableInterval() { [EOL]     return new MutableInterval(getStartMillis(), getEndMillis(), getChronology()); [EOL] } <line_num>: 388,390
public long toDurationMillis() { [EOL]     return FieldUtils.safeAdd(getEndMillis(), -getStartMillis()); [EOL] } <line_num>: 401,403
public Duration toDuration() { [EOL]     long durMillis = toDurationMillis(); [EOL]     if (durMillis == 0) { [EOL]         return Duration.ZERO; [EOL]     } else { [EOL]         return new Duration(durMillis); [EOL]     } [EOL] } <line_num>: 413,420
public Period toPeriod() { [EOL]     return new Period(getStartMillis(), getEndMillis(), getChronology()); [EOL] } <line_num>: 432,434
public Period toPeriod(PeriodType type) { [EOL]     return new Period(getStartMillis(), getEndMillis(), type, getChronology()); [EOL] } <line_num>: 446,448
public boolean equals(Object readableInterval) { [EOL]     if (this == readableInterval) { [EOL]         return true; [EOL]     } [EOL]     if (readableInterval instanceof ReadableInterval == false) { [EOL]         return false; [EOL]     } [EOL]     ReadableInterval other = (ReadableInterval) readableInterval; [EOL]     return getStartMillis() == other.getStartMillis() && getEndMillis() == other.getEndMillis() && FieldUtils.equals(getChronology(), other.getChronology()); [EOL] } <line_num>: 463,475
public int hashCode() { [EOL]     long start = getStartMillis(); [EOL]     long end = getEndMillis(); [EOL]     int result = 97; [EOL]     result = 31 * result + ((int) (start ^ (start >>> 32))); [EOL]     result = 31 * result + ((int) (end ^ (end >>> 32))); [EOL]     result = 31 * result + getChronology().hashCode(); [EOL]     return result; [EOL] } <line_num>: 482,490
public String toString() { [EOL]     DateTimeFormatter printer = ISODateTimeFormat.dateTime(); [EOL]     printer = printer.withChronology(getChronology()); [EOL]     StringBuffer buf = new StringBuffer(48); [EOL]     printer.printTo(buf, getStartMillis()); [EOL]     buf.append('/'); [EOL]     printer.printTo(buf, getEndMillis()); [EOL]     return buf.toString(); [EOL] } <line_num>: 499,507
