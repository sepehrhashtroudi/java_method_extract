protected DateTimeZone(String id) { [EOL]     if (id == null) { [EOL]         throw new IllegalArgumentException("Id must not be null"); [EOL]     } [EOL]     iID = id; [EOL] } <line_num>: 714,719
Stub(String id) { [EOL]     iID = id; [EOL] } <line_num>: 1307,1309
public static DateTimeZone getDefault() { [EOL]     DateTimeZone zone = cDefault; [EOL]     if (zone == null) { [EOL]         synchronized (DateTimeZone.class) { [EOL]             zone = cDefault; [EOL]             if (zone == null) { [EOL]                 DateTimeZone temp = null; [EOL]                 try { [EOL]                     try { [EOL]                         String id = System.getProperty("user.timezone"); [EOL]                         if (id != null) { [EOL]                             temp = forID(id); [EOL]                         } [EOL]                     } catch (RuntimeException ex) { [EOL]                     } [EOL]                     if (temp == null) { [EOL]                         temp = forTimeZone(TimeZone.getDefault()); [EOL]                     } [EOL]                 } catch (IllegalArgumentException ex) { [EOL]                 } [EOL]                 if (temp == null) { [EOL]                     temp = UTC; [EOL]                 } [EOL]                 cDefault = zone = temp; [EOL]             } [EOL]         } [EOL]     } [EOL]     return zone; [EOL] } <line_num>: 133,163
public static void setDefault(DateTimeZone zone) throws SecurityException { [EOL]     SecurityManager sm = System.getSecurityManager(); [EOL]     if (sm != null) { [EOL]         sm.checkPermission(new JodaTimePermission("DateTimeZone.setDefault")); [EOL]     } [EOL]     if (zone == null) { [EOL]         throw new IllegalArgumentException("The datetime zone must not be null"); [EOL]     } [EOL]     synchronized (DateTimeZone.class) { [EOL]         cDefault = zone; [EOL]     } [EOL] } <line_num>: 174,185
@FromString [EOL] public static DateTimeZone forID(String id) { [EOL]     if (id == null) { [EOL]         return getDefault(); [EOL]     } [EOL]     if (id.equals("UTC")) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     DateTimeZone zone = cProvider.getZone(id); [EOL]     if (zone != null) { [EOL]         return zone; [EOL]     } [EOL]     if (id.startsWith("+") || id.startsWith("-")) { [EOL]         int offset = parseOffset(id); [EOL]         if (offset == 0L) { [EOL]             return DateTimeZone.UTC; [EOL]         } else { [EOL]             id = printOffset(offset); [EOL]             return fixedOffsetZone(id, offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised"); [EOL] } <line_num>: 203,225
public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException { [EOL]     return forOffsetHoursMinutes(hoursOffset, 0); [EOL] } <line_num>: 237,239
public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { [EOL]     if (hoursOffset == 0 && minutesOffset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     if (hoursOffset < -23 || hoursOffset > 23) { [EOL]         throw new IllegalArgumentException("Hours out of range: " + hoursOffset); [EOL]     } [EOL]     if (minutesOffset < -59 || minutesOffset > 59) { [EOL]         throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); [EOL]     } [EOL]     if (hoursOffset > 0 && minutesOffset < 0) { [EOL]         throw new IllegalArgumentException("Positive hours must not have negative minutes: " + minutesOffset); [EOL]     } [EOL]     int offset = 0; [EOL]     try { [EOL]         int hoursInMinutes = hoursOffset * 60; [EOL]         if (hoursInMinutes < 0) { [EOL]             minutesOffset = hoursInMinutes - Math.abs(minutesOffset); [EOL]         } else { [EOL]             minutesOffset = hoursInMinutes + minutesOffset; [EOL]         } [EOL]         offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); [EOL]     } catch (ArithmeticException ex) { [EOL]         throw new IllegalArgumentException("Offset is too large"); [EOL]     } [EOL]     return forOffsetMillis(offset); [EOL] } <line_num>: 272,298
public static DateTimeZone forOffsetMillis(int millisOffset) { [EOL]     if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) { [EOL]         throw new IllegalArgumentException("Millis out of range: " + millisOffset); [EOL]     } [EOL]     String id = printOffset(millisOffset); [EOL]     return fixedOffsetZone(id, millisOffset); [EOL] } <line_num>: 306,312
public static DateTimeZone forTimeZone(TimeZone zone) { [EOL]     if (zone == null) { [EOL]         return getDefault(); [EOL]     } [EOL]     final String id = zone.getID(); [EOL]     if (id.equals("UTC")) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     DateTimeZone dtz = null; [EOL]     String convId = getConvertedId(id); [EOL]     if (convId != null) { [EOL]         dtz = cProvider.getZone(convId); [EOL]     } [EOL]     if (dtz == null) { [EOL]         dtz = cProvider.getZone(id); [EOL]     } [EOL]     if (dtz != null) { [EOL]         return dtz; [EOL]     } [EOL]     if (convId == null) { [EOL]         convId = zone.getID(); [EOL]         if (convId.startsWith("GMT+") || convId.startsWith("GMT-")) { [EOL]             convId = convId.substring(3); [EOL]             int offset = parseOffset(convId); [EOL]             if (offset == 0L) { [EOL]                 return DateTimeZone.UTC; [EOL]             } else { [EOL]                 convId = printOffset(offset); [EOL]                 return fixedOffsetZone(convId, offset); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised"); [EOL] } <line_num>: 329,366
private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) { [EOL]     if (offset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     if (iFixedOffsetCache == null) { [EOL]         iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>(); [EOL]     } [EOL]     DateTimeZone zone; [EOL]     Reference<DateTimeZone> ref = iFixedOffsetCache.get(id); [EOL]     if (ref != null) { [EOL]         zone = ref.get(); [EOL]         if (zone != null) { [EOL]             return zone; [EOL]         } [EOL]     } [EOL]     zone = new FixedDateTimeZone(id, null, offset, offset); [EOL]     iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone)); [EOL]     return zone; [EOL] } <line_num>: 376,394
public static Set<String> getAvailableIDs() { [EOL]     return cAvailableIDs; [EOL] } <line_num>: 401,403
public static Provider getProvider() { [EOL]     return cProvider; [EOL] } <line_num>: 414,416
public static void setProvider(Provider provider) throws SecurityException { [EOL]     SecurityManager sm = System.getSecurityManager(); [EOL]     if (sm != null) { [EOL]         sm.checkPermission(new JodaTimePermission("DateTimeZone.setProvider")); [EOL]     } [EOL]     setProvider0(provider); [EOL] } <line_num>: 428,434
private static void setProvider0(Provider provider) { [EOL]     if (provider == null) { [EOL]         provider = getDefaultProvider(); [EOL]     } [EOL]     Set<String> ids = provider.getAvailableIDs(); [EOL]     if (ids == null || ids.size() == 0) { [EOL]         throw new IllegalArgumentException("The provider doesn't have any available ids"); [EOL]     } [EOL]     if (!ids.contains("UTC")) { [EOL]         throw new IllegalArgumentException("The provider doesn't support UTC"); [EOL]     } [EOL]     if (!UTC.equals(provider.getZone("UTC"))) { [EOL]         throw new IllegalArgumentException("Invalid UTC zone provided"); [EOL]     } [EOL]     cProvider = provider; [EOL]     cAvailableIDs = ids; [EOL] } <line_num>: 442,459
private static Provider getDefaultProvider() { [EOL]     Provider provider = null; [EOL]     try { [EOL]         String providerClass = System.getProperty("org.joda.time.DateTimeZone.Provider"); [EOL]         if (providerClass != null) { [EOL]             try { [EOL]                 provider = (Provider) Class.forName(providerClass).newInstance(); [EOL]             } catch (Exception ex) { [EOL]                 throw new RuntimeException(ex); [EOL]             } [EOL]         } [EOL]     } catch (SecurityException ex) { [EOL]     } [EOL]     if (provider == null) { [EOL]         try { [EOL]             provider = new ZoneInfoProvider("org/joda/time/tz/data"); [EOL]         } catch (Exception ex) { [EOL]             ex.printStackTrace(); [EOL]         } [EOL]     } [EOL]     if (provider == null) { [EOL]         provider = new UTCProvider(); [EOL]     } [EOL]     return provider; [EOL] } <line_num>: 470,499
public static NameProvider getNameProvider() { [EOL]     return cNameProvider; [EOL] } <line_num>: 510,512
public static void setNameProvider(NameProvider nameProvider) throws SecurityException { [EOL]     SecurityManager sm = System.getSecurityManager(); [EOL]     if (sm != null) { [EOL]         sm.checkPermission(new JodaTimePermission("DateTimeZone.setNameProvider")); [EOL]     } [EOL]     setNameProvider0(nameProvider); [EOL] } <line_num>: 524,530
private static void setNameProvider0(NameProvider nameProvider) { [EOL]     if (nameProvider == null) { [EOL]         nameProvider = getDefaultNameProvider(); [EOL]     } [EOL]     cNameProvider = nameProvider; [EOL] } <line_num>: 538,543
private static NameProvider getDefaultNameProvider() { [EOL]     NameProvider nameProvider = null; [EOL]     try { [EOL]         String providerClass = System.getProperty("org.joda.time.DateTimeZone.NameProvider"); [EOL]         if (providerClass != null) { [EOL]             try { [EOL]                 nameProvider = (NameProvider) Class.forName(providerClass).newInstance(); [EOL]             } catch (Exception ex) { [EOL]                 throw new RuntimeException(ex); [EOL]             } [EOL]         } [EOL]     } catch (SecurityException ex) { [EOL]     } [EOL]     if (nameProvider == null) { [EOL]         nameProvider = new DefaultNameProvider(); [EOL]     } [EOL]     return nameProvider; [EOL] } <line_num>: 553,573
private static synchronized String getConvertedId(String id) { [EOL]     Map<String, String> map = cZoneIdConversion; [EOL]     if (map == null) { [EOL]         map = new HashMap<String, String>(); [EOL]         map.put("GMT", "UTC"); [EOL]         map.put("WET", "WET"); [EOL]         map.put("CET", "CET"); [EOL]         map.put("MET", "CET"); [EOL]         map.put("ECT", "CET"); [EOL]         map.put("EET", "EET"); [EOL]         map.put("MIT", "Pacific/Apia"); [EOL]         map.put("HST", "Pacific/Honolulu"); [EOL]         map.put("AST", "America/Anchorage"); [EOL]         map.put("PST", "America/Los_Angeles"); [EOL]         map.put("MST", "America/Denver"); [EOL]         map.put("PNT", "America/Phoenix"); [EOL]         map.put("CST", "America/Chicago"); [EOL]         map.put("EST", "America/New_York"); [EOL]         map.put("IET", "America/Indiana/Indianapolis"); [EOL]         map.put("PRT", "America/Puerto_Rico"); [EOL]         map.put("CNT", "America/St_Johns"); [EOL]         map.put("AGT", "America/Argentina/Buenos_Aires"); [EOL]         map.put("BET", "America/Sao_Paulo"); [EOL]         map.put("ART", "Africa/Cairo"); [EOL]         map.put("CAT", "Africa/Harare"); [EOL]         map.put("EAT", "Africa/Addis_Ababa"); [EOL]         map.put("NET", "Asia/Yerevan"); [EOL]         map.put("PLT", "Asia/Karachi"); [EOL]         map.put("IST", "Asia/Kolkata"); [EOL]         map.put("BST", "Asia/Dhaka"); [EOL]         map.put("VST", "Asia/Ho_Chi_Minh"); [EOL]         map.put("CTT", "Asia/Shanghai"); [EOL]         map.put("JST", "Asia/Tokyo"); [EOL]         map.put("ACT", "Australia/Darwin"); [EOL]         map.put("AET", "Australia/Sydney"); [EOL]         map.put("SST", "Pacific/Guadalcanal"); [EOL]         map.put("NST", "Pacific/Auckland"); [EOL]         cZoneIdConversion = map; [EOL]     } [EOL]     return map.get(id); [EOL] } <line_num>: 582,623
public DateTimeZone getZone() { [EOL]     return null; [EOL] } <line_num>: 630,632
public Chronology withUTC() { [EOL]     return this; [EOL] } <line_num>: 633,635
public Chronology withZone(DateTimeZone zone) { [EOL]     return this; [EOL] } <line_num>: 636,638
public String toString() { [EOL]     return getClass().getName(); [EOL] } <line_num>: 639,641
private static int parseOffset(String str) { [EOL]     Chronology chrono = new BaseChronology() { [EOL]  [EOL]         private static final long serialVersionUID = -3128740902654445468L; [EOL]  [EOL]         public DateTimeZone getZone() { [EOL]             return null; [EOL]         } [EOL]  [EOL]         public Chronology withUTC() { [EOL]             return this; [EOL]         } [EOL]  [EOL]         public Chronology withZone(DateTimeZone zone) { [EOL]             return this; [EOL]         } [EOL]  [EOL]         public String toString() { [EOL]             return getClass().getName(); [EOL]         } [EOL]     }; [EOL]     return -(int) offsetFormatter().withChronology(chrono).parseMillis(str); [EOL] } <line_num>: 625,644
private static String printOffset(int offset) { [EOL]     StringBuffer buf = new StringBuffer(); [EOL]     if (offset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         offset = -offset; [EOL]     } [EOL]     int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     buf.append('.'); [EOL]     FormatUtils.appendPaddedInteger(buf, offset, 3); [EOL]     return buf.toString(); [EOL] } <line_num>: 655,687
private static synchronized DateTimeFormatter offsetFormatter() { [EOL]     if (cOffsetFormatter == null) { [EOL]         cOffsetFormatter = new DateTimeFormatterBuilder().appendTimeZoneOffset(null, true, 2, 4).toFormatter(); [EOL]     } [EOL]     return cOffsetFormatter; [EOL] } <line_num>: 694,701
@ToString [EOL] public final String getID() { [EOL]     return iID; [EOL] } <line_num>: 729,732
public abstract String getNameKey(long instant); <line_num>: 741,741
public final String getShortName(long instant) { [EOL]     return getShortName(instant, null); [EOL] } <line_num>: 753,755
public String getShortName(long instant, Locale locale) { [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     String nameKey = getNameKey(instant); [EOL]     if (nameKey == null) { [EOL]         return iID; [EOL]     } [EOL]     String name = cNameProvider.getShortName(locale, iID, nameKey); [EOL]     if (name != null) { [EOL]         return name; [EOL]     } [EOL]     return printOffset(getOffset(instant)); [EOL] } <line_num>: 768,781
public final String getName(long instant) { [EOL]     return getName(instant, null); [EOL] } <line_num>: 793,795
public String getName(long instant, Locale locale) { [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     String nameKey = getNameKey(instant); [EOL]     if (nameKey == null) { [EOL]         return iID; [EOL]     } [EOL]     String name = cNameProvider.getName(locale, iID, nameKey); [EOL]     if (name != null) { [EOL]         return name; [EOL]     } [EOL]     return printOffset(getOffset(instant)); [EOL] } <line_num>: 808,821
public abstract int getOffset(long instant); <line_num>: 829,829
public final int getOffset(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return getOffset(DateTimeUtils.currentTimeMillis()); [EOL]     } [EOL]     return getOffset(instant.getMillis()); [EOL] } <line_num>: 837,842
public abstract int getStandardOffset(long instant); <line_num>: 851,851
public boolean isStandardOffset(long instant) { [EOL]     return getOffset(instant) == getStandardOffset(instant); [EOL] } <line_num>: 868,870
public int getOffsetFromLocal(long instantLocal) { [EOL]     final int offsetLocal = getOffset(instantLocal); [EOL]     final long instantAdjusted = instantLocal - offsetLocal; [EOL]     final int offsetAdjusted = getOffset(instantAdjusted); [EOL]     if (offsetLocal != offsetAdjusted) { [EOL]         if ((offsetLocal - offsetAdjusted) < 0) { [EOL]             long nextLocal = nextTransition(instantAdjusted); [EOL]             long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); [EOL]             if (nextLocal != nextAdjusted) { [EOL]                 return offsetLocal; [EOL]             } [EOL]         } [EOL]     } else if (offsetLocal >= 0) { [EOL]         long prev = previousTransition(instantAdjusted); [EOL]         if (prev < instantAdjusted) { [EOL]             int offsetPrev = getOffset(prev); [EOL]             int diff = offsetPrev - offsetLocal; [EOL]             if (instantAdjusted - prev <= diff) { [EOL]                 return offsetPrev; [EOL]             } [EOL]         } [EOL]     } [EOL]     return offsetAdjusted; [EOL] } <line_num>: 905,936
public long convertUTCToLocal(long instantUTC) { [EOL]     int offset = getOffset(instantUTC); [EOL]     long instantLocal = instantUTC + offset; [EOL]     if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) { [EOL]         throw new ArithmeticException("Adding time zone offset caused overflow"); [EOL]     } [EOL]     return instantLocal; [EOL] } <line_num>: 948,956
public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) { [EOL]     int offsetOriginal = getOffset(originalInstantUTC); [EOL]     long instantUTC = instantLocal - offsetOriginal; [EOL]     int offsetLocalFromOriginal = getOffset(instantUTC); [EOL]     if (offsetLocalFromOriginal == offsetOriginal) { [EOL]         return instantUTC; [EOL]     } [EOL]     return convertLocalToUTC(instantLocal, strict); [EOL] } <line_num>: 975,983
public long convertLocalToUTC(long instantLocal, boolean strict) { [EOL]     int offsetLocal = getOffset(instantLocal); [EOL]     int offset = getOffset(instantLocal - offsetLocal); [EOL]     if (offsetLocal != offset) { [EOL]         if (strict || offsetLocal < 0) { [EOL]             long nextLocal = nextTransition(instantLocal - offsetLocal); [EOL]             if (nextLocal == (instantLocal - offsetLocal)) { [EOL]                 nextLocal = Long.MAX_VALUE; [EOL]             } [EOL]             long nextAdjusted = nextTransition(instantLocal - offset); [EOL]             if (nextAdjusted == (instantLocal - offset)) { [EOL]                 nextAdjusted = Long.MAX_VALUE; [EOL]             } [EOL]             if (nextLocal != nextAdjusted) { [EOL]                 if (strict) { [EOL]                     throw new IllegalInstantException(instantLocal, getID()); [EOL]                 } else { [EOL]                     offset = offsetLocal; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     long instantUTC = instantLocal - offset; [EOL]     if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) { [EOL]         throw new ArithmeticException("Subtracting time zone offset caused overflow"); [EOL]     } [EOL]     return instantUTC; [EOL] } <line_num>: 997,1038
public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) { [EOL]     if (newZone == null) { [EOL]         newZone = DateTimeZone.getDefault(); [EOL]     } [EOL]     if (newZone == this) { [EOL]         return oldInstant; [EOL]     } [EOL]     long instantLocal = convertUTCToLocal(oldInstant); [EOL]     return newZone.convertLocalToUTC(instantLocal, false, oldInstant); [EOL] } <line_num>: 1050,1059
public boolean isLocalDateTimeGap(LocalDateTime localDateTime) { [EOL]     if (isFixed()) { [EOL]         return false; [EOL]     } [EOL]     try { [EOL]         localDateTime.toDateTime(this); [EOL]         return false; [EOL]     } catch (IllegalInstantException ex) { [EOL]         return true; [EOL]     } [EOL] } <line_num>: 1167,1177
public long adjustOffset(long instant, boolean earlierOrLater) { [EOL]     long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     long offsetBefore = getOffset(instantBefore); [EOL]     long offsetAfter = getOffset(instantAfter); [EOL]     if (offsetBefore <= offsetAfter) { [EOL]         return instant; [EOL]     } [EOL]     long diff = offsetBefore - offsetAfter; [EOL]     long transition = nextTransition(instantBefore); [EOL]     long overlapStart = transition - diff; [EOL]     long overlapEnd = transition + diff; [EOL]     if (instant < overlapStart || instant >= overlapEnd) { [EOL]         return instant; [EOL]     } [EOL]     long afterStart = instant - overlapStart; [EOL]     if (afterStart >= diff) { [EOL]         return earlierOrLater ? instant : instant - diff; [EOL]     } else { [EOL]         return earlierOrLater ? instant + diff : instant; [EOL]     } [EOL] } <line_num>: 1186,1216
public abstract boolean isFixed(); <line_num>: 1225,1225
public abstract long nextTransition(long instant); <line_num>: 1235,1235
public abstract long previousTransition(long instant); <line_num>: 1245,1245
public java.util.TimeZone toTimeZone() { [EOL]     return java.util.TimeZone.getTimeZone(iID); [EOL] } <line_num>: 1255,1257
public abstract boolean equals(Object object); <line_num>: 1265,1265
public int hashCode() { [EOL]     return 57 + getID().hashCode(); [EOL] } <line_num>: 1272,1274
public String toString() { [EOL]     return getID(); [EOL] } <line_num>: 1280,1282
protected Object writeReplace() throws ObjectStreamException { [EOL]     return new Stub(iID); [EOL] } <line_num>: 1290,1292
private void writeObject(ObjectOutputStream out) throws IOException { [EOL]     out.writeUTF(iID); [EOL] } <line_num>: 1311,1313
private void readObject(ObjectInputStream in) throws IOException { [EOL]     iID = in.readUTF(); [EOL] } <line_num>: 1315,1317
private Object readResolve() throws ObjectStreamException { [EOL]     return forID(iID); [EOL] } <line_num>: 1319,1321
