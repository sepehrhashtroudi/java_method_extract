public DateTimeFormatterBuilder() { [EOL]     super(); [EOL]     iElementPairs = new ArrayList<Object>(); [EOL] } <line_num>: 83,86
CharacterLiteral(char value) { [EOL]     super(); [EOL]     iValue = value; [EOL] } <line_num>: 1206,1209
StringLiteral(String value) { [EOL]     super(); [EOL]     iValue = value; [EOL] } <line_num>: 1269,1272
NumberFormatter(DateTimeFieldType fieldType, int maxParsedDigits, boolean signed) { [EOL]     super(); [EOL]     iFieldType = fieldType; [EOL]     iMaxParsedDigits = maxParsedDigits; [EOL]     iSigned = signed; [EOL] } <line_num>: 1317,1323
protected UnpaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits, boolean signed) { [EOL]     super(fieldType, maxParsedDigits, signed); [EOL] } <line_num>: 1398,1402
protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits, boolean signed, int minPrintedDigits) { [EOL]     super(fieldType, maxParsedDigits, signed); [EOL]     iMinPrintedDigits = minPrintedDigits; [EOL] } <line_num>: 1460,1465
protected FixedNumber(DateTimeFieldType fieldType, int numDigits, boolean signed) { [EOL]     super(fieldType, numDigits, signed, numDigits); [EOL] } <line_num>: 1521,1523
TwoDigitYear(DateTimeFieldType type, int pivot, boolean lenientParse) { [EOL]     super(); [EOL]     iType = type; [EOL]     iPivot = pivot; [EOL]     iLenientParse = lenientParse; [EOL] } <line_num>: 1560,1565
TextField(DateTimeFieldType fieldType, boolean isShort) { [EOL]     super(); [EOL]     iFieldType = fieldType; [EOL]     iShort = isShort; [EOL] } <line_num>: 1753,1757
protected Fraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     super(); [EOL]     iFieldType = fieldType; [EOL]     if (maxDigits > 18) { [EOL]         maxDigits = 18; [EOL]     } [EOL]     iMinDigits = minDigits; [EOL]     iMaxDigits = maxDigits; [EOL] } <line_num>: 1894,1903
TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText, boolean showSeparators, int minFields, int maxFields) { [EOL]     super(); [EOL]     iZeroOffsetPrintText = zeroOffsetPrintText; [EOL]     iZeroOffsetParseText = zeroOffsetParseText; [EOL]     iShowSeparators = showSeparators; [EOL]     if (minFields <= 0 || maxFields < minFields) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (minFields > 4) { [EOL]         minFields = 4; [EOL]         maxFields = 4; [EOL]     } [EOL]     iMinFields = minFields; [EOL]     iMaxFields = maxFields; [EOL] } <line_num>: 2117,2134
TimeZoneName(int type, Map<String, DateTimeZone> parseLookup) { [EOL]     super(); [EOL]     iType = type; [EOL]     iParseLookup = parseLookup; [EOL] } <line_num>: 2476,2480
Composite(List<Object> elementPairs) { [EOL]     super(); [EOL]     List<Object> printerList = new ArrayList<Object>(); [EOL]     List<Object> parserList = new ArrayList<Object>(); [EOL]     decompose(elementPairs, printerList, parserList); [EOL]     if (printerList.contains(null) || printerList.isEmpty()) { [EOL]         iPrinters = null; [EOL]         iPrintedLengthEstimate = 0; [EOL]     } else { [EOL]         int size = printerList.size(); [EOL]         iPrinters = new DateTimePrinter[size]; [EOL]         int printEst = 0; [EOL]         for (int i = 0; i < size; i++) { [EOL]             DateTimePrinter printer = (DateTimePrinter) printerList.get(i); [EOL]             printEst += printer.estimatePrintedLength(); [EOL]             iPrinters[i] = printer; [EOL]         } [EOL]         iPrintedLengthEstimate = printEst; [EOL]     } [EOL]     if (parserList.contains(null) || parserList.isEmpty()) { [EOL]         iParsers = null; [EOL]         iParsedLengthEstimate = 0; [EOL]     } else { [EOL]         int size = parserList.size(); [EOL]         iParsers = new DateTimeParser[size]; [EOL]         int parseEst = 0; [EOL]         for (int i = 0; i < size; i++) { [EOL]             DateTimeParser parser = (DateTimeParser) parserList.get(i); [EOL]             parseEst += parser.estimateParsedLength(); [EOL]             iParsers[i] = parser; [EOL]         } [EOL]         iParsedLengthEstimate = parseEst; [EOL]     } [EOL] } <line_num>: 2614,2651
MatchingParser(DateTimeParser[] parsers) { [EOL]     super(); [EOL]     iParsers = parsers; [EOL]     int est = 0; [EOL]     for (int i = parsers.length; --i >= 0; ) { [EOL]         DateTimeParser parser = parsers[i]; [EOL]         if (parser != null) { [EOL]             int len = parser.estimateParsedLength(); [EOL]             if (len > est) { [EOL]                 est = len; [EOL]             } [EOL]         } [EOL]     } [EOL]     iParsedLengthEstimate = est; [EOL] } <line_num>: 2793,2807
public DateTimeFormatter toFormatter() { [EOL]     Object f = getFormatter(); [EOL]     DateTimePrinter printer = null; [EOL]     if (isPrinter(f)) { [EOL]         printer = (DateTimePrinter) f; [EOL]     } [EOL]     DateTimeParser parser = null; [EOL]     if (isParser(f)) { [EOL]         parser = (DateTimeParser) f; [EOL]     } [EOL]     if (printer != null || parser != null) { [EOL]         return new DateTimeFormatter(printer, parser); [EOL]     } [EOL]     throw new UnsupportedOperationException("Both printing and parsing not supported"); [EOL] } <line_num>: 104,118
public DateTimePrinter toPrinter() { [EOL]     Object f = getFormatter(); [EOL]     if (isPrinter(f)) { [EOL]         return (DateTimePrinter) f; [EOL]     } [EOL]     throw new UnsupportedOperationException("Printing is not supported"); [EOL] } <line_num>: 132,138
public DateTimeParser toParser() { [EOL]     Object f = getFormatter(); [EOL]     if (isParser(f)) { [EOL]         return (DateTimeParser) f; [EOL]     } [EOL]     throw new UnsupportedOperationException("Parsing is not supported"); [EOL] } <line_num>: 152,158
public boolean canBuildFormatter() { [EOL]     return isFormatter(getFormatter()); [EOL] } <line_num>: 167,169
public boolean canBuildPrinter() { [EOL]     return isPrinter(getFormatter()); [EOL] } <line_num>: 177,179
public boolean canBuildParser() { [EOL]     return isParser(getFormatter()); [EOL] } <line_num>: 187,189
public void clear() { [EOL]     iFormatter = null; [EOL]     iElementPairs.clear(); [EOL] } <line_num>: 196,199
public DateTimeFormatterBuilder append(DateTimeFormatter formatter) { [EOL]     if (formatter == null) { [EOL]         throw new IllegalArgumentException("No formatter supplied"); [EOL]     } [EOL]     return append0(formatter.getPrinter(), formatter.getParser()); [EOL] } <line_num>: 216,221
public DateTimeFormatterBuilder append(DateTimePrinter printer) { [EOL]     checkPrinter(printer); [EOL]     return append0(printer, null); [EOL] } <line_num>: 237,240
public DateTimeFormatterBuilder append(DateTimeParser parser) { [EOL]     checkParser(parser); [EOL]     return append0(null, parser); [EOL] } <line_num>: 256,259
public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser parser) { [EOL]     checkPrinter(printer); [EOL]     checkParser(parser); [EOL]     return append0(printer, parser); [EOL] } <line_num>: 275,279
public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser[] parsers) { [EOL]     if (printer != null) { [EOL]         checkPrinter(printer); [EOL]     } [EOL]     if (parsers == null) { [EOL]         throw new IllegalArgumentException("No parsers supplied"); [EOL]     } [EOL]     int length = parsers.length; [EOL]     if (length == 1) { [EOL]         if (parsers[0] == null) { [EOL]             throw new IllegalArgumentException("No parser supplied"); [EOL]         } [EOL]         return append0(printer, parsers[0]); [EOL]     } [EOL]     DateTimeParser[] copyOfParsers = new DateTimeParser[length]; [EOL]     int i; [EOL]     for (i = 0; i < length - 1; i++) { [EOL]         if ((copyOfParsers[i] = parsers[i]) == null) { [EOL]             throw new IllegalArgumentException("Incomplete parser array"); [EOL]         } [EOL]     } [EOL]     copyOfParsers[i] = parsers[i]; [EOL]     return append0(printer, new MatchingParser(copyOfParsers)); [EOL] } <line_num>: 304,329
public DateTimeFormatterBuilder appendOptional(DateTimeParser parser) { [EOL]     checkParser(parser); [EOL]     DateTimeParser[] parsers = new DateTimeParser[] { parser, null }; [EOL]     return append0(null, new MatchingParser(parsers)); [EOL] } <line_num>: 344,348
private void checkParser(DateTimeParser parser) { [EOL]     if (parser == null) { [EOL]         throw new IllegalArgumentException("No parser supplied"); [EOL]     } [EOL] } <line_num>: 356,360
private void checkPrinter(DateTimePrinter printer) { [EOL]     if (printer == null) { [EOL]         throw new IllegalArgumentException("No printer supplied"); [EOL]     } [EOL] } <line_num>: 367,371
private DateTimeFormatterBuilder append0(Object element) { [EOL]     iFormatter = null; [EOL]     iElementPairs.add(element); [EOL]     iElementPairs.add(element); [EOL]     return this; [EOL] } <line_num>: 373,379
private DateTimeFormatterBuilder append0(DateTimePrinter printer, DateTimeParser parser) { [EOL]     iFormatter = null; [EOL]     iElementPairs.add(printer); [EOL]     iElementPairs.add(parser); [EOL]     return this; [EOL] } <line_num>: 381,387
public DateTimeFormatterBuilder appendLiteral(char c) { [EOL]     return append0(new CharacterLiteral(c)); [EOL] } <line_num>: 396,398
public DateTimeFormatterBuilder appendLiteral(String text) { [EOL]     if (text == null) { [EOL]         throw new IllegalArgumentException("Literal must not be null"); [EOL]     } [EOL]     switch(text.length()) { [EOL]         case 0: [EOL]             return this; [EOL]         case 1: [EOL]             return append0(new CharacterLiteral(text.charAt(0))); [EOL]         default: [EOL]             return append0(new StringLiteral(text)); [EOL]     } [EOL] } <line_num>: 407,419
public DateTimeFormatterBuilder appendDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (maxDigits < minDigits) { [EOL]         maxDigits = minDigits; [EOL]     } [EOL]     if (minDigits < 0 || maxDigits <= 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (minDigits <= 1) { [EOL]         return append0(new UnpaddedNumber(fieldType, maxDigits, false)); [EOL]     } else { [EOL]         return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits)); [EOL]     } [EOL] } <line_num>: 432,448
public DateTimeFormatterBuilder appendFixedDecimal(DateTimeFieldType fieldType, int numDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (numDigits <= 0) { [EOL]         throw new IllegalArgumentException("Illegal number of digits: " + numDigits); [EOL]     } [EOL]     return append0(new FixedNumber(fieldType, numDigits, false)); [EOL] } <line_num>: 462,471
public DateTimeFormatterBuilder appendSignedDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (maxDigits < minDigits) { [EOL]         maxDigits = minDigits; [EOL]     } [EOL]     if (minDigits < 0 || maxDigits <= 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (minDigits <= 1) { [EOL]         return append0(new UnpaddedNumber(fieldType, maxDigits, true)); [EOL]     } else { [EOL]         return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits)); [EOL]     } [EOL] } <line_num>: 484,500
public DateTimeFormatterBuilder appendFixedSignedDecimal(DateTimeFieldType fieldType, int numDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (numDigits <= 0) { [EOL]         throw new IllegalArgumentException("Illegal number of digits: " + numDigits); [EOL]     } [EOL]     return append0(new FixedNumber(fieldType, numDigits, true)); [EOL] } <line_num>: 514,523
public DateTimeFormatterBuilder appendText(DateTimeFieldType fieldType) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     return append0(new TextField(fieldType, false)); [EOL] } <line_num>: 533,538
public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     return append0(new TextField(fieldType, true)); [EOL] } <line_num>: 548,553
public DateTimeFormatterBuilder appendFraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (maxDigits < minDigits) { [EOL]         maxDigits = minDigits; [EOL]     } [EOL]     if (minDigits < 0 || maxDigits <= 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     return append0(new Fraction(fieldType, minDigits, maxDigits)); [EOL] } <line_num>: 568,580
public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) { [EOL]     return appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits); [EOL] } <line_num>: 596,598
public DateTimeFormatterBuilder appendFractionOfMinute(int minDigits, int maxDigits) { [EOL]     return appendFraction(DateTimeFieldType.minuteOfDay(), minDigits, maxDigits); [EOL] } <line_num>: 613,615
public DateTimeFormatterBuilder appendFractionOfHour(int minDigits, int maxDigits) { [EOL]     return appendFraction(DateTimeFieldType.hourOfDay(), minDigits, maxDigits); [EOL] } <line_num>: 630,632
public DateTimeFormatterBuilder appendFractionOfDay(int minDigits, int maxDigits) { [EOL]     return appendFraction(DateTimeFieldType.dayOfYear(), minDigits, maxDigits); [EOL] } <line_num>: 647,649
public DateTimeFormatterBuilder appendMillisOfSecond(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.millisOfSecond(), minDigits, 3); [EOL] } <line_num>: 664,666
public DateTimeFormatterBuilder appendMillisOfDay(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.millisOfDay(), minDigits, 8); [EOL] } <line_num>: 674,676
public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2); [EOL] } <line_num>: 684,686
public DateTimeFormatterBuilder appendSecondOfDay(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.secondOfDay(), minDigits, 5); [EOL] } <line_num>: 694,696
public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2); [EOL] } <line_num>: 704,706
public DateTimeFormatterBuilder appendMinuteOfDay(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.minuteOfDay(), minDigits, 4); [EOL] } <line_num>: 714,716
public DateTimeFormatterBuilder appendHourOfDay(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2); [EOL] } <line_num>: 724,726
public DateTimeFormatterBuilder appendClockhourOfDay(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.clockhourOfDay(), minDigits, 2); [EOL] } <line_num>: 734,736
public DateTimeFormatterBuilder appendHourOfHalfday(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.hourOfHalfday(), minDigits, 2); [EOL] } <line_num>: 744,746
public DateTimeFormatterBuilder appendClockhourOfHalfday(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.clockhourOfHalfday(), minDigits, 2); [EOL] } <line_num>: 754,756
public DateTimeFormatterBuilder appendDayOfWeek(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.dayOfWeek(), minDigits, 1); [EOL] } <line_num>: 764,766
public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2); [EOL] } <line_num>: 774,776
public DateTimeFormatterBuilder appendDayOfYear(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.dayOfYear(), minDigits, 3); [EOL] } <line_num>: 784,786
public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.weekOfWeekyear(), minDigits, 2); [EOL] } <line_num>: 794,796
public DateTimeFormatterBuilder appendWeekyear(int minDigits, int maxDigits) { [EOL]     return appendSignedDecimal(DateTimeFieldType.weekyear(), minDigits, maxDigits); [EOL] } <line_num>: 806,808
public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2); [EOL] } <line_num>: 816,818
public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) { [EOL]     return appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits); [EOL] } <line_num>: 828,830
public DateTimeFormatterBuilder appendTwoDigitYear(int pivot) { [EOL]     return appendTwoDigitYear(pivot, false); [EOL] } <line_num>: 850,852
public DateTimeFormatterBuilder appendTwoDigitYear(int pivot, boolean lenientParse) { [EOL]     return append0(new TwoDigitYear(DateTimeFieldType.year(), pivot, lenientParse)); [EOL] } <line_num>: 868,870
public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot) { [EOL]     return appendTwoDigitWeekyear(pivot, false); [EOL] } <line_num>: 890,892
public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot, boolean lenientParse) { [EOL]     return append0(new TwoDigitYear(DateTimeFieldType.weekyear(), pivot, lenientParse)); [EOL] } <line_num>: 908,910
public DateTimeFormatterBuilder appendYearOfEra(int minDigits, int maxDigits) { [EOL]     return appendDecimal(DateTimeFieldType.yearOfEra(), minDigits, maxDigits); [EOL] } <line_num>: 920,922
public DateTimeFormatterBuilder appendYearOfCentury(int minDigits, int maxDigits) { [EOL]     return appendDecimal(DateTimeFieldType.yearOfCentury(), minDigits, maxDigits); [EOL] } <line_num>: 932,934
public DateTimeFormatterBuilder appendCenturyOfEra(int minDigits, int maxDigits) { [EOL]     return appendSignedDecimal(DateTimeFieldType.centuryOfEra(), minDigits, maxDigits); [EOL] } <line_num>: 944,946
public DateTimeFormatterBuilder appendHalfdayOfDayText() { [EOL]     return appendText(DateTimeFieldType.halfdayOfDay()); [EOL] } <line_num>: 954,956
public DateTimeFormatterBuilder appendDayOfWeekText() { [EOL]     return appendText(DateTimeFieldType.dayOfWeek()); [EOL] } <line_num>: 964,966
public DateTimeFormatterBuilder appendDayOfWeekShortText() { [EOL]     return appendShortText(DateTimeFieldType.dayOfWeek()); [EOL] } <line_num>: 975,977
public DateTimeFormatterBuilder appendMonthOfYearText() { [EOL]     return appendText(DateTimeFieldType.monthOfYear()); [EOL] } <line_num>: 986,988
public DateTimeFormatterBuilder appendMonthOfYearShortText() { [EOL]     return appendShortText(DateTimeFieldType.monthOfYear()); [EOL] } <line_num>: 996,998
public DateTimeFormatterBuilder appendEraText() { [EOL]     return appendText(DateTimeFieldType.era()); [EOL] } <line_num>: 1006,1008
public DateTimeFormatterBuilder appendTimeZoneName() { [EOL]     return append0(new TimeZoneName(TimeZoneName.LONG_NAME, null), null); [EOL] } <line_num>: 1017,1019
public DateTimeFormatterBuilder appendTimeZoneName(Map<String, DateTimeZone> parseLookup) { [EOL]     TimeZoneName pp = new TimeZoneName(TimeZoneName.LONG_NAME, parseLookup); [EOL]     return append0(pp, pp); [EOL] } <line_num>: 1030,1033
public DateTimeFormatterBuilder appendTimeZoneShortName() { [EOL]     return append0(new TimeZoneName(TimeZoneName.SHORT_NAME, null), null); [EOL] } <line_num>: 1042,1044
public DateTimeFormatterBuilder appendTimeZoneShortName(Map<String, DateTimeZone> parseLookup) { [EOL]     TimeZoneName pp = new TimeZoneName(TimeZoneName.SHORT_NAME, parseLookup); [EOL]     return append0(pp, pp); [EOL] } <line_num>: 1056,1059
public DateTimeFormatterBuilder appendTimeZoneId() { [EOL]     return append0(TimeZoneId.INSTANCE, TimeZoneId.INSTANCE); [EOL] } <line_num>: 1067,1069
public DateTimeFormatterBuilder appendTimeZoneOffset(String zeroOffsetText, boolean showSeparators, int minFields, int maxFields) { [EOL]     return append0(new TimeZoneOffset(zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields)); [EOL] } <line_num>: 1088,1093
public DateTimeFormatterBuilder appendTimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText, boolean showSeparators, int minFields, int maxFields) { [EOL]     return append0(new TimeZoneOffset(zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields)); [EOL] } <line_num>: 1115,1120
public DateTimeFormatterBuilder appendPattern(String pattern) { [EOL]     DateTimeFormat.appendPatternTo(this, pattern); [EOL]     return this; [EOL] } <line_num>: 1131,1134
private Object getFormatter() { [EOL]     Object f = iFormatter; [EOL]     if (f == null) { [EOL]         if (iElementPairs.size() == 2) { [EOL]             Object printer = iElementPairs.get(0); [EOL]             Object parser = iElementPairs.get(1); [EOL]             if (printer != null) { [EOL]                 if (printer == parser || parser == null) { [EOL]                     f = printer; [EOL]                 } [EOL]             } else { [EOL]                 f = parser; [EOL]             } [EOL]         } [EOL]         if (f == null) { [EOL]             f = new Composite(iElementPairs); [EOL]         } [EOL]         iFormatter = f; [EOL]     } [EOL]     return f; [EOL] } <line_num>: 1137,1162
private boolean isPrinter(Object f) { [EOL]     if (f instanceof DateTimePrinter) { [EOL]         if (f instanceof Composite) { [EOL]             return ((Composite) f).isPrinter(); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1164,1172
private boolean isParser(Object f) { [EOL]     if (f instanceof DateTimeParser) { [EOL]         if (f instanceof Composite) { [EOL]             return ((Composite) f).isParser(); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1174,1182
private boolean isFormatter(Object f) { [EOL]     return (isPrinter(f) || isParser(f)); [EOL] } <line_num>: 1184,1186
static void appendUnknownString(StringBuffer buf, int len) { [EOL]     for (int i = len; --i >= 0; ) { [EOL]         buf.append('\ufffd'); [EOL]     } [EOL] } <line_num>: 1188,1192
static void printUnknownString(Writer out, int len) throws IOException { [EOL]     for (int i = len; --i >= 0; ) { [EOL]         out.write('\ufffd'); [EOL]     } [EOL] } <line_num>: 1194,1198
public int estimatePrintedLength() { [EOL]     return 1; [EOL] } <line_num>: 1211,1213
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     buf.append(iValue); [EOL] } <line_num>: 1215,1219
public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException { [EOL]     out.write(iValue); [EOL] } <line_num>: 1221,1225
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) { [EOL]     buf.append(iValue); [EOL] } <line_num>: 1227,1229
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException { [EOL]     out.write(iValue); [EOL] } <line_num>: 1231,1233
public int estimateParsedLength() { [EOL]     return 1; [EOL] } <line_num>: 1235,1237
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     if (position >= text.length()) { [EOL]         return ~position; [EOL]     } [EOL]     char a = text.charAt(position); [EOL]     char b = iValue; [EOL]     if (a != b) { [EOL]         a = Character.toUpperCase(a); [EOL]         b = Character.toUpperCase(b); [EOL]         if (a != b) { [EOL]             a = Character.toLowerCase(a); [EOL]             b = Character.toLowerCase(b); [EOL]             if (a != b) { [EOL]                 return ~position; [EOL]             } [EOL]         } [EOL]     } [EOL]     return position + 1; [EOL] } <line_num>: 1239,1260
public int estimatePrintedLength() { [EOL]     return iValue.length(); [EOL] } <line_num>: 1274,1276
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     buf.append(iValue); [EOL] } <line_num>: 1278,1282
public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException { [EOL]     out.write(iValue); [EOL] } <line_num>: 1284,1288
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) { [EOL]     buf.append(iValue); [EOL] } <line_num>: 1290,1292
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException { [EOL]     out.write(iValue); [EOL] } <line_num>: 1294,1296
public int estimateParsedLength() { [EOL]     return iValue.length(); [EOL] } <line_num>: 1298,1300
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     if (text.regionMatches(true, position, iValue, 0, iValue.length())) { [EOL]         return position + iValue.length(); [EOL]     } [EOL]     return ~position; [EOL] } <line_num>: 1302,1307
public int estimateParsedLength() { [EOL]     return iMaxParsedDigits; [EOL] } <line_num>: 1325,1327
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = Math.min(iMaxParsedDigits, text.length() - position); [EOL]     boolean negative = false; [EOL]     int length = 0; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (length == 0 && (c == '-' || c == '+') && iSigned) { [EOL]             negative = c == '-'; [EOL]             if (length + 1 >= limit || (c = text.charAt(position + length + 1)) < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             if (negative) { [EOL]                 length++; [EOL]             } else { [EOL]                 position++; [EOL]             } [EOL]             limit = Math.min(limit + 1, text.length() - position); [EOL]             continue; [EOL]         } [EOL]         if (c < '0' || c > '9') { [EOL]             break; [EOL]         } [EOL]         length++; [EOL]     } [EOL]     if (length == 0) { [EOL]         return ~position; [EOL]     } [EOL]     int value; [EOL]     if (length >= 9) { [EOL]         value = Integer.parseInt(text.substring(position, position += length)); [EOL]     } else { [EOL]         int i = position; [EOL]         if (negative) { [EOL]             i++; [EOL]         } [EOL]         try { [EOL]             value = text.charAt(i++) - '0'; [EOL]         } catch (StringIndexOutOfBoundsException e) { [EOL]             return ~position; [EOL]         } [EOL]         position += length; [EOL]         while (i < position) { [EOL]             value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]         } [EOL]         if (negative) { [EOL]             value = -value; [EOL]         } [EOL]     } [EOL]     bucket.saveField(iFieldType, value); [EOL]     return position; [EOL] } <line_num>: 1329,1392
public int estimatePrintedLength() { [EOL]     return iMaxParsedDigits; [EOL] } <line_num>: 1404,1406
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     try { [EOL]         DateTimeField field = iFieldType.getField(chrono); [EOL]         FormatUtils.appendUnpaddedInteger(buf, field.get(instant)); [EOL]     } catch (RuntimeException e) { [EOL]         buf.append('\ufffd'); [EOL]     } [EOL] } <line_num>: 1408,1417
public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException { [EOL]     try { [EOL]         DateTimeField field = iFieldType.getField(chrono); [EOL]         FormatUtils.writeUnpaddedInteger(out, field.get(instant)); [EOL]     } catch (RuntimeException e) { [EOL]         out.write('\ufffd'); [EOL]     } [EOL] } <line_num>: 1419,1428
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) { [EOL]     if (partial.isSupported(iFieldType)) { [EOL]         try { [EOL]             FormatUtils.appendUnpaddedInteger(buf, partial.get(iFieldType)); [EOL]         } catch (RuntimeException e) { [EOL]             buf.append('\ufffd'); [EOL]         } [EOL]     } else { [EOL]         buf.append('\ufffd'); [EOL]     } [EOL] } <line_num>: 1430,1440
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException { [EOL]     if (partial.isSupported(iFieldType)) { [EOL]         try { [EOL]             FormatUtils.writeUnpaddedInteger(out, partial.get(iFieldType)); [EOL]         } catch (RuntimeException e) { [EOL]             out.write('\ufffd'); [EOL]         } [EOL]     } else { [EOL]         out.write('\ufffd'); [EOL]     } [EOL] } <line_num>: 1442,1452
public int estimatePrintedLength() { [EOL]     return iMaxParsedDigits; [EOL] } <line_num>: 1467,1469
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     try { [EOL]         DateTimeField field = iFieldType.getField(chrono); [EOL]         FormatUtils.appendPaddedInteger(buf, field.get(instant), iMinPrintedDigits); [EOL]     } catch (RuntimeException e) { [EOL]         appendUnknownString(buf, iMinPrintedDigits); [EOL]     } [EOL] } <line_num>: 1471,1480
public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException { [EOL]     try { [EOL]         DateTimeField field = iFieldType.getField(chrono); [EOL]         FormatUtils.writePaddedInteger(out, field.get(instant), iMinPrintedDigits); [EOL]     } catch (RuntimeException e) { [EOL]         printUnknownString(out, iMinPrintedDigits); [EOL]     } [EOL] } <line_num>: 1482,1491
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) { [EOL]     if (partial.isSupported(iFieldType)) { [EOL]         try { [EOL]             FormatUtils.appendPaddedInteger(buf, partial.get(iFieldType), iMinPrintedDigits); [EOL]         } catch (RuntimeException e) { [EOL]             appendUnknownString(buf, iMinPrintedDigits); [EOL]         } [EOL]     } else { [EOL]         appendUnknownString(buf, iMinPrintedDigits); [EOL]     } [EOL] } <line_num>: 1493,1503
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException { [EOL]     if (partial.isSupported(iFieldType)) { [EOL]         try { [EOL]             FormatUtils.writePaddedInteger(out, partial.get(iFieldType), iMinPrintedDigits); [EOL]         } catch (RuntimeException e) { [EOL]             printUnknownString(out, iMinPrintedDigits); [EOL]         } [EOL]     } else { [EOL]         printUnknownString(out, iMinPrintedDigits); [EOL]     } [EOL] } <line_num>: 1505,1515
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int newPos = super.parseInto(bucket, text, position); [EOL]     if (newPos < 0) { [EOL]         return newPos; [EOL]     } [EOL]     int expectedPos = position + iMaxParsedDigits; [EOL]     if (newPos != expectedPos) { [EOL]         if (iSigned) { [EOL]             char c = text.charAt(position); [EOL]             if (c == '-' || c == '+') { [EOL]                 expectedPos++; [EOL]             } [EOL]         } [EOL]         if (newPos > expectedPos) { [EOL]             return ~(expectedPos + 1); [EOL]         } else if (newPos < expectedPos) { [EOL]             return ~newPos; [EOL]         } [EOL]     } [EOL]     return newPos; [EOL] } <line_num>: 1525,1547
public int estimateParsedLength() { [EOL]     return iLenientParse ? 4 : 2; [EOL] } <line_num>: 1567,1569
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     if (!iLenientParse) { [EOL]         limit = Math.min(2, limit); [EOL]         if (limit < 2) { [EOL]             return ~position; [EOL]         } [EOL]     } else { [EOL]         boolean hasSignChar = false; [EOL]         boolean negative = false; [EOL]         int length = 0; [EOL]         while (length < limit) { [EOL]             char c = text.charAt(position + length); [EOL]             if (length == 0 && (c == '-' || c == '+')) { [EOL]                 hasSignChar = true; [EOL]                 negative = c == '-'; [EOL]                 if (negative) { [EOL]                     length++; [EOL]                 } else { [EOL]                     position++; [EOL]                     limit--; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (c < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             length++; [EOL]         } [EOL]         if (length == 0) { [EOL]             return ~position; [EOL]         } [EOL]         if (hasSignChar || length != 2) { [EOL]             int value; [EOL]             if (length >= 9) { [EOL]                 value = Integer.parseInt(text.substring(position, position += length)); [EOL]             } else { [EOL]                 int i = position; [EOL]                 if (negative) { [EOL]                     i++; [EOL]                 } [EOL]                 try { [EOL]                     value = text.charAt(i++) - '0'; [EOL]                 } catch (StringIndexOutOfBoundsException e) { [EOL]                     return ~position; [EOL]                 } [EOL]                 position += length; [EOL]                 while (i < position) { [EOL]                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]                 } [EOL]                 if (negative) { [EOL]                     value = -value; [EOL]                 } [EOL]             } [EOL]             bucket.saveField(iType, value); [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int year; [EOL]     char c = text.charAt(position); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = c - '0'; [EOL]     c = text.charAt(position + 1); [EOL]     if (c < '0' || c > '9') { [EOL]         return ~position; [EOL]     } [EOL]     year = ((year << 3) + (year << 1)) + c - '0'; [EOL]     int pivot = iPivot; [EOL]     if (bucket.getPivotYear() != null) { [EOL]         pivot = bucket.getPivotYear().intValue(); [EOL]     } [EOL]     int low = pivot - 50; [EOL]     int t; [EOL]     if (low >= 0) { [EOL]         t = low % 100; [EOL]     } else { [EOL]         t = 99 + ((low + 1) % 100); [EOL]     } [EOL]     year += low + ((year < t) ? 100 : 0) - t; [EOL]     bucket.saveField(iType, year); [EOL]     return position + 2; [EOL] } <line_num>: 1571,1668
public int estimatePrintedLength() { [EOL]     return 2; [EOL] } <line_num>: 1670,1672
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     int year = getTwoDigitYear(instant, chrono); [EOL]     if (year < 0) { [EOL]         buf.append('\ufffd'); [EOL]         buf.append('\ufffd'); [EOL]     } else { [EOL]         FormatUtils.appendPaddedInteger(buf, year, 2); [EOL]     } [EOL] } <line_num>: 1674,1684
public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException { [EOL]     int year = getTwoDigitYear(instant, chrono); [EOL]     if (year < 0) { [EOL]         out.write('\ufffd'); [EOL]         out.write('\ufffd'); [EOL]     } else { [EOL]         FormatUtils.writePaddedInteger(out, year, 2); [EOL]     } [EOL] } <line_num>: 1686,1696
private int getTwoDigitYear(long instant, Chronology chrono) { [EOL]     try { [EOL]         int year = iType.getField(chrono).get(instant); [EOL]         if (year < 0) { [EOL]             year = -year; [EOL]         } [EOL]         return year % 100; [EOL]     } catch (RuntimeException e) { [EOL]         return -1; [EOL]     } [EOL] } <line_num>: 1698,1708
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) { [EOL]     int year = getTwoDigitYear(partial); [EOL]     if (year < 0) { [EOL]         buf.append('\ufffd'); [EOL]         buf.append('\ufffd'); [EOL]     } else { [EOL]         FormatUtils.appendPaddedInteger(buf, year, 2); [EOL]     } [EOL] } <line_num>: 1710,1718
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException { [EOL]     int year = getTwoDigitYear(partial); [EOL]     if (year < 0) { [EOL]         out.write('\ufffd'); [EOL]         out.write('\ufffd'); [EOL]     } else { [EOL]         FormatUtils.writePaddedInteger(out, year, 2); [EOL]     } [EOL] } <line_num>: 1720,1728
private int getTwoDigitYear(ReadablePartial partial) { [EOL]     if (partial.isSupported(iType)) { [EOL]         try { [EOL]             int year = partial.get(iType); [EOL]             if (year < 0) { [EOL]                 year = -year; [EOL]             } [EOL]             return year % 100; [EOL]         } catch (RuntimeException e) { [EOL]         } [EOL]     } [EOL]     return -1; [EOL] } <line_num>: 1730,1741
public int estimatePrintedLength() { [EOL]     return iShort ? 6 : 20; [EOL] } <line_num>: 1759,1761
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     try { [EOL]         buf.append(print(instant, chrono, locale)); [EOL]     } catch (RuntimeException e) { [EOL]         buf.append('\ufffd'); [EOL]     } [EOL] } <line_num>: 1763,1771
public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException { [EOL]     try { [EOL]         out.write(print(instant, chrono, locale)); [EOL]     } catch (RuntimeException e) { [EOL]         out.write('\ufffd'); [EOL]     } [EOL] } <line_num>: 1773,1781
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) { [EOL]     try { [EOL]         buf.append(print(partial, locale)); [EOL]     } catch (RuntimeException e) { [EOL]         buf.append('\ufffd'); [EOL]     } [EOL] } <line_num>: 1783,1789
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException { [EOL]     try { [EOL]         out.write(print(partial, locale)); [EOL]     } catch (RuntimeException e) { [EOL]         out.write('\ufffd'); [EOL]     } [EOL] } <line_num>: 1791,1797
private String print(long instant, Chronology chrono, Locale locale) { [EOL]     DateTimeField field = iFieldType.getField(chrono); [EOL]     if (iShort) { [EOL]         return field.getAsShortText(instant, locale); [EOL]     } else { [EOL]         return field.getAsText(instant, locale); [EOL]     } [EOL] } <line_num>: 1799,1806
private String print(ReadablePartial partial, Locale locale) { [EOL]     if (partial.isSupported(iFieldType)) { [EOL]         DateTimeField field = iFieldType.getField(partial.getChronology()); [EOL]         if (iShort) { [EOL]             return field.getAsShortText(partial, locale); [EOL]         } else { [EOL]             return field.getAsText(partial, locale); [EOL]         } [EOL]     } else { [EOL]         return "\ufffd"; [EOL]     } [EOL] } <line_num>: 1808,1819
public int estimateParsedLength() { [EOL]     return estimatePrintedLength(); [EOL] } <line_num>: 1821,1823
@SuppressWarnings("unchecked") [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     Locale locale = bucket.getLocale(); [EOL]     Set<String> validValues = null; [EOL]     int maxLength = 0; [EOL]     synchronized (cParseCache) { [EOL]         Map<DateTimeFieldType, Object[]> innerMap = cParseCache.get(locale); [EOL]         if (innerMap == null) { [EOL]             innerMap = new HashMap<DateTimeFieldType, Object[]>(); [EOL]             cParseCache.put(locale, innerMap); [EOL]         } [EOL]         Object[] array = innerMap.get(iFieldType); [EOL]         if (array == null) { [EOL]             validValues = new HashSet<String>(32); [EOL]             MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC); [EOL]             Property property = dt.property(iFieldType); [EOL]             int min = property.getMinimumValueOverall(); [EOL]             int max = property.getMaximumValueOverall(); [EOL]             if (max - min > 32) { [EOL]                 return ~position; [EOL]             } [EOL]             maxLength = property.getMaximumTextLength(locale); [EOL]             for (int i = min; i <= max; i++) { [EOL]                 property.set(i); [EOL]                 validValues.add(property.getAsShortText(locale)); [EOL]                 validValues.add(property.getAsShortText(locale).toLowerCase(locale)); [EOL]                 validValues.add(property.getAsShortText(locale).toUpperCase(locale)); [EOL]                 validValues.add(property.getAsText(locale)); [EOL]                 validValues.add(property.getAsText(locale).toLowerCase(locale)); [EOL]                 validValues.add(property.getAsText(locale).toUpperCase(locale)); [EOL]             } [EOL]             if ("en".equals(locale.getLanguage()) && iFieldType == DateTimeFieldType.era()) { [EOL]                 validValues.add("BCE"); [EOL]                 validValues.add("bce"); [EOL]                 validValues.add("CE"); [EOL]                 validValues.add("ce"); [EOL]                 maxLength = 3; [EOL]             } [EOL]             array = new Object[] { validValues, Integer.valueOf(maxLength) }; [EOL]             innerMap.put(iFieldType, array); [EOL]         } else { [EOL]             validValues = (Set<String>) array[0]; [EOL]             maxLength = ((Integer) array[1]).intValue(); [EOL]         } [EOL]     } [EOL]     int limit = Math.min(text.length(), position + maxLength); [EOL]     for (int i = limit; i > position; i--) { [EOL]         String match = text.substring(position, i); [EOL]         if (validValues.contains(match)) { [EOL]             bucket.saveField(iFieldType, match, locale); [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return ~position; [EOL] } <line_num>: 1825,1883
public int estimatePrintedLength() { [EOL]     return iMaxDigits; [EOL] } <line_num>: 1905,1907
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     try { [EOL]         printTo(buf, null, instant, chrono); [EOL]     } catch (IOException e) { [EOL]     } [EOL] } <line_num>: 1909,1917
public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException { [EOL]     printTo(null, out, instant, chrono); [EOL] } <line_num>: 1919,1923
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) { [EOL]     long millis = partial.getChronology().set(partial, 0L); [EOL]     try { [EOL]         printTo(buf, null, millis, partial.getChronology()); [EOL]     } catch (IOException e) { [EOL]     } [EOL] } <line_num>: 1925,1934
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException { [EOL]     long millis = partial.getChronology().set(partial, 0L); [EOL]     printTo(null, out, millis, partial.getChronology()); [EOL] } <line_num>: 1936,1941
protected void printTo(StringBuffer buf, Writer out, long instant, Chronology chrono) throws IOException { [EOL]     DateTimeField field = iFieldType.getField(chrono); [EOL]     int minDigits = iMinDigits; [EOL]     long fraction; [EOL]     try { [EOL]         fraction = field.remainder(instant); [EOL]     } catch (RuntimeException e) { [EOL]         if (buf != null) { [EOL]             appendUnknownString(buf, minDigits); [EOL]         } else { [EOL]             printUnknownString(out, minDigits); [EOL]         } [EOL]         return; [EOL]     } [EOL]     if (fraction == 0) { [EOL]         if (buf != null) { [EOL]             while (--minDigits >= 0) { [EOL]                 buf.append('0'); [EOL]             } [EOL]         } else { [EOL]             while (--minDigits >= 0) { [EOL]                 out.write('0'); [EOL]             } [EOL]         } [EOL]         return; [EOL]     } [EOL]     String str; [EOL]     long[] fractionData = getFractionData(fraction, field); [EOL]     long scaled = fractionData[0]; [EOL]     int maxDigits = (int) fractionData[1]; [EOL]     if ((scaled & 0x7fffffff) == scaled) { [EOL]         str = Integer.toString((int) scaled); [EOL]     } else { [EOL]         str = Long.toString(scaled); [EOL]     } [EOL]     int length = str.length(); [EOL]     int digits = maxDigits; [EOL]     while (length < digits) { [EOL]         if (buf != null) { [EOL]             buf.append('0'); [EOL]         } else { [EOL]             out.write('0'); [EOL]         } [EOL]         minDigits--; [EOL]         digits--; [EOL]     } [EOL]     if (minDigits < digits) { [EOL]         while (minDigits < digits) { [EOL]             if (length <= 1 || str.charAt(length - 1) != '0') { [EOL]                 break; [EOL]             } [EOL]             digits--; [EOL]             length--; [EOL]         } [EOL]         if (length < str.length()) { [EOL]             if (buf != null) { [EOL]                 for (int i = 0; i < length; i++) { [EOL]                     buf.append(str.charAt(i)); [EOL]                 } [EOL]             } else { [EOL]                 for (int i = 0; i < length; i++) { [EOL]                     out.write(str.charAt(i)); [EOL]                 } [EOL]             } [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (buf != null) { [EOL]         buf.append(str); [EOL]     } else { [EOL]         out.write(str); [EOL]     } [EOL] } <line_num>: 1943,2025
private long[] getFractionData(long fraction, DateTimeField field) { [EOL]     long rangeMillis = field.getDurationField().getUnitMillis(); [EOL]     long scalar; [EOL]     int maxDigits = iMaxDigits; [EOL]     while (true) { [EOL]         switch(maxDigits) { [EOL]             default: [EOL]                 scalar = 1L; [EOL]                 break; [EOL]             case 1: [EOL]                 scalar = 10L; [EOL]                 break; [EOL]             case 2: [EOL]                 scalar = 100L; [EOL]                 break; [EOL]             case 3: [EOL]                 scalar = 1000L; [EOL]                 break; [EOL]             case 4: [EOL]                 scalar = 10000L; [EOL]                 break; [EOL]             case 5: [EOL]                 scalar = 100000L; [EOL]                 break; [EOL]             case 6: [EOL]                 scalar = 1000000L; [EOL]                 break; [EOL]             case 7: [EOL]                 scalar = 10000000L; [EOL]                 break; [EOL]             case 8: [EOL]                 scalar = 100000000L; [EOL]                 break; [EOL]             case 9: [EOL]                 scalar = 1000000000L; [EOL]                 break; [EOL]             case 10: [EOL]                 scalar = 10000000000L; [EOL]                 break; [EOL]             case 11: [EOL]                 scalar = 100000000000L; [EOL]                 break; [EOL]             case 12: [EOL]                 scalar = 1000000000000L; [EOL]                 break; [EOL]             case 13: [EOL]                 scalar = 10000000000000L; [EOL]                 break; [EOL]             case 14: [EOL]                 scalar = 100000000000000L; [EOL]                 break; [EOL]             case 15: [EOL]                 scalar = 1000000000000000L; [EOL]                 break; [EOL]             case 16: [EOL]                 scalar = 10000000000000000L; [EOL]                 break; [EOL]             case 17: [EOL]                 scalar = 100000000000000000L; [EOL]                 break; [EOL]             case 18: [EOL]                 scalar = 1000000000000000000L; [EOL]                 break; [EOL]         } [EOL]         if (((rangeMillis * scalar) / scalar) == rangeMillis) { [EOL]             break; [EOL]         } [EOL]         maxDigits--; [EOL]     } [EOL]     return new long[] { fraction * scalar / rangeMillis, maxDigits }; [EOL] } <line_num>: 2027,2061
public int estimateParsedLength() { [EOL]     return iMaxDigits; [EOL] } <line_num>: 2063,2065
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     DateTimeField field = iFieldType.getField(bucket.getChronology()); [EOL]     int limit = Math.min(iMaxDigits, text.length() - position); [EOL]     long value = 0; [EOL]     long n = field.getDurationField().getUnitMillis() * 10; [EOL]     int length = 0; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (c < '0' || c > '9') { [EOL]             break; [EOL]         } [EOL]         length++; [EOL]         long nn = n / 10; [EOL]         value += (c - '0') * nn; [EOL]         n = nn; [EOL]     } [EOL]     value /= 10; [EOL]     if (length == 0) { [EOL]         return ~position; [EOL]     } [EOL]     if (value > Integer.MAX_VALUE) { [EOL]         return ~position; [EOL]     } [EOL]     DateTimeField parseField = new PreciseDateTimeField(DateTimeFieldType.millisOfSecond(), MillisDurationField.INSTANCE, field.getDurationField()); [EOL]     bucket.saveField(parseField, (int) value); [EOL]     return position + length; [EOL] } <line_num>: 2067,2104
public int estimatePrintedLength() { [EOL]     int est = 1 + iMinFields << 1; [EOL]     if (iShowSeparators) { [EOL]         est += iMinFields - 1; [EOL]     } [EOL]     if (iZeroOffsetPrintText != null && iZeroOffsetPrintText.length() > est) { [EOL]         est = iZeroOffsetPrintText.length(); [EOL]     } [EOL]     return est; [EOL] } <line_num>: 2136,2145
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     if (displayZone == null) { [EOL]         return; [EOL]     } [EOL]     if (displayOffset == 0 && iZeroOffsetPrintText != null) { [EOL]         buf.append(iZeroOffsetPrintText); [EOL]         return; [EOL]     } [EOL]     if (displayOffset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         displayOffset = -displayOffset; [EOL]     } [EOL]     int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     if (iMaxFields == 1) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     if (displayOffset == 0 && iMinFields <= 1) { [EOL]         return; [EOL]     } [EOL]     int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     if (iMaxFields == 2) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (displayOffset == 0 && iMinFields <= 2) { [EOL]         return; [EOL]     } [EOL]     int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     if (iMaxFields == 3) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (displayOffset == 0 && iMinFields <= 3) { [EOL]         return; [EOL]     } [EOL]     if (iShowSeparators) { [EOL]         buf.append('.'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, displayOffset, 3); [EOL] } <line_num>: 2147,2204
public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException { [EOL]     if (displayZone == null) { [EOL]         return; [EOL]     } [EOL]     if (displayOffset == 0 && iZeroOffsetPrintText != null) { [EOL]         out.write(iZeroOffsetPrintText); [EOL]         return; [EOL]     } [EOL]     if (displayOffset >= 0) { [EOL]         out.write('+'); [EOL]     } else { [EOL]         out.write('-'); [EOL]         displayOffset = -displayOffset; [EOL]     } [EOL]     int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.writePaddedInteger(out, hours, 2); [EOL]     if (iMaxFields == 1) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     if (displayOffset == 0 && iMinFields == 1) { [EOL]         return; [EOL]     } [EOL]     int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (iShowSeparators) { [EOL]         out.write(':'); [EOL]     } [EOL]     FormatUtils.writePaddedInteger(out, minutes, 2); [EOL]     if (iMaxFields == 2) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (displayOffset == 0 && iMinFields == 2) { [EOL]         return; [EOL]     } [EOL]     int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (iShowSeparators) { [EOL]         out.write(':'); [EOL]     } [EOL]     FormatUtils.writePaddedInteger(out, seconds, 2); [EOL]     if (iMaxFields == 3) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (displayOffset == 0 && iMinFields == 3) { [EOL]         return; [EOL]     } [EOL]     if (iShowSeparators) { [EOL]         out.write('.'); [EOL]     } [EOL]     FormatUtils.writePaddedInteger(out, displayOffset, 3); [EOL] } <line_num>: 2206,2263
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) { [EOL] } <line_num>: 2265,2267
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException { [EOL] } <line_num>: 2269,2271
public int estimateParsedLength() { [EOL]     return estimatePrintedLength(); [EOL] } <line_num>: 2273,2275
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     zeroOffset: if (iZeroOffsetParseText != null) { [EOL]         if (iZeroOffsetParseText.length() == 0) { [EOL]             if (limit > 0) { [EOL]                 char c = text.charAt(position); [EOL]                 if (c == '-' || c == '+') { [EOL]                     break zeroOffset; [EOL]                 } [EOL]             } [EOL]             bucket.setOffset(Integer.valueOf(0)); [EOL]             return position; [EOL]         } [EOL]         if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) { [EOL]             bucket.setOffset(Integer.valueOf(0)); [EOL]             return position + iZeroOffsetParseText.length(); [EOL]         } [EOL]     } [EOL]     if (limit <= 1) { [EOL]         return ~position; [EOL]     } [EOL]     boolean negative; [EOL]     char c = text.charAt(position); [EOL]     if (c == '-') { [EOL]         negative = true; [EOL]     } else if (c == '+') { [EOL]         negative = false; [EOL]     } else { [EOL]         return ~position; [EOL]     } [EOL]     limit--; [EOL]     position++; [EOL]     if (digitCount(text, position, 2) < 2) { [EOL]         return ~position; [EOL]     } [EOL]     int offset; [EOL]     int hours = FormatUtils.parseTwoDigits(text, position); [EOL]     if (hours > 23) { [EOL]         return ~position; [EOL]     } [EOL]     offset = hours * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     limit -= 2; [EOL]     position += 2; [EOL]     parse: { [EOL]         if (limit <= 0) { [EOL]             break parse; [EOL]         } [EOL]         boolean expectSeparators; [EOL]         c = text.charAt(position); [EOL]         if (c == ':') { [EOL]             expectSeparators = true; [EOL]             limit--; [EOL]             position++; [EOL]         } else if (c >= '0' && c <= '9') { [EOL]             expectSeparators = false; [EOL]         } else { [EOL]             break parse; [EOL]         } [EOL]         int count = digitCount(text, position, 2); [EOL]         if (count == 0 && !expectSeparators) { [EOL]             break parse; [EOL]         } else if (count < 2) { [EOL]             return ~position; [EOL]         } [EOL]         int minutes = FormatUtils.parseTwoDigits(text, position); [EOL]         if (minutes > 59) { [EOL]             return ~position; [EOL]         } [EOL]         offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]         limit -= 2; [EOL]         position += 2; [EOL]         if (limit <= 0) { [EOL]             break parse; [EOL]         } [EOL]         if (expectSeparators) { [EOL]             if (text.charAt(position) != ':') { [EOL]                 break parse; [EOL]             } [EOL]             limit--; [EOL]             position++; [EOL]         } [EOL]         count = digitCount(text, position, 2); [EOL]         if (count == 0 && !expectSeparators) { [EOL]             break parse; [EOL]         } else if (count < 2) { [EOL]             return ~position; [EOL]         } [EOL]         int seconds = FormatUtils.parseTwoDigits(text, position); [EOL]         if (seconds > 59) { [EOL]             return ~position; [EOL]         } [EOL]         offset += seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]         limit -= 2; [EOL]         position += 2; [EOL]         if (limit <= 0) { [EOL]             break parse; [EOL]         } [EOL]         if (expectSeparators) { [EOL]             if (text.charAt(position) != '.' && text.charAt(position) != ',') { [EOL]                 break parse; [EOL]             } [EOL]             limit--; [EOL]             position++; [EOL]         } [EOL]         count = digitCount(text, position, 3); [EOL]         if (count == 0 && !expectSeparators) { [EOL]             break parse; [EOL]         } else if (count < 1) { [EOL]             return ~position; [EOL]         } [EOL]         offset += (text.charAt(position++) - '0') * 100; [EOL]         if (count > 1) { [EOL]             offset += (text.charAt(position++) - '0') * 10; [EOL]             if (count > 2) { [EOL]                 offset += text.charAt(position++) - '0'; [EOL]             } [EOL]         } [EOL]     } [EOL]     bucket.setOffset(Integer.valueOf(negative ? -offset : offset)); [EOL]     return position; [EOL] } <line_num>: 2277,2446
private int digitCount(String text, int position, int amount) { [EOL]     int limit = Math.min(text.length() - position, amount); [EOL]     amount = 0; [EOL]     for (; limit > 0; limit--) { [EOL]         char c = text.charAt(position + amount); [EOL]         if (c < '0' || c > '9') { [EOL]             break; [EOL]         } [EOL]         amount++; [EOL]     } [EOL]     return amount; [EOL] } <line_num>: 2452,2463
public int estimatePrintedLength() { [EOL]     return (iType == SHORT_NAME ? 4 : 20); [EOL] } <line_num>: 2482,2484
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     buf.append(print(instant - displayOffset, displayZone, locale)); [EOL] } <line_num>: 2486,2490
public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException { [EOL]     out.write(print(instant - displayOffset, displayZone, locale)); [EOL] } <line_num>: 2492,2496
private String print(long instant, DateTimeZone displayZone, Locale locale) { [EOL]     if (displayZone == null) { [EOL]         return ""; [EOL]     } [EOL]     switch(iType) { [EOL]         case LONG_NAME: [EOL]             return displayZone.getName(instant, locale); [EOL]         case SHORT_NAME: [EOL]             return displayZone.getShortName(instant, locale); [EOL]     } [EOL]     return ""; [EOL] } <line_num>: 2498,2509
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) { [EOL] } <line_num>: 2511,2513
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException { [EOL] } <line_num>: 2515,2517
public int estimateParsedLength() { [EOL]     return (iType == SHORT_NAME ? 4 : 20); [EOL] } <line_num>: 2519,2521
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     Map<String, DateTimeZone> parseLookup = iParseLookup; [EOL]     parseLookup = (parseLookup != null ? parseLookup : DateTimeUtils.getDefaultTimeZoneNames()); [EOL]     String str = text.substring(position); [EOL]     String matched = null; [EOL]     for (String name : parseLookup.keySet()) { [EOL]         if (str.startsWith(name)) { [EOL]             if (matched == null || name.length() > matched.length()) { [EOL]                 matched = name; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (matched != null) { [EOL]         bucket.setZone(parseLookup.get(matched)); [EOL]         return position + matched.length(); [EOL]     } [EOL]     return ~position; [EOL] } <line_num>: 2523,2540
public int estimatePrintedLength() { [EOL]     return MAX_LENGTH; [EOL] } <line_num>: 2558,2560
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     buf.append(displayZone != null ? displayZone.getID() : ""); [EOL] } <line_num>: 2562,2566
public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException { [EOL]     out.write(displayZone != null ? displayZone.getID() : ""); [EOL] } <line_num>: 2568,2572
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) { [EOL] } <line_num>: 2574,2576
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException { [EOL] } <line_num>: 2578,2580
public int estimateParsedLength() { [EOL]     return MAX_LENGTH; [EOL] } <line_num>: 2582,2584
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     String str = text.substring(position); [EOL]     String best = null; [EOL]     for (String id : ALL_IDS) { [EOL]         if (str.startsWith(id)) { [EOL]             if (best == null || id.length() > best.length()) { [EOL]                 best = id; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (best != null) { [EOL]         bucket.setZone(DateTimeZone.forID(best)); [EOL]         return position + best.length(); [EOL]     } [EOL]     return ~position; [EOL] } <line_num>: 2586,2601
public int estimatePrintedLength() { [EOL]     return iPrintedLengthEstimate; [EOL] } <line_num>: 2653,2655
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     DateTimePrinter[] elements = iPrinters; [EOL]     if (elements == null) { [EOL]         throw new UnsupportedOperationException(); [EOL]     } [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     int len = elements.length; [EOL]     for (int i = 0; i < len; i++) { [EOL]         elements[i].printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL]     } [EOL] } <line_num>: 2657,2674
public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException { [EOL]     DateTimePrinter[] elements = iPrinters; [EOL]     if (elements == null) { [EOL]         throw new UnsupportedOperationException(); [EOL]     } [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     int len = elements.length; [EOL]     for (int i = 0; i < len; i++) { [EOL]         elements[i].printTo(out, instant, chrono, displayOffset, displayZone, locale); [EOL]     } [EOL] } <line_num>: 2676,2693
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) { [EOL]     DateTimePrinter[] elements = iPrinters; [EOL]     if (elements == null) { [EOL]         throw new UnsupportedOperationException(); [EOL]     } [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     int len = elements.length; [EOL]     for (int i = 0; i < len; i++) { [EOL]         elements[i].printTo(buf, partial, locale); [EOL]     } [EOL] } <line_num>: 2695,2710
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException { [EOL]     DateTimePrinter[] elements = iPrinters; [EOL]     if (elements == null) { [EOL]         throw new UnsupportedOperationException(); [EOL]     } [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     int len = elements.length; [EOL]     for (int i = 0; i < len; i++) { [EOL]         elements[i].printTo(out, partial, locale); [EOL]     } [EOL] } <line_num>: 2712,2727
public int estimateParsedLength() { [EOL]     return iParsedLengthEstimate; [EOL] } <line_num>: 2729,2731
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     DateTimeParser[] elements = iParsers; [EOL]     if (elements == null) { [EOL]         throw new UnsupportedOperationException(); [EOL]     } [EOL]     int len = elements.length; [EOL]     for (int i = 0; i < len && position >= 0; i++) { [EOL]         position = elements[i].parseInto(bucket, text, position); [EOL]     } [EOL]     return position; [EOL] } <line_num>: 2733,2744
boolean isPrinter() { [EOL]     return iPrinters != null; [EOL] } <line_num>: 2746,2748
boolean isParser() { [EOL]     return iParsers != null; [EOL] } <line_num>: 2750,2752
private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) { [EOL]     int size = elementPairs.size(); [EOL]     for (int i = 0; i < size; i += 2) { [EOL]         Object element = elementPairs.get(i); [EOL]         if (element instanceof Composite) { [EOL]             addArrayToList(printerList, ((Composite) element).iPrinters); [EOL]         } else { [EOL]             printerList.add(element); [EOL]         } [EOL]         element = elementPairs.get(i + 1); [EOL]         if (element instanceof Composite) { [EOL]             addArrayToList(parserList, ((Composite) element).iParsers); [EOL]         } else { [EOL]             parserList.add(element); [EOL]         } [EOL]     } [EOL] } <line_num>: 2758,2775
private void addArrayToList(List<Object> list, Object[] array) { [EOL]     if (array != null) { [EOL]         for (int i = 0; i < array.length; i++) { [EOL]             list.add(array[i]); [EOL]         } [EOL]     } [EOL] } <line_num>: 2777,2783
public int estimateParsedLength() { [EOL]     return iParsedLengthEstimate; [EOL] } <line_num>: 2809,2811
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     DateTimeParser[] parsers = iParsers; [EOL]     int length = parsers.length; [EOL]     final Object originalState = bucket.saveState(); [EOL]     boolean isOptional = false; [EOL]     int bestValidPos = position; [EOL]     Object bestValidState = null; [EOL]     int bestInvalidPos = position; [EOL]     for (int i = 0; i < length; i++) { [EOL]         DateTimeParser parser = parsers[i]; [EOL]         if (parser == null) { [EOL]             if (bestValidPos <= position) { [EOL]                 return position; [EOL]             } [EOL]             isOptional = true; [EOL]             break; [EOL]         } [EOL]         int parsePos = parser.parseInto(bucket, text, position); [EOL]         if (parsePos >= position) { [EOL]             if (parsePos > bestValidPos) { [EOL]                 if (parsePos >= text.length() || (i + 1) >= length || parsers[i + 1] == null) { [EOL]                     return parsePos; [EOL]                 } [EOL]                 bestValidPos = parsePos; [EOL]                 bestValidState = bucket.saveState(); [EOL]             } [EOL]         } else { [EOL]             if (parsePos < 0) { [EOL]                 parsePos = ~parsePos; [EOL]                 if (parsePos > bestInvalidPos) { [EOL]                     bestInvalidPos = parsePos; [EOL]                 } [EOL]             } [EOL]         } [EOL]         bucket.restoreState(originalState); [EOL]     } [EOL]     if (bestValidPos > position || (bestValidPos == position && isOptional)) { [EOL]         if (bestValidState != null) { [EOL]             bucket.restoreState(bestValidState); [EOL]         } [EOL]         return bestValidPos; [EOL]     } [EOL]     return ~bestInvalidPos; [EOL] } <line_num>: 2813,2868
