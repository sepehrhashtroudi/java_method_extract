protected DateTimeFormat() { [EOL]     super(); [EOL] } <line_num>: 403,405
StyleFormatter(int dateStyle, int timeStyle, int type) { [EOL]     super(); [EOL]     iDateStyle = dateStyle; [EOL]     iTimeStyle = timeStyle; [EOL]     iType = type; [EOL] } <line_num>: 803,808
@Override [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) { [EOL]     return size() > PATTERN_CACHE_SIZE; [EOL] } <line_num>: 159,162
public static DateTimeFormatter forPattern(String pattern) { [EOL]     return createFormatterForPattern(pattern); [EOL] } <line_num>: 186,188
public static DateTimeFormatter forStyle(String style) { [EOL]     return createFormatterForStyle(style); [EOL] } <line_num>: 210,212
public static String patternForStyle(String style, Locale locale) { [EOL]     DateTimeFormatter formatter = createFormatterForStyle(style); [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     return ((StyleFormatter) formatter.getPrinter()).getPattern(locale); [EOL] } <line_num>: 228,235
public static DateTimeFormatter shortDate() { [EOL]     return createFormatterForStyleIndex(SHORT, NONE); [EOL] } <line_num>: 246,248
public static DateTimeFormatter shortTime() { [EOL]     return createFormatterForStyleIndex(NONE, SHORT); [EOL] } <line_num>: 258,260
public static DateTimeFormatter shortDateTime() { [EOL]     return createFormatterForStyleIndex(SHORT, SHORT); [EOL] } <line_num>: 270,272
public static DateTimeFormatter mediumDate() { [EOL]     return createFormatterForStyleIndex(MEDIUM, NONE); [EOL] } <line_num>: 283,285
public static DateTimeFormatter mediumTime() { [EOL]     return createFormatterForStyleIndex(NONE, MEDIUM); [EOL] } <line_num>: 295,297
public static DateTimeFormatter mediumDateTime() { [EOL]     return createFormatterForStyleIndex(MEDIUM, MEDIUM); [EOL] } <line_num>: 307,309
public static DateTimeFormatter longDate() { [EOL]     return createFormatterForStyleIndex(LONG, NONE); [EOL] } <line_num>: 320,322
public static DateTimeFormatter longTime() { [EOL]     return createFormatterForStyleIndex(NONE, LONG); [EOL] } <line_num>: 332,334
public static DateTimeFormatter longDateTime() { [EOL]     return createFormatterForStyleIndex(LONG, LONG); [EOL] } <line_num>: 344,346
public static DateTimeFormatter fullDate() { [EOL]     return createFormatterForStyleIndex(FULL, NONE); [EOL] } <line_num>: 357,359
public static DateTimeFormatter fullTime() { [EOL]     return createFormatterForStyleIndex(NONE, FULL); [EOL] } <line_num>: 369,371
public static DateTimeFormatter fullDateTime() { [EOL]     return createFormatterForStyleIndex(FULL, FULL); [EOL] } <line_num>: 381,383
static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) { [EOL]     parsePatternTo(builder, pattern); [EOL] } <line_num>: 393,395
private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) { [EOL]     int length = pattern.length(); [EOL]     int[] indexRef = new int[1]; [EOL]     for (int i = 0; i < length; i++) { [EOL]         indexRef[0] = i; [EOL]         String token = parseToken(pattern, indexRef); [EOL]         i = indexRef[0]; [EOL]         int tokenLen = token.length(); [EOL]         if (tokenLen == 0) { [EOL]             break; [EOL]         } [EOL]         char c = token.charAt(0); [EOL]         switch(c) { [EOL]             case 'G': [EOL]                 builder.appendEraText(); [EOL]                 break; [EOL]             case 'C': [EOL]                 builder.appendCenturyOfEra(tokenLen, tokenLen); [EOL]                 break; [EOL]             case 'x': [EOL]             case 'y': [EOL]             case 'Y': [EOL]                 if (tokenLen == 2) { [EOL]                     boolean lenientParse = true; [EOL]                     if (i + 1 < length) { [EOL]                         indexRef[0]++; [EOL]                         if (isNumericToken(parseToken(pattern, indexRef))) { [EOL]                             lenientParse = false; [EOL]                         } [EOL]                         indexRef[0]--; [EOL]                     } [EOL]                     switch(c) { [EOL]                         case 'x': [EOL]                             builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30, lenientParse); [EOL]                             break; [EOL]                         case 'y': [EOL]                         case 'Y': [EOL]                         default: [EOL]                             builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse); [EOL]                             break; [EOL]                     } [EOL]                 } else { [EOL]                     int maxDigits = 9; [EOL]                     if (i + 1 < length) { [EOL]                         indexRef[0]++; [EOL]                         if (isNumericToken(parseToken(pattern, indexRef))) { [EOL]                             maxDigits = tokenLen; [EOL]                         } [EOL]                         indexRef[0]--; [EOL]                     } [EOL]                     switch(c) { [EOL]                         case 'x': [EOL]                             builder.appendWeekyear(tokenLen, maxDigits); [EOL]                             break; [EOL]                         case 'y': [EOL]                             builder.appendYear(tokenLen, maxDigits); [EOL]                             break; [EOL]                         case 'Y': [EOL]                             builder.appendYearOfEra(tokenLen, maxDigits); [EOL]                             break; [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case 'M': [EOL]                 if (tokenLen >= 3) { [EOL]                     if (tokenLen >= 4) { [EOL]                         builder.appendMonthOfYearText(); [EOL]                     } else { [EOL]                         builder.appendMonthOfYearShortText(); [EOL]                     } [EOL]                 } else { [EOL]                     builder.appendMonthOfYear(tokenLen); [EOL]                 } [EOL]                 break; [EOL]             case 'd': [EOL]                 builder.appendDayOfMonth(tokenLen); [EOL]                 break; [EOL]             case 'a': [EOL]                 builder.appendHalfdayOfDayText(); [EOL]                 break; [EOL]             case 'h': [EOL]                 builder.appendClockhourOfHalfday(tokenLen); [EOL]                 break; [EOL]             case 'H': [EOL]                 builder.appendHourOfDay(tokenLen); [EOL]                 break; [EOL]             case 'k': [EOL]                 builder.appendClockhourOfDay(tokenLen); [EOL]                 break; [EOL]             case 'K': [EOL]                 builder.appendHourOfHalfday(tokenLen); [EOL]                 break; [EOL]             case 'm': [EOL]                 builder.appendMinuteOfHour(tokenLen); [EOL]                 break; [EOL]             case 's': [EOL]                 builder.appendSecondOfMinute(tokenLen); [EOL]                 break; [EOL]             case 'S': [EOL]                 builder.appendFractionOfSecond(tokenLen, tokenLen); [EOL]                 break; [EOL]             case 'e': [EOL]                 builder.appendDayOfWeek(tokenLen); [EOL]                 break; [EOL]             case 'E': [EOL]                 if (tokenLen >= 4) { [EOL]                     builder.appendDayOfWeekText(); [EOL]                 } else { [EOL]                     builder.appendDayOfWeekShortText(); [EOL]                 } [EOL]                 break; [EOL]             case 'D': [EOL]                 builder.appendDayOfYear(tokenLen); [EOL]                 break; [EOL]             case 'w': [EOL]                 builder.appendWeekOfWeekyear(tokenLen); [EOL]                 break; [EOL]             case 'z': [EOL]                 if (tokenLen >= 4) { [EOL]                     builder.appendTimeZoneName(); [EOL]                 } else { [EOL]                     builder.appendTimeZoneShortName(null); [EOL]                 } [EOL]                 break; [EOL]             case 'Z': [EOL]                 if (tokenLen == 1) { [EOL]                     builder.appendTimeZoneOffset(null, "Z", false, 2, 2); [EOL]                 } else if (tokenLen == 2) { [EOL]                     builder.appendTimeZoneOffset(null, "Z", true, 2, 2); [EOL]                 } else { [EOL]                     builder.appendTimeZoneId(); [EOL]                 } [EOL]                 break; [EOL]             case '\'': [EOL]                 String sub = token.substring(1); [EOL]                 if (sub.length() == 1) { [EOL]                     builder.appendLiteral(sub.charAt(0)); [EOL]                 } else { [EOL]                     builder.appendLiteral(new String(sub)); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 throw new IllegalArgumentException("Illegal pattern component: " + token); [EOL]         } [EOL]     } [EOL] } <line_num>: 416,580
private static String parseToken(String pattern, int[] indexRef) { [EOL]     StringBuilder buf = new StringBuilder(); [EOL]     int i = indexRef[0]; [EOL]     int length = pattern.length(); [EOL]     char c = pattern.charAt(i); [EOL]     if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') { [EOL]         buf.append(c); [EOL]         while (i + 1 < length) { [EOL]             char peek = pattern.charAt(i + 1); [EOL]             if (peek == c) { [EOL]                 buf.append(c); [EOL]                 i++; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         buf.append('\''); [EOL]         boolean inLiteral = false; [EOL]         for (; i < length; i++) { [EOL]             c = pattern.charAt(i); [EOL]             if (c == '\'') { [EOL]                 if (i + 1 < length && pattern.charAt(i + 1) == '\'') { [EOL]                     i++; [EOL]                     buf.append(c); [EOL]                 } else { [EOL]                     inLiteral = !inLiteral; [EOL]                 } [EOL]             } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) { [EOL]                 i--; [EOL]                 break; [EOL]             } else { [EOL]                 buf.append(c); [EOL]             } [EOL]         } [EOL]     } [EOL]     indexRef[0] = i; [EOL]     return buf.toString(); [EOL] } <line_num>: 590,640
private static boolean isNumericToken(String token) { [EOL]     int tokenLen = token.length(); [EOL]     if (tokenLen > 0) { [EOL]         char c = token.charAt(0); [EOL]         switch(c) { [EOL]             case 'c': [EOL]             case 'C': [EOL]             case 'x': [EOL]             case 'y': [EOL]             case 'Y': [EOL]             case 'd': [EOL]             case 'h': [EOL]             case 'H': [EOL]             case 'm': [EOL]             case 's': [EOL]             case 'S': [EOL]             case 'e': [EOL]             case 'D': [EOL]             case 'F': [EOL]             case 'w': [EOL]             case 'W': [EOL]             case 'k': [EOL]             case 'K': [EOL]                 return true; [EOL]             case 'M': [EOL]                 if (tokenLen <= 2) { [EOL]                     return true; [EOL]                 } [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 648,680
private static DateTimeFormatter createFormatterForPattern(String pattern) { [EOL]     if (pattern == null || pattern.length() == 0) { [EOL]         throw new IllegalArgumentException("Invalid pattern specification"); [EOL]     } [EOL]     DateTimeFormatter formatter = null; [EOL]     synchronized (PATTERN_CACHE) { [EOL]         formatter = PATTERN_CACHE.get(pattern); [EOL]         if (formatter == null) { [EOL]             DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL]             parsePatternTo(builder, pattern); [EOL]             formatter = builder.toFormatter(); [EOL]             PATTERN_CACHE.put(pattern, formatter); [EOL]         } [EOL]     } [EOL]     return formatter; [EOL] } <line_num>: 690,706
private static DateTimeFormatter createFormatterForStyle(String style) { [EOL]     if (style == null || style.length() != 2) { [EOL]         throw new IllegalArgumentException("Invalid style specification: " + style); [EOL]     } [EOL]     int dateStyle = selectStyle(style.charAt(0)); [EOL]     int timeStyle = selectStyle(style.charAt(1)); [EOL]     if (dateStyle == NONE && timeStyle == NONE) { [EOL]         throw new IllegalArgumentException("Style '--' is invalid"); [EOL]     } [EOL]     return createFormatterForStyleIndex(dateStyle, timeStyle); [EOL] } <line_num>: 717,727
private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle) { [EOL]     int index = ((dateStyle << 2) + dateStyle) + timeStyle; [EOL]     if (index >= STYLE_CACHE.length) { [EOL]         return createDateTimeFormatter(dateStyle, timeStyle); [EOL]     } [EOL]     DateTimeFormatter f = null; [EOL]     synchronized (STYLE_CACHE) { [EOL]         f = STYLE_CACHE[index]; [EOL]         if (f == null) { [EOL]             f = createDateTimeFormatter(dateStyle, timeStyle); [EOL]             STYLE_CACHE[index] = f; [EOL]         } [EOL]     } [EOL]     return f; [EOL] } <line_num>: 736,751
private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle) { [EOL]     int type = DATETIME; [EOL]     if (dateStyle == NONE) { [EOL]         type = TIME; [EOL]     } else if (timeStyle == NONE) { [EOL]         type = DATE; [EOL]     } [EOL]     StyleFormatter llf = new StyleFormatter(dateStyle, timeStyle, type); [EOL]     return new DateTimeFormatter(llf, llf); [EOL] } <line_num>: 759,768
private static int selectStyle(char ch) { [EOL]     switch(ch) { [EOL]         case 'S': [EOL]             return SHORT; [EOL]         case 'M': [EOL]             return MEDIUM; [EOL]         case 'L': [EOL]             return LONG; [EOL]         case 'F': [EOL]             return FULL; [EOL]         case '-': [EOL]             return NONE; [EOL]         default: [EOL]             throw new IllegalArgumentException("Invalid style character: " + ch); [EOL]     } [EOL] } <line_num>: 776,791
public int estimatePrintedLength() { [EOL]     return 40; [EOL] } <line_num>: 810,812
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     DateTimePrinter p = getFormatter(locale).getPrinter(); [EOL]     p.printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] } <line_num>: 814,819
public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException { [EOL]     DateTimePrinter p = getFormatter(locale).getPrinter(); [EOL]     p.printTo(out, instant, chrono, displayOffset, displayZone, locale); [EOL] } <line_num>: 821,826
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) { [EOL]     DateTimePrinter p = getFormatter(locale).getPrinter(); [EOL]     p.printTo(buf, partial, locale); [EOL] } <line_num>: 828,831
public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException { [EOL]     DateTimePrinter p = getFormatter(locale).getPrinter(); [EOL]     p.printTo(out, partial, locale); [EOL] } <line_num>: 833,836
public int estimateParsedLength() { [EOL]     return 40; [EOL] } <line_num>: 838,840
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     DateTimeParser p = getFormatter(bucket.getLocale()).getParser(); [EOL]     return p.parseInto(bucket, text, position); [EOL] } <line_num>: 842,845
private DateTimeFormatter getFormatter(Locale locale) { [EOL]     locale = (locale == null ? Locale.getDefault() : locale); [EOL]     String key = Integer.toString(iType + (iDateStyle << 4) + (iTimeStyle << 8)) + locale.toString(); [EOL]     DateTimeFormatter f = null; [EOL]     synchronized (cCache) { [EOL]         f = cCache.get(key); [EOL]         if (f == null) { [EOL]             String pattern = getPattern(locale); [EOL]             f = DateTimeFormat.forPattern(pattern); [EOL]             cCache.put(key, f); [EOL]         } [EOL]     } [EOL]     return f; [EOL] } <line_num>: 847,860
String getPattern(Locale locale) { [EOL]     DateFormat f = null; [EOL]     switch(iType) { [EOL]         case DATE: [EOL]             f = DateFormat.getDateInstance(iDateStyle, locale); [EOL]             break; [EOL]         case TIME: [EOL]             f = DateFormat.getTimeInstance(iTimeStyle, locale); [EOL]             break; [EOL]         case DATETIME: [EOL]             f = DateFormat.getDateTimeInstance(iDateStyle, iTimeStyle, locale); [EOL]             break; [EOL]     } [EOL]     if (f instanceof SimpleDateFormat == false) { [EOL]         throw new IllegalArgumentException("No datetime pattern for locale: " + locale); [EOL]     } [EOL]     return ((SimpleDateFormat) f).toPattern(); [EOL] } <line_num>: 862,879
