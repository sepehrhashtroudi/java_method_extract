public DateTimeZoneBuilder() { [EOL]     iRuleSets = new ArrayList<RuleSet>(10); [EOL] } <line_num>: 225,227
OfYear(char mode, int monthOfYear, int dayOfMonth, int dayOfWeek, boolean advanceDayOfWeek, int millisOfDay) { [EOL]     if (mode != 'u' && mode != 'w' && mode != 's') { [EOL]         throw new IllegalArgumentException("Unknown mode: " + mode); [EOL]     } [EOL]     iMode = mode; [EOL]     iMonthOfYear = monthOfYear; [EOL]     iDayOfMonth = dayOfMonth; [EOL]     iDayOfWeek = dayOfWeek; [EOL]     iAdvance = advanceDayOfWeek; [EOL]     iMillisOfDay = millisOfDay; [EOL] } <line_num>: 499,515
Recurrence(OfYear ofYear, String nameKey, int saveMillis) { [EOL]     iOfYear = ofYear; [EOL]     iNameKey = nameKey; [EOL]     iSaveMillis = saveMillis; [EOL] } <line_num>: 747,751
Rule(Recurrence recurrence, int fromYear, int toYear) { [EOL]     iRecurrence = recurrence; [EOL]     iFromYear = fromYear; [EOL]     iToYear = toYear; [EOL] } <line_num>: 816,820
Transition(long millis, Transition tr) { [EOL]     iMillis = millis; [EOL]     iNameKey = tr.iNameKey; [EOL]     iWallOffset = tr.iWallOffset; [EOL]     iStandardOffset = tr.iStandardOffset; [EOL] } <line_num>: 885,890
Transition(long millis, Rule rule, int standardOffset) { [EOL]     iMillis = millis; [EOL]     iNameKey = rule.getNameKey(); [EOL]     iWallOffset = standardOffset + rule.getSaveMillis(); [EOL]     iStandardOffset = standardOffset; [EOL] } <line_num>: 892,897
Transition(long millis, String nameKey, int wallOffset, int standardOffset) { [EOL]     iMillis = millis; [EOL]     iNameKey = nameKey; [EOL]     iWallOffset = wallOffset; [EOL]     iStandardOffset = standardOffset; [EOL] } <line_num>: 899,905
RuleSet() { [EOL]     iRules = new ArrayList<Rule>(10); [EOL]     iUpperYear = Integer.MAX_VALUE; [EOL] } <line_num>: 965,968
RuleSet(RuleSet rs) { [EOL]     iStandardOffset = rs.iStandardOffset; [EOL]     iRules = new ArrayList<Rule>(rs.iRules); [EOL]     iInitialNameKey = rs.iInitialNameKey; [EOL]     iInitialSaveMillis = rs.iInitialSaveMillis; [EOL]     iUpperYear = rs.iUpperYear; [EOL]     iUpperOfYear = rs.iUpperOfYear; [EOL] } <line_num>: 973,980
DSTZone(String id, int standardOffset, Recurrence startRecurrence, Recurrence endRecurrence) { [EOL]     super(id); [EOL]     iStandardOffset = standardOffset; [EOL]     iStartRecurrence = startRecurrence; [EOL]     iEndRecurrence = endRecurrence; [EOL] } <line_num>: 1177,1183
private PrecalculatedZone(String id, long[] transitions, int[] wallOffsets, int[] standardOffsets, String[] nameKeys, DSTZone tailZone) { [EOL]     super(id); [EOL]     iTransitions = transitions; [EOL]     iWallOffsets = wallOffsets; [EOL]     iStandardOffsets = standardOffsets; [EOL]     iNameKeys = nameKeys; [EOL]     iTailZone = tailZone; [EOL] } <line_num>: 1500,1509
public static DateTimeZone readFrom(InputStream in, String id) throws IOException { [EOL]     if (in instanceof DataInput) { [EOL]         return readFrom((DataInput) in, id); [EOL]     } else { [EOL]         return readFrom((DataInput) new DataInputStream(in), id); [EOL]     } [EOL] } <line_num>: 94,100
public static DateTimeZone readFrom(DataInput in, String id) throws IOException { [EOL]     switch(in.readUnsignedByte()) { [EOL]         case 'F': [EOL]             DateTimeZone fixed = new FixedDateTimeZone(id, in.readUTF(), (int) readMillis(in), (int) readMillis(in)); [EOL]             if (fixed.equals(DateTimeZone.UTC)) { [EOL]                 fixed = DateTimeZone.UTC; [EOL]             } [EOL]             return fixed; [EOL]         case 'C': [EOL]             return CachedDateTimeZone.forZone(PrecalculatedZone.readFrom(in, id)); [EOL]         case 'P': [EOL]             return PrecalculatedZone.readFrom(in, id); [EOL]         default: [EOL]             throw new IOException("Invalid encoding"); [EOL]     } [EOL] } <line_num>: 109,125
static void writeMillis(DataOutput out, long millis) throws IOException { [EOL]     if (millis % (30 * 60000L) == 0) { [EOL]         long units = millis / (30 * 60000L); [EOL]         if (((units << (64 - 6)) >> (64 - 6)) == units) { [EOL]             out.writeByte((int) (units & 0x3f)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (millis % 60000L == 0) { [EOL]         long minutes = millis / 60000L; [EOL]         if (((minutes << (64 - 30)) >> (64 - 30)) == minutes) { [EOL]             out.writeInt(0x40000000 | (int) (minutes & 0x3fffffff)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (millis % 1000L == 0) { [EOL]         long seconds = millis / 1000L; [EOL]         if (((seconds << (64 - 38)) >> (64 - 38)) == seconds) { [EOL]             out.writeByte(0x80 | (int) ((seconds >> 32) & 0x3f)); [EOL]             out.writeInt((int) (seconds & 0xffffffff)); [EOL]             return; [EOL]         } [EOL]     } [EOL]     out.writeByte(millis < 0 ? 0xff : 0xc0); [EOL]     out.writeLong(millis); [EOL] } <line_num>: 139,177
static long readMillis(DataInput in) throws IOException { [EOL]     int v = in.readUnsignedByte(); [EOL]     switch(v >> 6) { [EOL]         case 0: [EOL]         default: [EOL]             v = (v << (32 - 6)) >> (32 - 6); [EOL]             return v * (30 * 60000L); [EOL]         case 1: [EOL]             v = (v << (32 - 6)) >> (32 - 30); [EOL]             v |= (in.readUnsignedByte()) << 16; [EOL]             v |= (in.readUnsignedByte()) << 8; [EOL]             v |= (in.readUnsignedByte()); [EOL]             return v * 60000L; [EOL]         case 2: [EOL]             long w = (((long) v) << (64 - 6)) >> (64 - 38); [EOL]             w |= (in.readUnsignedByte()) << 24; [EOL]             w |= (in.readUnsignedByte()) << 16; [EOL]             w |= (in.readUnsignedByte()) << 8; [EOL]             w |= (in.readUnsignedByte()); [EOL]             return w * 1000L; [EOL]         case 3: [EOL]             return in.readLong(); [EOL]     } [EOL] } <line_num>: 182,211
private static DateTimeZone buildFixedZone(String id, String nameKey, int wallOffset, int standardOffset) { [EOL]     if ("UTC".equals(id) && id.equals(nameKey) && wallOffset == 0 && standardOffset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     return new FixedDateTimeZone(id, nameKey, wallOffset, standardOffset); [EOL] } <line_num>: 213,220
public DateTimeZoneBuilder addCutover(int year, char mode, int monthOfYear, int dayOfMonth, int dayOfWeek, boolean advanceDayOfWeek, int millisOfDay) { [EOL]     if (iRuleSets.size() > 0) { [EOL]         OfYear ofYear = new OfYear(mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay); [EOL]         RuleSet lastRuleSet = iRuleSets.get(iRuleSets.size() - 1); [EOL]         lastRuleSet.setUpperLimit(year, ofYear); [EOL]     } [EOL]     iRuleSets.add(new RuleSet()); [EOL]     return this; [EOL] } <line_num>: 244,260
public DateTimeZoneBuilder setStandardOffset(int standardOffset) { [EOL]     getLastRuleSet().setStandardOffset(standardOffset); [EOL]     return this; [EOL] } <line_num>: 267,270
public DateTimeZoneBuilder setFixedSavings(String nameKey, int saveMillis) { [EOL]     getLastRuleSet().setFixedSavings(nameKey, saveMillis); [EOL]     return this; [EOL] } <line_num>: 275,278
public DateTimeZoneBuilder addRecurringSavings(String nameKey, int saveMillis, int fromYear, int toYear, char mode, int monthOfYear, int dayOfMonth, int dayOfWeek, boolean advanceDayOfWeek, int millisOfDay) { [EOL]     if (fromYear <= toYear) { [EOL]         OfYear ofYear = new OfYear(mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay); [EOL]         Recurrence recurrence = new Recurrence(ofYear, nameKey, saveMillis); [EOL]         Rule rule = new Rule(recurrence, fromYear, toYear); [EOL]         getLastRuleSet().addRule(rule); [EOL]     } [EOL]     return this; [EOL] } <line_num>: 300,317
private RuleSet getLastRuleSet() { [EOL]     if (iRuleSets.size() == 0) { [EOL]         addCutover(Integer.MIN_VALUE, 'w', 1, 1, 0, false, 0); [EOL]     } [EOL]     return iRuleSets.get(iRuleSets.size() - 1); [EOL] } <line_num>: 319,324
public DateTimeZone toDateTimeZone(String id, boolean outputID) { [EOL]     if (id == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     ArrayList<Transition> transitions = new ArrayList<Transition>(); [EOL]     DSTZone tailZone = null; [EOL]     long millis = Long.MIN_VALUE; [EOL]     int saveMillis = 0; [EOL]     int ruleSetCount = iRuleSets.size(); [EOL]     for (int i = 0; i < ruleSetCount; i++) { [EOL]         RuleSet rs = iRuleSets.get(i); [EOL]         Transition next = rs.firstTransition(millis); [EOL]         if (next == null) { [EOL]             continue; [EOL]         } [EOL]         addTransition(transitions, next); [EOL]         millis = next.getMillis(); [EOL]         saveMillis = next.getSaveMillis(); [EOL]         rs = new RuleSet(rs); [EOL]         while ((next = rs.nextTransition(millis, saveMillis)) != null) { [EOL]             if (addTransition(transitions, next)) { [EOL]                 if (tailZone != null) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             millis = next.getMillis(); [EOL]             saveMillis = next.getSaveMillis(); [EOL]             if (tailZone == null && i == ruleSetCount - 1) { [EOL]                 tailZone = rs.buildTailZone(id); [EOL]             } [EOL]         } [EOL]         millis = rs.getUpperLimit(saveMillis); [EOL]     } [EOL]     if (transitions.size() == 0) { [EOL]         if (tailZone != null) { [EOL]             return tailZone; [EOL]         } [EOL]         return buildFixedZone(id, "UTC", 0, 0); [EOL]     } [EOL]     if (transitions.size() == 1 && tailZone == null) { [EOL]         Transition tr = transitions.get(0); [EOL]         return buildFixedZone(id, tr.getNameKey(), tr.getWallOffset(), tr.getStandardOffset()); [EOL]     } [EOL]     PrecalculatedZone zone = PrecalculatedZone.create(id, outputID, transitions, tailZone); [EOL]     if (zone.isCachable()) { [EOL]         return CachedDateTimeZone.forZone(zone); [EOL]     } [EOL]     return zone; [EOL] } <line_num>: 332,401
private boolean addTransition(ArrayList<Transition> transitions, Transition tr) { [EOL]     int size = transitions.size(); [EOL]     if (size == 0) { [EOL]         transitions.add(tr); [EOL]         return true; [EOL]     } [EOL]     Transition last = transitions.get(size - 1); [EOL]     if (!tr.isTransitionFrom(last)) { [EOL]         return false; [EOL]     } [EOL]     int offsetForLast = 0; [EOL]     if (size >= 2) { [EOL]         offsetForLast = transitions.get(size - 2).getWallOffset(); [EOL]     } [EOL]     int offsetForNew = last.getWallOffset(); [EOL]     long lastLocal = last.getMillis() + offsetForLast; [EOL]     long newLocal = tr.getMillis() + offsetForNew; [EOL]     if (newLocal != lastLocal) { [EOL]         transitions.add(tr); [EOL]         return true; [EOL]     } [EOL]     transitions.remove(size - 1); [EOL]     return addTransition(transitions, tr); [EOL] } <line_num>: 403,433
public void writeTo(String zoneID, OutputStream out) throws IOException { [EOL]     if (out instanceof DataOutput) { [EOL]         writeTo(zoneID, (DataOutput) out); [EOL]     } else { [EOL]         writeTo(zoneID, (DataOutput) new DataOutputStream(out)); [EOL]     } [EOL] } <line_num>: 442,448
public void writeTo(String zoneID, DataOutput out) throws IOException { [EOL]     DateTimeZone zone = toDateTimeZone(zoneID, false); [EOL]     if (zone instanceof FixedDateTimeZone) { [EOL]         out.writeByte('F'); [EOL]         out.writeUTF(zone.getNameKey(0)); [EOL]         writeMillis(out, zone.getOffset(0)); [EOL]         writeMillis(out, zone.getStandardOffset(0)); [EOL]     } else { [EOL]         if (zone instanceof CachedDateTimeZone) { [EOL]             out.writeByte('C'); [EOL]             zone = ((CachedDateTimeZone) zone).getUncachedZone(); [EOL]         } else { [EOL]             out.writeByte('P'); [EOL]         } [EOL]         ((PrecalculatedZone) zone).writeTo(out); [EOL]     } [EOL] } <line_num>: 457,475
static OfYear readFrom(DataInput in) throws IOException { [EOL]     return new OfYear((char) in.readUnsignedByte(), (int) in.readUnsignedByte(), (int) in.readByte(), (int) in.readUnsignedByte(), in.readBoolean(), (int) readMillis(in)); [EOL] } <line_num>: 481,488
public long setInstant(int year, int standardOffset, int saveMillis) { [EOL]     int offset; [EOL]     if (iMode == 'w') { [EOL]         offset = standardOffset + saveMillis; [EOL]     } else if (iMode == 's') { [EOL]         offset = standardOffset; [EOL]     } else { [EOL]         offset = 0; [EOL]     } [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     long millis = chrono.year().set(0, year); [EOL]     millis = chrono.monthOfYear().set(millis, iMonthOfYear); [EOL]     millis = chrono.millisOfDay().set(millis, iMillisOfDay); [EOL]     millis = setDayOfMonth(chrono, millis); [EOL]     if (iDayOfWeek != 0) { [EOL]         millis = setDayOfWeek(chrono, millis); [EOL]     } [EOL]     return millis - offset; [EOL] } <line_num>: 520,542
public long next(long instant, int standardOffset, int saveMillis) { [EOL]     int offset; [EOL]     if (iMode == 'w') { [EOL]         offset = standardOffset + saveMillis; [EOL]     } else if (iMode == 's') { [EOL]         offset = standardOffset; [EOL]     } else { [EOL]         offset = 0; [EOL]     } [EOL]     instant += offset; [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     long next = chrono.monthOfYear().set(instant, iMonthOfYear); [EOL]     next = chrono.millisOfDay().set(next, 0); [EOL]     next = chrono.millisOfDay().add(next, iMillisOfDay); [EOL]     next = setDayOfMonthNext(chrono, next); [EOL]     if (iDayOfWeek == 0) { [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]         } [EOL]     } else { [EOL]         next = setDayOfWeek(chrono, next); [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = chrono.monthOfYear().set(next, iMonthOfYear); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]             next = setDayOfWeek(chrono, next); [EOL]         } [EOL]     } [EOL]     return next - offset; [EOL] } <line_num>: 547,584
public long previous(long instant, int standardOffset, int saveMillis) { [EOL]     int offset; [EOL]     if (iMode == 'w') { [EOL]         offset = standardOffset + saveMillis; [EOL]     } else if (iMode == 's') { [EOL]         offset = standardOffset; [EOL]     } else { [EOL]         offset = 0; [EOL]     } [EOL]     instant += offset; [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     long prev = chrono.monthOfYear().set(instant, iMonthOfYear); [EOL]     prev = chrono.millisOfDay().set(prev, 0); [EOL]     prev = chrono.millisOfDay().add(prev, iMillisOfDay); [EOL]     prev = setDayOfMonthPrevious(chrono, prev); [EOL]     if (iDayOfWeek == 0) { [EOL]         if (prev >= instant) { [EOL]             prev = chrono.year().add(prev, -1); [EOL]             prev = setDayOfMonthPrevious(chrono, prev); [EOL]         } [EOL]     } else { [EOL]         prev = setDayOfWeek(chrono, prev); [EOL]         if (prev >= instant) { [EOL]             prev = chrono.year().add(prev, -1); [EOL]             prev = chrono.monthOfYear().set(prev, iMonthOfYear); [EOL]             prev = setDayOfMonthPrevious(chrono, prev); [EOL]             prev = setDayOfWeek(chrono, prev); [EOL]         } [EOL]     } [EOL]     return prev - offset; [EOL] } <line_num>: 589,626
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof OfYear) { [EOL]         OfYear other = (OfYear) obj; [EOL]         return iMode == other.iMode && iMonthOfYear == other.iMonthOfYear && iDayOfMonth == other.iDayOfMonth && iDayOfWeek == other.iDayOfWeek && iAdvance == other.iAdvance && iMillisOfDay == other.iMillisOfDay; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 628,643
public void writeTo(DataOutput out) throws IOException { [EOL]     out.writeByte(iMode); [EOL]     out.writeByte(iMonthOfYear); [EOL]     out.writeByte(iDayOfMonth); [EOL]     out.writeByte(iDayOfWeek); [EOL]     out.writeBoolean(iAdvance); [EOL]     writeMillis(out, iMillisOfDay); [EOL] } <line_num>: 658,665
private long setDayOfMonthNext(Chronology chrono, long next) { [EOL]     try { [EOL]         next = setDayOfMonth(chrono, next); [EOL]     } catch (IllegalArgumentException e) { [EOL]         if (iMonthOfYear == 2 && iDayOfMonth == 29) { [EOL]             while (chrono.year().isLeap(next) == false) { [EOL]                 next = chrono.year().add(next, 1); [EOL]             } [EOL]             next = setDayOfMonth(chrono, next); [EOL]         } else { [EOL]             throw e; [EOL]         } [EOL]     } [EOL]     return next; [EOL] } <line_num>: 670,684
private long setDayOfMonthPrevious(Chronology chrono, long prev) { [EOL]     try { [EOL]         prev = setDayOfMonth(chrono, prev); [EOL]     } catch (IllegalArgumentException e) { [EOL]         if (iMonthOfYear == 2 && iDayOfMonth == 29) { [EOL]             while (chrono.year().isLeap(prev) == false) { [EOL]                 prev = chrono.year().add(prev, -1); [EOL]             } [EOL]             prev = setDayOfMonth(chrono, prev); [EOL]         } else { [EOL]             throw e; [EOL]         } [EOL]     } [EOL]     return prev; [EOL] } <line_num>: 689,703
private long setDayOfMonth(Chronology chrono, long instant) { [EOL]     if (iDayOfMonth >= 0) { [EOL]         instant = chrono.dayOfMonth().set(instant, iDayOfMonth); [EOL]     } else { [EOL]         instant = chrono.dayOfMonth().set(instant, 1); [EOL]         instant = chrono.monthOfYear().add(instant, 1); [EOL]         instant = chrono.dayOfMonth().add(instant, iDayOfMonth); [EOL]     } [EOL]     return instant; [EOL] } <line_num>: 705,714
private long setDayOfWeek(Chronology chrono, long instant) { [EOL]     int dayOfWeek = chrono.dayOfWeek().get(instant); [EOL]     int daysToAdd = iDayOfWeek - dayOfWeek; [EOL]     if (daysToAdd != 0) { [EOL]         if (iAdvance) { [EOL]             if (daysToAdd < 0) { [EOL]                 daysToAdd += 7; [EOL]             } [EOL]         } else { [EOL]             if (daysToAdd > 0) { [EOL]                 daysToAdd -= 7; [EOL]             } [EOL]         } [EOL]         instant = chrono.dayOfWeek().add(instant, daysToAdd); [EOL]     } [EOL]     return instant; [EOL] } <line_num>: 716,732
static Recurrence readFrom(DataInput in) throws IOException { [EOL]     return new Recurrence(OfYear.readFrom(in), in.readUTF(), (int) readMillis(in)); [EOL] } <line_num>: 739,741
public OfYear getOfYear() { [EOL]     return iOfYear; [EOL] } <line_num>: 753,755
public long next(long instant, int standardOffset, int saveMillis) { [EOL]     return iOfYear.next(instant, standardOffset, saveMillis); [EOL] } <line_num>: 760,762
public long previous(long instant, int standardOffset, int saveMillis) { [EOL]     return iOfYear.previous(instant, standardOffset, saveMillis); [EOL] } <line_num>: 767,769
public String getNameKey() { [EOL]     return iNameKey; [EOL] } <line_num>: 771,773
public int getSaveMillis() { [EOL]     return iSaveMillis; [EOL] } <line_num>: 775,777
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof Recurrence) { [EOL]         Recurrence other = (Recurrence) obj; [EOL]         return iSaveMillis == other.iSaveMillis && iNameKey.equals(other.iNameKey) && iOfYear.equals(other.iOfYear); [EOL]     } [EOL]     return false; [EOL] } <line_num>: 779,791
public void writeTo(DataOutput out) throws IOException { [EOL]     iOfYear.writeTo(out); [EOL]     out.writeUTF(iNameKey); [EOL]     writeMillis(out, iSaveMillis); [EOL] } <line_num>: 793,797
Recurrence rename(String nameKey) { [EOL]     return new Recurrence(iOfYear, nameKey, iSaveMillis); [EOL] } <line_num>: 799,801
Recurrence renameAppend(String appendNameKey) { [EOL]     return rename((iNameKey + appendNameKey).intern()); [EOL] } <line_num>: 803,805
@SuppressWarnings("unused") [EOL] public int getFromYear() { [EOL]     return iFromYear; [EOL] } <line_num>: 822,825
public int getToYear() { [EOL]     return iToYear; [EOL] } <line_num>: 827,829
@SuppressWarnings("unused") [EOL] public OfYear getOfYear() { [EOL]     return iRecurrence.getOfYear(); [EOL] } <line_num>: 831,834
public String getNameKey() { [EOL]     return iRecurrence.getNameKey(); [EOL] } <line_num>: 836,838
public int getSaveMillis() { [EOL]     return iRecurrence.getSaveMillis(); [EOL] } <line_num>: 840,842
public long next(final long instant, int standardOffset, int saveMillis) { [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     final int wallOffset = standardOffset + saveMillis; [EOL]     long testInstant = instant; [EOL]     int year; [EOL]     if (instant == Long.MIN_VALUE) { [EOL]         year = Integer.MIN_VALUE; [EOL]     } else { [EOL]         year = chrono.year().get(instant + wallOffset); [EOL]     } [EOL]     if (year < iFromYear) { [EOL]         testInstant = chrono.year().set(0, iFromYear) - wallOffset; [EOL]         testInstant -= 1; [EOL]     } [EOL]     long next = iRecurrence.next(testInstant, standardOffset, saveMillis); [EOL]     if (next > instant) { [EOL]         year = chrono.year().get(next + wallOffset); [EOL]         if (year > iToYear) { [EOL]             next = instant; [EOL]         } [EOL]     } [EOL]     return next; [EOL] } <line_num>: 844,876
public long getMillis() { [EOL]     return iMillis; [EOL] } <line_num>: 907,909
public String getNameKey() { [EOL]     return iNameKey; [EOL] } <line_num>: 911,913
public int getWallOffset() { [EOL]     return iWallOffset; [EOL] } <line_num>: 915,917
public int getStandardOffset() { [EOL]     return iStandardOffset; [EOL] } <line_num>: 919,921
public int getSaveMillis() { [EOL]     return iWallOffset - iStandardOffset; [EOL] } <line_num>: 923,925
public boolean isTransitionFrom(Transition other) { [EOL]     if (other == null) { [EOL]         return true; [EOL]     } [EOL]     return iMillis > other.iMillis && (iWallOffset != other.iWallOffset || !(iNameKey.equals(other.iNameKey))); [EOL] } <line_num>: 930,938
@SuppressWarnings("unused") [EOL] public int getStandardOffset() { [EOL]     return iStandardOffset; [EOL] } <line_num>: 982,985
public void setStandardOffset(int standardOffset) { [EOL]     iStandardOffset = standardOffset; [EOL] } <line_num>: 987,989
public void setFixedSavings(String nameKey, int saveMillis) { [EOL]     iInitialNameKey = nameKey; [EOL]     iInitialSaveMillis = saveMillis; [EOL] } <line_num>: 991,994
public void addRule(Rule rule) { [EOL]     if (!iRules.contains(rule)) { [EOL]         iRules.add(rule); [EOL]     } [EOL] } <line_num>: 996,1000
public void setUpperLimit(int year, OfYear ofYear) { [EOL]     iUpperYear = year; [EOL]     iUpperOfYear = ofYear; [EOL] } <line_num>: 1002,1005
public Transition firstTransition(final long firstMillis) { [EOL]     if (iInitialNameKey != null) { [EOL]         return new Transition(firstMillis, iInitialNameKey, iStandardOffset + iInitialSaveMillis, iStandardOffset); [EOL]     } [EOL]     ArrayList<Rule> copy = new ArrayList<Rule>(iRules); [EOL]     long millis = Long.MIN_VALUE; [EOL]     int saveMillis = 0; [EOL]     Transition first = null; [EOL]     Transition next; [EOL]     while ((next = nextTransition(millis, saveMillis)) != null) { [EOL]         millis = next.getMillis(); [EOL]         if (millis == firstMillis) { [EOL]             first = new Transition(firstMillis, next); [EOL]             break; [EOL]         } [EOL]         if (millis > firstMillis) { [EOL]             if (first == null) { [EOL]                 for (Rule rule : copy) { [EOL]                     if (rule.getSaveMillis() == 0) { [EOL]                         first = new Transition(firstMillis, rule, iStandardOffset); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (first == null) { [EOL]                 first = new Transition(firstMillis, next.getNameKey(), iStandardOffset, iStandardOffset); [EOL]             } [EOL]             break; [EOL]         } [EOL]         first = new Transition(firstMillis, next); [EOL]         saveMillis = next.getSaveMillis(); [EOL]     } [EOL]     iRules = copy; [EOL]     return first; [EOL] } <line_num>: 1013,1071
public Transition nextTransition(final long instant, final int saveMillis) { [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     Rule nextRule = null; [EOL]     long nextMillis = Long.MAX_VALUE; [EOL]     Iterator<Rule> it = iRules.iterator(); [EOL]     while (it.hasNext()) { [EOL]         Rule rule = it.next(); [EOL]         long next = rule.next(instant, iStandardOffset, saveMillis); [EOL]         if (next <= instant) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         if (next <= nextMillis) { [EOL]             nextRule = rule; [EOL]             nextMillis = next; [EOL]         } [EOL]     } [EOL]     if (nextRule == null) { [EOL]         return null; [EOL]     } [EOL]     if (chrono.year().get(nextMillis) >= YEAR_LIMIT) { [EOL]         return null; [EOL]     } [EOL]     if (iUpperYear < Integer.MAX_VALUE) { [EOL]         long upperMillis = iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis); [EOL]         if (nextMillis >= upperMillis) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     return new Transition(nextMillis, nextRule, iStandardOffset); [EOL] } <line_num>: 1084,1128
public long getUpperLimit(int saveMillis) { [EOL]     if (iUpperYear == Integer.MAX_VALUE) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     return iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis); [EOL] } <line_num>: 1133,1138
public DSTZone buildTailZone(String id) { [EOL]     if (iRules.size() == 2) { [EOL]         Rule startRule = iRules.get(0); [EOL]         Rule endRule = iRules.get(1); [EOL]         if (startRule.getToYear() == Integer.MAX_VALUE && endRule.getToYear() == Integer.MAX_VALUE) { [EOL]             return new DSTZone(id, iStandardOffset, startRule.iRecurrence, endRule.iRecurrence); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 1143,1162
static DSTZone readFrom(DataInput in, String id) throws IOException { [EOL]     return new DSTZone(id, (int) readMillis(in), Recurrence.readFrom(in), Recurrence.readFrom(in)); [EOL] } <line_num>: 1168,1171
public String getNameKey(long instant) { [EOL]     return findMatchingRecurrence(instant).getNameKey(); [EOL] } <line_num>: 1185,1187
public int getOffset(long instant) { [EOL]     return iStandardOffset + findMatchingRecurrence(instant).getSaveMillis(); [EOL] } <line_num>: 1189,1191
public int getStandardOffset(long instant) { [EOL]     return iStandardOffset; [EOL] } <line_num>: 1193,1195
public boolean isFixed() { [EOL]     return false; [EOL] } <line_num>: 1197,1199
public long nextTransition(long instant) { [EOL]     int standardOffset = iStandardOffset; [EOL]     Recurrence startRecurrence = iStartRecurrence; [EOL]     Recurrence endRecurrence = iEndRecurrence; [EOL]     long start, end; [EOL]     try { [EOL]         start = startRecurrence.next(instant, standardOffset, endRecurrence.getSaveMillis()); [EOL]         if (instant > 0 && start < 0) { [EOL]             start = instant; [EOL]         } [EOL]     } catch (IllegalArgumentException e) { [EOL]         start = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         start = instant; [EOL]     } [EOL]     try { [EOL]         end = endRecurrence.next(instant, standardOffset, startRecurrence.getSaveMillis()); [EOL]         if (instant > 0 && end < 0) { [EOL]             end = instant; [EOL]         } [EOL]     } catch (IllegalArgumentException e) { [EOL]         end = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         end = instant; [EOL]     } [EOL]     return (start > end) ? end : start; [EOL] } <line_num>: 1201,1239
public long previousTransition(long instant) { [EOL]     instant++; [EOL]     int standardOffset = iStandardOffset; [EOL]     Recurrence startRecurrence = iStartRecurrence; [EOL]     Recurrence endRecurrence = iEndRecurrence; [EOL]     long start, end; [EOL]     try { [EOL]         start = startRecurrence.previous(instant, standardOffset, endRecurrence.getSaveMillis()); [EOL]         if (instant < 0 && start > 0) { [EOL]             start = instant; [EOL]         } [EOL]     } catch (IllegalArgumentException e) { [EOL]         start = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         start = instant; [EOL]     } [EOL]     try { [EOL]         end = endRecurrence.previous(instant, standardOffset, startRecurrence.getSaveMillis()); [EOL]         if (instant < 0 && end > 0) { [EOL]             end = instant; [EOL]         } [EOL]     } catch (IllegalArgumentException e) { [EOL]         end = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         end = instant; [EOL]     } [EOL]     return ((start > end) ? start : end) - 1; [EOL] } <line_num>: 1241,1283
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof DSTZone) { [EOL]         DSTZone other = (DSTZone) obj; [EOL]         return getID().equals(other.getID()) && iStandardOffset == other.iStandardOffset && iStartRecurrence.equals(other.iStartRecurrence) && iEndRecurrence.equals(other.iEndRecurrence); [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1285,1298
public void writeTo(DataOutput out) throws IOException { [EOL]     writeMillis(out, iStandardOffset); [EOL]     iStartRecurrence.writeTo(out); [EOL]     iEndRecurrence.writeTo(out); [EOL] } <line_num>: 1300,1304
private Recurrence findMatchingRecurrence(long instant) { [EOL]     int standardOffset = iStandardOffset; [EOL]     Recurrence startRecurrence = iStartRecurrence; [EOL]     Recurrence endRecurrence = iEndRecurrence; [EOL]     long start, end; [EOL]     try { [EOL]         start = startRecurrence.next(instant, standardOffset, endRecurrence.getSaveMillis()); [EOL]     } catch (IllegalArgumentException e) { [EOL]         start = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         start = instant; [EOL]     } [EOL]     try { [EOL]         end = endRecurrence.next(instant, standardOffset, startRecurrence.getSaveMillis()); [EOL]     } catch (IllegalArgumentException e) { [EOL]         end = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         end = instant; [EOL]     } [EOL]     return (start > end) ? startRecurrence : endRecurrence; [EOL] } <line_num>: 1306,1336
static PrecalculatedZone readFrom(DataInput in, String id) throws IOException { [EOL]     int poolSize = in.readUnsignedShort(); [EOL]     String[] pool = new String[poolSize]; [EOL]     for (int i = 0; i < poolSize; i++) { [EOL]         pool[i] = in.readUTF(); [EOL]     } [EOL]     int size = in.readInt(); [EOL]     long[] transitions = new long[size]; [EOL]     int[] wallOffsets = new int[size]; [EOL]     int[] standardOffsets = new int[size]; [EOL]     String[] nameKeys = new String[size]; [EOL]     for (int i = 0; i < size; i++) { [EOL]         transitions[i] = readMillis(in); [EOL]         wallOffsets[i] = (int) readMillis(in); [EOL]         standardOffsets[i] = (int) readMillis(in); [EOL]         try { [EOL]             int index; [EOL]             if (poolSize < 256) { [EOL]                 index = in.readUnsignedByte(); [EOL]             } else { [EOL]                 index = in.readUnsignedShort(); [EOL]             } [EOL]             nameKeys[i] = pool[index]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IOException("Invalid encoding"); [EOL]         } [EOL]     } [EOL]     DSTZone tailZone = null; [EOL]     if (in.readBoolean()) { [EOL]         tailZone = DSTZone.readFrom(in, id); [EOL]     } [EOL]     return new PrecalculatedZone(id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone); [EOL] } <line_num>: 1342,1380
static PrecalculatedZone create(String id, boolean outputID, ArrayList<Transition> transitions, DSTZone tailZone) { [EOL]     int size = transitions.size(); [EOL]     if (size == 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     long[] trans = new long[size]; [EOL]     int[] wallOffsets = new int[size]; [EOL]     int[] standardOffsets = new int[size]; [EOL]     String[] nameKeys = new String[size]; [EOL]     Transition last = null; [EOL]     for (int i = 0; i < size; i++) { [EOL]         Transition tr = transitions.get(i); [EOL]         if (!tr.isTransitionFrom(last)) { [EOL]             throw new IllegalArgumentException(id); [EOL]         } [EOL]         trans[i] = tr.getMillis(); [EOL]         wallOffsets[i] = tr.getWallOffset(); [EOL]         standardOffsets[i] = tr.getStandardOffset(); [EOL]         nameKeys[i] = tr.getNameKey(); [EOL]         last = tr; [EOL]     } [EOL]     String[] zoneNameData = new String[5]; [EOL]     String[][] zoneStrings = new DateFormatSymbols(Locale.ENGLISH).getZoneStrings(); [EOL]     for (int j = 0; j < zoneStrings.length; j++) { [EOL]         String[] set = zoneStrings[j]; [EOL]         if (set != null && set.length == 5 && id.equals(set[0])) { [EOL]             zoneNameData = set; [EOL]         } [EOL]     } [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     for (int i = 0; i < nameKeys.length - 1; i++) { [EOL]         String curNameKey = nameKeys[i]; [EOL]         String nextNameKey = nameKeys[i + 1]; [EOL]         long curOffset = wallOffsets[i]; [EOL]         long nextOffset = wallOffsets[i + 1]; [EOL]         long curStdOffset = standardOffsets[i]; [EOL]         long nextStdOffset = standardOffsets[i + 1]; [EOL]         Period p = new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay(), chrono); [EOL]         if (curOffset != nextOffset && curStdOffset == nextStdOffset && curNameKey.equals(nextNameKey) && p.getYears() == 0 && p.getMonths() > 4 && p.getMonths() < 8 && curNameKey.equals(zoneNameData[2]) && curNameKey.equals(zoneNameData[4])) { [EOL]             if (ZoneInfoCompiler.verbose()) { [EOL]                 System.out.println("Fixing duplicate name key - " + nextNameKey); [EOL]                 System.out.println("     - " + new DateTime(trans[i], chrono) + " - " + new DateTime(trans[i + 1], chrono)); [EOL]             } [EOL]             if (curOffset > nextOffset) { [EOL]                 nameKeys[i] = (curNameKey + "-Summer").intern(); [EOL]             } else if (curOffset < nextOffset) { [EOL]                 nameKeys[i + 1] = (nextNameKey + "-Summer").intern(); [EOL]                 i++; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (tailZone != null) { [EOL]         if (tailZone.iStartRecurrence.getNameKey().equals(tailZone.iEndRecurrence.getNameKey())) { [EOL]             if (ZoneInfoCompiler.verbose()) { [EOL]                 System.out.println("Fixing duplicate recurrent name key - " + tailZone.iStartRecurrence.getNameKey()); [EOL]             } [EOL]             if (tailZone.iStartRecurrence.getSaveMillis() > 0) { [EOL]                 tailZone = new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence.renameAppend("-Summer"), tailZone.iEndRecurrence); [EOL]             } else { [EOL]                 tailZone = new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence, tailZone.iEndRecurrence.renameAppend("-Summer")); [EOL]             } [EOL]         } [EOL]     } [EOL]     return new PrecalculatedZone((outputID ? id : ""), trans, wallOffsets, standardOffsets, nameKeys, tailZone); [EOL] } <line_num>: 1390,1485
public String getNameKey(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         return iNameKeys[i]; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             return iNameKeys[i - 1]; [EOL]         } [EOL]         return "UTC"; [EOL]     } [EOL]     if (iTailZone == null) { [EOL]         return iNameKeys[i - 1]; [EOL]     } [EOL]     return iTailZone.getNameKey(instant); [EOL] } <line_num>: 1511,1528
public int getOffset(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         return iWallOffsets[i]; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             return iWallOffsets[i - 1]; [EOL]         } [EOL]         return 0; [EOL]     } [EOL]     if (iTailZone == null) { [EOL]         return iWallOffsets[i - 1]; [EOL]     } [EOL]     return iTailZone.getOffset(instant); [EOL] } <line_num>: 1530,1547
public int getStandardOffset(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         return iStandardOffsets[i]; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             return iStandardOffsets[i - 1]; [EOL]         } [EOL]         return 0; [EOL]     } [EOL]     if (iTailZone == null) { [EOL]         return iStandardOffsets[i - 1]; [EOL]     } [EOL]     return iTailZone.getStandardOffset(instant); [EOL] } <line_num>: 1549,1566
public boolean isFixed() { [EOL]     return false; [EOL] } <line_num>: 1568,1570
public long nextTransition(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     i = (i >= 0) ? (i + 1) : ~i; [EOL]     if (i < transitions.length) { [EOL]         return transitions[i]; [EOL]     } [EOL]     if (iTailZone == null) { [EOL]         return instant; [EOL]     } [EOL]     long end = transitions[transitions.length - 1]; [EOL]     if (instant < end) { [EOL]         instant = end; [EOL]     } [EOL]     return iTailZone.nextTransition(instant); [EOL] } <line_num>: 1572,1587
public long previousTransition(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         if (instant > Long.MIN_VALUE) { [EOL]             return instant - 1; [EOL]         } [EOL]         return instant; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             long prev = transitions[i - 1]; [EOL]             if (prev > Long.MIN_VALUE) { [EOL]                 return prev - 1; [EOL]             } [EOL]         } [EOL]         return instant; [EOL]     } [EOL]     if (iTailZone != null) { [EOL]         long prev = iTailZone.previousTransition(instant); [EOL]         if (prev < instant) { [EOL]             return prev; [EOL]         } [EOL]     } [EOL]     long prev = transitions[i - 1]; [EOL]     if (prev > Long.MIN_VALUE) { [EOL]         return prev - 1; [EOL]     } [EOL]     return instant; [EOL] } <line_num>: 1589,1619
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof PrecalculatedZone) { [EOL]         PrecalculatedZone other = (PrecalculatedZone) obj; [EOL]         return getID().equals(other.getID()) && Arrays.equals(iTransitions, other.iTransitions) && Arrays.equals(iNameKeys, other.iNameKeys) && Arrays.equals(iWallOffsets, other.iWallOffsets) && Arrays.equals(iStandardOffsets, other.iStandardOffsets) && ((iTailZone == null) ? (null == other.iTailZone) : (iTailZone.equals(other.iTailZone))); [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1621,1638
public void writeTo(DataOutput out) throws IOException { [EOL]     int size = iTransitions.length; [EOL]     Set<String> poolSet = new HashSet<String>(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         poolSet.add(iNameKeys[i]); [EOL]     } [EOL]     int poolSize = poolSet.size(); [EOL]     if (poolSize > 65535) { [EOL]         throw new UnsupportedOperationException("String pool is too large"); [EOL]     } [EOL]     String[] pool = new String[poolSize]; [EOL]     Iterator<String> it = poolSet.iterator(); [EOL]     for (int i = 0; it.hasNext(); i++) { [EOL]         pool[i] = it.next(); [EOL]     } [EOL]     out.writeShort(poolSize); [EOL]     for (int i = 0; i < poolSize; i++) { [EOL]         out.writeUTF(pool[i]); [EOL]     } [EOL]     out.writeInt(size); [EOL]     for (int i = 0; i < size; i++) { [EOL]         writeMillis(out, iTransitions[i]); [EOL]         writeMillis(out, iWallOffsets[i]); [EOL]         writeMillis(out, iStandardOffsets[i]); [EOL]         String nameKey = iNameKeys[i]; [EOL]         for (int j = 0; j < poolSize; j++) { [EOL]             if (pool[j].equals(nameKey)) { [EOL]                 if (poolSize < 256) { [EOL]                     out.writeByte(j); [EOL]                 } else { [EOL]                     out.writeShort(j); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     out.writeBoolean(iTailZone != null); [EOL]     if (iTailZone != null) { [EOL]         iTailZone.writeTo(out); [EOL]     } [EOL] } <line_num>: 1640,1690
public boolean isCachable() { [EOL]     if (iTailZone != null) { [EOL]         return true; [EOL]     } [EOL]     long[] transitions = iTransitions; [EOL]     if (transitions.length <= 1) { [EOL]         return false; [EOL]     } [EOL]     double distances = 0; [EOL]     int count = 0; [EOL]     for (int i = 1; i < transitions.length; i++) { [EOL]         long diff = transitions[i] - transitions[i - 1]; [EOL]         if (diff < ((366L + 365) * 24 * 60 * 60 * 1000)) { [EOL]             distances += (double) diff; [EOL]             count++; [EOL]         } [EOL]     } [EOL]     if (count > 0) { [EOL]         double avg = distances / count; [EOL]         avg /= 24 * 60 * 60 * 1000; [EOL]         if (avg >= 25) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1692,1729
