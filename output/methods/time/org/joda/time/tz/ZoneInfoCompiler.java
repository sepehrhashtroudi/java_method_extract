public ZoneInfoCompiler() { [EOL]     iRuleSets = new HashMap<String, RuleSet>(); [EOL]     iZones = new ArrayList<Zone>(); [EOL]     iLinks = new ArrayList<String>(); [EOL] } <line_num>: 355,359
DateTimeOfYear() { [EOL]     iMonthOfYear = 1; [EOL]     iDayOfMonth = 1; [EOL]     iDayOfWeek = 0; [EOL]     iAdvanceDayOfWeek = false; [EOL]     iMillisOfDay = 0; [EOL]     iZoneChar = 'w'; [EOL] } <line_num>: 530,537
DateTimeOfYear(StringTokenizer st) { [EOL]     int month = 1; [EOL]     int day = 1; [EOL]     int dayOfWeek = 0; [EOL]     int millis = 0; [EOL]     boolean advance = false; [EOL]     char zoneChar = 'w'; [EOL]     if (st.hasMoreTokens()) { [EOL]         month = parseMonth(st.nextToken()); [EOL]         if (st.hasMoreTokens()) { [EOL]             String str = st.nextToken(); [EOL]             if (str.startsWith("last")) { [EOL]                 day = -1; [EOL]                 dayOfWeek = parseDayOfWeek(str.substring(4)); [EOL]                 advance = false; [EOL]             } else { [EOL]                 try { [EOL]                     day = Integer.parseInt(str); [EOL]                     dayOfWeek = 0; [EOL]                     advance = false; [EOL]                 } catch (NumberFormatException e) { [EOL]                     int index = str.indexOf(">="); [EOL]                     if (index > 0) { [EOL]                         day = Integer.parseInt(str.substring(index + 2)); [EOL]                         dayOfWeek = parseDayOfWeek(str.substring(0, index)); [EOL]                         advance = true; [EOL]                     } else { [EOL]                         index = str.indexOf("<="); [EOL]                         if (index > 0) { [EOL]                             day = Integer.parseInt(str.substring(index + 2)); [EOL]                             dayOfWeek = parseDayOfWeek(str.substring(0, index)); [EOL]                             advance = false; [EOL]                         } else { [EOL]                             throw new IllegalArgumentException(str); [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (st.hasMoreTokens()) { [EOL]                 str = st.nextToken(); [EOL]                 zoneChar = parseZoneChar(str.charAt(str.length() - 1)); [EOL]                 if (str.equals("24:00")) { [EOL]                     LocalDate date = (day == -1 ? new LocalDate(2001, month, 1).plusMonths(1) : new LocalDate(2001, month, day).plusDays(1)); [EOL]                     advance = (day != -1); [EOL]                     month = date.getMonthOfYear(); [EOL]                     day = date.getDayOfMonth(); [EOL]                     dayOfWeek = ((dayOfWeek - 1 + 1) % 7) + 1; [EOL]                 } else { [EOL]                     millis = parseTime(str); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     iMonthOfYear = month; [EOL]     iDayOfMonth = day; [EOL]     iDayOfWeek = dayOfWeek; [EOL]     iAdvanceDayOfWeek = advance; [EOL]     iMillisOfDay = millis; [EOL]     iZoneChar = zoneChar; [EOL] } <line_num>: 539,604
Rule(StringTokenizer st) { [EOL]     iName = st.nextToken().intern(); [EOL]     iFromYear = parseYear(st.nextToken(), 0); [EOL]     iToYear = parseYear(st.nextToken(), iFromYear); [EOL]     if (iToYear < iFromYear) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     iType = parseOptional(st.nextToken()); [EOL]     iDateTimeOfYear = new DateTimeOfYear(st); [EOL]     iSaveMillis = parseTime(st.nextToken()); [EOL]     iLetterS = parseOptional(st.nextToken()); [EOL] } <line_num>: 655,666
RuleSet(Rule rule) { [EOL]     iRules = new ArrayList<Rule>(); [EOL]     iRules.add(rule); [EOL] } <line_num>: 718,721
Zone(StringTokenizer st) { [EOL]     this(st.nextToken(), st); [EOL] } <line_num>: 751,753
private Zone(String name, StringTokenizer st) { [EOL]     iName = name.intern(); [EOL]     iOffsetMillis = parseTime(st.nextToken()); [EOL]     iRules = parseOptional(st.nextToken()); [EOL]     iFormat = st.nextToken().intern(); [EOL]     int year = Integer.MAX_VALUE; [EOL]     DateTimeOfYear dtOfYear = getStartOfYear(); [EOL]     if (st.hasMoreTokens()) { [EOL]         year = Integer.parseInt(st.nextToken()); [EOL]         if (st.hasMoreTokens()) { [EOL]             dtOfYear = new DateTimeOfYear(st); [EOL]         } [EOL]     } [EOL]     iUntilYear = year; [EOL]     iUntilDateTimeOfYear = dtOfYear; [EOL] } <line_num>: 755,773
protected Boolean initialValue() { [EOL]     return Boolean.FALSE; [EOL] } <line_num>: 69,71
public static boolean verbose() { [EOL]     return cVerbose.get(); [EOL] } <line_num>: 78,80
public static void main(String[] args) throws Exception { [EOL]     if (args.length == 0) { [EOL]         printUsage(); [EOL]         return; [EOL]     } [EOL]     File inputDir = null; [EOL]     File outputDir = null; [EOL]     boolean verbose = false; [EOL]     int i; [EOL]     for (i = 0; i < args.length; i++) { [EOL]         try { [EOL]             if ("-src".equals(args[i])) { [EOL]                 inputDir = new File(args[++i]); [EOL]             } else if ("-dst".equals(args[i])) { [EOL]                 outputDir = new File(args[++i]); [EOL]             } else if ("-verbose".equals(args[i])) { [EOL]                 verbose = true; [EOL]             } else if ("-?".equals(args[i])) { [EOL]                 printUsage(); [EOL]                 return; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } catch (IndexOutOfBoundsException e) { [EOL]             printUsage(); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (i >= args.length) { [EOL]         printUsage(); [EOL]         return; [EOL]     } [EOL]     File[] sources = new File[args.length - i]; [EOL]     for (int j = 0; i < args.length; i++, j++) { [EOL]         sources[j] = inputDir == null ? new File(args[i]) : new File(inputDir, args[i]); [EOL]     } [EOL]     cVerbose.set(verbose); [EOL]     ZoneInfoCompiler zic = new ZoneInfoCompiler(); [EOL]     zic.compile(outputDir, sources); [EOL] } <line_num>: 94,138
private static void printUsage() { [EOL]     System.out.println("Usage: java org.joda.time.tz.ZoneInfoCompiler <options> <source files>"); [EOL]     System.out.println("where possible options include:"); [EOL]     System.out.println("  -src <directory>    Specify where to read source files"); [EOL]     System.out.println("  -dst <directory>    Specify where to write generated files"); [EOL]     System.out.println("  -verbose            Output verbosely (default false)"); [EOL] } <line_num>: 140,146
static DateTimeOfYear getStartOfYear() { [EOL]     if (cStartOfYear == null) { [EOL]         cStartOfYear = new DateTimeOfYear(); [EOL]     } [EOL]     return cStartOfYear; [EOL] } <line_num>: 148,153
static Chronology getLenientISOChronology() { [EOL]     if (cLenientISO == null) { [EOL]         cLenientISO = LenientChronology.getInstance(ISOChronology.getInstanceUTC()); [EOL]     } [EOL]     return cLenientISO; [EOL] } <line_num>: 155,160
static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException { [EOL]     Map<String, Short> idToIndex = new HashMap<String, Short>(zimap.size()); [EOL]     TreeMap<Short, String> indexToId = new TreeMap<Short, String>(); [EOL]     short count = 0; [EOL]     for (Entry<String, DateTimeZone> entry : zimap.entrySet()) { [EOL]         String id = (String) entry.getKey(); [EOL]         if (!idToIndex.containsKey(id)) { [EOL]             Short index = Short.valueOf(count); [EOL]             idToIndex.put(id, index); [EOL]             indexToId.put(index, id); [EOL]             if (++count == 0) { [EOL]                 throw new InternalError("Too many time zone ids"); [EOL]             } [EOL]         } [EOL]         id = ((DateTimeZone) entry.getValue()).getID(); [EOL]         if (!idToIndex.containsKey(id)) { [EOL]             Short index = Short.valueOf(count); [EOL]             idToIndex.put(id, index); [EOL]             indexToId.put(index, id); [EOL]             if (++count == 0) { [EOL]                 throw new InternalError("Too many time zone ids"); [EOL]             } [EOL]         } [EOL]     } [EOL]     dout.writeShort(indexToId.size()); [EOL]     for (String id : indexToId.values()) { [EOL]         dout.writeUTF(id); [EOL]     } [EOL]     dout.writeShort(zimap.size()); [EOL]     for (Entry<String, DateTimeZone> entry : zimap.entrySet()) { [EOL]         String id = entry.getKey(); [EOL]         dout.writeShort(idToIndex.get(id).shortValue()); [EOL]         id = entry.getValue().getID(); [EOL]         dout.writeShort(idToIndex.get(id).shortValue()); [EOL]     } [EOL] } <line_num>: 165,206
static int parseYear(String str, int def) { [EOL]     str = str.toLowerCase(); [EOL]     if (str.equals("minimum") || str.equals("min")) { [EOL]         return Integer.MIN_VALUE; [EOL]     } else if (str.equals("maximum") || str.equals("max")) { [EOL]         return Integer.MAX_VALUE; [EOL]     } else if (str.equals("only")) { [EOL]         return def; [EOL]     } [EOL]     return Integer.parseInt(str); [EOL] } <line_num>: 208,218
static int parseMonth(String str) { [EOL]     DateTimeField field = ISOChronology.getInstanceUTC().monthOfYear(); [EOL]     return field.get(field.set(0, str, Locale.ENGLISH)); [EOL] } <line_num>: 220,223
static int parseDayOfWeek(String str) { [EOL]     DateTimeField field = ISOChronology.getInstanceUTC().dayOfWeek(); [EOL]     return field.get(field.set(0, str, Locale.ENGLISH)); [EOL] } <line_num>: 225,228
static String parseOptional(String str) { [EOL]     return (str.equals("-")) ? null : str; [EOL] } <line_num>: 230,232
static int parseTime(String str) { [EOL]     DateTimeFormatter p = ISODateTimeFormat.hourMinuteSecondFraction(); [EOL]     MutableDateTime mdt = new MutableDateTime(0, getLenientISOChronology()); [EOL]     int pos = 0; [EOL]     if (str.startsWith("-")) { [EOL]         pos = 1; [EOL]     } [EOL]     int newPos = p.parseInto(mdt, str, pos); [EOL]     if (newPos == ~pos) { [EOL]         throw new IllegalArgumentException(str); [EOL]     } [EOL]     int millis = (int) mdt.getMillis(); [EOL]     if (pos == 1) { [EOL]         millis = -millis; [EOL]     } [EOL]     return millis; [EOL] } <line_num>: 234,250
static char parseZoneChar(char c) { [EOL]     switch(c) { [EOL]         case 's': [EOL]         case 'S': [EOL]             return 's'; [EOL]         case 'u': [EOL]         case 'U': [EOL]         case 'g': [EOL]         case 'G': [EOL]         case 'z': [EOL]         case 'Z': [EOL]             return 'u'; [EOL]         case 'w': [EOL]         case 'W': [EOL]         default: [EOL]             return 'w'; [EOL]     } [EOL] } <line_num>: 252,264
static boolean test(String id, DateTimeZone tz) { [EOL]     if (!id.equals(tz.getID())) { [EOL]         return true; [EOL]     } [EOL]     long millis = ISOChronology.getInstanceUTC().year().set(0, 1850); [EOL]     long end = ISOChronology.getInstanceUTC().year().set(0, 2050); [EOL]     int offset = tz.getOffset(millis); [EOL]     String key = tz.getNameKey(millis); [EOL]     List<Long> transitions = new ArrayList<Long>(); [EOL]     while (true) { [EOL]         long next = tz.nextTransition(millis); [EOL]         if (next == millis || next > end) { [EOL]             break; [EOL]         } [EOL]         millis = next; [EOL]         int nextOffset = tz.getOffset(millis); [EOL]         String nextKey = tz.getNameKey(millis); [EOL]         if (offset == nextOffset && key.equals(nextKey)) { [EOL]             System.out.println("*d* Error in " + tz.getID() + " " + new DateTime(millis, ISOChronology.getInstanceUTC())); [EOL]             return false; [EOL]         } [EOL]         if (nextKey == null || (nextKey.length() < 3 && !"??".equals(nextKey))) { [EOL]             System.out.println("*s* Error in " + tz.getID() + " " + new DateTime(millis, ISOChronology.getInstanceUTC()) + ", nameKey=" + nextKey); [EOL]             return false; [EOL]         } [EOL]         transitions.add(Long.valueOf(millis)); [EOL]         offset = nextOffset; [EOL]         key = nextKey; [EOL]     } [EOL]     millis = ISOChronology.getInstanceUTC().year().set(0, 2050); [EOL]     end = ISOChronology.getInstanceUTC().year().set(0, 1850); [EOL]     for (int i = transitions.size(); --i >= 0; ) { [EOL]         long prev = tz.previousTransition(millis); [EOL]         if (prev == millis || prev < end) { [EOL]             break; [EOL]         } [EOL]         millis = prev; [EOL]         long trans = transitions.get(i).longValue(); [EOL]         if (trans - 1 != millis) { [EOL]             System.out.println("*r* Error in " + tz.getID() + " " + new DateTime(millis, ISOChronology.getInstanceUTC()) + " != " + new DateTime(trans - 1, ISOChronology.getInstanceUTC())); [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 269,344
public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException { [EOL]     if (sources != null) { [EOL]         for (int i = 0; i < sources.length; i++) { [EOL]             BufferedReader in = new BufferedReader(new FileReader(sources[i])); [EOL]             parseDataFile(in); [EOL]             in.close(); [EOL]         } [EOL]     } [EOL]     if (outputDir != null) { [EOL]         if (!outputDir.exists()) { [EOL]             if (!outputDir.mkdirs()) { [EOL]                 throw new IOException("Destination directory doesn't exist and cannot be created: " + outputDir); [EOL]             } [EOL]         } [EOL]         if (!outputDir.isDirectory()) { [EOL]             throw new IOException("Destination is not a directory: " + outputDir); [EOL]         } [EOL]     } [EOL]     Map<String, DateTimeZone> map = new TreeMap<String, DateTimeZone>(); [EOL]     System.out.println("Writing zoneinfo files"); [EOL]     for (int i = 0; i < iZones.size(); i++) { [EOL]         Zone zone = iZones.get(i); [EOL]         DateTimeZoneBuilder builder = new DateTimeZoneBuilder(); [EOL]         zone.addToBuilder(builder, iRuleSets); [EOL]         final DateTimeZone original = builder.toDateTimeZone(zone.iName, true); [EOL]         DateTimeZone tz = original; [EOL]         if (test(tz.getID(), tz)) { [EOL]             map.put(tz.getID(), tz); [EOL]             if (outputDir != null) { [EOL]                 if (ZoneInfoCompiler.verbose()) { [EOL]                     System.out.println("Writing " + tz.getID()); [EOL]                 } [EOL]                 File file = new File(outputDir, tz.getID()); [EOL]                 if (!file.getParentFile().exists()) { [EOL]                     file.getParentFile().mkdirs(); [EOL]                 } [EOL]                 OutputStream out = new FileOutputStream(file); [EOL]                 try { [EOL]                     builder.writeTo(zone.iName, out); [EOL]                 } finally { [EOL]                     out.close(); [EOL]                 } [EOL]                 InputStream in = new FileInputStream(file); [EOL]                 DateTimeZone tz2 = DateTimeZoneBuilder.readFrom(in, tz.getID()); [EOL]                 in.close(); [EOL]                 if (!original.equals(tz2)) { [EOL]                     System.out.println("*e* Error in " + tz.getID() + ": Didn't read properly from file"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     for (int pass = 0; pass < 2; pass++) { [EOL]         for (int i = 0; i < iLinks.size(); i += 2) { [EOL]             String id = iLinks.get(i); [EOL]             String alias = iLinks.get(i + 1); [EOL]             DateTimeZone tz = map.get(id); [EOL]             if (tz == null) { [EOL]                 if (pass > 0) { [EOL]                     System.out.println("Cannot find time zone '" + id + "' to link alias '" + alias + "' to"); [EOL]                 } [EOL]             } else { [EOL]                 map.put(alias, tz); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (outputDir != null) { [EOL]         System.out.println("Writing ZoneInfoMap"); [EOL]         File file = new File(outputDir, "ZoneInfoMap"); [EOL]         if (!file.getParentFile().exists()) { [EOL]             file.getParentFile().mkdirs(); [EOL]         } [EOL]         OutputStream out = new FileOutputStream(file); [EOL]         DataOutputStream dout = new DataOutputStream(out); [EOL]         try { [EOL]             Map<String, DateTimeZone> zimap = new TreeMap<String, DateTimeZone>(String.CASE_INSENSITIVE_ORDER); [EOL]             zimap.putAll(map); [EOL]             writeZoneInfoMap(dout, zimap); [EOL]         } finally { [EOL]             dout.close(); [EOL]         } [EOL]     } [EOL]     return map; [EOL] } <line_num>: 367,462
public void parseDataFile(BufferedReader in) throws IOException { [EOL]     Zone zone = null; [EOL]     String line; [EOL]     while ((line = in.readLine()) != null) { [EOL]         String trimmed = line.trim(); [EOL]         if (trimmed.length() == 0 || trimmed.charAt(0) == '#') { [EOL]             continue; [EOL]         } [EOL]         int index = line.indexOf('#'); [EOL]         if (index >= 0) { [EOL]             line = line.substring(0, index); [EOL]         } [EOL]         StringTokenizer st = new StringTokenizer(line, " \t"); [EOL]         if (Character.isWhitespace(line.charAt(0)) && st.hasMoreTokens()) { [EOL]             if (zone != null) { [EOL]                 zone.chain(st); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             if (zone != null) { [EOL]                 iZones.add(zone); [EOL]             } [EOL]             zone = null; [EOL]         } [EOL]         if (st.hasMoreTokens()) { [EOL]             String token = st.nextToken(); [EOL]             if (token.equalsIgnoreCase("Rule")) { [EOL]                 Rule r = new Rule(st); [EOL]                 RuleSet rs = iRuleSets.get(r.iName); [EOL]                 if (rs == null) { [EOL]                     rs = new RuleSet(r); [EOL]                     iRuleSets.put(r.iName, rs); [EOL]                 } else { [EOL]                     rs.addRule(r); [EOL]                 } [EOL]             } else if (token.equalsIgnoreCase("Zone")) { [EOL]                 zone = new Zone(st); [EOL]             } else if (token.equalsIgnoreCase("Link")) { [EOL]                 iLinks.add(st.nextToken()); [EOL]                 iLinks.add(st.nextToken()); [EOL]             } else { [EOL]                 System.out.println("Unknown line: " + line); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (zone != null) { [EOL]         iZones.add(zone); [EOL]     } [EOL] } <line_num>: 464,520
public void addRecurring(DateTimeZoneBuilder builder, String nameKey, int saveMillis, int fromYear, int toYear) { [EOL]     builder.addRecurringSavings(nameKey, saveMillis, fromYear, toYear, iZoneChar, iMonthOfYear, iDayOfMonth, iDayOfWeek, iAdvanceDayOfWeek, iMillisOfDay); [EOL] } <line_num>: 609,620
public void addCutover(DateTimeZoneBuilder builder, int year) { [EOL]     builder.addCutover(year, iZoneChar, iMonthOfYear, iDayOfMonth, iDayOfWeek, iAdvanceDayOfWeek, iMillisOfDay); [EOL] } <line_num>: 625,633
public String toString() { [EOL]     return "MonthOfYear: " + iMonthOfYear + "\n" + "DayOfMonth: " + iDayOfMonth + "\n" + "DayOfWeek: " + iDayOfWeek + "\n" + "AdvanceDayOfWeek: " + iAdvanceDayOfWeek + "\n" + "MillisOfDay: " + iMillisOfDay + "\n" + "ZoneChar: " + iZoneChar + "\n"; [EOL] } <line_num>: 635,643
public void addRecurring(DateTimeZoneBuilder builder, String nameFormat) { [EOL]     String nameKey = formatName(nameFormat); [EOL]     iDateTimeOfYear.addRecurring(builder, nameKey, iSaveMillis, iFromYear, iToYear); [EOL] } <line_num>: 671,675
private String formatName(String nameFormat) { [EOL]     int index = nameFormat.indexOf('/'); [EOL]     if (index > 0) { [EOL]         if (iSaveMillis == 0) { [EOL]             return nameFormat.substring(0, index).intern(); [EOL]         } else { [EOL]             return nameFormat.substring(index + 1).intern(); [EOL]         } [EOL]     } [EOL]     index = nameFormat.indexOf("%s"); [EOL]     if (index < 0) { [EOL]         return nameFormat; [EOL]     } [EOL]     String left = nameFormat.substring(0, index); [EOL]     String right = nameFormat.substring(index + 2); [EOL]     String name; [EOL]     if (iLetterS == null) { [EOL]         name = left.concat(right); [EOL]     } else { [EOL]         name = left + iLetterS + right; [EOL]     } [EOL]     return name.intern(); [EOL] } <line_num>: 677,700
public String toString() { [EOL]     return "[Rule]\n" + "Name: " + iName + "\n" + "FromYear: " + iFromYear + "\n" + "ToYear: " + iToYear + "\n" + "Type: " + iType + "\n" + iDateTimeOfYear + "SaveMillis: " + iSaveMillis + "\n" + "LetterS: " + iLetterS + "\n"; [EOL] } <line_num>: 702,712
void addRule(Rule rule) { [EOL]     if (!(rule.iName.equals(iRules.get(0).iName))) { [EOL]         throw new IllegalArgumentException("Rule name mismatch"); [EOL]     } [EOL]     iRules.add(rule); [EOL] } <line_num>: 723,728
public void addRecurring(DateTimeZoneBuilder builder, String nameFormat) { [EOL]     for (int i = 0; i < iRules.size(); i++) { [EOL]         Rule rule = iRules.get(i); [EOL]         rule.addRecurring(builder, nameFormat); [EOL]     } [EOL] } <line_num>: 733,738
void chain(StringTokenizer st) { [EOL]     if (iNext != null) { [EOL]         iNext.chain(st); [EOL]     } else { [EOL]         iNext = new Zone(iName, st); [EOL]     } [EOL] } <line_num>: 775,781
public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets) { [EOL]     addToBuilder(this, builder, ruleSets); [EOL] } <line_num>: 794,796
private static void addToBuilder(Zone zone, DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets) { [EOL]     for (; zone != null; zone = zone.iNext) { [EOL]         builder.setStandardOffset(zone.iOffsetMillis); [EOL]         if (zone.iRules == null) { [EOL]             builder.setFixedSavings(zone.iFormat, 0); [EOL]         } else { [EOL]             try { [EOL]                 int saveMillis = parseTime(zone.iRules); [EOL]                 builder.setFixedSavings(zone.iFormat, saveMillis); [EOL]             } catch (Exception e) { [EOL]                 RuleSet rs = ruleSets.get(zone.iRules); [EOL]                 if (rs == null) { [EOL]                     throw new IllegalArgumentException("Rules not found: " + zone.iRules); [EOL]                 } [EOL]                 rs.addRecurring(builder, zone.iFormat); [EOL]             } [EOL]         } [EOL]         if (zone.iUntilYear == Integer.MAX_VALUE) { [EOL]             break; [EOL]         } [EOL]         zone.iUntilDateTimeOfYear.addCutover(builder, zone.iUntilYear); [EOL]     } [EOL] } <line_num>: 798,829
public String toString() { [EOL]     String str = "[Zone]\n" + "Name: " + iName + "\n" + "OffsetMillis: " + iOffsetMillis + "\n" + "Rules: " + iRules + "\n" + "Format: " + iFormat + "\n" + "UntilYear: " + iUntilYear + "\n" + iUntilDateTimeOfYear; [EOL]     if (iNext == null) { [EOL]         return str; [EOL]     } [EOL]     return str + "...\n" + iNext.toString(); [EOL] } <line_num>: 831,846
