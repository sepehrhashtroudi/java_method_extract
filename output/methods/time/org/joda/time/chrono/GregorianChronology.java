private GregorianChronology(Chronology base, Object param, int minDaysInFirstWeek) { [EOL]     super(base, param, minDaysInFirstWeek); [EOL] } <line_num>: 147,149
public static GregorianChronology getInstanceUTC() { [EOL]     return INSTANCE_UTC; [EOL] } <line_num>: 80,82
public static GregorianChronology getInstance() { [EOL]     return getInstance(DateTimeZone.getDefault(), 4); [EOL] } <line_num>: 89,91
public static GregorianChronology getInstance(DateTimeZone zone) { [EOL]     return getInstance(zone, 4); [EOL] } <line_num>: 99,101
public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     GregorianChronology chrono; [EOL]     synchronized (cCache) { [EOL]         GregorianChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new GregorianChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new GregorianChronology(null, null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new GregorianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] } <line_num>: 110,139
private Object readResolve() { [EOL]     Chronology base = getBase(); [EOL]     int minDays = getMinimumDaysInFirstWeek(); [EOL]     minDays = (minDays == 0 ? 4 : minDays); [EOL]     return base == null ? getInstance(DateTimeZone.UTC, minDays) : getInstance(base.getZone(), minDays); [EOL] } <line_num>: 154,161
public Chronology withUTC() { [EOL]     return INSTANCE_UTC; [EOL] } <line_num>: 170,172
public Chronology withZone(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     if (zone == getZone()) { [EOL]         return this; [EOL]     } [EOL]     return getInstance(zone); [EOL] } <line_num>: 180,188
protected void assemble(Fields fields) { [EOL]     if (getBase() == null) { [EOL]         super.assemble(fields); [EOL]     } [EOL] } <line_num>: 190,194
boolean isLeapYear(int year) { [EOL]     return ((year & 3) == 0) && ((year % 100) != 0 || (year % 400) == 0); [EOL] } <line_num>: 196,198
long calculateFirstDayOfYearMillis(int year) { [EOL]     int leapYears = year / 100; [EOL]     if (year < 0) { [EOL]         leapYears = ((year + 3) >> 2) - leapYears + ((leapYears + 3) >> 2) - 1; [EOL]     } else { [EOL]         leapYears = (year >> 2) - leapYears + (leapYears >> 2); [EOL]         if (isLeapYear(year)) { [EOL]             leapYears--; [EOL]         } [EOL]     } [EOL]     return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY; [EOL] } <line_num>: 200,218
int getMinYear() { [EOL]     return MIN_YEAR; [EOL] } <line_num>: 220,222
int getMaxYear() { [EOL]     return MAX_YEAR; [EOL] } <line_num>: 224,226
long getAverageMillisPerYear() { [EOL]     return MILLIS_PER_YEAR; [EOL] } <line_num>: 228,230
long getAverageMillisPerYearDividedByTwo() { [EOL]     return MILLIS_PER_YEAR / 2; [EOL] } <line_num>: 232,234
long getAverageMillisPerMonth() { [EOL]     return MILLIS_PER_MONTH; [EOL] } <line_num>: 236,238
long getApproxMillisAtEpochDividedByTwo() { [EOL]     return (1970L * MILLIS_PER_YEAR) / 2; [EOL] } <line_num>: 240,242
