JulianChronology(Chronology base, Object param, int minDaysInFirstWeek) { [EOL]     super(base, param, minDaysInFirstWeek); [EOL] } <line_num>: 161,163
static int adjustYearForSet(int year) { [EOL]     if (year <= 0) { [EOL]         if (year == 0) { [EOL]             throw new IllegalFieldValueException(DateTimeFieldType.year(), Integer.valueOf(year), null, null); [EOL]         } [EOL]         year++; [EOL]     } [EOL]     return year; [EOL] } <line_num>: 77,86
public static JulianChronology getInstanceUTC() { [EOL]     return INSTANCE_UTC; [EOL] } <line_num>: 94,96
public static JulianChronology getInstance() { [EOL]     return getInstance(DateTimeZone.getDefault(), 4); [EOL] } <line_num>: 103,105
public static JulianChronology getInstance(DateTimeZone zone) { [EOL]     return getInstance(zone, 4); [EOL] } <line_num>: 113,115
public static JulianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     JulianChronology chrono; [EOL]     synchronized (cCache) { [EOL]         JulianChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new JulianChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new JulianChronology(null, null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new JulianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] } <line_num>: 124,153
private Object readResolve() { [EOL]     Chronology base = getBase(); [EOL]     int minDays = getMinimumDaysInFirstWeek(); [EOL]     minDays = (minDays == 0 ? 4 : minDays); [EOL]     return base == null ? getInstance(DateTimeZone.UTC, minDays) : getInstance(base.getZone(), minDays); [EOL] } <line_num>: 168,175
public Chronology withUTC() { [EOL]     return INSTANCE_UTC; [EOL] } <line_num>: 184,186
public Chronology withZone(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     if (zone == getZone()) { [EOL]         return this; [EOL]     } [EOL]     return getInstance(zone); [EOL] } <line_num>: 194,202
long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) throws IllegalArgumentException { [EOL]     return super.getDateMidnightMillis(adjustYearForSet(year), monthOfYear, dayOfMonth); [EOL] } <line_num>: 204,208
boolean isLeapYear(int year) { [EOL]     return (year & 3) == 0; [EOL] } <line_num>: 210,212
long calculateFirstDayOfYearMillis(int year) { [EOL]     int relativeYear = year - 1968; [EOL]     int leapYears; [EOL]     if (relativeYear <= 0) { [EOL]         leapYears = (relativeYear + 3) >> 2; [EOL]     } else { [EOL]         leapYears = relativeYear >> 2; [EOL]         if (!isLeapYear(year)) { [EOL]             leapYears++; [EOL]         } [EOL]     } [EOL]     long millis = (relativeYear * 365L + leapYears) * (long) DateTimeConstants.MILLIS_PER_DAY; [EOL]     return millis - (366L + 352) * DateTimeConstants.MILLIS_PER_DAY; [EOL] } <line_num>: 214,238
int getMinYear() { [EOL]     return MIN_YEAR; [EOL] } <line_num>: 240,242
int getMaxYear() { [EOL]     return MAX_YEAR; [EOL] } <line_num>: 244,246
long getAverageMillisPerYear() { [EOL]     return MILLIS_PER_YEAR; [EOL] } <line_num>: 248,250
long getAverageMillisPerYearDividedByTwo() { [EOL]     return MILLIS_PER_YEAR / 2; [EOL] } <line_num>: 252,254
long getAverageMillisPerMonth() { [EOL]     return MILLIS_PER_MONTH; [EOL] } <line_num>: 256,258
long getApproxMillisAtEpochDividedByTwo() { [EOL]     return (1969L * MILLIS_PER_YEAR + 352L * DateTimeConstants.MILLIS_PER_DAY) / 2; [EOL] } <line_num>: 260,262
protected void assemble(Fields fields) { [EOL]     if (getBase() == null) { [EOL]         super.assemble(fields); [EOL]         fields.year = new SkipDateTimeField(this, fields.year); [EOL]         fields.weekyear = new SkipDateTimeField(this, fields.weekyear); [EOL]     } [EOL] } <line_num>: 264,271
