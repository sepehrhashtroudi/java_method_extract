CopticChronology(Chronology base, Object param, int minDaysInFirstWeek) { [EOL]     super(base, param, minDaysInFirstWeek); [EOL] } <line_num>: 160,162
public static CopticChronology getInstanceUTC() { [EOL]     return INSTANCE_UTC; [EOL] } <line_num>: 88,90
public static CopticChronology getInstance() { [EOL]     return getInstance(DateTimeZone.getDefault(), 4); [EOL] } <line_num>: 97,99
public static CopticChronology getInstance(DateTimeZone zone) { [EOL]     return getInstance(zone, 4); [EOL] } <line_num>: 107,109
public static CopticChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     CopticChronology chrono; [EOL]     synchronized (cCache) { [EOL]         CopticChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new CopticChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new CopticChronology(null, null, minDaysInFirstWeek); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new CopticChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new CopticChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] } <line_num>: 118,153
private Object readResolve() { [EOL]     Chronology base = getBase(); [EOL]     int minDays = getMinimumDaysInFirstWeek(); [EOL]     minDays = (minDays == 0 ? 4 : minDays); [EOL]     return base == null ? getInstance(DateTimeZone.UTC, minDays) : getInstance(base.getZone(), minDays); [EOL] } <line_num>: 167,174
public Chronology withUTC() { [EOL]     return INSTANCE_UTC; [EOL] } <line_num>: 183,185
public Chronology withZone(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     if (zone == getZone()) { [EOL]         return this; [EOL]     } [EOL]     return getInstance(zone); [EOL] } <line_num>: 193,201
long calculateFirstDayOfYearMillis(int year) { [EOL]     int relativeYear = year - 1687; [EOL]     int leapYears; [EOL]     if (relativeYear <= 0) { [EOL]         leapYears = (relativeYear + 3) >> 2; [EOL]     } else { [EOL]         leapYears = relativeYear >> 2; [EOL]         if (!isLeapYear(year)) { [EOL]             leapYears++; [EOL]         } [EOL]     } [EOL]     long millis = (relativeYear * 365L + leapYears) * (long) DateTimeConstants.MILLIS_PER_DAY; [EOL]     return millis + (365L - 112) * DateTimeConstants.MILLIS_PER_DAY; [EOL] } <line_num>: 204,229
int getMinYear() { [EOL]     return MIN_YEAR; [EOL] } <line_num>: 232,234
int getMaxYear() { [EOL]     return MAX_YEAR; [EOL] } <line_num>: 237,239
long getApproxMillisAtEpochDividedByTwo() { [EOL]     return (1686L * MILLIS_PER_YEAR + 112L * DateTimeConstants.MILLIS_PER_DAY) / 2; [EOL] } <line_num>: 242,244
protected void assemble(Fields fields) { [EOL]     if (getBase() == null) { [EOL]         super.assemble(fields); [EOL]         fields.year = new SkipDateTimeField(this, fields.year); [EOL]         fields.weekyear = new SkipDateTimeField(this, fields.weekyear); [EOL]         fields.era = ERA_FIELD; [EOL]         fields.monthOfYear = new BasicMonthOfYearDateTimeField(this, 13); [EOL]         fields.months = fields.monthOfYear.getDurationField(); [EOL]     } [EOL] } <line_num>: 247,259
