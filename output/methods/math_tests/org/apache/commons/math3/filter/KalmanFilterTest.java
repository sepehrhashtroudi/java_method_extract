@Test(expected = MatrixDimensionMismatchException.class) [EOL] public void testTransitionMeasurementMatrixMismatch() { [EOL]     RealMatrix A = new Array2DRowRealMatrix(new double[] { 1d }); [EOL]     RealMatrix B = null; [EOL]     RealMatrix H = new Array2DRowRealMatrix(new double[] { 1d, 1d }); [EOL]     RealMatrix Q = new Array2DRowRealMatrix(new double[] { 0 }); [EOL]     RealMatrix R = new Array2DRowRealMatrix(new double[] { 0 }); [EOL]     ProcessModel pm = new DefaultProcessModel(A, B, Q, new ArrayRealVector(new double[] { 0 }), null); [EOL]     MeasurementModel mm = new DefaultMeasurementModel(H, R); [EOL]     new KalmanFilter(pm, mm); [EOL]     Assert.fail("transition and measurement matrix should not be compatible"); [EOL] } <line_num>: 35,57
@Test(expected = MatrixDimensionMismatchException.class) [EOL] public void testTransitionControlMatrixMismatch() { [EOL]     RealMatrix A = new Array2DRowRealMatrix(new double[] { 1d }); [EOL]     RealMatrix B = new Array2DRowRealMatrix(new double[] { 1d, 1d }); [EOL]     RealMatrix H = new Array2DRowRealMatrix(new double[] { 1d }); [EOL]     RealMatrix Q = new Array2DRowRealMatrix(new double[] { 0 }); [EOL]     RealMatrix R = new Array2DRowRealMatrix(new double[] { 0 }); [EOL]     ProcessModel pm = new DefaultProcessModel(A, B, Q, new ArrayRealVector(new double[] { 0 }), null); [EOL]     MeasurementModel mm = new DefaultMeasurementModel(H, R); [EOL]     new KalmanFilter(pm, mm); [EOL]     Assert.fail("transition and control matrix should not be compatible"); [EOL] } <line_num>: 59,81
@Test [EOL] public void testConstant() { [EOL]     double constantValue = 10d; [EOL]     double measurementNoise = 0.1d; [EOL]     double processNoise = 1e-5d; [EOL]     RealMatrix A = new Array2DRowRealMatrix(new double[] { 1d }); [EOL]     RealMatrix B = null; [EOL]     RealMatrix H = new Array2DRowRealMatrix(new double[] { 1d }); [EOL]     RealVector x = new ArrayRealVector(new double[] { constantValue }); [EOL]     RealMatrix Q = new Array2DRowRealMatrix(new double[] { processNoise }); [EOL]     RealMatrix R = new Array2DRowRealMatrix(new double[] { measurementNoise }); [EOL]     ProcessModel pm = new DefaultProcessModel(A, B, Q, new ArrayRealVector(new double[] { constantValue }), null); [EOL]     MeasurementModel mm = new DefaultMeasurementModel(H, R); [EOL]     KalmanFilter filter = new KalmanFilter(pm, mm); [EOL]     Assert.assertEquals(1, filter.getMeasurementDimension()); [EOL]     Assert.assertEquals(1, filter.getStateDimension()); [EOL]     assertMatrixEquals(Q.getData(), filter.getErrorCovariance()); [EOL]     double[] expectedInitialState = new double[] { constantValue }; [EOL]     assertVectorEquals(expectedInitialState, filter.getStateEstimation()); [EOL]     RealVector pNoise = new ArrayRealVector(1); [EOL]     RealVector mNoise = new ArrayRealVector(1); [EOL]     RandomGenerator rand = new JDKRandomGenerator(); [EOL]     for (int i = 0; i < 60; i++) { [EOL]         filter.predict(); [EOL]         pNoise.setEntry(0, processNoise * rand.nextGaussian()); [EOL]         x = A.operate(x).add(pNoise); [EOL]         mNoise.setEntry(0, measurementNoise * rand.nextGaussian()); [EOL]         RealVector z = H.operate(x).add(mNoise); [EOL]         filter.correct(z); [EOL]         double diff = Math.abs(constantValue - filter.getStateEstimation()[0]); [EOL]         Assert.assertTrue(Precision.compareTo(diff, measurementNoise, 1e-6) < 0); [EOL]     } [EOL]     Assert.assertTrue(Precision.compareTo(filter.getErrorCovariance()[0][0], 0.02d, 1e-6) < 0); [EOL] } <line_num>: 83,150
@Test [EOL] public void testConstantAcceleration() { [EOL]     double dt = 0.1d; [EOL]     double measurementNoise = 10d; [EOL]     double accelNoise = 0.2d; [EOL]     RealMatrix A = new Array2DRowRealMatrix(new double[][] { { 1, dt }, { 0, 1 } }); [EOL]     RealMatrix B = new Array2DRowRealMatrix(new double[][] { { Math.pow(dt, 2d) / 2d }, { dt } }); [EOL]     RealMatrix H = new Array2DRowRealMatrix(new double[][] { { 1d, 0d } }); [EOL]     RealVector x = new ArrayRealVector(new double[] { 0, 0 }); [EOL]     RealMatrix tmp = new Array2DRowRealMatrix(new double[][] { { Math.pow(dt, 4d) / 4d, Math.pow(dt, 3d) / 2d }, { Math.pow(dt, 3d) / 2d, Math.pow(dt, 2d) } }); [EOL]     RealMatrix Q = tmp.scalarMultiply(Math.pow(accelNoise, 2)); [EOL]     RealMatrix P0 = new Array2DRowRealMatrix(new double[][] { { 1, 1 }, { 1, 1 } }); [EOL]     RealMatrix R = new Array2DRowRealMatrix(new double[] { Math.pow(measurementNoise, 2) }); [EOL]     RealVector u = new ArrayRealVector(new double[] { 0.1d }); [EOL]     ProcessModel pm = new DefaultProcessModel(A, B, Q, x, P0); [EOL]     MeasurementModel mm = new DefaultMeasurementModel(H, R); [EOL]     KalmanFilter filter = new KalmanFilter(pm, mm); [EOL]     Assert.assertEquals(1, filter.getMeasurementDimension()); [EOL]     Assert.assertEquals(2, filter.getStateDimension()); [EOL]     assertMatrixEquals(P0.getData(), filter.getErrorCovariance()); [EOL]     double[] expectedInitialState = new double[] { 0.0, 0.0 }; [EOL]     assertVectorEquals(expectedInitialState, filter.getStateEstimation()); [EOL]     RandomGenerator rand = new JDKRandomGenerator(); [EOL]     RealVector tmpPNoise = new ArrayRealVector(new double[] { Math.pow(dt, 2d) / 2d, dt }); [EOL]     RealVector mNoise = new ArrayRealVector(1); [EOL]     for (int i = 0; i < 60; i++) { [EOL]         filter.predict(u); [EOL]         RealVector pNoise = tmpPNoise.mapMultiply(accelNoise * rand.nextGaussian()); [EOL]         x = A.operate(x).add(B.operate(u)).add(pNoise); [EOL]         mNoise.setEntry(0, measurementNoise * rand.nextGaussian()); [EOL]         RealVector z = H.operate(x).add(mNoise); [EOL]         filter.correct(z); [EOL]         double diff = Math.abs(x.getEntry(0) - filter.getStateEstimation()[0]); [EOL]         Assert.assertTrue(Precision.compareTo(diff, measurementNoise, 1e-6) < 0); [EOL]     } [EOL]     Assert.assertTrue(Precision.compareTo(filter.getErrorCovariance()[1][1], 0.1d, 1e-6) < 0); [EOL] } <line_num>: 152,243
private void assertVectorEquals(double[] expected, double[] result) { [EOL]     Assert.assertEquals("Wrong number of rows.", expected.length, result.length); [EOL]     for (int i = 0; i < expected.length; i++) { [EOL]         Assert.assertEquals("Wrong value at position [" + i + "]", expected[i], result[i], 1.0e-6); [EOL]     } [EOL] } <line_num>: 245,252
private void assertMatrixEquals(double[][] expected, double[][] result) { [EOL]     Assert.assertEquals("Wrong number of rows.", expected.length, result.length); [EOL]     for (int i = 0; i < expected.length; i++) { [EOL]         Assert.assertEquals("Wrong number of columns.", expected[i].length, result[i].length); [EOL]         for (int j = 0; j < expected[i].length; j++) { [EOL]             Assert.assertEquals("Wrong value at position [" + i + "," + j + "]", expected[i][j], result[i][j], 1.0e-6); [EOL]         } [EOL]     } [EOL] } <line_num>: 254,265
