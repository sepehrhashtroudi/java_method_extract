public MillerUpdatingRegressionTest() { [EOL] } <line_num>: 31,32
@Test [EOL] public void testHasIntercept() { [EOL]     MillerUpdatingRegression instance = new MillerUpdatingRegression(10, false); [EOL]     if (instance.hasIntercept()) { [EOL]         Assert.fail("Should not have intercept"); [EOL]     } [EOL]     instance = new MillerUpdatingRegression(10, true); [EOL]     if (!instance.hasIntercept()) { [EOL]         Assert.fail("Should have intercept"); [EOL]     } [EOL] } <line_num>: 48,58
@Test [EOL] public void testAddObsGetNClear() { [EOL]     MillerUpdatingRegression instance = new MillerUpdatingRegression(3, true); [EOL]     double[][] xAll = new double[airdata[0].length][]; [EOL]     double[] y = new double[airdata[0].length]; [EOL]     for (int i = 0; i < airdata[0].length; i++) { [EOL]         xAll[i] = new double[3]; [EOL]         xAll[i][0] = Math.log(airdata[3][i]); [EOL]         xAll[i][1] = Math.log(airdata[4][i]); [EOL]         xAll[i][2] = airdata[5][i]; [EOL]         y[i] = Math.log(airdata[2][i]); [EOL]     } [EOL]     instance.addObservations(xAll, y); [EOL]     if (instance.getN() != xAll.length) { [EOL]         Assert.fail("Number of observations not correct in bulk addition"); [EOL]     } [EOL]     instance.clear(); [EOL]     for (int i = 0; i < xAll.length; i++) { [EOL]         instance.addObservation(xAll[i], y[i]); [EOL]     } [EOL]     if (instance.getN() != xAll.length) { [EOL]         Assert.fail("Number of observations not correct in drip addition"); [EOL]     } [EOL]     return; [EOL] } <line_num>: 63,87
@Test [EOL] public void testNegativeTestAddObs() { [EOL]     MillerUpdatingRegression instance = new MillerUpdatingRegression(3, true); [EOL]     try { [EOL]         instance.addObservation(new double[] { 1.0 }, 0.0); [EOL]         Assert.fail("Should throw IllegalArgumentException"); [EOL]     } catch (IllegalArgumentException iae) { [EOL]     } catch (Exception e) { [EOL]         Assert.fail("Should throw IllegalArgumentException"); [EOL]     } [EOL]     try { [EOL]         instance.addObservation(new double[] { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 }, 0.0); [EOL]         Assert.fail("Should throw IllegalArgumentException"); [EOL]     } catch (IllegalArgumentException iae) { [EOL]     } catch (Exception e) { [EOL]         Assert.fail("Should throw IllegalArgumentException"); [EOL]     } [EOL]     try { [EOL]         instance.addObservation(new double[] { 1.0, 1.0, 1.0 }, 0.0); [EOL]     } catch (Exception e) { [EOL]         Assert.fail("Should throw IllegalArgumentException"); [EOL]     } [EOL]     instance = new MillerUpdatingRegression(3, false); [EOL]     try { [EOL]         instance.addObservation(new double[] { 1.0 }, 0.0); [EOL]         Assert.fail("Should throw IllegalArgumentException [NOINTERCEPT]"); [EOL]     } catch (IllegalArgumentException iae) { [EOL]     } catch (Exception e) { [EOL]         Assert.fail("Should throw IllegalArgumentException [NOINTERCEPT]"); [EOL]     } [EOL]     try { [EOL]         instance.addObservation(new double[] { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 }, 0.0); [EOL]         Assert.fail("Should throw IllegalArgumentException [NOINTERCEPT]"); [EOL]     } catch (IllegalArgumentException iae) { [EOL]     } catch (Exception e) { [EOL]         Assert.fail("Should throw IllegalArgumentException [NOINTERCEPT]"); [EOL]     } [EOL]     try { [EOL]         instance.addObservation(new double[] { 1.0, 1.0, 1.0 }, 0.0); [EOL]     } catch (Exception e) { [EOL]         Assert.fail("Should throw IllegalArgumentException [NOINTERCEPT]"); [EOL]     } [EOL] } <line_num>: 89,133
@Test [EOL] public void testNegativeTestAddMultipleObs() { [EOL]     MillerUpdatingRegression instance = new MillerUpdatingRegression(3, true); [EOL]     try { [EOL]         double[][] tst = { { 1.0, 1.0, 1.0 }, { 1.20, 2.0, 2.1 } }; [EOL]         double[] y = { 1.0 }; [EOL]         instance.addObservations(tst, y); [EOL]         Assert.fail("Should throw IllegalArgumentException"); [EOL]     } catch (IllegalArgumentException iae) { [EOL]     } catch (Exception e) { [EOL]         Assert.fail("Should throw IllegalArgumentException"); [EOL]     } [EOL]     try { [EOL]         double[][] tst = { { 1.0, 1.0, 1.0 }, { 1.20, 2.0, 2.1 } }; [EOL]         double[] y = { 1.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0 }; [EOL]         instance.addObservations(tst, y); [EOL]         Assert.fail("Should throw IllegalArgumentException"); [EOL]     } catch (IllegalArgumentException iae) { [EOL]     } catch (Exception e) { [EOL]         Assert.fail("Should throw IllegalArgumentException"); [EOL]     } [EOL] } <line_num>: 135,159
@Test [EOL] public void testRegressAirlineConstantExternal() { [EOL]     MillerUpdatingRegression instance = new MillerUpdatingRegression(4, false); [EOL]     double[][] x = new double[airdata[0].length][]; [EOL]     double[] y = new double[airdata[0].length]; [EOL]     for (int i = 0; i < airdata[0].length; i++) { [EOL]         x[i] = new double[4]; [EOL]         x[i][0] = 1.0; [EOL]         x[i][1] = Math.log(airdata[3][i]); [EOL]         x[i][2] = Math.log(airdata[4][i]); [EOL]         x[i][3] = airdata[5][i]; [EOL]         y[i] = Math.log(airdata[2][i]); [EOL]     } [EOL]     instance.addObservations(x, y); [EOL]     try { [EOL]         RegressionResults result = instance.regress(); [EOL]         Assert.assertNotNull("The test case is a prototype.", result); [EOL]         TestUtils.assertEquals(new double[] { 9.5169, 0.8827, 0.4540, -1.6275 }, result.getParameterEstimates(), 1e-4); [EOL]         TestUtils.assertEquals(new double[] { .2292445, .0132545, .0203042, .345302 }, result.getStdErrorOfEstimates(), 1.0e-4); [EOL]         TestUtils.assertEquals(0.01552839, result.getMeanSquareError(), 1.0e-8); [EOL]     } catch (Exception e) { [EOL]         Assert.fail("Should not throw exception but does"); [EOL]     } [EOL] } <line_num>: 164,195
@Test [EOL] public void testRegressAirlineConstantInternal() { [EOL]     MillerUpdatingRegression instance = new MillerUpdatingRegression(3, true); [EOL]     double[][] x = new double[airdata[0].length][]; [EOL]     double[] y = new double[airdata[0].length]; [EOL]     for (int i = 0; i < airdata[0].length; i++) { [EOL]         x[i] = new double[3]; [EOL]         x[i][0] = Math.log(airdata[3][i]); [EOL]         x[i][1] = Math.log(airdata[4][i]); [EOL]         x[i][2] = airdata[5][i]; [EOL]         y[i] = Math.log(airdata[2][i]); [EOL]     } [EOL]     instance.addObservations(x, y); [EOL]     try { [EOL]         RegressionResults result = instance.regress(); [EOL]         Assert.assertNotNull("The test case is a prototype.", result); [EOL]         TestUtils.assertEquals(new double[] { 9.5169, 0.8827, 0.4540, -1.6275 }, result.getParameterEstimates(), 1e-4); [EOL]         TestUtils.assertEquals(new double[] { .2292445, .0132545, .0203042, .345302 }, result.getStdErrorOfEstimates(), 1.0e-4); [EOL]         TestUtils.assertEquals(0.9883, result.getRSquared(), 1.0e-4); [EOL]         TestUtils.assertEquals(0.01552839, result.getMeanSquareError(), 1.0e-8); [EOL]     } catch (Exception e) { [EOL]         Assert.fail("Should not throw exception but does"); [EOL]     } [EOL] } <line_num>: 197,228
@Test [EOL] public void testFilippelli() { [EOL]     double[] data = new double[] { 0.8116, -6.860120914, 0.9072, -4.324130045, 0.9052, -4.358625055, 0.9039, -4.358426747, 0.8053, -6.955852379, 0.8377, -6.661145254, 0.8667, -6.355462942, 0.8809, -6.118102026, 0.7975, -7.115148017, 0.8162, -6.815308569, 0.8515, -6.519993057, 0.8766, -6.204119983, 0.8885, -5.853871964, 0.8859, -6.109523091, 0.8959, -5.79832982, 0.8913, -5.482672118, 0.8959, -5.171791386, 0.8971, -4.851705903, 0.9021, -4.517126416, 0.909, -4.143573228, 0.9139, -3.709075441, 0.9199, -3.499489089, 0.8692, -6.300769497, 0.8872, -5.953504836, 0.89, -5.642065153, 0.891, -5.031376979, 0.8977, -4.680685696, 0.9035, -4.329846955, 0.9078, -3.928486195, 0.7675, -8.56735134, 0.7705, -8.363211311, 0.7713, -8.107682739, 0.7736, -7.823908741, 0.7775, -7.522878745, 0.7841, -7.218819279, 0.7971, -6.920818754, 0.8329, -6.628932138, 0.8641, -6.323946875, 0.8804, -5.991399828, 0.7668, -8.781464495, 0.7633, -8.663140179, 0.7678, -8.473531488, 0.7697, -8.247337057, 0.77, -7.971428747, 0.7749, -7.676129393, 0.7796, -7.352812702, 0.7897, -7.072065318, 0.8131, -6.774174009, 0.8498, -6.478861916, 0.8741, -6.159517513, 0.8061, -6.835647144, 0.846, -6.53165267, 0.8751, -6.224098421, 0.8856, -5.910094889, 0.8919, -5.598599459, 0.8934, -5.290645224, 0.894, -4.974284616, 0.8957, -4.64454848, 0.9047, -4.290560426, 0.9129, -3.885055584, 0.9209, -3.408378962, 0.9219, -3.13200249, 0.7739, -8.726767166, 0.7681, -8.66695597, 0.7665, -8.511026475, 0.7703, -8.165388579, 0.7702, -7.886056648, 0.7761, -7.588043762, 0.7809, -7.283412422, 0.7961, -6.995678626, 0.8253, -6.691862621, 0.8602, -6.392544977, 0.8809, -6.067374056, 0.8301, -6.684029655, 0.8664, -6.378719832, 0.8834, -6.065855188, 0.8898, -5.752272167, 0.8964, -5.132414673, 0.8963, -4.811352704, 0.9074, -4.098269308, 0.9119, -3.66174277, 0.9228, -3.2644011 }; [EOL]     MillerUpdatingRegression model = new MillerUpdatingRegression(10, true); [EOL]     int off = 0; [EOL]     double[] tmp = new double[10]; [EOL]     int nobs = 82; [EOL]     for (int i = 0; i < nobs; i++) { [EOL]         tmp[0] = data[off + 1]; [EOL]         tmp[1] = tmp[0] * tmp[0]; [EOL]         tmp[2] = tmp[0] * tmp[1]; [EOL]         tmp[3] = tmp[0] * tmp[2]; [EOL]         tmp[4] = tmp[0] * tmp[3]; [EOL]         tmp[5] = tmp[0] * tmp[4]; [EOL]         tmp[6] = tmp[0] * tmp[5]; [EOL]         tmp[7] = tmp[0] * tmp[6]; [EOL]         tmp[8] = tmp[0] * tmp[7]; [EOL]         tmp[9] = tmp[0] * tmp[8]; [EOL]         model.addObservation(tmp, data[off]); [EOL]         off += 2; [EOL]     } [EOL]     RegressionResults result = model.regress(); [EOL]     double[] betaHat = result.getParameterEstimates(); [EOL]     TestUtils.assertEquals(betaHat, new double[] { -1467.48961422980, -2772.17959193342, -2316.37108160893, -1127.97394098372, -354.478233703349, -75.1242017393757, -10.8753180355343, -1.06221498588947, -0.670191154593408E-01, -0.246781078275479E-02, -0.402962525080404E-04 }, 1E-5); [EOL]     double[] se = result.getStdErrorOfEstimates(); [EOL]     TestUtils.assertEquals(se, new double[] { 298.084530995537, 559.779865474950, 466.477572127796, 227.204274477751, 71.6478660875927, 15.2897178747400, 2.23691159816033, 0.221624321934227, 0.142363763154724E-01, 0.535617408889821E-03, 0.896632837373868E-05 }, 1E-5); [EOL]     TestUtils.assertEquals(0.996727416185620, result.getRSquared(), 1.0e-8); [EOL]     TestUtils.assertEquals(0.112091743968020E-04, result.getMeanSquareError(), 1.0e-10); [EOL]     TestUtils.assertEquals(0.795851382172941E-03, result.getErrorSumSquares(), 1.0e-10); [EOL] } <line_num>: 230,380
@Test [EOL] public void testWampler1() { [EOL]     double[] data = new double[] { 1, 0, 6, 1, 63, 2, 364, 3, 1365, 4, 3906, 5, 9331, 6, 19608, 7, 37449, 8, 66430, 9, 111111, 10, 177156, 11, 271453, 12, 402234, 13, 579195, 14, 813616, 15, 1118481, 16, 1508598, 17, 2000719, 18, 2613660, 19, 3368421, 20 }; [EOL]     MillerUpdatingRegression model = new MillerUpdatingRegression(5, true); [EOL]     int off = 0; [EOL]     double[] tmp = new double[5]; [EOL]     int nobs = 21; [EOL]     for (int i = 0; i < nobs; i++) { [EOL]         tmp[0] = data[off + 1]; [EOL]         tmp[1] = tmp[0] * tmp[0]; [EOL]         tmp[2] = tmp[0] * tmp[1]; [EOL]         tmp[3] = tmp[0] * tmp[2]; [EOL]         tmp[4] = tmp[0] * tmp[3]; [EOL]         model.addObservation(tmp, data[off]); [EOL]         off += 2; [EOL]     } [EOL]     RegressionResults result = model.regress(); [EOL]     double[] betaHat = result.getParameterEstimates(); [EOL]     TestUtils.assertEquals(betaHat, new double[] { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 }, 1E-8); [EOL]     double[] se = result.getStdErrorOfEstimates(); [EOL]     TestUtils.assertEquals(se, new double[] { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 }, 1E-8); [EOL]     TestUtils.assertEquals(1.0, result.getRSquared(), 1.0e-10); [EOL]     TestUtils.assertEquals(0, result.getMeanSquareError(), 1.0e-7); [EOL]     TestUtils.assertEquals(0.00, result.getErrorSumSquares(), 1.0e-6); [EOL]     return; [EOL] } <line_num>: 382,440
@Test [EOL] public void testWampler2() { [EOL]     double[] data = new double[] { 1.00000, 0, 1.11111, 1, 1.24992, 2, 1.42753, 3, 1.65984, 4, 1.96875, 5, 2.38336, 6, 2.94117, 7, 3.68928, 8, 4.68559, 9, 6.00000, 10, 7.71561, 11, 9.92992, 12, 12.75603, 13, 16.32384, 14, 20.78125, 15, 26.29536, 16, 33.05367, 17, 41.26528, 18, 51.16209, 19, 63.00000, 20 }; [EOL]     MillerUpdatingRegression model = new MillerUpdatingRegression(5, true); [EOL]     int off = 0; [EOL]     double[] tmp = new double[5]; [EOL]     int nobs = 21; [EOL]     for (int i = 0; i < nobs; i++) { [EOL]         tmp[0] = data[off + 1]; [EOL]         tmp[1] = tmp[0] * tmp[0]; [EOL]         tmp[2] = tmp[0] * tmp[1]; [EOL]         tmp[3] = tmp[0] * tmp[2]; [EOL]         tmp[4] = tmp[0] * tmp[3]; [EOL]         model.addObservation(tmp, data[off]); [EOL]         off += 2; [EOL]     } [EOL]     RegressionResults result = model.regress(); [EOL]     double[] betaHat = result.getParameterEstimates(); [EOL]     TestUtils.assertEquals(betaHat, new double[] { 1.0, 1.0e-1, 1.0e-2, 1.0e-3, 1.0e-4, 1.0e-5 }, 1E-8); [EOL]     double[] se = result.getStdErrorOfEstimates(); [EOL]     TestUtils.assertEquals(se, new double[] { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 }, 1E-8); [EOL]     TestUtils.assertEquals(1.0, result.getRSquared(), 1.0e-10); [EOL]     TestUtils.assertEquals(0, result.getMeanSquareError(), 1.0e-7); [EOL]     TestUtils.assertEquals(0.00, result.getErrorSumSquares(), 1.0e-6); [EOL]     return; [EOL] } <line_num>: 442,499
@Test [EOL] public void testWampler3() { [EOL]     double[] data = new double[] { 760, 0, -2042, 1, 2111, 2, -1684, 3, 3888, 4, 1858, 5, 11379, 6, 17560, 7, 39287, 8, 64382, 9, 113159, 10, 175108, 11, 273291, 12, 400186, 13, 581243, 14, 811568, 15, 1121004, 16, 1506550, 17, 2002767, 18, 2611612, 19, 3369180, 20 }; [EOL]     MillerUpdatingRegression model = new MillerUpdatingRegression(5, true); [EOL]     int off = 0; [EOL]     double[] tmp = new double[5]; [EOL]     int nobs = 21; [EOL]     for (int i = 0; i < nobs; i++) { [EOL]         tmp[0] = data[off + 1]; [EOL]         tmp[1] = tmp[0] * tmp[0]; [EOL]         tmp[2] = tmp[0] * tmp[1]; [EOL]         tmp[3] = tmp[0] * tmp[2]; [EOL]         tmp[4] = tmp[0] * tmp[3]; [EOL]         model.addObservation(tmp, data[off]); [EOL]         off += 2; [EOL]     } [EOL]     RegressionResults result = model.regress(); [EOL]     double[] betaHat = result.getParameterEstimates(); [EOL]     TestUtils.assertEquals(betaHat, new double[] { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 }, 1E-8); [EOL]     double[] se = result.getStdErrorOfEstimates(); [EOL]     TestUtils.assertEquals(se, new double[] { 2152.32624678170, 2363.55173469681, 779.343524331583, 101.475507550350, 5.64566512170752, 0.112324854679312 }, 1E-8); [EOL]     TestUtils.assertEquals(.999995559025820, result.getRSquared(), 1.0e-10); [EOL]     TestUtils.assertEquals(5570284.53333333, result.getMeanSquareError(), 1.0e-7); [EOL]     TestUtils.assertEquals(83554268.0000000, result.getErrorSumSquares(), 1.0e-6); [EOL]     return; [EOL] } <line_num>: 501,556
public void testWampler4() { [EOL]     double[] data = new double[] { 75901, 0, -204794, 1, 204863, 2, -204436, 3, 253665, 4, -200894, 5, 214131, 6, -185192, 7, 221249, 8, -138370, 9, 315911, 10, -27644, 11, 455253, 12, 197434, 13, 783995, 14, 608816, 15, 1370781, 16, 1303798, 17, 2205519, 18, 2408860, 19, 3444321, 20 }; [EOL]     MillerUpdatingRegression model = new MillerUpdatingRegression(5, true); [EOL]     int off = 0; [EOL]     double[] tmp = new double[5]; [EOL]     int nobs = 21; [EOL]     for (int i = 0; i < nobs; i++) { [EOL]         tmp[0] = data[off + 1]; [EOL]         tmp[1] = tmp[0] * tmp[0]; [EOL]         tmp[2] = tmp[0] * tmp[1]; [EOL]         tmp[3] = tmp[0] * tmp[2]; [EOL]         tmp[4] = tmp[0] * tmp[3]; [EOL]         model.addObservation(tmp, data[off]); [EOL]         off += 2; [EOL]     } [EOL]     RegressionResults result = model.regress(); [EOL]     double[] betaHat = result.getParameterEstimates(); [EOL]     TestUtils.assertEquals(betaHat, new double[] { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 }, 1E-8); [EOL]     double[] se = result.getStdErrorOfEstimates(); [EOL]     TestUtils.assertEquals(se, new double[] { 215232.624678170, 236355.173469681, 77934.3524331583, 10147.5507550350, 564.566512170752, 11.2324854679312 }, 1E-8); [EOL]     TestUtils.assertEquals(.957478440825662, result.getRSquared(), 1.0e-10); [EOL]     TestUtils.assertEquals(55702845333.3333, result.getMeanSquareError(), 1.0e-4); [EOL]     TestUtils.assertEquals(835542680000.000, result.getErrorSumSquares(), 1.0e-3); [EOL]     return; [EOL] } <line_num>: 559,615
@Test [EOL] public void testLongly() { [EOL]     double[] design = new double[] { 60323, 83.0, 234289, 2356, 1590, 107608, 1947, 61122, 88.5, 259426, 2325, 1456, 108632, 1948, 60171, 88.2, 258054, 3682, 1616, 109773, 1949, 61187, 89.5, 284599, 3351, 1650, 110929, 1950, 63221, 96.2, 328975, 2099, 3099, 112075, 1951, 63639, 98.1, 346999, 1932, 3594, 113270, 1952, 64989, 99.0, 365385, 1870, 3547, 115094, 1953, 63761, 100.0, 363112, 3578, 3350, 116219, 1954, 66019, 101.2, 397469, 2904, 3048, 117388, 1955, 67857, 104.6, 419180, 2822, 2857, 118734, 1956, 68169, 108.4, 442769, 2936, 2798, 120445, 1957, 66513, 110.8, 444546, 4681, 2637, 121950, 1958, 68655, 112.6, 482704, 3813, 2552, 123366, 1959, 69564, 114.2, 502601, 3931, 2514, 125368, 1960, 69331, 115.7, 518173, 4806, 2572, 127852, 1961, 70551, 116.9, 554894, 4007, 2827, 130081, 1962 }; [EOL]     final int nobs = 16; [EOL]     final int nvars = 6; [EOL]     MillerUpdatingRegression model = new MillerUpdatingRegression(6, true); [EOL]     int off = 0; [EOL]     double[] tmp = new double[6]; [EOL]     for (int i = 0; i < nobs; i++) { [EOL]         System.arraycopy(design, off + 1, tmp, 0, nvars); [EOL]         model.addObservation(tmp, design[off]); [EOL]         off += nvars + 1; [EOL]     } [EOL]     RegressionResults result = model.regress(); [EOL]     double[] betaHat = result.getParameterEstimates(); [EOL]     TestUtils.assertEquals(betaHat, new double[] { -3482258.63459582, 15.0618722713733, -0.358191792925910E-01, -2.02022980381683, -1.03322686717359, -0.511041056535807E-01, 1829.15146461355 }, 1E-8); [EOL]     double[] errors = result.getStdErrorOfEstimates(); [EOL]     TestUtils.assertEquals(new double[] { 890420.383607373, 84.9149257747669, 0.334910077722432E-01, 0.488399681651699, 0.214274163161675, 0.226073200069370, 455.478499142212 }, errors, 1E-6); [EOL]     TestUtils.assertEquals(0.995479004577296, result.getRSquared(), 1E-12); [EOL]     TestUtils.assertEquals(0.992465007628826, result.getAdjustedRSquared(), 1E-12); [EOL]     model = new MillerUpdatingRegression(6, false); [EOL]     off = 0; [EOL]     for (int i = 0; i < nobs; i++) { [EOL]         System.arraycopy(design, off + 1, tmp, 0, nvars); [EOL]         model.addObservation(tmp, design[off]); [EOL]         off += nvars + 1; [EOL]     } [EOL]     result = model.regress(); [EOL]     betaHat = result.getParameterEstimates(); [EOL]     TestUtils.assertEquals(betaHat, new double[] { -52.99357013868291, 0.07107319907358, -0.42346585566399, -0.57256866841929, -0.41420358884978, 48.41786562001326 }, 1E-11); [EOL]     errors = result.getStdErrorOfEstimates(); [EOL]     TestUtils.assertEquals(new double[] { 129.54486693117232, 0.03016640003786, 0.41773654056612, 0.27899087467676, 0.32128496193363, 17.68948737819961 }, errors, 1E-11); [EOL]     TestUtils.assertEquals(0.9999670130706, result.getRSquared(), 1E-12); [EOL]     TestUtils.assertEquals(0.999947220913, result.getAdjustedRSquared(), 1E-12); [EOL] } <line_num>: 627,714
@Test [EOL] public void testOneRedundantColumn() { [EOL]     MillerUpdatingRegression instance = new MillerUpdatingRegression(4, false); [EOL]     MillerUpdatingRegression instance2 = new MillerUpdatingRegression(5, false); [EOL]     double[][] x = new double[airdata[0].length][]; [EOL]     double[][] x2 = new double[airdata[0].length][]; [EOL]     double[] y = new double[airdata[0].length]; [EOL]     for (int i = 0; i < airdata[0].length; i++) { [EOL]         x[i] = new double[4]; [EOL]         x2[i] = new double[5]; [EOL]         x[i][0] = 1.0; [EOL]         x[i][1] = Math.log(airdata[3][i]); [EOL]         x[i][2] = Math.log(airdata[4][i]); [EOL]         x[i][3] = airdata[5][i]; [EOL]         x2[i][0] = x[i][0]; [EOL]         x2[i][1] = x[i][1]; [EOL]         x2[i][2] = x[i][2]; [EOL]         x2[i][3] = x[i][3]; [EOL]         x2[i][4] = x[i][3]; [EOL]         y[i] = Math.log(airdata[2][i]); [EOL]     } [EOL]     instance.addObservations(x, y); [EOL]     RegressionResults result = instance.regress(); [EOL]     Assert.assertNotNull("Could not estimate initial regression", result); [EOL]     instance2.addObservations(x2, y); [EOL]     RegressionResults resultRedundant = instance2.regress(); [EOL]     Assert.assertNotNull("Could not estimate redundant regression", resultRedundant); [EOL]     double[] beta = result.getParameterEstimates(); [EOL]     double[] betar = resultRedundant.getParameterEstimates(); [EOL]     double[] se = result.getStdErrorOfEstimates(); [EOL]     double[] ser = resultRedundant.getStdErrorOfEstimates(); [EOL]     for (int i = 0; i < beta.length; i++) { [EOL]         if (Math.abs(beta[i] - betar[i]) > 1.0e-8) { [EOL]             Assert.fail("Parameters not correctly estimated"); [EOL]         } [EOL]         if (Math.abs(se[i] - ser[i]) > 1.0e-8) { [EOL]             Assert.fail("Standard errors not correctly estimated"); [EOL]         } [EOL]         for (int j = 0; j < i; j++) { [EOL]             if (Math.abs(result.getCovarianceOfParameters(i, j) - resultRedundant.getCovarianceOfParameters(i, j)) > 1.0e-8) { [EOL]                 Assert.fail("Variance Covariance not correct"); [EOL]             } [EOL]         } [EOL]     } [EOL]     TestUtils.assertEquals(result.getAdjustedRSquared(), resultRedundant.getAdjustedRSquared(), 1.0e-8); [EOL]     TestUtils.assertEquals(result.getErrorSumSquares(), resultRedundant.getErrorSumSquares(), 1.0e-8); [EOL]     TestUtils.assertEquals(result.getMeanSquareError(), resultRedundant.getMeanSquareError(), 1.0e-8); [EOL]     TestUtils.assertEquals(result.getRSquared(), resultRedundant.getRSquared(), 1.0e-8); [EOL]     return; [EOL] } <line_num>: 756,813
@Test [EOL] public void testThreeRedundantColumn() { [EOL]     MillerUpdatingRegression instance = new MillerUpdatingRegression(4, false); [EOL]     MillerUpdatingRegression instance2 = new MillerUpdatingRegression(7, false); [EOL]     double[][] x = new double[airdata[0].length][]; [EOL]     double[][] x2 = new double[airdata[0].length][]; [EOL]     double[] y = new double[airdata[0].length]; [EOL]     for (int i = 0; i < airdata[0].length; i++) { [EOL]         x[i] = new double[4]; [EOL]         x2[i] = new double[7]; [EOL]         x[i][0] = 1.0; [EOL]         x[i][1] = Math.log(airdata[3][i]); [EOL]         x[i][2] = Math.log(airdata[4][i]); [EOL]         x[i][3] = airdata[5][i]; [EOL]         x2[i][0] = x[i][0]; [EOL]         x2[i][1] = x[i][0]; [EOL]         x2[i][2] = x[i][1]; [EOL]         x2[i][3] = x[i][2]; [EOL]         x2[i][4] = x[i][1]; [EOL]         x2[i][5] = x[i][3]; [EOL]         x2[i][6] = x[i][2]; [EOL]         y[i] = Math.log(airdata[2][i]); [EOL]     } [EOL]     instance.addObservations(x, y); [EOL]     RegressionResults result = instance.regress(); [EOL]     Assert.assertNotNull("Could not estimate initial regression", result); [EOL]     instance2.addObservations(x2, y); [EOL]     RegressionResults resultRedundant = instance2.regress(); [EOL]     Assert.assertNotNull("Could not estimate redundant regression", resultRedundant); [EOL]     double[] beta = result.getParameterEstimates(); [EOL]     double[] betar = resultRedundant.getParameterEstimates(); [EOL]     double[] se = result.getStdErrorOfEstimates(); [EOL]     double[] ser = resultRedundant.getStdErrorOfEstimates(); [EOL]     if (Math.abs(beta[0] - betar[0]) > 1.0e-8) { [EOL]         Assert.fail("Parameters not correct after reorder (0,3)"); [EOL]     } [EOL]     if (Math.abs(beta[1] - betar[2]) > 1.0e-8) { [EOL]         Assert.fail("Parameters not correct after reorder (1,2)"); [EOL]     } [EOL]     if (Math.abs(beta[2] - betar[3]) > 1.0e-8) { [EOL]         Assert.fail("Parameters not correct after reorder (2,1)"); [EOL]     } [EOL]     if (Math.abs(beta[3] - betar[5]) > 1.0e-8) { [EOL]         Assert.fail("Parameters not correct after reorder (3,0)"); [EOL]     } [EOL]     if (Math.abs(se[0] - ser[0]) > 1.0e-8) { [EOL]         Assert.fail("Se not correct after reorder (0,3)"); [EOL]     } [EOL]     if (Math.abs(se[1] - ser[2]) > 1.0e-8) { [EOL]         Assert.fail("Se not correct after reorder (1,2)"); [EOL]     } [EOL]     if (Math.abs(se[2] - ser[3]) > 1.0e-8) { [EOL]         Assert.fail("Se not correct after reorder (2,1)"); [EOL]     } [EOL]     if (Math.abs(se[3] - ser[5]) > 1.0e-8) { [EOL]         Assert.fail("Se not correct after reorder (3,0)"); [EOL]     } [EOL]     if (Math.abs(result.getCovarianceOfParameters(0, 0) - resultRedundant.getCovarianceOfParameters(0, 0)) > 1.0e-8) { [EOL]         Assert.fail("VCV not correct after reorder (0,0)"); [EOL]     } [EOL]     if (Math.abs(result.getCovarianceOfParameters(0, 1) - resultRedundant.getCovarianceOfParameters(0, 2)) > 1.0e-8) { [EOL]         Assert.fail("VCV not correct after reorder (0,1)<->(0,2)"); [EOL]     } [EOL]     if (Math.abs(result.getCovarianceOfParameters(0, 2) - resultRedundant.getCovarianceOfParameters(0, 3)) > 1.0e-8) { [EOL]         Assert.fail("VCV not correct after reorder (0,2)<->(0,1)"); [EOL]     } [EOL]     if (Math.abs(result.getCovarianceOfParameters(0, 3) - resultRedundant.getCovarianceOfParameters(0, 5)) > 1.0e-8) { [EOL]         Assert.fail("VCV not correct after reorder (0,3)<->(0,3)"); [EOL]     } [EOL]     if (Math.abs(result.getCovarianceOfParameters(1, 0) - resultRedundant.getCovarianceOfParameters(2, 0)) > 1.0e-8) { [EOL]         Assert.fail("VCV not correct after reorder (1,0)<->(2,0)"); [EOL]     } [EOL]     if (Math.abs(result.getCovarianceOfParameters(1, 1) - resultRedundant.getCovarianceOfParameters(2, 2)) > 1.0e-8) { [EOL]         Assert.fail("VCV not correct  (1,1)<->(2,1)"); [EOL]     } [EOL]     if (Math.abs(result.getCovarianceOfParameters(1, 2) - resultRedundant.getCovarianceOfParameters(2, 3)) > 1.0e-8) { [EOL]         Assert.fail("VCV not correct  (1,2)<->(2,2)"); [EOL]     } [EOL]     if (Math.abs(result.getCovarianceOfParameters(2, 0) - resultRedundant.getCovarianceOfParameters(3, 0)) > 1.0e-8) { [EOL]         Assert.fail("VCV not correct  (2,0)<->(1,0)"); [EOL]     } [EOL]     if (Math.abs(result.getCovarianceOfParameters(2, 1) - resultRedundant.getCovarianceOfParameters(3, 2)) > 1.0e-8) { [EOL]         Assert.fail("VCV not correct  (2,1)<->(1,2)"); [EOL]     } [EOL]     if (Math.abs(result.getCovarianceOfParameters(3, 3) - resultRedundant.getCovarianceOfParameters(5, 5)) > 1.0e-8) { [EOL]         Assert.fail("VCV not correct  (3,3)<->(3,2)"); [EOL]     } [EOL]     TestUtils.assertEquals(result.getAdjustedRSquared(), resultRedundant.getAdjustedRSquared(), 1.0e-8); [EOL]     TestUtils.assertEquals(result.getErrorSumSquares(), resultRedundant.getErrorSumSquares(), 1.0e-8); [EOL]     TestUtils.assertEquals(result.getMeanSquareError(), resultRedundant.getMeanSquareError(), 1.0e-8); [EOL]     TestUtils.assertEquals(result.getRSquared(), resultRedundant.getRSquared(), 1.0e-8); [EOL]     return; [EOL] } <line_num>: 815,928
@Test [EOL] public void testPCorr() { [EOL]     MillerUpdatingRegression instance = new MillerUpdatingRegression(4, false); [EOL]     double[][] x = new double[airdata[0].length][]; [EOL]     double[] y = new double[airdata[0].length]; [EOL]     double[] cp = new double[10]; [EOL]     double[] yxcorr = new double[4]; [EOL]     double[] diag = new double[4]; [EOL]     double sumysq = 0.0; [EOL]     int off = 0; [EOL]     for (int i = 0; i < airdata[0].length; i++) { [EOL]         x[i] = new double[4]; [EOL]         x[i][0] = 1.0; [EOL]         x[i][1] = Math.log(airdata[3][i]); [EOL]         x[i][2] = Math.log(airdata[4][i]); [EOL]         x[i][3] = airdata[5][i]; [EOL]         y[i] = Math.log(airdata[2][i]); [EOL]         off = 0; [EOL]         for (int j = 0; j < 4; j++) { [EOL]             double tmp = x[i][j]; [EOL]             for (int k = 0; k <= j; k++, off++) { [EOL]                 cp[off] += tmp * x[i][k]; [EOL]             } [EOL]             yxcorr[j] += tmp * y[i]; [EOL]         } [EOL]         sumysq += y[i] * y[i]; [EOL]     } [EOL]     PearsonsCorrelation pearson = new PearsonsCorrelation(x); [EOL]     RealMatrix corr = pearson.getCorrelationMatrix(); [EOL]     off = 0; [EOL]     for (int i = 0; i < 4; i++, off += (i + 1)) { [EOL]         diag[i] = FastMath.sqrt(cp[off]); [EOL]     } [EOL]     instance.addObservations(x, y); [EOL]     double[] pc = instance.getPartialCorrelations(0); [EOL]     int idx = 0; [EOL]     off = 0; [EOL]     int off2 = 6; [EOL]     for (int i = 0; i < 4; i++) { [EOL]         for (int j = 0; j < i; j++) { [EOL]             if (Math.abs(pc[idx] - cp[off] / (diag[i] * diag[j])) > 1.0e-8) { [EOL]                 Assert.fail("Failed cross products... i = " + i + " j = " + j); [EOL]             } [EOL]             ++idx; [EOL]             ++off; [EOL]         } [EOL]         ++off; [EOL]         if (Math.abs(pc[i + off2] - yxcorr[i] / (FastMath.sqrt(sumysq) * diag[i])) > 1.0e-8) { [EOL]             Assert.fail("Assert.failed cross product i = " + i + " y"); [EOL]         } [EOL]     } [EOL]     double[] pc2 = instance.getPartialCorrelations(1); [EOL]     idx = 0; [EOL]     for (int i = 1; i < 4; i++) { [EOL]         for (int j = 1; j < i; j++) { [EOL]             if (Math.abs(pc2[idx] - corr.getEntry(j, i)) > 1.0e-8) { [EOL]                 Assert.fail("Failed cross products... i = " + i + " j = " + j); [EOL]             } [EOL]             ++idx; [EOL]         } [EOL]     } [EOL]     double[] pc3 = instance.getPartialCorrelations(2); [EOL]     if (pc3 == null) { [EOL]         Assert.fail("Should not be null"); [EOL]     } [EOL]     return; [EOL] } <line_num>: 930,999
@Test [EOL] public void testHdiag() { [EOL]     MillerUpdatingRegression instance = new MillerUpdatingRegression(4, false); [EOL]     double[][] x = new double[airdata[0].length][]; [EOL]     double[] y = new double[airdata[0].length]; [EOL]     for (int i = 0; i < airdata[0].length; i++) { [EOL]         x[i] = new double[4]; [EOL]         x[i][0] = 1.0; [EOL]         x[i][1] = Math.log(airdata[3][i]); [EOL]         x[i][2] = Math.log(airdata[4][i]); [EOL]         x[i][3] = airdata[5][i]; [EOL]         y[i] = Math.log(airdata[2][i]); [EOL]     } [EOL]     instance.addObservations(x, y); [EOL]     OLSMultipleLinearRegression ols = new OLSMultipleLinearRegression(); [EOL]     ols.setNoIntercept(true); [EOL]     ols.newSampleData(y, x); [EOL]     RealMatrix rm = ols.calculateHat(); [EOL]     for (int i = 0; i < x.length; i++) { [EOL]         TestUtils.assertEquals(instance.getDiagonalOfHatMatrix(x[i]), rm.getEntry(i, i), 1.0e-8); [EOL]     } [EOL]     return; [EOL] } <line_num>: 1001,1024
@Test [EOL] public void testHdiagConstant() { [EOL]     MillerUpdatingRegression instance = new MillerUpdatingRegression(3, true); [EOL]     double[][] x = new double[airdata[0].length][]; [EOL]     double[] y = new double[airdata[0].length]; [EOL]     for (int i = 0; i < airdata[0].length; i++) { [EOL]         x[i] = new double[3]; [EOL]         x[i][0] = Math.log(airdata[3][i]); [EOL]         x[i][1] = Math.log(airdata[4][i]); [EOL]         x[i][2] = airdata[5][i]; [EOL]         y[i] = Math.log(airdata[2][i]); [EOL]     } [EOL]     instance.addObservations(x, y); [EOL]     OLSMultipleLinearRegression ols = new OLSMultipleLinearRegression(); [EOL]     ols.setNoIntercept(false); [EOL]     ols.newSampleData(y, x); [EOL]     RealMatrix rm = ols.calculateHat(); [EOL]     for (int i = 0; i < x.length; i++) { [EOL]         TestUtils.assertEquals(instance.getDiagonalOfHatMatrix(x[i]), rm.getEntry(i, i), 1.0e-8); [EOL]     } [EOL]     return; [EOL] } <line_num>: 1025,1047
@Test [EOL] public void testSubsetRegression() { [EOL]     MillerUpdatingRegression instance = new MillerUpdatingRegression(3, true); [EOL]     MillerUpdatingRegression redRegression = new MillerUpdatingRegression(2, true); [EOL]     double[][] x = new double[airdata[0].length][]; [EOL]     double[][] xReduced = new double[airdata[0].length][]; [EOL]     double[] y = new double[airdata[0].length]; [EOL]     for (int i = 0; i < airdata[0].length; i++) { [EOL]         x[i] = new double[3]; [EOL]         x[i][0] = Math.log(airdata[3][i]); [EOL]         x[i][1] = Math.log(airdata[4][i]); [EOL]         x[i][2] = airdata[5][i]; [EOL]         xReduced[i] = new double[2]; [EOL]         xReduced[i][0] = Math.log(airdata[3][i]); [EOL]         xReduced[i][1] = Math.log(airdata[4][i]); [EOL]         y[i] = Math.log(airdata[2][i]); [EOL]     } [EOL]     instance.addObservations(x, y); [EOL]     redRegression.addObservations(xReduced, y); [EOL]     RegressionResults resultsInstance = instance.regress(new int[] { 0, 1, 2 }); [EOL]     RegressionResults resultsReduced = redRegression.regress(); [EOL]     TestUtils.assertEquals(resultsInstance.getParameterEstimates(), resultsReduced.getParameterEstimates(), 1.0e-12); [EOL]     TestUtils.assertEquals(resultsInstance.getStdErrorOfEstimates(), resultsReduced.getStdErrorOfEstimates(), 1.0e-12); [EOL] } <line_num>: 1050,1079
