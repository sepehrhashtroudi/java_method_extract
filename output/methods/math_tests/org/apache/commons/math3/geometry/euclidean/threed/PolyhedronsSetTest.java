@Test [EOL] public void testBox() { [EOL]     PolyhedronsSet tree = new PolyhedronsSet(0, 1, 0, 1, 0, 1); [EOL]     Assert.assertEquals(1.0, tree.getSize(), 1.0e-10); [EOL]     Assert.assertEquals(6.0, tree.getBoundarySize(), 1.0e-10); [EOL]     Vector3D barycenter = (Vector3D) tree.getBarycenter(); [EOL]     Assert.assertEquals(0.5, barycenter.getX(), 1.0e-10); [EOL]     Assert.assertEquals(0.5, barycenter.getY(), 1.0e-10); [EOL]     Assert.assertEquals(0.5, barycenter.getZ(), 1.0e-10); [EOL]     for (double x = -0.25; x < 1.25; x += 0.1) { [EOL]         boolean xOK = (x >= 0.0) && (x <= 1.0); [EOL]         for (double y = -0.25; y < 1.25; y += 0.1) { [EOL]             boolean yOK = (y >= 0.0) && (y <= 1.0); [EOL]             for (double z = -0.25; z < 1.25; z += 0.1) { [EOL]                 boolean zOK = (z >= 0.0) && (z <= 1.0); [EOL]                 Region.Location expected = (xOK && yOK && zOK) ? Region.Location.INSIDE : Region.Location.OUTSIDE; [EOL]                 Assert.assertEquals(expected, tree.checkPoint(new Vector3D(x, y, z))); [EOL]             } [EOL]         } [EOL]     } [EOL]     checkPoints(Region.Location.BOUNDARY, tree, new Vector3D[] { new Vector3D(0.0, 0.5, 0.5), new Vector3D(1.0, 0.5, 0.5), new Vector3D(0.5, 0.0, 0.5), new Vector3D(0.5, 1.0, 0.5), new Vector3D(0.5, 0.5, 0.0), new Vector3D(0.5, 0.5, 1.0) }); [EOL]     checkPoints(Region.Location.OUTSIDE, tree, new Vector3D[] { new Vector3D(0.0, 1.2, 1.2), new Vector3D(1.0, 1.2, 1.2), new Vector3D(1.2, 0.0, 1.2), new Vector3D(1.2, 1.0, 1.2), new Vector3D(1.2, 1.2, 0.0), new Vector3D(1.2, 1.2, 1.0) }); [EOL] } <line_num>: 39,76
@Test [EOL] public void testTetrahedron() throws MathArithmeticException { [EOL]     Vector3D vertex1 = new Vector3D(1, 2, 3); [EOL]     Vector3D vertex2 = new Vector3D(2, 2, 4); [EOL]     Vector3D vertex3 = new Vector3D(2, 3, 3); [EOL]     Vector3D vertex4 = new Vector3D(1, 3, 4); [EOL]     @SuppressWarnings("unchecked") [EOL]     PolyhedronsSet tree = (PolyhedronsSet) new RegionFactory<Euclidean3D>().buildConvex(new Plane(vertex3, vertex2, vertex1), new Plane(vertex2, vertex3, vertex4), new Plane(vertex4, vertex3, vertex1), new Plane(vertex1, vertex2, vertex4)); [EOL]     Assert.assertEquals(1.0 / 3.0, tree.getSize(), 1.0e-10); [EOL]     Assert.assertEquals(2.0 * FastMath.sqrt(3.0), tree.getBoundarySize(), 1.0e-10); [EOL]     Vector3D barycenter = (Vector3D) tree.getBarycenter(); [EOL]     Assert.assertEquals(1.5, barycenter.getX(), 1.0e-10); [EOL]     Assert.assertEquals(2.5, barycenter.getY(), 1.0e-10); [EOL]     Assert.assertEquals(3.5, barycenter.getZ(), 1.0e-10); [EOL]     double third = 1.0 / 3.0; [EOL]     checkPoints(Region.Location.BOUNDARY, tree, new Vector3D[] { vertex1, vertex2, vertex3, vertex4, new Vector3D(third, vertex1, third, vertex2, third, vertex3), new Vector3D(third, vertex2, third, vertex3, third, vertex4), new Vector3D(third, vertex3, third, vertex4, third, vertex1), new Vector3D(third, vertex4, third, vertex1, third, vertex2) }); [EOL]     checkPoints(Region.Location.OUTSIDE, tree, new Vector3D[] { new Vector3D(1, 2, 4), new Vector3D(2, 2, 3), new Vector3D(2, 3, 4), new Vector3D(1, 3, 3) }); [EOL] } <line_num>: 78,111
public Order visitOrder(BSPTree<Euclidean3D> node) { [EOL]     return Order.MINUS_SUB_PLUS; [EOL] } <line_num>: 157,159
public void visitInternalNode(BSPTree<Euclidean3D> node) { [EOL]     @SuppressWarnings("unchecked") [EOL]     BoundaryAttribute<Euclidean3D> attribute = (BoundaryAttribute<Euclidean3D>) node.getAttribute(); [EOL]     if (attribute.getPlusOutside() != null) { [EOL]         checkFacet((SubPlane) attribute.getPlusOutside()); [EOL]     } [EOL]     if (attribute.getPlusInside() != null) { [EOL]         checkFacet((SubPlane) attribute.getPlusInside()); [EOL]     } [EOL] } <line_num>: 161,171
public void visitLeafNode(BSPTree<Euclidean3D> node) { [EOL] } <line_num>: 173,174
private void checkFacet(SubPlane facet) { [EOL]     Plane plane = (Plane) facet.getHyperplane(); [EOL]     Vector2D[][] vertices = ((PolygonsSet) facet.getRemainingRegion()).getVertices(); [EOL]     Assert.assertEquals(1, vertices.length); [EOL]     for (int i = 0; i < vertices[0].length; ++i) { [EOL]         Vector3D v = plane.toSpace(vertices[0][i]); [EOL]         double d = Double.POSITIVE_INFINITY; [EOL]         for (int k = 0; k < expectedV.length; ++k) { [EOL]             d = FastMath.min(d, v.subtract(expectedV[k]).getNorm()); [EOL]         } [EOL]         Assert.assertEquals(0, d, 1.0e-10); [EOL]     } [EOL] } <line_num>: 176,189
@Test [EOL] public void testIsometry() throws MathArithmeticException, MathIllegalArgumentException { [EOL]     Vector3D vertex1 = new Vector3D(1.1, 2.2, 3.3); [EOL]     Vector3D vertex2 = new Vector3D(2.0, 2.4, 4.2); [EOL]     Vector3D vertex3 = new Vector3D(2.8, 3.3, 3.7); [EOL]     Vector3D vertex4 = new Vector3D(1.0, 3.6, 4.5); [EOL]     @SuppressWarnings("unchecked") [EOL]     PolyhedronsSet tree = (PolyhedronsSet) new RegionFactory<Euclidean3D>().buildConvex(new Plane(vertex3, vertex2, vertex1), new Plane(vertex2, vertex3, vertex4), new Plane(vertex4, vertex3, vertex1), new Plane(vertex1, vertex2, vertex4)); [EOL]     Vector3D barycenter = (Vector3D) tree.getBarycenter(); [EOL]     Vector3D s = new Vector3D(10.2, 4.3, -6.7); [EOL]     Vector3D c = new Vector3D(-0.2, 2.1, -3.2); [EOL]     Rotation r = new Rotation(new Vector3D(6.2, -4.4, 2.1), 0.12); [EOL]     tree = tree.rotate(c, r).translate(s); [EOL]     Vector3D newB = new Vector3D(1.0, s, 1.0, c, 1.0, r.applyTo(barycenter.subtract(c))); [EOL]     Assert.assertEquals(0.0, newB.subtract(tree.getBarycenter()).getNorm(), 1.0e-10); [EOL]     final Vector3D[] expectedV = new Vector3D[] { new Vector3D(1.0, s, 1.0, c, 1.0, r.applyTo(vertex1.subtract(c))), new Vector3D(1.0, s, 1.0, c, 1.0, r.applyTo(vertex2.subtract(c))), new Vector3D(1.0, s, 1.0, c, 1.0, r.applyTo(vertex3.subtract(c))), new Vector3D(1.0, s, 1.0, c, 1.0, r.applyTo(vertex4.subtract(c))) }; [EOL]     tree.getTree(true).visit(new BSPTreeVisitor<Euclidean3D>() { [EOL]  [EOL]         public Order visitOrder(BSPTree<Euclidean3D> node) { [EOL]             return Order.MINUS_SUB_PLUS; [EOL]         } [EOL]  [EOL]         public void visitInternalNode(BSPTree<Euclidean3D> node) { [EOL]             @SuppressWarnings("unchecked") [EOL]             BoundaryAttribute<Euclidean3D> attribute = (BoundaryAttribute<Euclidean3D>) node.getAttribute(); [EOL]             if (attribute.getPlusOutside() != null) { [EOL]                 checkFacet((SubPlane) attribute.getPlusOutside()); [EOL]             } [EOL]             if (attribute.getPlusInside() != null) { [EOL]                 checkFacet((SubPlane) attribute.getPlusInside()); [EOL]             } [EOL]         } [EOL]  [EOL]         public void visitLeafNode(BSPTree<Euclidean3D> node) { [EOL]         } [EOL]  [EOL]         private void checkFacet(SubPlane facet) { [EOL]             Plane plane = (Plane) facet.getHyperplane(); [EOL]             Vector2D[][] vertices = ((PolygonsSet) facet.getRemainingRegion()).getVertices(); [EOL]             Assert.assertEquals(1, vertices.length); [EOL]             for (int i = 0; i < vertices[0].length; ++i) { [EOL]                 Vector3D v = plane.toSpace(vertices[0][i]); [EOL]                 double d = Double.POSITIVE_INFINITY; [EOL]                 for (int k = 0; k < expectedV.length; ++k) { [EOL]                     d = FastMath.min(d, v.subtract(expectedV[k]).getNorm()); [EOL]                 } [EOL]                 Assert.assertEquals(0, d, 1.0e-10); [EOL]             } [EOL]         } [EOL]     }); [EOL] } <line_num>: 113,193
@Test [EOL] public void testBuildBox() { [EOL]     double x = 1.0; [EOL]     double y = 2.0; [EOL]     double z = 3.0; [EOL]     double w = 0.1; [EOL]     double l = 1.0; [EOL]     PolyhedronsSet tree = new PolyhedronsSet(x - l, x + l, y - w, y + w, z - w, z + w); [EOL]     Vector3D barycenter = (Vector3D) tree.getBarycenter(); [EOL]     Assert.assertEquals(x, barycenter.getX(), 1.0e-10); [EOL]     Assert.assertEquals(y, barycenter.getY(), 1.0e-10); [EOL]     Assert.assertEquals(z, barycenter.getZ(), 1.0e-10); [EOL]     Assert.assertEquals(8 * l * w * w, tree.getSize(), 1.0e-10); [EOL]     Assert.assertEquals(8 * w * (2 * l + w), tree.getBoundarySize(), 1.0e-10); [EOL] } <line_num>: 195,210
@Test [EOL] public void testCross() { [EOL]     double x = 1.0; [EOL]     double y = 2.0; [EOL]     double z = 3.0; [EOL]     double w = 0.1; [EOL]     double l = 1.0; [EOL]     PolyhedronsSet xBeam = new PolyhedronsSet(x - l, x + l, y - w, y + w, z - w, z + w); [EOL]     PolyhedronsSet yBeam = new PolyhedronsSet(x - w, x + w, y - l, y + l, z - w, z + w); [EOL]     PolyhedronsSet zBeam = new PolyhedronsSet(x - w, x + w, y - w, y + w, z - l, z + l); [EOL]     RegionFactory<Euclidean3D> factory = new RegionFactory<Euclidean3D>(); [EOL]     PolyhedronsSet tree = (PolyhedronsSet) factory.union(xBeam, factory.union(yBeam, zBeam)); [EOL]     Vector3D barycenter = (Vector3D) tree.getBarycenter(); [EOL]     Assert.assertEquals(x, barycenter.getX(), 1.0e-10); [EOL]     Assert.assertEquals(y, barycenter.getY(), 1.0e-10); [EOL]     Assert.assertEquals(z, barycenter.getZ(), 1.0e-10); [EOL]     Assert.assertEquals(8 * w * w * (3 * l - 2 * w), tree.getSize(), 1.0e-10); [EOL]     Assert.assertEquals(24 * w * (2 * l - w), tree.getBoundarySize(), 1.0e-10); [EOL] } <line_num>: 212,236
@Test [EOL] public void testIssue780() throws MathArithmeticException { [EOL]     float[] coords = { 1.000000f, -1.000000f, -1.000000f, 1.000000f, -1.000000f, 1.000000f, -1.000000f, -1.000000f, 1.000000f, -1.000000f, -1.000000f, -1.000000f, 1.000000f, 1.000000f, -1f, 0.999999f, 1.000000f, 1.000000f, -1.000000f, 1.000000f, 1.000000f, -1.000000f, 1.000000f, -1.000000f }; [EOL]     int[] indices = { 0, 1, 2, 0, 2, 3, 4, 7, 6, 4, 6, 5, 0, 4, 5, 0, 5, 1, 1, 5, 6, 1, 6, 2, 2, 6, 7, 2, 7, 3, 4, 0, 3, 4, 3, 7 }; [EOL]     ArrayList<SubHyperplane<Euclidean3D>> subHyperplaneList = new ArrayList<SubHyperplane<Euclidean3D>>(); [EOL]     for (int idx = 0; idx < indices.length; idx += 3) { [EOL]         int idxA = indices[idx] * 3; [EOL]         int idxB = indices[idx + 1] * 3; [EOL]         int idxC = indices[idx + 2] * 3; [EOL]         Vector3D v_1 = new Vector3D(coords[idxA], coords[idxA + 1], coords[idxA + 2]); [EOL]         Vector3D v_2 = new Vector3D(coords[idxB], coords[idxB + 1], coords[idxB + 2]); [EOL]         Vector3D v_3 = new Vector3D(coords[idxC], coords[idxC + 1], coords[idxC + 2]); [EOL]         Vector3D[] vertices = { v_1, v_2, v_3 }; [EOL]         Plane polyPlane = new Plane(v_1, v_2, v_3); [EOL]         ArrayList<SubHyperplane<Euclidean2D>> lines = new ArrayList<SubHyperplane<Euclidean2D>>(); [EOL]         Vector2D[] projPts = new Vector2D[vertices.length]; [EOL]         for (int ptIdx = 0; ptIdx < projPts.length; ptIdx++) { [EOL]             projPts[ptIdx] = polyPlane.toSubSpace(vertices[ptIdx]); [EOL]         } [EOL]         SubLine lineInPlane = null; [EOL]         for (int ptIdx = 0; ptIdx < projPts.length; ptIdx++) { [EOL]             lineInPlane = new SubLine(projPts[ptIdx], projPts[(ptIdx + 1) % projPts.length]); [EOL]             lines.add(lineInPlane); [EOL]         } [EOL]         Region<Euclidean2D> polyRegion = new PolygonsSet(lines); [EOL]         SubPlane polygon = new SubPlane(polyPlane, polyRegion); [EOL]         subHyperplaneList.add(polygon); [EOL]     } [EOL]     PolyhedronsSet polyhedronsSet = new PolyhedronsSet(subHyperplaneList); [EOL]     Assert.assertEquals(8.0, polyhedronsSet.getSize(), 3.0e-6); [EOL]     Assert.assertEquals(24.0, polyhedronsSet.getBoundarySize(), 5.0e-6); [EOL] } <line_num>: 238,285
private void checkPoints(Region.Location expected, PolyhedronsSet tree, Vector3D[] points) { [EOL]     for (int i = 0; i < points.length; ++i) { [EOL]         Assert.assertEquals(expected, tree.checkPoint(points[i])); [EOL]     } [EOL] } <line_num>: 287,291
