@Test [EOL] public void testConstructors() throws DimensionMismatchException { [EOL]     double r = FastMath.sqrt(2) / 2; [EOL]     checkVector(new Vector3D(2, new Vector3D(FastMath.PI / 3, -FastMath.PI / 4)), r, r * FastMath.sqrt(3), -2 * r); [EOL]     checkVector(new Vector3D(2, Vector3D.PLUS_I, -3, Vector3D.MINUS_K), 2, 0, 3); [EOL]     checkVector(new Vector3D(2, Vector3D.PLUS_I, 5, Vector3D.PLUS_J, -3, Vector3D.MINUS_K), 2, 5, 3); [EOL]     checkVector(new Vector3D(2, Vector3D.PLUS_I, 5, Vector3D.PLUS_J, 5, Vector3D.MINUS_J, -3, Vector3D.MINUS_K), 2, 0, 3); [EOL]     checkVector(new Vector3D(new double[] { 2, 5, -3 }), 2, 5, -3); [EOL] } <line_num>: 36,55
@Test [EOL] public void testSpace() { [EOL]     Space space = new Vector3D(1, 2, 2).getSpace(); [EOL]     Assert.assertEquals(3, space.getDimension()); [EOL]     Assert.assertEquals(2, space.getSubSpace().getDimension()); [EOL]     Space deserialized = (Space) TestUtils.serializeAndRecover(space); [EOL]     Assert.assertTrue(space == deserialized); [EOL] } <line_num>: 57,64
@Test [EOL] public void testZero() { [EOL]     Assert.assertEquals(0, new Vector3D(1, 2, 2).getZero().getNorm(), 1.0e-15); [EOL] } <line_num>: 66,69
@Test [EOL] public void testEquals() { [EOL]     Vector3D u1 = new Vector3D(1, 2, 3); [EOL]     Vector3D u2 = new Vector3D(1, 2, 3); [EOL]     Assert.assertTrue(u1.equals(u1)); [EOL]     Assert.assertTrue(u1.equals(u2)); [EOL]     Assert.assertFalse(u1.equals(new Rotation(1, 0, 0, 0, false))); [EOL]     Assert.assertFalse(u1.equals(new Vector3D(1, 2, 3 + 10 * Precision.EPSILON))); [EOL]     Assert.assertFalse(u1.equals(new Vector3D(1, 2 + 10 * Precision.EPSILON, 3))); [EOL]     Assert.assertFalse(u1.equals(new Vector3D(1 + 10 * Precision.EPSILON, 2, 3))); [EOL]     Assert.assertTrue(new Vector3D(0, Double.NaN, 0).equals(new Vector3D(0, 0, Double.NaN))); [EOL] } <line_num>: 71,82
@Test [EOL] public void testHash() { [EOL]     Assert.assertEquals(new Vector3D(0, Double.NaN, 0).hashCode(), new Vector3D(0, 0, Double.NaN).hashCode()); [EOL]     Vector3D u = new Vector3D(1, 2, 3); [EOL]     Vector3D v = new Vector3D(1, 2, 3 + 10 * Precision.EPSILON); [EOL]     Assert.assertTrue(u.hashCode() != v.hashCode()); [EOL] } <line_num>: 84,90
@Test [EOL] public void testInfinite() { [EOL]     Assert.assertTrue(new Vector3D(1, 1, Double.NEGATIVE_INFINITY).isInfinite()); [EOL]     Assert.assertTrue(new Vector3D(1, Double.NEGATIVE_INFINITY, 1).isInfinite()); [EOL]     Assert.assertTrue(new Vector3D(Double.NEGATIVE_INFINITY, 1, 1).isInfinite()); [EOL]     Assert.assertFalse(new Vector3D(1, 1, 2).isInfinite()); [EOL]     Assert.assertFalse(new Vector3D(1, Double.NaN, Double.NEGATIVE_INFINITY).isInfinite()); [EOL] } <line_num>: 92,99
@Test [EOL] public void testNaN() { [EOL]     Assert.assertTrue(new Vector3D(1, 1, Double.NaN).isNaN()); [EOL]     Assert.assertTrue(new Vector3D(1, Double.NaN, 1).isNaN()); [EOL]     Assert.assertTrue(new Vector3D(Double.NaN, 1, 1).isNaN()); [EOL]     Assert.assertFalse(new Vector3D(1, 1, 2).isNaN()); [EOL]     Assert.assertFalse(new Vector3D(1, 1, Double.NEGATIVE_INFINITY).isNaN()); [EOL] } <line_num>: 101,108
@Test [EOL] public void testToString() { [EOL]     Assert.assertEquals("{3; 2; 1}", new Vector3D(3, 2, 1).toString()); [EOL]     NumberFormat format = new DecimalFormat("0.000", new DecimalFormatSymbols(Locale.US)); [EOL]     Assert.assertEquals("{3.000; 2.000; 1.000}", new Vector3D(3, 2, 1).toString(format)); [EOL] } <line_num>: 110,115
@Test(expected = DimensionMismatchException.class) [EOL] public void testWrongDimension() throws DimensionMismatchException { [EOL]     new Vector3D(new double[] { 2, 5 }); [EOL] } <line_num>: 117,120
@Test [EOL] public void testCoordinates() { [EOL]     Vector3D v = new Vector3D(1, 2, 3); [EOL]     Assert.assertTrue(FastMath.abs(v.getX() - 1) < 1.0e-12); [EOL]     Assert.assertTrue(FastMath.abs(v.getY() - 2) < 1.0e-12); [EOL]     Assert.assertTrue(FastMath.abs(v.getZ() - 3) < 1.0e-12); [EOL]     double[] coordinates = v.toArray(); [EOL]     Assert.assertTrue(FastMath.abs(coordinates[0] - 1) < 1.0e-12); [EOL]     Assert.assertTrue(FastMath.abs(coordinates[1] - 2) < 1.0e-12); [EOL]     Assert.assertTrue(FastMath.abs(coordinates[2] - 3) < 1.0e-12); [EOL] } <line_num>: 122,132
@Test [EOL] public void testNorm1() { [EOL]     Assert.assertEquals(0.0, Vector3D.ZERO.getNorm1(), 0); [EOL]     Assert.assertEquals(6.0, new Vector3D(1, -2, 3).getNorm1(), 0); [EOL] } <line_num>: 134,138
@Test [EOL] public void testNorm() { [EOL]     Assert.assertEquals(0.0, Vector3D.ZERO.getNorm(), 0); [EOL]     Assert.assertEquals(FastMath.sqrt(14), new Vector3D(1, 2, 3).getNorm(), 1.0e-12); [EOL] } <line_num>: 140,144
@Test [EOL] public void testNormSq() { [EOL]     Assert.assertEquals(0.0, new Vector3D(0, 0, 0).getNormSq(), 0); [EOL]     Assert.assertEquals(14, new Vector3D(1, 2, 3).getNormSq(), 1.0e-12); [EOL] } <line_num>: 146,150
@Test [EOL] public void testNormInf() { [EOL]     Assert.assertEquals(0.0, Vector3D.ZERO.getNormInf(), 0); [EOL]     Assert.assertEquals(3.0, new Vector3D(1, -2, 3).getNormInf(), 0); [EOL] } <line_num>: 152,156
@Test [EOL] public void testDistance1() { [EOL]     Vector3D v1 = new Vector3D(1, -2, 3); [EOL]     Vector3D v2 = new Vector3D(-4, 2, 0); [EOL]     Assert.assertEquals(0.0, Vector3D.distance1(Vector3D.MINUS_I, Vector3D.MINUS_I), 0); [EOL]     Assert.assertEquals(12.0, Vector3D.distance1(v1, v2), 1.0e-12); [EOL]     Assert.assertEquals(v1.subtract(v2).getNorm1(), Vector3D.distance1(v1, v2), 1.0e-12); [EOL] } <line_num>: 158,165
@Test [EOL] public void testDistance() { [EOL]     Vector3D v1 = new Vector3D(1, -2, 3); [EOL]     Vector3D v2 = new Vector3D(-4, 2, 0); [EOL]     Assert.assertEquals(0.0, Vector3D.distance(Vector3D.MINUS_I, Vector3D.MINUS_I), 0); [EOL]     Assert.assertEquals(FastMath.sqrt(50), Vector3D.distance(v1, v2), 1.0e-12); [EOL]     Assert.assertEquals(v1.subtract(v2).getNorm(), Vector3D.distance(v1, v2), 1.0e-12); [EOL] } <line_num>: 167,174
@Test [EOL] public void testDistanceSq() { [EOL]     Vector3D v1 = new Vector3D(1, -2, 3); [EOL]     Vector3D v2 = new Vector3D(-4, 2, 0); [EOL]     Assert.assertEquals(0.0, Vector3D.distanceSq(Vector3D.MINUS_I, Vector3D.MINUS_I), 0); [EOL]     Assert.assertEquals(50.0, Vector3D.distanceSq(v1, v2), 1.0e-12); [EOL]     Assert.assertEquals(Vector3D.distance(v1, v2) * Vector3D.distance(v1, v2), Vector3D.distanceSq(v1, v2), 1.0e-12); [EOL] } <line_num>: 176,184
@Test [EOL] public void testDistanceInf() { [EOL]     Vector3D v1 = new Vector3D(1, -2, 3); [EOL]     Vector3D v2 = new Vector3D(-4, 2, 0); [EOL]     Assert.assertEquals(0.0, Vector3D.distanceInf(Vector3D.MINUS_I, Vector3D.MINUS_I), 0); [EOL]     Assert.assertEquals(5.0, Vector3D.distanceInf(v1, v2), 1.0e-12); [EOL]     Assert.assertEquals(v1.subtract(v2).getNormInf(), Vector3D.distanceInf(v1, v2), 1.0e-12); [EOL] } <line_num>: 186,193
@Test [EOL] public void testSubtract() { [EOL]     Vector3D v1 = new Vector3D(1, 2, 3); [EOL]     Vector3D v2 = new Vector3D(-3, -2, -1); [EOL]     v1 = v1.subtract(v2); [EOL]     checkVector(v1, 4, 4, 4); [EOL]     checkVector(v2.subtract(v1), -7, -6, -5); [EOL]     checkVector(v2.subtract(3, v1), -15, -14, -13); [EOL] } <line_num>: 195,204
@Test [EOL] public void testAdd() { [EOL]     Vector3D v1 = new Vector3D(1, 2, 3); [EOL]     Vector3D v2 = new Vector3D(-3, -2, -1); [EOL]     v1 = v1.add(v2); [EOL]     checkVector(v1, -2, 0, 2); [EOL]     checkVector(v2.add(v1), -5, -2, 1); [EOL]     checkVector(v2.add(3, v1), -9, -2, 5); [EOL] } <line_num>: 206,215
@Test [EOL] public void testScalarProduct() { [EOL]     Vector3D v = new Vector3D(1, 2, 3); [EOL]     v = v.scalarMultiply(3); [EOL]     checkVector(v, 3, 6, 9); [EOL]     checkVector(v.scalarMultiply(0.5), 1.5, 3, 4.5); [EOL] } <line_num>: 217,224
@Test [EOL] public void testVectorialProducts() { [EOL]     Vector3D v1 = new Vector3D(2, 1, -4); [EOL]     Vector3D v2 = new Vector3D(3, 1, -1); [EOL]     Assert.assertTrue(FastMath.abs(Vector3D.dotProduct(v1, v2) - 11) < 1.0e-12); [EOL]     Vector3D v3 = Vector3D.crossProduct(v1, v2); [EOL]     checkVector(v3, 3, -10, -1); [EOL]     Assert.assertTrue(FastMath.abs(Vector3D.dotProduct(v1, v3)) < 1.0e-12); [EOL]     Assert.assertTrue(FastMath.abs(Vector3D.dotProduct(v2, v3)) < 1.0e-12); [EOL] } <line_num>: 226,238
@Test [EOL] public void testCrossProductCancellation() { [EOL]     Vector3D v1 = new Vector3D(9070467121.0, 4535233560.0, 1); [EOL]     Vector3D v2 = new Vector3D(9070467123.0, 4535233561.0, 1); [EOL]     checkVector(Vector3D.crossProduct(v1, v2), -1, 2, 1); [EOL]     double scale = FastMath.scalb(1.0, 100); [EOL]     Vector3D big1 = new Vector3D(scale, v1); [EOL]     Vector3D small2 = new Vector3D(1 / scale, v2); [EOL]     checkVector(Vector3D.crossProduct(big1, small2), -1, 2, 1); [EOL] } <line_num>: 240,251
@Test [EOL] public void testAngular() { [EOL]     Assert.assertEquals(0, Vector3D.PLUS_I.getAlpha(), 1.0e-10); [EOL]     Assert.assertEquals(0, Vector3D.PLUS_I.getDelta(), 1.0e-10); [EOL]     Assert.assertEquals(FastMath.PI / 2, Vector3D.PLUS_J.getAlpha(), 1.0e-10); [EOL]     Assert.assertEquals(0, Vector3D.PLUS_J.getDelta(), 1.0e-10); [EOL]     Assert.assertEquals(0, Vector3D.PLUS_K.getAlpha(), 1.0e-10); [EOL]     Assert.assertEquals(FastMath.PI / 2, Vector3D.PLUS_K.getDelta(), 1.0e-10); [EOL]     Vector3D u = new Vector3D(-1, 1, -1); [EOL]     Assert.assertEquals(3 * FastMath.PI / 4, u.getAlpha(), 1.0e-10); [EOL]     Assert.assertEquals(-1.0 / FastMath.sqrt(3), FastMath.sin(u.getDelta()), 1.0e-10); [EOL] } <line_num>: 253,265
@Test [EOL] public void testAngularSeparation() throws MathArithmeticException { [EOL]     Vector3D v1 = new Vector3D(2, -1, 4); [EOL]     Vector3D k = v1.normalize(); [EOL]     Vector3D i = k.orthogonal(); [EOL]     Vector3D v2 = k.scalarMultiply(FastMath.cos(1.2)).add(i.scalarMultiply(FastMath.sin(1.2))); [EOL]     Assert.assertTrue(FastMath.abs(Vector3D.angle(v1, v2) - 1.2) < 1.0e-12); [EOL] } <line_num>: 267,276
@Test [EOL] public void testNormalize() throws MathArithmeticException { [EOL]     Assert.assertEquals(1.0, new Vector3D(5, -4, 2).normalize().getNorm(), 1.0e-12); [EOL]     try { [EOL]         Vector3D.ZERO.normalize(); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (MathArithmeticException ae) { [EOL]     } [EOL] } <line_num>: 278,287
@Test [EOL] public void testNegate() { [EOL]     checkVector(new Vector3D(0.1, 2.5, 1.3).negate(), -0.1, -2.5, -1.3); [EOL] } <line_num>: 289,292
@Test [EOL] public void testOrthogonal() throws MathArithmeticException { [EOL]     Vector3D v1 = new Vector3D(0.1, 2.5, 1.3); [EOL]     Assert.assertEquals(0.0, Vector3D.dotProduct(v1, v1.orthogonal()), 1.0e-12); [EOL]     Vector3D v2 = new Vector3D(2.3, -0.003, 7.6); [EOL]     Assert.assertEquals(0.0, Vector3D.dotProduct(v2, v2.orthogonal()), 1.0e-12); [EOL]     Vector3D v3 = new Vector3D(-1.7, 1.4, 0.2); [EOL]     Assert.assertEquals(0.0, Vector3D.dotProduct(v3, v3.orthogonal()), 1.0e-12); [EOL]     Vector3D v4 = new Vector3D(4.2, 0.1, -1.8); [EOL]     Assert.assertEquals(0.0, Vector3D.dotProduct(v4, v4.orthogonal()), 1.0e-12); [EOL]     try { [EOL]         new Vector3D(0, 0, 0).orthogonal(); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (MathArithmeticException ae) { [EOL]     } [EOL] } <line_num>: 294,310
@Test [EOL] public void testAngle() throws MathArithmeticException { [EOL]     Assert.assertEquals(0.22572612855273393616, Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(4, 5, 6)), 1.0e-12); [EOL]     Assert.assertEquals(7.98595620686106654517199e-8, Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(2, 4, 6.000001)), 1.0e-12); [EOL]     Assert.assertEquals(3.14159257373023116985197793156, Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(-2, -4, -6.000001)), 1.0e-12); [EOL]     try { [EOL]         Vector3D.angle(Vector3D.ZERO, Vector3D.PLUS_I); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (MathArithmeticException ae) { [EOL]     } [EOL] } <line_num>: 311,328
@Test [EOL] public void testAccurateDotProduct() { [EOL]     Vector3D u1 = new Vector3D(-1321008684645961.0 / 268435456.0, -5774608829631843.0 / 268435456.0, -7645843051051357.0 / 8589934592.0); [EOL]     Vector3D u2 = new Vector3D(-5712344449280879.0 / 2097152.0, -4550117129121957.0 / 2097152.0, 8846951984510141.0 / 131072.0); [EOL]     double sNaive = u1.getX() * u2.getX() + u1.getY() * u2.getY() + u1.getZ() * u2.getZ(); [EOL]     double sAccurate = u1.dotProduct(u2); [EOL]     Assert.assertEquals(0.0, sNaive, 1.0e-30); [EOL]     Assert.assertEquals(-2088690039198397.0 / 1125899906842624.0, sAccurate, 1.0e-16); [EOL] } <line_num>: 330,345
@Test [EOL] public void testDotProduct() { [EOL]     Well1024a random = new Well1024a(553267312521321234l); [EOL]     for (int i = 0; i < 10000; ++i) { [EOL]         double ux = 10000 * random.nextDouble(); [EOL]         double uy = 10000 * random.nextDouble(); [EOL]         double uz = 10000 * random.nextDouble(); [EOL]         double vx = 10000 * random.nextDouble(); [EOL]         double vy = 10000 * random.nextDouble(); [EOL]         double vz = 10000 * random.nextDouble(); [EOL]         double sNaive = ux * vx + uy * vy + uz * vz; [EOL]         double sAccurate = new Vector3D(ux, uy, uz).dotProduct(new Vector3D(vx, vy, vz)); [EOL]         Assert.assertEquals(sNaive, sAccurate, 2.5e-16 * sAccurate); [EOL]     } [EOL] } <line_num>: 347,363
@Test [EOL] public void testAccurateCrossProduct() { [EOL]     final Vector3D u1 = new Vector3D(-1321008684645961.0 / 268435456.0, -5774608829631843.0 / 268435456.0, -7645843051051357.0 / 8589934592.0); [EOL]     final Vector3D u2 = new Vector3D(1796571811118507.0 / 2147483648.0, 7853468008299307.0 / 2147483648.0, 2599586637357461.0 / 17179869184.0); [EOL]     final Vector3D u3 = new Vector3D(12753243807587107.0 / 18446744073709551616.0, -2313766922703915.0 / 18446744073709551616.0, -227970081415313.0 / 288230376151711744.0); [EOL]     Vector3D cNaive = new Vector3D(u1.getY() * u2.getZ() - u1.getZ() * u2.getY(), u1.getZ() * u2.getX() - u1.getX() * u2.getZ(), u1.getX() * u2.getY() - u1.getY() * u2.getX()); [EOL]     Vector3D cAccurate = u1.crossProduct(u2); [EOL]     Assert.assertTrue(u3.distance(cNaive) > 2.9 * u3.getNorm()); [EOL]     Assert.assertEquals(0.0, u3.distance(cAccurate), 1.0e-30 * cAccurate.getNorm()); [EOL] } <line_num>: 365,387
@Test [EOL] public void testCrossProduct() { [EOL]     Well1024a random = new Well1024a(885362227452043214l); [EOL]     for (int i = 0; i < 10000; ++i) { [EOL]         double ux = 10000 * random.nextDouble(); [EOL]         double uy = 10000 * random.nextDouble(); [EOL]         double uz = 10000 * random.nextDouble(); [EOL]         double vx = 10000 * random.nextDouble(); [EOL]         double vy = 10000 * random.nextDouble(); [EOL]         double vz = 10000 * random.nextDouble(); [EOL]         Vector3D cNaive = new Vector3D(uy * vz - uz * vy, uz * vx - ux * vz, ux * vy - uy * vx); [EOL]         Vector3D cAccurate = new Vector3D(ux, uy, uz).crossProduct(new Vector3D(vx, vy, vz)); [EOL]         Assert.assertEquals(0.0, cAccurate.distance(cNaive), 6.0e-15 * cAccurate.getNorm()); [EOL]     } [EOL] } <line_num>: 389,405
private void checkVector(Vector3D v, double x, double y, double z) { [EOL]     Assert.assertEquals(x, v.getX(), 1.0e-12); [EOL]     Assert.assertEquals(y, v.getY(), 1.0e-12); [EOL]     Assert.assertEquals(z, v.getZ(), 1.0e-12); [EOL] } <line_num>: 407,411
