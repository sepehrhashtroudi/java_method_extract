@Test [EOL] public void testIdentity() { [EOL]     FieldRotation<DerivativeStructure> r = createRotation(1, 0, 0, 0, false); [EOL]     checkVector(r.applyTo(createVector(1, 0, 0)), createVector(1, 0, 0)); [EOL]     checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 1, 0)); [EOL]     checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 0, 1)); [EOL]     checkAngle(r.getAngle(), 0); [EOL]     r = createRotation(-1, 0, 0, 0, false); [EOL]     checkVector(r.applyTo(createVector(1, 0, 0)), createVector(1, 0, 0)); [EOL]     checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 1, 0)); [EOL]     checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 0, 1)); [EOL]     checkAngle(r.getAngle(), 0); [EOL]     r = createRotation(42, 0, 0, 0, true); [EOL]     checkVector(r.applyTo(createVector(1, 0, 0)), createVector(1, 0, 0)); [EOL]     checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 1, 0)); [EOL]     checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 0, 1)); [EOL]     checkAngle(r.getAngle(), 0); [EOL] } <line_num>: 35,56
@Test [EOL] public void testAxisAngle() throws MathIllegalArgumentException { [EOL]     FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(createAxis(10, 10, 10), createAngle(2 * FastMath.PI / 3)); [EOL]     checkVector(r.applyTo(createVector(1, 0, 0)), createVector(0, 1, 0)); [EOL]     checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 0, 1)); [EOL]     checkVector(r.applyTo(createVector(0, 0, 1)), createVector(1, 0, 0)); [EOL]     double s = 1 / FastMath.sqrt(3); [EOL]     checkVector(r.getAxis(), createVector(s, s, s)); [EOL]     checkAngle(r.getAngle(), 2 * FastMath.PI / 3); [EOL]     try { [EOL]         new FieldRotation<DerivativeStructure>(createAxis(0, 0, 0), createAngle(2 * FastMath.PI / 3)); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (MathIllegalArgumentException e) { [EOL]     } [EOL]     r = new FieldRotation<DerivativeStructure>(createAxis(0, 0, 1), createAngle(1.5 * FastMath.PI)); [EOL]     checkVector(r.getAxis(), createVector(0, 0, -1)); [EOL]     checkAngle(r.getAngle(), 0.5 * FastMath.PI); [EOL]     r = new FieldRotation<DerivativeStructure>(createAxis(0, 1, 0), createAngle(FastMath.PI)); [EOL]     checkVector(r.getAxis(), createVector(0, 1, 0)); [EOL]     checkAngle(r.getAngle(), FastMath.PI); [EOL]     checkVector(createRotation(1, 0, 0, 0, false).getAxis(), createVector(1, 0, 0)); [EOL] } <line_num>: 58,85
@Test [EOL] public void testRevert() { [EOL]     double a = 0.001; [EOL]     double b = 0.36; [EOL]     double c = 0.48; [EOL]     double d = 0.8; [EOL]     FieldRotation<DerivativeStructure> r = createRotation(a, b, c, d, true); [EOL]     double a2 = a * a; [EOL]     double b2 = b * b; [EOL]     double c2 = c * c; [EOL]     double d2 = d * d; [EOL]     double den = (a2 + b2 + c2 + d2) * FastMath.sqrt(a2 + b2 + c2 + d2); [EOL]     Assert.assertEquals((b2 + c2 + d2) / den, r.getQ0().getPartialDerivative(1, 0, 0, 0), 1.0e-15); [EOL]     Assert.assertEquals(-a * b / den, r.getQ0().getPartialDerivative(0, 1, 0, 0), 1.0e-15); [EOL]     Assert.assertEquals(-a * c / den, r.getQ0().getPartialDerivative(0, 0, 1, 0), 1.0e-15); [EOL]     Assert.assertEquals(-a * d / den, r.getQ0().getPartialDerivative(0, 0, 0, 1), 1.0e-15); [EOL]     Assert.assertEquals(-b * a / den, r.getQ1().getPartialDerivative(1, 0, 0, 0), 1.0e-15); [EOL]     Assert.assertEquals((a2 + c2 + d2) / den, r.getQ1().getPartialDerivative(0, 1, 0, 0), 1.0e-15); [EOL]     Assert.assertEquals(-b * c / den, r.getQ1().getPartialDerivative(0, 0, 1, 0), 1.0e-15); [EOL]     Assert.assertEquals(-b * d / den, r.getQ1().getPartialDerivative(0, 0, 0, 1), 1.0e-15); [EOL]     Assert.assertEquals(-c * a / den, r.getQ2().getPartialDerivative(1, 0, 0, 0), 1.0e-15); [EOL]     Assert.assertEquals(-c * b / den, r.getQ2().getPartialDerivative(0, 1, 0, 0), 1.0e-15); [EOL]     Assert.assertEquals((a2 + b2 + d2) / den, r.getQ2().getPartialDerivative(0, 0, 1, 0), 1.0e-15); [EOL]     Assert.assertEquals(-c * d / den, r.getQ2().getPartialDerivative(0, 0, 0, 1), 1.0e-15); [EOL]     Assert.assertEquals(-d * a / den, r.getQ3().getPartialDerivative(1, 0, 0, 0), 1.0e-15); [EOL]     Assert.assertEquals(-d * b / den, r.getQ3().getPartialDerivative(0, 1, 0, 0), 1.0e-15); [EOL]     Assert.assertEquals(-d * c / den, r.getQ3().getPartialDerivative(0, 0, 1, 0), 1.0e-15); [EOL]     Assert.assertEquals((a2 + b2 + c2) / den, r.getQ3().getPartialDerivative(0, 0, 0, 1), 1.0e-15); [EOL]     FieldRotation<DerivativeStructure> reverted = r.revert(); [EOL]     FieldRotation<DerivativeStructure> rrT = r.applyTo(reverted); [EOL]     checkRotationDS(rrT, 1, 0, 0, 0); [EOL]     Assert.assertEquals(0, rrT.getQ0().getPartialDerivative(1, 0, 0, 0), 1.0e-15); [EOL]     Assert.assertEquals(0, rrT.getQ0().getPartialDerivative(0, 1, 0, 0), 1.0e-15); [EOL]     Assert.assertEquals(0, rrT.getQ0().getPartialDerivative(0, 0, 1, 0), 1.0e-15); [EOL]     Assert.assertEquals(0, rrT.getQ0().getPartialDerivative(0, 0, 0, 1), 1.0e-15); [EOL]     Assert.assertEquals(0, rrT.getQ1().getPartialDerivative(1, 0, 0, 0), 1.0e-15); [EOL]     Assert.assertEquals(0, rrT.getQ1().getPartialDerivative(0, 1, 0, 0), 1.0e-15); [EOL]     Assert.assertEquals(0, rrT.getQ1().getPartialDerivative(0, 0, 1, 0), 1.0e-15); [EOL]     Assert.assertEquals(0, rrT.getQ1().getPartialDerivative(0, 0, 0, 1), 1.0e-15); [EOL]     Assert.assertEquals(0, rrT.getQ2().getPartialDerivative(1, 0, 0, 0), 1.0e-15); [EOL]     Assert.assertEquals(0, rrT.getQ2().getPartialDerivative(0, 1, 0, 0), 1.0e-15); [EOL]     Assert.assertEquals(0, rrT.getQ2().getPartialDerivative(0, 0, 1, 0), 1.0e-15); [EOL]     Assert.assertEquals(0, rrT.getQ2().getPartialDerivative(0, 0, 0, 1), 1.0e-15); [EOL]     Assert.assertEquals(0, rrT.getQ3().getPartialDerivative(1, 0, 0, 0), 1.0e-15); [EOL]     Assert.assertEquals(0, rrT.getQ3().getPartialDerivative(0, 1, 0, 0), 1.0e-15); [EOL]     Assert.assertEquals(0, rrT.getQ3().getPartialDerivative(0, 0, 1, 0), 1.0e-15); [EOL]     Assert.assertEquals(0, rrT.getQ3().getPartialDerivative(0, 0, 0, 1), 1.0e-15); [EOL]     FieldRotation<DerivativeStructure> rTr = reverted.applyTo(r); [EOL]     checkRotationDS(rTr, 1, 0, 0, 0); [EOL]     Assert.assertEquals(0, rTr.getQ0().getPartialDerivative(1, 0, 0, 0), 1.0e-15); [EOL]     Assert.assertEquals(0, rTr.getQ0().getPartialDerivative(0, 1, 0, 0), 1.0e-15); [EOL]     Assert.assertEquals(0, rTr.getQ0().getPartialDerivative(0, 0, 1, 0), 1.0e-15); [EOL]     Assert.assertEquals(0, rTr.getQ0().getPartialDerivative(0, 0, 0, 1), 1.0e-15); [EOL]     Assert.assertEquals(0, rTr.getQ1().getPartialDerivative(1, 0, 0, 0), 1.0e-15); [EOL]     Assert.assertEquals(0, rTr.getQ1().getPartialDerivative(0, 1, 0, 0), 1.0e-15); [EOL]     Assert.assertEquals(0, rTr.getQ1().getPartialDerivative(0, 0, 1, 0), 1.0e-15); [EOL]     Assert.assertEquals(0, rTr.getQ1().getPartialDerivative(0, 0, 0, 1), 1.0e-15); [EOL]     Assert.assertEquals(0, rTr.getQ2().getPartialDerivative(1, 0, 0, 0), 1.0e-15); [EOL]     Assert.assertEquals(0, rTr.getQ2().getPartialDerivative(0, 1, 0, 0), 1.0e-15); [EOL]     Assert.assertEquals(0, rTr.getQ2().getPartialDerivative(0, 0, 1, 0), 1.0e-15); [EOL]     Assert.assertEquals(0, rTr.getQ2().getPartialDerivative(0, 0, 0, 1), 1.0e-15); [EOL]     Assert.assertEquals(0, rTr.getQ3().getPartialDerivative(1, 0, 0, 0), 1.0e-15); [EOL]     Assert.assertEquals(0, rTr.getQ3().getPartialDerivative(0, 1, 0, 0), 1.0e-15); [EOL]     Assert.assertEquals(0, rTr.getQ3().getPartialDerivative(0, 0, 1, 0), 1.0e-15); [EOL]     Assert.assertEquals(0, rTr.getQ3().getPartialDerivative(0, 0, 0, 1), 1.0e-15); [EOL]     Assert.assertEquals(r.getAngle().getReal(), reverted.getAngle().getReal(), 1.0e-15); [EOL]     Assert.assertEquals(-1, FieldVector3D.dotProduct(r.getAxis(), reverted.getAxis()).getReal(), 1.0e-15); [EOL] } <line_num>: 87,154
@Test [EOL] public void testVectorOnePair() throws MathArithmeticException { [EOL]     FieldVector3D<DerivativeStructure> u = createVector(3, 2, 1); [EOL]     FieldVector3D<DerivativeStructure> v = createVector(-4, 2, 2); [EOL]     FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(u, v); [EOL]     checkVector(r.applyTo(u.scalarMultiply(v.getNorm())), v.scalarMultiply(u.getNorm())); [EOL]     checkAngle(new FieldRotation<DerivativeStructure>(u, u.negate()).getAngle(), FastMath.PI); [EOL]     try { [EOL]         new FieldRotation<DerivativeStructure>(u, createVector(0, 0, 0)); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (MathArithmeticException e) { [EOL]     } [EOL] } <line_num>: 156,173
@Test [EOL] public void testVectorTwoPairs() throws MathArithmeticException { [EOL]     FieldVector3D<DerivativeStructure> u1 = createVector(3, 0, 0); [EOL]     FieldVector3D<DerivativeStructure> u2 = createVector(0, 5, 0); [EOL]     FieldVector3D<DerivativeStructure> v1 = createVector(0, 0, 2); [EOL]     FieldVector3D<DerivativeStructure> v2 = createVector(-2, 0, 2); [EOL]     FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(u1, u2, v1, v2); [EOL]     checkVector(r.applyTo(createVector(1, 0, 0)), createVector(0, 0, 1)); [EOL]     checkVector(r.applyTo(createVector(0, 1, 0)), createVector(-1, 0, 0)); [EOL]     r = new FieldRotation<DerivativeStructure>(u1, u2, u1.negate(), u2.negate()); [EOL]     FieldVector3D<DerivativeStructure> axis = r.getAxis(); [EOL]     if (FieldVector3D.dotProduct(axis, createVector(0, 0, 1)).getReal() > 0) { [EOL]         checkVector(axis, createVector(0, 0, 1)); [EOL]     } else { [EOL]         checkVector(axis, createVector(0, 0, -1)); [EOL]     } [EOL]     checkAngle(r.getAngle(), FastMath.PI); [EOL]     double sqrt = FastMath.sqrt(2) / 2; [EOL]     r = new FieldRotation<DerivativeStructure>(createVector(1, 0, 0), createVector(0, 1, 0), createVector(0.5, 0.5, sqrt), createVector(0.5, 0.5, -sqrt)); [EOL]     checkRotationDS(r, sqrt, 0.5, 0.5, 0); [EOL]     r = new FieldRotation<DerivativeStructure>(u1, u2, u1, FieldVector3D.crossProduct(u1, u2)); [EOL]     checkRotationDS(r, sqrt, -sqrt, 0, 0); [EOL]     checkRotationDS(new FieldRotation<DerivativeStructure>(u1, u2, u1, u2), 1, 0, 0, 0); [EOL]     try { [EOL]         new FieldRotation<DerivativeStructure>(u1, u2, createVector(0, 0, 0), v2); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (MathArithmeticException e) { [EOL]     } [EOL] } <line_num>: 175,213
@Test [EOL] public void testMatrix() throws NotARotationMatrixException { [EOL]     try { [EOL]         createRotation(new double[][] { { 0.0, 1.0, 0.0 }, { 1.0, 0.0, 0.0 } }, 1.0e-7); [EOL]         Assert.fail("Expecting NotARotationMatrixException"); [EOL]     } catch (NotARotationMatrixException nrme) { [EOL]     } [EOL]     try { [EOL]         createRotation(new double[][] { { 0.445888, 0.797184, -0.407040 }, { 0.821760, -0.184320, 0.539200 }, { -0.354816, 0.574912, 0.737280 } }, 1.0e-7); [EOL]         Assert.fail("Expecting NotARotationMatrixException"); [EOL]     } catch (NotARotationMatrixException nrme) { [EOL]     } [EOL]     try { [EOL]         createRotation(new double[][] { { 0.4, 0.8, -0.4 }, { -0.4, 0.6, 0.7 }, { 0.8, -0.2, 0.5 } }, 1.0e-15); [EOL]         Assert.fail("Expecting NotARotationMatrixException"); [EOL]     } catch (NotARotationMatrixException nrme) { [EOL]     } [EOL]     checkRotationDS(createRotation(new double[][] { { 0.445888, 0.797184, -0.407040 }, { -0.354816, 0.574912, 0.737280 }, { 0.821760, -0.184320, 0.539200 } }, 1.0e-10), 0.8, 0.288, 0.384, 0.36); [EOL]     checkRotationDS(createRotation(new double[][] { { 0.539200, 0.737280, 0.407040 }, { 0.184320, -0.574912, 0.797184 }, { 0.821760, -0.354816, -0.445888 } }, 1.0e-10), 0.36, 0.8, 0.288, 0.384); [EOL]     checkRotationDS(createRotation(new double[][] { { -0.445888, 0.797184, -0.407040 }, { 0.354816, 0.574912, 0.737280 }, { 0.821760, 0.184320, -0.539200 } }, 1.0e-10), 0.384, 0.36, 0.8, 0.288); [EOL]     checkRotationDS(createRotation(new double[][] { { -0.539200, 0.737280, 0.407040 }, { -0.184320, -0.574912, 0.797184 }, { 0.821760, 0.354816, 0.445888 } }, 1.0e-10), 0.288, 0.384, 0.36, 0.8); [EOL]     double[][] m1 = { { 0.0, 1.0, 0.0 }, { 0.0, 0.0, 1.0 }, { 1.0, 0.0, 0.0 } }; [EOL]     FieldRotation<DerivativeStructure> r = createRotation(m1, 1.0e-7); [EOL]     checkVector(r.applyTo(createVector(1, 0, 0)), createVector(0, 0, 1)); [EOL]     checkVector(r.applyTo(createVector(0, 1, 0)), createVector(1, 0, 0)); [EOL]     checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 1, 0)); [EOL]     double[][] m2 = { { 0.83203, -0.55012, -0.07139 }, { 0.48293, 0.78164, -0.39474 }, { 0.27296, 0.29396, 0.91602 } }; [EOL]     r = createRotation(m2, 1.0e-12); [EOL]     DerivativeStructure[][] m3 = r.getMatrix(); [EOL]     double d00 = m2[0][0] - m3[0][0].getReal(); [EOL]     double d01 = m2[0][1] - m3[0][1].getReal(); [EOL]     double d02 = m2[0][2] - m3[0][2].getReal(); [EOL]     double d10 = m2[1][0] - m3[1][0].getReal(); [EOL]     double d11 = m2[1][1] - m3[1][1].getReal(); [EOL]     double d12 = m2[1][2] - m3[1][2].getReal(); [EOL]     double d20 = m2[2][0] - m3[2][0].getReal(); [EOL]     double d21 = m2[2][1] - m3[2][1].getReal(); [EOL]     double d22 = m2[2][2] - m3[2][2].getReal(); [EOL]     Assert.assertTrue(FastMath.abs(d00) < 6.0e-6); [EOL]     Assert.assertTrue(FastMath.abs(d01) < 6.0e-6); [EOL]     Assert.assertTrue(FastMath.abs(d02) < 6.0e-6); [EOL]     Assert.assertTrue(FastMath.abs(d10) < 6.0e-6); [EOL]     Assert.assertTrue(FastMath.abs(d11) < 6.0e-6); [EOL]     Assert.assertTrue(FastMath.abs(d12) < 6.0e-6); [EOL]     Assert.assertTrue(FastMath.abs(d20) < 6.0e-6); [EOL]     Assert.assertTrue(FastMath.abs(d21) < 6.0e-6); [EOL]     Assert.assertTrue(FastMath.abs(d22) < 6.0e-6); [EOL]     Assert.assertTrue(FastMath.abs(d00) > 4.0e-7); [EOL]     Assert.assertTrue(FastMath.abs(d01) > 4.0e-7); [EOL]     Assert.assertTrue(FastMath.abs(d02) > 4.0e-7); [EOL]     Assert.assertTrue(FastMath.abs(d10) > 4.0e-7); [EOL]     Assert.assertTrue(FastMath.abs(d11) > 4.0e-7); [EOL]     Assert.assertTrue(FastMath.abs(d12) > 4.0e-7); [EOL]     Assert.assertTrue(FastMath.abs(d20) > 4.0e-7); [EOL]     Assert.assertTrue(FastMath.abs(d21) > 4.0e-7); [EOL]     Assert.assertTrue(FastMath.abs(d22) > 4.0e-7); [EOL]     for (int i = 0; i < 3; ++i) { [EOL]         for (int j = 0; j < 3; ++j) { [EOL]             double m3tm3 = m3[i][0].getReal() * m3[j][0].getReal() + m3[i][1].getReal() * m3[j][1].getReal() + m3[i][2].getReal() * m3[j][2].getReal(); [EOL]             if (i == j) { [EOL]                 Assert.assertTrue(FastMath.abs(m3tm3 - 1.0) < 1.0e-10); [EOL]             } else { [EOL]                 Assert.assertTrue(FastMath.abs(m3tm3) < 1.0e-10); [EOL]             } [EOL]         } [EOL]     } [EOL]     checkVector(r.applyTo(createVector(1, 0, 0)), new FieldVector3D<DerivativeStructure>(m3[0][0], m3[1][0], m3[2][0])); [EOL]     checkVector(r.applyTo(createVector(0, 1, 0)), new FieldVector3D<DerivativeStructure>(m3[0][1], m3[1][1], m3[2][1])); [EOL]     checkVector(r.applyTo(createVector(0, 0, 1)), new FieldVector3D<DerivativeStructure>(m3[0][2], m3[1][2], m3[2][2])); [EOL]     double[][] m4 = { { 1.0, 0.0, 0.0 }, { 0.0, -1.0, 0.0 }, { 0.0, 0.0, -1.0 } }; [EOL]     r = createRotation(m4, 1.0e-7); [EOL]     checkAngle(r.getAngle(), FastMath.PI); [EOL]     try { [EOL]         double[][] m5 = { { 0.0, 0.0, 1.0 }, { 0.0, 1.0, 0.0 }, { 1.0, 0.0, 0.0 } }; [EOL]         r = createRotation(m5, 1.0e-7); [EOL]         Assert.fail("got " + r + ", should have caught an exception"); [EOL]     } catch (NotARotationMatrixException e) { [EOL]     } [EOL] } <line_num>: 215,359
@Test [EOL] public void testAngles() throws CardanEulerSingularityException { [EOL]     RotationOrder[] CardanOrders = { RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ, RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX }; [EOL]     for (int i = 0; i < CardanOrders.length; ++i) { [EOL]         for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) { [EOL]             for (double alpha2 = -1.55; alpha2 < 1.55; alpha2 += 0.3) { [EOL]                 for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) { [EOL]                     FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(CardanOrders[i], new DerivativeStructure(3, 1, 0, alpha1), new DerivativeStructure(3, 1, 1, alpha2), new DerivativeStructure(3, 1, 2, alpha3)); [EOL]                     DerivativeStructure[] angles = r.getAngles(CardanOrders[i]); [EOL]                     checkAngle(angles[0], alpha1); [EOL]                     checkAngle(angles[1], alpha2); [EOL]                     checkAngle(angles[2], alpha3); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     RotationOrder[] EulerOrders = { RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY, RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ }; [EOL]     for (int i = 0; i < EulerOrders.length; ++i) { [EOL]         for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) { [EOL]             for (double alpha2 = 0.05; alpha2 < 3.1; alpha2 += 0.3) { [EOL]                 for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) { [EOL]                     FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(EulerOrders[i], new DerivativeStructure(3, 1, 0, alpha1), new DerivativeStructure(3, 1, 1, alpha2), new DerivativeStructure(3, 1, 2, alpha3)); [EOL]                     DerivativeStructure[] angles = r.getAngles(EulerOrders[i]); [EOL]                     checkAngle(angles[0], alpha1); [EOL]                     checkAngle(angles[1], alpha2); [EOL]                     checkAngle(angles[2], alpha3); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 361,409
@Test [EOL] public void testSingularities() { [EOL]     RotationOrder[] CardanOrders = { RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ, RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX }; [EOL]     double[] singularCardanAngle = { FastMath.PI / 2, -FastMath.PI / 2 }; [EOL]     for (int i = 0; i < CardanOrders.length; ++i) { [EOL]         for (int j = 0; j < singularCardanAngle.length; ++j) { [EOL]             FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(CardanOrders[i], new DerivativeStructure(3, 1, 0, 0.1), new DerivativeStructure(3, 1, 1, singularCardanAngle[j]), new DerivativeStructure(3, 1, 2, 0.3)); [EOL]             try { [EOL]                 r.getAngles(CardanOrders[i]); [EOL]                 Assert.fail("an exception should have been caught"); [EOL]             } catch (CardanEulerSingularityException cese) { [EOL]             } [EOL]         } [EOL]     } [EOL]     RotationOrder[] EulerOrders = { RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY, RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ }; [EOL]     double[] singularEulerAngle = { 0, FastMath.PI }; [EOL]     for (int i = 0; i < EulerOrders.length; ++i) { [EOL]         for (int j = 0; j < singularEulerAngle.length; ++j) { [EOL]             FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(EulerOrders[i], new DerivativeStructure(3, 1, 0, 0.1), new DerivativeStructure(3, 1, 1, singularEulerAngle[j]), new DerivativeStructure(3, 1, 2, 0.3)); [EOL]             try { [EOL]                 r.getAngles(EulerOrders[i]); [EOL]                 Assert.fail("an exception should have been caught"); [EOL]             } catch (CardanEulerSingularityException cese) { [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 411,457
@Test [EOL] public void testQuaternion() throws MathIllegalArgumentException { [EOL]     FieldRotation<DerivativeStructure> r1 = new FieldRotation<DerivativeStructure>(createVector(2, -3, 5), createAngle(1.7)); [EOL]     double n = 23.5; [EOL]     FieldRotation<DerivativeStructure> r2 = new FieldRotation<DerivativeStructure>(r1.getQ0().multiply(n), r1.getQ1().multiply(n), r1.getQ2().multiply(n), r1.getQ3().multiply(n), true); [EOL]     for (double x = -0.9; x < 0.9; x += 0.2) { [EOL]         for (double y = -0.9; y < 0.9; y += 0.2) { [EOL]             for (double z = -0.9; z < 0.9; z += 0.2) { [EOL]                 FieldVector3D<DerivativeStructure> u = createVector(x, y, z); [EOL]                 checkVector(r2.applyTo(u), r1.applyTo(u)); [EOL]             } [EOL]         } [EOL]     } [EOL]     r1 = createRotation(0.288, 0.384, 0.36, 0.8, false); [EOL]     checkRotationDS(r1, -r1.getQ0().getReal(), -r1.getQ1().getReal(), -r1.getQ2().getReal(), -r1.getQ3().getReal()); [EOL]     Assert.assertEquals(0.288, r1.toRotation().getQ0(), 1.0e-15); [EOL]     Assert.assertEquals(0.384, r1.toRotation().getQ1(), 1.0e-15); [EOL]     Assert.assertEquals(0.36, r1.toRotation().getQ2(), 1.0e-15); [EOL]     Assert.assertEquals(0.8, r1.toRotation().getQ3(), 1.0e-15); [EOL] } <line_num>: 459,485
@Test [EOL] public void testCompose() throws MathIllegalArgumentException { [EOL]     FieldRotation<DerivativeStructure> r1 = new FieldRotation<DerivativeStructure>(createVector(2, -3, 5), createAngle(1.7)); [EOL]     FieldRotation<DerivativeStructure> r2 = new FieldRotation<DerivativeStructure>(createVector(-1, 3, 2), createAngle(0.3)); [EOL]     FieldRotation<DerivativeStructure> r3 = r2.applyTo(r1); [EOL]     FieldRotation<DerivativeStructure> r3Double = r2.applyTo(new Rotation(r1.getQ0().getReal(), r1.getQ1().getReal(), r1.getQ2().getReal(), r1.getQ3().getReal(), false)); [EOL]     for (double x = -0.9; x < 0.9; x += 0.2) { [EOL]         for (double y = -0.9; y < 0.9; y += 0.2) { [EOL]             for (double z = -0.9; z < 0.9; z += 0.2) { [EOL]                 FieldVector3D<DerivativeStructure> u = createVector(x, y, z); [EOL]                 checkVector(r2.applyTo(r1.applyTo(u)), r3.applyTo(u)); [EOL]                 checkVector(r2.applyTo(r1.applyTo(u)), r3Double.applyTo(u)); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 487,509
@Test [EOL] public void testComposeInverse() throws MathIllegalArgumentException { [EOL]     FieldRotation<DerivativeStructure> r1 = new FieldRotation<DerivativeStructure>(createVector(2, -3, 5), createAngle(1.7)); [EOL]     FieldRotation<DerivativeStructure> r2 = new FieldRotation<DerivativeStructure>(createVector(-1, 3, 2), createAngle(0.3)); [EOL]     FieldRotation<DerivativeStructure> r3 = r2.applyInverseTo(r1); [EOL]     FieldRotation<DerivativeStructure> r3Double = r2.applyInverseTo(new Rotation(r1.getQ0().getReal(), r1.getQ1().getReal(), r1.getQ2().getReal(), r1.getQ3().getReal(), false)); [EOL]     for (double x = -0.9; x < 0.9; x += 0.2) { [EOL]         for (double y = -0.9; y < 0.9; y += 0.2) { [EOL]             for (double z = -0.9; z < 0.9; z += 0.2) { [EOL]                 FieldVector3D<DerivativeStructure> u = createVector(x, y, z); [EOL]                 checkVector(r2.applyInverseTo(r1.applyTo(u)), r3.applyTo(u)); [EOL]                 checkVector(r2.applyInverseTo(r1.applyTo(u)), r3Double.applyTo(u)); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 511,533
@Test [EOL] public void testDoubleVectors() throws MathIllegalArgumentException { [EOL]     Well1024a random = new Well1024a(0x180b41cfeeffaf67l); [EOL]     UnitSphereRandomVectorGenerator g = new UnitSphereRandomVectorGenerator(3, random); [EOL]     for (int i = 0; i < 10; ++i) { [EOL]         double[] unit = g.nextVector(); [EOL]         FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(createVector(unit[0], unit[1], unit[2]), createAngle(random.nextDouble())); [EOL]         for (double x = -0.9; x < 0.9; x += 0.2) { [EOL]             for (double y = -0.9; y < 0.9; y += 0.2) { [EOL]                 for (double z = -0.9; z < 0.9; z += 0.2) { [EOL]                     FieldVector3D<DerivativeStructure> uds = createVector(x, y, z); [EOL]                     FieldVector3D<DerivativeStructure> ruds = r.applyTo(uds); [EOL]                     FieldVector3D<DerivativeStructure> rIuds = r.applyInverseTo(uds); [EOL]                     Vector3D u = new Vector3D(x, y, z); [EOL]                     FieldVector3D<DerivativeStructure> ru = r.applyTo(u); [EOL]                     FieldVector3D<DerivativeStructure> rIu = r.applyInverseTo(u); [EOL]                     DerivativeStructure[] ruArray = new DerivativeStructure[3]; [EOL]                     r.applyTo(new double[] { x, y, z }, ruArray); [EOL]                     DerivativeStructure[] rIuArray = new DerivativeStructure[3]; [EOL]                     r.applyInverseTo(new double[] { x, y, z }, rIuArray); [EOL]                     checkVector(ruds, ru); [EOL]                     checkVector(ruds, new FieldVector3D<DerivativeStructure>(ruArray)); [EOL]                     checkVector(rIuds, rIu); [EOL]                     checkVector(rIuds, new FieldVector3D<DerivativeStructure>(rIuArray)); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 535,567
@Test [EOL] public void testDoubleRotations() throws MathIllegalArgumentException { [EOL]     Well1024a random = new Well1024a(0x180b41cfeeffaf67l); [EOL]     UnitSphereRandomVectorGenerator g = new UnitSphereRandomVectorGenerator(3, random); [EOL]     for (int i = 0; i < 10; ++i) { [EOL]         double[] unit1 = g.nextVector(); [EOL]         Rotation r1 = new Rotation(new Vector3D(unit1[0], unit1[1], unit1[2]), random.nextDouble()); [EOL]         FieldRotation<DerivativeStructure> r1Prime = new FieldRotation<DerivativeStructure>(new DerivativeStructure(4, 1, 0, r1.getQ0()), new DerivativeStructure(4, 1, 1, r1.getQ1()), new DerivativeStructure(4, 1, 2, r1.getQ2()), new DerivativeStructure(4, 1, 3, r1.getQ3()), false); [EOL]         double[] unit2 = g.nextVector(); [EOL]         FieldRotation<DerivativeStructure> r2 = new FieldRotation<DerivativeStructure>(createVector(unit2[0], unit2[1], unit2[2]), createAngle(random.nextDouble())); [EOL]         FieldRotation<DerivativeStructure> rA = FieldRotation.applyTo(r1, r2); [EOL]         FieldRotation<DerivativeStructure> rB = r1Prime.applyTo(r2); [EOL]         FieldRotation<DerivativeStructure> rC = FieldRotation.applyInverseTo(r1, r2); [EOL]         FieldRotation<DerivativeStructure> rD = r1Prime.applyInverseTo(r2); [EOL]         for (double x = -0.9; x < 0.9; x += 0.2) { [EOL]             for (double y = -0.9; y < 0.9; y += 0.2) { [EOL]                 for (double z = -0.9; z < 0.9; z += 0.2) { [EOL]                     FieldVector3D<DerivativeStructure> uds = createVector(x, y, z); [EOL]                     checkVector(r1Prime.applyTo(uds), FieldRotation.applyTo(r1, uds)); [EOL]                     checkVector(r1Prime.applyInverseTo(uds), FieldRotation.applyInverseTo(r1, uds)); [EOL]                     checkVector(rA.applyTo(uds), rB.applyTo(uds)); [EOL]                     checkVector(rA.applyInverseTo(uds), rB.applyInverseTo(uds)); [EOL]                     checkVector(rC.applyTo(uds), rD.applyTo(uds)); [EOL]                     checkVector(rC.applyInverseTo(uds), rD.applyInverseTo(uds)); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 569,609
@Test [EOL] public void testDerivatives() { [EOL]     double eps = 5.0e-16; [EOL]     double kx = 2; [EOL]     double ky = -3; [EOL]     double kz = 5; [EOL]     double n2 = kx * kx + ky * ky + kz * kz; [EOL]     double n = FastMath.sqrt(n2); [EOL]     double theta = 1.7; [EOL]     double cosTheta = FastMath.cos(theta); [EOL]     double sinTheta = FastMath.sin(theta); [EOL]     FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(createAxis(kx, ky, kz), createAngle(theta)); [EOL]     Vector3D a = new Vector3D(kx / n, ky / n, kz / n); [EOL]     RealMatrix dadk = MatrixUtils.createRealMatrix(new double[][] { { (ky * ky + kz * kz) / (n * n2), -kx * ky / (n * n2), -kx * kz / (n * n2) }, { -kx * ky / (n * n2), (kx * kx + kz * kz) / (n * n2), -ky * kz / (n * n2) }, { -kx * kz / (n * n2), -ky * kz / (n * n2), (kx * kx + ky * ky) / (n * n2) } }); [EOL]     for (double x = -0.9; x < 0.9; x += 0.2) { [EOL]         for (double y = -0.9; y < 0.9; y += 0.2) { [EOL]             for (double z = -0.9; z < 0.9; z += 0.2) { [EOL]                 Vector3D u = new Vector3D(x, y, z); [EOL]                 FieldVector3D<DerivativeStructure> v = r.applyTo(createVector(x, y, z)); [EOL]                 double dot = Vector3D.dotProduct(u, a); [EOL]                 Vector3D cross = Vector3D.crossProduct(a, u); [EOL]                 double c1 = 1 - cosTheta; [EOL]                 double c2 = c1 * dot; [EOL]                 Vector3D rt = new Vector3D(cosTheta, u, c2, a, sinTheta, cross); [EOL]                 Assert.assertEquals(rt.getX(), v.getX().getReal(), eps); [EOL]                 Assert.assertEquals(rt.getY(), v.getY().getReal(), eps); [EOL]                 Assert.assertEquals(rt.getZ(), v.getZ().getReal(), eps); [EOL]                 RealMatrix dvda = MatrixUtils.createRealMatrix(new double[][] { { c1 * x * a.getX() + c2, c1 * y * a.getX() + sinTheta * z, c1 * z * a.getX() - sinTheta * y }, { c1 * x * a.getY() - sinTheta * z, c1 * y * a.getY() + c2, c1 * z * a.getY() + sinTheta * x }, { c1 * x * a.getZ() + sinTheta * y, c1 * y * a.getZ() - sinTheta * x, c1 * z * a.getZ() + c2 } }); [EOL]                 RealMatrix dvdk = dvda.multiply(dadk); [EOL]                 Assert.assertEquals(dvdk.getEntry(0, 0), v.getX().getPartialDerivative(1, 0, 0, 0), eps); [EOL]                 Assert.assertEquals(dvdk.getEntry(0, 1), v.getX().getPartialDerivative(0, 1, 0, 0), eps); [EOL]                 Assert.assertEquals(dvdk.getEntry(0, 2), v.getX().getPartialDerivative(0, 0, 1, 0), eps); [EOL]                 Assert.assertEquals(dvdk.getEntry(1, 0), v.getY().getPartialDerivative(1, 0, 0, 0), eps); [EOL]                 Assert.assertEquals(dvdk.getEntry(1, 1), v.getY().getPartialDerivative(0, 1, 0, 0), eps); [EOL]                 Assert.assertEquals(dvdk.getEntry(1, 2), v.getY().getPartialDerivative(0, 0, 1, 0), eps); [EOL]                 Assert.assertEquals(dvdk.getEntry(2, 0), v.getZ().getPartialDerivative(1, 0, 0, 0), eps); [EOL]                 Assert.assertEquals(dvdk.getEntry(2, 1), v.getZ().getPartialDerivative(0, 1, 0, 0), eps); [EOL]                 Assert.assertEquals(dvdk.getEntry(2, 2), v.getZ().getPartialDerivative(0, 0, 1, 0), eps); [EOL]                 Vector3D dvdTheta = new Vector3D(-sinTheta, u, sinTheta * dot, a, cosTheta, cross); [EOL]                 Assert.assertEquals(dvdTheta.getX(), v.getX().getPartialDerivative(0, 0, 0, 1), eps); [EOL]                 Assert.assertEquals(dvdTheta.getY(), v.getY().getPartialDerivative(0, 0, 0, 1), eps); [EOL]                 Assert.assertEquals(dvdTheta.getZ(), v.getZ().getPartialDerivative(0, 0, 0, 1), eps); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 611,682
@Test [EOL] public void testArray() throws MathIllegalArgumentException { [EOL]     FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(createAxis(2, -3, 5), createAngle(1.7)); [EOL]     for (double x = -0.9; x < 0.9; x += 0.2) { [EOL]         for (double y = -0.9; y < 0.9; y += 0.2) { [EOL]             for (double z = -0.9; z < 0.9; z += 0.2) { [EOL]                 FieldVector3D<DerivativeStructure> u = createVector(x, y, z); [EOL]                 FieldVector3D<DerivativeStructure> v = r.applyTo(u); [EOL]                 DerivativeStructure[] out = new DerivativeStructure[3]; [EOL]                 r.applyTo(new DerivativeStructure[] { u.getX(), u.getY(), u.getZ() }, out); [EOL]                 Assert.assertEquals(v.getX().getReal(), out[0].getReal(), 1.0e-10); [EOL]                 Assert.assertEquals(v.getY().getReal(), out[1].getReal(), 1.0e-10); [EOL]                 Assert.assertEquals(v.getZ().getReal(), out[2].getReal(), 1.0e-10); [EOL]                 r.applyInverseTo(out, out); [EOL]                 Assert.assertEquals(u.getX().getReal(), out[0].getReal(), 1.0e-10); [EOL]                 Assert.assertEquals(u.getY().getReal(), out[1].getReal(), 1.0e-10); [EOL]                 Assert.assertEquals(u.getZ().getReal(), out[2].getReal(), 1.0e-10); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 684,707
@Test [EOL] public void testApplyInverseTo() throws MathIllegalArgumentException { [EOL]     DerivativeStructure[] in = new DerivativeStructure[3]; [EOL]     DerivativeStructure[] out = new DerivativeStructure[3]; [EOL]     DerivativeStructure[] rebuilt = new DerivativeStructure[3]; [EOL]     FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(createVector(2, -3, 5), createAngle(1.7)); [EOL]     for (double lambda = 0; lambda < 6.2; lambda += 0.2) { [EOL]         for (double phi = -1.55; phi < 1.55; phi += 0.2) { [EOL]             FieldVector3D<DerivativeStructure> u = createVector(FastMath.cos(lambda) * FastMath.cos(phi), FastMath.sin(lambda) * FastMath.cos(phi), FastMath.sin(phi)); [EOL]             r.applyInverseTo(r.applyTo(u)); [EOL]             checkVector(u, r.applyInverseTo(r.applyTo(u))); [EOL]             checkVector(u, r.applyTo(r.applyInverseTo(u))); [EOL]             in[0] = u.getX(); [EOL]             in[1] = u.getY(); [EOL]             in[2] = u.getZ(); [EOL]             r.applyTo(in, out); [EOL]             r.applyInverseTo(out, rebuilt); [EOL]             Assert.assertEquals(in[0].getReal(), rebuilt[0].getReal(), 1.0e-12); [EOL]             Assert.assertEquals(in[1].getReal(), rebuilt[1].getReal(), 1.0e-12); [EOL]             Assert.assertEquals(in[2].getReal(), rebuilt[2].getReal(), 1.0e-12); [EOL]         } [EOL]     } [EOL]     r = createRotation(1, 0, 0, 0, false); [EOL]     for (double lambda = 0; lambda < 6.2; lambda += 0.2) { [EOL]         for (double phi = -1.55; phi < 1.55; phi += 0.2) { [EOL]             FieldVector3D<DerivativeStructure> u = createVector(FastMath.cos(lambda) * FastMath.cos(phi), FastMath.sin(lambda) * FastMath.cos(phi), FastMath.sin(phi)); [EOL]             checkVector(u, r.applyInverseTo(r.applyTo(u))); [EOL]             checkVector(u, r.applyTo(r.applyInverseTo(u))); [EOL]         } [EOL]     } [EOL]     r = new FieldRotation<DerivativeStructure>(createVector(0, 0, 1), createAngle(FastMath.PI)); [EOL]     for (double lambda = 0; lambda < 6.2; lambda += 0.2) { [EOL]         for (double phi = -1.55; phi < 1.55; phi += 0.2) { [EOL]             FieldVector3D<DerivativeStructure> u = createVector(FastMath.cos(lambda) * FastMath.cos(phi), FastMath.sin(lambda) * FastMath.cos(phi), FastMath.sin(phi)); [EOL]             checkVector(u, r.applyInverseTo(r.applyTo(u))); [EOL]             checkVector(u, r.applyTo(r.applyInverseTo(u))); [EOL]         } [EOL]     } [EOL] } <line_num>: 709,757
@Test [EOL] public void testIssue639() throws MathArithmeticException { [EOL]     FieldVector3D<DerivativeStructure> u1 = createVector(-1321008684645961.0 / 268435456.0, -5774608829631843.0 / 268435456.0, -3822921525525679.0 / 4294967296.0); [EOL]     FieldVector3D<DerivativeStructure> u2 = createVector(-5712344449280879.0 / 2097152.0, -2275058564560979.0 / 1048576.0, 4423475992255071.0 / 65536.0); [EOL]     FieldRotation<DerivativeStructure> rot = new FieldRotation<DerivativeStructure>(u1, u2, createVector(1, 0, 0), createVector(0, 0, 1)); [EOL]     Assert.assertEquals(0.6228370359608200639829222, rot.getQ0().getReal(), 1.0e-15); [EOL]     Assert.assertEquals(0.0257707621456498790029987, rot.getQ1().getReal(), 1.0e-15); [EOL]     Assert.assertEquals(-0.0000000002503012255839931, rot.getQ2().getReal(), 1.0e-15); [EOL]     Assert.assertEquals(-0.7819270390861109450724902, rot.getQ3().getReal(), 1.0e-15); [EOL] } <line_num>: 759,772
@Test [EOL] public void testIssue801() throws MathArithmeticException { [EOL]     FieldVector3D<DerivativeStructure> u1 = createVector(0.9999988431610581, -0.0015210774290851095, 0.0); [EOL]     FieldVector3D<DerivativeStructure> u2 = createVector(0.0, 0.0, 1.0); [EOL]     FieldVector3D<DerivativeStructure> v1 = createVector(0.9999999999999999, 0.0, 0.0); [EOL]     FieldVector3D<DerivativeStructure> v2 = createVector(0.0, 0.0, -1.0); [EOL]     FieldRotation<DerivativeStructure> quat = new FieldRotation<DerivativeStructure>(u1, u2, v1, v2); [EOL]     double q2 = quat.getQ0().getReal() * quat.getQ0().getReal() + quat.getQ1().getReal() * quat.getQ1().getReal() + quat.getQ2().getReal() * quat.getQ2().getReal() + quat.getQ3().getReal() * quat.getQ3().getReal(); [EOL]     Assert.assertEquals(1.0, q2, 1.0e-14); [EOL]     Assert.assertEquals(0.0, FieldVector3D.angle(v1, quat.applyTo(u1)).getReal(), 1.0e-14); [EOL]     Assert.assertEquals(0.0, FieldVector3D.angle(v2, quat.applyTo(u2)).getReal(), 1.0e-14); [EOL] } <line_num>: 774,791
private void checkAngle(DerivativeStructure a1, double a2) { [EOL]     Assert.assertEquals(a1.getReal(), MathUtils.normalizeAngle(a2, a1.getReal()), 1.0e-10); [EOL] } <line_num>: 793,795
private void checkRotationDS(FieldRotation<DerivativeStructure> r, double q0, double q1, double q2, double q3) { [EOL]     FieldRotation<DerivativeStructure> rPrime = createRotation(q0, q1, q2, q3, false); [EOL]     Assert.assertEquals(0, FieldRotation.distance(r, rPrime).getReal(), 1.0e-12); [EOL] } <line_num>: 797,800
private FieldRotation<DerivativeStructure> createRotation(double q0, double q1, double q2, double q3, boolean needsNormalization) { [EOL]     return new FieldRotation<DerivativeStructure>(new DerivativeStructure(4, 1, 0, q0), new DerivativeStructure(4, 1, 1, q1), new DerivativeStructure(4, 1, 2, q2), new DerivativeStructure(4, 1, 3, q3), needsNormalization); [EOL] } <line_num>: 802,809
private FieldRotation<DerivativeStructure> createRotation(double[][] m, double threshold) { [EOL]     DerivativeStructure[][] mds = new DerivativeStructure[m.length][m[0].length]; [EOL]     int index = 0; [EOL]     for (int i = 0; i < m.length; ++i) { [EOL]         for (int j = 0; j < m[i].length; ++j) { [EOL]             mds[i][j] = new DerivativeStructure(4, 1, index, m[i][j]); [EOL]             index = (index + 1) % 4; [EOL]         } [EOL]     } [EOL]     return new FieldRotation<DerivativeStructure>(mds, threshold); [EOL] } <line_num>: 811,821
private FieldVector3D<DerivativeStructure> createVector(double x, double y, double z) { [EOL]     return new FieldVector3D<DerivativeStructure>(new DerivativeStructure(4, 1, x), new DerivativeStructure(4, 1, y), new DerivativeStructure(4, 1, z)); [EOL] } <line_num>: 823,827
private FieldVector3D<DerivativeStructure> createAxis(double x, double y, double z) { [EOL]     return new FieldVector3D<DerivativeStructure>(new DerivativeStructure(4, 1, 0, x), new DerivativeStructure(4, 1, 1, y), new DerivativeStructure(4, 1, 2, z)); [EOL] } <line_num>: 829,833
private DerivativeStructure createAngle(double alpha) { [EOL]     return new DerivativeStructure(4, 1, 3, alpha); [EOL] } <line_num>: 835,837
private void checkVector(FieldVector3D<DerivativeStructure> u, FieldVector3D<DerivativeStructure> v) { [EOL]     Assert.assertEquals(u.getX().getReal(), v.getX().getReal(), 1.0e-12); [EOL]     Assert.assertEquals(u.getY().getReal(), v.getY().getReal(), 1.0e-12); [EOL]     Assert.assertEquals(u.getZ().getReal(), v.getZ().getReal(), 1.0e-12); [EOL] } <line_num>: 839,843
