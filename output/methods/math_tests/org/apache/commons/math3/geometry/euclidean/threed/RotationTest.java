@Test [EOL] public void testIdentity() { [EOL]     Rotation r = Rotation.IDENTITY; [EOL]     checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I); [EOL]     checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J); [EOL]     checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K); [EOL]     checkAngle(r.getAngle(), 0); [EOL]     r = new Rotation(-1, 0, 0, 0, false); [EOL]     checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I); [EOL]     checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J); [EOL]     checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K); [EOL]     checkAngle(r.getAngle(), 0); [EOL]     r = new Rotation(42, 0, 0, 0, true); [EOL]     checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I); [EOL]     checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J); [EOL]     checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K); [EOL]     checkAngle(r.getAngle(), 0); [EOL] } <line_num>: 30,51
@Test [EOL] public void testAxisAngle() throws MathIllegalArgumentException { [EOL]     Rotation r = new Rotation(new Vector3D(10, 10, 10), 2 * FastMath.PI / 3); [EOL]     checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_J); [EOL]     checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_K); [EOL]     checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_I); [EOL]     double s = 1 / FastMath.sqrt(3); [EOL]     checkVector(r.getAxis(), new Vector3D(s, s, s)); [EOL]     checkAngle(r.getAngle(), 2 * FastMath.PI / 3); [EOL]     try { [EOL]         new Rotation(new Vector3D(0, 0, 0), 2 * FastMath.PI / 3); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (MathIllegalArgumentException e) { [EOL]     } [EOL]     r = new Rotation(Vector3D.PLUS_K, 1.5 * FastMath.PI); [EOL]     checkVector(r.getAxis(), new Vector3D(0, 0, -1)); [EOL]     checkAngle(r.getAngle(), 0.5 * FastMath.PI); [EOL]     r = new Rotation(Vector3D.PLUS_J, FastMath.PI); [EOL]     checkVector(r.getAxis(), Vector3D.PLUS_J); [EOL]     checkAngle(r.getAngle(), FastMath.PI); [EOL]     checkVector(Rotation.IDENTITY.getAxis(), Vector3D.PLUS_I); [EOL] } <line_num>: 53,80
@Test [EOL] public void testRevert() { [EOL]     Rotation r = new Rotation(0.001, 0.36, 0.48, 0.8, true); [EOL]     Rotation reverted = r.revert(); [EOL]     checkRotation(r.applyTo(reverted), 1, 0, 0, 0); [EOL]     checkRotation(reverted.applyTo(r), 1, 0, 0, 0); [EOL]     Assert.assertEquals(r.getAngle(), reverted.getAngle(), 1.0e-12); [EOL]     Assert.assertEquals(-1, Vector3D.dotProduct(r.getAxis(), reverted.getAxis()), 1.0e-12); [EOL] } <line_num>: 82,90
@Test [EOL] public void testVectorOnePair() throws MathArithmeticException { [EOL]     Vector3D u = new Vector3D(3, 2, 1); [EOL]     Vector3D v = new Vector3D(-4, 2, 2); [EOL]     Rotation r = new Rotation(u, v); [EOL]     checkVector(r.applyTo(u.scalarMultiply(v.getNorm())), v.scalarMultiply(u.getNorm())); [EOL]     checkAngle(new Rotation(u, u.negate()).getAngle(), FastMath.PI); [EOL]     try { [EOL]         new Rotation(u, Vector3D.ZERO); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (MathArithmeticException e) { [EOL]     } [EOL] } <line_num>: 92,109
@Test [EOL] public void testVectorTwoPairs() throws MathArithmeticException { [EOL]     Vector3D u1 = new Vector3D(3, 0, 0); [EOL]     Vector3D u2 = new Vector3D(0, 5, 0); [EOL]     Vector3D v1 = new Vector3D(0, 0, 2); [EOL]     Vector3D v2 = new Vector3D(-2, 0, 2); [EOL]     Rotation r = new Rotation(u1, u2, v1, v2); [EOL]     checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_K); [EOL]     checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.MINUS_I); [EOL]     r = new Rotation(u1, u2, u1.negate(), u2.negate()); [EOL]     Vector3D axis = r.getAxis(); [EOL]     if (Vector3D.dotProduct(axis, Vector3D.PLUS_K) > 0) { [EOL]         checkVector(axis, Vector3D.PLUS_K); [EOL]     } else { [EOL]         checkVector(axis, Vector3D.MINUS_K); [EOL]     } [EOL]     checkAngle(r.getAngle(), FastMath.PI); [EOL]     double sqrt = FastMath.sqrt(2) / 2; [EOL]     r = new Rotation(Vector3D.PLUS_I, Vector3D.PLUS_J, new Vector3D(0.5, 0.5, sqrt), new Vector3D(0.5, 0.5, -sqrt)); [EOL]     checkRotation(r, sqrt, 0.5, 0.5, 0); [EOL]     r = new Rotation(u1, u2, u1, Vector3D.crossProduct(u1, u2)); [EOL]     checkRotation(r, sqrt, -sqrt, 0, 0); [EOL]     checkRotation(new Rotation(u1, u2, u1, u2), 1, 0, 0, 0); [EOL]     try { [EOL]         new Rotation(u1, u2, Vector3D.ZERO, v2); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (MathArithmeticException e) { [EOL]     } [EOL] } <line_num>: 111,149
@Test [EOL] public void testMatrix() throws NotARotationMatrixException { [EOL]     try { [EOL]         new Rotation(new double[][] { { 0.0, 1.0, 0.0 }, { 1.0, 0.0, 0.0 } }, 1.0e-7); [EOL]         Assert.fail("Expecting NotARotationMatrixException"); [EOL]     } catch (NotARotationMatrixException nrme) { [EOL]     } [EOL]     try { [EOL]         new Rotation(new double[][] { { 0.445888, 0.797184, -0.407040 }, { 0.821760, -0.184320, 0.539200 }, { -0.354816, 0.574912, 0.737280 } }, 1.0e-7); [EOL]         Assert.fail("Expecting NotARotationMatrixException"); [EOL]     } catch (NotARotationMatrixException nrme) { [EOL]     } [EOL]     try { [EOL]         new Rotation(new double[][] { { 0.4, 0.8, -0.4 }, { -0.4, 0.6, 0.7 }, { 0.8, -0.2, 0.5 } }, 1.0e-15); [EOL]         Assert.fail("Expecting NotARotationMatrixException"); [EOL]     } catch (NotARotationMatrixException nrme) { [EOL]     } [EOL]     checkRotation(new Rotation(new double[][] { { 0.445888, 0.797184, -0.407040 }, { -0.354816, 0.574912, 0.737280 }, { 0.821760, -0.184320, 0.539200 } }, 1.0e-10), 0.8, 0.288, 0.384, 0.36); [EOL]     checkRotation(new Rotation(new double[][] { { 0.539200, 0.737280, 0.407040 }, { 0.184320, -0.574912, 0.797184 }, { 0.821760, -0.354816, -0.445888 } }, 1.0e-10), 0.36, 0.8, 0.288, 0.384); [EOL]     checkRotation(new Rotation(new double[][] { { -0.445888, 0.797184, -0.407040 }, { 0.354816, 0.574912, 0.737280 }, { 0.821760, 0.184320, -0.539200 } }, 1.0e-10), 0.384, 0.36, 0.8, 0.288); [EOL]     checkRotation(new Rotation(new double[][] { { -0.539200, 0.737280, 0.407040 }, { -0.184320, -0.574912, 0.797184 }, { 0.821760, 0.354816, 0.445888 } }, 1.0e-10), 0.288, 0.384, 0.36, 0.8); [EOL]     double[][] m1 = { { 0.0, 1.0, 0.0 }, { 0.0, 0.0, 1.0 }, { 1.0, 0.0, 0.0 } }; [EOL]     Rotation r = new Rotation(m1, 1.0e-7); [EOL]     checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_K); [EOL]     checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_I); [EOL]     checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_J); [EOL]     double[][] m2 = { { 0.83203, -0.55012, -0.07139 }, { 0.48293, 0.78164, -0.39474 }, { 0.27296, 0.29396, 0.91602 } }; [EOL]     r = new Rotation(m2, 1.0e-12); [EOL]     double[][] m3 = r.getMatrix(); [EOL]     double d00 = m2[0][0] - m3[0][0]; [EOL]     double d01 = m2[0][1] - m3[0][1]; [EOL]     double d02 = m2[0][2] - m3[0][2]; [EOL]     double d10 = m2[1][0] - m3[1][0]; [EOL]     double d11 = m2[1][1] - m3[1][1]; [EOL]     double d12 = m2[1][2] - m3[1][2]; [EOL]     double d20 = m2[2][0] - m3[2][0]; [EOL]     double d21 = m2[2][1] - m3[2][1]; [EOL]     double d22 = m2[2][2] - m3[2][2]; [EOL]     Assert.assertTrue(FastMath.abs(d00) < 6.0e-6); [EOL]     Assert.assertTrue(FastMath.abs(d01) < 6.0e-6); [EOL]     Assert.assertTrue(FastMath.abs(d02) < 6.0e-6); [EOL]     Assert.assertTrue(FastMath.abs(d10) < 6.0e-6); [EOL]     Assert.assertTrue(FastMath.abs(d11) < 6.0e-6); [EOL]     Assert.assertTrue(FastMath.abs(d12) < 6.0e-6); [EOL]     Assert.assertTrue(FastMath.abs(d20) < 6.0e-6); [EOL]     Assert.assertTrue(FastMath.abs(d21) < 6.0e-6); [EOL]     Assert.assertTrue(FastMath.abs(d22) < 6.0e-6); [EOL]     Assert.assertTrue(FastMath.abs(d00) > 4.0e-7); [EOL]     Assert.assertTrue(FastMath.abs(d01) > 4.0e-7); [EOL]     Assert.assertTrue(FastMath.abs(d02) > 4.0e-7); [EOL]     Assert.assertTrue(FastMath.abs(d10) > 4.0e-7); [EOL]     Assert.assertTrue(FastMath.abs(d11) > 4.0e-7); [EOL]     Assert.assertTrue(FastMath.abs(d12) > 4.0e-7); [EOL]     Assert.assertTrue(FastMath.abs(d20) > 4.0e-7); [EOL]     Assert.assertTrue(FastMath.abs(d21) > 4.0e-7); [EOL]     Assert.assertTrue(FastMath.abs(d22) > 4.0e-7); [EOL]     for (int i = 0; i < 3; ++i) { [EOL]         for (int j = 0; j < 3; ++j) { [EOL]             double m3tm3 = m3[i][0] * m3[j][0] + m3[i][1] * m3[j][1] + m3[i][2] * m3[j][2]; [EOL]             if (i == j) { [EOL]                 Assert.assertTrue(FastMath.abs(m3tm3 - 1.0) < 1.0e-10); [EOL]             } else { [EOL]                 Assert.assertTrue(FastMath.abs(m3tm3) < 1.0e-10); [EOL]             } [EOL]         } [EOL]     } [EOL]     checkVector(r.applyTo(Vector3D.PLUS_I), new Vector3D(m3[0][0], m3[1][0], m3[2][0])); [EOL]     checkVector(r.applyTo(Vector3D.PLUS_J), new Vector3D(m3[0][1], m3[1][1], m3[2][1])); [EOL]     checkVector(r.applyTo(Vector3D.PLUS_K), new Vector3D(m3[0][2], m3[1][2], m3[2][2])); [EOL]     double[][] m4 = { { 1.0, 0.0, 0.0 }, { 0.0, -1.0, 0.0 }, { 0.0, 0.0, -1.0 } }; [EOL]     r = new Rotation(m4, 1.0e-7); [EOL]     checkAngle(r.getAngle(), FastMath.PI); [EOL]     try { [EOL]         double[][] m5 = { { 0.0, 0.0, 1.0 }, { 0.0, 1.0, 0.0 }, { 1.0, 0.0, 0.0 } }; [EOL]         r = new Rotation(m5, 1.0e-7); [EOL]         Assert.fail("got " + r + ", should have caught an exception"); [EOL]     } catch (NotARotationMatrixException e) { [EOL]     } [EOL] } <line_num>: 151,295
@Test [EOL] public void testAngles() throws CardanEulerSingularityException { [EOL]     RotationOrder[] CardanOrders = { RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ, RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX }; [EOL]     for (int i = 0; i < CardanOrders.length; ++i) { [EOL]         for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) { [EOL]             for (double alpha2 = -1.55; alpha2 < 1.55; alpha2 += 0.3) { [EOL]                 for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) { [EOL]                     Rotation r = new Rotation(CardanOrders[i], alpha1, alpha2, alpha3); [EOL]                     double[] angles = r.getAngles(CardanOrders[i]); [EOL]                     checkAngle(angles[0], alpha1); [EOL]                     checkAngle(angles[1], alpha2); [EOL]                     checkAngle(angles[2], alpha3); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     RotationOrder[] EulerOrders = { RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY, RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ }; [EOL]     for (int i = 0; i < EulerOrders.length; ++i) { [EOL]         for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) { [EOL]             for (double alpha2 = 0.05; alpha2 < 3.1; alpha2 += 0.3) { [EOL]                 for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) { [EOL]                     Rotation r = new Rotation(EulerOrders[i], alpha1, alpha2, alpha3); [EOL]                     double[] angles = r.getAngles(EulerOrders[i]); [EOL]                     checkAngle(angles[0], alpha1); [EOL]                     checkAngle(angles[1], alpha2); [EOL]                     checkAngle(angles[2], alpha3); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 297,340
@Test [EOL] public void testSingularities() { [EOL]     RotationOrder[] CardanOrders = { RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ, RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX }; [EOL]     double[] singularCardanAngle = { FastMath.PI / 2, -FastMath.PI / 2 }; [EOL]     for (int i = 0; i < CardanOrders.length; ++i) { [EOL]         for (int j = 0; j < singularCardanAngle.length; ++j) { [EOL]             Rotation r = new Rotation(CardanOrders[i], 0.1, singularCardanAngle[j], 0.3); [EOL]             try { [EOL]                 r.getAngles(CardanOrders[i]); [EOL]                 Assert.fail("an exception should have been caught"); [EOL]             } catch (CardanEulerSingularityException cese) { [EOL]             } [EOL]         } [EOL]     } [EOL]     RotationOrder[] EulerOrders = { RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY, RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ }; [EOL]     double[] singularEulerAngle = { 0, FastMath.PI }; [EOL]     for (int i = 0; i < EulerOrders.length; ++i) { [EOL]         for (int j = 0; j < singularEulerAngle.length; ++j) { [EOL]             Rotation r = new Rotation(EulerOrders[i], 0.1, singularEulerAngle[j], 0.3); [EOL]             try { [EOL]                 r.getAngles(EulerOrders[i]); [EOL]                 Assert.fail("an exception should have been caught"); [EOL]             } catch (CardanEulerSingularityException cese) { [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 342,382
@Test [EOL] public void testQuaternion() throws MathIllegalArgumentException { [EOL]     Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7); [EOL]     double n = 23.5; [EOL]     Rotation r2 = new Rotation(n * r1.getQ0(), n * r1.getQ1(), n * r1.getQ2(), n * r1.getQ3(), true); [EOL]     for (double x = -0.9; x < 0.9; x += 0.2) { [EOL]         for (double y = -0.9; y < 0.9; y += 0.2) { [EOL]             for (double z = -0.9; z < 0.9; z += 0.2) { [EOL]                 Vector3D u = new Vector3D(x, y, z); [EOL]                 checkVector(r2.applyTo(u), r1.applyTo(u)); [EOL]             } [EOL]         } [EOL]     } [EOL]     r1 = new Rotation(0.288, 0.384, 0.36, 0.8, false); [EOL]     checkRotation(r1, -r1.getQ0(), -r1.getQ1(), -r1.getQ2(), -r1.getQ3()); [EOL] } <line_num>: 384,404
@Test [EOL] public void testCompose() throws MathIllegalArgumentException { [EOL]     Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7); [EOL]     Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3); [EOL]     Rotation r3 = r2.applyTo(r1); [EOL]     for (double x = -0.9; x < 0.9; x += 0.2) { [EOL]         for (double y = -0.9; y < 0.9; y += 0.2) { [EOL]             for (double z = -0.9; z < 0.9; z += 0.2) { [EOL]                 Vector3D u = new Vector3D(x, y, z); [EOL]                 checkVector(r2.applyTo(r1.applyTo(u)), r3.applyTo(u)); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 406,422
@Test [EOL] public void testComposeInverse() throws MathIllegalArgumentException { [EOL]     Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7); [EOL]     Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3); [EOL]     Rotation r3 = r2.applyInverseTo(r1); [EOL]     for (double x = -0.9; x < 0.9; x += 0.2) { [EOL]         for (double y = -0.9; y < 0.9; y += 0.2) { [EOL]             for (double z = -0.9; z < 0.9; z += 0.2) { [EOL]                 Vector3D u = new Vector3D(x, y, z); [EOL]                 checkVector(r2.applyInverseTo(r1.applyTo(u)), r3.applyTo(u)); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 424,440
@Test [EOL] public void testArray() throws MathIllegalArgumentException { [EOL]     Rotation r = new Rotation(new Vector3D(2, -3, 5), 1.7); [EOL]     for (double x = -0.9; x < 0.9; x += 0.2) { [EOL]         for (double y = -0.9; y < 0.9; y += 0.2) { [EOL]             for (double z = -0.9; z < 0.9; z += 0.2) { [EOL]                 Vector3D u = new Vector3D(x, y, z); [EOL]                 Vector3D v = r.applyTo(u); [EOL]                 double[] inOut = new double[] { x, y, z }; [EOL]                 r.applyTo(inOut, inOut); [EOL]                 Assert.assertEquals(v.getX(), inOut[0], 1.0e-10); [EOL]                 Assert.assertEquals(v.getY(), inOut[1], 1.0e-10); [EOL]                 Assert.assertEquals(v.getZ(), inOut[2], 1.0e-10); [EOL]                 r.applyInverseTo(inOut, inOut); [EOL]                 Assert.assertEquals(u.getX(), inOut[0], 1.0e-10); [EOL]                 Assert.assertEquals(u.getY(), inOut[1], 1.0e-10); [EOL]                 Assert.assertEquals(u.getZ(), inOut[2], 1.0e-10); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 442,465
@Test [EOL] public void testApplyInverseTo() throws MathIllegalArgumentException { [EOL]     Rotation r = new Rotation(new Vector3D(2, -3, 5), 1.7); [EOL]     for (double lambda = 0; lambda < 6.2; lambda += 0.2) { [EOL]         for (double phi = -1.55; phi < 1.55; phi += 0.2) { [EOL]             Vector3D u = new Vector3D(FastMath.cos(lambda) * FastMath.cos(phi), FastMath.sin(lambda) * FastMath.cos(phi), FastMath.sin(phi)); [EOL]             r.applyInverseTo(r.applyTo(u)); [EOL]             checkVector(u, r.applyInverseTo(r.applyTo(u))); [EOL]             checkVector(u, r.applyTo(r.applyInverseTo(u))); [EOL]         } [EOL]     } [EOL]     r = Rotation.IDENTITY; [EOL]     for (double lambda = 0; lambda < 6.2; lambda += 0.2) { [EOL]         for (double phi = -1.55; phi < 1.55; phi += 0.2) { [EOL]             Vector3D u = new Vector3D(FastMath.cos(lambda) * FastMath.cos(phi), FastMath.sin(lambda) * FastMath.cos(phi), FastMath.sin(phi)); [EOL]             checkVector(u, r.applyInverseTo(r.applyTo(u))); [EOL]             checkVector(u, r.applyTo(r.applyInverseTo(u))); [EOL]         } [EOL]     } [EOL]     r = new Rotation(Vector3D.PLUS_K, FastMath.PI); [EOL]     for (double lambda = 0; lambda < 6.2; lambda += 0.2) { [EOL]         for (double phi = -1.55; phi < 1.55; phi += 0.2) { [EOL]             Vector3D u = new Vector3D(FastMath.cos(lambda) * FastMath.cos(phi), FastMath.sin(lambda) * FastMath.cos(phi), FastMath.sin(phi)); [EOL]             checkVector(u, r.applyInverseTo(r.applyTo(u))); [EOL]             checkVector(u, r.applyTo(r.applyInverseTo(u))); [EOL]         } [EOL]     } [EOL] } <line_num>: 467,504
@Test [EOL] public void testIssue639() throws MathArithmeticException { [EOL]     Vector3D u1 = new Vector3D(-1321008684645961.0 / 268435456.0, -5774608829631843.0 / 268435456.0, -3822921525525679.0 / 4294967296.0); [EOL]     Vector3D u2 = new Vector3D(-5712344449280879.0 / 2097152.0, -2275058564560979.0 / 1048576.0, 4423475992255071.0 / 65536.0); [EOL]     Rotation rot = new Rotation(u1, u2, Vector3D.PLUS_I, Vector3D.PLUS_K); [EOL]     Assert.assertEquals(0.6228370359608200639829222, rot.getQ0(), 1.0e-15); [EOL]     Assert.assertEquals(0.0257707621456498790029987, rot.getQ1(), 1.0e-15); [EOL]     Assert.assertEquals(-0.0000000002503012255839931, rot.getQ2(), 1.0e-15); [EOL]     Assert.assertEquals(-0.7819270390861109450724902, rot.getQ3(), 1.0e-15); [EOL] } <line_num>: 506,519
@Test [EOL] public void testIssue801() throws MathArithmeticException { [EOL]     Vector3D u1 = new Vector3D(0.9999988431610581, -0.0015210774290851095, 0.0); [EOL]     Vector3D u2 = new Vector3D(0.0, 0.0, 1.0); [EOL]     Vector3D v1 = new Vector3D(0.9999999999999999, 0.0, 0.0); [EOL]     Vector3D v2 = new Vector3D(0.0, 0.0, -1.0); [EOL]     Rotation quat = new Rotation(u1, u2, v1, v2); [EOL]     double q2 = quat.getQ0() * quat.getQ0() + quat.getQ1() * quat.getQ1() + quat.getQ2() * quat.getQ2() + quat.getQ3() * quat.getQ3(); [EOL]     Assert.assertEquals(1.0, q2, 1.0e-14); [EOL]     Assert.assertEquals(0.0, Vector3D.angle(v1, quat.applyTo(u1)), 1.0e-14); [EOL]     Assert.assertEquals(0.0, Vector3D.angle(v2, quat.applyTo(u2)), 1.0e-14); [EOL] } <line_num>: 521,538
private void checkVector(Vector3D v1, Vector3D v2) { [EOL]     Assert.assertTrue(v1.subtract(v2).getNorm() < 1.0e-10); [EOL] } <line_num>: 540,542
private void checkAngle(double a1, double a2) { [EOL]     Assert.assertEquals(a1, MathUtils.normalizeAngle(a2, a1), 1.0e-10); [EOL] } <line_num>: 544,546
private void checkRotation(Rotation r, double q0, double q1, double q2, double q3) { [EOL]     Assert.assertEquals(0, Rotation.distance(r, new Rotation(q0, q1, q2, q3, false)), 1.0e-12); [EOL] } <line_num>: 548,550
