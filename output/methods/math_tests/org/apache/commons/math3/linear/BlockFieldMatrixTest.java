public SetVisitor() { [EOL]     super(Fraction.ZERO); [EOL] } <line_num>: 1337,1339
public GetVisitor() { [EOL]     super(Fraction.ZERO); [EOL]     count = 0; [EOL] } <line_num>: 1348,1351
@Test [EOL] public void testDimensions() { [EOL]     BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); [EOL]     BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testData2); [EOL]     Assert.assertEquals("testData row dimension", 3, m.getRowDimension()); [EOL]     Assert.assertEquals("testData column dimension", 3, m.getColumnDimension()); [EOL]     Assert.assertTrue("testData is square", m.isSquare()); [EOL]     Assert.assertEquals("testData2 row dimension", m2.getRowDimension(), 2); [EOL]     Assert.assertEquals("testData2 column dimension", m2.getColumnDimension(), 3); [EOL]     Assert.assertTrue("testData2 is not square", !m2.isSquare()); [EOL] } <line_num>: 161,171
@Test [EOL] public void testCopyFunctions() { [EOL]     Random r = new Random(66636328996002l); [EOL]     BlockFieldMatrix<Fraction> m1 = createRandomMatrix(r, 47, 83); [EOL]     BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(m1.getData()); [EOL]     Assert.assertEquals(m1, m2); [EOL]     BlockFieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(testData); [EOL]     BlockFieldMatrix<Fraction> m4 = new BlockFieldMatrix<Fraction>(m3.getData()); [EOL]     Assert.assertEquals(m3, m4); [EOL] } <line_num>: 174,183
@Test [EOL] public void testAdd() { [EOL]     BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); [EOL]     BlockFieldMatrix<Fraction> mInv = new BlockFieldMatrix<Fraction>(testDataInv); [EOL]     FieldMatrix<Fraction> mPlusMInv = m.add(mInv); [EOL]     Fraction[][] sumEntries = mPlusMInv.getData(); [EOL]     for (int row = 0; row < m.getRowDimension(); row++) { [EOL]         for (int col = 0; col < m.getColumnDimension(); col++) { [EOL]             Assert.assertEquals(testDataPlusInv[row][col], sumEntries[row][col]); [EOL]         } [EOL]     } [EOL] } <line_num>: 186,197
@Test [EOL] public void testAddFail() { [EOL]     BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); [EOL]     BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testData2); [EOL]     try { [EOL]         m.add(m2); [EOL]         Assert.fail("MathIllegalArgumentException expected"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 200,210
@Test [EOL] public void testPlusMinus() { [EOL]     BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); [EOL]     BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testDataInv); [EOL]     TestUtils.assertEquals(m.subtract(m2), m2.scalarMultiply(new Fraction(-1)).add(m)); [EOL]     try { [EOL]         m.subtract(new BlockFieldMatrix<Fraction>(testData2)); [EOL]         Assert.fail("Expecting illegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 213,224
@Test [EOL] public void testMultiply() { [EOL]     BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); [EOL]     BlockFieldMatrix<Fraction> mInv = new BlockFieldMatrix<Fraction>(testDataInv); [EOL]     BlockFieldMatrix<Fraction> identity = new BlockFieldMatrix<Fraction>(id); [EOL]     BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testData2); [EOL]     TestUtils.assertEquals(m.multiply(mInv), identity); [EOL]     TestUtils.assertEquals(mInv.multiply(m), identity); [EOL]     TestUtils.assertEquals(m.multiply(identity), m); [EOL]     TestUtils.assertEquals(identity.multiply(mInv), mInv); [EOL]     TestUtils.assertEquals(m2.multiply(identity), m2); [EOL]     try { [EOL]         m.multiply(new BlockFieldMatrix<Fraction>(bigSingular)); [EOL]         Assert.fail("Expecting illegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 227,244
@Test [EOL] public void testSeveralBlocks() { [EOL]     FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), 37, 41); [EOL]     for (int i = 0; i < m.getRowDimension(); ++i) { [EOL]         for (int j = 0; j < m.getColumnDimension(); ++j) { [EOL]             m.setEntry(i, j, new Fraction(i * 11 + j, 11)); [EOL]         } [EOL]     } [EOL]     FieldMatrix<Fraction> mT = m.transpose(); [EOL]     Assert.assertEquals(m.getRowDimension(), mT.getColumnDimension()); [EOL]     Assert.assertEquals(m.getColumnDimension(), mT.getRowDimension()); [EOL]     for (int i = 0; i < mT.getRowDimension(); ++i) { [EOL]         for (int j = 0; j < mT.getColumnDimension(); ++j) { [EOL]             Assert.assertEquals(m.getEntry(j, i), mT.getEntry(i, j)); [EOL]         } [EOL]     } [EOL]     FieldMatrix<Fraction> mPm = m.add(m); [EOL]     for (int i = 0; i < mPm.getRowDimension(); ++i) { [EOL]         for (int j = 0; j < mPm.getColumnDimension(); ++j) { [EOL]             Assert.assertEquals(m.getEntry(i, j).multiply(new Fraction(2)), mPm.getEntry(i, j)); [EOL]         } [EOL]     } [EOL]     FieldMatrix<Fraction> mPmMm = mPm.subtract(m); [EOL]     for (int i = 0; i < mPmMm.getRowDimension(); ++i) { [EOL]         for (int j = 0; j < mPmMm.getColumnDimension(); ++j) { [EOL]             Assert.assertEquals(m.getEntry(i, j), mPmMm.getEntry(i, j)); [EOL]         } [EOL]     } [EOL]     FieldMatrix<Fraction> mTm = mT.multiply(m); [EOL]     for (int i = 0; i < mTm.getRowDimension(); ++i) { [EOL]         for (int j = 0; j < mTm.getColumnDimension(); ++j) { [EOL]             Fraction sum = Fraction.ZERO; [EOL]             for (int k = 0; k < mT.getColumnDimension(); ++k) { [EOL]                 sum = sum.add(new Fraction(k * 11 + i, 11).multiply(new Fraction(k * 11 + j, 11))); [EOL]             } [EOL]             Assert.assertEquals(sum, mTm.getEntry(i, j)); [EOL]         } [EOL]     } [EOL]     FieldMatrix<Fraction> mmT = m.multiply(mT); [EOL]     for (int i = 0; i < mmT.getRowDimension(); ++i) { [EOL]         for (int j = 0; j < mmT.getColumnDimension(); ++j) { [EOL]             Fraction sum = Fraction.ZERO; [EOL]             for (int k = 0; k < m.getColumnDimension(); ++k) { [EOL]                 sum = sum.add(new Fraction(i * 11 + k, 11).multiply(new Fraction(j * 11 + k, 11))); [EOL]             } [EOL]             Assert.assertEquals(sum, mmT.getEntry(i, j)); [EOL]         } [EOL]     } [EOL]     FieldMatrix<Fraction> sub1 = m.getSubMatrix(2, 9, 5, 20); [EOL]     for (int i = 0; i < sub1.getRowDimension(); ++i) { [EOL]         for (int j = 0; j < sub1.getColumnDimension(); ++j) { [EOL]             Assert.assertEquals(new Fraction((i + 2) * 11 + (j + 5), 11), sub1.getEntry(i, j)); [EOL]         } [EOL]     } [EOL]     FieldMatrix<Fraction> sub2 = m.getSubMatrix(10, 12, 3, 40); [EOL]     for (int i = 0; i < sub2.getRowDimension(); ++i) { [EOL]         for (int j = 0; j < sub2.getColumnDimension(); ++j) { [EOL]             Assert.assertEquals(new Fraction((i + 10) * 11 + (j + 3), 11), sub2.getEntry(i, j)); [EOL]         } [EOL]     } [EOL]     FieldMatrix<Fraction> sub3 = m.getSubMatrix(30, 34, 0, 5); [EOL]     for (int i = 0; i < sub3.getRowDimension(); ++i) { [EOL]         for (int j = 0; j < sub3.getColumnDimension(); ++j) { [EOL]             Assert.assertEquals(new Fraction((i + 30) * 11 + (j + 0), 11), sub3.getEntry(i, j)); [EOL]         } [EOL]     } [EOL]     FieldMatrix<Fraction> sub4 = m.getSubMatrix(30, 32, 32, 35); [EOL]     for (int i = 0; i < sub4.getRowDimension(); ++i) { [EOL]         for (int j = 0; j < sub4.getColumnDimension(); ++j) { [EOL]             Assert.assertEquals(new Fraction((i + 30) * 11 + (j + 32), 11), sub4.getEntry(i, j)); [EOL]         } [EOL]     } [EOL] } <line_num>: 246,329
@Test [EOL] public void testMultiply2() { [EOL]     FieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(d3); [EOL]     FieldMatrix<Fraction> m4 = new BlockFieldMatrix<Fraction>(d4); [EOL]     FieldMatrix<Fraction> m5 = new BlockFieldMatrix<Fraction>(d5); [EOL]     TestUtils.assertEquals(m3.multiply(m4), m5); [EOL] } <line_num>: 345,351
@Test [EOL] public void testTrace() { [EOL]     FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(id); [EOL]     Assert.assertEquals(new Fraction(3), m.getTrace()); [EOL]     m = new BlockFieldMatrix<Fraction>(testData2); [EOL]     try { [EOL]         m.getTrace(); [EOL]         Assert.fail("Expecting NonSquareMatrixException"); [EOL]     } catch (NonSquareMatrixException ex) { [EOL]     } [EOL] } <line_num>: 354,365
@Test [EOL] public void testScalarAdd() { [EOL]     FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); [EOL]     TestUtils.assertEquals(new BlockFieldMatrix<Fraction>(testDataPlus2), m.scalarAdd(new Fraction(2))); [EOL] } <line_num>: 368,373
@Test [EOL] public void testOperate() { [EOL]     FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(id); [EOL]     TestUtils.assertEquals(testVector, m.operate(testVector)); [EOL]     TestUtils.assertEquals(testVector, m.operate(new ArrayFieldVector<Fraction>(testVector)).getData()); [EOL]     m = new BlockFieldMatrix<Fraction>(bigSingular); [EOL]     try { [EOL]         m.operate(testVector); [EOL]         Assert.fail("Expecting illegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 376,388
@Test [EOL] public void testOperateLarge() { [EOL]     int p = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10; [EOL]     int q = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10; [EOL]     int r = BlockFieldMatrix.BLOCK_SIZE / 2; [EOL]     Random random = new Random(111007463902334l); [EOL]     FieldMatrix<Fraction> m1 = createRandomMatrix(random, p, q); [EOL]     FieldMatrix<Fraction> m2 = createRandomMatrix(random, q, r); [EOL]     FieldMatrix<Fraction> m1m2 = m1.multiply(m2); [EOL]     for (int i = 0; i < r; ++i) { [EOL]         TestUtils.assertEquals(m1m2.getColumn(i), m1.operate(m2.getColumn(i))); [EOL]     } [EOL] } <line_num>: 390,402
@Test [EOL] public void testOperatePremultiplyLarge() { [EOL]     int p = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10; [EOL]     int q = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10; [EOL]     int r = BlockFieldMatrix.BLOCK_SIZE / 2; [EOL]     Random random = new Random(111007463902334l); [EOL]     FieldMatrix<Fraction> m1 = createRandomMatrix(random, p, q); [EOL]     FieldMatrix<Fraction> m2 = createRandomMatrix(random, q, r); [EOL]     FieldMatrix<Fraction> m1m2 = m1.multiply(m2); [EOL]     for (int i = 0; i < p; ++i) { [EOL]         TestUtils.assertEquals(m1m2.getRow(i), m2.preMultiply(m1.getRow(i))); [EOL]     } [EOL] } <line_num>: 404,416
@Test [EOL] public void testMath209() { [EOL]     FieldMatrix<Fraction> a = new BlockFieldMatrix<Fraction>(new Fraction[][] { { new Fraction(1), new Fraction(2) }, { new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6) } }); [EOL]     Fraction[] b = a.operate(new Fraction[] { new Fraction(1), new Fraction(1) }); [EOL]     Assert.assertEquals(a.getRowDimension(), b.length); [EOL]     Assert.assertEquals(new Fraction(3), b[0]); [EOL]     Assert.assertEquals(new Fraction(7), b[1]); [EOL]     Assert.assertEquals(new Fraction(11), b[2]); [EOL] } <line_num>: 419,431
@Test [EOL] public void testTranspose() { [EOL]     FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); [EOL]     FieldMatrix<Fraction> mIT = new FieldLUDecomposition<Fraction>(m).getSolver().getInverse().transpose(); [EOL]     FieldMatrix<Fraction> mTI = new FieldLUDecomposition<Fraction>(m.transpose()).getSolver().getInverse(); [EOL]     TestUtils.assertEquals(mIT, mTI); [EOL]     m = new BlockFieldMatrix<Fraction>(testData2); [EOL]     FieldMatrix<Fraction> mt = new BlockFieldMatrix<Fraction>(testData2T); [EOL]     TestUtils.assertEquals(mt, m.transpose()); [EOL] } <line_num>: 434,443
@Test [EOL] public void testPremultiplyVector() { [EOL]     FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); [EOL]     TestUtils.assertEquals(m.preMultiply(testVector), preMultTest); [EOL]     TestUtils.assertEquals(m.preMultiply(new ArrayFieldVector<Fraction>(testVector).getData()), preMultTest); [EOL]     m = new BlockFieldMatrix<Fraction>(bigSingular); [EOL]     try { [EOL]         m.preMultiply(testVector); [EOL]         Assert.fail("expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 446,459
@Test [EOL] public void testPremultiply() { [EOL]     FieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(d3); [EOL]     FieldMatrix<Fraction> m4 = new BlockFieldMatrix<Fraction>(d4); [EOL]     FieldMatrix<Fraction> m5 = new BlockFieldMatrix<Fraction>(d5); [EOL]     TestUtils.assertEquals(m4.preMultiply(m3), m5); [EOL]     BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); [EOL]     BlockFieldMatrix<Fraction> mInv = new BlockFieldMatrix<Fraction>(testDataInv); [EOL]     BlockFieldMatrix<Fraction> identity = new BlockFieldMatrix<Fraction>(id); [EOL]     TestUtils.assertEquals(m.preMultiply(mInv), identity); [EOL]     TestUtils.assertEquals(mInv.preMultiply(m), identity); [EOL]     TestUtils.assertEquals(m.preMultiply(identity), m); [EOL]     TestUtils.assertEquals(identity.preMultiply(mInv), mInv); [EOL]     try { [EOL]         m.preMultiply(new BlockFieldMatrix<Fraction>(bigSingular)); [EOL]         Assert.fail("Expecting illegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 461,481
@Test [EOL] public void testGetVectors() { [EOL]     FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); [EOL]     TestUtils.assertEquals(m.getRow(0), testDataRow1); [EOL]     TestUtils.assertEquals(m.getColumn(2), testDataCol3); [EOL]     try { [EOL]         m.getRow(10); [EOL]         Assert.fail("expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.getColumn(-1); [EOL]         Assert.fail("expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL] } <line_num>: 483,500
@Test [EOL] public void testGetEntry() { [EOL]     FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); [EOL]     Assert.assertEquals(m.getEntry(0, 1), new Fraction(2)); [EOL]     try { [EOL]         m.getEntry(10, 4); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL] } <line_num>: 502,512
@Test [EOL] public void testExamples() { [EOL]     Fraction[][] matrixData = { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(5), new Fraction(3) } }; [EOL]     FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(matrixData); [EOL]     Fraction[][] matrixData2 = { { new Fraction(1), new Fraction(2) }, { new Fraction(2), new Fraction(5) }, { new Fraction(1), new Fraction(7) } }; [EOL]     FieldMatrix<Fraction> n = new BlockFieldMatrix<Fraction>(matrixData2); [EOL]     FieldMatrix<Fraction> p = m.multiply(n); [EOL]     Assert.assertEquals(2, p.getRowDimension()); [EOL]     Assert.assertEquals(2, p.getColumnDimension()); [EOL]     FieldMatrix<Fraction> pInverse = new FieldLUDecomposition<Fraction>(p).getSolver().getInverse(); [EOL]     Assert.assertEquals(2, pInverse.getRowDimension()); [EOL]     Assert.assertEquals(2, pInverse.getColumnDimension()); [EOL]     Fraction[][] coefficientsData = { { new Fraction(2), new Fraction(3), new Fraction(-2) }, { new Fraction(-1), new Fraction(7), new Fraction(6) }, { new Fraction(4), new Fraction(-3), new Fraction(-5) } }; [EOL]     FieldMatrix<Fraction> coefficients = new BlockFieldMatrix<Fraction>(coefficientsData); [EOL]     Fraction[] constants = { new Fraction(1), new Fraction(-2), new Fraction(1) }; [EOL]     Fraction[] solution; [EOL]     solution = new FieldLUDecomposition<Fraction>(coefficients).getSolver().solve(new ArrayFieldVector<Fraction>(constants, false)).toArray(); [EOL]     Assert.assertEquals(new Fraction(2).multiply(solution[0]).add(new Fraction(3).multiply(solution[1])).subtract(new Fraction(2).multiply(solution[2])), constants[0]); [EOL]     Assert.assertEquals(new Fraction(-1).multiply(solution[0]).add(new Fraction(7).multiply(solution[1])).add(new Fraction(6).multiply(solution[2])), constants[1]); [EOL]     Assert.assertEquals(new Fraction(4).multiply(solution[0]).subtract(new Fraction(3).multiply(solution[1])).subtract(new Fraction(5).multiply(solution[2])), constants[2]); [EOL] } <line_num>: 515,566
@Test [EOL] public void testGetSubMatrix() { [EOL]     FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData); [EOL]     checkGetSubMatrix(m, subRows23Cols00, 2, 3, 0, 0); [EOL]     checkGetSubMatrix(m, subRows00Cols33, 0, 0, 3, 3); [EOL]     checkGetSubMatrix(m, subRows01Cols23, 0, 1, 2, 3); [EOL]     checkGetSubMatrix(m, subRows02Cols13, new int[] { 0, 2 }, new int[] { 1, 3 }); [EOL]     checkGetSubMatrix(m, subRows03Cols12, new int[] { 0, 3 }, new int[] { 1, 2 }); [EOL]     checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }); [EOL]     checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }); [EOL]     checkGetSubMatrix(m, subRows31Cols31, new int[] { 3, 1 }, new int[] { 3, 1 }); [EOL]     checkGetSubMatrix(m, subRows31Cols31, new int[] { 3, 1 }, new int[] { 3, 1 }); [EOL]     checkGetSubMatrix(m, null, 1, 0, 2, 4); [EOL]     checkGetSubMatrix(m, null, -1, 1, 2, 2); [EOL]     checkGetSubMatrix(m, null, 1, 0, 2, 2); [EOL]     checkGetSubMatrix(m, null, 1, 0, 2, 4); [EOL]     checkGetSubMatrix(m, null, new int[] {}, new int[] { 0 }); [EOL]     checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 }); [EOL] } <line_num>: 569,587
private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference, int startRow, int endRow, int startColumn, int endColumn) { [EOL]     try { [EOL]         FieldMatrix<Fraction> sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn); [EOL]         if (reference != null) { [EOL]             Assert.assertEquals(new BlockFieldMatrix<Fraction>(reference), sub); [EOL]         } else { [EOL]             Assert.fail("Expecting OutOfRangeException or NotStrictlyPositiveException" + " or NumberIsTooSmallException or NoDataException"); [EOL]         } [EOL]     } catch (OutOfRangeException e) { [EOL]         if (reference != null) { [EOL]             throw e; [EOL]         } [EOL]     } catch (NotStrictlyPositiveException e) { [EOL]         if (reference != null) { [EOL]             throw e; [EOL]         } [EOL]     } catch (NumberIsTooSmallException e) { [EOL]         if (reference != null) { [EOL]             throw e; [EOL]         } [EOL]     } catch (NoDataException e) { [EOL]         if (reference != null) { [EOL]             throw e; [EOL]         } [EOL]     } [EOL] } <line_num>: 589,616
private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference, int[] selectedRows, int[] selectedColumns) { [EOL]     try { [EOL]         FieldMatrix<Fraction> sub = m.getSubMatrix(selectedRows, selectedColumns); [EOL]         if (reference != null) { [EOL]             Assert.assertEquals(new BlockFieldMatrix<Fraction>(reference), sub); [EOL]         } else { [EOL]             Assert.fail("Expecting OutOfRangeException"); [EOL]         } [EOL]     } catch (OutOfRangeException e) { [EOL]         if (reference != null) { [EOL]             throw e; [EOL]         } [EOL]     } catch (NotStrictlyPositiveException e) { [EOL]         if (reference != null) { [EOL]             throw e; [EOL]         } [EOL]     } catch (NumberIsTooSmallException e) { [EOL]         if (reference != null) { [EOL]             throw e; [EOL]         } [EOL]     } catch (NoDataException e) { [EOL]         if (reference != null) { [EOL]             throw e; [EOL]         } [EOL]     } [EOL] } <line_num>: 618,644
@Test [EOL] public void testGetSetMatrixLarge() { [EOL]     int n = 3 * BlockFieldMatrix.BLOCK_SIZE; [EOL]     FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n); [EOL]     FieldMatrix<Fraction> sub = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n - 4, n - 4).scalarAdd(new Fraction(1)); [EOL]     m.setSubMatrix(sub.getData(), 2, 2); [EOL]     for (int i = 0; i < n; ++i) { [EOL]         for (int j = 0; j < n; ++j) { [EOL]             if ((i < 2) || (i > n - 3) || (j < 2) || (j > n - 3)) { [EOL]                 Assert.assertEquals(new Fraction(0), m.getEntry(i, j)); [EOL]             } else { [EOL]                 Assert.assertEquals(new Fraction(1), m.getEntry(i, j)); [EOL]             } [EOL]         } [EOL]     } [EOL]     Assert.assertEquals(sub, m.getSubMatrix(2, n - 3, 2, n - 3)); [EOL] } <line_num>: 646,665
@Test [EOL] public void testCopySubMatrix() { [EOL]     FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData); [EOL]     checkCopy(m, subRows23Cols00, 2, 3, 0, 0); [EOL]     checkCopy(m, subRows00Cols33, 0, 0, 3, 3); [EOL]     checkCopy(m, subRows01Cols23, 0, 1, 2, 3); [EOL]     checkCopy(m, subRows02Cols13, new int[] { 0, 2 }, new int[] { 1, 3 }); [EOL]     checkCopy(m, subRows03Cols12, new int[] { 0, 3 }, new int[] { 1, 2 }); [EOL]     checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }); [EOL]     checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }); [EOL]     checkCopy(m, subRows31Cols31, new int[] { 3, 1 }, new int[] { 3, 1 }); [EOL]     checkCopy(m, subRows31Cols31, new int[] { 3, 1 }, new int[] { 3, 1 }); [EOL]     checkCopy(m, null, 1, 0, 2, 4); [EOL]     checkCopy(m, null, -1, 1, 2, 2); [EOL]     checkCopy(m, null, 1, 0, 2, 2); [EOL]     checkCopy(m, null, 1, 0, 2, 4); [EOL]     checkCopy(m, null, new int[] {}, new int[] { 0 }); [EOL]     checkCopy(m, null, new int[] { 0 }, new int[] { 4 }); [EOL] } <line_num>: 667,686
private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference, int startRow, int endRow, int startColumn, int endColumn) { [EOL]     try { [EOL]         Fraction[][] sub = (reference == null) ? new Fraction[1][1] : new Fraction[reference.length][reference[0].length]; [EOL]         m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub); [EOL]         if (reference != null) { [EOL]             Assert.assertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub)); [EOL]         } else { [EOL]             Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException"); [EOL]         } [EOL]     } catch (OutOfRangeException e) { [EOL]         if (reference != null) { [EOL]             throw e; [EOL]         } [EOL]     } catch (NumberIsTooSmallException e) { [EOL]         if (reference != null) { [EOL]             throw e; [EOL]         } [EOL]     } catch (NoDataException e) { [EOL]         if (reference != null) { [EOL]             throw e; [EOL]         } [EOL]     } [EOL] } <line_num>: 688,713
private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference, int[] selectedRows, int[] selectedColumns) { [EOL]     try { [EOL]         Fraction[][] sub = (reference == null) ? new Fraction[1][1] : new Fraction[reference.length][reference[0].length]; [EOL]         m.copySubMatrix(selectedRows, selectedColumns, sub); [EOL]         if (reference != null) { [EOL]             Assert.assertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub)); [EOL]         } else { [EOL]             Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException"); [EOL]         } [EOL]     } catch (OutOfRangeException e) { [EOL]         if (reference != null) { [EOL]             throw e; [EOL]         } [EOL]     } catch (NumberIsTooSmallException e) { [EOL]         if (reference != null) { [EOL]             throw e; [EOL]         } [EOL]     } catch (NoDataException e) { [EOL]         if (reference != null) { [EOL]             throw e; [EOL]         } [EOL]     } [EOL] } <line_num>: 715,740
@Test [EOL] public void testGetRowMatrix() { [EOL]     FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData); [EOL]     FieldMatrix<Fraction> mRow0 = new BlockFieldMatrix<Fraction>(subRow0); [EOL]     FieldMatrix<Fraction> mRow3 = new BlockFieldMatrix<Fraction>(subRow3); [EOL]     Assert.assertEquals("Row0", mRow0, m.getRowMatrix(0)); [EOL]     Assert.assertEquals("Row3", mRow3, m.getRowMatrix(3)); [EOL]     try { [EOL]         m.getRowMatrix(-1); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.getRowMatrix(4); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL] } <line_num>: 742,761
@Test [EOL] public void testSetRowMatrix() { [EOL]     FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData); [EOL]     FieldMatrix<Fraction> mRow3 = new BlockFieldMatrix<Fraction>(subRow3); [EOL]     Assert.assertNotSame(mRow3, m.getRowMatrix(0)); [EOL]     m.setRowMatrix(0, mRow3); [EOL]     Assert.assertEquals(mRow3, m.getRowMatrix(0)); [EOL]     try { [EOL]         m.setRowMatrix(-1, mRow3); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.setRowMatrix(0, m); [EOL]         Assert.fail("Expecting MatrixDimensionMismatchException"); [EOL]     } catch (MatrixDimensionMismatchException ex) { [EOL]     } [EOL] } <line_num>: 763,782
@Test [EOL] public void testGetSetRowMatrixLarge() { [EOL]     int n = 3 * BlockFieldMatrix.BLOCK_SIZE; [EOL]     FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n); [EOL]     FieldMatrix<Fraction> sub = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), 1, n).scalarAdd(new Fraction(1)); [EOL]     m.setRowMatrix(2, sub); [EOL]     for (int i = 0; i < n; ++i) { [EOL]         for (int j = 0; j < n; ++j) { [EOL]             if (i != 2) { [EOL]                 Assert.assertEquals(new Fraction(0), m.getEntry(i, j)); [EOL]             } else { [EOL]                 Assert.assertEquals(new Fraction(1), m.getEntry(i, j)); [EOL]             } [EOL]         } [EOL]     } [EOL]     Assert.assertEquals(sub, m.getRowMatrix(2)); [EOL] } <line_num>: 784,804
@Test [EOL] public void testGetColumnMatrix() { [EOL]     FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData); [EOL]     FieldMatrix<Fraction> mColumn1 = new BlockFieldMatrix<Fraction>(subColumn1); [EOL]     FieldMatrix<Fraction> mColumn3 = new BlockFieldMatrix<Fraction>(subColumn3); [EOL]     Assert.assertEquals(mColumn1, m.getColumnMatrix(1)); [EOL]     Assert.assertEquals(mColumn3, m.getColumnMatrix(3)); [EOL]     try { [EOL]         m.getColumnMatrix(-1); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.getColumnMatrix(4); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL] } <line_num>: 806,825
@Test [EOL] public void testSetColumnMatrix() { [EOL]     FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData); [EOL]     FieldMatrix<Fraction> mColumn3 = new BlockFieldMatrix<Fraction>(subColumn3); [EOL]     Assert.assertNotSame(mColumn3, m.getColumnMatrix(1)); [EOL]     m.setColumnMatrix(1, mColumn3); [EOL]     Assert.assertEquals(mColumn3, m.getColumnMatrix(1)); [EOL]     try { [EOL]         m.setColumnMatrix(-1, mColumn3); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.setColumnMatrix(0, m); [EOL]         Assert.fail("Expecting MatrixDimensionMismatchException"); [EOL]     } catch (MatrixDimensionMismatchException ex) { [EOL]     } [EOL] } <line_num>: 827,846
@Test [EOL] public void testGetSetColumnMatrixLarge() { [EOL]     int n = 3 * BlockFieldMatrix.BLOCK_SIZE; [EOL]     FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n); [EOL]     FieldMatrix<Fraction> sub = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, 1).scalarAdd(new Fraction(1)); [EOL]     m.setColumnMatrix(2, sub); [EOL]     for (int i = 0; i < n; ++i) { [EOL]         for (int j = 0; j < n; ++j) { [EOL]             if (j != 2) { [EOL]                 Assert.assertEquals(new Fraction(0), m.getEntry(i, j)); [EOL]             } else { [EOL]                 Assert.assertEquals(new Fraction(1), m.getEntry(i, j)); [EOL]             } [EOL]         } [EOL]     } [EOL]     Assert.assertEquals(sub, m.getColumnMatrix(2)); [EOL] } <line_num>: 848,868
@Test [EOL] public void testGetRowVector() { [EOL]     FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData); [EOL]     FieldVector<Fraction> mRow0 = new ArrayFieldVector<Fraction>(subRow0[0]); [EOL]     FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]); [EOL]     Assert.assertEquals(mRow0, m.getRowVector(0)); [EOL]     Assert.assertEquals(mRow3, m.getRowVector(3)); [EOL]     try { [EOL]         m.getRowVector(-1); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.getRowVector(4); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL] } <line_num>: 870,889
@Test [EOL] public void testSetRowVector() { [EOL]     FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData); [EOL]     FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]); [EOL]     Assert.assertNotSame(mRow3, m.getRowMatrix(0)); [EOL]     m.setRowVector(0, mRow3); [EOL]     Assert.assertEquals(mRow3, m.getRowVector(0)); [EOL]     try { [EOL]         m.setRowVector(-1, mRow3); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.setRowVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5)); [EOL]         Assert.fail("Expecting MatrixDimensionMismatchException"); [EOL]     } catch (MatrixDimensionMismatchException ex) { [EOL]     } [EOL] } <line_num>: 891,910
@Test [EOL] public void testGetSetRowVectorLarge() { [EOL]     int n = 3 * BlockFieldMatrix.BLOCK_SIZE; [EOL]     FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n); [EOL]     FieldVector<Fraction> sub = new ArrayFieldVector<Fraction>(n, new Fraction(1)); [EOL]     m.setRowVector(2, sub); [EOL]     for (int i = 0; i < n; ++i) { [EOL]         for (int j = 0; j < n; ++j) { [EOL]             if (i != 2) { [EOL]                 Assert.assertEquals(new Fraction(0), m.getEntry(i, j)); [EOL]             } else { [EOL]                 Assert.assertEquals(new Fraction(1), m.getEntry(i, j)); [EOL]             } [EOL]         } [EOL]     } [EOL]     Assert.assertEquals(sub, m.getRowVector(2)); [EOL] } <line_num>: 912,930
@Test [EOL] public void testGetColumnVector() { [EOL]     FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData); [EOL]     FieldVector<Fraction> mColumn1 = columnToVector(subColumn1); [EOL]     FieldVector<Fraction> mColumn3 = columnToVector(subColumn3); [EOL]     Assert.assertEquals(mColumn1, m.getColumnVector(1)); [EOL]     Assert.assertEquals(mColumn3, m.getColumnVector(3)); [EOL]     try { [EOL]         m.getColumnVector(-1); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.getColumnVector(4); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL] } <line_num>: 932,951
@Test [EOL] public void testSetColumnVector() { [EOL]     FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData); [EOL]     FieldVector<Fraction> mColumn3 = columnToVector(subColumn3); [EOL]     Assert.assertNotSame(mColumn3, m.getColumnVector(1)); [EOL]     m.setColumnVector(1, mColumn3); [EOL]     Assert.assertEquals(mColumn3, m.getColumnVector(1)); [EOL]     try { [EOL]         m.setColumnVector(-1, mColumn3); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.setColumnVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5)); [EOL]         Assert.fail("Expecting MatrixDimensionMismatchException"); [EOL]     } catch (MatrixDimensionMismatchException ex) { [EOL]     } [EOL] } <line_num>: 953,972
@Test [EOL] public void testGetSetColumnVectorLarge() { [EOL]     int n = 3 * BlockFieldMatrix.BLOCK_SIZE; [EOL]     FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n); [EOL]     FieldVector<Fraction> sub = new ArrayFieldVector<Fraction>(n, new Fraction(1)); [EOL]     m.setColumnVector(2, sub); [EOL]     for (int i = 0; i < n; ++i) { [EOL]         for (int j = 0; j < n; ++j) { [EOL]             if (j != 2) { [EOL]                 Assert.assertEquals(new Fraction(0), m.getEntry(i, j)); [EOL]             } else { [EOL]                 Assert.assertEquals(new Fraction(1), m.getEntry(i, j)); [EOL]             } [EOL]         } [EOL]     } [EOL]     Assert.assertEquals(sub, m.getColumnVector(2)); [EOL] } <line_num>: 974,992
private FieldVector<Fraction> columnToVector(Fraction[][] column) { [EOL]     Fraction[] data = new Fraction[column.length]; [EOL]     for (int i = 0; i < data.length; ++i) { [EOL]         data[i] = column[i][0]; [EOL]     } [EOL]     return new ArrayFieldVector<Fraction>(data, false); [EOL] } <line_num>: 994,1000
@Test [EOL] public void testGetRow() { [EOL]     FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData); [EOL]     checkArrays(subRow0[0], m.getRow(0)); [EOL]     checkArrays(subRow3[0], m.getRow(3)); [EOL]     try { [EOL]         m.getRow(-1); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.getRow(4); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL] } <line_num>: 1002,1019
@Test [EOL] public void testSetRow() { [EOL]     FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData); [EOL]     Assert.assertTrue(subRow3[0][0] != m.getRow(0)[0]); [EOL]     m.setRow(0, subRow3[0]); [EOL]     checkArrays(subRow3[0], m.getRow(0)); [EOL]     try { [EOL]         m.setRow(-1, subRow3[0]); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.setRow(0, new Fraction[5]); [EOL]         Assert.fail("Expecting MatrixDimensionMismatchException"); [EOL]     } catch (MatrixDimensionMismatchException ex) { [EOL]     } [EOL] } <line_num>: 1021,1039
@Test [EOL] public void testGetSetRowLarge() { [EOL]     int n = 3 * BlockFieldMatrix.BLOCK_SIZE; [EOL]     FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n); [EOL]     Fraction[] sub = new Fraction[n]; [EOL]     Arrays.fill(sub, new Fraction(1)); [EOL]     m.setRow(2, sub); [EOL]     for (int i = 0; i < n; ++i) { [EOL]         for (int j = 0; j < n; ++j) { [EOL]             if (i != 2) { [EOL]                 Assert.assertEquals(new Fraction(0), m.getEntry(i, j)); [EOL]             } else { [EOL]                 Assert.assertEquals(new Fraction(1), m.getEntry(i, j)); [EOL]             } [EOL]         } [EOL]     } [EOL]     checkArrays(sub, m.getRow(2)); [EOL] } <line_num>: 1041,1060
@Test [EOL] public void testGetColumn() { [EOL]     FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData); [EOL]     Fraction[] mColumn1 = columnToArray(subColumn1); [EOL]     Fraction[] mColumn3 = columnToArray(subColumn3); [EOL]     checkArrays(mColumn1, m.getColumn(1)); [EOL]     checkArrays(mColumn3, m.getColumn(3)); [EOL]     try { [EOL]         m.getColumn(-1); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.getColumn(4); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL] } <line_num>: 1062,1081
@Test [EOL] public void testSetColumn() { [EOL]     FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData); [EOL]     Fraction[] mColumn3 = columnToArray(subColumn3); [EOL]     Assert.assertTrue(mColumn3[0] != m.getColumn(1)[0]); [EOL]     m.setColumn(1, mColumn3); [EOL]     checkArrays(mColumn3, m.getColumn(1)); [EOL]     try { [EOL]         m.setColumn(-1, mColumn3); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.setColumn(0, new Fraction[5]); [EOL]         Assert.fail("Expecting MatrixDimensionMismatchException"); [EOL]     } catch (MatrixDimensionMismatchException ex) { [EOL]     } [EOL] } <line_num>: 1083,1102
@Test [EOL] public void testGetSetColumnLarge() { [EOL]     int n = 3 * BlockFieldMatrix.BLOCK_SIZE; [EOL]     FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n); [EOL]     Fraction[] sub = new Fraction[n]; [EOL]     Arrays.fill(sub, new Fraction(1)); [EOL]     m.setColumn(2, sub); [EOL]     for (int i = 0; i < n; ++i) { [EOL]         for (int j = 0; j < n; ++j) { [EOL]             if (j != 2) { [EOL]                 Assert.assertEquals(new Fraction(0), m.getEntry(i, j)); [EOL]             } else { [EOL]                 Assert.assertEquals(new Fraction(1), m.getEntry(i, j)); [EOL]             } [EOL]         } [EOL]     } [EOL]     checkArrays(sub, m.getColumn(2)); [EOL] } <line_num>: 1104,1123
private Fraction[] columnToArray(Fraction[][] column) { [EOL]     Fraction[] data = new Fraction[column.length]; [EOL]     for (int i = 0; i < data.length; ++i) { [EOL]         data[i] = column[i][0]; [EOL]     } [EOL]     return data; [EOL] } <line_num>: 1125,1131
private void checkArrays(Fraction[] expected, Fraction[] actual) { [EOL]     Assert.assertEquals(expected.length, actual.length); [EOL]     for (int i = 0; i < expected.length; ++i) { [EOL]         Assert.assertEquals(expected[i], actual[i]); [EOL]     } [EOL] } <line_num>: 1133,1138
@Test [EOL] public void testEqualsAndHashCode() { [EOL]     BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); [EOL]     BlockFieldMatrix<Fraction> m1 = (BlockFieldMatrix<Fraction>) m.copy(); [EOL]     BlockFieldMatrix<Fraction> mt = (BlockFieldMatrix<Fraction>) m.transpose(); [EOL]     Assert.assertTrue(m.hashCode() != mt.hashCode()); [EOL]     Assert.assertEquals(m.hashCode(), m1.hashCode()); [EOL]     Assert.assertEquals(m, m); [EOL]     Assert.assertEquals(m, m1); [EOL]     Assert.assertFalse(m.equals(null)); [EOL]     Assert.assertFalse(m.equals(mt)); [EOL]     Assert.assertFalse(m.equals(new BlockFieldMatrix<Fraction>(bigSingular))); [EOL] } <line_num>: 1140,1152
@Test [EOL] public void testToString() { [EOL]     BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); [EOL]     Assert.assertEquals("BlockFieldMatrix{{1,2,3},{2,5,3},{1,0,8}}", m.toString()); [EOL] } <line_num>: 1154,1158
@Test [EOL] public void testSetSubMatrix() { [EOL]     BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); [EOL]     m.setSubMatrix(detData2, 1, 1); [EOL]     FieldMatrix<Fraction> expected = new BlockFieldMatrix<Fraction>(new Fraction[][] { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(1), new Fraction(3) }, { new Fraction(1), new Fraction(2), new Fraction(4) } }); [EOL]     Assert.assertEquals(expected, m); [EOL]     m.setSubMatrix(detData2, 0, 0); [EOL]     expected = new BlockFieldMatrix<Fraction>(new Fraction[][] { { new Fraction(1), new Fraction(3), new Fraction(3) }, { new Fraction(2), new Fraction(4), new Fraction(3) }, { new Fraction(1), new Fraction(2), new Fraction(4) } }); [EOL]     Assert.assertEquals(expected, m); [EOL]     m.setSubMatrix(testDataPlus2, 0, 0); [EOL]     expected = new BlockFieldMatrix<Fraction>(new Fraction[][] { { new Fraction(3), new Fraction(4), new Fraction(5) }, { new Fraction(4), new Fraction(7), new Fraction(5) }, { new Fraction(3), new Fraction(2), new Fraction(10) } }); [EOL]     Assert.assertEquals(expected, m); [EOL]     BlockFieldMatrix<Fraction> matrix = new BlockFieldMatrix<Fraction>(new Fraction[][] { { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8) }, { new Fraction(9), new Fraction(0), new Fraction(1), new Fraction(2) } }); [EOL]     matrix.setSubMatrix(new Fraction[][] { { new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6) } }, 1, 1); [EOL]     expected = new BlockFieldMatrix<Fraction>(new Fraction[][] { { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(3), new Fraction(4), new Fraction(8) }, { new Fraction(9), new Fraction(5), new Fraction(6), new Fraction(2) } }); [EOL]     Assert.assertEquals(expected, matrix); [EOL]     try { [EOL]         m.setSubMatrix(testData, 1, 1); [EOL]         Assert.fail("expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException e) { [EOL]     } [EOL]     try { [EOL]         m.setSubMatrix(testData, -1, 1); [EOL]         Assert.fail("expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException e) { [EOL]     } [EOL]     try { [EOL]         m.setSubMatrix(testData, 1, -1); [EOL]         Assert.fail("expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException e) { [EOL]     } [EOL]     try { [EOL]         m.setSubMatrix(null, 1, 1); [EOL]         Assert.fail("expecting NullArgumentException"); [EOL]     } catch (NullArgumentException e) { [EOL]     } [EOL]     try { [EOL]         m.setSubMatrix(new Fraction[][] { { new Fraction(1) }, { new Fraction(2), new Fraction(3) } }, 0, 0); [EOL]         Assert.fail("expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         m.setSubMatrix(new Fraction[][] { {} }, 0, 0); [EOL]         Assert.fail("expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException e) { [EOL]     } [EOL] } <line_num>: 1160,1241
@Test [EOL] public void testWalk() { [EOL]     int rows = 150; [EOL]     int columns = 75; [EOL]     FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns); [EOL]     m.walkInRowOrder(new SetVisitor()); [EOL]     GetVisitor getVisitor = new GetVisitor(); [EOL]     m.walkInOptimizedOrder(getVisitor); [EOL]     Assert.assertEquals(rows * columns, getVisitor.getCount()); [EOL]     m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns); [EOL]     m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2); [EOL]     getVisitor = new GetVisitor(); [EOL]     m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2); [EOL]     Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount()); [EOL]     for (int i = 0; i < rows; ++i) { [EOL]         Assert.assertEquals(new Fraction(0), m.getEntry(i, 0)); [EOL]         Assert.assertEquals(new Fraction(0), m.getEntry(i, columns - 1)); [EOL]     } [EOL]     for (int j = 0; j < columns; ++j) { [EOL]         Assert.assertEquals(new Fraction(0), m.getEntry(0, j)); [EOL]         Assert.assertEquals(new Fraction(0), m.getEntry(rows - 1, j)); [EOL]     } [EOL]     m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns); [EOL]     m.walkInColumnOrder(new SetVisitor()); [EOL]     getVisitor = new GetVisitor(); [EOL]     m.walkInOptimizedOrder(getVisitor); [EOL]     Assert.assertEquals(rows * columns, getVisitor.getCount()); [EOL]     m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns); [EOL]     m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2); [EOL]     getVisitor = new GetVisitor(); [EOL]     m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2); [EOL]     Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount()); [EOL]     for (int i = 0; i < rows; ++i) { [EOL]         Assert.assertEquals(new Fraction(0), m.getEntry(i, 0)); [EOL]         Assert.assertEquals(new Fraction(0), m.getEntry(i, columns - 1)); [EOL]     } [EOL]     for (int j = 0; j < columns; ++j) { [EOL]         Assert.assertEquals(new Fraction(0), m.getEntry(0, j)); [EOL]         Assert.assertEquals(new Fraction(0), m.getEntry(rows - 1, j)); [EOL]     } [EOL]     m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns); [EOL]     m.walkInOptimizedOrder(new SetVisitor()); [EOL]     getVisitor = new GetVisitor(); [EOL]     m.walkInRowOrder(getVisitor); [EOL]     Assert.assertEquals(rows * columns, getVisitor.getCount()); [EOL]     m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns); [EOL]     m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2); [EOL]     getVisitor = new GetVisitor(); [EOL]     m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2); [EOL]     Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount()); [EOL]     for (int i = 0; i < rows; ++i) { [EOL]         Assert.assertEquals(new Fraction(0), m.getEntry(i, 0)); [EOL]         Assert.assertEquals(new Fraction(0), m.getEntry(i, columns - 1)); [EOL]     } [EOL]     for (int j = 0; j < columns; ++j) { [EOL]         Assert.assertEquals(new Fraction(0), m.getEntry(0, j)); [EOL]         Assert.assertEquals(new Fraction(0), m.getEntry(rows - 1, j)); [EOL]     } [EOL]     m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns); [EOL]     m.walkInOptimizedOrder(new SetVisitor()); [EOL]     getVisitor = new GetVisitor(); [EOL]     m.walkInColumnOrder(getVisitor); [EOL]     Assert.assertEquals(rows * columns, getVisitor.getCount()); [EOL]     m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns); [EOL]     m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2); [EOL]     getVisitor = new GetVisitor(); [EOL]     m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2); [EOL]     Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount()); [EOL]     for (int i = 0; i < rows; ++i) { [EOL]         Assert.assertEquals(new Fraction(0), m.getEntry(i, 0)); [EOL]         Assert.assertEquals(new Fraction(0), m.getEntry(i, columns - 1)); [EOL]     } [EOL]     for (int j = 0; j < columns; ++j) { [EOL]         Assert.assertEquals(new Fraction(0), m.getEntry(0, j)); [EOL]         Assert.assertEquals(new Fraction(0), m.getEntry(rows - 1, j)); [EOL]     } [EOL] } <line_num>: 1243,1328
@Test [EOL] public void testSerial() { [EOL]     BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); [EOL]     Assert.assertEquals(m, TestUtils.serializeAndRecover(m)); [EOL] } <line_num>: 1330,1334
@Override [EOL] public Fraction visit(int i, int j, Fraction value) { [EOL]     return new Fraction(i * 11 + j, 11); [EOL] } <line_num>: 1340,1343
@Override [EOL] public void visit(int i, int j, Fraction value) { [EOL]     ++count; [EOL]     Assert.assertEquals(new Fraction(i * 11 + j, 11), value); [EOL] } <line_num>: 1352,1356
public int getCount() { [EOL]     return count; [EOL] } <line_num>: 1357,1359
private BlockFieldMatrix<Fraction> createRandomMatrix(Random r, int rows, int columns) { [EOL]     BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns); [EOL]     for (int i = 0; i < rows; ++i) { [EOL]         for (int j = 0; j < columns; ++j) { [EOL]             int p = r.nextInt(20) - 10; [EOL]             int q = r.nextInt(20) - 10; [EOL]             if (q == 0) { [EOL]                 q = 1; [EOL]             } [EOL]             m.setEntry(i, j, new Fraction(p, q)); [EOL]         } [EOL]     } [EOL]     return m; [EOL] } <line_num>: 1362,1376
