public SparseFieldMatrixTest() { [EOL]     try { [EOL]         testDataLU = new Fraction[][] { { new Fraction(2), new Fraction(5), new Fraction(3) }, { new Fraction(.5d), new Fraction(-2.5d), new Fraction(6.5d) }, { new Fraction(0.5d), new Fraction(0.2d), new Fraction(.2d) } }; [EOL]         luDataLUDecomposition = new Fraction[][] { { new Fraction(6), new Fraction(9), new Fraction(8) }, { new Fraction(0), new Fraction(5), new Fraction(7) }, { new Fraction(0.33333333333333), new Fraction(0), new Fraction(0.33333333333333) } }; [EOL]         subTestData = new Fraction[][] { { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(1.5), new Fraction(2.5), new Fraction(3.5), new Fraction(4.5) }, { new Fraction(2), new Fraction(4), new Fraction(6), new Fraction(8) }, { new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7) } }; [EOL]         subRows31Cols31 = new Fraction[][] { { new Fraction(7), new Fraction(5) }, { new Fraction(4.5), new Fraction(2.5) } }; [EOL]         subRows01Cols23 = new Fraction[][] { { new Fraction(3), new Fraction(4) }, { new Fraction(3.5), new Fraction(4.5) } }; [EOL]         subColumn1 = new Fraction[][] { { new Fraction(2) }, { new Fraction(2.5) }, { new Fraction(4) }, { new Fraction(5) } }; [EOL]         subColumn3 = new Fraction[][] { { new Fraction(4) }, { new Fraction(4.5) }, { new Fraction(8) }, { new Fraction(7) } }; [EOL]     } catch (FractionConversionException e) { [EOL]     } [EOL] } <line_num>: 110,125
@Test [EOL] public void testDimensions() { [EOL]     SparseFieldMatrix<Fraction> m = createSparseMatrix(testData); [EOL]     SparseFieldMatrix<Fraction> m2 = createSparseMatrix(testData2); [EOL]     Assert.assertEquals("testData row dimension", 3, m.getRowDimension()); [EOL]     Assert.assertEquals("testData column dimension", 3, m.getColumnDimension()); [EOL]     Assert.assertTrue("testData is square", m.isSquare()); [EOL]     Assert.assertEquals("testData2 row dimension", m2.getRowDimension(), 2); [EOL]     Assert.assertEquals("testData2 column dimension", m2.getColumnDimension(), 3); [EOL]     Assert.assertTrue("testData2 is not square", !m2.isSquare()); [EOL] } <line_num>: 128,138
@Test [EOL] public void testCopyFunctions() { [EOL]     SparseFieldMatrix<Fraction> m1 = createSparseMatrix(testData); [EOL]     FieldMatrix<Fraction> m2 = m1.copy(); [EOL]     Assert.assertEquals(m1.getClass(), m2.getClass()); [EOL]     Assert.assertEquals((m2), m1); [EOL]     SparseFieldMatrix<Fraction> m3 = createSparseMatrix(testData); [EOL]     FieldMatrix<Fraction> m4 = m3.copy(); [EOL]     Assert.assertEquals(m3.getClass(), m4.getClass()); [EOL]     Assert.assertEquals((m4), m3); [EOL] } <line_num>: 141,151
@Test [EOL] public void testAdd() { [EOL]     SparseFieldMatrix<Fraction> m = createSparseMatrix(testData); [EOL]     SparseFieldMatrix<Fraction> mInv = createSparseMatrix(testDataInv); [EOL]     SparseFieldMatrix<Fraction> mDataPlusInv = createSparseMatrix(testDataPlusInv); [EOL]     FieldMatrix<Fraction> mPlusMInv = m.add(mInv); [EOL]     for (int row = 0; row < m.getRowDimension(); row++) { [EOL]         for (int col = 0; col < m.getColumnDimension(); col++) { [EOL]             Assert.assertEquals("sum entry entry", mDataPlusInv.getEntry(row, col).doubleValue(), mPlusMInv.getEntry(row, col).doubleValue(), entryTolerance); [EOL]         } [EOL]     } [EOL] } <line_num>: 154,167
@Test [EOL] public void testAddFail() { [EOL]     SparseFieldMatrix<Fraction> m = createSparseMatrix(testData); [EOL]     SparseFieldMatrix<Fraction> m2 = createSparseMatrix(testData2); [EOL]     try { [EOL]         m.add(m2); [EOL]         Assert.fail("MathIllegalArgumentException expected"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 170,180
@Test [EOL] public void testPlusMinus() { [EOL]     SparseFieldMatrix<Fraction> m = createSparseMatrix(testData); [EOL]     SparseFieldMatrix<Fraction> n = createSparseMatrix(testDataInv); [EOL]     assertClose("m-n = m + -n", m.subtract(n), n.scalarMultiply(new Fraction(-1)).add(m), entryTolerance); [EOL]     try { [EOL]         m.subtract(createSparseMatrix(testData2)); [EOL]         Assert.fail("Expecting illegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 184,196
@Test [EOL] public void testMultiply() { [EOL]     SparseFieldMatrix<Fraction> m = createSparseMatrix(testData); [EOL]     SparseFieldMatrix<Fraction> mInv = createSparseMatrix(testDataInv); [EOL]     SparseFieldMatrix<Fraction> identity = createSparseMatrix(id); [EOL]     SparseFieldMatrix<Fraction> m2 = createSparseMatrix(testData2); [EOL]     assertClose("inverse multiply", m.multiply(mInv), identity, entryTolerance); [EOL]     assertClose("inverse multiply", m.multiply(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testDataInv)), identity, entryTolerance); [EOL]     assertClose("inverse multiply", mInv.multiply(m), identity, entryTolerance); [EOL]     assertClose("identity multiply", m.multiply(identity), m, entryTolerance); [EOL]     assertClose("identity multiply", identity.multiply(mInv), mInv, entryTolerance); [EOL]     assertClose("identity multiply", m2.multiply(identity), m2, entryTolerance); [EOL]     try { [EOL]         m.multiply(createSparseMatrix(bigSingular)); [EOL]         Assert.fail("Expecting illegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 199,223
@Test [EOL] public void testMultiply2() { [EOL]     FieldMatrix<Fraction> m3 = createSparseMatrix(d3); [EOL]     FieldMatrix<Fraction> m4 = createSparseMatrix(d4); [EOL]     FieldMatrix<Fraction> m5 = createSparseMatrix(d5); [EOL]     assertClose("m3*m4=m5", m3.multiply(m4), m5, entryTolerance); [EOL] } <line_num>: 231,237
@Test [EOL] public void testTrace() { [EOL]     FieldMatrix<Fraction> m = createSparseMatrix(id); [EOL]     Assert.assertEquals("identity trace", 3d, m.getTrace().doubleValue(), entryTolerance); [EOL]     m = createSparseMatrix(testData2); [EOL]     try { [EOL]         m.getTrace(); [EOL]         Assert.fail("Expecting NonSquareMatrixException"); [EOL]     } catch (NonSquareMatrixException ex) { [EOL]     } [EOL] } <line_num>: 240,251
@Test [EOL] public void testScalarAdd() { [EOL]     FieldMatrix<Fraction> m = createSparseMatrix(testData); [EOL]     assertClose("scalar add", createSparseMatrix(testDataPlus2), m.scalarAdd(new Fraction(2)), entryTolerance); [EOL] } <line_num>: 254,259
@Test [EOL] public void testOperate() { [EOL]     FieldMatrix<Fraction> m = createSparseMatrix(id); [EOL]     assertClose("identity operate", testVector, m.operate(testVector), entryTolerance); [EOL]     assertClose("identity operate", testVector, m.operate(new ArrayFieldVector<Fraction>(testVector)).getData(), entryTolerance); [EOL]     m = createSparseMatrix(bigSingular); [EOL]     try { [EOL]         m.operate(testVector); [EOL]         Assert.fail("Expecting illegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 262,276
@Test [EOL] public void testMath209() { [EOL]     FieldMatrix<Fraction> a = createSparseMatrix(new Fraction[][] { { new Fraction(1), new Fraction(2) }, { new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6) } }); [EOL]     Fraction[] b = a.operate(new Fraction[] { new Fraction(1), new Fraction(1) }); [EOL]     Assert.assertEquals(a.getRowDimension(), b.length); [EOL]     Assert.assertEquals(3.0, b[0].doubleValue(), 1.0e-12); [EOL]     Assert.assertEquals(7.0, b[1].doubleValue(), 1.0e-12); [EOL]     Assert.assertEquals(11.0, b[2].doubleValue(), 1.0e-12); [EOL] } <line_num>: 279,288
@Test [EOL] public void testTranspose() { [EOL]     FieldMatrix<Fraction> m = createSparseMatrix(testData); [EOL]     FieldMatrix<Fraction> mIT = new FieldLUDecomposition<Fraction>(m).getSolver().getInverse().transpose(); [EOL]     FieldMatrix<Fraction> mTI = new FieldLUDecomposition<Fraction>(m.transpose()).getSolver().getInverse(); [EOL]     assertClose("inverse-transpose", mIT, mTI, normTolerance); [EOL]     m = createSparseMatrix(testData2); [EOL]     FieldMatrix<Fraction> mt = createSparseMatrix(testData2T); [EOL]     assertClose("transpose", mt, m.transpose(), normTolerance); [EOL] } <line_num>: 291,300
@Test [EOL] public void testPremultiplyVector() { [EOL]     FieldMatrix<Fraction> m = createSparseMatrix(testData); [EOL]     assertClose("premultiply", m.preMultiply(testVector), preMultTest, normTolerance); [EOL]     assertClose("premultiply", m.preMultiply(new ArrayFieldVector<Fraction>(testVector).getData()), preMultTest, normTolerance); [EOL]     m = createSparseMatrix(bigSingular); [EOL]     try { [EOL]         m.preMultiply(testVector); [EOL]         Assert.fail("expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 303,317
@Test [EOL] public void testPremultiply() { [EOL]     FieldMatrix<Fraction> m3 = createSparseMatrix(d3); [EOL]     FieldMatrix<Fraction> m4 = createSparseMatrix(d4); [EOL]     FieldMatrix<Fraction> m5 = createSparseMatrix(d5); [EOL]     assertClose("m3*m4=m5", m4.preMultiply(m3), m5, entryTolerance); [EOL]     SparseFieldMatrix<Fraction> m = createSparseMatrix(testData); [EOL]     SparseFieldMatrix<Fraction> mInv = createSparseMatrix(testDataInv); [EOL]     SparseFieldMatrix<Fraction> identity = createSparseMatrix(id); [EOL]     assertClose("inverse multiply", m.preMultiply(mInv), identity, entryTolerance); [EOL]     assertClose("inverse multiply", mInv.preMultiply(m), identity, entryTolerance); [EOL]     assertClose("identity multiply", m.preMultiply(identity), m, entryTolerance); [EOL]     assertClose("identity multiply", identity.preMultiply(mInv), mInv, entryTolerance); [EOL]     try { [EOL]         m.preMultiply(createSparseMatrix(bigSingular)); [EOL]         Assert.fail("Expecting illegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 319,343
@Test [EOL] public void testGetVectors() { [EOL]     FieldMatrix<Fraction> m = createSparseMatrix(testData); [EOL]     assertClose("get row", m.getRow(0), testDataRow1, entryTolerance); [EOL]     assertClose("get col", m.getColumn(2), testDataCol3, entryTolerance); [EOL]     try { [EOL]         m.getRow(10); [EOL]         Assert.fail("expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.getColumn(-1); [EOL]         Assert.fail("expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL] } <line_num>: 345,362
@Test [EOL] public void testGetEntry() { [EOL]     FieldMatrix<Fraction> m = createSparseMatrix(testData); [EOL]     Assert.assertEquals("get entry", m.getEntry(0, 1).doubleValue(), 2d, entryTolerance); [EOL]     try { [EOL]         m.getEntry(10, 4); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL] } <line_num>: 364,374
@Test [EOL] public void testExamples() { [EOL]     Fraction[][] matrixData = { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(5), new Fraction(3) } }; [EOL]     FieldMatrix<Fraction> m = createSparseMatrix(matrixData); [EOL]     Fraction[][] matrixData2 = { { new Fraction(1), new Fraction(2) }, { new Fraction(2), new Fraction(5) }, { new Fraction(1), new Fraction(7) } }; [EOL]     FieldMatrix<Fraction> n = createSparseMatrix(matrixData2); [EOL]     FieldMatrix<Fraction> p = m.multiply(n); [EOL]     Assert.assertEquals(2, p.getRowDimension()); [EOL]     Assert.assertEquals(2, p.getColumnDimension()); [EOL]     FieldMatrix<Fraction> pInverse = new FieldLUDecomposition<Fraction>(p).getSolver().getInverse(); [EOL]     Assert.assertEquals(2, pInverse.getRowDimension()); [EOL]     Assert.assertEquals(2, pInverse.getColumnDimension()); [EOL]     Fraction[][] coefficientsData = { { new Fraction(2), new Fraction(3), new Fraction(-2) }, { new Fraction(-1), new Fraction(7), new Fraction(6) }, { new Fraction(4), new Fraction(-3), new Fraction(-5) } }; [EOL]     FieldMatrix<Fraction> coefficients = createSparseMatrix(coefficientsData); [EOL]     Fraction[] constants = { new Fraction(1), new Fraction(-2), new Fraction(1) }; [EOL]     Fraction[] solution; [EOL]     solution = new FieldLUDecomposition<Fraction>(coefficients).getSolver().solve(new ArrayFieldVector<Fraction>(constants, false)).toArray(); [EOL]     Assert.assertEquals((new Fraction(2).multiply((solution[0])).add(new Fraction(3).multiply(solution[1])).subtract(new Fraction(2).multiply(solution[2]))).doubleValue(), constants[0].doubleValue(), 1E-12); [EOL]     Assert.assertEquals(((new Fraction(-1).multiply(solution[0])).add(new Fraction(7).multiply(solution[1])).add(new Fraction(6).multiply(solution[2]))).doubleValue(), constants[1].doubleValue(), 1E-12); [EOL]     Assert.assertEquals(((new Fraction(4).multiply(solution[0])).subtract(new Fraction(3).multiply(solution[1])).subtract(new Fraction(5).multiply(solution[2]))).doubleValue(), constants[2].doubleValue(), 1E-12); [EOL] } <line_num>: 377,410
@Test [EOL] public void testSubMatrix() { [EOL]     FieldMatrix<Fraction> m = createSparseMatrix(subTestData); [EOL]     FieldMatrix<Fraction> mRows23Cols00 = createSparseMatrix(subRows23Cols00); [EOL]     FieldMatrix<Fraction> mRows00Cols33 = createSparseMatrix(subRows00Cols33); [EOL]     FieldMatrix<Fraction> mRows01Cols23 = createSparseMatrix(subRows01Cols23); [EOL]     FieldMatrix<Fraction> mRows02Cols13 = createSparseMatrix(subRows02Cols13); [EOL]     FieldMatrix<Fraction> mRows03Cols12 = createSparseMatrix(subRows03Cols12); [EOL]     FieldMatrix<Fraction> mRows03Cols123 = createSparseMatrix(subRows03Cols123); [EOL]     FieldMatrix<Fraction> mRows20Cols123 = createSparseMatrix(subRows20Cols123); [EOL]     FieldMatrix<Fraction> mRows31Cols31 = createSparseMatrix(subRows31Cols31); [EOL]     Assert.assertEquals("Rows23Cols00", mRows23Cols00, m.getSubMatrix(2, 3, 0, 0)); [EOL]     Assert.assertEquals("Rows00Cols33", mRows00Cols33, m.getSubMatrix(0, 0, 3, 3)); [EOL]     Assert.assertEquals("Rows01Cols23", mRows01Cols23, m.getSubMatrix(0, 1, 2, 3)); [EOL]     Assert.assertEquals("Rows02Cols13", mRows02Cols13, m.getSubMatrix(new int[] { 0, 2 }, new int[] { 1, 3 })); [EOL]     Assert.assertEquals("Rows03Cols12", mRows03Cols12, m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2 })); [EOL]     Assert.assertEquals("Rows03Cols123", mRows03Cols123, m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2, 3 })); [EOL]     Assert.assertEquals("Rows20Cols123", mRows20Cols123, m.getSubMatrix(new int[] { 2, 0 }, new int[] { 1, 2, 3 })); [EOL]     Assert.assertEquals("Rows31Cols31", mRows31Cols31, m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 })); [EOL]     Assert.assertEquals("Rows31Cols31", mRows31Cols31, m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 })); [EOL]     try { [EOL]         m.getSubMatrix(1, 0, 2, 4); [EOL]         Assert.fail("Expecting NumberIsTooSmallException"); [EOL]     } catch (NumberIsTooSmallException ex) { [EOL]     } [EOL]     try { [EOL]         m.getSubMatrix(-1, 1, 2, 2); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.getSubMatrix(1, 0, 2, 2); [EOL]         Assert.fail("Expecting NumberIsTooSmallException"); [EOL]     } catch (NumberIsTooSmallException ex) { [EOL]     } [EOL]     try { [EOL]         m.getSubMatrix(1, 0, 2, 4); [EOL]         Assert.fail("Expecting NumberIsTooSmallException"); [EOL]     } catch (NumberIsTooSmallException ex) { [EOL]     } [EOL]     try { [EOL]         m.getSubMatrix(new int[] {}, new int[] { 0 }); [EOL]         Assert.fail("Expecting NoDataException"); [EOL]     } catch (NoDataException ex) { [EOL]     } [EOL]     try { [EOL]         m.getSubMatrix(new int[] { 0 }, new int[] { 4 }); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL] } <line_num>: 413,476
@Test [EOL] public void testGetRowMatrix() { [EOL]     FieldMatrix<Fraction> m = createSparseMatrix(subTestData); [EOL]     FieldMatrix<Fraction> mRow0 = createSparseMatrix(subRow0); [EOL]     FieldMatrix<Fraction> mRow3 = createSparseMatrix(subRow3); [EOL]     Assert.assertEquals("Row0", mRow0, m.getRowMatrix(0)); [EOL]     Assert.assertEquals("Row3", mRow3, m.getRowMatrix(3)); [EOL]     try { [EOL]         m.getRowMatrix(-1); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.getRowMatrix(4); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL] } <line_num>: 478,497
@Test [EOL] public void testGetColumnMatrix() { [EOL]     FieldMatrix<Fraction> m = createSparseMatrix(subTestData); [EOL]     FieldMatrix<Fraction> mColumn1 = createSparseMatrix(subColumn1); [EOL]     FieldMatrix<Fraction> mColumn3 = createSparseMatrix(subColumn3); [EOL]     Assert.assertEquals("Column1", mColumn1, m.getColumnMatrix(1)); [EOL]     Assert.assertEquals("Column3", mColumn3, m.getColumnMatrix(3)); [EOL]     try { [EOL]         m.getColumnMatrix(-1); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.getColumnMatrix(4); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL] } <line_num>: 499,518
@Test [EOL] public void testGetRowVector() { [EOL]     FieldMatrix<Fraction> m = createSparseMatrix(subTestData); [EOL]     FieldVector<Fraction> mRow0 = new ArrayFieldVector<Fraction>(subRow0[0]); [EOL]     FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]); [EOL]     Assert.assertEquals("Row0", mRow0, m.getRowVector(0)); [EOL]     Assert.assertEquals("Row3", mRow3, m.getRowVector(3)); [EOL]     try { [EOL]         m.getRowVector(-1); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.getRowVector(4); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL] } <line_num>: 520,539
@Test [EOL] public void testGetColumnVector() { [EOL]     FieldMatrix<Fraction> m = createSparseMatrix(subTestData); [EOL]     FieldVector<Fraction> mColumn1 = columnToVector(subColumn1); [EOL]     FieldVector<Fraction> mColumn3 = columnToVector(subColumn3); [EOL]     Assert.assertEquals("Column1", mColumn1, m.getColumnVector(1)); [EOL]     Assert.assertEquals("Column3", mColumn3, m.getColumnVector(3)); [EOL]     try { [EOL]         m.getColumnVector(-1); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.getColumnVector(4); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL] } <line_num>: 541,560
private FieldVector<Fraction> columnToVector(Fraction[][] column) { [EOL]     Fraction[] data = new Fraction[column.length]; [EOL]     for (int i = 0; i < data.length; ++i) { [EOL]         data[i] = column[i][0]; [EOL]     } [EOL]     return new ArrayFieldVector<Fraction>(data, false); [EOL] } <line_num>: 562,568
@Test [EOL] public void testEqualsAndHashCode() { [EOL]     SparseFieldMatrix<Fraction> m = createSparseMatrix(testData); [EOL]     SparseFieldMatrix<Fraction> m1 = (SparseFieldMatrix<Fraction>) m.copy(); [EOL]     SparseFieldMatrix<Fraction> mt = (SparseFieldMatrix<Fraction>) m.transpose(); [EOL]     Assert.assertTrue(m.hashCode() != mt.hashCode()); [EOL]     Assert.assertEquals(m.hashCode(), m1.hashCode()); [EOL]     Assert.assertEquals(m, m); [EOL]     Assert.assertEquals(m, m1); [EOL]     Assert.assertFalse(m.equals(null)); [EOL]     Assert.assertFalse(m.equals(mt)); [EOL]     Assert.assertFalse(m.equals(createSparseMatrix(bigSingular))); [EOL] } <line_num>: 570,582
@Test [EOL] public void testSetSubMatrix() { [EOL]     SparseFieldMatrix<Fraction> m = createSparseMatrix(testData); [EOL]     m.setSubMatrix(detData2, 1, 1); [EOL]     FieldMatrix<Fraction> expected = createSparseMatrix(new Fraction[][] { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(1), new Fraction(3) }, { new Fraction(1), new Fraction(2), new Fraction(4) } }); [EOL]     Assert.assertEquals(expected, m); [EOL]     m.setSubMatrix(detData2, 0, 0); [EOL]     expected = createSparseMatrix(new Fraction[][] { { new Fraction(1), new Fraction(3), new Fraction(3) }, { new Fraction(2), new Fraction(4), new Fraction(3) }, { new Fraction(1), new Fraction(2), new Fraction(4) } }); [EOL]     Assert.assertEquals(expected, m); [EOL]     m.setSubMatrix(testDataPlus2, 0, 0); [EOL]     expected = createSparseMatrix(new Fraction[][] { { new Fraction(3), new Fraction(4), new Fraction(5) }, { new Fraction(4), new Fraction(7), new Fraction(5) }, { new Fraction(3), new Fraction(2), new Fraction(10) } }); [EOL]     Assert.assertEquals(expected, m); [EOL]     SparseFieldMatrix<Fraction> matrix = createSparseMatrix(new Fraction[][] { { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8) }, { new Fraction(9), new Fraction(0), new Fraction(1), new Fraction(2) } }); [EOL]     matrix.setSubMatrix(new Fraction[][] { { new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6) } }, 1, 1); [EOL]     expected = createSparseMatrix(new Fraction[][] { { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(3), new Fraction(4), new Fraction(8) }, { new Fraction(9), new Fraction(5), new Fraction(6), new Fraction(2) } }); [EOL]     Assert.assertEquals(expected, matrix); [EOL]     try { [EOL]         m.setSubMatrix(testData, 1, 1); [EOL]         Assert.fail("expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException e) { [EOL]     } [EOL]     try { [EOL]         m.setSubMatrix(testData, -1, 1); [EOL]         Assert.fail("expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException e) { [EOL]     } [EOL]     try { [EOL]         m.setSubMatrix(testData, 1, -1); [EOL]         Assert.fail("expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException e) { [EOL]     } [EOL]     try { [EOL]         m.setSubMatrix(null, 1, 1); [EOL]         Assert.fail("expecting NullArgumentException"); [EOL]     } catch (NullArgumentException e) { [EOL]     } [EOL]     try { [EOL]         new SparseFieldMatrix<Fraction>(field, 0, 0); [EOL]         Assert.fail("expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         m.setSubMatrix(new Fraction[][] { { new Fraction(1) }, { new Fraction(2), new Fraction(3) } }, 0, 0); [EOL]         Assert.fail("expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         m.setSubMatrix(new Fraction[][] { {} }, 0, 0); [EOL]         Assert.fail("expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException e) { [EOL]     } [EOL] } <line_num>: 595,672
protected void assertClose(String msg, FieldMatrix<Fraction> m, FieldMatrix<Fraction> n, double tolerance) { [EOL]     for (int i = 0; i < m.getRowDimension(); i++) { [EOL]         for (int j = 0; j < m.getColumnDimension(); j++) { [EOL]             Assert.assertEquals(msg, m.getEntry(i, j).doubleValue(), n.getEntry(i, j).doubleValue(), tolerance); [EOL]         } [EOL]     } [EOL] } <line_num>: 677,685
protected void assertClose(String msg, Fraction[] m, Fraction[] n, double tolerance) { [EOL]     if (m.length != n.length) { [EOL]         Assert.fail("vectors not same length"); [EOL]     } [EOL]     for (int i = 0; i < m.length; i++) { [EOL]         Assert.assertEquals(msg + " " + i + " elements differ", m[i].doubleValue(), n[i].doubleValue(), tolerance); [EOL]     } [EOL] } <line_num>: 688,697
private SparseFieldMatrix<Fraction> createSparseMatrix(Fraction[][] data) { [EOL]     SparseFieldMatrix<Fraction> matrix = new SparseFieldMatrix<Fraction>(field, data.length, data[0].length); [EOL]     for (int row = 0; row < data.length; row++) { [EOL]         for (int col = 0; col < data[row].length; col++) { [EOL]             matrix.setEntry(row, col, data[row][col]); [EOL]         } [EOL]     } [EOL]     return matrix; [EOL] } <line_num>: 699,707
