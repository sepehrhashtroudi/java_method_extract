@Test [EOL] public void testCreateRealMatrix() { [EOL]     Assert.assertEquals(new BlockRealMatrix(testData), MatrixUtils.createRealMatrix(testData)); [EOL]     try { [EOL]         MatrixUtils.createRealMatrix(new double[][] { { 1 }, { 1, 2 } }); [EOL]         Assert.fail("Expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         MatrixUtils.createRealMatrix(new double[][] { {}, {} }); [EOL]         Assert.fail("Expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         MatrixUtils.createRealMatrix(null); [EOL]         Assert.fail("Expecting NullArgumentException"); [EOL]     } catch (NullArgumentException ex) { [EOL]     } [EOL] } <line_num>: 67,89
@Test [EOL] public void testcreateFieldMatrix() { [EOL]     Assert.assertEquals(new Array2DRowFieldMatrix<Fraction>(asFraction(testData)), MatrixUtils.createFieldMatrix(asFraction(testData))); [EOL]     Assert.assertEquals(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), fractionColMatrix), MatrixUtils.createFieldMatrix(fractionColMatrix)); [EOL]     try { [EOL]         MatrixUtils.createFieldMatrix(asFraction(new double[][] { { 1 }, { 1, 2 } })); [EOL]         Assert.fail("Expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         MatrixUtils.createFieldMatrix(asFraction(new double[][] { {}, {} })); [EOL]         Assert.fail("Expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         MatrixUtils.createFieldMatrix((Fraction[][]) null); [EOL]         Assert.fail("Expecting NullArgumentException"); [EOL]     } catch (NullArgumentException ex) { [EOL]     } [EOL] } <line_num>: 91,115
@Test [EOL] public void testCreateRowRealMatrix() { [EOL]     Assert.assertEquals(MatrixUtils.createRowRealMatrix(row), new BlockRealMatrix(rowMatrix)); [EOL]     try { [EOL]         MatrixUtils.createRowRealMatrix(new double[] {}); [EOL]         Assert.fail("Expecting NotStrictlyPositiveException"); [EOL]     } catch (NotStrictlyPositiveException ex) { [EOL]     } [EOL]     try { [EOL]         MatrixUtils.createRowRealMatrix(null); [EOL]         Assert.fail("Expecting NullArgumentException"); [EOL]     } catch (NullArgumentException ex) { [EOL]     } [EOL] } <line_num>: 117,133
@Test [EOL] public void testCreateRowFieldMatrix() { [EOL]     Assert.assertEquals(MatrixUtils.createRowFieldMatrix(asFraction(row)), new Array2DRowFieldMatrix<Fraction>(asFraction(rowMatrix))); [EOL]     Assert.assertEquals(MatrixUtils.createRowFieldMatrix(fractionRow), new Array2DRowFieldMatrix<Fraction>(fractionRowMatrix)); [EOL]     try { [EOL]         MatrixUtils.createRowFieldMatrix(new Fraction[] {}); [EOL]         Assert.fail("Expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         MatrixUtils.createRowFieldMatrix((Fraction[]) null); [EOL]         Assert.fail("Expecting NullArgumentException"); [EOL]     } catch (NullArgumentException ex) { [EOL]     } [EOL] } <line_num>: 135,153
@Test [EOL] public void testCreateColumnRealMatrix() { [EOL]     Assert.assertEquals(MatrixUtils.createColumnRealMatrix(col), new BlockRealMatrix(colMatrix)); [EOL]     try { [EOL]         MatrixUtils.createColumnRealMatrix(new double[] {}); [EOL]         Assert.fail("Expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         MatrixUtils.createColumnRealMatrix(null); [EOL]         Assert.fail("Expecting NullArgumentException"); [EOL]     } catch (NullArgumentException ex) { [EOL]     } [EOL] } <line_num>: 155,171
@Test [EOL] public void testCreateColumnFieldMatrix() { [EOL]     Assert.assertEquals(MatrixUtils.createColumnFieldMatrix(asFraction(col)), new Array2DRowFieldMatrix<Fraction>(asFraction(colMatrix))); [EOL]     Assert.assertEquals(MatrixUtils.createColumnFieldMatrix(fractionCol), new Array2DRowFieldMatrix<Fraction>(fractionColMatrix)); [EOL]     try { [EOL]         MatrixUtils.createColumnFieldMatrix(new Fraction[] {}); [EOL]         Assert.fail("Expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         MatrixUtils.createColumnFieldMatrix((Fraction[]) null); [EOL]         Assert.fail("Expecting NullArgumentException"); [EOL]     } catch (NullArgumentException ex) { [EOL]     } [EOL] } <line_num>: 173,192
protected void checkIdentityMatrix(RealMatrix m) { [EOL]     for (int i = 0; i < m.getRowDimension(); i++) { [EOL]         for (int j = 0; j < m.getColumnDimension(); j++) { [EOL]             if (i == j) { [EOL]                 Assert.assertEquals(m.getEntry(i, j), 1d, 0); [EOL]             } else { [EOL]                 Assert.assertEquals(m.getEntry(i, j), 0d, 0); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 197,207
@Test [EOL] public void testCreateIdentityMatrix() { [EOL]     checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(3)); [EOL]     checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(2)); [EOL]     checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(1)); [EOL]     try { [EOL]         MatrixUtils.createRealIdentityMatrix(0); [EOL]         Assert.fail("Expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 209,220
protected void checkIdentityFieldMatrix(FieldMatrix<Fraction> m) { [EOL]     for (int i = 0; i < m.getRowDimension(); i++) { [EOL]         for (int j = 0; j < m.getColumnDimension(); j++) { [EOL]             if (i == j) { [EOL]                 Assert.assertEquals(m.getEntry(i, j), Fraction.ONE); [EOL]             } else { [EOL]                 Assert.assertEquals(m.getEntry(i, j), Fraction.ZERO); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 225,235
@Test [EOL] public void testcreateFieldIdentityMatrix() { [EOL]     checkIdentityFieldMatrix(MatrixUtils.createFieldIdentityMatrix(FractionField.getInstance(), 3)); [EOL]     checkIdentityFieldMatrix(MatrixUtils.createFieldIdentityMatrix(FractionField.getInstance(), 2)); [EOL]     checkIdentityFieldMatrix(MatrixUtils.createFieldIdentityMatrix(FractionField.getInstance(), 1)); [EOL]     try { [EOL]         MatrixUtils.createRealIdentityMatrix(0); [EOL]         Assert.fail("Expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 237,248
@Test [EOL] public void testBigFractionConverter() { [EOL]     BigFraction[][] bfData = { { new BigFraction(1), new BigFraction(2), new BigFraction(3) }, { new BigFraction(2), new BigFraction(5), new BigFraction(3) }, { new BigFraction(1), new BigFraction(0), new BigFraction(8) } }; [EOL]     FieldMatrix<BigFraction> m = new Array2DRowFieldMatrix<BigFraction>(bfData, false); [EOL]     RealMatrix converted = MatrixUtils.bigFractionMatrixToRealMatrix(m); [EOL]     RealMatrix reference = new Array2DRowRealMatrix(testData, false); [EOL]     Assert.assertEquals(0.0, converted.subtract(reference).getNorm(), 0.0); [EOL] } <line_num>: 250,261
@Test [EOL] public void testFractionConverter() { [EOL]     Fraction[][] fData = { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(5), new Fraction(3) }, { new Fraction(1), new Fraction(0), new Fraction(8) } }; [EOL]     FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(fData, false); [EOL]     RealMatrix converted = MatrixUtils.fractionMatrixToRealMatrix(m); [EOL]     RealMatrix reference = new Array2DRowRealMatrix(testData, false); [EOL]     Assert.assertEquals(0.0, converted.subtract(reference).getNorm(), 0.0); [EOL] } <line_num>: 263,274
public static final Fraction[][] asFraction(double[][] data) { [EOL]     Fraction[][] d = new Fraction[data.length][]; [EOL]     try { [EOL]         for (int i = 0; i < data.length; ++i) { [EOL]             double[] dataI = data[i]; [EOL]             Fraction[] dI = new Fraction[dataI.length]; [EOL]             for (int j = 0; j < dataI.length; ++j) { [EOL]                 dI[j] = new Fraction(dataI[j]); [EOL]             } [EOL]             d[i] = dI; [EOL]         } [EOL]     } catch (FractionConversionException fce) { [EOL]         Assert.fail(fce.getMessage()); [EOL]     } [EOL]     return d; [EOL] } <line_num>: 276,291
public static final Fraction[] asFraction(double[] data) { [EOL]     Fraction[] d = new Fraction[data.length]; [EOL]     try { [EOL]         for (int i = 0; i < data.length; ++i) { [EOL]             d[i] = new Fraction(data[i]); [EOL]         } [EOL]     } catch (FractionConversionException fce) { [EOL]         Assert.fail(fce.getMessage()); [EOL]     } [EOL]     return d; [EOL] } <line_num>: 293,303
@Test [EOL] public void testSolveLowerTriangularSystem() { [EOL]     RealMatrix rm = new Array2DRowRealMatrix(new double[][] { { 2, 0, 0, 0 }, { 1, 1, 0, 0 }, { 3, 3, 3, 0 }, { 3, 3, 3, 4 } }, false); [EOL]     RealVector b = new ArrayRealVector(new double[] { 2, 3, 4, 8 }, false); [EOL]     MatrixUtils.solveLowerTriangularSystem(rm, b); [EOL]     TestUtils.assertEquals(new double[] { 1, 2, -1.66666666666667, 1.0 }, b.toArray(), 1.0e-12); [EOL] } <line_num>: 305,313
@Test [EOL] public void testSolveUpperTriangularSystem() { [EOL]     RealMatrix rm = new Array2DRowRealMatrix(new double[][] { { 1, 2, 3 }, { 0, 1, 1 }, { 0, 0, 2 } }, false); [EOL]     RealVector b = new ArrayRealVector(new double[] { 8, 4, 2 }, false); [EOL]     MatrixUtils.solveUpperTriangularSystem(rm, b); [EOL]     TestUtils.assertEquals(new double[] { -1, 3, 1 }, b.toArray(), 1.0e-12); [EOL] } <line_num>: 319,327
@Test [EOL] public void testBlockInverse() { [EOL]     final double[][] data = { { -1, 0, 123, 4 }, { -56, 78.9, -0.1, -23.4 }, { 5.67, 8, -9, 1011 }, { 12, 345, -67.8, 9 } }; [EOL]     final RealMatrix m = new Array2DRowRealMatrix(data); [EOL]     final int len = data.length; [EOL]     final double tol = 1e-14; [EOL]     for (int splitIndex = 0; splitIndex < 3; splitIndex++) { [EOL]         final RealMatrix mInv = MatrixUtils.blockInverse(m, splitIndex); [EOL]         final RealMatrix id = m.multiply(mInv); [EOL]         for (int i = 0; i < len; i++) { [EOL]             for (int j = 0; j < len; j++) { [EOL]                 final double entry = id.getEntry(i, j); [EOL]                 if (i == j) { [EOL]                     Assert.assertEquals("[" + i + "][" + j + "]", 1, entry, tol); [EOL]                 } else { [EOL]                     Assert.assertEquals("[" + i + "][" + j + "]", 0, entry, tol); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 334,365
@Test(expected = SingularMatrixException.class) [EOL] public void testBlockInverseNonInvertible() { [EOL]     final double[][] data = { { -1, 0, 123, 4 }, { -56, 78.9, -0.1, -23.4 }, { 5.67, 8, -9, 1011 }, { 5.67, 8, -9, 1011 } }; [EOL]     MatrixUtils.blockInverse(new Array2DRowRealMatrix(data), 2); [EOL] } <line_num>: 367,377
@Test [EOL] public void testIsSymmetric() { [EOL]     final double eps = Math.ulp(1d); [EOL]     final double[][] dataSym = { { 1, 2, 3 }, { 2, 2, 5 }, { 3, 5, 6 } }; [EOL]     Assert.assertTrue(MatrixUtils.isSymmetric(MatrixUtils.createRealMatrix(dataSym), eps)); [EOL]     final double[][] dataNonSym = { { 1, 2, -3 }, { 2, 2, 5 }, { 3, 5, 6 } }; [EOL]     Assert.assertFalse(MatrixUtils.isSymmetric(MatrixUtils.createRealMatrix(dataNonSym), eps)); [EOL] } <line_num>: 379,396
@Test [EOL] public void testIsSymmetricTolerance() { [EOL]     final double eps = 1e-4; [EOL]     final double[][] dataSym1 = { { 1, 1, 1.00009 }, { 1, 1, 1 }, { 1.0, 1, 1 } }; [EOL]     Assert.assertTrue(MatrixUtils.isSymmetric(MatrixUtils.createRealMatrix(dataSym1), eps)); [EOL]     final double[][] dataSym2 = { { 1, 1, 0.99990 }, { 1, 1, 1 }, { 1.0, 1, 1 } }; [EOL]     Assert.assertTrue(MatrixUtils.isSymmetric(MatrixUtils.createRealMatrix(dataSym2), eps)); [EOL]     final double[][] dataNonSym1 = { { 1, 1, 1.00011 }, { 1, 1, 1 }, { 1.0, 1, 1 } }; [EOL]     Assert.assertFalse(MatrixUtils.isSymmetric(MatrixUtils.createRealMatrix(dataNonSym1), eps)); [EOL]     final double[][] dataNonSym2 = { { 1, 1, 0.99989 }, { 1, 1, 1 }, { 1.0, 1, 1 } }; [EOL]     Assert.assertFalse(MatrixUtils.isSymmetric(MatrixUtils.createRealMatrix(dataNonSym2), eps)); [EOL] } <line_num>: 398,427
@Test [EOL] public void testCheckSymmetric1() { [EOL]     final double[][] dataSym = { { 1, 2, 3 }, { 2, 2, 5 }, { 3, 5, 6 } }; [EOL]     MatrixUtils.checkSymmetric(MatrixUtils.createRealMatrix(dataSym), Math.ulp(1d)); [EOL] } <line_num>: 429,437
@Test(expected = NonSymmetricMatrixException.class) [EOL] public void testCheckSymmetric2() { [EOL]     final double[][] dataNonSym = { { 1, 2, -3 }, { 2, 2, 5 }, { 3, 5, 6 } }; [EOL]     MatrixUtils.checkSymmetric(MatrixUtils.createRealMatrix(dataNonSym), Math.ulp(1d)); [EOL] } <line_num>: 439,447
