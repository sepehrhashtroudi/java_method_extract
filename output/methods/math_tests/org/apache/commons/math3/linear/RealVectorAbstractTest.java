public RealVectorAbstractTest() { [EOL]     final double x = getPreferredEntryValue(); [EOL]     final double y = x + 1d; [EOL]     final double z = y + 1d; [EOL]     values = new double[] { Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 0d, -0d, x, y, z, 2 * x, -x, 1 / x, x * x, x + y, x - y, y - x }; [EOL] } <line_num>: 170,185
public RealVectorTestImpl(double[] d) { [EOL]     data = d.clone(); [EOL] } <line_num>: 1907,1909
public abstract RealVector create(double[] data); <line_num>: 139,139
public RealVector createAlien(double[] data) { [EOL]     return new RealVectorTestImpl(data); [EOL] } <line_num>: 151,153
public double getPreferredEntryValue() { [EOL]     return 0.0; [EOL] } <line_num>: 166,168
@Test [EOL] public void testGetDimension() { [EOL]     final double x = getPreferredEntryValue(); [EOL]     final double[] data1 = { x, x, x, x }; [EOL]     Assert.assertEquals(data1.length, create(data1).getDimension()); [EOL]     final double y = x + 1; [EOL]     final double[] data2 = { y, y, y, y }; [EOL]     Assert.assertEquals(data2.length, create(data2).getDimension()); [EOL] } <line_num>: 187,195
@Test [EOL] public void testGetEntry() { [EOL]     final double x = getPreferredEntryValue(); [EOL]     final double[] data = { x, 1d, 2d, x, x }; [EOL]     final RealVector v = create(data); [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         Assert.assertEquals("entry " + i, data[i], v.getEntry(i), 0d); [EOL]     } [EOL] } <line_num>: 197,205
@Test(expected = OutOfRangeException.class) [EOL] public void testGetEntryInvalidIndex1() { [EOL]     create(new double[4]).getEntry(-1); [EOL] } <line_num>: 207,210
@Test(expected = OutOfRangeException.class) [EOL] public void testGetEntryInvalidIndex2() { [EOL]     create(new double[4]).getEntry(4); [EOL] } <line_num>: 212,215
@Test [EOL] public void testSetEntry() { [EOL]     final double x = getPreferredEntryValue(); [EOL]     final double[] data = { x, 1d, 2d, x, x }; [EOL]     final double[] expected = MathArrays.copyOf(data); [EOL]     final RealVector actual = create(data); [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         final double oldValue = data[i]; [EOL]         final double newValue = oldValue + 1d; [EOL]         expected[i] = newValue; [EOL]         actual.setEntry(i, newValue); [EOL]         TestUtils.assertEquals("while setting entry #" + i, expected, actual, 0d); [EOL]         expected[i] = oldValue; [EOL]         actual.setEntry(i, oldValue); [EOL]     } [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         final double oldValue = data[i]; [EOL]         final double newValue = x; [EOL]         expected[i] = newValue; [EOL]         actual.setEntry(i, newValue); [EOL]         TestUtils.assertEquals("while setting entry #" + i, expected, actual, 0d); [EOL]         expected[i] = oldValue; [EOL]         actual.setEntry(i, oldValue); [EOL]     } [EOL] } <line_num>: 217,251
@Test(expected = OutOfRangeException.class) [EOL] public void testSetEntryInvalidIndex1() { [EOL]     create(new double[4]).setEntry(-1, getPreferredEntryValue()); [EOL] } <line_num>: 253,256
@Test(expected = OutOfRangeException.class) [EOL] public void testSetEntryInvalidIndex2() { [EOL]     create(new double[4]).setEntry(4, getPreferredEntryValue()); [EOL] } <line_num>: 258,261
@Test [EOL] public void testAddToEntry() { [EOL]     final double x = getPreferredEntryValue(); [EOL]     final double[] data1 = { x, 1d, 2d, x, x }; [EOL]     final double[] data2 = { x, x, 3d, x, 4d, x }; [EOL]     final double[] expected = MathArrays.copyOf(data1); [EOL]     final RealVector actual = create(data1); [EOL]     double increment = 1d; [EOL]     for (int i = 0; i < data1.length; i++) { [EOL]         final double oldValue = data1[i]; [EOL]         expected[i] += increment; [EOL]         actual.addToEntry(i, increment); [EOL]         TestUtils.assertEquals("while incrementing entry #" + i, expected, actual, 0d); [EOL]         expected[i] = oldValue; [EOL]         actual.setEntry(i, oldValue); [EOL]     } [EOL]     for (int i = 0; i < data1.length; i++) { [EOL]         final double oldValue = data1[i]; [EOL]         increment = x - oldValue; [EOL]         expected[i] = x; [EOL]         actual.addToEntry(i, increment); [EOL]         TestUtils.assertEquals("while incrementing entry #" + i, expected, actual, 0d); [EOL]         expected[i] = oldValue; [EOL]         actual.setEntry(i, oldValue); [EOL]     } [EOL] } <line_num>: 263,299
@Test(expected = OutOfRangeException.class) [EOL] public void testAddToEntryInvalidIndex1() { [EOL]     create(new double[3]).addToEntry(-1, getPreferredEntryValue()); [EOL] } <line_num>: 301,304
@Test(expected = OutOfRangeException.class) [EOL] public void testAddToEntryInvalidIndex2() { [EOL]     create(new double[3]).addToEntry(4, getPreferredEntryValue()); [EOL] } <line_num>: 306,309
private void doTestAppendVector(final String message, final RealVector v1, final RealVector v2, final double delta) { [EOL]     final int n1 = v1.getDimension(); [EOL]     final int n2 = v2.getDimension(); [EOL]     final RealVector v = v1.append(v2); [EOL]     Assert.assertEquals(message, n1 + n2, v.getDimension()); [EOL]     for (int i = 0; i < n1; i++) { [EOL]         final String msg = message + ", entry #" + i; [EOL]         Assert.assertEquals(msg, v1.getEntry(i), v.getEntry(i), delta); [EOL]     } [EOL]     for (int i = 0; i < n2; i++) { [EOL]         final String msg = message + ", entry #" + (n1 + i); [EOL]         Assert.assertEquals(msg, v2.getEntry(i), v.getEntry(n1 + i), delta); [EOL]     } [EOL] } <line_num>: 311,326
@Test [EOL] public void testAppendVector() { [EOL]     final double x = getPreferredEntryValue(); [EOL]     final double[] data1 = { x, 1d, 2d, x, x }; [EOL]     final double[] data2 = { x, x, 3d, x, 4d, x }; [EOL]     doTestAppendVector("same type", create(data1), create(data2), 0d); [EOL]     doTestAppendVector("mixed types", create(data1), createAlien(data2), 0d); [EOL] } <line_num>: 328,336
private void doTestAppendScalar(final String message, final RealVector v, final double d, final double delta) { [EOL]     final int n = v.getDimension(); [EOL]     final RealVector w = v.append(d); [EOL]     Assert.assertEquals(message, n + 1, w.getDimension()); [EOL]     for (int i = 0; i < n; i++) { [EOL]         final String msg = message + ", entry #" + i; [EOL]         Assert.assertEquals(msg, v.getEntry(i), w.getEntry(i), delta); [EOL]     } [EOL]     final String msg = message + ", entry #" + n; [EOL]     Assert.assertEquals(msg, d, w.getEntry(n), delta); [EOL] } <line_num>: 338,350
@Test [EOL] public void testAppendScalar() { [EOL]     final double x = getPreferredEntryValue(); [EOL]     final double[] data = new double[] { x, 1d, 2d, x, x }; [EOL]     doTestAppendScalar("", create(data), 1d, 0d); [EOL]     doTestAppendScalar("", create(data), x, 0d); [EOL] } <line_num>: 352,359
@Test [EOL] public void testGetSubVector() { [EOL]     final double x = getPreferredEntryValue(); [EOL]     final double[] data = { x, x, x, 1d, x, 2d, x, x, 3d, x, x, x, 4d, x, x, x }; [EOL]     final int index = 1; [EOL]     final int n = data.length - 5; [EOL]     final RealVector actual = create(data).getSubVector(index, n); [EOL]     final double[] expected = new double[n]; [EOL]     System.arraycopy(data, index, expected, 0, n); [EOL]     TestUtils.assertEquals("", expected, actual, 0d); [EOL] } <line_num>: 361,371
@Test(expected = OutOfRangeException.class) [EOL] public void testGetSubVectorInvalidIndex1() { [EOL]     final int n = 10; [EOL]     create(new double[n]).getSubVector(-1, 2); [EOL] } <line_num>: 373,377
@Test(expected = OutOfRangeException.class) [EOL] public void testGetSubVectorInvalidIndex2() { [EOL]     final int n = 10; [EOL]     create(new double[n]).getSubVector(n, 2); [EOL] } <line_num>: 379,383
@Test(expected = OutOfRangeException.class) [EOL] public void testGetSubVectorInvalidIndex3() { [EOL]     final int n = 10; [EOL]     create(new double[n]).getSubVector(0, n + 1); [EOL] } <line_num>: 385,389
@Test(expected = NotPositiveException.class) [EOL] public void testGetSubVectorInvalidIndex4() { [EOL]     final int n = 10; [EOL]     create(new double[n]).getSubVector(3, -2); [EOL] } <line_num>: 391,395
@Test [EOL] public void testSetSubVectorSameType() { [EOL]     final double x = getPreferredEntryValue(); [EOL]     final double[] expected = { x, x, x, 1d, x, 2d, x, x, 3d, x, x, x, 4d, x, x, x }; [EOL]     final double[] sub = { 5d, x, 6d, 7d, 8d }; [EOL]     final RealVector actual = create(expected); [EOL]     final int index = 2; [EOL]     actual.setSubVector(index, create(sub)); [EOL]     for (int i = 0; i < sub.length; i++) { [EOL]         expected[index + i] = sub[i]; [EOL]     } [EOL]     TestUtils.assertEquals("", expected, actual, 0d); [EOL] } <line_num>: 397,410
@Test [EOL] public void testSetSubVectorMixedType() { [EOL]     final double x = getPreferredEntryValue(); [EOL]     final double[] expected = { x, x, x, 1d, x, 2d, x, x, 3d, x, x, x, 4d, x, x, x }; [EOL]     final double[] sub = { 5d, x, 6d, 7d, 8d }; [EOL]     final RealVector actual = create(expected); [EOL]     final int index = 2; [EOL]     actual.setSubVector(index, createAlien(sub)); [EOL]     for (int i = 0; i < sub.length; i++) { [EOL]         expected[index + i] = sub[i]; [EOL]     } [EOL]     TestUtils.assertEquals("", expected, actual, 0d); [EOL] } <line_num>: 412,425
@Test(expected = OutOfRangeException.class) [EOL] public void testSetSubVectorInvalidIndex1() { [EOL]     create(new double[10]).setSubVector(-1, create(new double[2])); [EOL] } <line_num>: 427,430
@Test(expected = OutOfRangeException.class) [EOL] public void testSetSubVectorInvalidIndex2() { [EOL]     create(new double[10]).setSubVector(10, create(new double[2])); [EOL] } <line_num>: 432,435
@Test(expected = OutOfRangeException.class) [EOL] public void testSetSubVectorInvalidIndex3() { [EOL]     create(new double[10]).setSubVector(9, create(new double[2])); [EOL] } <line_num>: 437,440
@Test [EOL] public void testIsNaN() { [EOL]     final RealVector v = create(new double[] { 0, 1, 2 }); [EOL]     Assert.assertFalse(v.isNaN()); [EOL]     v.setEntry(1, Double.NaN); [EOL]     Assert.assertTrue(v.isNaN()); [EOL] } <line_num>: 442,449
@Test [EOL] public void testIsInfinite() { [EOL]     final RealVector v = create(new double[] { 0, 1, 2 }); [EOL]     Assert.assertFalse(v.isInfinite()); [EOL]     v.setEntry(0, Double.POSITIVE_INFINITY); [EOL]     Assert.assertTrue(v.isInfinite()); [EOL]     v.setEntry(1, Double.NaN); [EOL]     Assert.assertFalse(v.isInfinite()); [EOL] } <line_num>: 451,460
private void doTestEbeBinaryOperation(final BinaryOperation op, final boolean mixed) { [EOL]     final double[] data1 = new double[values.length * values.length]; [EOL]     final double[] data2 = new double[values.length * values.length]; [EOL]     int k = 0; [EOL]     for (int i = 0; i < values.length; i++) { [EOL]         for (int j = 0; j < values.length; j++) { [EOL]             data1[k] = values[i]; [EOL]             data2[k] = values[j]; [EOL]             ++k; [EOL]         } [EOL]     } [EOL]     final RealVector v1 = create(data1); [EOL]     final RealVector v2 = mixed ? createAlien(data2) : create(data2); [EOL]     final RealVector actual; [EOL]     switch(op) { [EOL]         case ADD: [EOL]             actual = v1.add(v2); [EOL]             break; [EOL]         case SUB: [EOL]             actual = v1.subtract(v2); [EOL]             break; [EOL]         case MUL: [EOL]             actual = v1.ebeMultiply(v2); [EOL]             break; [EOL]         case DIV: [EOL]             actual = v1.ebeDivide(v2); [EOL]             break; [EOL]         default: [EOL]             throw new AssertionError("unexpected value"); [EOL]     } [EOL]     final double[] expected = new double[data1.length]; [EOL]     for (int i = 0; i < expected.length; i++) { [EOL]         switch(op) { [EOL]             case ADD: [EOL]                 expected[i] = data1[i] + data2[i]; [EOL]                 break; [EOL]             case SUB: [EOL]                 expected[i] = data1[i] - data2[i]; [EOL]                 break; [EOL]             case MUL: [EOL]                 expected[i] = data1[i] * data2[i]; [EOL]                 break; [EOL]             case DIV: [EOL]                 expected[i] = data1[i] / data2[i]; [EOL]                 break; [EOL]             default: [EOL]                 throw new AssertionError("unexpected value"); [EOL]         } [EOL]     } [EOL]     for (int i = 0; i < expected.length; i++) { [EOL]         final String msg = "entry #" + i + ", left = " + data1[i] + ", right = " + data2[i]; [EOL]         Assert.assertEquals(msg, expected[i], actual.getEntry(i), 0.0); [EOL]     } [EOL] } <line_num>: 462,515
private void doTestEbeBinaryOperationDimensionMismatch(final BinaryOperation op) { [EOL]     final int n = 10; [EOL]     switch(op) { [EOL]         case ADD: [EOL]             create(new double[n]).add(create(new double[n + 1])); [EOL]             break; [EOL]         case SUB: [EOL]             create(new double[n]).subtract(create(new double[n + 1])); [EOL]             break; [EOL]         case MUL: [EOL]             create(new double[n]).ebeMultiply(create(new double[n + 1])); [EOL]             break; [EOL]         case DIV: [EOL]             create(new double[n]).ebeDivide(create(new double[n + 1])); [EOL]             break; [EOL]         default: [EOL]             throw new AssertionError("unexpected value"); [EOL]     } [EOL] } <line_num>: 517,535
@Test [EOL] public void testAddSameType() { [EOL]     doTestEbeBinaryOperation(BinaryOperation.ADD, false); [EOL] } <line_num>: 537,540
@Test [EOL] public void testAddMixedTypes() { [EOL]     doTestEbeBinaryOperation(BinaryOperation.ADD, true); [EOL] } <line_num>: 542,545
@Test(expected = DimensionMismatchException.class) [EOL] public void testAddDimensionMismatch() { [EOL]     doTestEbeBinaryOperationDimensionMismatch(BinaryOperation.ADD); [EOL] } <line_num>: 547,550
@Test [EOL] public void testSubtractSameType() { [EOL]     doTestEbeBinaryOperation(BinaryOperation.SUB, false); [EOL] } <line_num>: 552,555
@Test [EOL] public void testSubtractMixedTypes() { [EOL]     doTestEbeBinaryOperation(BinaryOperation.SUB, true); [EOL] } <line_num>: 557,560
@Test(expected = DimensionMismatchException.class) [EOL] public void testSubtractDimensionMismatch() { [EOL]     doTestEbeBinaryOperationDimensionMismatch(BinaryOperation.SUB); [EOL] } <line_num>: 562,565
@Ignore("ebeMultiply(RealVector) is known to be faulty (MATH-803) and is deprecated.") [EOL] @Test [EOL] public void testEbeMultiplySameType() { [EOL]     doTestEbeBinaryOperation(BinaryOperation.MUL, false); [EOL] } <line_num>: 567,571
@Ignore("ebeMultiply(RealVector) is known to be faulty (MATH-803) and is deprecated.") [EOL] @Test [EOL] public void testEbeMultiplyMixedTypes() { [EOL]     doTestEbeBinaryOperation(BinaryOperation.MUL, true); [EOL] } <line_num>: 573,577
@Ignore("ebeMultiply(RealVector) is known to be faulty (MATH-803) and is deprecated.") [EOL] @Test(expected = DimensionMismatchException.class) [EOL] public void testEbeMultiplyDimensionMismatch() { [EOL]     doTestEbeBinaryOperationDimensionMismatch(BinaryOperation.MUL); [EOL] } <line_num>: 579,583
@Ignore("ebeDivide(RealVector) is known to be faulty (MATH-803) and is deprecated.") [EOL] @Test [EOL] public void testEbeDivideSameType() { [EOL]     doTestEbeBinaryOperation(BinaryOperation.DIV, false); [EOL] } <line_num>: 585,589
@Ignore("ebeDivide(RealVector) is known to be faulty (MATH-803) and is deprecated.") [EOL] @Test [EOL] public void testEbeDivideMixedTypes() { [EOL]     doTestEbeBinaryOperation(BinaryOperation.DIV, true); [EOL] } <line_num>: 591,595
@Ignore("ebeDivide(RealVector) is known to be faulty (MATH-803) and is deprecated.") [EOL] @Test(expected = DimensionMismatchException.class) [EOL] public void testEbeDivideDimensionMismatch() { [EOL]     doTestEbeBinaryOperationDimensionMismatch(BinaryOperation.DIV); [EOL] } <line_num>: 597,601
private void doTestGetDistance(final boolean mixed) { [EOL]     final double x = getPreferredEntryValue(); [EOL]     final double[] data1 = new double[] { x, x, 1d, x, 2d, x, x, 3d, x }; [EOL]     final double[] data2 = new double[] { 4d, x, x, 5d, 6d, 7d, x, x, 8d }; [EOL]     final RealVector v1 = create(data1); [EOL]     final RealVector v2; [EOL]     if (mixed) { [EOL]         v2 = createAlien(data2); [EOL]     } else { [EOL]         v2 = create(data2); [EOL]     } [EOL]     final double actual = v1.getDistance(v2); [EOL]     double expected = 0d; [EOL]     for (int i = 0; i < data1.length; i++) { [EOL]         final double delta = data2[i] - data1[i]; [EOL]         expected += delta * delta; [EOL]     } [EOL]     expected = FastMath.sqrt(expected); [EOL]     Assert.assertEquals("", expected, actual, 0d); [EOL] } <line_num>: 603,622
@Test [EOL] public void testGetDistanceSameType() { [EOL]     doTestGetDistance(false); [EOL] } <line_num>: 624,627
@Test [EOL] public void testGetDistanceMixedTypes() { [EOL]     doTestGetDistance(true); [EOL] } <line_num>: 629,632
@Test(expected = DimensionMismatchException.class) [EOL] public void testGetDistanceDimensionMismatch() { [EOL]     create(new double[4]).getDistance(createAlien(new double[5])); [EOL] } <line_num>: 634,637
@Test [EOL] public void testGetNorm() { [EOL]     final double x = getPreferredEntryValue(); [EOL]     final double[] data = new double[] { x, x, 1d, x, 2d, x, x, 3d, x }; [EOL]     final RealVector v = create(data); [EOL]     final double actual = v.getNorm(); [EOL]     double expected = 0d; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         expected += data[i] * data[i]; [EOL]     } [EOL]     expected = FastMath.sqrt(expected); [EOL]     Assert.assertEquals("", expected, actual, 0d); [EOL] } <line_num>: 639,651
private void doTestGetL1Distance(final boolean mixed) { [EOL]     final double x = getPreferredEntryValue(); [EOL]     final double[] data1 = new double[] { x, x, 1d, x, 2d, x, x, 3d, x }; [EOL]     final double[] data2 = new double[] { 4d, x, x, 5d, 6d, 7d, x, x, 8d }; [EOL]     final RealVector v1 = create(data1); [EOL]     final RealVector v2; [EOL]     if (mixed) { [EOL]         v2 = createAlien(data2); [EOL]     } else { [EOL]         v2 = create(data2); [EOL]     } [EOL]     final double actual = v1.getL1Distance(v2); [EOL]     double expected = 0d; [EOL]     for (int i = 0; i < data1.length; i++) { [EOL]         final double delta = data2[i] - data1[i]; [EOL]         expected += FastMath.abs(delta); [EOL]     } [EOL]     Assert.assertEquals("", expected, actual, 0d); [EOL] } <line_num>: 653,671
@Test [EOL] public void testGetL1DistanceSameType() { [EOL]     doTestGetL1Distance(false); [EOL] } <line_num>: 673,676
@Test [EOL] public void testGetL1DistanceMixedTypes() { [EOL]     doTestGetL1Distance(true); [EOL] } <line_num>: 678,681
@Test(expected = DimensionMismatchException.class) [EOL] public void testGetL1DistanceDimensionMismatch() { [EOL]     create(new double[4]).getL1Distance(createAlien(new double[5])); [EOL] } <line_num>: 683,686
@Test [EOL] public void testGetL1Norm() { [EOL]     final double x = getPreferredEntryValue(); [EOL]     final double[] data = new double[] { x, x, 1d, x, 2d, x, x, 3d, x }; [EOL]     final RealVector v = create(data); [EOL]     final double actual = v.getL1Norm(); [EOL]     double expected = 0d; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         expected += FastMath.abs(data[i]); [EOL]     } [EOL]     Assert.assertEquals("", expected, actual, 0d); [EOL] } <line_num>: 688,700
private void doTestGetLInfDistance(final boolean mixed) { [EOL]     final double x = getPreferredEntryValue(); [EOL]     final double[] data1 = new double[] { x, x, 1d, x, 2d, x, x, 3d, x }; [EOL]     final double[] data2 = new double[] { 4d, x, x, 5d, 6d, 7d, x, x, 8d }; [EOL]     final RealVector v1 = create(data1); [EOL]     final RealVector v2; [EOL]     if (mixed) { [EOL]         v2 = createAlien(data2); [EOL]     } else { [EOL]         v2 = create(data2); [EOL]     } [EOL]     final double actual = v1.getLInfDistance(v2); [EOL]     double expected = 0d; [EOL]     for (int i = 0; i < data1.length; i++) { [EOL]         final double delta = data2[i] - data1[i]; [EOL]         expected = FastMath.max(expected, FastMath.abs(delta)); [EOL]     } [EOL]     Assert.assertEquals("", expected, actual, 0d); [EOL] } <line_num>: 702,720
@Test [EOL] public void testGetLInfDistanceSameType() { [EOL]     doTestGetLInfDistance(false); [EOL] } <line_num>: 722,725
@Test [EOL] public void testGetLInfDistanceMixedTypes() { [EOL]     doTestGetLInfDistance(true); [EOL] } <line_num>: 727,730
@Test(expected = DimensionMismatchException.class) [EOL] public void testGetLInfDistanceDimensionMismatch() { [EOL]     create(new double[4]).getLInfDistance(createAlien(new double[5])); [EOL] } <line_num>: 732,735
@Test [EOL] public void testGetLInfNorm() { [EOL]     final double x = getPreferredEntryValue(); [EOL]     final double[] data = new double[] { x, x, 1d, x, 2d, x, x, 3d, x }; [EOL]     final RealVector v = create(data); [EOL]     final double actual = v.getLInfNorm(); [EOL]     double expected = 0d; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         expected = FastMath.max(expected, FastMath.abs(data[i])); [EOL]     } [EOL]     Assert.assertEquals("", expected, actual, 0d); [EOL] } <line_num>: 737,749
private void doTestMapBinaryOperation(final BinaryOperation op, final boolean inPlace) { [EOL]     final double[] expected = new double[values.length]; [EOL]     for (int i = 0; i < values.length; i++) { [EOL]         final double d = values[i]; [EOL]         for (int j = 0; j < expected.length; j++) { [EOL]             switch(op) { [EOL]                 case ADD: [EOL]                     expected[j] = values[j] + d; [EOL]                     break; [EOL]                 case SUB: [EOL]                     expected[j] = values[j] - d; [EOL]                     break; [EOL]                 case MUL: [EOL]                     expected[j] = values[j] * d; [EOL]                     break; [EOL]                 case DIV: [EOL]                     expected[j] = values[j] / d; [EOL]                     break; [EOL]                 default: [EOL]                     throw new AssertionError("unexpected value"); [EOL]             } [EOL]         } [EOL]         final RealVector v = create(values); [EOL]         final RealVector actual; [EOL]         if (inPlace) { [EOL]             switch(op) { [EOL]                 case ADD: [EOL]                     actual = v.mapAddToSelf(d); [EOL]                     break; [EOL]                 case SUB: [EOL]                     actual = v.mapSubtractToSelf(d); [EOL]                     break; [EOL]                 case MUL: [EOL]                     actual = v.mapMultiplyToSelf(d); [EOL]                     break; [EOL]                 case DIV: [EOL]                     actual = v.mapDivideToSelf(d); [EOL]                     break; [EOL]                 default: [EOL]                     throw new AssertionError("unexpected value"); [EOL]             } [EOL]         } else { [EOL]             switch(op) { [EOL]                 case ADD: [EOL]                     actual = v.mapAdd(d); [EOL]                     break; [EOL]                 case SUB: [EOL]                     actual = v.mapSubtract(d); [EOL]                     break; [EOL]                 case MUL: [EOL]                     actual = v.mapMultiply(d); [EOL]                     break; [EOL]                 case DIV: [EOL]                     actual = v.mapDivide(d); [EOL]                     break; [EOL]                 default: [EOL]                     throw new AssertionError("unexpected value"); [EOL]             } [EOL]         } [EOL]         TestUtils.assertEquals(Double.toString(d), expected, actual, 0d); [EOL]     } [EOL] } <line_num>: 751,812
@Test [EOL] public void testMapAdd() { [EOL]     doTestMapBinaryOperation(BinaryOperation.ADD, false); [EOL] } <line_num>: 814,817
@Test [EOL] public void testMapAddToSelf() { [EOL]     doTestMapBinaryOperation(BinaryOperation.ADD, true); [EOL] } <line_num>: 819,822
@Test [EOL] public void testMapSubtract() { [EOL]     doTestMapBinaryOperation(BinaryOperation.SUB, false); [EOL] } <line_num>: 824,827
@Test [EOL] public void testMapSubtractToSelf() { [EOL]     doTestMapBinaryOperation(BinaryOperation.SUB, true); [EOL] } <line_num>: 829,832
@Test [EOL] public void testMapMultiply() { [EOL]     doTestMapBinaryOperation(BinaryOperation.MUL, false); [EOL] } <line_num>: 834,837
@Test [EOL] public void testMapMultiplyToSelf() { [EOL]     doTestMapBinaryOperation(BinaryOperation.MUL, true); [EOL] } <line_num>: 839,842
@Test [EOL] public void testMapDivide() { [EOL]     doTestMapBinaryOperation(BinaryOperation.DIV, false); [EOL] } <line_num>: 844,847
@Test [EOL] public void testMapDivideToSelf() { [EOL]     doTestMapBinaryOperation(BinaryOperation.DIV, true); [EOL] } <line_num>: 849,852
private void doTestMapFunction(final UnivariateFunction f, final boolean inPlace) { [EOL]     final double[] data = new double[values.length + 6]; [EOL]     System.arraycopy(values, 0, data, 0, values.length); [EOL]     data[values.length + 0] = 0.5 * FastMath.PI; [EOL]     data[values.length + 1] = -0.5 * FastMath.PI; [EOL]     data[values.length + 2] = FastMath.E; [EOL]     data[values.length + 3] = -FastMath.E; [EOL]     data[values.length + 4] = 1.0; [EOL]     data[values.length + 5] = -1.0; [EOL]     final double[] expected = new double[data.length]; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         expected[i] = f.value(data[i]); [EOL]     } [EOL]     final RealVector v = create(data); [EOL]     final RealVector actual; [EOL]     if (inPlace) { [EOL]         actual = v.mapToSelf(f); [EOL]         Assert.assertSame(v, actual); [EOL]     } else { [EOL]         actual = v.map(f); [EOL]     } [EOL]     TestUtils.assertEquals(f.getClass().getSimpleName(), expected, actual, 1E-16); [EOL] } <line_num>: 854,877
private UnivariateFunction[] createFunctions() { [EOL]     return new UnivariateFunction[] { new Power(2.0), new Exp(), new Expm1(), new Log(), new Log10(), new Log1p(), new Cosh(), new Sinh(), new Tanh(), new Cos(), new Sin(), new Tan(), new Acos(), new Asin(), new Atan(), new Inverse(), new Abs(), new Sqrt(), new Cbrt(), new Ceil(), new Floor(), new Rint(), new Signum(), new Ulp() }; [EOL] } <line_num>: 879,887
@Test [EOL] public void testMap() { [EOL]     final UnivariateFunction[] functions = createFunctions(); [EOL]     for (UnivariateFunction f : functions) { [EOL]         doTestMapFunction(f, false); [EOL]     } [EOL] } <line_num>: 889,895
@Test [EOL] public void testMapToSelf() { [EOL]     final UnivariateFunction[] functions = createFunctions(); [EOL]     for (UnivariateFunction f : functions) { [EOL]         doTestMapFunction(f, true); [EOL]     } [EOL] } <line_num>: 897,903
private void doTestOuterProduct(final boolean mixed) { [EOL]     final double[] dataU = values; [EOL]     final RealVector u = create(dataU); [EOL]     final double[] dataV = new double[values.length + 3]; [EOL]     System.arraycopy(values, 0, dataV, 0, values.length); [EOL]     dataV[values.length] = 1d; [EOL]     dataV[values.length] = -2d; [EOL]     dataV[values.length] = 3d; [EOL]     final RealVector v; [EOL]     if (mixed) { [EOL]         v = createAlien(dataV); [EOL]     } else { [EOL]         v = create(dataV); [EOL]     } [EOL]     final RealMatrix uv = u.outerProduct(v); [EOL]     Assert.assertEquals("number of rows", dataU.length, uv.getRowDimension()); [EOL]     Assert.assertEquals("number of columns", dataV.length, uv.getColumnDimension()); [EOL]     for (int i = 0; i < dataU.length; i++) { [EOL]         for (int j = 0; j < dataV.length; j++) { [EOL]             final double expected = dataU[i] * dataV[j]; [EOL]             final double actual = uv.getEntry(i, j); [EOL]             Assert.assertEquals(dataU[i] + " * " + dataV[j], expected, actual, 0d); [EOL]         } [EOL]     } [EOL] } <line_num>: 905,931
@Test [EOL] public void testOuterProductSameType() { [EOL]     doTestOuterProduct(false); [EOL] } <line_num>: 933,936
@Test [EOL] public void testOuterProductMixedTypes() { [EOL]     doTestOuterProduct(true); [EOL] } <line_num>: 938,941
private void doTestProjection(final boolean mixed) { [EOL]     final double x = getPreferredEntryValue(); [EOL]     final double[] data1 = { x, 1d, x, x, 2d, x, x, x, 3d, x, x, x, x }; [EOL]     final double[] data2 = { 5d, -6d, 7d, x, x, -8d, -9d, 10d, 11d, x, 12d, 13d, -15d }; [EOL]     double dotProduct = 0d; [EOL]     double norm2 = 0d; [EOL]     for (int i = 0; i < data1.length; i++) { [EOL]         dotProduct += data1[i] * data2[i]; [EOL]         norm2 += data2[i] * data2[i]; [EOL]     } [EOL]     final double s = dotProduct / norm2; [EOL]     final double[] expected = new double[data1.length]; [EOL]     for (int i = 0; i < data2.length; i++) { [EOL]         expected[i] = s * data2[i]; [EOL]     } [EOL]     final RealVector v1 = create(data1); [EOL]     final RealVector v2; [EOL]     if (mixed) { [EOL]         v2 = createAlien(data2); [EOL]     } else { [EOL]         v2 = create(data2); [EOL]     } [EOL]     final RealVector actual = v1.projection(v2); [EOL]     TestUtils.assertEquals("", expected, actual, 0d); [EOL] } <line_num>: 943,971
@Test [EOL] public void testProjectionSameType() { [EOL]     doTestProjection(false); [EOL] } <line_num>: 973,976
@Test [EOL] public void testProjectionMixedTypes() { [EOL]     doTestProjection(true); [EOL] } <line_num>: 978,981
@Test(expected = MathArithmeticException.class) [EOL] public void testProjectionNullVector() { [EOL]     create(new double[4]).projection(create(new double[4])); [EOL] } <line_num>: 983,986
@Test(expected = DimensionMismatchException.class) [EOL] public void testProjectionDimensionMismatch() { [EOL]     final RealVector v1 = create(new double[4]); [EOL]     final RealVector v2 = create(new double[5]); [EOL]     v2.set(1.0); [EOL]     v1.projection(v2); [EOL] } <line_num>: 988,994
@Test [EOL] public void testSet() { [EOL]     for (int i = 0; i < values.length; i++) { [EOL]         final double expected = values[i]; [EOL]         final RealVector v = create(values); [EOL]         v.set(expected); [EOL]         for (int j = 0; j < values.length; j++) { [EOL]             Assert.assertEquals("entry #" + j, expected, v.getEntry(j), 0); [EOL]         } [EOL]     } [EOL] } <line_num>: 996,1006
@Test [EOL] public void testToArray() { [EOL]     final double[] data = create(values).toArray(); [EOL]     Assert.assertNotSame(values, data); [EOL]     for (int i = 0; i < values.length; i++) { [EOL]         Assert.assertEquals("entry #" + i, values[i], data[i], 0); [EOL]     } [EOL] } <line_num>: 1008,1015
private void doTestUnitVector(final boolean inPlace) { [EOL]     final double x = getPreferredEntryValue(); [EOL]     final double[] data = { x, 1d, x, x, 2d, x, x, x, 3d, x, x, x, x }; [EOL]     double norm = 0d; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         norm += data[i] * data[i]; [EOL]     } [EOL]     norm = FastMath.sqrt(norm); [EOL]     final double[] expected = new double[data.length]; [EOL]     for (int i = 0; i < expected.length; i++) { [EOL]         expected[i] = data[i] / norm; [EOL]     } [EOL]     final RealVector v = create(data); [EOL]     final RealVector actual; [EOL]     if (inPlace) { [EOL]         v.unitize(); [EOL]         actual = v; [EOL]     } else { [EOL]         actual = v.unitVector(); [EOL]         Assert.assertNotSame(v, actual); [EOL]     } [EOL]     TestUtils.assertEquals("", expected, actual, 0d); [EOL] } <line_num>: 1017,1041
@Test [EOL] public void testUnitVector() { [EOL]     doTestUnitVector(false); [EOL] } <line_num>: 1043,1046
@Test [EOL] public void testUnitize() { [EOL]     doTestUnitVector(true); [EOL] } <line_num>: 1048,1051
private void doTestUnitVectorNullVector(final boolean inPlace) { [EOL]     final double[] data = { 0d, 0d, 0d, 0d, 0d }; [EOL]     if (inPlace) { [EOL]         create(data).unitize(); [EOL]     } else { [EOL]         create(data).unitVector(); [EOL]     } [EOL] } <line_num>: 1053,1062
@Test(expected = ArithmeticException.class) [EOL] public void testUnitVectorNullVector() { [EOL]     doTestUnitVectorNullVector(false); [EOL] } <line_num>: 1064,1067
@Test(expected = ArithmeticException.class) [EOL] public void testUnitizeNullVector() { [EOL]     doTestUnitVectorNullVector(true); [EOL] } <line_num>: 1069,1072
@Test [EOL] public void testIterator() { [EOL]     final RealVector v = create(values); [EOL]     final Iterator<RealVector.Entry> it = v.iterator(); [EOL]     for (int i = 0; i < values.length; i++) { [EOL]         Assert.assertTrue("entry #" + i, it.hasNext()); [EOL]         final RealVector.Entry e = it.next(); [EOL]         Assert.assertEquals("", i, e.getIndex()); [EOL]         Assert.assertEquals("", values[i], e.getValue(), 0d); [EOL]         try { [EOL]             it.remove(); [EOL]             Assert.fail("UnsupportedOperationException should have been thrown"); [EOL]         } catch (UnsupportedOperationException exc) { [EOL]         } [EOL]     } [EOL]     Assert.assertFalse(it.hasNext()); [EOL]     try { [EOL]         it.next(); [EOL]         Assert.fail("NoSuchElementException should have been thrown"); [EOL]     } catch (NoSuchElementException e) { [EOL]     } [EOL] } <line_num>: 1074,1097
private void doTestCombine(final boolean inPlace, final boolean mixed) { [EOL]     final int n = values.length * values.length; [EOL]     final double[] data1 = new double[n]; [EOL]     final double[] data2 = new double[n]; [EOL]     for (int i = 0; i < values.length; i++) { [EOL]         for (int j = 0; j < values.length; j++) { [EOL]             final int index = values.length * i + j; [EOL]             data1[index] = values[i]; [EOL]             data2[index] = values[j]; [EOL]         } [EOL]     } [EOL]     final RealVector v1 = create(data1); [EOL]     final RealVector v2 = mixed ? createAlien(data2) : create(data2); [EOL]     final double[] expected = new double[n]; [EOL]     for (int i = 0; i < values.length; i++) { [EOL]         final double a1 = values[i]; [EOL]         for (int j = 0; j < values.length; j++) { [EOL]             final double a2 = values[j]; [EOL]             for (int k = 0; k < n; k++) { [EOL]                 expected[k] = a1 * data1[k] + a2 * data2[k]; [EOL]             } [EOL]             final RealVector actual; [EOL]             if (inPlace) { [EOL]                 final RealVector v1bis = v1.copy(); [EOL]                 actual = v1bis.combineToSelf(a1, a2, v2); [EOL]                 Assert.assertSame(v1bis, actual); [EOL]             } else { [EOL]                 actual = v1.combine(a1, a2, v2); [EOL]             } [EOL]             TestUtils.assertEquals("a1 = " + a1 + ", a2 = " + a2, expected, actual, 0.); [EOL]         } [EOL]     } [EOL] } <line_num>: 1099,1132
private void doTestCombineDimensionMismatch(final boolean inPlace, final boolean mixed) { [EOL]     final RealVector v1 = create(new double[10]); [EOL]     final RealVector v2; [EOL]     if (mixed) { [EOL]         v2 = createAlien(new double[15]); [EOL]     } else { [EOL]         v2 = create(new double[15]); [EOL]     } [EOL]     if (inPlace) { [EOL]         v1.combineToSelf(1.0, 1.0, v2); [EOL]     } else { [EOL]         v1.combine(1.0, 1.0, v2); [EOL]     } [EOL] } <line_num>: 1134,1147
@Test [EOL] public void testCombineSameType() { [EOL]     doTestCombine(false, false); [EOL] } <line_num>: 1149,1152
@Test [EOL] public void testCombineMixedTypes() { [EOL]     doTestCombine(false, true); [EOL] } <line_num>: 1154,1157
@Test(expected = DimensionMismatchException.class) [EOL] public void testCombineDimensionMismatchSameType() { [EOL]     doTestCombineDimensionMismatch(false, false); [EOL] } <line_num>: 1159,1162
@Test(expected = DimensionMismatchException.class) [EOL] public void testCombineDimensionMismatchMixedTypes() { [EOL]     doTestCombineDimensionMismatch(false, true); [EOL] } <line_num>: 1164,1167
@Test [EOL] public void testCombineToSelfSameType() { [EOL]     doTestCombine(true, false); [EOL] } <line_num>: 1169,1172
@Test [EOL] public void testCombineToSelfMixedTypes() { [EOL]     doTestCombine(true, true); [EOL] } <line_num>: 1174,1177
@Test(expected = DimensionMismatchException.class) [EOL] public void testCombineToSelfDimensionMismatchSameType() { [EOL]     doTestCombineDimensionMismatch(true, false); [EOL] } <line_num>: 1179,1182
@Test(expected = DimensionMismatchException.class) [EOL] public void testCombineToSelfDimensionMismatchMixedTypes() { [EOL]     doTestCombineDimensionMismatch(true, true); [EOL] } <line_num>: 1184,1187
@Test [EOL] public void testCopy() { [EOL]     final RealVector v = create(values); [EOL]     final RealVector w = v.copy(); [EOL]     Assert.assertNotSame(v, w); [EOL]     TestUtils.assertEquals("", values, w, 0d); [EOL] } <line_num>: 1189,1195
private void doTestDotProductRegularValues(final boolean mixed) { [EOL]     final double x = getPreferredEntryValue(); [EOL]     final double[] data1 = { x, 1d, x, x, 2d, x, x, x, 3d, x, x, x, x }; [EOL]     final double[] data2 = { 5d, -6d, 7d, x, x, -8d, -9d, 10d, 11d, x, 12d, 13d, -15d }; [EOL]     double expected = 0d; [EOL]     for (int i = 0; i < data1.length; i++) { [EOL]         expected += data1[i] * data2[i]; [EOL]     } [EOL]     final RealVector v1 = create(data1); [EOL]     final RealVector v2; [EOL]     if (mixed) { [EOL]         v2 = createAlien(data2); [EOL]     } else { [EOL]         v2 = create(data2); [EOL]     } [EOL]     final double actual = v1.dotProduct(v2); [EOL]     Assert.assertEquals("", expected, actual, 0d); [EOL] } <line_num>: 1197,1218
private void doTestDotProductSpecialValues(final boolean mixed) { [EOL]     for (int i = 0; i < values.length; i++) { [EOL]         final double[] data1 = { values[i] }; [EOL]         final RealVector v1 = create(data1); [EOL]         for (int j = 0; j < values.length; j++) { [EOL]             final double[] data2 = { values[j] }; [EOL]             final RealVector v2; [EOL]             if (mixed) { [EOL]                 v2 = createAlien(data2); [EOL]             } else { [EOL]                 v2 = create(data2); [EOL]             } [EOL]             final double expected = data1[0] * data2[0]; [EOL]             final double actual = v1.dotProduct(v2); [EOL]             Assert.assertEquals(data1[0] + " * " + data2[0], expected, actual, 0d); [EOL]         } [EOL]     } [EOL] } <line_num>: 1220,1242
private void doTestDotProductDimensionMismatch(final boolean mixed) { [EOL]     final double[] data1 = new double[10]; [EOL]     final double[] data2 = new double[data1.length + 1]; [EOL]     final RealVector v1 = create(data1); [EOL]     final RealVector v2; [EOL]     if (mixed) { [EOL]         v2 = createAlien(data2); [EOL]     } else { [EOL]         v2 = create(data2); [EOL]     } [EOL]     v1.dotProduct(v2); [EOL] } <line_num>: 1244,1255
@Test [EOL] public void testDotProductSameType() { [EOL]     doTestDotProductRegularValues(false); [EOL]     doTestDotProductSpecialValues(false); [EOL] } <line_num>: 1257,1261
@Test(expected = DimensionMismatchException.class) [EOL] public void testDotProductDimensionMismatchSameType() { [EOL]     doTestDotProductDimensionMismatch(false); [EOL] } <line_num>: 1263,1266
@Test [EOL] public void testDotProductMixedTypes() { [EOL]     doTestDotProductRegularValues(true); [EOL]     doTestDotProductSpecialValues(true); [EOL] } <line_num>: 1268,1272
@Test(expected = DimensionMismatchException.class) [EOL] public void testDotProductDimensionMismatchMixedTypes() { [EOL]     doTestDotProductDimensionMismatch(true); [EOL] } <line_num>: 1274,1277
private void doTestCosine(final boolean mixed) { [EOL]     final double x = getPreferredEntryValue(); [EOL]     final double[] data1 = { x, 1d, x, x, 2d, x, x, x, 3d, x, x, x, x }; [EOL]     final double[] data2 = { 5d, -6d, 7d, x, x, -8d, -9d, 10d, 11d, x, 12d, 13d, -15d }; [EOL]     double norm1 = 0d; [EOL]     double norm2 = 0d; [EOL]     double dotProduct = 0d; [EOL]     for (int i = 0; i < data1.length; i++) { [EOL]         norm1 += data1[i] * data1[i]; [EOL]         norm2 += data2[i] * data2[i]; [EOL]         dotProduct += data1[i] * data2[i]; [EOL]     } [EOL]     norm1 = FastMath.sqrt(norm1); [EOL]     norm2 = FastMath.sqrt(norm2); [EOL]     final double expected = dotProduct / (norm1 * norm2); [EOL]     final RealVector v1 = create(data1); [EOL]     final RealVector v2; [EOL]     if (mixed) { [EOL]         v2 = createAlien(data2); [EOL]     } else { [EOL]         v2 = create(data2); [EOL]     } [EOL]     final double actual = v1.cosine(v2); [EOL]     Assert.assertEquals("", expected, actual, 0d); [EOL] } <line_num>: 1279,1308
@Test [EOL] public void testCosineSameType() { [EOL]     doTestCosine(false); [EOL] } <line_num>: 1310,1313
@Test [EOL] public void testCosineMixedTypes() { [EOL]     doTestCosine(true); [EOL] } <line_num>: 1315,1318
@Test(expected = MathArithmeticException.class) [EOL] public void testCosineLeftNullVector() { [EOL]     final RealVector v = create(new double[] { 0, 0, 0 }); [EOL]     final RealVector w = create(new double[] { 1, 0, 0 }); [EOL]     v.cosine(w); [EOL] } <line_num>: 1320,1325
@Test(expected = MathArithmeticException.class) [EOL] public void testCosineRightNullVector() { [EOL]     final RealVector v = create(new double[] { 0, 0, 0 }); [EOL]     final RealVector w = create(new double[] { 1, 0, 0 }); [EOL]     w.cosine(v); [EOL] } <line_num>: 1327,1332
@Test(expected = DimensionMismatchException.class) [EOL] public void testCosineDimensionMismatch() { [EOL]     final RealVector v = create(new double[] { 1, 2, 3 }); [EOL]     final RealVector w = create(new double[] { 1, 2, 3, 4 }); [EOL]     v.cosine(w); [EOL] } <line_num>: 1334,1339
@Test [EOL] public void testEquals() { [EOL]     final RealVector v = create(new double[] { 0, 1, 2 }); [EOL]     Assert.assertTrue(v.equals(v)); [EOL]     Assert.assertTrue(v.equals(v.copy())); [EOL]     Assert.assertFalse(v.equals(null)); [EOL]     Assert.assertFalse(v.equals(v.getSubVector(0, v.getDimension() - 1))); [EOL]     Assert.assertTrue(v.equals(v.getSubVector(0, v.getDimension()))); [EOL] } <line_num>: 1341,1350
@Test [EOL] public void testSerial() { [EOL]     RealVector v = create(new double[] { 0, 1, 2 }); [EOL]     Assert.assertEquals(v, TestUtils.serializeAndRecover(v)); [EOL] } <line_num>: 1352,1356
@Test [EOL] public void testMinMax() { [EOL]     final RealVector v1 = create(new double[] { 0, -6, 4, 12, 7 }); [EOL]     Assert.assertEquals(1, v1.getMinIndex()); [EOL]     Assert.assertEquals(-6, v1.getMinValue(), 1.0e-12); [EOL]     Assert.assertEquals(3, v1.getMaxIndex()); [EOL]     Assert.assertEquals(12, v1.getMaxValue(), 1.0e-12); [EOL]     final RealVector v2 = create(new double[] { Double.NaN, 3, Double.NaN, -2 }); [EOL]     Assert.assertEquals(3, v2.getMinIndex()); [EOL]     Assert.assertEquals(-2, v2.getMinValue(), 1.0e-12); [EOL]     Assert.assertEquals(1, v2.getMaxIndex()); [EOL]     Assert.assertEquals(3, v2.getMaxValue(), 1.0e-12); [EOL]     final RealVector v3 = create(new double[] { Double.NaN, Double.NaN }); [EOL]     Assert.assertEquals(-1, v3.getMinIndex()); [EOL]     Assert.assertTrue(Double.isNaN(v3.getMinValue())); [EOL]     Assert.assertEquals(-1, v3.getMaxIndex()); [EOL]     Assert.assertTrue(Double.isNaN(v3.getMaxValue())); [EOL]     final RealVector v4 = create(new double[0]); [EOL]     Assert.assertEquals(-1, v4.getMinIndex()); [EOL]     Assert.assertTrue(Double.isNaN(v4.getMinValue())); [EOL]     Assert.assertEquals(-1, v4.getMaxIndex()); [EOL]     Assert.assertTrue(Double.isNaN(v4.getMaxValue())); [EOL] } <line_num>: 1358,1380
public void visit(final int actualIndex, final double actualValue) { [EOL]     Assert.assertEquals(expectedIndex, actualIndex); [EOL]     Assert.assertEquals(Integer.toString(actualIndex), data[actualIndex], actualValue, 0d); [EOL]     ++expectedIndex; [EOL] } <line_num>: 1398,1403
public void start(final int actualSize, final int actualStart, final int actualEnd) { [EOL]     Assert.assertEquals(data.length, actualSize); [EOL]     Assert.assertEquals(0, actualStart); [EOL]     Assert.assertEquals(data.length - 1, actualEnd); [EOL]     expectedIndex = 0; [EOL] } <line_num>: 1405,1411
public double end() { [EOL]     return 0.0; [EOL] } <line_num>: 1413,1415
@Test [EOL] public void testWalkInDefaultOrderPreservingVisitor1() { [EOL]     final double[] data = new double[] { 0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d }; [EOL]     final RealVector v = create(data); [EOL]     final RealVectorPreservingVisitor visitor; [EOL]     visitor = new RealVectorPreservingVisitor() { [EOL]  [EOL]         private int expectedIndex; [EOL]  [EOL]         public void visit(final int actualIndex, final double actualValue) { [EOL]             Assert.assertEquals(expectedIndex, actualIndex); [EOL]             Assert.assertEquals(Integer.toString(actualIndex), data[actualIndex], actualValue, 0d); [EOL]             ++expectedIndex; [EOL]         } [EOL]  [EOL]         public void start(final int actualSize, final int actualStart, final int actualEnd) { [EOL]             Assert.assertEquals(data.length, actualSize); [EOL]             Assert.assertEquals(0, actualStart); [EOL]             Assert.assertEquals(data.length - 1, actualEnd); [EOL]             expectedIndex = 0; [EOL]         } [EOL]  [EOL]         public double end() { [EOL]             return 0.0; [EOL]         } [EOL]     }; [EOL]     v.walkInDefaultOrder(visitor); [EOL] } <line_num>: 1387,1418
public void visit(int index, double value) { [EOL] } <line_num>: 1427,1429
public void start(int dimension, int start, int end) { [EOL] } <line_num>: 1431,1433
public double end() { [EOL]     return 0.0; [EOL] } <line_num>: 1435,1437
@Test [EOL] public void testWalkInDefaultOrderPreservingVisitor2() { [EOL]     final RealVector v = create(new double[5]); [EOL]     final RealVectorPreservingVisitor visitor; [EOL]     visitor = new RealVectorPreservingVisitor() { [EOL]  [EOL]         public void visit(int index, double value) { [EOL]         } [EOL]  [EOL]         public void start(int dimension, int start, int end) { [EOL]         } [EOL]  [EOL]         public double end() { [EOL]             return 0.0; [EOL]         } [EOL]     }; [EOL]     try { [EOL]         v.walkInDefaultOrder(visitor, -1, 4); [EOL]         Assert.fail(); [EOL]     } catch (OutOfRangeException e) { [EOL]     } [EOL]     try { [EOL]         v.walkInDefaultOrder(visitor, 5, 4); [EOL]         Assert.fail(); [EOL]     } catch (OutOfRangeException e) { [EOL]     } [EOL]     try { [EOL]         v.walkInDefaultOrder(visitor, 0, -1); [EOL]         Assert.fail(); [EOL]     } catch (OutOfRangeException e) { [EOL]     } [EOL]     try { [EOL]         v.walkInDefaultOrder(visitor, 0, 5); [EOL]         Assert.fail(); [EOL]     } catch (OutOfRangeException e) { [EOL]     } [EOL]     try { [EOL]         v.walkInDefaultOrder(visitor, 4, 0); [EOL]         Assert.fail(); [EOL]     } catch (NumberIsTooSmallException e) { [EOL]     } [EOL] } <line_num>: 1421,1469
public void visit(final int actualIndex, final double actualValue) { [EOL]     Assert.assertEquals(expectedIndex, actualIndex); [EOL]     Assert.assertEquals(Integer.toString(actualIndex), data[actualIndex], actualValue, 0d); [EOL]     ++expectedIndex; [EOL] } <line_num>: 1485,1490
public void start(final int actualSize, final int actualStart, final int actualEnd) { [EOL]     Assert.assertEquals(data.length, actualSize); [EOL]     Assert.assertEquals(expectedStart, actualStart); [EOL]     Assert.assertEquals(expectedEnd, actualEnd); [EOL]     expectedIndex = expectedStart; [EOL] } <line_num>: 1492,1498
public double end() { [EOL]     return 0.0; [EOL] } <line_num>: 1500,1502
@Test [EOL] public void testWalkInDefaultOrderPreservingVisitor3() { [EOL]     final double[] data = new double[] { 0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d }; [EOL]     final int expectedStart = 2; [EOL]     final int expectedEnd = 7; [EOL]     final RealVector v = create(data); [EOL]     final RealVectorPreservingVisitor visitor; [EOL]     visitor = new RealVectorPreservingVisitor() { [EOL]  [EOL]         private int expectedIndex; [EOL]  [EOL]         public void visit(final int actualIndex, final double actualValue) { [EOL]             Assert.assertEquals(expectedIndex, actualIndex); [EOL]             Assert.assertEquals(Integer.toString(actualIndex), data[actualIndex], actualValue, 0d); [EOL]             ++expectedIndex; [EOL]         } [EOL]  [EOL]         public void start(final int actualSize, final int actualStart, final int actualEnd) { [EOL]             Assert.assertEquals(data.length, actualSize); [EOL]             Assert.assertEquals(expectedStart, actualStart); [EOL]             Assert.assertEquals(expectedEnd, actualEnd); [EOL]             expectedIndex = expectedStart; [EOL]         } [EOL]  [EOL]         public double end() { [EOL]             return 0.0; [EOL]         } [EOL]     }; [EOL]     v.walkInDefaultOrder(visitor, expectedStart, expectedEnd); [EOL] } <line_num>: 1472,1505
public void visit(final int actualIndex, final double actualValue) { [EOL]     visited[actualIndex] = true; [EOL]     Assert.assertEquals(Integer.toString(actualIndex), data[actualIndex], actualValue, 0d); [EOL] } <line_num>: 1518,1522
public void start(final int actualSize, final int actualStart, final int actualEnd) { [EOL]     Assert.assertEquals(data.length, actualSize); [EOL]     Assert.assertEquals(0, actualStart); [EOL]     Assert.assertEquals(data.length - 1, actualEnd); [EOL]     Arrays.fill(visited, false); [EOL] } <line_num>: 1524,1530
public double end() { [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         Assert.assertTrue("entry " + i + "has not been visited", visited[i]); [EOL]     } [EOL]     return 0.0; [EOL] } <line_num>: 1532,1538
@Test [EOL] public void testWalkInOptimizedOrderPreservingVisitor1() { [EOL]     final double[] data = new double[] { 0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d }; [EOL]     final RealVector v = create(data); [EOL]     final RealVectorPreservingVisitor visitor; [EOL]     visitor = new RealVectorPreservingVisitor() { [EOL]  [EOL]         private final boolean[] visited = new boolean[data.length]; [EOL]  [EOL]         public void visit(final int actualIndex, final double actualValue) { [EOL]             visited[actualIndex] = true; [EOL]             Assert.assertEquals(Integer.toString(actualIndex), data[actualIndex], actualValue, 0d); [EOL]         } [EOL]  [EOL]         public void start(final int actualSize, final int actualStart, final int actualEnd) { [EOL]             Assert.assertEquals(data.length, actualSize); [EOL]             Assert.assertEquals(0, actualStart); [EOL]             Assert.assertEquals(data.length - 1, actualEnd); [EOL]             Arrays.fill(visited, false); [EOL]         } [EOL]  [EOL]         public double end() { [EOL]             for (int i = 0; i < data.length; i++) { [EOL]                 Assert.assertTrue("entry " + i + "has not been visited", visited[i]); [EOL]             } [EOL]             return 0.0; [EOL]         } [EOL]     }; [EOL]     v.walkInOptimizedOrder(visitor); [EOL] } <line_num>: 1508,1541
public void visit(int index, double value) { [EOL] } <line_num>: 1550,1552
public void start(int dimension, int start, int end) { [EOL] } <line_num>: 1554,1556
public double end() { [EOL]     return 0.0; [EOL] } <line_num>: 1558,1560
@Test [EOL] public void testWalkInOptimizedOrderPreservingVisitor2() { [EOL]     final RealVector v = create(new double[5]); [EOL]     final RealVectorPreservingVisitor visitor; [EOL]     visitor = new RealVectorPreservingVisitor() { [EOL]  [EOL]         public void visit(int index, double value) { [EOL]         } [EOL]  [EOL]         public void start(int dimension, int start, int end) { [EOL]         } [EOL]  [EOL]         public double end() { [EOL]             return 0.0; [EOL]         } [EOL]     }; [EOL]     try { [EOL]         v.walkInOptimizedOrder(visitor, -1, 4); [EOL]         Assert.fail(); [EOL]     } catch (OutOfRangeException e) { [EOL]     } [EOL]     try { [EOL]         v.walkInOptimizedOrder(visitor, 5, 4); [EOL]         Assert.fail(); [EOL]     } catch (OutOfRangeException e) { [EOL]     } [EOL]     try { [EOL]         v.walkInOptimizedOrder(visitor, 0, -1); [EOL]         Assert.fail(); [EOL]     } catch (OutOfRangeException e) { [EOL]     } [EOL]     try { [EOL]         v.walkInOptimizedOrder(visitor, 0, 5); [EOL]         Assert.fail(); [EOL]     } catch (OutOfRangeException e) { [EOL]     } [EOL]     try { [EOL]         v.walkInOptimizedOrder(visitor, 4, 0); [EOL]         Assert.fail(); [EOL]     } catch (NumberIsTooSmallException e) { [EOL]     } [EOL] } <line_num>: 1544,1592
public void visit(final int actualIndex, final double actualValue) { [EOL]     Assert.assertEquals(Integer.toString(actualIndex), data[actualIndex], actualValue, 0d); [EOL]     visited[actualIndex] = true; [EOL] } <line_num>: 1607,1611
public void start(final int actualSize, final int actualStart, final int actualEnd) { [EOL]     Assert.assertEquals(data.length, actualSize); [EOL]     Assert.assertEquals(expectedStart, actualStart); [EOL]     Assert.assertEquals(expectedEnd, actualEnd); [EOL]     Arrays.fill(visited, true); [EOL] } <line_num>: 1613,1619
public double end() { [EOL]     for (int i = expectedStart; i <= expectedEnd; i++) { [EOL]         Assert.assertTrue("entry " + i + "has not been visited", visited[i]); [EOL]     } [EOL]     return 0.0; [EOL] } <line_num>: 1621,1627
@Test [EOL] public void testWalkInOptimizedOrderPreservingVisitor3() { [EOL]     final double[] data = new double[] { 0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d }; [EOL]     final int expectedStart = 2; [EOL]     final int expectedEnd = 7; [EOL]     final RealVector v = create(data); [EOL]     final RealVectorPreservingVisitor visitor; [EOL]     visitor = new RealVectorPreservingVisitor() { [EOL]  [EOL]         private final boolean[] visited = new boolean[data.length]; [EOL]  [EOL]         public void visit(final int actualIndex, final double actualValue) { [EOL]             Assert.assertEquals(Integer.toString(actualIndex), data[actualIndex], actualValue, 0d); [EOL]             visited[actualIndex] = true; [EOL]         } [EOL]  [EOL]         public void start(final int actualSize, final int actualStart, final int actualEnd) { [EOL]             Assert.assertEquals(data.length, actualSize); [EOL]             Assert.assertEquals(expectedStart, actualStart); [EOL]             Assert.assertEquals(expectedEnd, actualEnd); [EOL]             Arrays.fill(visited, true); [EOL]         } [EOL]  [EOL]         public double end() { [EOL]             for (int i = expectedStart; i <= expectedEnd; i++) { [EOL]                 Assert.assertTrue("entry " + i + "has not been visited", visited[i]); [EOL]             } [EOL]             return 0.0; [EOL]         } [EOL]     }; [EOL]     v.walkInOptimizedOrder(visitor, expectedStart, expectedEnd); [EOL] } <line_num>: 1595,1630
public double visit(final int actualIndex, final double actualValue) { [EOL]     Assert.assertEquals(expectedIndex, actualIndex); [EOL]     Assert.assertEquals(Integer.toString(actualIndex), data[actualIndex], actualValue, 0d); [EOL]     ++expectedIndex; [EOL]     return actualIndex + actualValue; [EOL] } <line_num>: 1644,1650
public void start(final int actualSize, final int actualStart, final int actualEnd) { [EOL]     Assert.assertEquals(data.length, actualSize); [EOL]     Assert.assertEquals(0, actualStart); [EOL]     Assert.assertEquals(data.length - 1, actualEnd); [EOL]     expectedIndex = 0; [EOL] } <line_num>: 1652,1658
public double end() { [EOL]     return 0.0; [EOL] } <line_num>: 1660,1662
@Test [EOL] public void testWalkInDefaultOrderChangingVisitor1() { [EOL]     final double[] data = new double[] { 0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d }; [EOL]     final RealVector v = create(data); [EOL]     final RealVectorChangingVisitor visitor; [EOL]     visitor = new RealVectorChangingVisitor() { [EOL]  [EOL]         private int expectedIndex; [EOL]  [EOL]         public double visit(final int actualIndex, final double actualValue) { [EOL]             Assert.assertEquals(expectedIndex, actualIndex); [EOL]             Assert.assertEquals(Integer.toString(actualIndex), data[actualIndex], actualValue, 0d); [EOL]             ++expectedIndex; [EOL]             return actualIndex + actualValue; [EOL]         } [EOL]  [EOL]         public void start(final int actualSize, final int actualStart, final int actualEnd) { [EOL]             Assert.assertEquals(data.length, actualSize); [EOL]             Assert.assertEquals(0, actualStart); [EOL]             Assert.assertEquals(data.length - 1, actualEnd); [EOL]             expectedIndex = 0; [EOL]         } [EOL]  [EOL]         public double end() { [EOL]             return 0.0; [EOL]         } [EOL]     }; [EOL]     v.walkInDefaultOrder(visitor); [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         Assert.assertEquals("entry " + i, i + data[i], v.getEntry(i), 0.0); [EOL]     } [EOL] } <line_num>: 1633,1668
public double visit(int index, double value) { [EOL]     return 0.0; [EOL] } <line_num>: 1677,1679
public void start(int dimension, int start, int end) { [EOL] } <line_num>: 1681,1683
public double end() { [EOL]     return 0.0; [EOL] } <line_num>: 1685,1687
@Test [EOL] public void testWalkInDefaultOrderChangingVisitor2() { [EOL]     final RealVector v = create(new double[5]); [EOL]     final RealVectorChangingVisitor visitor; [EOL]     visitor = new RealVectorChangingVisitor() { [EOL]  [EOL]         public double visit(int index, double value) { [EOL]             return 0.0; [EOL]         } [EOL]  [EOL]         public void start(int dimension, int start, int end) { [EOL]         } [EOL]  [EOL]         public double end() { [EOL]             return 0.0; [EOL]         } [EOL]     }; [EOL]     try { [EOL]         v.walkInDefaultOrder(visitor, -1, 4); [EOL]         Assert.fail(); [EOL]     } catch (OutOfRangeException e) { [EOL]     } [EOL]     try { [EOL]         v.walkInDefaultOrder(visitor, 5, 4); [EOL]         Assert.fail(); [EOL]     } catch (OutOfRangeException e) { [EOL]     } [EOL]     try { [EOL]         v.walkInDefaultOrder(visitor, 0, -1); [EOL]         Assert.fail(); [EOL]     } catch (OutOfRangeException e) { [EOL]     } [EOL]     try { [EOL]         v.walkInDefaultOrder(visitor, 0, 5); [EOL]         Assert.fail(); [EOL]     } catch (OutOfRangeException e) { [EOL]     } [EOL]     try { [EOL]         v.walkInDefaultOrder(visitor, 4, 0); [EOL]         Assert.fail(); [EOL]     } catch (NumberIsTooSmallException e) { [EOL]     } [EOL] } <line_num>: 1671,1719
public double visit(final int actualIndex, final double actualValue) { [EOL]     Assert.assertEquals(expectedIndex, actualIndex); [EOL]     Assert.assertEquals(Integer.toString(actualIndex), data[actualIndex], actualValue, 0d); [EOL]     ++expectedIndex; [EOL]     return actualIndex + actualValue; [EOL] } <line_num>: 1735,1741
public void start(final int actualSize, final int actualStart, final int actualEnd) { [EOL]     Assert.assertEquals(data.length, actualSize); [EOL]     Assert.assertEquals(expectedStart, actualStart); [EOL]     Assert.assertEquals(expectedEnd, actualEnd); [EOL]     expectedIndex = expectedStart; [EOL] } <line_num>: 1743,1749
public double end() { [EOL]     return 0.0; [EOL] } <line_num>: 1751,1753
@Test [EOL] public void testWalkInDefaultOrderChangingVisitor3() { [EOL]     final double[] data = new double[] { 0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d }; [EOL]     final int expectedStart = 2; [EOL]     final int expectedEnd = 7; [EOL]     final RealVector v = create(data); [EOL]     final RealVectorChangingVisitor visitor; [EOL]     visitor = new RealVectorChangingVisitor() { [EOL]  [EOL]         private int expectedIndex; [EOL]  [EOL]         public double visit(final int actualIndex, final double actualValue) { [EOL]             Assert.assertEquals(expectedIndex, actualIndex); [EOL]             Assert.assertEquals(Integer.toString(actualIndex), data[actualIndex], actualValue, 0d); [EOL]             ++expectedIndex; [EOL]             return actualIndex + actualValue; [EOL]         } [EOL]  [EOL]         public void start(final int actualSize, final int actualStart, final int actualEnd) { [EOL]             Assert.assertEquals(data.length, actualSize); [EOL]             Assert.assertEquals(expectedStart, actualStart); [EOL]             Assert.assertEquals(expectedEnd, actualEnd); [EOL]             expectedIndex = expectedStart; [EOL]         } [EOL]  [EOL]         public double end() { [EOL]             return 0.0; [EOL]         } [EOL]     }; [EOL]     v.walkInDefaultOrder(visitor, expectedStart, expectedEnd); [EOL]     for (int i = expectedStart; i <= expectedEnd; i++) { [EOL]         Assert.assertEquals("entry " + i, i + data[i], v.getEntry(i), 0.0); [EOL]     } [EOL] } <line_num>: 1722,1759
public double visit(final int actualIndex, final double actualValue) { [EOL]     visited[actualIndex] = true; [EOL]     Assert.assertEquals(Integer.toString(actualIndex), data[actualIndex], actualValue, 0d); [EOL]     return actualIndex + actualValue; [EOL] } <line_num>: 1772,1777
public void start(final int actualSize, final int actualStart, final int actualEnd) { [EOL]     Assert.assertEquals(data.length, actualSize); [EOL]     Assert.assertEquals(0, actualStart); [EOL]     Assert.assertEquals(data.length - 1, actualEnd); [EOL]     Arrays.fill(visited, false); [EOL] } <line_num>: 1779,1785
public double end() { [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         Assert.assertTrue("entry " + i + "has not been visited", visited[i]); [EOL]     } [EOL]     return 0.0; [EOL] } <line_num>: 1787,1793
@Test [EOL] public void testWalkInOptimizedOrderChangingVisitor1() { [EOL]     final double[] data = new double[] { 0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d }; [EOL]     final RealVector v = create(data); [EOL]     final RealVectorChangingVisitor visitor; [EOL]     visitor = new RealVectorChangingVisitor() { [EOL]  [EOL]         private final boolean[] visited = new boolean[data.length]; [EOL]  [EOL]         public double visit(final int actualIndex, final double actualValue) { [EOL]             visited[actualIndex] = true; [EOL]             Assert.assertEquals(Integer.toString(actualIndex), data[actualIndex], actualValue, 0d); [EOL]             return actualIndex + actualValue; [EOL]         } [EOL]  [EOL]         public void start(final int actualSize, final int actualStart, final int actualEnd) { [EOL]             Assert.assertEquals(data.length, actualSize); [EOL]             Assert.assertEquals(0, actualStart); [EOL]             Assert.assertEquals(data.length - 1, actualEnd); [EOL]             Arrays.fill(visited, false); [EOL]         } [EOL]  [EOL]         public double end() { [EOL]             for (int i = 0; i < data.length; i++) { [EOL]                 Assert.assertTrue("entry " + i + "has not been visited", visited[i]); [EOL]             } [EOL]             return 0.0; [EOL]         } [EOL]     }; [EOL]     v.walkInOptimizedOrder(visitor); [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         Assert.assertEquals("entry " + i, i + data[i], v.getEntry(i), 0.0); [EOL]     } [EOL] } <line_num>: 1762,1799
public double visit(int index, double value) { [EOL]     return 0.0; [EOL] } <line_num>: 1808,1810
public void start(int dimension, int start, int end) { [EOL] } <line_num>: 1812,1814
public double end() { [EOL]     return 0.0; [EOL] } <line_num>: 1816,1818
@Test [EOL] public void testWalkInOptimizedOrderChangingVisitor2() { [EOL]     final RealVector v = create(new double[5]); [EOL]     final RealVectorChangingVisitor visitor; [EOL]     visitor = new RealVectorChangingVisitor() { [EOL]  [EOL]         public double visit(int index, double value) { [EOL]             return 0.0; [EOL]         } [EOL]  [EOL]         public void start(int dimension, int start, int end) { [EOL]         } [EOL]  [EOL]         public double end() { [EOL]             return 0.0; [EOL]         } [EOL]     }; [EOL]     try { [EOL]         v.walkInOptimizedOrder(visitor, -1, 4); [EOL]         Assert.fail(); [EOL]     } catch (OutOfRangeException e) { [EOL]     } [EOL]     try { [EOL]         v.walkInOptimizedOrder(visitor, 5, 4); [EOL]         Assert.fail(); [EOL]     } catch (OutOfRangeException e) { [EOL]     } [EOL]     try { [EOL]         v.walkInOptimizedOrder(visitor, 0, -1); [EOL]         Assert.fail(); [EOL]     } catch (OutOfRangeException e) { [EOL]     } [EOL]     try { [EOL]         v.walkInOptimizedOrder(visitor, 0, 5); [EOL]         Assert.fail(); [EOL]     } catch (OutOfRangeException e) { [EOL]     } [EOL]     try { [EOL]         v.walkInOptimizedOrder(visitor, 4, 0); [EOL]         Assert.fail(); [EOL]     } catch (NumberIsTooSmallException e) { [EOL]     } [EOL] } <line_num>: 1802,1850
public double visit(final int actualIndex, final double actualValue) { [EOL]     Assert.assertEquals(Integer.toString(actualIndex), data[actualIndex], actualValue, 0d); [EOL]     visited[actualIndex] = true; [EOL]     return actualIndex + actualValue; [EOL] } <line_num>: 1865,1870
public void start(final int actualSize, final int actualStart, final int actualEnd) { [EOL]     Assert.assertEquals(data.length, actualSize); [EOL]     Assert.assertEquals(expectedStart, actualStart); [EOL]     Assert.assertEquals(expectedEnd, actualEnd); [EOL]     Arrays.fill(visited, true); [EOL] } <line_num>: 1872,1878
public double end() { [EOL]     for (int i = expectedStart; i <= expectedEnd; i++) { [EOL]         Assert.assertTrue("entry " + i + "has not been visited", visited[i]); [EOL]     } [EOL]     return 0.0; [EOL] } <line_num>: 1880,1886
@Test [EOL] public void testWalkInOptimizedOrderChangingVisitor3() { [EOL]     final double[] data = new double[] { 0d, 1d, 0d, 0d, 2d, 0d, 0d, 0d, 3d }; [EOL]     final int expectedStart = 2; [EOL]     final int expectedEnd = 7; [EOL]     final RealVector v = create(data); [EOL]     final RealVectorChangingVisitor visitor; [EOL]     visitor = new RealVectorChangingVisitor() { [EOL]  [EOL]         private final boolean[] visited = new boolean[data.length]; [EOL]  [EOL]         public double visit(final int actualIndex, final double actualValue) { [EOL]             Assert.assertEquals(Integer.toString(actualIndex), data[actualIndex], actualValue, 0d); [EOL]             visited[actualIndex] = true; [EOL]             return actualIndex + actualValue; [EOL]         } [EOL]  [EOL]         public void start(final int actualSize, final int actualStart, final int actualEnd) { [EOL]             Assert.assertEquals(data.length, actualSize); [EOL]             Assert.assertEquals(expectedStart, actualStart); [EOL]             Assert.assertEquals(expectedEnd, actualEnd); [EOL]             Arrays.fill(visited, true); [EOL]         } [EOL]  [EOL]         public double end() { [EOL]             for (int i = expectedStart; i <= expectedEnd; i++) { [EOL]                 Assert.assertTrue("entry " + i + "has not been visited", visited[i]); [EOL]             } [EOL]             return 0.0; [EOL]         } [EOL]     }; [EOL]     v.walkInOptimizedOrder(visitor, expectedStart, expectedEnd); [EOL]     for (int i = expectedStart; i <= expectedEnd; i++) { [EOL]         Assert.assertEquals("entry " + i, i + data[i], v.getEntry(i), 0.0); [EOL]     } [EOL] } <line_num>: 1853,1892
private UnsupportedOperationException unsupported() { [EOL]     return new UnsupportedOperationException("Not supported, unneeded for test purposes"); [EOL] } <line_num>: 1911,1913
@Override [EOL] public RealVector copy() { [EOL]     return new RealVectorTestImpl(data); [EOL] } <line_num>: 1915,1918
@Override [EOL] public RealVector ebeMultiply(RealVector v) { [EOL]     throw unsupported(); [EOL] } <line_num>: 1920,1923
@Override [EOL] public RealVector ebeDivide(RealVector v) { [EOL]     throw unsupported(); [EOL] } <line_num>: 1925,1928
@Override [EOL] public double getEntry(int index) { [EOL]     checkIndex(index); [EOL]     return data[index]; [EOL] } <line_num>: 1930,1934
@Override [EOL] public int getDimension() { [EOL]     return data.length; [EOL] } <line_num>: 1936,1939
@Override [EOL] public RealVector append(RealVector v) { [EOL]     throw unsupported(); [EOL] } <line_num>: 1941,1944
@Override [EOL] public RealVector append(double d) { [EOL]     throw unsupported(); [EOL] } <line_num>: 1946,1949
@Override [EOL] public RealVector getSubVector(int index, int n) { [EOL]     throw unsupported(); [EOL] } <line_num>: 1951,1954
@Override [EOL] public void setEntry(int index, double value) { [EOL]     checkIndex(index); [EOL]     data[index] = value; [EOL] } <line_num>: 1956,1960
@Override [EOL] public void setSubVector(int index, RealVector v) { [EOL]     throw unsupported(); [EOL] } <line_num>: 1962,1965
@Override [EOL] public boolean isNaN() { [EOL]     throw unsupported(); [EOL] } <line_num>: 1967,1970
@Override [EOL] public boolean isInfinite() { [EOL]     throw unsupported(); [EOL] } <line_num>: 1972,1975
