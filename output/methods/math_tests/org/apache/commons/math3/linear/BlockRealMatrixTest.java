@Test [EOL] public void testDimensions() { [EOL]     BlockRealMatrix m = new BlockRealMatrix(testData); [EOL]     BlockRealMatrix m2 = new BlockRealMatrix(testData2); [EOL]     Assert.assertEquals("testData row dimension", 3, m.getRowDimension()); [EOL]     Assert.assertEquals("testData column dimension", 3, m.getColumnDimension()); [EOL]     Assert.assertTrue("testData is square", m.isSquare()); [EOL]     Assert.assertEquals("testData2 row dimension", m2.getRowDimension(), 2); [EOL]     Assert.assertEquals("testData2 column dimension", m2.getColumnDimension(), 3); [EOL]     Assert.assertTrue("testData2 is not square", !m2.isSquare()); [EOL] } <line_num>: 102,112
@Test [EOL] public void testCopyFunctions() { [EOL]     Random r = new Random(66636328996002l); [EOL]     BlockRealMatrix m1 = createRandomMatrix(r, 47, 83); [EOL]     BlockRealMatrix m2 = new BlockRealMatrix(m1.getData()); [EOL]     Assert.assertEquals(m1, m2); [EOL]     BlockRealMatrix m3 = new BlockRealMatrix(testData); [EOL]     BlockRealMatrix m4 = new BlockRealMatrix(m3.getData()); [EOL]     Assert.assertEquals(m3, m4); [EOL] } <line_num>: 115,124
@Test [EOL] public void testAdd() { [EOL]     BlockRealMatrix m = new BlockRealMatrix(testData); [EOL]     BlockRealMatrix mInv = new BlockRealMatrix(testDataInv); [EOL]     RealMatrix mPlusMInv = m.add(mInv); [EOL]     double[][] sumEntries = mPlusMInv.getData(); [EOL]     for (int row = 0; row < m.getRowDimension(); row++) { [EOL]         for (int col = 0; col < m.getColumnDimension(); col++) { [EOL]             Assert.assertEquals("sum entry entry", testDataPlusInv[row][col], sumEntries[row][col], entryTolerance); [EOL]         } [EOL]     } [EOL] } <line_num>: 127,140
@Test [EOL] public void testAddFail() { [EOL]     BlockRealMatrix m = new BlockRealMatrix(testData); [EOL]     BlockRealMatrix m2 = new BlockRealMatrix(testData2); [EOL]     try { [EOL]         m.add(m2); [EOL]         Assert.fail("MathIllegalArgumentException expected"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 143,153
@Test [EOL] public void testNorm() { [EOL]     BlockRealMatrix m = new BlockRealMatrix(testData); [EOL]     BlockRealMatrix m2 = new BlockRealMatrix(testData2); [EOL]     Assert.assertEquals("testData norm", 14d, m.getNorm(), entryTolerance); [EOL]     Assert.assertEquals("testData2 norm", 7d, m2.getNorm(), entryTolerance); [EOL] } <line_num>: 156,162
@Test [EOL] public void testFrobeniusNorm() { [EOL]     BlockRealMatrix m = new BlockRealMatrix(testData); [EOL]     BlockRealMatrix m2 = new BlockRealMatrix(testData2); [EOL]     Assert.assertEquals("testData Frobenius norm", FastMath.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance); [EOL]     Assert.assertEquals("testData2 Frobenius norm", FastMath.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance); [EOL] } <line_num>: 165,171
@Test [EOL] public void testPlusMinus() { [EOL]     BlockRealMatrix m = new BlockRealMatrix(testData); [EOL]     BlockRealMatrix m2 = new BlockRealMatrix(testDataInv); [EOL]     assertClose(m.subtract(m2), m2.scalarMultiply(-1d).add(m), entryTolerance); [EOL]     try { [EOL]         m.subtract(new BlockRealMatrix(testData2)); [EOL]         Assert.fail("Expecting illegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 174,185
@Test [EOL] public void testMultiply() { [EOL]     BlockRealMatrix m = new BlockRealMatrix(testData); [EOL]     BlockRealMatrix mInv = new BlockRealMatrix(testDataInv); [EOL]     BlockRealMatrix identity = new BlockRealMatrix(id); [EOL]     BlockRealMatrix m2 = new BlockRealMatrix(testData2); [EOL]     assertClose(m.multiply(mInv), identity, entryTolerance); [EOL]     assertClose(mInv.multiply(m), identity, entryTolerance); [EOL]     assertClose(m.multiply(identity), m, entryTolerance); [EOL]     assertClose(identity.multiply(mInv), mInv, entryTolerance); [EOL]     assertClose(m2.multiply(identity), m2, entryTolerance); [EOL]     try { [EOL]         m.multiply(new BlockRealMatrix(bigSingular)); [EOL]         Assert.fail("Expecting illegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 188,205
@Test [EOL] public void testSeveralBlocks() { [EOL]     RealMatrix m = new BlockRealMatrix(35, 71); [EOL]     for (int i = 0; i < m.getRowDimension(); ++i) { [EOL]         for (int j = 0; j < m.getColumnDimension(); ++j) { [EOL]             m.setEntry(i, j, i + j / 1024.0); [EOL]         } [EOL]     } [EOL]     RealMatrix mT = m.transpose(); [EOL]     Assert.assertEquals(m.getRowDimension(), mT.getColumnDimension()); [EOL]     Assert.assertEquals(m.getColumnDimension(), mT.getRowDimension()); [EOL]     for (int i = 0; i < mT.getRowDimension(); ++i) { [EOL]         for (int j = 0; j < mT.getColumnDimension(); ++j) { [EOL]             Assert.assertEquals(m.getEntry(j, i), mT.getEntry(i, j), 0); [EOL]         } [EOL]     } [EOL]     RealMatrix mPm = m.add(m); [EOL]     for (int i = 0; i < mPm.getRowDimension(); ++i) { [EOL]         for (int j = 0; j < mPm.getColumnDimension(); ++j) { [EOL]             Assert.assertEquals(2 * m.getEntry(i, j), mPm.getEntry(i, j), 0); [EOL]         } [EOL]     } [EOL]     RealMatrix mPmMm = mPm.subtract(m); [EOL]     for (int i = 0; i < mPmMm.getRowDimension(); ++i) { [EOL]         for (int j = 0; j < mPmMm.getColumnDimension(); ++j) { [EOL]             Assert.assertEquals(m.getEntry(i, j), mPmMm.getEntry(i, j), 0); [EOL]         } [EOL]     } [EOL]     RealMatrix mTm = mT.multiply(m); [EOL]     for (int i = 0; i < mTm.getRowDimension(); ++i) { [EOL]         for (int j = 0; j < mTm.getColumnDimension(); ++j) { [EOL]             double sum = 0; [EOL]             for (int k = 0; k < mT.getColumnDimension(); ++k) { [EOL]                 sum += (k + i / 1024.0) * (k + j / 1024.0); [EOL]             } [EOL]             Assert.assertEquals(sum, mTm.getEntry(i, j), 0); [EOL]         } [EOL]     } [EOL]     RealMatrix mmT = m.multiply(mT); [EOL]     for (int i = 0; i < mmT.getRowDimension(); ++i) { [EOL]         for (int j = 0; j < mmT.getColumnDimension(); ++j) { [EOL]             double sum = 0; [EOL]             for (int k = 0; k < m.getColumnDimension(); ++k) { [EOL]                 sum += (i + k / 1024.0) * (j + k / 1024.0); [EOL]             } [EOL]             Assert.assertEquals(sum, mmT.getEntry(i, j), 0); [EOL]         } [EOL]     } [EOL]     RealMatrix sub1 = m.getSubMatrix(2, 9, 5, 20); [EOL]     for (int i = 0; i < sub1.getRowDimension(); ++i) { [EOL]         for (int j = 0; j < sub1.getColumnDimension(); ++j) { [EOL]             Assert.assertEquals((i + 2) + (j + 5) / 1024.0, sub1.getEntry(i, j), 0); [EOL]         } [EOL]     } [EOL]     RealMatrix sub2 = m.getSubMatrix(10, 12, 3, 70); [EOL]     for (int i = 0; i < sub2.getRowDimension(); ++i) { [EOL]         for (int j = 0; j < sub2.getColumnDimension(); ++j) { [EOL]             Assert.assertEquals((i + 10) + (j + 3) / 1024.0, sub2.getEntry(i, j), 0); [EOL]         } [EOL]     } [EOL]     RealMatrix sub3 = m.getSubMatrix(30, 34, 0, 5); [EOL]     for (int i = 0; i < sub3.getRowDimension(); ++i) { [EOL]         for (int j = 0; j < sub3.getColumnDimension(); ++j) { [EOL]             Assert.assertEquals((i + 30) + (j + 0) / 1024.0, sub3.getEntry(i, j), 0); [EOL]         } [EOL]     } [EOL]     RealMatrix sub4 = m.getSubMatrix(30, 32, 62, 65); [EOL]     for (int i = 0; i < sub4.getRowDimension(); ++i) { [EOL]         for (int j = 0; j < sub4.getColumnDimension(); ++j) { [EOL]             Assert.assertEquals((i + 30) + (j + 62) / 1024.0, sub4.getEntry(i, j), 0); [EOL]         } [EOL]     } [EOL] } <line_num>: 207,289
@Test [EOL] public void testMultiply2() { [EOL]     RealMatrix m3 = new BlockRealMatrix(d3); [EOL]     RealMatrix m4 = new BlockRealMatrix(d4); [EOL]     RealMatrix m5 = new BlockRealMatrix(d5); [EOL]     assertClose(m3.multiply(m4), m5, entryTolerance); [EOL] } <line_num>: 297,303
@Test [EOL] public void testTrace() { [EOL]     RealMatrix m = new BlockRealMatrix(id); [EOL]     Assert.assertEquals("identity trace", 3d, m.getTrace(), entryTolerance); [EOL]     m = new BlockRealMatrix(testData2); [EOL]     try { [EOL]         m.getTrace(); [EOL]         Assert.fail("Expecting NonSquareMatrixException"); [EOL]     } catch (NonSquareMatrixException ex) { [EOL]     } [EOL] } <line_num>: 306,317
@Test [EOL] public void testScalarAdd() { [EOL]     RealMatrix m = new BlockRealMatrix(testData); [EOL]     assertClose(new BlockRealMatrix(testDataPlus2), m.scalarAdd(2d), entryTolerance); [EOL] } <line_num>: 320,324
@Test [EOL] public void testOperate() { [EOL]     RealMatrix m = new BlockRealMatrix(id); [EOL]     assertClose(testVector, m.operate(testVector), entryTolerance); [EOL]     assertClose(testVector, m.operate(new ArrayRealVector(testVector)).toArray(), entryTolerance); [EOL]     m = new BlockRealMatrix(bigSingular); [EOL]     try { [EOL]         m.operate(testVector); [EOL]         Assert.fail("Expecting illegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 327,339
@Test [EOL] public void testOperateLarge() { [EOL]     int p = (7 * BlockRealMatrix.BLOCK_SIZE) / 2; [EOL]     int q = (5 * BlockRealMatrix.BLOCK_SIZE) / 2; [EOL]     int r = 3 * BlockRealMatrix.BLOCK_SIZE; [EOL]     Random random = new Random(111007463902334l); [EOL]     RealMatrix m1 = createRandomMatrix(random, p, q); [EOL]     RealMatrix m2 = createRandomMatrix(random, q, r); [EOL]     RealMatrix m1m2 = m1.multiply(m2); [EOL]     for (int i = 0; i < r; ++i) { [EOL]         checkArrays(m1m2.getColumn(i), m1.operate(m2.getColumn(i))); [EOL]     } [EOL] } <line_num>: 341,353
@Test [EOL] public void testOperatePremultiplyLarge() { [EOL]     int p = (7 * BlockRealMatrix.BLOCK_SIZE) / 2; [EOL]     int q = (5 * BlockRealMatrix.BLOCK_SIZE) / 2; [EOL]     int r = 3 * BlockRealMatrix.BLOCK_SIZE; [EOL]     Random random = new Random(111007463902334l); [EOL]     RealMatrix m1 = createRandomMatrix(random, p, q); [EOL]     RealMatrix m2 = createRandomMatrix(random, q, r); [EOL]     RealMatrix m1m2 = m1.multiply(m2); [EOL]     for (int i = 0; i < p; ++i) { [EOL]         checkArrays(m1m2.getRow(i), m2.preMultiply(m1.getRow(i))); [EOL]     } [EOL] } <line_num>: 355,367
@Test [EOL] public void testMath209() { [EOL]     RealMatrix a = new BlockRealMatrix(new double[][] { { 1, 2 }, { 3, 4 }, { 5, 6 } }); [EOL]     double[] b = a.operate(new double[] { 1, 1 }); [EOL]     Assert.assertEquals(a.getRowDimension(), b.length); [EOL]     Assert.assertEquals(3.0, b[0], 1.0e-12); [EOL]     Assert.assertEquals(7.0, b[1], 1.0e-12); [EOL]     Assert.assertEquals(11.0, b[2], 1.0e-12); [EOL] } <line_num>: 370,380
@Test [EOL] public void testTranspose() { [EOL]     RealMatrix m = new BlockRealMatrix(testData); [EOL]     RealMatrix mIT = new LUDecomposition(m).getSolver().getInverse().transpose(); [EOL]     RealMatrix mTI = new LUDecomposition(m.transpose()).getSolver().getInverse(); [EOL]     assertClose(mIT, mTI, normTolerance); [EOL]     m = new BlockRealMatrix(testData2); [EOL]     RealMatrix mt = new BlockRealMatrix(testData2T); [EOL]     assertClose(mt, m.transpose(), normTolerance); [EOL] } <line_num>: 383,392
@Test [EOL] public void testPremultiplyVector() { [EOL]     RealMatrix m = new BlockRealMatrix(testData); [EOL]     assertClose(m.preMultiply(testVector), preMultTest, normTolerance); [EOL]     assertClose(m.preMultiply(new ArrayRealVector(testVector).toArray()), preMultTest, normTolerance); [EOL]     m = new BlockRealMatrix(bigSingular); [EOL]     try { [EOL]         m.preMultiply(testVector); [EOL]         Assert.fail("expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 395,408
@Test [EOL] public void testPremultiply() { [EOL]     RealMatrix m3 = new BlockRealMatrix(d3); [EOL]     RealMatrix m4 = new BlockRealMatrix(d4); [EOL]     RealMatrix m5 = new BlockRealMatrix(d5); [EOL]     assertClose(m4.preMultiply(m3), m5, entryTolerance); [EOL]     BlockRealMatrix m = new BlockRealMatrix(testData); [EOL]     BlockRealMatrix mInv = new BlockRealMatrix(testDataInv); [EOL]     BlockRealMatrix identity = new BlockRealMatrix(id); [EOL]     assertClose(m.preMultiply(mInv), identity, entryTolerance); [EOL]     assertClose(mInv.preMultiply(m), identity, entryTolerance); [EOL]     assertClose(m.preMultiply(identity), m, entryTolerance); [EOL]     assertClose(identity.preMultiply(mInv), mInv, entryTolerance); [EOL]     try { [EOL]         m.preMultiply(new BlockRealMatrix(bigSingular)); [EOL]         Assert.fail("Expecting illegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 410,430
@Test [EOL] public void testGetVectors() { [EOL]     RealMatrix m = new BlockRealMatrix(testData); [EOL]     assertClose(m.getRow(0), testDataRow1, entryTolerance); [EOL]     assertClose(m.getColumn(2), testDataCol3, entryTolerance); [EOL]     try { [EOL]         m.getRow(10); [EOL]         Assert.fail("expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.getColumn(-1); [EOL]         Assert.fail("expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL] } <line_num>: 432,449
@Test [EOL] public void testGetEntry() { [EOL]     RealMatrix m = new BlockRealMatrix(testData); [EOL]     Assert.assertEquals("get entry", m.getEntry(0, 1), 2d, entryTolerance); [EOL]     try { [EOL]         m.getEntry(10, 4); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL] } <line_num>: 451,461
@Test [EOL] public void testExamples() { [EOL]     double[][] matrixData = { { 1d, 2d, 3d }, { 2d, 5d, 3d } }; [EOL]     RealMatrix m = new BlockRealMatrix(matrixData); [EOL]     double[][] matrixData2 = { { 1d, 2d }, { 2d, 5d }, { 1d, 7d } }; [EOL]     RealMatrix n = new BlockRealMatrix(matrixData2); [EOL]     RealMatrix p = m.multiply(n); [EOL]     Assert.assertEquals(2, p.getRowDimension()); [EOL]     Assert.assertEquals(2, p.getColumnDimension()); [EOL]     RealMatrix pInverse = new LUDecomposition(p).getSolver().getInverse(); [EOL]     Assert.assertEquals(2, pInverse.getRowDimension()); [EOL]     Assert.assertEquals(2, pInverse.getColumnDimension()); [EOL]     double[][] coefficientsData = { { 2, 3, -2 }, { -1, 7, 6 }, { 4, -3, -5 } }; [EOL]     RealMatrix coefficients = new BlockRealMatrix(coefficientsData); [EOL]     RealVector constants = new ArrayRealVector(new double[] { 1, -2, 1 }, false); [EOL]     RealVector solution = new LUDecomposition(coefficients).getSolver().solve(constants); [EOL]     final double cst0 = constants.getEntry(0); [EOL]     final double cst1 = constants.getEntry(1); [EOL]     final double cst2 = constants.getEntry(2); [EOL]     final double sol0 = solution.getEntry(0); [EOL]     final double sol1 = solution.getEntry(1); [EOL]     final double sol2 = solution.getEntry(2); [EOL]     Assert.assertEquals(2 * sol0 + 3 * sol1 - 2 * sol2, cst0, 1E-12); [EOL]     Assert.assertEquals(-1 * sol0 + 7 * sol1 + 6 * sol2, cst1, 1E-12); [EOL]     Assert.assertEquals(4 * sol0 - 3 * sol1 - 5 * sol2, cst2, 1E-12); [EOL] } <line_num>: 464,495
@Test [EOL] public void testGetSubMatrix() { [EOL]     RealMatrix m = new BlockRealMatrix(subTestData); [EOL]     checkGetSubMatrix(m, subRows23Cols00, 2, 3, 0, 0); [EOL]     checkGetSubMatrix(m, subRows00Cols33, 0, 0, 3, 3); [EOL]     checkGetSubMatrix(m, subRows01Cols23, 0, 1, 2, 3); [EOL]     checkGetSubMatrix(m, subRows02Cols13, new int[] { 0, 2 }, new int[] { 1, 3 }); [EOL]     checkGetSubMatrix(m, subRows03Cols12, new int[] { 0, 3 }, new int[] { 1, 2 }); [EOL]     checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }); [EOL]     checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }); [EOL]     checkGetSubMatrix(m, subRows31Cols31, new int[] { 3, 1 }, new int[] { 3, 1 }); [EOL]     checkGetSubMatrix(m, subRows31Cols31, new int[] { 3, 1 }, new int[] { 3, 1 }); [EOL]     checkGetSubMatrix(m, null, 1, 0, 2, 4); [EOL]     checkGetSubMatrix(m, null, -1, 1, 2, 2); [EOL]     checkGetSubMatrix(m, null, 1, 0, 2, 2); [EOL]     checkGetSubMatrix(m, null, 1, 0, 2, 4); [EOL]     checkGetSubMatrix(m, null, new int[] {}, new int[] { 0 }); [EOL]     checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 }); [EOL] } <line_num>: 498,516
private void checkGetSubMatrix(RealMatrix m, double[][] reference, int startRow, int endRow, int startColumn, int endColumn) { [EOL]     try { [EOL]         RealMatrix sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn); [EOL]         if (reference != null) { [EOL]             Assert.assertEquals(new BlockRealMatrix(reference), sub); [EOL]         } else { [EOL]             Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException"); [EOL]         } [EOL]     } catch (OutOfRangeException e) { [EOL]         if (reference != null) { [EOL]             throw e; [EOL]         } [EOL]     } catch (NumberIsTooSmallException e) { [EOL]         if (reference != null) { [EOL]             throw e; [EOL]         } [EOL]     } catch (NoDataException e) { [EOL]         if (reference != null) { [EOL]             throw e; [EOL]         } [EOL]     } [EOL] } <line_num>: 518,540
private void checkGetSubMatrix(RealMatrix m, double[][] reference, int[] selectedRows, int[] selectedColumns) { [EOL]     try { [EOL]         RealMatrix sub = m.getSubMatrix(selectedRows, selectedColumns); [EOL]         if (reference != null) { [EOL]             Assert.assertEquals(new BlockRealMatrix(reference), sub); [EOL]         } else { [EOL]             Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallExceptiono r NoDataException"); [EOL]         } [EOL]     } catch (OutOfRangeException e) { [EOL]         if (reference != null) { [EOL]             throw e; [EOL]         } [EOL]     } catch (NumberIsTooSmallException e) { [EOL]         if (reference != null) { [EOL]             throw e; [EOL]         } [EOL]     } catch (NoDataException e) { [EOL]         if (reference != null) { [EOL]             throw e; [EOL]         } [EOL]     } [EOL] } <line_num>: 542,564
@Test [EOL] public void testGetSetMatrixLarge() { [EOL]     int n = 3 * BlockRealMatrix.BLOCK_SIZE; [EOL]     RealMatrix m = new BlockRealMatrix(n, n); [EOL]     RealMatrix sub = new BlockRealMatrix(n - 4, n - 4).scalarAdd(1); [EOL]     m.setSubMatrix(sub.getData(), 2, 2); [EOL]     for (int i = 0; i < n; ++i) { [EOL]         for (int j = 0; j < n; ++j) { [EOL]             if ((i < 2) || (i > n - 3) || (j < 2) || (j > n - 3)) { [EOL]                 Assert.assertEquals(0.0, m.getEntry(i, j), 0.0); [EOL]             } else { [EOL]                 Assert.assertEquals(1.0, m.getEntry(i, j), 0.0); [EOL]             } [EOL]         } [EOL]     } [EOL]     Assert.assertEquals(sub, m.getSubMatrix(2, n - 3, 2, n - 3)); [EOL] } <line_num>: 566,584
@Test [EOL] public void testCopySubMatrix() { [EOL]     RealMatrix m = new BlockRealMatrix(subTestData); [EOL]     checkCopy(m, subRows23Cols00, 2, 3, 0, 0); [EOL]     checkCopy(m, subRows00Cols33, 0, 0, 3, 3); [EOL]     checkCopy(m, subRows01Cols23, 0, 1, 2, 3); [EOL]     checkCopy(m, subRows02Cols13, new int[] { 0, 2 }, new int[] { 1, 3 }); [EOL]     checkCopy(m, subRows03Cols12, new int[] { 0, 3 }, new int[] { 1, 2 }); [EOL]     checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }); [EOL]     checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }); [EOL]     checkCopy(m, subRows31Cols31, new int[] { 3, 1 }, new int[] { 3, 1 }); [EOL]     checkCopy(m, subRows31Cols31, new int[] { 3, 1 }, new int[] { 3, 1 }); [EOL]     checkCopy(m, null, 1, 0, 2, 4); [EOL]     checkCopy(m, null, -1, 1, 2, 2); [EOL]     checkCopy(m, null, 1, 0, 2, 2); [EOL]     checkCopy(m, null, 1, 0, 2, 4); [EOL]     checkCopy(m, null, new int[] {}, new int[] { 0 }); [EOL]     checkCopy(m, null, new int[] { 0 }, new int[] { 4 }); [EOL] } <line_num>: 586,605
private void checkCopy(RealMatrix m, double[][] reference, int startRow, int endRow, int startColumn, int endColumn) { [EOL]     try { [EOL]         double[][] sub = (reference == null) ? new double[1][1] : new double[reference.length][reference[0].length]; [EOL]         m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub); [EOL]         if (reference != null) { [EOL]             Assert.assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub)); [EOL]         } else { [EOL]             Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException"); [EOL]         } [EOL]     } catch (OutOfRangeException e) { [EOL]         if (reference != null) { [EOL]             throw e; [EOL]         } [EOL]     } catch (NumberIsTooSmallException e) { [EOL]         if (reference != null) { [EOL]             throw e; [EOL]         } [EOL]     } catch (NoDataException e) { [EOL]         if (reference != null) { [EOL]             throw e; [EOL]         } [EOL]     } [EOL] } <line_num>: 607,632
private void checkCopy(RealMatrix m, double[][] reference, int[] selectedRows, int[] selectedColumns) { [EOL]     try { [EOL]         double[][] sub = (reference == null) ? new double[1][1] : new double[reference.length][reference[0].length]; [EOL]         m.copySubMatrix(selectedRows, selectedColumns, sub); [EOL]         if (reference != null) { [EOL]             Assert.assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub)); [EOL]         } else { [EOL]             Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException"); [EOL]         } [EOL]     } catch (OutOfRangeException e) { [EOL]         if (reference != null) { [EOL]             throw e; [EOL]         } [EOL]     } catch (NumberIsTooSmallException e) { [EOL]         if (reference != null) { [EOL]             throw e; [EOL]         } [EOL]     } catch (NoDataException e) { [EOL]         if (reference != null) { [EOL]             throw e; [EOL]         } [EOL]     } [EOL] } <line_num>: 634,659
@Test [EOL] public void testGetRowMatrix() { [EOL]     RealMatrix m = new BlockRealMatrix(subTestData); [EOL]     RealMatrix mRow0 = new BlockRealMatrix(subRow0); [EOL]     RealMatrix mRow3 = new BlockRealMatrix(subRow3); [EOL]     Assert.assertEquals("Row0", mRow0, m.getRowMatrix(0)); [EOL]     Assert.assertEquals("Row3", mRow3, m.getRowMatrix(3)); [EOL]     try { [EOL]         m.getRowMatrix(-1); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.getRowMatrix(4); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL] } <line_num>: 661,680
@Test [EOL] public void testSetRowMatrix() { [EOL]     RealMatrix m = new BlockRealMatrix(subTestData); [EOL]     RealMatrix mRow3 = new BlockRealMatrix(subRow3); [EOL]     Assert.assertNotSame(mRow3, m.getRowMatrix(0)); [EOL]     m.setRowMatrix(0, mRow3); [EOL]     Assert.assertEquals(mRow3, m.getRowMatrix(0)); [EOL]     try { [EOL]         m.setRowMatrix(-1, mRow3); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.setRowMatrix(0, m); [EOL]         Assert.fail("Expecting MatrixDimensionMismatchException"); [EOL]     } catch (MatrixDimensionMismatchException ex) { [EOL]     } [EOL] } <line_num>: 682,701
@Test [EOL] public void testGetSetRowMatrixLarge() { [EOL]     int n = 3 * BlockRealMatrix.BLOCK_SIZE; [EOL]     RealMatrix m = new BlockRealMatrix(n, n); [EOL]     RealMatrix sub = new BlockRealMatrix(1, n).scalarAdd(1); [EOL]     m.setRowMatrix(2, sub); [EOL]     for (int i = 0; i < n; ++i) { [EOL]         for (int j = 0; j < n; ++j) { [EOL]             if (i != 2) { [EOL]                 Assert.assertEquals(0.0, m.getEntry(i, j), 0.0); [EOL]             } else { [EOL]                 Assert.assertEquals(1.0, m.getEntry(i, j), 0.0); [EOL]             } [EOL]         } [EOL]     } [EOL]     Assert.assertEquals(sub, m.getRowMatrix(2)); [EOL] } <line_num>: 703,720
@Test [EOL] public void testGetColumnMatrix() { [EOL]     RealMatrix m = new BlockRealMatrix(subTestData); [EOL]     RealMatrix mColumn1 = new BlockRealMatrix(subColumn1); [EOL]     RealMatrix mColumn3 = new BlockRealMatrix(subColumn3); [EOL]     Assert.assertEquals(mColumn1, m.getColumnMatrix(1)); [EOL]     Assert.assertEquals(mColumn3, m.getColumnMatrix(3)); [EOL]     try { [EOL]         m.getColumnMatrix(-1); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.getColumnMatrix(4); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL] } <line_num>: 722,741
@Test [EOL] public void testSetColumnMatrix() { [EOL]     RealMatrix m = new BlockRealMatrix(subTestData); [EOL]     RealMatrix mColumn3 = new BlockRealMatrix(subColumn3); [EOL]     Assert.assertNotSame(mColumn3, m.getColumnMatrix(1)); [EOL]     m.setColumnMatrix(1, mColumn3); [EOL]     Assert.assertEquals(mColumn3, m.getColumnMatrix(1)); [EOL]     try { [EOL]         m.setColumnMatrix(-1, mColumn3); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.setColumnMatrix(0, m); [EOL]         Assert.fail("Expecting MatrixDimensionMismatchException"); [EOL]     } catch (MatrixDimensionMismatchException ex) { [EOL]     } [EOL] } <line_num>: 743,762
@Test [EOL] public void testGetSetColumnMatrixLarge() { [EOL]     int n = 3 * BlockRealMatrix.BLOCK_SIZE; [EOL]     RealMatrix m = new BlockRealMatrix(n, n); [EOL]     RealMatrix sub = new BlockRealMatrix(n, 1).scalarAdd(1); [EOL]     m.setColumnMatrix(2, sub); [EOL]     for (int i = 0; i < n; ++i) { [EOL]         for (int j = 0; j < n; ++j) { [EOL]             if (j != 2) { [EOL]                 Assert.assertEquals(0.0, m.getEntry(i, j), 0.0); [EOL]             } else { [EOL]                 Assert.assertEquals(1.0, m.getEntry(i, j), 0.0); [EOL]             } [EOL]         } [EOL]     } [EOL]     Assert.assertEquals(sub, m.getColumnMatrix(2)); [EOL] } <line_num>: 764,782
@Test [EOL] public void testGetRowVector() { [EOL]     RealMatrix m = new BlockRealMatrix(subTestData); [EOL]     RealVector mRow0 = new ArrayRealVector(subRow0[0]); [EOL]     RealVector mRow3 = new ArrayRealVector(subRow3[0]); [EOL]     Assert.assertEquals(mRow0, m.getRowVector(0)); [EOL]     Assert.assertEquals(mRow3, m.getRowVector(3)); [EOL]     try { [EOL]         m.getRowVector(-1); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.getRowVector(4); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL] } <line_num>: 784,803
@Test [EOL] public void testSetRowVector() { [EOL]     RealMatrix m = new BlockRealMatrix(subTestData); [EOL]     RealVector mRow3 = new ArrayRealVector(subRow3[0]); [EOL]     Assert.assertNotSame(mRow3, m.getRowMatrix(0)); [EOL]     m.setRowVector(0, mRow3); [EOL]     Assert.assertEquals(mRow3, m.getRowVector(0)); [EOL]     try { [EOL]         m.setRowVector(-1, mRow3); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.setRowVector(0, new ArrayRealVector(5)); [EOL]         Assert.fail("Expecting MatrixDimensionMismatchException"); [EOL]     } catch (MatrixDimensionMismatchException ex) { [EOL]     } [EOL] } <line_num>: 805,824
@Test [EOL] public void testGetSetRowVectorLarge() { [EOL]     int n = 3 * BlockRealMatrix.BLOCK_SIZE; [EOL]     RealMatrix m = new BlockRealMatrix(n, n); [EOL]     RealVector sub = new ArrayRealVector(n, 1.0); [EOL]     m.setRowVector(2, sub); [EOL]     for (int i = 0; i < n; ++i) { [EOL]         for (int j = 0; j < n; ++j) { [EOL]             if (i != 2) { [EOL]                 Assert.assertEquals(0.0, m.getEntry(i, j), 0.0); [EOL]             } else { [EOL]                 Assert.assertEquals(1.0, m.getEntry(i, j), 0.0); [EOL]             } [EOL]         } [EOL]     } [EOL]     Assert.assertEquals(sub, m.getRowVector(2)); [EOL] } <line_num>: 826,843
@Test [EOL] public void testGetColumnVector() { [EOL]     RealMatrix m = new BlockRealMatrix(subTestData); [EOL]     RealVector mColumn1 = columnToVector(subColumn1); [EOL]     RealVector mColumn3 = columnToVector(subColumn3); [EOL]     Assert.assertEquals(mColumn1, m.getColumnVector(1)); [EOL]     Assert.assertEquals(mColumn3, m.getColumnVector(3)); [EOL]     try { [EOL]         m.getColumnVector(-1); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.getColumnVector(4); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL] } <line_num>: 845,864
@Test [EOL] public void testSetColumnVector() { [EOL]     RealMatrix m = new BlockRealMatrix(subTestData); [EOL]     RealVector mColumn3 = columnToVector(subColumn3); [EOL]     Assert.assertNotSame(mColumn3, m.getColumnVector(1)); [EOL]     m.setColumnVector(1, mColumn3); [EOL]     Assert.assertEquals(mColumn3, m.getColumnVector(1)); [EOL]     try { [EOL]         m.setColumnVector(-1, mColumn3); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.setColumnVector(0, new ArrayRealVector(5)); [EOL]         Assert.fail("Expecting MatrixDimensionMismatchException"); [EOL]     } catch (MatrixDimensionMismatchException ex) { [EOL]     } [EOL] } <line_num>: 866,885
@Test [EOL] public void testGetSetColumnVectorLarge() { [EOL]     int n = 3 * BlockRealMatrix.BLOCK_SIZE; [EOL]     RealMatrix m = new BlockRealMatrix(n, n); [EOL]     RealVector sub = new ArrayRealVector(n, 1.0); [EOL]     m.setColumnVector(2, sub); [EOL]     for (int i = 0; i < n; ++i) { [EOL]         for (int j = 0; j < n; ++j) { [EOL]             if (j != 2) { [EOL]                 Assert.assertEquals(0.0, m.getEntry(i, j), 0.0); [EOL]             } else { [EOL]                 Assert.assertEquals(1.0, m.getEntry(i, j), 0.0); [EOL]             } [EOL]         } [EOL]     } [EOL]     Assert.assertEquals(sub, m.getColumnVector(2)); [EOL] } <line_num>: 887,904
private RealVector columnToVector(double[][] column) { [EOL]     double[] data = new double[column.length]; [EOL]     for (int i = 0; i < data.length; ++i) { [EOL]         data[i] = column[i][0]; [EOL]     } [EOL]     return new ArrayRealVector(data, false); [EOL] } <line_num>: 906,912
@Test [EOL] public void testGetRow() { [EOL]     RealMatrix m = new BlockRealMatrix(subTestData); [EOL]     checkArrays(subRow0[0], m.getRow(0)); [EOL]     checkArrays(subRow3[0], m.getRow(3)); [EOL]     try { [EOL]         m.getRow(-1); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.getRow(4); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL] } <line_num>: 914,931
@Test [EOL] public void testSetRow() { [EOL]     RealMatrix m = new BlockRealMatrix(subTestData); [EOL]     Assert.assertTrue(subRow3[0][0] != m.getRow(0)[0]); [EOL]     m.setRow(0, subRow3[0]); [EOL]     checkArrays(subRow3[0], m.getRow(0)); [EOL]     try { [EOL]         m.setRow(-1, subRow3[0]); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.setRow(0, new double[5]); [EOL]         Assert.fail("Expecting MatrixDimensionMismatchException"); [EOL]     } catch (MatrixDimensionMismatchException ex) { [EOL]     } [EOL] } <line_num>: 933,951
@Test [EOL] public void testGetSetRowLarge() { [EOL]     int n = 3 * BlockRealMatrix.BLOCK_SIZE; [EOL]     RealMatrix m = new BlockRealMatrix(n, n); [EOL]     double[] sub = new double[n]; [EOL]     Arrays.fill(sub, 1.0); [EOL]     m.setRow(2, sub); [EOL]     for (int i = 0; i < n; ++i) { [EOL]         for (int j = 0; j < n; ++j) { [EOL]             if (i != 2) { [EOL]                 Assert.assertEquals(0.0, m.getEntry(i, j), 0.0); [EOL]             } else { [EOL]                 Assert.assertEquals(1.0, m.getEntry(i, j), 0.0); [EOL]             } [EOL]         } [EOL]     } [EOL]     checkArrays(sub, m.getRow(2)); [EOL] } <line_num>: 953,971
@Test [EOL] public void testGetColumn() { [EOL]     RealMatrix m = new BlockRealMatrix(subTestData); [EOL]     double[] mColumn1 = columnToArray(subColumn1); [EOL]     double[] mColumn3 = columnToArray(subColumn3); [EOL]     checkArrays(mColumn1, m.getColumn(1)); [EOL]     checkArrays(mColumn3, m.getColumn(3)); [EOL]     try { [EOL]         m.getColumn(-1); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.getColumn(4); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL] } <line_num>: 973,992
@Test [EOL] public void testSetColumn() { [EOL]     RealMatrix m = new BlockRealMatrix(subTestData); [EOL]     double[] mColumn3 = columnToArray(subColumn3); [EOL]     Assert.assertTrue(mColumn3[0] != m.getColumn(1)[0]); [EOL]     m.setColumn(1, mColumn3); [EOL]     checkArrays(mColumn3, m.getColumn(1)); [EOL]     try { [EOL]         m.setColumn(-1, mColumn3); [EOL]         Assert.fail("Expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException ex) { [EOL]     } [EOL]     try { [EOL]         m.setColumn(0, new double[5]); [EOL]         Assert.fail("Expecting MatrixDimensionMismatchException"); [EOL]     } catch (MatrixDimensionMismatchException ex) { [EOL]     } [EOL] } <line_num>: 994,1013
@Test [EOL] public void testGetSetColumnLarge() { [EOL]     int n = 3 * BlockRealMatrix.BLOCK_SIZE; [EOL]     RealMatrix m = new BlockRealMatrix(n, n); [EOL]     double[] sub = new double[n]; [EOL]     Arrays.fill(sub, 1.0); [EOL]     m.setColumn(2, sub); [EOL]     for (int i = 0; i < n; ++i) { [EOL]         for (int j = 0; j < n; ++j) { [EOL]             if (j != 2) { [EOL]                 Assert.assertEquals(0.0, m.getEntry(i, j), 0.0); [EOL]             } else { [EOL]                 Assert.assertEquals(1.0, m.getEntry(i, j), 0.0); [EOL]             } [EOL]         } [EOL]     } [EOL]     checkArrays(sub, m.getColumn(2)); [EOL] } <line_num>: 1015,1033
private double[] columnToArray(double[][] column) { [EOL]     double[] data = new double[column.length]; [EOL]     for (int i = 0; i < data.length; ++i) { [EOL]         data[i] = column[i][0]; [EOL]     } [EOL]     return data; [EOL] } <line_num>: 1035,1041
private void checkArrays(double[] expected, double[] actual) { [EOL]     Assert.assertEquals(expected.length, actual.length); [EOL]     for (int i = 0; i < expected.length; ++i) { [EOL]         Assert.assertEquals(expected[i], actual[i], 0); [EOL]     } [EOL] } <line_num>: 1043,1048
@Test [EOL] public void testEqualsAndHashCode() { [EOL]     BlockRealMatrix m = new BlockRealMatrix(testData); [EOL]     BlockRealMatrix m1 = m.copy(); [EOL]     BlockRealMatrix mt = m.transpose(); [EOL]     Assert.assertTrue(m.hashCode() != mt.hashCode()); [EOL]     Assert.assertEquals(m.hashCode(), m1.hashCode()); [EOL]     Assert.assertEquals(m, m); [EOL]     Assert.assertEquals(m, m1); [EOL]     Assert.assertFalse(m.equals(null)); [EOL]     Assert.assertFalse(m.equals(mt)); [EOL]     Assert.assertFalse(m.equals(new BlockRealMatrix(bigSingular))); [EOL] } <line_num>: 1050,1062
@Test [EOL] public void testToString() { [EOL]     BlockRealMatrix m = new BlockRealMatrix(testData); [EOL]     Assert.assertEquals("BlockRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}", m.toString()); [EOL] } <line_num>: 1064,1069
@Test [EOL] public void testSetSubMatrix() { [EOL]     BlockRealMatrix m = new BlockRealMatrix(testData); [EOL]     m.setSubMatrix(detData2, 1, 1); [EOL]     RealMatrix expected = new BlockRealMatrix(new double[][] { { 1.0, 2.0, 3.0 }, { 2.0, 1.0, 3.0 }, { 1.0, 2.0, 4.0 } }); [EOL]     Assert.assertEquals(expected, m); [EOL]     m.setSubMatrix(detData2, 0, 0); [EOL]     expected = new BlockRealMatrix(new double[][] { { 1.0, 3.0, 3.0 }, { 2.0, 4.0, 3.0 }, { 1.0, 2.0, 4.0 } }); [EOL]     Assert.assertEquals(expected, m); [EOL]     m.setSubMatrix(testDataPlus2, 0, 0); [EOL]     expected = new BlockRealMatrix(new double[][] { { 3.0, 4.0, 5.0 }, { 4.0, 7.0, 5.0 }, { 3.0, 2.0, 10.0 } }); [EOL]     Assert.assertEquals(expected, m); [EOL]     BlockRealMatrix matrix = new BlockRealMatrix(new double[][] { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 0, 1, 2 } }); [EOL]     matrix.setSubMatrix(new double[][] { { 3, 4 }, { 5, 6 } }, 1, 1); [EOL]     expected = new BlockRealMatrix(new double[][] { { 1, 2, 3, 4 }, { 5, 3, 4, 8 }, { 9, 5, 6, 2 } }); [EOL]     Assert.assertEquals(expected, matrix); [EOL]     try { [EOL]         m.setSubMatrix(testData, 1, 1); [EOL]         Assert.fail("expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException e) { [EOL]     } [EOL]     try { [EOL]         m.setSubMatrix(testData, -1, 1); [EOL]         Assert.fail("expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException e) { [EOL]     } [EOL]     try { [EOL]         m.setSubMatrix(testData, 1, -1); [EOL]         Assert.fail("expecting OutOfRangeException"); [EOL]     } catch (OutOfRangeException e) { [EOL]     } [EOL]     try { [EOL]         m.setSubMatrix(null, 1, 1); [EOL]         Assert.fail("expecting NullArgumentException"); [EOL]     } catch (NullArgumentException e) { [EOL]     } [EOL]     try { [EOL]         m.setSubMatrix(new double[][] { { 1 }, { 2, 3 } }, 0, 0); [EOL]         Assert.fail("expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException e) { [EOL]     } [EOL]     try { [EOL]         m.setSubMatrix(new double[][] { {} }, 0, 0); [EOL]         Assert.fail("expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException e) { [EOL]     } [EOL] } <line_num>: 1071,1141
@Test [EOL] public void testWalk() { [EOL]     int rows = 150; [EOL]     int columns = 75; [EOL]     RealMatrix m = new BlockRealMatrix(rows, columns); [EOL]     m.walkInRowOrder(new SetVisitor()); [EOL]     GetVisitor getVisitor = new GetVisitor(); [EOL]     m.walkInOptimizedOrder(getVisitor); [EOL]     Assert.assertEquals(rows * columns, getVisitor.getCount()); [EOL]     m = new BlockRealMatrix(rows, columns); [EOL]     m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2); [EOL]     getVisitor = new GetVisitor(); [EOL]     m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2); [EOL]     Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount()); [EOL]     for (int i = 0; i < rows; ++i) { [EOL]         Assert.assertEquals(0.0, m.getEntry(i, 0), 0); [EOL]         Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0); [EOL]     } [EOL]     for (int j = 0; j < columns; ++j) { [EOL]         Assert.assertEquals(0.0, m.getEntry(0, j), 0); [EOL]         Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0); [EOL]     } [EOL]     m = new BlockRealMatrix(rows, columns); [EOL]     m.walkInColumnOrder(new SetVisitor()); [EOL]     getVisitor = new GetVisitor(); [EOL]     m.walkInOptimizedOrder(getVisitor); [EOL]     Assert.assertEquals(rows * columns, getVisitor.getCount()); [EOL]     m = new BlockRealMatrix(rows, columns); [EOL]     m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2); [EOL]     getVisitor = new GetVisitor(); [EOL]     m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2); [EOL]     Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount()); [EOL]     for (int i = 0; i < rows; ++i) { [EOL]         Assert.assertEquals(0.0, m.getEntry(i, 0), 0); [EOL]         Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0); [EOL]     } [EOL]     for (int j = 0; j < columns; ++j) { [EOL]         Assert.assertEquals(0.0, m.getEntry(0, j), 0); [EOL]         Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0); [EOL]     } [EOL]     m = new BlockRealMatrix(rows, columns); [EOL]     m.walkInOptimizedOrder(new SetVisitor()); [EOL]     getVisitor = new GetVisitor(); [EOL]     m.walkInRowOrder(getVisitor); [EOL]     Assert.assertEquals(rows * columns, getVisitor.getCount()); [EOL]     m = new BlockRealMatrix(rows, columns); [EOL]     m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2); [EOL]     getVisitor = new GetVisitor(); [EOL]     m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2); [EOL]     Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount()); [EOL]     for (int i = 0; i < rows; ++i) { [EOL]         Assert.assertEquals(0.0, m.getEntry(i, 0), 0); [EOL]         Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0); [EOL]     } [EOL]     for (int j = 0; j < columns; ++j) { [EOL]         Assert.assertEquals(0.0, m.getEntry(0, j), 0); [EOL]         Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0); [EOL]     } [EOL]     m = new BlockRealMatrix(rows, columns); [EOL]     m.walkInOptimizedOrder(new SetVisitor()); [EOL]     getVisitor = new GetVisitor(); [EOL]     m.walkInColumnOrder(getVisitor); [EOL]     Assert.assertEquals(rows * columns, getVisitor.getCount()); [EOL]     m = new BlockRealMatrix(rows, columns); [EOL]     m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2); [EOL]     getVisitor = new GetVisitor(); [EOL]     m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2); [EOL]     Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount()); [EOL]     for (int i = 0; i < rows; ++i) { [EOL]         Assert.assertEquals(0.0, m.getEntry(i, 0), 0); [EOL]         Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0); [EOL]     } [EOL]     for (int j = 0; j < columns; ++j) { [EOL]         Assert.assertEquals(0.0, m.getEntry(0, j), 0); [EOL]         Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0); [EOL]     } [EOL] } <line_num>: 1143,1228
@Test [EOL] public void testSerial() { [EOL]     BlockRealMatrix m = new BlockRealMatrix(testData); [EOL]     Assert.assertEquals(m, TestUtils.serializeAndRecover(m)); [EOL] } <line_num>: 1230,1234
@Override [EOL] public double visit(int i, int j, double value) { [EOL]     return i + j / 1024.0; [EOL] } <line_num>: 1237,1240
@Override [EOL] public void visit(int i, int j, double value) { [EOL]     ++count; [EOL]     Assert.assertEquals(i + j / 1024.0, value, 0.0); [EOL] } <line_num>: 1245,1249
public int getCount() { [EOL]     return count; [EOL] } <line_num>: 1250,1252
protected void assertClose(RealMatrix m, RealMatrix n, double tolerance) { [EOL]     Assert.assertTrue(m.subtract(n).getNorm() < tolerance); [EOL] } <line_num>: 1258,1260
protected void assertClose(double[] m, double[] n, double tolerance) { [EOL]     if (m.length != n.length) { [EOL]         Assert.fail("vectors not same length"); [EOL]     } [EOL]     for (int i = 0; i < m.length; i++) { [EOL]         Assert.assertEquals(m[i], n[i], tolerance); [EOL]     } [EOL] } <line_num>: 1263,1270
private BlockRealMatrix createRandomMatrix(Random r, int rows, int columns) { [EOL]     BlockRealMatrix m = new BlockRealMatrix(rows, columns); [EOL]     for (int i = 0; i < rows; ++i) { [EOL]         for (int j = 0; j < columns; ++j) { [EOL]             m.setEntry(i, j, 200 * r.nextDouble() - 100); [EOL]         } [EOL]     } [EOL]     return m; [EOL] } <line_num>: 1272,1280
