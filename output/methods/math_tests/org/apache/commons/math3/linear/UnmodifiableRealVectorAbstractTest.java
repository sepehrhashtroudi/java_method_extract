public static boolean equals(final double x, final double y) { [EOL]     if (x == y) { [EOL]         return true; [EOL]     } else if (Math.abs(x) <= EPS) { [EOL]         return Math.abs(y) <= EPS; [EOL]     } else if (Math.abs(y) <= EPS) { [EOL]         return Math.abs(x) <= EPS; [EOL]     } else { [EOL]         return Math.abs(x - y) <= EPS * Math.min(Math.abs(x), Math.abs(y)); [EOL]     } [EOL] } <line_num>: 85,95
public static boolean equals(final double[] x, final double[] y) { [EOL]     if (x.length != y.length) { [EOL]         return false; [EOL]     } [EOL]     final int n = x.length; [EOL]     for (int i = 0; i < n; i++) { [EOL]         if (!equals(x[i], y[i])) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 105,116
public static boolean equals(final RealVector x, final RealVector y) { [EOL]     if (x.getDimension() != y.getDimension()) { [EOL]         return false; [EOL]     } [EOL]     final int n = x.getDimension(); [EOL]     for (int i = 0; i < n; i++) { [EOL]         if (!equals(x.getEntry(i), y.getEntry(i))) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 126,137
public static boolean equals(final RealVector x, final double[] y) { [EOL]     if (x.getDimension() != y.length) { [EOL]         return false; [EOL]     } [EOL]     final int n = x.getDimension(); [EOL]     for (int i = 0; i < n; i++) { [EOL]         if (!equals(x.getEntry(i), y[i])) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 147,158
public static boolean equals(final RealMatrix x, final RealMatrix y) { [EOL]     if (x.getRowDimension() != y.getRowDimension()) { [EOL]         return false; [EOL]     } [EOL]     if (x.getColumnDimension() != y.getColumnDimension()) { [EOL]         return false; [EOL]     } [EOL]     final int rows = x.getRowDimension(); [EOL]     final int cols = x.getColumnDimension(); [EOL]     for (int i = 0; i < rows; i++) { [EOL]         for (int j = 0; j < cols; j++) { [EOL]             if (!equals(x.getEntry(i, j), y.getEntry(i, j))) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 168,185
public static boolean equals(final Object x, final Object y) { [EOL]     if (x instanceof Boolean) { [EOL]         if (y instanceof Boolean) { [EOL]             return ((Boolean) x).booleanValue() == ((Boolean) y).booleanValue(); [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if (x instanceof Integer) { [EOL]         if (y instanceof Integer) { [EOL]             return ((Integer) x).intValue() == ((Integer) y).intValue(); [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]     } else if (x instanceof Double) { [EOL]         if (y instanceof Double) { [EOL]             return equals(((Double) x).doubleValue(), ((Double) y).doubleValue()); [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]     } else if (x instanceof double[]) { [EOL]         if (y instanceof double[]) { [EOL]             return equals((double[]) x, (double[]) y); [EOL]         } else if (y instanceof RealVector) { [EOL]             return equals((RealVector) y, (double[]) x); [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]     } else if (x instanceof RealVector) { [EOL]         if (y instanceof double[]) { [EOL]             return equals((RealVector) x, (double[]) y); [EOL]         } else if (y instanceof RealVector) { [EOL]             return equals((RealVector) x, (RealVector) y); [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]     } else if (x instanceof RealMatrix) { [EOL]         if (y instanceof RealMatrix) { [EOL]             return equals((RealMatrix) x, (RealMatrix) y); [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         throw new IllegalArgumentException("could not compare " + x + ", " + y); [EOL]     } [EOL] } <line_num>: 196,244
public abstract RealVector createVector(); <line_num>: 252,252
public Object createParameter(final Class<?> c) { [EOL]     if (c == Integer.TYPE) { [EOL]         return Integer.valueOf(RANDOM.nextInt()); [EOL]     } else if (c == Double.TYPE) { [EOL]         return Double.valueOf(RANDOM.nextDouble()); [EOL]     } else if (c == double[].class) { [EOL]         final double[] v = new double[DIM]; [EOL]         for (int i = 0; i < DIM; i++) { [EOL]             v[i] = RANDOM.nextDouble(); [EOL]         } [EOL]         return v; [EOL]     } else if (c.isAssignableFrom(RealVector.class)) { [EOL]         return createVector(); [EOL]     } else if (c.isAssignableFrom(UnivariateFunction.class)) { [EOL]         return new Sin(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("could not create " + c); [EOL]     } [EOL] } <line_num>: 262,280
private void callMethod(final Method m, final RealVector u, final Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException { [EOL]     final RealVector uu = u.copy(); [EOL]     final RealVector v = RealVector.unmodifiableRealVector(u.copy()); [EOL]     Object exp = m.invoke(u, args); [EOL]     if (equals(uu, u)) { [EOL]         Object act = m.invoke(v, args); [EOL]         Assert.assertTrue(m.toGenericString() + ", unmodifiable vector has changed", equals(uu, v)); [EOL]         Assert.assertTrue(m.toGenericString() + ", wrong result", equals(exp, act)); [EOL]     } else { [EOL]         boolean flag = false; [EOL]         try { [EOL]             m.invoke(v, args); [EOL]         } catch (InvocationTargetException e) { [EOL]             if (e.getCause() instanceof MathUnsupportedOperationException) { [EOL]                 flag = true; [EOL]             } [EOL]         } [EOL]         Assert.assertTrue(m.toGenericString() + ", exception should have been thrown", flag); [EOL]     } [EOL] } <line_num>: 302,329
@Test [EOL] public void testAllButExcluded() throws IllegalAccessException, IllegalArgumentException, InvocationTargetException { [EOL]     Method[] method = RealVector.class.getMethods(); [EOL]     for (int i = 0; i < method.length; i++) { [EOL]         Method m = method[i]; [EOL]         if (!EXCLUDE.contains(m.getName())) { [EOL]             RealVector u = (RealVector) createParameter(RealVector.class); [EOL]             Class<?>[] paramType = m.getParameterTypes(); [EOL]             Object[] param = new Object[paramType.length]; [EOL]             for (int j = 0; j < paramType.length; j++) { [EOL]                 param[j] = createParameter(paramType[j]); [EOL]             } [EOL]             callMethod(m, u, param); [EOL]         } [EOL]     } [EOL] } <line_num>: 337,355
@Test [EOL] public void testGetEntry() { [EOL]     RealVector u = createVector(); [EOL]     RealVector v = RealVector.unmodifiableRealVector(u); [EOL]     for (int i = 0; i < DIM; i++) { [EOL]         Assert.assertTrue(equals(u.getEntry(i), v.getEntry(i))); [EOL]     } [EOL] } <line_num>: 357,364
@Test(expected = MathUnsupportedOperationException.class) [EOL] public void testSetEntry() { [EOL]     RealVector u = createVector(); [EOL]     RealVector v = RealVector.unmodifiableRealVector(u); [EOL]     for (int i = 0; i < DIM; i++) { [EOL]         v.setEntry(i, 0d); [EOL]     } [EOL] } <line_num>: 366,373
@Test(expected = MathUnsupportedOperationException.class) [EOL] public void testAddToEntry() { [EOL]     RealVector u = createVector(); [EOL]     RealVector v = RealVector.unmodifiableRealVector(u); [EOL]     for (int i = 0; i < DIM; i++) { [EOL]         v.addToEntry(i, 0d); [EOL]     } [EOL] } <line_num>: 375,382
@Test [EOL] public void testGetSubVector() { [EOL]     RealVector u = createVector(); [EOL]     RealVector v = RealVector.unmodifiableRealVector(u); [EOL]     for (int i = 0; i < DIM; i++) { [EOL]         for (int n = 1; n < DIM - i; n++) { [EOL]             RealVector exp = u.getSubVector(i, n); [EOL]             RealVector act = v.getSubVector(i, n); [EOL]             Assert.assertTrue(equals(exp, act)); [EOL]         } [EOL]     } [EOL] } <line_num>: 384,395
@Test(expected = MathUnsupportedOperationException.class) [EOL] public void testSetSubVector() { [EOL]     RealVector u = createVector(); [EOL]     RealVector v = RealVector.unmodifiableRealVector(u); [EOL]     v.setSubVector(0, new ArrayRealVector()); [EOL] } <line_num>: 397,402
@Test [EOL] public void testIterator() { [EOL]     RealVector u = createVector(); [EOL]     Iterator<Entry> i = u.iterator(); [EOL]     RealVector v = RealVector.unmodifiableRealVector(u.copy()); [EOL]     Iterator<Entry> j = v.iterator(); [EOL]     boolean flag; [EOL]     while (i.hasNext()) { [EOL]         Assert.assertTrue(j.hasNext()); [EOL]         Entry exp = i.next(); [EOL]         Entry act = j.next(); [EOL]         Assert.assertTrue(equals(exp.getIndex(), act.getIndex())); [EOL]         Assert.assertTrue(equals(exp.getValue(), act.getValue())); [EOL]         exp.setIndex(RANDOM.nextInt(DIM)); [EOL]         act.setIndex(RANDOM.nextInt(DIM)); [EOL]         flag = false; [EOL]         try { [EOL]             act.setValue(RANDOM.nextDouble()); [EOL]         } catch (MathUnsupportedOperationException e) { [EOL]             flag = true; [EOL]         } [EOL]         Assert.assertTrue("exception should have been thrown", flag); [EOL]     } [EOL]     Assert.assertFalse(j.hasNext()); [EOL] } <line_num>: 404,428
@Test [EOL] public void testSparseIterator() { [EOL]     RealVector u = createVector(); [EOL]     Iterator<Entry> i = u.sparseIterator(); [EOL]     RealVector v = RealVector.unmodifiableRealVector(u.copy()); [EOL]     Iterator<Entry> j = v.sparseIterator(); [EOL]     boolean flag; [EOL]     while (i.hasNext()) { [EOL]         Assert.assertTrue(j.hasNext()); [EOL]         Entry exp = i.next(); [EOL]         Entry act = j.next(); [EOL]         Assert.assertTrue(equals(exp.getIndex(), act.getIndex())); [EOL]         Assert.assertTrue(equals(exp.getValue(), act.getValue())); [EOL]         exp.setIndex(RANDOM.nextInt(DIM)); [EOL]         act.setIndex(RANDOM.nextInt(DIM)); [EOL]         flag = false; [EOL]         try { [EOL]             act.setValue(RANDOM.nextDouble()); [EOL]         } catch (MathUnsupportedOperationException e) { [EOL]             flag = true; [EOL]         } [EOL]         Assert.assertTrue("exception should have been thrown", flag); [EOL]     } [EOL]     Assert.assertFalse(j.hasNext()); [EOL] } <line_num>: 430,454
