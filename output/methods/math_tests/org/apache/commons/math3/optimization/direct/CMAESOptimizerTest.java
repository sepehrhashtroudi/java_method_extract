Cigar() { [EOL]     this(1e3); [EOL] } <line_num>: 516,518
Cigar(double axisratio) { [EOL]     factor = axisratio * axisratio; [EOL] } <line_num>: 520,522
Tablet() { [EOL]     this(1e3); [EOL] } <line_num>: 535,537
Tablet(double axisratio) { [EOL]     factor = axisratio * axisratio; [EOL] } <line_num>: 539,541
CigTab() { [EOL]     this(1e4); [EOL] } <line_num>: 554,556
CigTab(double axisratio) { [EOL]     factor = axisratio; [EOL] } <line_num>: 558,560
TwoAxes() { [EOL]     this(1e6); [EOL] } <line_num>: 575,577
TwoAxes(double axisratio) { [EOL]     factor = axisratio * axisratio; [EOL] } <line_num>: 579,581
ElliRotated() { [EOL]     this(1e3); [EOL] } <line_num>: 595,597
ElliRotated(double axisratio) { [EOL]     factor = axisratio * axisratio; [EOL] } <line_num>: 599,601
Elli() { [EOL]     this(1e3); [EOL] } <line_num>: 616,618
Elli(double axisratio) { [EOL]     factor = axisratio * axisratio; [EOL] } <line_num>: 620,622
Ackley(double axra) { [EOL]     axisratio = axra; [EOL] } <line_num>: 672,674
public Ackley() { [EOL]     this(1); [EOL] } <line_num>: 676,678
Rastrigin() { [EOL]     this(1, 10); [EOL] } <line_num>: 700,702
Rastrigin(double axisratio, double amplitude) { [EOL]     this.axisratio = axisratio; [EOL]     this.amplitude = amplitude; [EOL] } <line_num>: 704,707
@Test(expected = NumberIsTooLargeException.class) [EOL] public void testInitOutofbounds1() { [EOL]     double[] startPoint = point(DIM, 3); [EOL]     double[] insigma = point(DIM, 0.3); [EOL]     double[][] boundaries = boundaries(DIM, -1, 2); [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 1.0), 0.0); [EOL]     doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL] } <line_num>: 48,58
@Test(expected = NumberIsTooSmallException.class) [EOL] public void testInitOutofbounds2() { [EOL]     double[] startPoint = point(DIM, -2); [EOL]     double[] insigma = point(DIM, 0.3); [EOL]     double[][] boundaries = boundaries(DIM, -1, 2); [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 1.0), 0.0); [EOL]     doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL] } <line_num>: 59,69
@Test(expected = DimensionMismatchException.class) [EOL] public void testBoundariesDimensionMismatch() { [EOL]     double[] startPoint = point(DIM, 0.5); [EOL]     double[] insigma = point(DIM, 0.3); [EOL]     double[][] boundaries = boundaries(DIM + 1, -1, 2); [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 1.0), 0.0); [EOL]     doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL] } <line_num>: 71,81
@Test(expected = NotPositiveException.class) [EOL] public void testInputSigmaNegative() { [EOL]     double[] startPoint = point(DIM, 0.5); [EOL]     double[] insigma = point(DIM, -0.5); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 1.0), 0.0); [EOL]     doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL] } <line_num>: 83,93
@Test(expected = OutOfRangeException.class) [EOL] public void testInputSigmaOutOfRange() { [EOL]     double[] startPoint = point(DIM, 0.5); [EOL]     double[] insigma = point(DIM, 1.1); [EOL]     double[][] boundaries = boundaries(DIM, -0.5, 0.5); [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 1.0), 0.0); [EOL]     doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL] } <line_num>: 95,105
@Test(expected = DimensionMismatchException.class) [EOL] public void testInputSigmaDimensionMismatch() { [EOL]     double[] startPoint = point(DIM, 0.5); [EOL]     double[] insigma = point(DIM + 1, 0.5); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 1.0), 0.0); [EOL]     doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL] } <line_num>: 107,117
@Test [EOL] @Retry(3) [EOL] public void testRosen() { [EOL]     double[] startPoint = point(DIM, 0.1); [EOL]     double[] insigma = point(DIM, 0.1); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 1.0), 0.0); [EOL]     doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL]     doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL] } <line_num>: 119,133
@Test [EOL] @Retry(3) [EOL] public void testMaximize() { [EOL] } <line_num>: 135,137
@Test [EOL] public void testEllipse() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[] insigma = point(DIM, 0.1); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new Elli(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL]     doTest(new Elli(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL] } <line_num>: 158,171
@Test [EOL] public void testElliRotated() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[] insigma = point(DIM, 0.1); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new ElliRotated(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL]     doTest(new ElliRotated(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL] } <line_num>: 173,186
@Test [EOL] public void testCigar() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[] insigma = point(DIM, 0.1); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new Cigar(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 200000, expected); [EOL]     doTest(new Cigar(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL] } <line_num>: 188,201
@Test [EOL] public void testCigarWithBoundaries() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[] insigma = point(DIM, 0.1); [EOL]     double[][] boundaries = boundaries(DIM, -1e100, Double.POSITIVE_INFINITY); [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new Cigar(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 200000, expected); [EOL]     doTest(new Cigar(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL] } <line_num>: 203,216
@Test [EOL] public void testTwoAxes() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[] insigma = point(DIM, 0.1); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new TwoAxes(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 2 * LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 200000, expected); [EOL]     doTest(new TwoAxes(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 2 * LAMBDA, false, 0, 1e-13, 1e-8, 1e-3, 200000, expected); [EOL] } <line_num>: 218,231
@Test [EOL] public void testCigTab() { [EOL] } <line_num>: 233,234
@Test [EOL] public void testSphere() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[] insigma = point(DIM, 0.1); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new Sphere(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL]     doTest(new Sphere(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL] } <line_num>: 251,264
@Test [EOL] public void testTablet() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[] insigma = point(DIM, 0.1); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new Tablet(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL]     doTest(new Tablet(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL] } <line_num>: 266,279
@Test [EOL] public void testDiffPow() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[] insigma = point(DIM, 0.1); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new DiffPow(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 10, true, 0, 1e-13, 1e-8, 1e-1, 100000, expected); [EOL]     doTest(new DiffPow(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 10, false, 0, 1e-13, 1e-8, 2e-1, 100000, expected); [EOL] } <line_num>: 281,294
@Test [EOL] public void testSsDiffPow() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[] insigma = point(DIM, 0.1); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new SsDiffPow(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 10, true, 0, 1e-13, 1e-4, 1e-1, 200000, expected); [EOL]     doTest(new SsDiffPow(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 10, false, 0, 1e-13, 1e-4, 1e-1, 200000, expected); [EOL] } <line_num>: 296,309
@Test [EOL] public void testAckley() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[] insigma = point(DIM, 1.0); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new Ackley(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 2 * LAMBDA, true, 0, 1e-13, 1e-9, 1e-5, 100000, expected); [EOL]     doTest(new Ackley(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 2 * LAMBDA, false, 0, 1e-13, 1e-9, 1e-5, 100000, expected); [EOL] } <line_num>: 311,324
@Test [EOL] public void testRastrigin() { [EOL]     double[] startPoint = point(DIM, 0.1); [EOL]     double[] insigma = point(DIM, 0.1); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new Rastrigin(), startPoint, insigma, boundaries, GoalType.MINIMIZE, (int) (200 * Math.sqrt(DIM)), true, 0, 1e-13, 1e-13, 1e-6, 200000, expected); [EOL]     doTest(new Rastrigin(), startPoint, insigma, boundaries, GoalType.MINIMIZE, (int) (200 * Math.sqrt(DIM)), false, 0, 1e-13, 1e-13, 1e-6, 200000, expected); [EOL] } <line_num>: 326,339
@Test [EOL] public void testConstrainedRosen() { [EOL]     double[] startPoint = point(DIM, 0.1); [EOL]     double[] insigma = point(DIM, 0.1); [EOL]     double[][] boundaries = boundaries(DIM, -1, 2); [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 1.0), 0.0); [EOL]     doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 2 * LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL]     doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 2 * LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL] } <line_num>: 341,354
@Test [EOL] public void testDiagonalRosen() { [EOL] } <line_num>: 356,357
public double value(double[] parameters) { [EOL]     final double target = 1; [EOL]     final double error = target - parameters[0]; [EOL]     return error * error; [EOL] } <line_num>: 375,379
@Test [EOL] public void testMath864() { [EOL]     final CMAESOptimizer optimizer = new CMAESOptimizer(); [EOL]     final MultivariateFunction fitnessFunction = new MultivariateFunction() { [EOL]  [EOL]         public double value(double[] parameters) { [EOL]             final double target = 1; [EOL]             final double error = target - parameters[0]; [EOL]             return error * error; [EOL]         } [EOL]     }; [EOL]     final double[] start = { 0 }; [EOL]     final double[] lower = { -1e6 }; [EOL]     final double[] upper = { 1.5 }; [EOL]     final double[] result = optimizer.optimize(10000, fitnessFunction, GoalType.MINIMIZE, start, lower, upper).getPoint(); [EOL]     Assert.assertTrue("Out of bounds (" + result[0] + " > " + upper[0] + ")", result[0] <= upper[0]); [EOL] } <line_num>: 371,389
public double value(double[] parameters) { [EOL]     final double target = 11.1; [EOL]     final double error = target - parameters[0]; [EOL]     return error * error; [EOL] } <line_num>: 398,402
@Test [EOL] public void testFitAccuracyDependsOnBoundary() { [EOL]     final CMAESOptimizer optimizer = new CMAESOptimizer(); [EOL]     final MultivariateFunction fitnessFunction = new MultivariateFunction() { [EOL]  [EOL]         public double value(double[] parameters) { [EOL]             final double target = 11.1; [EOL]             final double error = target - parameters[0]; [EOL]             return error * error; [EOL]         } [EOL]     }; [EOL]     final double[] start = { 1 }; [EOL]     PointValuePair result = optimizer.optimize(100000, fitnessFunction, GoalType.MINIMIZE, start); [EOL]     final double resNoBound = result.getPoint()[0]; [EOL]     final double[] lower = { -20 }; [EOL]     final double[] upper = { 5e16 }; [EOL]     result = optimizer.optimize(100000, fitnessFunction, GoalType.MINIMIZE, start, lower, upper); [EOL]     final double resNearLo = result.getPoint()[0]; [EOL]     lower[0] = -5e16; [EOL]     upper[0] = 20; [EOL]     result = optimizer.optimize(100000, fitnessFunction, GoalType.MINIMIZE, start, lower, upper); [EOL]     final double resNearHi = result.getPoint()[0]; [EOL]     Assert.assertEquals(resNoBound, resNearLo, 1e-3); [EOL]     Assert.assertEquals(resNoBound, resNearHi, 1e-3); [EOL] } <line_num>: 394,434
private void doTest(MultivariateFunction func, double[] startPoint, double[] inSigma, double[][] boundaries, GoalType goal, int lambda, boolean isActive, int diagonalOnly, double stopValue, double fTol, double pointTol, int maxEvaluations, PointValuePair expected) { [EOL]     int dim = startPoint.length; [EOL]     CMAESOptimizer optim = new CMAESOptimizer(30000, stopValue, isActive, diagonalOnly, 0, new MersenneTwister(), false, null); [EOL]     final double[] lB = boundaries == null ? null : boundaries[0]; [EOL]     final double[] uB = boundaries == null ? null : boundaries[1]; [EOL]     PointValuePair result = boundaries == null ? optim.optimize(maxEvaluations, func, goal, new InitialGuess(startPoint), new CMAESOptimizer.Sigma(inSigma), new CMAESOptimizer.PopulationSize(lambda)) : optim.optimize(maxEvaluations, func, goal, new InitialGuess(startPoint), new SimpleBounds(lB, uB), new CMAESOptimizer.Sigma(inSigma), new CMAESOptimizer.PopulationSize(lambda)); [EOL]     Assert.assertEquals(expected.getValue(), result.getValue(), fTol); [EOL]     for (int i = 0; i < dim; i++) { [EOL]         Assert.assertEquals(expected.getPoint()[i], result.getPoint()[i], pointTol); [EOL]     } [EOL] } <line_num>: 451,485
private static double[] point(int n, double value) { [EOL]     double[] ds = new double[n]; [EOL]     Arrays.fill(ds, value); [EOL]     return ds; [EOL] } <line_num>: 487,491
private static double[][] boundaries(int dim, double lower, double upper) { [EOL]     double[][] boundaries = new double[2][dim]; [EOL]     for (int i = 0; i < dim; i++) boundaries[0][i] = lower; [EOL]     for (int i = 0; i < dim; i++) boundaries[1][i] = upper; [EOL]     return boundaries; [EOL] } <line_num>: 493,501
public double value(double[] x) { [EOL]     double f = 0; [EOL]     for (int i = 0; i < x.length; ++i) f += x[i] * x[i]; [EOL]     return f; [EOL] } <line_num>: 505,510
public double value(double[] x) { [EOL]     double f = x[0] * x[0]; [EOL]     for (int i = 1; i < x.length; ++i) f += factor * x[i] * x[i]; [EOL]     return f; [EOL] } <line_num>: 524,529
public double value(double[] x) { [EOL]     double f = factor * x[0] * x[0]; [EOL]     for (int i = 1; i < x.length; ++i) f += x[i] * x[i]; [EOL]     return f; [EOL] } <line_num>: 543,548
public double value(double[] x) { [EOL]     int end = x.length - 1; [EOL]     double f = x[0] * x[0] / factor + factor * x[end] * x[end]; [EOL]     for (int i = 1; i < end; ++i) f += x[i] * x[i]; [EOL]     return f; [EOL] } <line_num>: 562,568
public double value(double[] x) { [EOL]     double f = 0; [EOL]     for (int i = 0; i < x.length; ++i) f += (i < x.length / 2 ? factor : 1) * x[i] * x[i]; [EOL]     return f; [EOL] } <line_num>: 583,588
public double value(double[] x) { [EOL]     double f = 0; [EOL]     x = B.Rotate(x); [EOL]     for (int i = 0; i < x.length; ++i) f += Math.pow(factor, i / (x.length - 1.)) * x[i] * x[i]; [EOL]     return f; [EOL] } <line_num>: 603,609
public double value(double[] x) { [EOL]     double f = 0; [EOL]     for (int i = 0; i < x.length; ++i) f += Math.pow(factor, i / (x.length - 1.)) * x[i] * x[i]; [EOL]     return f; [EOL] } <line_num>: 624,629
public double value(double[] x) { [EOL]     return 1.0 - (new Elli().value(x)); [EOL] } <line_num>: 634,636
public double value(double[] x) { [EOL]     double f = 0; [EOL]     for (int i = 0; i < x.length; ++i) f += Math.pow(Math.abs(x[i]), 2. + 10 * (double) i / (x.length - 1.)); [EOL]     return f; [EOL] } <line_num>: 641,647
public double value(double[] x) { [EOL]     double f = Math.pow(new DiffPow().value(x), 0.25); [EOL]     return f; [EOL] } <line_num>: 652,655
public double value(double[] x) { [EOL]     double f = 0; [EOL]     for (int i = 0; i < x.length - 1; ++i) f += 1e2 * (x[i] * x[i] - x[i + 1]) * (x[i] * x[i] - x[i + 1]) + (x[i] - 1.) * (x[i] - 1.); [EOL]     return f; [EOL] } <line_num>: 660,666
public double value(double[] x) { [EOL]     double f = 0; [EOL]     double res2 = 0; [EOL]     double fac = 0; [EOL]     for (int i = 0; i < x.length; ++i) { [EOL]         fac = Math.pow(axisratio, (i - 1.) / (x.length - 1.)); [EOL]         f += fac * fac * x[i] * x[i]; [EOL]         res2 += Math.cos(2. * Math.PI * fac * x[i]); [EOL]     } [EOL]     f = (20. - 20. * Math.exp(-0.2 * Math.sqrt(f / x.length)) + Math.exp(1.) - Math.exp(res2 / x.length)); [EOL]     return f; [EOL] } <line_num>: 680,692
public double value(double[] x) { [EOL]     double f = 0; [EOL]     double fac; [EOL]     for (int i = 0; i < x.length; ++i) { [EOL]         fac = Math.pow(axisratio, (i - 1.) / (x.length - 1.)); [EOL]         if (i == 0 && x[i] < 0) [EOL]             fac *= 1.; [EOL]         f += fac * fac * x[i] * x[i] + amplitude * (1. - Math.cos(2. * Math.PI * fac * x[i])); [EOL]     } [EOL]     return f; [EOL] } <line_num>: 709,720
double[] Rotate(double[] x) { [EOL]     GenBasis(x.length); [EOL]     double[] y = new double[x.length]; [EOL]     for (int i = 0; i < x.length; ++i) { [EOL]         y[i] = 0; [EOL]         for (int j = 0; j < x.length; ++j) y[i] += basis[i][j] * x[j]; [EOL]     } [EOL]     return y; [EOL] } <line_num>: 727,736
void GenBasis(int DIM) { [EOL]     if (basis != null ? basis.length == DIM : false) [EOL]         return; [EOL]     double sp; [EOL]     int i, j, k; [EOL]     basis = new double[DIM][DIM]; [EOL]     for (i = 0; i < DIM; ++i) { [EOL]         for (j = 0; j < DIM; ++j) basis[i][j] = rand.nextGaussian(); [EOL]         for (j = i - 1; j >= 0; --j) { [EOL]             for (sp = 0., k = 0; k < DIM; ++k) sp += basis[i][k] * basis[j][k]; [EOL]             for (k = 0; k < DIM; ++k) basis[i][k] -= sp * basis[j][k]; [EOL]         } [EOL]         for (sp = 0., k = 0; k < DIM; ++k) sp += basis[i][k] * basis[i][k]; [EOL]         for (k = 0; k < DIM; ++k) basis[i][k] /= Math.sqrt(sp); [EOL]     } [EOL] } <line_num>: 738,764
