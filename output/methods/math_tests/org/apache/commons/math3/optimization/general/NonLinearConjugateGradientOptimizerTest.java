public LinearProblem(double[][] factors, double[] target) { [EOL]     this.factors = new BlockRealMatrix(factors); [EOL]     this.target = target; [EOL] } <line_num>: 351,354
@Test [EOL] public void testTrivial() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 2 } }, new double[] { 3 }); [EOL]     NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); [EOL]     PointValuePair optimum = optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0 }); [EOL]     Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10); [EOL]     Assert.assertEquals(0.0, optimum.getValue(), 1.0e-10); [EOL] } <line_num>: 97,108
@Test [EOL] public void testColumnsPermutation() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } }, new double[] { 4.0, 6.0, 1.0 }); [EOL]     NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); [EOL]     PointValuePair optimum = optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0 }); [EOL]     Assert.assertEquals(7.0, optimum.getPoint()[0], 1.0e-10); [EOL]     Assert.assertEquals(3.0, optimum.getPoint()[1], 1.0e-10); [EOL]     Assert.assertEquals(0.0, optimum.getValue(), 1.0e-10); [EOL] } <line_num>: 110,125
@Test [EOL] public void testNoDependency() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 2, 0, 0, 0, 0, 0 }, { 0, 2, 0, 0, 0, 0 }, { 0, 0, 2, 0, 0, 0 }, { 0, 0, 0, 2, 0, 0 }, { 0, 0, 0, 0, 2, 0 }, { 0, 0, 0, 0, 0, 2 } }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 }); [EOL]     NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); [EOL]     PointValuePair optimum = optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0, 0, 0, 0, 0 }); [EOL]     for (int i = 0; i < problem.target.length; ++i) { [EOL]         Assert.assertEquals(0.55 * i, optimum.getPoint()[i], 1.0e-10); [EOL]     } [EOL] } <line_num>: 127,145
@Test [EOL] public void testOneSet() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 1, 0, 0 }, { -1, 1, 0 }, { 0, -1, 1 } }, new double[] { 1, 1, 1 }); [EOL]     NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); [EOL]     PointValuePair optimum = optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0, 0 }); [EOL]     Assert.assertEquals(1.0, optimum.getPoint()[0], 1.0e-10); [EOL]     Assert.assertEquals(2.0, optimum.getPoint()[1], 1.0e-10); [EOL]     Assert.assertEquals(3.0, optimum.getPoint()[2], 1.0e-10); [EOL] } <line_num>: 147,163
public double[] precondition(double[] point, double[] r) { [EOL]     double[] d = r.clone(); [EOL]     d[0] /= 72.0; [EOL]     d[1] /= 30.0; [EOL]     d[2] /= 314.0; [EOL]     d[3] /= 260.0; [EOL]     d[4] /= 2 * (1 + epsilon * epsilon); [EOL]     d[5] /= 4.0; [EOL]     return d; [EOL] } <line_num>: 179,188
@Test [EOL] public void testTwoSets() { [EOL]     final double epsilon = 1.0e-7; [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 2, 1, 0, 4, 0, 0 }, { -4, -2, 3, -7, 0, 0 }, { 4, 1, -2, 8, 0, 0 }, { 0, -3, -12, -1, 0, 0 }, { 0, 0, 0, 0, epsilon, 1 }, { 0, 0, 0, 0, 1, 1 } }, new double[] { 2, -9, 2, 2, 1 + epsilon * epsilon, 2 }); [EOL]     final Preconditioner preconditioner = new Preconditioner() { [EOL]  [EOL]         public double[] precondition(double[] point, double[] r) { [EOL]             double[] d = r.clone(); [EOL]             d[0] /= 72.0; [EOL]             d[1] /= 30.0; [EOL]             d[2] /= 314.0; [EOL]             d[3] /= 260.0; [EOL]             d[4] /= 2 * (1 + epsilon * epsilon); [EOL]             d[5] /= 4.0; [EOL]             return d; [EOL]         } [EOL]     }; [EOL]     NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE, new SimpleValueChecker(1e-13, 1e-13), new BrentSolver(), preconditioner); [EOL]     PointValuePair optimum = optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0, 0, 0, 0, 0 }); [EOL]     Assert.assertEquals(3.0, optimum.getPoint()[0], 1.0e-10); [EOL]     Assert.assertEquals(4.0, optimum.getPoint()[1], 1.0e-10); [EOL]     Assert.assertEquals(-1.0, optimum.getPoint()[2], 1.0e-10); [EOL]     Assert.assertEquals(-2.0, optimum.getPoint()[3], 1.0e-10); [EOL]     Assert.assertEquals(1.0 + epsilon, optimum.getPoint()[4], 1.0e-10); [EOL]     Assert.assertEquals(1.0 - epsilon, optimum.getPoint()[5], 1.0e-10); [EOL] } <line_num>: 165,206
@Test [EOL] public void testNonInversible() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 1, 2, -3 }, { 2, 1, 3 }, { -3, 0, -9 } }, new double[] { 1, 1, 1 }); [EOL]     NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); [EOL]     PointValuePair optimum = optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0, 0 }); [EOL]     Assert.assertTrue(optimum.getValue() > 0.5); [EOL] } <line_num>: 208,221
@Test [EOL] public void testIllConditioned() { [EOL]     LinearProblem problem1 = new LinearProblem(new double[][] { { 10.0, 7.0, 8.0, 7.0 }, { 7.0, 5.0, 6.0, 5.0 }, { 8.0, 6.0, 10.0, 9.0 }, { 7.0, 5.0, 9.0, 10.0 } }, new double[] { 32, 23, 33, 31 }); [EOL]     NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE, new SimpleValueChecker(1e-13, 1e-13), new BrentSolver(1e-15, 1e-15)); [EOL]     PointValuePair optimum1 = optimizer.optimize(200, problem1, GoalType.MINIMIZE, new double[] { 0, 1, 2, 3 }); [EOL]     Assert.assertEquals(1.0, optimum1.getPoint()[0], 1.0e-4); [EOL]     Assert.assertEquals(1.0, optimum1.getPoint()[1], 1.0e-4); [EOL]     Assert.assertEquals(1.0, optimum1.getPoint()[2], 1.0e-4); [EOL]     Assert.assertEquals(1.0, optimum1.getPoint()[3], 1.0e-4); [EOL]     LinearProblem problem2 = new LinearProblem(new double[][] { { 10.00, 7.00, 8.10, 7.20 }, { 7.08, 5.04, 6.00, 5.00 }, { 8.00, 5.98, 9.89, 9.00 }, { 6.99, 4.99, 9.00, 9.98 } }, new double[] { 32, 23, 33, 31 }); [EOL]     PointValuePair optimum2 = optimizer.optimize(200, problem2, GoalType.MINIMIZE, new double[] { 0, 1, 2, 3 }); [EOL]     Assert.assertEquals(-81.0, optimum2.getPoint()[0], 1.0e-1); [EOL]     Assert.assertEquals(137.0, optimum2.getPoint()[1], 1.0e-1); [EOL]     Assert.assertEquals(-34.0, optimum2.getPoint()[2], 1.0e-1); [EOL]     Assert.assertEquals(22.0, optimum2.getPoint()[3], 1.0e-1); [EOL] } <line_num>: 223,255
@Test [EOL] public void testMoreEstimatedParametersSimple() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 3.0, 2.0, 0.0, 0.0 }, { 0.0, 1.0, -1.0, 1.0 }, { 2.0, 0.0, 1.0, 0.0 } }, new double[] { 7.0, 3.0, 5.0 }); [EOL]     NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); [EOL]     PointValuePair optimum = optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 7, 6, 5, 4 }); [EOL]     Assert.assertEquals(0, optimum.getValue(), 1.0e-10); [EOL] } <line_num>: 257,272
@Test [EOL] public void testMoreEstimatedParametersUnsorted() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 1.0, 1.0, 0.0, 0.0, 0.0, 0.0 }, { 0.0, 0.0, 1.0, 1.0, 1.0, 0.0 }, { 0.0, 0.0, 0.0, 0.0, 1.0, -1.0 }, { 0.0, 0.0, -1.0, 1.0, 0.0, 1.0 }, { 0.0, 0.0, 0.0, -1.0, 1.0, 0.0 } }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 }); [EOL]     NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); [EOL]     PointValuePair optimum = optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 2, 2, 2, 2, 2, 2 }); [EOL]     Assert.assertEquals(0, optimum.getValue(), 1.0e-10); [EOL] } <line_num>: 274,289
@Test [EOL] public void testRedundantEquations() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 1.0, 1.0 }, { 1.0, -1.0 }, { 1.0, 3.0 } }, new double[] { 3.0, 1.0, 5.0 }); [EOL]     NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); [EOL]     PointValuePair optimum = optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 1, 1 }); [EOL]     Assert.assertEquals(2.0, optimum.getPoint()[0], 1.0e-8); [EOL]     Assert.assertEquals(1.0, optimum.getPoint()[1], 1.0e-8); [EOL] } <line_num>: 291,307
@Test [EOL] public void testInconsistentEquations() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 1.0, 1.0 }, { 1.0, -1.0 }, { 1.0, 3.0 } }, new double[] { 3.0, 1.0, 4.0 }); [EOL]     NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); [EOL]     PointValuePair optimum = optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 1, 1 }); [EOL]     Assert.assertTrue(optimum.getValue() > 0.1); [EOL] } <line_num>: 309,324
@Test [EOL] public void testCircleFitting() { [EOL]     CircleScalar circle = new CircleScalar(); [EOL]     circle.addPoint(30.0, 68.0); [EOL]     circle.addPoint(50.0, -6.0); [EOL]     circle.addPoint(110.0, -20.0); [EOL]     circle.addPoint(35.0, 15.0); [EOL]     circle.addPoint(45.0, 97.0); [EOL]     NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE, new SimpleValueChecker(1e-30, 1e-30), new BrentSolver(1e-15, 1e-13)); [EOL]     PointValuePair optimum = optimizer.optimize(100, circle, GoalType.MINIMIZE, new double[] { 98.680, 47.345 }); [EOL]     Vector2D center = new Vector2D(optimum.getPointRef()[0], optimum.getPointRef()[1]); [EOL]     Assert.assertEquals(69.960161753, circle.getRadius(center), 1.0e-8); [EOL]     Assert.assertEquals(96.075902096, center.getX(), 1.0e-8); [EOL]     Assert.assertEquals(48.135167894, center.getY(), 1.0e-8); [EOL] } <line_num>: 326,344
public double value(double[] variables) { [EOL]     double[] y = factors.operate(variables); [EOL]     double sum = 0; [EOL]     for (int i = 0; i < y.length; ++i) { [EOL]         double ri = y[i] - target[i]; [EOL]         sum += ri * ri; [EOL]     } [EOL]     return sum; [EOL] } <line_num>: 356,364
public DerivativeStructure value(DerivativeStructure[] variables) { [EOL]     DerivativeStructure[] y = new DerivativeStructure[factors.getRowDimension()]; [EOL]     for (int i = 0; i < y.length; ++i) { [EOL]         y[i] = variables[0].getField().getZero(); [EOL]         for (int j = 0; j < factors.getColumnDimension(); ++j) { [EOL]             y[i] = y[i].add(variables[j].multiply(factors.getEntry(i, j))); [EOL]         } [EOL]     } [EOL]     DerivativeStructure sum = variables[0].getField().getZero(); [EOL]     for (int i = 0; i < y.length; ++i) { [EOL]         DerivativeStructure ri = y[i].subtract(target[i]); [EOL]         sum = sum.add(ri.multiply(ri)); [EOL]     } [EOL]     return sum; [EOL] } <line_num>: 366,381
