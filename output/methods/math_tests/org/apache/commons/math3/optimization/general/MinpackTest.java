protected MinpackFunction(int m, double[] startParams, double theoreticalMinCost, double[] theoreticalMinParams) { [EOL]     this.m = m; [EOL]     this.n = startParams.length; [EOL]     this.startParams = startParams.clone(); [EOL]     this.theoreticalMinCost = theoreticalMinCost; [EOL]     this.theoreticalMinParams = theoreticalMinParams; [EOL]     this.costAccuracy = 1.0e-8; [EOL]     this.paramsAccuracy = 1.0e-5; [EOL] } <line_num>: 536,545
public LinearFullRankFunction(int m, int n, double x0, double theoreticalStartCost, double theoreticalMinCost) { [EOL]     super(m, buildArray(n, x0), theoreticalMinCost, buildArray(n, -1.0)); [EOL] } <line_num>: 614,619
public LinearRank1Function(int m, int n, double x0, double theoreticalStartCost, double theoreticalMinCost) { [EOL]     super(m, buildArray(n, x0), theoreticalMinCost, null); [EOL] } <line_num>: 642,646
public LinearRank1ZeroColsAndRowsFunction(int m, int n, double x0) { [EOL]     super(m, buildArray(n, x0), FastMath.sqrt((m * (m + 3) - 6) / (2.0 * (2 * m - 3))), null); [EOL] } <line_num>: 667,671
public RosenbrockFunction(double[] startParams, double theoreticalStartCost) { [EOL]     super(2, startParams, 0.0, buildArray(2, 1.0)); [EOL] } <line_num>: 693,695
public HelicalValleyFunction(double[] startParams, double theoreticalStartCost) { [EOL]     super(3, startParams, 0.0, new double[] { 1.0, 0.0, 0.0 }); [EOL] } <line_num>: 713,716
public PowellSingularFunction(double[] startParams, double theoreticalStartCost) { [EOL]     super(4, startParams, 0.0, buildArray(4, 0.0)); [EOL] } <line_num>: 748,751
public FreudensteinRothFunction(double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { [EOL]     super(2, startParams, theoreticalMinCost, theoreticalMinParams); [EOL] } <line_num>: 776,782
public BardFunction(double x0, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { [EOL]     super(15, buildArray(3, x0), theoreticalMinCost, theoreticalMinParams); [EOL] } <line_num>: 800,806
public KowalikOsborneFunction(double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { [EOL]     super(11, startParams, theoreticalMinCost, theoreticalMinParams); [EOL]     if (theoreticalStartCost > 20.0) { [EOL]         setCostAccuracy(2.0e-4); [EOL]         setParamsAccuracy(5.0e-3); [EOL]     } [EOL] } <line_num>: 835,845
public MeyerFunction(double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { [EOL]     super(16, startParams, theoreticalMinCost, theoreticalMinParams); [EOL]     if (theoreticalStartCost > 1.0e6) { [EOL]         setCostAccuracy(7.0e-3); [EOL]         setParamsAccuracy(2.0e-2); [EOL]     } [EOL] } <line_num>: 875,885
public WatsonFunction(int n, double x0, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { [EOL]     super(31, buildArray(n, x0), theoreticalMinCost, theoreticalMinParams); [EOL] } <line_num>: 912,918
public Box3DimensionalFunction(int m, double[] startParams, double theoreticalStartCost) { [EOL]     super(m, startParams, 0.0, new double[] { 1.0, 10.0, 1.0 }); [EOL] } <line_num>: 955,959
public JennrichSampsonFunction(int m, double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { [EOL]     super(m, startParams, theoreticalMinCost, theoreticalMinParams); [EOL] } <line_num>: 981,987
public BrownDennisFunction(int m, double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { [EOL]     super(m, startParams, theoreticalMinCost, theoreticalMinParams); [EOL]     setCostAccuracy(2.5e-8); [EOL] } <line_num>: 1007,1014
public ChebyquadFunction(int n, int m, double factor, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { [EOL]     super(m, buildChebyquadArray(n, factor), theoreticalMinCost, theoreticalMinParams); [EOL] } <line_num>: 1047,1053
public BrownAlmostLinearFunction(int m, double factor, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { [EOL]     super(m, buildArray(m, factor), theoreticalMinCost, theoreticalMinParams); [EOL] } <line_num>: 1093,1099
public Osborne1Function(double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { [EOL]     super(33, startParams, theoreticalMinCost, theoreticalMinParams); [EOL] } <line_num>: 1123,1129
public Osborne2Function(double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { [EOL]     super(65, startParams, theoreticalMinCost, theoreticalMinParams); [EOL] } <line_num>: 1160,1166
@Test [EOL] public void testMinpackLinearFullRank() { [EOL]     minpackTest(new LinearFullRankFunction(10, 5, 1.0, 5.0, 2.23606797749979), false); [EOL]     minpackTest(new LinearFullRankFunction(50, 5, 1.0, 8.06225774829855, 6.70820393249937), false); [EOL] } <line_num>: 96,102
@Test [EOL] public void testMinpackLinearRank1() { [EOL]     minpackTest(new LinearRank1Function(10, 5, 1.0, 291.521868819476, 1.4638501094228), false); [EOL]     minpackTest(new LinearRank1Function(50, 5, 1.0, 3101.60039334535, 3.48263016573496), false); [EOL] } <line_num>: 104,110
@Test [EOL] public void testMinpackLinearRank1ZeroColsAndRows() { [EOL]     minpackTest(new LinearRank1ZeroColsAndRowsFunction(10, 5, 1.0), false); [EOL]     minpackTest(new LinearRank1ZeroColsAndRowsFunction(50, 5, 1.0), false); [EOL] } <line_num>: 112,116
@Test [EOL] public void testMinpackRosenbrok() { [EOL]     minpackTest(new RosenbrockFunction(new double[] { -1.2, 1.0 }, FastMath.sqrt(24.2)), false); [EOL]     minpackTest(new RosenbrockFunction(new double[] { -12.0, 10.0 }, FastMath.sqrt(1795769.0)), false); [EOL]     minpackTest(new RosenbrockFunction(new double[] { -120.0, 100.0 }, 11.0 * FastMath.sqrt(169000121.0)), false); [EOL] } <line_num>: 118,126
@Test [EOL] public void testMinpackHelicalValley() { [EOL]     minpackTest(new HelicalValleyFunction(new double[] { -1.0, 0.0, 0.0 }, 50.0), false); [EOL]     minpackTest(new HelicalValleyFunction(new double[] { -10.0, 0.0, 0.0 }, 102.95630140987), false); [EOL]     minpackTest(new HelicalValleyFunction(new double[] { -100.0, 0.0, 0.0 }, 991.261822123701), false); [EOL] } <line_num>: 128,136
@Test [EOL] public void testMinpackPowellSingular() { [EOL]     minpackTest(new PowellSingularFunction(new double[] { 3.0, -1.0, 0.0, 1.0 }, 14.6628782986152), false); [EOL]     minpackTest(new PowellSingularFunction(new double[] { 30.0, -10.0, 0.0, 10.0 }, 1270.9838708654), false); [EOL]     minpackTest(new PowellSingularFunction(new double[] { 300.0, -100.0, 0.0, 100.0 }, 126887.903284750), false); [EOL] } <line_num>: 138,146
@Test [EOL] public void testMinpackFreudensteinRoth() { [EOL]     minpackTest(new FreudensteinRothFunction(new double[] { 0.5, -2.0 }, 20.0124960961895, 6.99887517584575, new double[] { 11.4124844654993, -0.896827913731509 }), false); [EOL]     minpackTest(new FreudensteinRothFunction(new double[] { 5.0, -20.0 }, 12432.833948863, 6.9988751744895, new double[] { 11.41300466147456, -0.896796038685959 }), false); [EOL]     minpackTest(new FreudensteinRothFunction(new double[] { 50.0, -200.0 }, 11426454.595762, 6.99887517242903, new double[] { 11.412781785788564, -0.8968051074920405 }), false); [EOL] } <line_num>: 148,168
@Test [EOL] public void testMinpackBard() { [EOL]     minpackTest(new BardFunction(1.0, 6.45613629515967, 0.0906359603390466, new double[] { 0.0824105765758334, 1.1330366534715, 2.34369463894115 }), false); [EOL]     minpackTest(new BardFunction(10.0, 36.1418531596785, 4.17476870138539, new double[] { 0.840666673818329, -158848033.259565, -164378671.653535 }), false); [EOL]     minpackTest(new BardFunction(100.0, 384.114678637399, 4.17476870135969, new double[] { 0.840666673867645, -158946167.205518, -164464906.857771 }), false); [EOL] } <line_num>: 170,190
@Test [EOL] public void testMinpackKowalikOsborne() { [EOL]     minpackTest(new KowalikOsborneFunction(new double[] { 0.25, 0.39, 0.415, 0.39 }, 0.0728915102882945, 0.017535837721129, new double[] { 0.192807810476249, 0.191262653354071, 0.123052801046931, 0.136053221150517 }), false); [EOL]     minpackTest(new KowalikOsborneFunction(new double[] { 2.5, 3.9, 4.15, 3.9 }, 2.97937007555202, 0.032052192917937, new double[] { 728675.473768287, -14.0758803129393, -32977797.7841797, -20571594.1977912 }), false); [EOL]     minpackTest(new KowalikOsborneFunction(new double[] { 25.0, 39.0, 41.5, 39.0 }, 29.9590617016037, 0.0175364017658228, new double[] { 0.192948328597594, 0.188053165007911, 0.122430604321144, 0.134575665392506 }), false); [EOL] } <line_num>: 192,221
@Test [EOL] public void testMinpackMeyer() { [EOL]     minpackTest(new MeyerFunction(new double[] { 0.02, 4000.0, 250.0 }, 41153.4665543031, 9.37794514651874, new double[] { 0.00560963647102661, 6181.34634628659, 345.223634624144 }), false); [EOL]     minpackTest(new MeyerFunction(new double[] { 0.2, 40000.0, 2500.0 }, 4168216.89130846, 792.917871779501, new double[] { 1.42367074157994e-11, 33695.7133432541, 901.268527953801 }), true); [EOL] } <line_num>: 223,239
@Test [EOL] public void testMinpackWatson() { [EOL]     minpackTest(new WatsonFunction(6, 0.0, 5.47722557505166, 0.0478295939097601, new double[] { -0.0157249615083782, 1.01243488232965, -0.232991722387673, 1.26043101102818, -1.51373031394421, 0.99299727291842 }), false); [EOL]     minpackTest(new WatsonFunction(6, 10.0, 6433.12578950026, 0.0478295939096951, new double[] { -0.0157251901386677, 1.01243485860105, -0.232991545843829, 1.26042932089163, -1.51372776706575, 0.99299573426328 }), false); [EOL]     minpackTest(new WatsonFunction(6, 100.0, 674256.040605213, 0.047829593911544, new double[] { -0.0157247019712586, 1.01243490925658, -0.232991922761641, 1.26043292929555, -1.51373320452707, 0.99299901922322 }), false); [EOL]     minpackTest(new WatsonFunction(9, 0.0, 5.47722557505166, 0.00118311459212420, new double[] { -0.153070644166722e-4, 0.999789703934597, 0.0147639634910978, 0.146342330145992, 1.00082109454817, -2.61773112070507, 4.10440313943354, -3.14361226236241, 1.05262640378759 }), false); [EOL]     minpackTest(new WatsonFunction(9, 10.0, 12088.127069307, 0.00118311459212513, new double[] { -0.153071334849279e-4, 0.999789703941234, 0.0147639629786217, 0.146342334818836, 1.00082107321386, -2.61773107084722, 4.10440307655564, -3.14361222178686, 1.05262639322589 }), false); [EOL]     minpackTest(new WatsonFunction(9, 100.0, 1269109.29043834, 0.00118311459212384, new double[] { -0.153069523352176e-4, 0.999789703958371, 0.0147639625185392, 0.146342341096326, 1.00082104729164, -2.61773101573645, 4.10440301427286, -3.14361218602503, 1.05262638516774 }), false); [EOL]     minpackTest(new WatsonFunction(12, 0.0, 5.47722557505166, 0.217310402535861e-4, new double[] { -0.660266001396382e-8, 1.00000164411833, -0.000563932146980154, 0.347820540050756, -0.156731500244233, 1.05281515825593, -3.24727109519451, 7.2884347837505, -10.271848098614, 9.07411353715783, -4.54137541918194, 1.01201187975044 }), false); [EOL]     minpackTest(new WatsonFunction(12, 10.0, 19220.7589790951, 0.217310402518509e-4, new double[] { -0.663710223017410e-8, 1.00000164411787, -0.000563932208347327, 0.347820540486998, -0.156731503955652, 1.05281517654573, -3.2472711515214, 7.28843489430665, -10.2718482369638, 9.07411364383733, -4.54137546533666, 1.01201188830857 }), false); [EOL]     minpackTest(new WatsonFunction(12, 100.0, 2018918.04462367, 0.217310402539845e-4, new double[] { -0.663806046485249e-8, 1.00000164411786, -0.000563932210324959, 0.347820540503588, -0.156731504091375, 1.05281517718031, -3.24727115337025, 7.28843489775302, -10.2718482410813, 9.07411364688464, -4.54137546660822, 1.0120118885369 }), false); [EOL] } <line_num>: 241,325
@Test [EOL] public void testMinpackBox3Dimensional() { [EOL]     minpackTest(new Box3DimensionalFunction(10, new double[] { 0.0, 10.0, 20.0 }, 32.1115837449572), false); [EOL] } <line_num>: 327,331
@Test [EOL] public void testMinpackJennrichSampson() { [EOL]     minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 }, 64.5856498144943, 11.1517793413499, new double[] { 0.2578199266368004, 0.25782997676455244 }), false); [EOL] } <line_num>: 333,341
@Test [EOL] public void testMinpackBrownDennis() { [EOL]     minpackTest(new BrownDennisFunction(20, new double[] { 25.0, 5.0, -5.0, -1.0 }, 2815.43839161816, 292.954288244866, new double[] { -11.59125141003, 13.2024883984741, -0.403574643314272, 0.236736269844604 }), false); [EOL]     minpackTest(new BrownDennisFunction(20, new double[] { 250.0, 50.0, -50.0, -10.0 }, 555073.354173069, 292.954270581415, new double[] { -11.5959274272203, 13.2041866926242, -0.403417362841545, 0.236771143410386 }), false); [EOL]     minpackTest(new BrownDennisFunction(20, new double[] { 2500.0, 500.0, -500.0, -100.0 }, 61211252.2338581, 292.954306151134, new double[] { -11.5902596937374, 13.2020628854665, -0.403688070279258, 0.236665033746463 }), false); [EOL] } <line_num>: 343,366
@Test [EOL] public void testMinpackChebyquad() { [EOL]     minpackTest(new ChebyquadFunction(1, 8, 1.0, 1.88623796907732, 1.88623796907732, new double[] { 0.5 }), false); [EOL]     minpackTest(new ChebyquadFunction(1, 8, 10.0, 5383344372.34005, 1.88424820499951, new double[] { 0.9817314924684 }), false); [EOL]     minpackTest(new ChebyquadFunction(1, 8, 100.0, 0.118088726698392e19, 1.88424820499347, new double[] { 0.9817314852934 }), false); [EOL]     minpackTest(new ChebyquadFunction(8, 8, 1.0, 0.196513862833975, 0.0593032355046727, new double[] { 0.0431536648587336, 0.193091637843267, 0.266328593812698, 0.499999334628884, 0.500000665371116, 0.733671406187302, 0.806908362156733, 0.956846335141266 }), false); [EOL]     minpackTest(new ChebyquadFunction(9, 9, 1.0, 0.16994993465202, 0.0, new double[] { 0.0442053461357828, 0.199490672309881, 0.23561910847106, 0.416046907892598, 0.5, 0.583953092107402, 0.764380891528940, 0.800509327690119, 0.955794653864217 }), false); [EOL]     minpackTest(new ChebyquadFunction(10, 10, 1.0, 0.183747831178711, 0.0806471004038253, new double[] { 0.0596202671753563, 0.166708783805937, 0.239171018813509, 0.398885290346268, 0.398883667870681, 0.601116332129320, 0.60111470965373, 0.760828981186491, 0.833291216194063, 0.940379732824644 }), false); [EOL] } <line_num>: 368,405
@Test [EOL] public void testMinpackBrownAlmostLinear() { [EOL]     minpackTest(new BrownAlmostLinearFunction(10, 0.5, 16.5302162063499, 0.0, new double[] { 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 1.20569696650138 }), false); [EOL]     minpackTest(new BrownAlmostLinearFunction(10, 5.0, 9765624.00089211, 0.0, new double[] { 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 1.20569696650135 }), false); [EOL]     minpackTest(new BrownAlmostLinearFunction(10, 50.0, 0.9765625e17, 0.0, new double[] { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 }), false); [EOL]     minpackTest(new BrownAlmostLinearFunction(30, 0.5, 83.476044467848, 0.0, new double[] { 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 1.06737350671578 }), false); [EOL]     minpackTest(new BrownAlmostLinearFunction(40, 0.5, 128.026364472323, 0.0, new double[] { 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 0.999999999999121 }), false); [EOL] } <line_num>: 407,474
@Test [EOL] public void testMinpackOsborne1() { [EOL]     minpackTest(new Osborne1Function(new double[] { 0.5, 1.5, -1.0, 0.01, 0.02 }, 0.937564021037838, 0.00739249260904843, new double[] { 0.375410049244025, 1.93584654543108, -1.46468676748716, 0.0128675339110439, 0.0221227011813076 }), false); [EOL] } <line_num>: 476,485
@Test [EOL] public void testMinpackOsborne2() { [EOL]     minpackTest(new Osborne2Function(new double[] { 1.3, 0.65, 0.65, 0.7, 0.6, 3.0, 5.0, 7.0, 2.0, 4.5, 5.5 }, 1.44686540984712, 0.20034404483314, new double[] { 1.30997663810096, 0.43155248076, 0.633661261602859, 0.599428560991695, 0.754179768272449, 0.904300082378518, 1.36579949521007, 4.82373199748107, 2.39868475104871, 4.56887554791452, 5.67534206273052 }), false); [EOL] } <line_num>: 487,503
private void minpackTest(MinpackFunction function, boolean exceptionExpected) { [EOL]     LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer(FastMath.sqrt(2.22044604926e-16), FastMath.sqrt(2.22044604926e-16), 2.22044604926e-16); [EOL]     try { [EOL]         PointVectorValuePair optimum = optimizer.optimize(400 * (function.getN() + 1), function, function.getTarget(), function.getWeight(), function.getStartPoint()); [EOL]         Assert.assertFalse(exceptionExpected); [EOL]         function.checkTheoreticalMinCost(optimizer.getRMS()); [EOL]         function.checkTheoreticalMinParams(optimum); [EOL]     } catch (TooManyEvaluationsException e) { [EOL]         Assert.assertTrue(exceptionExpected); [EOL]     } [EOL] } <line_num>: 505,522
protected static double[] buildArray(int n, double x) { [EOL]     double[] array = new double[n]; [EOL]     Arrays.fill(array, x); [EOL]     return array; [EOL] } <line_num>: 547,551
public double[] getTarget() { [EOL]     return buildArray(m, 0.0); [EOL] } <line_num>: 553,555
public double[] getWeight() { [EOL]     return buildArray(m, 1.0); [EOL] } <line_num>: 557,559
public double[] getStartPoint() { [EOL]     return startParams.clone(); [EOL] } <line_num>: 561,563
protected void setCostAccuracy(double costAccuracy) { [EOL]     this.costAccuracy = costAccuracy; [EOL] } <line_num>: 565,567
protected void setParamsAccuracy(double paramsAccuracy) { [EOL]     this.paramsAccuracy = paramsAccuracy; [EOL] } <line_num>: 569,571
public int getN() { [EOL]     return startParams.length; [EOL] } <line_num>: 573,575
public void checkTheoreticalMinCost(double rms) { [EOL]     double threshold = costAccuracy * (1.0 + theoreticalMinCost); [EOL]     Assert.assertEquals(theoreticalMinCost, FastMath.sqrt(m) * rms, threshold); [EOL] } <line_num>: 577,580
public void checkTheoreticalMinParams(PointVectorValuePair optimum) { [EOL]     double[] params = optimum.getPointRef(); [EOL]     if (theoreticalMinParams != null) { [EOL]         for (int i = 0; i < theoreticalMinParams.length; ++i) { [EOL]             double mi = theoreticalMinParams[i]; [EOL]             double vi = params[i]; [EOL]             Assert.assertEquals(mi, vi, paramsAccuracy * (1.0 + FastMath.abs(mi))); [EOL]         } [EOL]     } [EOL] } <line_num>: 582,591
public double[] value(double[] variables) { [EOL]     DerivativeStructure[] dsV = new DerivativeStructure[variables.length]; [EOL]     for (int i = 0; i < variables.length; ++i) { [EOL]         dsV[i] = new DerivativeStructure(0, 0, variables[i]); [EOL]     } [EOL]     DerivativeStructure[] dsY = value(dsV); [EOL]     double[] y = new double[dsY.length]; [EOL]     for (int i = 0; i < dsY.length; ++i) { [EOL]         y[i] = dsY[i].getValue(); [EOL]     } [EOL]     return y; [EOL] } <line_num>: 593,604
public abstract DerivativeStructure[] value(DerivativeStructure[] variables); <line_num>: 606,606
@Override [EOL] public DerivativeStructure[] value(DerivativeStructure[] variables) { [EOL]     DerivativeStructure sum = variables[0].getField().getZero(); [EOL]     for (int i = 0; i < n; ++i) { [EOL]         sum = sum.add(variables[i]); [EOL]     } [EOL]     DerivativeStructure t = sum.multiply(2.0 / m).add(1); [EOL]     DerivativeStructure[] f = new DerivativeStructure[m]; [EOL]     for (int i = 0; i < n; ++i) { [EOL]         f[i] = variables[i].subtract(t); [EOL]     } [EOL]     Arrays.fill(f, n, m, t.negate()); [EOL]     return f; [EOL] } <line_num>: 621,634
@Override [EOL] public DerivativeStructure[] value(DerivativeStructure[] variables) { [EOL]     DerivativeStructure[] f = new DerivativeStructure[m]; [EOL]     DerivativeStructure sum = variables[0].getField().getZero(); [EOL]     for (int i = 0; i < n; ++i) { [EOL]         sum = sum.add(variables[i].multiply(i + 1)); [EOL]     } [EOL]     for (int i = 0; i < m; ++i) { [EOL]         f[i] = sum.multiply(i + 1).subtract(1); [EOL]     } [EOL]     return f; [EOL] } <line_num>: 648,659
@Override [EOL] public DerivativeStructure[] value(DerivativeStructure[] variables) { [EOL]     DerivativeStructure[] f = new DerivativeStructure[m]; [EOL]     DerivativeStructure sum = variables[0].getField().getZero(); [EOL]     for (int i = 1; i < (n - 1); ++i) { [EOL]         sum = sum.add(variables[i].multiply(i + 1)); [EOL]     } [EOL]     for (int i = 0; i < (m - 1); ++i) { [EOL]         f[i] = sum.multiply(i).subtract(1); [EOL]     } [EOL]     f[m - 1] = variables[0].getField().getOne().negate(); [EOL]     return f; [EOL] } <line_num>: 673,685
@Override [EOL] public DerivativeStructure[] value(DerivativeStructure[] variables) { [EOL]     DerivativeStructure x1 = variables[0]; [EOL]     DerivativeStructure x2 = variables[1]; [EOL]     return new DerivativeStructure[] { x2.subtract(x1.multiply(x1)).multiply(10), x1.negate().add(1) }; [EOL] } <line_num>: 697,705
@Override [EOL] public DerivativeStructure[] value(DerivativeStructure[] variables) { [EOL]     DerivativeStructure x1 = variables[0]; [EOL]     DerivativeStructure x2 = variables[1]; [EOL]     DerivativeStructure x3 = variables[2]; [EOL]     DerivativeStructure tmp1 = variables[0].getField().getZero(); [EOL]     if (x1.getValue() == 0) { [EOL]         tmp1 = tmp1.add((x2.getValue() >= 0) ? 0.25 : -0.25); [EOL]     } else { [EOL]         tmp1 = x2.divide(x1).atan().divide(twoPi); [EOL]         if (x1.getValue() < 0) { [EOL]             tmp1 = tmp1.add(0.5); [EOL]         } [EOL]     } [EOL]     DerivativeStructure tmp2 = x1.multiply(x1).add(x2.multiply(x2)).sqrt(); [EOL]     return new DerivativeStructure[] { x3.subtract(tmp1.multiply(10)).multiply(10), tmp2.subtract(1).multiply(10), x3 }; [EOL] } <line_num>: 718,738
@Override [EOL] public DerivativeStructure[] value(DerivativeStructure[] variables) { [EOL]     DerivativeStructure x1 = variables[0]; [EOL]     DerivativeStructure x2 = variables[1]; [EOL]     DerivativeStructure x3 = variables[2]; [EOL]     DerivativeStructure x4 = variables[3]; [EOL]     return new DerivativeStructure[] { x1.add(x2.multiply(10)), x3.subtract(x4).multiply(sqrt5), x2.subtract(x3.multiply(2)).multiply(x2.subtract(x3.multiply(2))), x1.subtract(x4).multiply(x1.subtract(x4)).multiply(sqrt10) }; [EOL] } <line_num>: 753,765
@Override [EOL] public DerivativeStructure[] value(DerivativeStructure[] variables) { [EOL]     DerivativeStructure x1 = variables[0]; [EOL]     DerivativeStructure x2 = variables[1]; [EOL]     return new DerivativeStructure[] { x1.subtract(13.0).add(x2.negate().add(5.0).multiply(x2).subtract(2).multiply(x2)), x1.subtract(29.0).add(x2.add(1).multiply(x2).subtract(14).multiply(x2)) }; [EOL] } <line_num>: 784,792
@Override [EOL] public DerivativeStructure[] value(DerivativeStructure[] variables) { [EOL]     DerivativeStructure x1 = variables[0]; [EOL]     DerivativeStructure x2 = variables[1]; [EOL]     DerivativeStructure x3 = variables[2]; [EOL]     DerivativeStructure[] f = new DerivativeStructure[m]; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         double tmp1 = i + 1; [EOL]         double tmp2 = 15 - i; [EOL]         double tmp3 = (i <= 7) ? tmp1 : tmp2; [EOL]         f[i] = x1.add(x2.multiply(tmp2).add(x3.multiply(tmp3)).reciprocal().multiply(tmp1)).negate().add(y[i]); [EOL]     } [EOL]     return f; [EOL] } <line_num>: 808,821
@Override [EOL] public DerivativeStructure[] value(DerivativeStructure[] variables) { [EOL]     DerivativeStructure x1 = variables[0]; [EOL]     DerivativeStructure x2 = variables[1]; [EOL]     DerivativeStructure x3 = variables[2]; [EOL]     DerivativeStructure x4 = variables[3]; [EOL]     DerivativeStructure[] f = new DerivativeStructure[m]; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         f[i] = x1.multiply(x2.add(v[i]).multiply(v[i])).divide(x4.add(x3.add(v[i]).multiply(v[i]))).negate().add(y[i]); [EOL]     } [EOL]     return f; [EOL] } <line_num>: 847,858
@Override [EOL] public DerivativeStructure[] value(DerivativeStructure[] variables) { [EOL]     DerivativeStructure x1 = variables[0]; [EOL]     DerivativeStructure x2 = variables[1]; [EOL]     DerivativeStructure x3 = variables[2]; [EOL]     DerivativeStructure[] f = new DerivativeStructure[m]; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         f[i] = x1.multiply(x2.divide(x3.add(5.0 * (i + 1) + 45.0)).exp()).subtract(y[i]); [EOL]     } [EOL]     return f; [EOL] } <line_num>: 887,897
@Override [EOL] public DerivativeStructure[] value(DerivativeStructure[] variables) { [EOL]     DerivativeStructure[] f = new DerivativeStructure[m]; [EOL]     for (int i = 0; i < (m - 2); ++i) { [EOL]         double div = (i + 1) / 29.0; [EOL]         DerivativeStructure s1 = variables[0].getField().getZero(); [EOL]         DerivativeStructure dx = variables[0].getField().getOne(); [EOL]         for (int j = 1; j < n; ++j) { [EOL]             s1 = s1.add(dx.multiply(j).multiply(variables[j])); [EOL]             dx = dx.multiply(div); [EOL]         } [EOL]         DerivativeStructure s2 = variables[0].getField().getZero(); [EOL]         dx = variables[0].getField().getOne(); [EOL]         for (int j = 0; j < n; ++j) { [EOL]             s2 = s2.add(dx.multiply(variables[j])); [EOL]             dx = dx.multiply(div); [EOL]         } [EOL]         f[i] = s1.subtract(s2.multiply(s2)).subtract(1); [EOL]     } [EOL]     DerivativeStructure x1 = variables[0]; [EOL]     DerivativeStructure x2 = variables[1]; [EOL]     f[m - 2] = x1; [EOL]     f[m - 1] = x2.subtract(x1.multiply(x1)).subtract(1); [EOL]     return f; [EOL] } <line_num>: 920,947
@Override [EOL] public DerivativeStructure[] value(DerivativeStructure[] variables) { [EOL]     DerivativeStructure x1 = variables[0]; [EOL]     DerivativeStructure x2 = variables[1]; [EOL]     DerivativeStructure x3 = variables[2]; [EOL]     DerivativeStructure[] f = new DerivativeStructure[m]; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         double tmp = (i + 1) / 10.0; [EOL]         f[i] = x1.multiply(-tmp).exp().subtract(x2.multiply(-tmp).exp()).add(x3.multiply(FastMath.exp(-i - 1) - FastMath.exp(-tmp))); [EOL]     } [EOL]     return f; [EOL] } <line_num>: 961,973
@Override [EOL] public DerivativeStructure[] value(DerivativeStructure[] variables) { [EOL]     DerivativeStructure x1 = variables[0]; [EOL]     DerivativeStructure x2 = variables[1]; [EOL]     DerivativeStructure[] f = new DerivativeStructure[m]; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         double temp = i + 1; [EOL]         f[i] = x1.multiply(temp).exp().add(x2.multiply(temp).exp()).subtract(2 + 2 * temp).negate(); [EOL]     } [EOL]     return f; [EOL] } <line_num>: 989,999
@Override [EOL] public DerivativeStructure[] value(DerivativeStructure[] variables) { [EOL]     DerivativeStructure x1 = variables[0]; [EOL]     DerivativeStructure x2 = variables[1]; [EOL]     DerivativeStructure x3 = variables[2]; [EOL]     DerivativeStructure x4 = variables[3]; [EOL]     DerivativeStructure[] f = new DerivativeStructure[m]; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         double temp = (i + 1) / 5.0; [EOL]         DerivativeStructure tmp1 = x1.add(x2.multiply(temp)).subtract(FastMath.exp(temp)); [EOL]         DerivativeStructure tmp2 = x3.add(x4.multiply(FastMath.sin(temp))).subtract(FastMath.cos(temp)); [EOL]         f[i] = tmp1.multiply(tmp1).add(tmp2.multiply(tmp2)); [EOL]     } [EOL]     return f; [EOL] } <line_num>: 1016,1030
private static double[] buildChebyquadArray(int n, double factor) { [EOL]     double[] array = new double[n]; [EOL]     double inv = factor / (n + 1); [EOL]     for (int i = 0; i < n; ++i) { [EOL]         array[i] = (i + 1) * inv; [EOL]     } [EOL]     return array; [EOL] } <line_num>: 1038,1045
@Override [EOL] public DerivativeStructure[] value(DerivativeStructure[] variables) { [EOL]     DerivativeStructure[] f = new DerivativeStructure[m]; [EOL]     Arrays.fill(f, variables[0].getField().getZero()); [EOL]     for (int j = 0; j < n; ++j) { [EOL]         DerivativeStructure tmp1 = variables[0].getField().getOne(); [EOL]         DerivativeStructure tmp2 = variables[j].multiply(2).subtract(1); [EOL]         DerivativeStructure temp = tmp2.multiply(2); [EOL]         for (int i = 0; i < m; ++i) { [EOL]             f[i] = f[i].add(tmp2); [EOL]             DerivativeStructure ti = temp.multiply(tmp2).subtract(tmp1); [EOL]             tmp1 = tmp2; [EOL]             tmp2 = ti; [EOL]         } [EOL]     } [EOL]     double dx = 1.0 / n; [EOL]     boolean iev = false; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         f[i] = f[i].multiply(dx); [EOL]         if (iev) { [EOL]             f[i] = f[i].add(1.0 / (i * (i + 2))); [EOL]         } [EOL]         iev = !iev; [EOL]     } [EOL]     return f; [EOL] } <line_num>: 1055,1085
@Override [EOL] public DerivativeStructure[] value(DerivativeStructure[] variables) { [EOL]     DerivativeStructure[] f = new DerivativeStructure[m]; [EOL]     DerivativeStructure sum = variables[0].getField().getZero().subtract(n + 1); [EOL]     DerivativeStructure prod = variables[0].getField().getOne(); [EOL]     for (int j = 0; j < n; ++j) { [EOL]         sum = sum.add(variables[j]); [EOL]         prod = prod.multiply(variables[j]); [EOL]     } [EOL]     for (int i = 0; i < n; ++i) { [EOL]         f[i] = variables[i].add(sum); [EOL]     } [EOL]     f[n - 1] = prod.subtract(1); [EOL]     return f; [EOL] } <line_num>: 1101,1115
@Override [EOL] public DerivativeStructure[] value(DerivativeStructure[] variables) { [EOL]     DerivativeStructure x1 = variables[0]; [EOL]     DerivativeStructure x2 = variables[1]; [EOL]     DerivativeStructure x3 = variables[2]; [EOL]     DerivativeStructure x4 = variables[3]; [EOL]     DerivativeStructure x5 = variables[4]; [EOL]     DerivativeStructure[] f = new DerivativeStructure[m]; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         double temp = 10.0 * i; [EOL]         DerivativeStructure tmp1 = x4.multiply(-temp).exp(); [EOL]         DerivativeStructure tmp2 = x5.multiply(-temp).exp(); [EOL]         f[i] = x1.add(x2.multiply(tmp1)).add(x3.multiply(tmp2)).negate().add(y[i]); [EOL]     } [EOL]     return f; [EOL] } <line_num>: 1131,1146
@Override [EOL] public DerivativeStructure[] value(DerivativeStructure[] variables) { [EOL]     DerivativeStructure x01 = variables[0]; [EOL]     DerivativeStructure x02 = variables[1]; [EOL]     DerivativeStructure x03 = variables[2]; [EOL]     DerivativeStructure x04 = variables[3]; [EOL]     DerivativeStructure x05 = variables[4]; [EOL]     DerivativeStructure x06 = variables[5]; [EOL]     DerivativeStructure x07 = variables[6]; [EOL]     DerivativeStructure x08 = variables[7]; [EOL]     DerivativeStructure x09 = variables[8]; [EOL]     DerivativeStructure x10 = variables[9]; [EOL]     DerivativeStructure x11 = variables[10]; [EOL]     DerivativeStructure[] f = new DerivativeStructure[m]; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         double temp = i / 10.0; [EOL]         DerivativeStructure tmp1 = x05.multiply(-temp).exp(); [EOL]         DerivativeStructure tmp2 = x06.negate().multiply(x09.subtract(temp).multiply(x09.subtract(temp))).exp(); [EOL]         DerivativeStructure tmp3 = x07.negate().multiply(x10.subtract(temp).multiply(x10.subtract(temp))).exp(); [EOL]         DerivativeStructure tmp4 = x08.negate().multiply(x11.subtract(temp).multiply(x11.subtract(temp))).exp(); [EOL]         f[i] = x01.multiply(tmp1).add(x02.multiply(tmp2)).add(x03.multiply(tmp3)).add(x04.multiply(tmp4)).negate().add(y[i]); [EOL]     } [EOL]     return f; [EOL] } <line_num>: 1168,1191
