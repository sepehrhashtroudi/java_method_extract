Cigar() { [EOL]     this(1e3); [EOL] } <line_num>: 380,382
Cigar(double axisratio) { [EOL]     factor = axisratio * axisratio; [EOL] } <line_num>: 384,386
Tablet() { [EOL]     this(1e3); [EOL] } <line_num>: 399,401
Tablet(double axisratio) { [EOL]     factor = axisratio * axisratio; [EOL] } <line_num>: 403,405
CigTab() { [EOL]     this(1e4); [EOL] } <line_num>: 418,420
CigTab(double axisratio) { [EOL]     factor = axisratio; [EOL] } <line_num>: 422,424
TwoAxes() { [EOL]     this(1e6); [EOL] } <line_num>: 439,441
TwoAxes(double axisratio) { [EOL]     factor = axisratio * axisratio; [EOL] } <line_num>: 443,445
ElliRotated() { [EOL]     this(1e3); [EOL] } <line_num>: 459,461
ElliRotated(double axisratio) { [EOL]     factor = axisratio * axisratio; [EOL] } <line_num>: 463,465
Elli() { [EOL]     this(1e3); [EOL] } <line_num>: 480,482
Elli(double axisratio) { [EOL]     factor = axisratio * axisratio; [EOL] } <line_num>: 484,486
Ackley(double axra) { [EOL]     axisratio = axra; [EOL] } <line_num>: 540,542
public Ackley() { [EOL]     this(1); [EOL] } <line_num>: 544,546
Rastrigin() { [EOL]     this(1, 10); [EOL] } <line_num>: 568,570
Rastrigin(double axisratio, double amplitude) { [EOL]     this.axisratio = axisratio; [EOL]     this.amplitude = amplitude; [EOL] } <line_num>: 572,575
@Test(expected = NumberIsTooLargeException.class) [EOL] public void testInitOutOfBounds() { [EOL]     double[] startPoint = point(DIM, 3); [EOL]     double[][] boundaries = boundaries(DIM, -1, 2); [EOL]     doTest(new Rosen(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 2000, null); [EOL] } <line_num>: 42,49
@Test(expected = DimensionMismatchException.class) [EOL] public void testBoundariesDimensionMismatch() { [EOL]     double[] startPoint = point(DIM, 0.5); [EOL]     double[][] boundaries = boundaries(DIM + 1, -1, 2); [EOL]     doTest(new Rosen(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 2000, null); [EOL] } <line_num>: 51,58
@Test(expected = NumberIsTooSmallException.class) [EOL] public void testProblemDimensionTooSmall() { [EOL]     double[] startPoint = point(1, 0.5); [EOL]     doTest(new Rosen(), startPoint, null, GoalType.MINIMIZE, 1e-13, 1e-6, 2000, null); [EOL] } <line_num>: 60,66
@Test(expected = TooManyEvaluationsException.class) [EOL] public void testMaxEvaluations() { [EOL]     final int lowMaxEval = 2; [EOL]     double[] startPoint = point(DIM, 0.1); [EOL]     double[][] boundaries = null; [EOL]     doTest(new Rosen(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, lowMaxEval, null); [EOL] } <line_num>: 68,76
@Test [EOL] public void testRosen() { [EOL]     double[] startPoint = point(DIM, 0.1); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 1.0), 0.0); [EOL]     doTest(new Rosen(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 2000, expected); [EOL] } <line_num>: 78,86
@Test [EOL] public void testMaximize() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 1.0); [EOL]     doTest(new MinusElli(), startPoint, boundaries, GoalType.MAXIMIZE, 2e-10, 5e-6, 1000, expected); [EOL]     boundaries = boundaries(DIM, -0.3, 0.3); [EOL]     startPoint = point(DIM, 0.1); [EOL]     doTest(new MinusElli(), startPoint, boundaries, GoalType.MAXIMIZE, 2e-10, 5e-6, 1000, expected); [EOL] } <line_num>: 88,101
@Test [EOL] public void testEllipse() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new Elli(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 1000, expected); [EOL] } <line_num>: 103,112
@Test [EOL] public void testElliRotated() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new ElliRotated(), startPoint, boundaries, GoalType.MINIMIZE, 1e-12, 1e-6, 10000, expected); [EOL] } <line_num>: 114,123
@Test [EOL] public void testCigar() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new Cigar(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 100, expected); [EOL] } <line_num>: 125,134
@Test [EOL] public void testTwoAxes() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new TwoAxes(), startPoint, boundaries, GoalType.MINIMIZE, 2 * 1e-13, 1e-6, 100, expected); [EOL] } <line_num>: 136,145
@Test [EOL] public void testCigTab() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new CigTab(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 5e-5, 100, expected); [EOL] } <line_num>: 147,156
@Test [EOL] public void testSphere() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new Sphere(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 100, expected); [EOL] } <line_num>: 158,167
@Test [EOL] public void testTablet() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new Tablet(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 100, expected); [EOL] } <line_num>: 169,178
@Test [EOL] public void testDiffPow() { [EOL] } <line_num>: 180,181
@Test [EOL] public void testSsDiffPow() { [EOL]     double[] startPoint = point(DIM / 2, 1.0); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM / 2, 0.0), 0.0); [EOL]     doTest(new SsDiffPow(), startPoint, boundaries, GoalType.MINIMIZE, 1e-2, 1.3e-1, 50000, expected); [EOL] } <line_num>: 194,203
@Test [EOL] public void testAckley() { [EOL] } <line_num>: 205,206
@Test [EOL] public void testRastrigin() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new Rastrigin(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 1000, expected); [EOL] } <line_num>: 219,229
@Test [EOL] public void testConstrainedRosen() { [EOL]     double[] startPoint = point(DIM, 0.1); [EOL]     double[][] boundaries = boundaries(DIM, -1, 2); [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 1.0), 0.0); [EOL]     doTest(new Rosen(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 2000, expected); [EOL] } <line_num>: 231,241
@Ignore [EOL] @Test [EOL] public void testConstrainedRosenWithMoreInterpolationPoints() { [EOL]     final double[] startPoint = point(DIM, 0.1); [EOL]     final double[][] boundaries = boundaries(DIM, -1, 2); [EOL]     final PointValuePair expected = new PointValuePair(point(DIM, 1.0), 0.0); [EOL]     final int maxAdditionalPoints = 47; [EOL]     for (int num = 1; num <= maxAdditionalPoints; num++) { [EOL]         doTest(new Rosen(), startPoint, boundaries, GoalType.MINIMIZE, 1e-12, 1e-6, 2000, num, expected, "num=" + num); [EOL]     } [EOL] } <line_num>: 246,267
private void doTest(MultivariateFunction func, double[] startPoint, double[][] boundaries, GoalType goal, double fTol, double pointTol, int maxEvaluations, PointValuePair expected) { [EOL]     doTest(func, startPoint, boundaries, goal, fTol, pointTol, maxEvaluations, 0, expected, ""); [EOL] } <line_num>: 279,297
private void doTest(MultivariateFunction func, double[] startPoint, double[][] boundaries, GoalType goal, double fTol, double pointTol, int maxEvaluations, int additionalInterpolationPoints, PointValuePair expected, String assertMsg) { [EOL]     int dim = startPoint.length; [EOL]     final double[] lB = boundaries == null ? null : boundaries[0]; [EOL]     final double[] uB = boundaries == null ? null : boundaries[1]; [EOL]     final int numIterpolationPoints = 2 * dim + 1 + additionalInterpolationPoints; [EOL]     BOBYQAOptimizer optim = new BOBYQAOptimizer(numIterpolationPoints); [EOL]     PointValuePair result = boundaries == null ? optim.optimize(maxEvaluations, func, goal, new InitialGuess(startPoint)) : optim.optimize(maxEvaluations, func, goal, new InitialGuess(startPoint), new SimpleBounds(lB, uB)); [EOL]     Assert.assertEquals(assertMsg, expected.getValue(), result.getValue(), fTol); [EOL]     for (int i = 0; i < dim; i++) { [EOL]         Assert.assertEquals(expected.getPoint()[i], result.getPoint()[i], pointTol); [EOL]     } [EOL] } <line_num>: 311,349
private static double[] point(int n, double value) { [EOL]     double[] ds = new double[n]; [EOL]     Arrays.fill(ds, value); [EOL]     return ds; [EOL] } <line_num>: 351,355
private static double[][] boundaries(int dim, double lower, double upper) { [EOL]     double[][] boundaries = new double[2][dim]; [EOL]     for (int i = 0; i < dim; i++) boundaries[0][i] = lower; [EOL]     for (int i = 0; i < dim; i++) boundaries[1][i] = upper; [EOL]     return boundaries; [EOL] } <line_num>: 357,365
public double value(double[] x) { [EOL]     double f = 0; [EOL]     for (int i = 0; i < x.length; ++i) f += x[i] * x[i]; [EOL]     return f; [EOL] } <line_num>: 369,374
public double value(double[] x) { [EOL]     double f = x[0] * x[0]; [EOL]     for (int i = 1; i < x.length; ++i) f += factor * x[i] * x[i]; [EOL]     return f; [EOL] } <line_num>: 388,393
public double value(double[] x) { [EOL]     double f = factor * x[0] * x[0]; [EOL]     for (int i = 1; i < x.length; ++i) f += x[i] * x[i]; [EOL]     return f; [EOL] } <line_num>: 407,412
public double value(double[] x) { [EOL]     int end = x.length - 1; [EOL]     double f = x[0] * x[0] / factor + factor * x[end] * x[end]; [EOL]     for (int i = 1; i < end; ++i) f += x[i] * x[i]; [EOL]     return f; [EOL] } <line_num>: 426,432
public double value(double[] x) { [EOL]     double f = 0; [EOL]     for (int i = 0; i < x.length; ++i) f += (i < x.length / 2 ? factor : 1) * x[i] * x[i]; [EOL]     return f; [EOL] } <line_num>: 447,452
public double value(double[] x) { [EOL]     double f = 0; [EOL]     x = B.Rotate(x); [EOL]     for (int i = 0; i < x.length; ++i) f += Math.pow(factor, i / (x.length - 1.)) * x[i] * x[i]; [EOL]     return f; [EOL] } <line_num>: 467,473
public double value(double[] x) { [EOL]     double f = 0; [EOL]     for (int i = 0; i < x.length; ++i) f += Math.pow(factor, i / (x.length - 1.)) * x[i] * x[i]; [EOL]     return f; [EOL] } <line_num>: 488,493
public double value(double[] x) { [EOL]     return 1.0 - elli.value(x); [EOL] } <line_num>: 498,500
public double value(double[] x) { [EOL]     double f = 0; [EOL]     for (int i = 0; i < x.length; ++i) f += Math.pow(Math.abs(x[i]), 2. + 10 * (double) i / (x.length - 1.)); [EOL]     return f; [EOL] } <line_num>: 505,515
public double value(double[] x) { [EOL]     double f = Math.pow(new DiffPow().value(x), 0.25); [EOL]     return f; [EOL] } <line_num>: 520,523
public double value(double[] x) { [EOL]     double f = 0; [EOL]     for (int i = 0; i < x.length - 1; ++i) f += 1e2 * (x[i] * x[i] - x[i + 1]) * (x[i] * x[i] - x[i + 1]) + (x[i] - 1.) * (x[i] - 1.); [EOL]     return f; [EOL] } <line_num>: 528,534
public double value(double[] x) { [EOL]     double f = 0; [EOL]     double res2 = 0; [EOL]     double fac = 0; [EOL]     for (int i = 0; i < x.length; ++i) { [EOL]         fac = Math.pow(axisratio, (i - 1.) / (x.length - 1.)); [EOL]         f += fac * fac * x[i] * x[i]; [EOL]         res2 += Math.cos(2. * Math.PI * fac * x[i]); [EOL]     } [EOL]     f = (20. - 20. * Math.exp(-0.2 * Math.sqrt(f / x.length)) + Math.exp(1.) - Math.exp(res2 / x.length)); [EOL]     return f; [EOL] } <line_num>: 548,560
public double value(double[] x) { [EOL]     double f = 0; [EOL]     double fac; [EOL]     for (int i = 0; i < x.length; ++i) { [EOL]         fac = Math.pow(axisratio, (i - 1.) / (x.length - 1.)); [EOL]         if (i == 0 && x[i] < 0) [EOL]             fac *= 1.; [EOL]         f += fac * fac * x[i] * x[i] + amplitude * (1. - Math.cos(2. * Math.PI * fac * x[i])); [EOL]     } [EOL]     return f; [EOL] } <line_num>: 577,588
double[] Rotate(double[] x) { [EOL]     GenBasis(x.length); [EOL]     double[] y = new double[x.length]; [EOL]     for (int i = 0; i < x.length; ++i) { [EOL]         y[i] = 0; [EOL]         for (int j = 0; j < x.length; ++j) y[i] += basis[i][j] * x[j]; [EOL]     } [EOL]     return y; [EOL] } <line_num>: 595,604
void GenBasis(int DIM) { [EOL]     if (basis != null ? basis.length == DIM : false) [EOL]         return; [EOL]     double sp; [EOL]     int i, j, k; [EOL]     basis = new double[DIM][DIM]; [EOL]     for (i = 0; i < DIM; ++i) { [EOL]         for (j = 0; j < DIM; ++j) basis[i][j] = rand.nextGaussian(); [EOL]         for (j = i - 1; j >= 0; --j) { [EOL]             for (sp = 0., k = 0; k < DIM; ++k) sp += basis[i][k] * basis[j][k]; [EOL]             for (k = 0; k < DIM; ++k) basis[i][k] -= sp * basis[j][k]; [EOL]         } [EOL]         for (sp = 0., k = 0; k < DIM; ++k) sp += basis[i][k] * basis[i][k]; [EOL]         for (k = 0; k < DIM; ++k) basis[i][k] /= Math.sqrt(sp); [EOL]     } [EOL] } <line_num>: 606,632
