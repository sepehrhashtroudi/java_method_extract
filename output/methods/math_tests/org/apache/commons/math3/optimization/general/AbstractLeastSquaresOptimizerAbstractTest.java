public LinearProblem(double[][] factors, double[] target) { [EOL]     this.factors = new BlockRealMatrix(factors); [EOL]     this.target = target; [EOL] } <line_num>: 501,504
public abstract AbstractLeastSquaresOptimizer createOptimizer(); <line_num>: 101,101
@Test [EOL] public void testTrivial() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 2 } }, new double[] { 3 }); [EOL]     AbstractLeastSquaresOptimizer optimizer = createOptimizer(); [EOL]     PointVectorValuePair optimum = optimizer.optimize(100, problem, problem.target, new double[] { 1 }, new double[] { 0 }); [EOL]     Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10); [EOL]     Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10); [EOL]     Assert.assertEquals(3.0, optimum.getValue()[0], 1.0e-10); [EOL]     try { [EOL]         optimizer.guessParametersErrors(); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (NumberIsTooSmallException ee) { [EOL]     } [EOL] } <line_num>: 103,119
@Test [EOL] public void testQRColumnsPermutation() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } }, new double[] { 4.0, 6.0, 1.0 }); [EOL]     AbstractLeastSquaresOptimizer optimizer = createOptimizer(); [EOL]     PointVectorValuePair optimum = optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0 }); [EOL]     Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10); [EOL]     Assert.assertEquals(7.0, optimum.getPoint()[0], 1.0e-10); [EOL]     Assert.assertEquals(3.0, optimum.getPoint()[1], 1.0e-10); [EOL]     Assert.assertEquals(4.0, optimum.getValue()[0], 1.0e-10); [EOL]     Assert.assertEquals(6.0, optimum.getValue()[1], 1.0e-10); [EOL]     Assert.assertEquals(1.0, optimum.getValue()[2], 1.0e-10); [EOL] } <line_num>: 121,137
@Test [EOL] public void testNoDependency() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 2, 0, 0, 0, 0, 0 }, { 0, 2, 0, 0, 0, 0 }, { 0, 0, 2, 0, 0, 0 }, { 0, 0, 0, 2, 0, 0 }, { 0, 0, 0, 0, 2, 0 }, { 0, 0, 0, 0, 0, 2 } }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 }); [EOL]     AbstractLeastSquaresOptimizer optimizer = createOptimizer(); [EOL]     PointVectorValuePair optimum = optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 }, new double[] { 0, 0, 0, 0, 0, 0 }); [EOL]     Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10); [EOL]     for (int i = 0; i < problem.target.length; ++i) { [EOL]         Assert.assertEquals(0.55 * i, optimum.getPoint()[i], 1.0e-10); [EOL]     } [EOL] } <line_num>: 139,157
@Test [EOL] public void testOneSet() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 1, 0, 0 }, { -1, 1, 0 }, { 0, -1, 1 } }, new double[] { 1, 1, 1 }); [EOL]     AbstractLeastSquaresOptimizer optimizer = createOptimizer(); [EOL]     PointVectorValuePair optimum = optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 }); [EOL]     Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10); [EOL]     Assert.assertEquals(1.0, optimum.getPoint()[0], 1.0e-10); [EOL]     Assert.assertEquals(2.0, optimum.getPoint()[1], 1.0e-10); [EOL]     Assert.assertEquals(3.0, optimum.getPoint()[2], 1.0e-10); [EOL] } <line_num>: 159,174
@Test [EOL] public void testTwoSets() { [EOL]     double epsilon = 1.0e-7; [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 2, 1, 0, 4, 0, 0 }, { -4, -2, 3, -7, 0, 0 }, { 4, 1, -2, 8, 0, 0 }, { 0, -3, -12, -1, 0, 0 }, { 0, 0, 0, 0, epsilon, 1 }, { 0, 0, 0, 0, 1, 1 } }, new double[] { 2, -9, 2, 2, 1 + epsilon * epsilon, 2 }); [EOL]     AbstractLeastSquaresOptimizer optimizer = createOptimizer(); [EOL]     PointVectorValuePair optimum = optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 }, new double[] { 0, 0, 0, 0, 0, 0 }); [EOL]     Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10); [EOL]     Assert.assertEquals(3.0, optimum.getPoint()[0], 1.0e-10); [EOL]     Assert.assertEquals(4.0, optimum.getPoint()[1], 1.0e-10); [EOL]     Assert.assertEquals(-1.0, optimum.getPoint()[2], 1.0e-10); [EOL]     Assert.assertEquals(-2.0, optimum.getPoint()[3], 1.0e-10); [EOL]     Assert.assertEquals(1.0 + epsilon, optimum.getPoint()[4], 1.0e-10); [EOL]     Assert.assertEquals(1.0 - epsilon, optimum.getPoint()[5], 1.0e-10); [EOL] } <line_num>: 176,199
@Test(expected = ConvergenceException.class) [EOL] public void testNonInvertible() throws Exception { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 1, 2, -3 }, { 2, 1, 3 }, { -3, 0, -9 } }, new double[] { 1, 1, 1 }); [EOL]     AbstractLeastSquaresOptimizer optimizer = createOptimizer(); [EOL]     optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 }); [EOL] } <line_num>: 201,213
@Test [EOL] public void testIllConditioned() { [EOL]     LinearProblem problem1 = new LinearProblem(new double[][] { { 10.0, 7.0, 8.0, 7.0 }, { 7.0, 5.0, 6.0, 5.0 }, { 8.0, 6.0, 10.0, 9.0 }, { 7.0, 5.0, 9.0, 10.0 } }, new double[] { 32, 23, 33, 31 }); [EOL]     AbstractLeastSquaresOptimizer optimizer = createOptimizer(); [EOL]     PointVectorValuePair optimum1 = optimizer.optimize(100, problem1, problem1.target, new double[] { 1, 1, 1, 1 }, new double[] { 0, 1, 2, 3 }); [EOL]     Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10); [EOL]     Assert.assertEquals(1.0, optimum1.getPoint()[0], 1.0e-10); [EOL]     Assert.assertEquals(1.0, optimum1.getPoint()[1], 1.0e-10); [EOL]     Assert.assertEquals(1.0, optimum1.getPoint()[2], 1.0e-10); [EOL]     Assert.assertEquals(1.0, optimum1.getPoint()[3], 1.0e-10); [EOL]     LinearProblem problem2 = new LinearProblem(new double[][] { { 10.00, 7.00, 8.10, 7.20 }, { 7.08, 5.04, 6.00, 5.00 }, { 8.00, 5.98, 9.89, 9.00 }, { 6.99, 4.99, 9.00, 9.98 } }, new double[] { 32, 23, 33, 31 }); [EOL]     PointVectorValuePair optimum2 = optimizer.optimize(100, problem2, problem2.target, new double[] { 1, 1, 1, 1 }, new double[] { 0, 1, 2, 3 }); [EOL]     Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10); [EOL]     Assert.assertEquals(-81.0, optimum2.getPoint()[0], 1.0e-8); [EOL]     Assert.assertEquals(137.0, optimum2.getPoint()[1], 1.0e-8); [EOL]     Assert.assertEquals(-34.0, optimum2.getPoint()[2], 1.0e-8); [EOL]     Assert.assertEquals(22.0, optimum2.getPoint()[3], 1.0e-8); [EOL] } <line_num>: 215,247
@Test [EOL] public void testMoreEstimatedParametersSimple() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 3.0, 2.0, 0.0, 0.0 }, { 0.0, 1.0, -1.0, 1.0 }, { 2.0, 0.0, 1.0, 0.0 } }, new double[] { 7.0, 3.0, 5.0 }); [EOL]     AbstractLeastSquaresOptimizer optimizer = createOptimizer(); [EOL]     optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 7, 6, 5, 4 }); [EOL]     Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10); [EOL] } <line_num>: 249,262
@Test [EOL] public void testMoreEstimatedParametersUnsorted() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 1.0, 1.0, 0.0, 0.0, 0.0, 0.0 }, { 0.0, 0.0, 1.0, 1.0, 1.0, 0.0 }, { 0.0, 0.0, 0.0, 0.0, 1.0, -1.0 }, { 0.0, 0.0, -1.0, 1.0, 0.0, 1.0 }, { 0.0, 0.0, 0.0, -1.0, 1.0, 0.0 } }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 }); [EOL]     AbstractLeastSquaresOptimizer optimizer = createOptimizer(); [EOL]     PointVectorValuePair optimum = optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1 }, new double[] { 2, 2, 2, 2, 2, 2 }); [EOL]     Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10); [EOL]     Assert.assertEquals(3.0, optimum.getPointRef()[2], 1.0e-10); [EOL]     Assert.assertEquals(4.0, optimum.getPointRef()[3], 1.0e-10); [EOL]     Assert.assertEquals(5.0, optimum.getPointRef()[4], 1.0e-10); [EOL]     Assert.assertEquals(6.0, optimum.getPointRef()[5], 1.0e-10); [EOL] } <line_num>: 264,283
@Test [EOL] public void testRedundantEquations() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 1.0, 1.0 }, { 1.0, -1.0 }, { 1.0, 3.0 } }, new double[] { 3.0, 1.0, 5.0 }); [EOL]     AbstractLeastSquaresOptimizer optimizer = createOptimizer(); [EOL]     PointVectorValuePair optimum = optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 1, 1 }); [EOL]     Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10); [EOL]     Assert.assertEquals(2.0, optimum.getPointRef()[0], 1.0e-10); [EOL]     Assert.assertEquals(1.0, optimum.getPointRef()[1], 1.0e-10); [EOL] } <line_num>: 285,300
@Test [EOL] public void testInconsistentEquations() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 1.0, 1.0 }, { 1.0, -1.0 }, { 1.0, 3.0 } }, new double[] { 3.0, 1.0, 4.0 }); [EOL]     AbstractLeastSquaresOptimizer optimizer = createOptimizer(); [EOL]     optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 1, 1 }); [EOL]     Assert.assertTrue(optimizer.getRMS() > 0.1); [EOL] } <line_num>: 302,313
@Test(expected = DimensionMismatchException.class) [EOL] public void testInconsistentSizes1() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 }); [EOL]     AbstractLeastSquaresOptimizer optimizer = createOptimizer(); [EOL]     PointVectorValuePair optimum = optimizer.optimize(100, problem, problem.target, new double[] { 1, 1 }, new double[] { 0, 0 }); [EOL]     Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10); [EOL]     Assert.assertEquals(-1, optimum.getPoint()[0], 1.0e-10); [EOL]     Assert.assertEquals(+1, optimum.getPoint()[1], 1.0e-10); [EOL]     optimizer.optimize(100, problem, problem.target, new double[] { 1 }, new double[] { 0, 0 }); [EOL] } <line_num>: 315,329
@Test(expected = DimensionMismatchException.class) [EOL] public void testInconsistentSizes2() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 }); [EOL]     AbstractLeastSquaresOptimizer optimizer = createOptimizer(); [EOL]     PointVectorValuePair optimum = optimizer.optimize(100, problem, problem.target, new double[] { 1, 1 }, new double[] { 0, 0 }); [EOL]     Assert.assertEquals(0, optimizer.getRMS(), 1.0e-10); [EOL]     Assert.assertEquals(-1, optimum.getPoint()[0], 1.0e-10); [EOL]     Assert.assertEquals(+1, optimum.getPoint()[1], 1.0e-10); [EOL]     optimizer.optimize(100, problem, new double[] { 1 }, new double[] { 1 }, new double[] { 0, 0 }); [EOL] } <line_num>: 331,345
@Test [EOL] public void testCircleFitting() { [EOL]     CircleVectorial circle = new CircleVectorial(); [EOL]     circle.addPoint(30.0, 68.0); [EOL]     circle.addPoint(50.0, -6.0); [EOL]     circle.addPoint(110.0, -20.0); [EOL]     circle.addPoint(35.0, 15.0); [EOL]     circle.addPoint(45.0, 97.0); [EOL]     AbstractLeastSquaresOptimizer optimizer = createOptimizer(); [EOL]     PointVectorValuePair optimum = optimizer.optimize(100, circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 }, new double[] { 98.680, 47.345 }); [EOL]     Assert.assertTrue(optimizer.getEvaluations() < 10); [EOL]     Assert.assertTrue(optimizer.getJacobianEvaluations() < 10); [EOL]     double rms = optimizer.getRMS(); [EOL]     Assert.assertEquals(1.768262623567235, FastMath.sqrt(circle.getN()) * rms, 1.0e-10); [EOL]     Vector2D center = new Vector2D(optimum.getPointRef()[0], optimum.getPointRef()[1]); [EOL]     Assert.assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-6); [EOL]     Assert.assertEquals(96.07590211815305, center.getX(), 1.0e-6); [EOL]     Assert.assertEquals(48.13516790438953, center.getY(), 1.0e-6); [EOL]     double[][] cov = optimizer.computeCovariances(optimum.getPoint(), 1e-14); [EOL]     Assert.assertEquals(1.839, cov[0][0], 0.001); [EOL]     Assert.assertEquals(0.731, cov[0][1], 0.001); [EOL]     Assert.assertEquals(cov[0][1], cov[1][0], 1.0e-14); [EOL]     Assert.assertEquals(0.786, cov[1][1], 0.001); [EOL]     double r = circle.getRadius(center); [EOL]     for (double d = 0; d < 2 * FastMath.PI; d += 0.01) { [EOL]         circle.addPoint(center.getX() + r * FastMath.cos(d), center.getY() + r * FastMath.sin(d)); [EOL]     } [EOL]     double[] target = new double[circle.getN()]; [EOL]     Arrays.fill(target, 0.0); [EOL]     double[] weights = new double[circle.getN()]; [EOL]     Arrays.fill(weights, 2.0); [EOL]     optimum = optimizer.optimize(100, circle, target, weights, new double[] { 98.680, 47.345 }); [EOL]     cov = optimizer.computeCovariances(optimum.getPoint(), 1e-14); [EOL]     Assert.assertEquals(0.0016, cov[0][0], 0.001); [EOL]     Assert.assertEquals(3.2e-7, cov[0][1], 1.0e-9); [EOL]     Assert.assertEquals(cov[0][1], cov[1][0], 1.0e-14); [EOL]     Assert.assertEquals(0.0016, cov[1][1], 0.001); [EOL] } <line_num>: 347,388
@Test [EOL] public void testCircleFittingBadInit() { [EOL]     CircleVectorial circle = new CircleVectorial(); [EOL]     double[][] points = circlePoints; [EOL]     double[] target = new double[points.length]; [EOL]     Arrays.fill(target, 0.0); [EOL]     double[] weights = new double[points.length]; [EOL]     Arrays.fill(weights, 2.0); [EOL]     for (int i = 0; i < points.length; ++i) { [EOL]         circle.addPoint(points[i][0], points[i][1]); [EOL]     } [EOL]     AbstractLeastSquaresOptimizer optimizer = createOptimizer(); [EOL]     PointVectorValuePair optimum = optimizer.optimize(100, circle, target, weights, new double[] { -12, -12 }); [EOL]     Vector2D center = new Vector2D(optimum.getPointRef()[0], optimum.getPointRef()[1]); [EOL]     Assert.assertTrue(optimizer.getEvaluations() < 25); [EOL]     Assert.assertTrue(optimizer.getJacobianEvaluations() < 20); [EOL]     Assert.assertEquals(0.043, optimizer.getRMS(), 1.0e-3); [EOL]     Assert.assertEquals(0.292235, circle.getRadius(center), 1.0e-6); [EOL]     Assert.assertEquals(-0.151738, center.getX(), 1.0e-6); [EOL]     Assert.assertEquals(0.2075001, center.getY(), 1.0e-6); [EOL] } <line_num>: 390,411
@Test [EOL] public void testCircleFittingGoodInit() { [EOL]     CircleVectorial circle = new CircleVectorial(); [EOL]     double[][] points = circlePoints; [EOL]     double[] target = new double[points.length]; [EOL]     Arrays.fill(target, 0.0); [EOL]     double[] weights = new double[points.length]; [EOL]     Arrays.fill(weights, 2.0); [EOL]     for (int i = 0; i < points.length; ++i) { [EOL]         circle.addPoint(points[i][0], points[i][1]); [EOL]     } [EOL]     AbstractLeastSquaresOptimizer optimizer = createOptimizer(); [EOL]     PointVectorValuePair optimum = optimizer.optimize(100, circle, target, weights, new double[] { 0, 0 }); [EOL]     Assert.assertEquals(-0.1517383071957963, optimum.getPointRef()[0], 1.0e-6); [EOL]     Assert.assertEquals(0.2074999736353867, optimum.getPointRef()[1], 1.0e-6); [EOL]     Assert.assertEquals(0.04268731682389561, optimizer.getRMS(), 1.0e-8); [EOL] } <line_num>: 413,430
public void doTestStRD(final StatisticalReferenceDataset dataset, final double errParams, final double errParamsSd) { [EOL]     final AbstractLeastSquaresOptimizer optimizer = createOptimizer(); [EOL]     final double[] w = new double[dataset.getNumObservations()]; [EOL]     Arrays.fill(w, 1.0); [EOL]     final double[][] data = dataset.getData(); [EOL]     final double[] initial = dataset.getStartingPoint(0); [EOL]     final MultivariateDifferentiableVectorFunction problem; [EOL]     problem = dataset.getLeastSquaresProblem(); [EOL]     final PointVectorValuePair optimum; [EOL]     optimum = optimizer.optimize(100, problem, data[1], w, initial); [EOL]     final double[] actual = optimum.getPoint(); [EOL]     for (int i = 0; i < actual.length; i++) { [EOL]         double expected = dataset.getParameter(i); [EOL]         double delta = FastMath.abs(errParams * expected); [EOL]         Assert.assertEquals(dataset.getName() + ", param #" + i, expected, actual[i], delta); [EOL]     } [EOL] } <line_num>: 464,484
@Test [EOL] public void testKirby2() throws IOException { [EOL]     doTestStRD(StatisticalReferenceDatasetFactory.createKirby2(), 1E-7, 1E-7); [EOL] } <line_num>: 486,489
@Test [EOL] public void testHahn1() throws IOException { [EOL]     doTestStRD(StatisticalReferenceDatasetFactory.createHahn1(), 1E-7, 1E-4); [EOL] } <line_num>: 491,494
public double[] value(double[] variables) { [EOL]     return factors.operate(variables); [EOL] } <line_num>: 506,508
public DerivativeStructure[] value(DerivativeStructure[] variables) { [EOL]     DerivativeStructure[] value = new DerivativeStructure[factors.getRowDimension()]; [EOL]     for (int i = 0; i < value.length; ++i) { [EOL]         value[i] = variables[0].getField().getZero(); [EOL]         for (int j = 0; j < factors.getColumnDimension(); ++j) { [EOL]             value[i] = value[i].add(variables[j].multiply(factors.getEntry(i, j))); [EOL]         } [EOL]     } [EOL]     return value; [EOL] } <line_num>: 510,520
