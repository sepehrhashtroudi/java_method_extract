@Test [EOL] public void testSinMin() { [EOL]     UnivariateFunction f = new Sin(); [EOL]     UnivariateOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14); [EOL]     Assert.assertEquals(3 * Math.PI / 2, optimizer.optimize(200, f, GoalType.MINIMIZE, 4, 5).getPoint(), 1e-8); [EOL]     Assert.assertTrue(optimizer.getEvaluations() <= 50); [EOL]     Assert.assertEquals(200, optimizer.getMaxEvaluations()); [EOL]     Assert.assertEquals(3 * Math.PI / 2, optimizer.optimize(200, f, GoalType.MINIMIZE, 1, 5).getPoint(), 1e-8); [EOL]     Assert.assertTrue(optimizer.getEvaluations() <= 100); [EOL]     Assert.assertTrue(optimizer.getEvaluations() >= 15); [EOL]     try { [EOL]         optimizer.optimize(10, f, GoalType.MINIMIZE, 4, 5); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (TooManyEvaluationsException fee) { [EOL]     } [EOL] } <line_num>: 40,56
@Test [EOL] public void testSinMinWithValueChecker() { [EOL]     final UnivariateFunction f = new Sin(); [EOL]     final ConvergenceChecker<UnivariatePointValuePair> checker = new SimpleUnivariateValueChecker(1e-5, 1e-14); [EOL]     final UnivariateOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14, checker); [EOL]     final UnivariatePointValuePair result = optimizer.optimize(200, f, GoalType.MINIMIZE, 4, 5); [EOL]     Assert.assertEquals(3 * Math.PI / 2, result.getPoint(), 1e-3); [EOL] } <line_num>: 58,68
public double value(double x) { [EOL]     if (x < lower) { [EOL]         throw new NumberIsTooSmallException(x, lower, true); [EOL]     } else if (x > upper) { [EOL]         throw new NumberIsTooLargeException(x, upper, true); [EOL]     } else { [EOL]         return x; [EOL]     } [EOL] } <line_num>: 75,83
@Test [EOL] public void testBoundaries() { [EOL]     final double lower = -1.0; [EOL]     final double upper = +1.0; [EOL]     UnivariateFunction f = new UnivariateFunction() { [EOL]  [EOL]         public double value(double x) { [EOL]             if (x < lower) { [EOL]                 throw new NumberIsTooSmallException(x, lower, true); [EOL]             } else if (x > upper) { [EOL]                 throw new NumberIsTooLargeException(x, upper, true); [EOL]             } else { [EOL]                 return x; [EOL]             } [EOL]         } [EOL]     }; [EOL]     UnivariateOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14); [EOL]     Assert.assertEquals(lower, optimizer.optimize(100, f, GoalType.MINIMIZE, lower, upper).getPoint(), 1.0e-8); [EOL]     Assert.assertEquals(upper, optimizer.optimize(100, f, GoalType.MAXIMIZE, lower, upper).getPoint(), 1.0e-8); [EOL] } <line_num>: 70,92
@Test [EOL] public void testQuinticMin() { [EOL]     UnivariateFunction f = new QuinticFunction(); [EOL]     UnivariateOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14); [EOL]     Assert.assertEquals(-0.27195613, optimizer.optimize(200, f, GoalType.MINIMIZE, -0.3, -0.2).getPoint(), 1.0e-8); [EOL]     Assert.assertEquals(0.82221643, optimizer.optimize(200, f, GoalType.MINIMIZE, 0.3, 0.9).getPoint(), 1.0e-8); [EOL]     Assert.assertTrue(optimizer.getEvaluations() <= 50); [EOL]     Assert.assertEquals(-0.27195613, optimizer.optimize(200, f, GoalType.MINIMIZE, -1.0, 0.2).getPoint(), 1.0e-8); [EOL]     Assert.assertTrue(optimizer.getEvaluations() <= 50); [EOL] } <line_num>: 94,106
@Test [EOL] public void testQuinticMinStatistics() { [EOL]     UnivariateFunction f = new QuinticFunction(); [EOL]     UnivariateOptimizer optimizer = new BrentOptimizer(1e-11, 1e-14); [EOL]     final DescriptiveStatistics[] stat = new DescriptiveStatistics[2]; [EOL]     for (int i = 0; i < stat.length; i++) { [EOL]         stat[i] = new DescriptiveStatistics(); [EOL]     } [EOL]     final double min = -0.75; [EOL]     final double max = 0.25; [EOL]     final int nSamples = 200; [EOL]     final double delta = (max - min) / nSamples; [EOL]     for (int i = 0; i < nSamples; i++) { [EOL]         final double start = min + i * delta; [EOL]         stat[0].addValue(optimizer.optimize(40, f, GoalType.MINIMIZE, min, max, start).getPoint()); [EOL]         stat[1].addValue(optimizer.getEvaluations()); [EOL]     } [EOL]     final double meanOptValue = stat[0].getMean(); [EOL]     final double medianEval = stat[1].getPercentile(50); [EOL]     Assert.assertTrue(meanOptValue > -0.2719561281); [EOL]     Assert.assertTrue(meanOptValue < -0.2719561280); [EOL]     Assert.assertEquals(23, (int) medianEval); [EOL] } <line_num>: 108,134
@Test [EOL] public void testQuinticMax() { [EOL]     UnivariateFunction f = new QuinticFunction(); [EOL]     UnivariateOptimizer optimizer = new BrentOptimizer(1e-12, 1e-14); [EOL]     Assert.assertEquals(0.27195613, optimizer.optimize(100, f, GoalType.MAXIMIZE, 0.2, 0.3).getPoint(), 1e-8); [EOL]     try { [EOL]         optimizer.optimize(5, f, GoalType.MAXIMIZE, 0.2, 0.3); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (TooManyEvaluationsException miee) { [EOL]     } [EOL] } <line_num>: 136,149
@Test [EOL] public void testMinEndpoints() { [EOL]     UnivariateFunction f = new Sin(); [EOL]     UnivariateOptimizer optimizer = new BrentOptimizer(1e-8, 1e-14); [EOL]     double result = optimizer.optimize(50, f, GoalType.MINIMIZE, 3 * Math.PI / 2, 5).getPoint(); [EOL]     Assert.assertEquals(3 * Math.PI / 2, result, 1e-6); [EOL]     result = optimizer.optimize(50, f, GoalType.MINIMIZE, 4, 3 * Math.PI / 2).getPoint(); [EOL]     Assert.assertEquals(3 * Math.PI / 2, result, 1e-6); [EOL] } <line_num>: 151,162
public double value(double x) { [EOL]     final double sqrtX = FastMath.sqrt(x); [EOL]     final double a = 1e2 * sqrtX; [EOL]     final double b = 1e6 / x; [EOL]     final double c = 1e4 / sqrtX; [EOL]     return a + b + c; [EOL] } <line_num>: 167,174
@Test [EOL] public void testMath832() { [EOL]     final UnivariateFunction f = new UnivariateFunction() { [EOL]  [EOL]         public double value(double x) { [EOL]             final double sqrtX = FastMath.sqrt(x); [EOL]             final double a = 1e2 * sqrtX; [EOL]             final double b = 1e6 / x; [EOL]             final double c = 1e4 / sqrtX; [EOL]             return a + b + c; [EOL]         } [EOL]     }; [EOL]     UnivariateOptimizer optimizer = new BrentOptimizer(1e-10, 1e-8); [EOL]     final double result = optimizer.optimize(1483, f, GoalType.MINIMIZE, Double.MIN_VALUE, Double.MAX_VALUE).getPoint(); [EOL]     Assert.assertEquals(804.9355825, result, 1e-6); [EOL] } <line_num>: 164,185
@Test [EOL] public void testKeepInitIfBest() { [EOL]     final double minSin = 3 * Math.PI / 2; [EOL]     final double offset = 1e-8; [EOL]     final double delta = 1e-7; [EOL]     final UnivariateFunction f1 = new Sin(); [EOL]     final UnivariateFunction f2 = new StepFunction(new double[] { minSin, minSin + offset, minSin + 2 * offset }, new double[] { 0, -1, 0 }); [EOL]     final UnivariateFunction f = FunctionUtils.add(f1, f2); [EOL]     final double relTol = 1e-8; [EOL]     final UnivariateOptimizer optimizer = new BrentOptimizer(relTol, 1e-100); [EOL]     final double init = minSin + 1.5 * offset; [EOL]     final UnivariatePointValuePair result = optimizer.optimize(200, f, GoalType.MINIMIZE, minSin - 6.789 * delta, minSin + 9.876 * delta, init); [EOL]     final int numEval = optimizer.getEvaluations(); [EOL]     final double sol = result.getPoint(); [EOL]     final double expected = init; [EOL]     Assert.assertTrue("Best point not reported", f.value(sol) <= f.value(expected)); [EOL] } <line_num>: 192,222
@Test [EOL] public void testMath855() { [EOL]     final double minSin = 3 * Math.PI / 2; [EOL]     final double offset = 1e-8; [EOL]     final double delta = 1e-7; [EOL]     final UnivariateFunction f1 = new Sin(); [EOL]     final UnivariateFunction f2 = new StepFunction(new double[] { minSin, minSin + offset, minSin + 5 * offset }, new double[] { 0, -1, 0 }); [EOL]     final UnivariateFunction f = FunctionUtils.add(f1, f2); [EOL]     final UnivariateOptimizer optimizer = new BrentOptimizer(1e-8, 1e-100); [EOL]     final UnivariatePointValuePair result = optimizer.optimize(200, f, GoalType.MINIMIZE, minSin - 6.789 * delta, minSin + 9.876 * delta); [EOL]     final int numEval = optimizer.getEvaluations(); [EOL]     final double sol = result.getPoint(); [EOL]     final double expected = 4.712389027602411; [EOL]     Assert.assertTrue("Best point not reported", f.value(sol) <= f.value(expected)); [EOL] } <line_num>: 229,253
