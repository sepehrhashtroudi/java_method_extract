public FastCosineTransformerTest(final DctNormalization normalization) { [EOL]     this.normalization = normalization; [EOL]     this.validDataSize = new int[] { 2, 3, 5, 9, 17, 33, 65, 129 }; [EOL]     this.invalidDataSize = new int[] { 128 }; [EOL]     this.relativeTolerance = new double[] { 1E-15, 1E-15, 1E-14, 1E-13, 1E-13, 1E-12, 1E-11, 1E-10 }; [EOL] } <line_num>: 53,64
@Parameters [EOL] public static Collection<Object[]> data() { [EOL]     final DctNormalization[] normalization = DctNormalization.values(); [EOL]     final Object[][] data = new DctNormalization[normalization.length][1]; [EOL]     for (int i = 0; i < normalization.length; i++) { [EOL]         data[i][0] = normalization[i]; [EOL]     } [EOL]     return Arrays.asList(data); [EOL] } <line_num>: 72,80
@Override [EOL] RealTransformer createRealTransformer() { [EOL]     return new FastCosineTransformer(normalization); [EOL] } <line_num>: 82,85
@Override [EOL] int getInvalidDataSize(final int i) { [EOL]     return invalidDataSize[i]; [EOL] } <line_num>: 87,90
@Override [EOL] int getNumberOfInvalidDataSizes() { [EOL]     return invalidDataSize.length; [EOL] } <line_num>: 92,95
@Override [EOL] int getNumberOfValidDataSizes() { [EOL]     return validDataSize.length; [EOL] } <line_num>: 97,100
@Override [EOL] double getRelativeTolerance(final int i) { [EOL]     return relativeTolerance[i]; [EOL] } <line_num>: 102,105
@Override [EOL] int getValidDataSize(final int i) { [EOL]     return validDataSize[i]; [EOL] } <line_num>: 107,110
@Override [EOL] UnivariateFunction getValidFunction() { [EOL]     return new Sinc(); [EOL] } <line_num>: 112,115
@Override [EOL] double getValidLowerBound() { [EOL]     return 0.0; [EOL] } <line_num>: 117,120
@Override [EOL] double getValidUpperBound() { [EOL]     return FastMath.PI; [EOL] } <line_num>: 122,125
@Override [EOL] double[] transform(final double[] x, final TransformType type) { [EOL]     final int n = x.length; [EOL]     final double[] y = new double[n]; [EOL]     final double[] cos = new double[2 * (n - 1)]; [EOL]     for (int i = 0; i < cos.length; i++) { [EOL]         cos[i] = FastMath.cos(FastMath.PI * i / (n - 1.0)); [EOL]     } [EOL]     int sgn = 1; [EOL]     for (int j = 0; j < n; j++) { [EOL]         double yj = 0.5 * (x[0] + sgn * x[n - 1]); [EOL]         for (int i = 1; i < n - 1; i++) { [EOL]             yj += x[i] * cos[(i * j) % cos.length]; [EOL]         } [EOL]         y[j] = yj; [EOL]         sgn *= -1; [EOL]     } [EOL]     final double s; [EOL]     if (type == TransformType.FORWARD) { [EOL]         if (normalization == DctNormalization.STANDARD_DCT_I) { [EOL]             s = 1.0; [EOL]         } else if (normalization == DctNormalization.ORTHOGONAL_DCT_I) { [EOL]             s = FastMath.sqrt(2.0 / (n - 1.0)); [EOL]         } else { [EOL]             throw new MathIllegalStateException(); [EOL]         } [EOL]     } else if (type == TransformType.INVERSE) { [EOL]         if (normalization == DctNormalization.STANDARD_DCT_I) { [EOL]             s = 2.0 / (n - 1.0); [EOL]         } else if (normalization == DctNormalization.ORTHOGONAL_DCT_I) { [EOL]             s = FastMath.sqrt(2.0 / (n - 1.0)); [EOL]         } else { [EOL]             throw new MathIllegalStateException(); [EOL]         } [EOL]     } else { [EOL]         throw new MathIllegalStateException(); [EOL]     } [EOL]     TransformUtils.scaleArray(y, s); [EOL]     return y; [EOL] } <line_num>: 127,170
@Test [EOL] public void testAdHocData() { [EOL]     FastCosineTransformer transformer; [EOL]     transformer = new FastCosineTransformer(DctNormalization.STANDARD_DCT_I); [EOL]     double result[], tolerance = 1E-12; [EOL]     double[] x = { 0.0, 1.0, 4.0, 9.0, 16.0, 25.0, 36.0, 49.0, 64.0 }; [EOL]     double[] y = { 172.0, -105.096569476353, 27.3137084989848, -12.9593152353742, 8.0, -5.78585076868676, 4.68629150101524, -4.15826451958632, 4.0 }; [EOL]     result = transformer.transform(x, TransformType.FORWARD); [EOL]     for (int i = 0; i < result.length; i++) { [EOL]         Assert.assertEquals(y[i], result[i], tolerance); [EOL]     } [EOL]     result = transformer.transform(y, TransformType.INVERSE); [EOL]     for (int i = 0; i < result.length; i++) { [EOL]         Assert.assertEquals(x[i], result[i], tolerance); [EOL]     } [EOL]     TransformUtils.scaleArray(x, FastMath.sqrt(0.5 * (x.length - 1))); [EOL]     transformer = new FastCosineTransformer(DctNormalization.ORTHOGONAL_DCT_I); [EOL]     result = transformer.transform(y, TransformType.FORWARD); [EOL]     for (int i = 0; i < result.length; i++) { [EOL]         Assert.assertEquals(x[i], result[i], tolerance); [EOL]     } [EOL]     result = transformer.transform(x, TransformType.INVERSE); [EOL]     for (int i = 0; i < result.length; i++) { [EOL]         Assert.assertEquals(y[i], result[i], tolerance); [EOL]     } [EOL] } <line_num>: 177,215
@Test [EOL] public void testParameters() throws Exception { [EOL]     UnivariateFunction f = new Sin(); [EOL]     FastCosineTransformer transformer; [EOL]     transformer = new FastCosineTransformer(DctNormalization.STANDARD_DCT_I); [EOL]     try { [EOL]         transformer.transform(f, 1, -1, 65, TransformType.FORWARD); [EOL]         Assert.fail("Expecting IllegalArgumentException - bad interval"); [EOL]     } catch (IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         transformer.transform(f, -1, 1, 1, TransformType.FORWARD); [EOL]         Assert.fail("Expecting IllegalArgumentException - bad samples number"); [EOL]     } catch (IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         transformer.transform(f, -1, 1, 64, TransformType.FORWARD); [EOL]         Assert.fail("Expecting IllegalArgumentException - bad samples number"); [EOL]     } catch (IllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 218,248
@Test [EOL] public void testSinFunction() { [EOL]     UnivariateFunction f = new Sin(); [EOL]     FastCosineTransformer transformer; [EOL]     transformer = new FastCosineTransformer(DctNormalization.STANDARD_DCT_I); [EOL]     double min, max, result[], tolerance = 1E-12; [EOL]     int N = 9; [EOL]     double[] expected = { 0.0, 3.26197262739567, 0.0, -2.17958042710327, 0.0, -0.648846697642915, 0.0, -0.433545502649478, 0.0 }; [EOL]     min = 0.0; [EOL]     max = 2.0 * FastMath.PI * N / (N - 1); [EOL]     result = transformer.transform(f, min, max, N, TransformType.FORWARD); [EOL]     for (int i = 0; i < N; i++) { [EOL]         Assert.assertEquals(expected[i], result[i], tolerance); [EOL]     } [EOL]     min = -FastMath.PI; [EOL]     max = FastMath.PI * (N + 1) / (N - 1); [EOL]     result = transformer.transform(f, min, max, N, TransformType.FORWARD); [EOL]     for (int i = 0; i < N; i++) { [EOL]         Assert.assertEquals(-expected[i], result[i], tolerance); [EOL]     } [EOL] } <line_num>: 251,277
