public FastSineTransformerTest(final DstNormalization normalization) { [EOL]     this.normalization = normalization; [EOL]     this.validDataSize = new int[] { 1, 2, 4, 8, 16, 32, 64, 128 }; [EOL]     this.invalidDataSize = new int[] { 129 }; [EOL]     this.relativeTolerance = new double[] { 1E-15, 1E-15, 1E-14, 1E-14, 1E-13, 1E-12, 1E-11, 1E-11 }; [EOL] } <line_num>: 53,64
@Parameters [EOL] public static Collection<Object[]> data() { [EOL]     final DstNormalization[] normalization = DstNormalization.values(); [EOL]     final Object[][] data = new DstNormalization[normalization.length][1]; [EOL]     for (int i = 0; i < normalization.length; i++) { [EOL]         data[i][0] = normalization[i]; [EOL]     } [EOL]     return Arrays.asList(data); [EOL] } <line_num>: 72,80
@Override [EOL] double[] createRealData(final int n) { [EOL]     final double[] data = super.createRealData(n); [EOL]     data[0] = 0.0; [EOL]     return data; [EOL] } <line_num>: 88,93
@Override [EOL] RealTransformer createRealTransformer() { [EOL]     return new FastSineTransformer(normalization); [EOL] } <line_num>: 95,98
@Override [EOL] int getInvalidDataSize(final int i) { [EOL]     return invalidDataSize[i]; [EOL] } <line_num>: 100,103
@Override [EOL] int getNumberOfInvalidDataSizes() { [EOL]     return invalidDataSize.length; [EOL] } <line_num>: 105,108
@Override [EOL] int getNumberOfValidDataSizes() { [EOL]     return validDataSize.length; [EOL] } <line_num>: 110,113
@Override [EOL] double getRelativeTolerance(final int i) { [EOL]     return relativeTolerance[i]; [EOL] } <line_num>: 115,118
@Override [EOL] int getValidDataSize(final int i) { [EOL]     return validDataSize[i]; [EOL] } <line_num>: 120,123
@Override [EOL] UnivariateFunction getValidFunction() { [EOL]     return new Sinc(); [EOL] } <line_num>: 125,128
@Override [EOL] double getValidLowerBound() { [EOL]     return 0.0; [EOL] } <line_num>: 130,133
@Override [EOL] double getValidUpperBound() { [EOL]     return FastMath.PI; [EOL] } <line_num>: 135,138
@Override [EOL] double[] transform(final double[] x, final TransformType type) { [EOL]     final int n = x.length; [EOL]     final double[] y = new double[n]; [EOL]     final double[] sin = new double[2 * n]; [EOL]     for (int i = 0; i < sin.length; i++) { [EOL]         sin[i] = FastMath.sin(FastMath.PI * i / n); [EOL]     } [EOL]     for (int j = 0; j < n; j++) { [EOL]         double yj = 0.0; [EOL]         for (int i = 0; i < n; i++) { [EOL]             yj += x[i] * sin[(i * j) % sin.length]; [EOL]         } [EOL]         y[j] = yj; [EOL]     } [EOL]     final double s; [EOL]     if (type == TransformType.FORWARD) { [EOL]         if (normalization == DstNormalization.STANDARD_DST_I) { [EOL]             s = 1.0; [EOL]         } else if (normalization == DstNormalization.ORTHOGONAL_DST_I) { [EOL]             s = FastMath.sqrt(2.0 / n); [EOL]         } else { [EOL]             throw new MathIllegalStateException(); [EOL]         } [EOL]     } else if (type == TransformType.INVERSE) { [EOL]         if (normalization == DstNormalization.STANDARD_DST_I) { [EOL]             s = 2.0 / n; [EOL]         } else if (normalization == DstNormalization.ORTHOGONAL_DST_I) { [EOL]             s = FastMath.sqrt(2.0 / n); [EOL]         } else { [EOL]             throw new MathIllegalStateException(); [EOL]         } [EOL]     } else { [EOL]         throw new MathIllegalStateException(); [EOL]     } [EOL]     TransformUtils.scaleArray(y, s); [EOL]     return y; [EOL] } <line_num>: 140,181
@Test [EOL] public void testTransformRealFirstElementNotZero() { [EOL]     final TransformType[] type = TransformType.values(); [EOL]     final double[] data = new double[] { 1.0, 1.0, 1.0, 1.0 }; [EOL]     final RealTransformer transformer = createRealTransformer(); [EOL]     for (int j = 0; j < type.length; j++) { [EOL]         try { [EOL]             transformer.transform(data, type[j]); [EOL]             Assert.fail(type[j].toString()); [EOL]         } catch (MathIllegalArgumentException e) { [EOL]         } [EOL]     } [EOL] } <line_num>: 186,201
@Test [EOL] public void testAdHocData() { [EOL]     FastSineTransformer transformer; [EOL]     transformer = new FastSineTransformer(DstNormalization.STANDARD_DST_I); [EOL]     double result[], tolerance = 1E-12; [EOL]     double[] x = { 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0 }; [EOL]     double[] y = { 0.0, 20.1093579685034, -9.65685424949238, 5.98642305066196, -4.0, 2.67271455167720, -1.65685424949238, 0.795649469518633 }; [EOL]     result = transformer.transform(x, TransformType.FORWARD); [EOL]     for (int i = 0; i < result.length; i++) { [EOL]         Assert.assertEquals(y[i], result[i], tolerance); [EOL]     } [EOL]     result = transformer.transform(y, TransformType.INVERSE); [EOL]     for (int i = 0; i < result.length; i++) { [EOL]         Assert.assertEquals(x[i], result[i], tolerance); [EOL]     } [EOL]     TransformUtils.scaleArray(x, FastMath.sqrt(x.length / 2.0)); [EOL]     transformer = new FastSineTransformer(DstNormalization.ORTHOGONAL_DST_I); [EOL]     result = transformer.transform(y, TransformType.FORWARD); [EOL]     for (int i = 0; i < result.length; i++) { [EOL]         Assert.assertEquals(x[i], result[i], tolerance); [EOL]     } [EOL]     result = transformer.transform(x, TransformType.INVERSE); [EOL]     for (int i = 0; i < result.length; i++) { [EOL]         Assert.assertEquals(y[i], result[i], tolerance); [EOL]     } [EOL] } <line_num>: 210,243
@Test [EOL] public void testSinFunction() { [EOL]     UnivariateFunction f = new Sin(); [EOL]     FastSineTransformer transformer; [EOL]     transformer = new FastSineTransformer(DstNormalization.STANDARD_DST_I); [EOL]     double min, max, result[], tolerance = 1E-12; [EOL]     int N = 1 << 8; [EOL]     min = 0.0; [EOL]     max = 2.0 * FastMath.PI; [EOL]     result = transformer.transform(f, min, max, N, TransformType.FORWARD); [EOL]     Assert.assertEquals(N >> 1, result[2], tolerance); [EOL]     for (int i = 0; i < N; i += (i == 1 ? 2 : 1)) { [EOL]         Assert.assertEquals(0.0, result[i], tolerance); [EOL]     } [EOL]     min = -FastMath.PI; [EOL]     max = FastMath.PI; [EOL]     result = transformer.transform(f, min, max, N, TransformType.FORWARD); [EOL]     Assert.assertEquals(-(N >> 1), result[2], tolerance); [EOL]     for (int i = 0; i < N; i += (i == 1 ? 2 : 1)) { [EOL]         Assert.assertEquals(0.0, result[i], tolerance); [EOL]     } [EOL] } <line_num>: 248,268
@Test [EOL] public void testParameters() throws Exception { [EOL]     UnivariateFunction f = new Sin(); [EOL]     FastSineTransformer transformer; [EOL]     transformer = new FastSineTransformer(DstNormalization.STANDARD_DST_I); [EOL]     try { [EOL]         transformer.transform(f, 1, -1, 64, TransformType.FORWARD); [EOL]         Assert.fail("Expecting IllegalArgumentException - bad interval"); [EOL]     } catch (IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         transformer.transform(f, -1, 1, 0, TransformType.FORWARD); [EOL]         Assert.fail("Expecting IllegalArgumentException - bad samples number"); [EOL]     } catch (IllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         transformer.transform(f, -1, 1, 100, TransformType.FORWARD); [EOL]         Assert.fail("Expecting IllegalArgumentException - bad samples number"); [EOL]     } catch (IllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 273,300
