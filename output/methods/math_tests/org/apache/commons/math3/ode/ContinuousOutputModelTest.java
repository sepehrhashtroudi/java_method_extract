public ContinuousOutputModelTest() { [EOL]     pb = null; [EOL]     integ = null; [EOL] } <line_num>: 39,42
@Test [EOL] public void testBoundaries() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     integ.addStepHandler(new ContinuousOutputModel()); [EOL]     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]     ContinuousOutputModel cm = (ContinuousOutputModel) integ.getStepHandlers().iterator().next(); [EOL]     cm.setInterpolatedTime(2.0 * pb.getInitialTime() - pb.getFinalTime()); [EOL]     cm.setInterpolatedTime(2.0 * pb.getFinalTime() - pb.getInitialTime()); [EOL]     cm.setInterpolatedTime(0.5 * (pb.getFinalTime() + pb.getInitialTime())); [EOL] } <line_num>: 44,54
@Test [EOL] public void testRandomAccess() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     ContinuousOutputModel cm = new ContinuousOutputModel(); [EOL]     integ.addStepHandler(cm); [EOL]     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]     Random random = new Random(347588535632l); [EOL]     double maxError = 0.0; [EOL]     for (int i = 0; i < 1000; ++i) { [EOL]         double r = random.nextDouble(); [EOL]         double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime(); [EOL]         cm.setInterpolatedTime(time); [EOL]         double[] interpolatedY = cm.getInterpolatedState(); [EOL]         double[] theoreticalY = pb.computeTheoreticalState(time); [EOL]         double dx = interpolatedY[0] - theoreticalY[0]; [EOL]         double dy = interpolatedY[1] - theoreticalY[1]; [EOL]         double error = dx * dx + dy * dy; [EOL]         if (error > maxError) { [EOL]             maxError = error; [EOL]         } [EOL]     } [EOL]     Assert.assertTrue(maxError < 1.0e-9); [EOL] } <line_num>: 56,83
public void computeDerivatives(double t, double[] y, double[] dot) { [EOL]     dot[0] = -y[1]; [EOL]     dot[1] = y[0]; [EOL] } <line_num>: 91,94
public int getDimension() { [EOL]     return 2; [EOL] } <line_num>: 95,97
@Test [EOL] public void testModelsMerging() throws MaxCountExceededException, MathIllegalArgumentException { [EOL]     FirstOrderDifferentialEquations problem = new FirstOrderDifferentialEquations() { [EOL]  [EOL]         public void computeDerivatives(double t, double[] y, double[] dot) { [EOL]             dot[0] = -y[1]; [EOL]             dot[1] = y[0]; [EOL]         } [EOL]  [EOL]         public int getDimension() { [EOL]             return 2; [EOL]         } [EOL]     }; [EOL]     ContinuousOutputModel cm1 = new ContinuousOutputModel(); [EOL]     FirstOrderIntegrator integ1 = new DormandPrince853Integrator(0, 1.0, 1.0e-8, 1.0e-8); [EOL]     integ1.addStepHandler(cm1); [EOL]     integ1.integrate(problem, FastMath.PI, new double[] { -1.0, 0.0 }, 0, new double[2]); [EOL]     ContinuousOutputModel cm2 = new ContinuousOutputModel(); [EOL]     FirstOrderIntegrator integ2 = new DormandPrince853Integrator(0, 0.1, 1.0e-12, 1.0e-12); [EOL]     integ2.addStepHandler(cm2); [EOL]     integ2.integrate(problem, 2.0 * FastMath.PI, new double[] { 1.0, 0.0 }, FastMath.PI, new double[2]); [EOL]     ContinuousOutputModel cm = new ContinuousOutputModel(); [EOL]     cm.append(cm2); [EOL]     cm.append(new ContinuousOutputModel()); [EOL]     cm.append(cm1); [EOL]     Assert.assertEquals(2.0 * FastMath.PI, cm.getInitialTime(), 1.0e-12); [EOL]     Assert.assertEquals(0, cm.getFinalTime(), 1.0e-12); [EOL]     Assert.assertEquals(cm.getFinalTime(), cm.getInterpolatedTime(), 1.0e-12); [EOL]     for (double t = 0; t < 2.0 * FastMath.PI; t += 0.1) { [EOL]         cm.setInterpolatedTime(t); [EOL]         double[] y = cm.getInterpolatedState(); [EOL]         Assert.assertEquals(FastMath.cos(t), y[0], 1.0e-7); [EOL]         Assert.assertEquals(FastMath.sin(t), y[1], 1.0e-7); [EOL]     } [EOL] } <line_num>: 85,133
@Test [EOL] public void testErrorConditions() throws MaxCountExceededException, MathIllegalArgumentException { [EOL]     ContinuousOutputModel cm = new ContinuousOutputModel(); [EOL]     cm.handleStep(buildInterpolator(0, new double[] { 0.0, 1.0, -2.0 }, 1), true); [EOL]     Assert.assertTrue(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0 }, 2.0)); [EOL]     Assert.assertTrue(checkAppendError(cm, 10.0, new double[] { 0.0, 1.0, -2.0 }, 20.0)); [EOL]     Assert.assertTrue(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0, -2.0 }, 0.0)); [EOL]     Assert.assertFalse(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0, -2.0 }, 2.0)); [EOL] } <line_num>: 135,153
private boolean checkAppendError(ContinuousOutputModel cm, double t0, double[] y0, double t1) throws MaxCountExceededException, MathIllegalArgumentException { [EOL]     try { [EOL]         ContinuousOutputModel otherCm = new ContinuousOutputModel(); [EOL]         otherCm.handleStep(buildInterpolator(t0, y0, t1), true); [EOL]         cm.append(otherCm); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 155,166
private StepInterpolator buildInterpolator(double t0, double[] y0, double t1) { [EOL]     DummyStepInterpolator interpolator = new DummyStepInterpolator(y0, new double[y0.length], t1 >= t0); [EOL]     interpolator.storeTime(t0); [EOL]     interpolator.shift(); [EOL]     interpolator.storeTime(t1); [EOL]     return interpolator; [EOL] } <line_num>: 168,174
public void checkValue(double value, double reference) { [EOL]     Assert.assertTrue(FastMath.abs(value - reference) < 1.0e-10); [EOL] } <line_num>: 176,178
@Before [EOL] public void setUp() { [EOL]     pb = new TestProblem3(0.9); [EOL]     double minStep = 0; [EOL]     double maxStep = pb.getFinalTime() - pb.getInitialTime(); [EOL]     integ = new DormandPrince54Integrator(minStep, maxStep, 1.0e-8, 1.0e-8); [EOL] } <line_num>: 180,186
@After [EOL] public void tearDown() { [EOL]     pb = null; [EOL]     integ = null; [EOL] } <line_num>: 188,192
