public TestProblemHandler(TestProblemAbstract problem, ODEIntegrator integrator) { [EOL]     this.problem = problem; [EOL]     this.integrator = integrator; [EOL]     maxValueError = 0; [EOL]     maxTimeError = 0; [EOL]     lastError = 0; [EOL]     expectedStepStart = Double.NaN; [EOL] } <line_num>: 56,63
public void init(double t0, double[] y0, double t) { [EOL]     maxValueError = 0; [EOL]     maxTimeError = 0; [EOL]     lastError = 0; [EOL]     expectedStepStart = Double.NaN; [EOL] } <line_num>: 65,70
public void handleStep(StepInterpolator interpolator, boolean isLast) throws MaxCountExceededException { [EOL]     double start = integrator.getCurrentStepStart(); [EOL]     if (FastMath.abs((start - problem.getInitialTime()) / integrator.getCurrentSignedStepsize()) > 0.001) { [EOL]         if (!Double.isNaN(expectedStepStart)) { [EOL]             double stepError = FastMath.max(maxTimeError, FastMath.abs(start - expectedStepStart)); [EOL]             for (double eventTime : problem.getTheoreticalEventsTimes()) { [EOL]                 stepError = FastMath.min(stepError, FastMath.abs(start - eventTime)); [EOL]             } [EOL]             maxTimeError = FastMath.max(maxTimeError, stepError); [EOL]         } [EOL]         expectedStepStart = start + integrator.getCurrentSignedStepsize(); [EOL]     } [EOL]     double pT = interpolator.getPreviousTime(); [EOL]     double cT = interpolator.getCurrentTime(); [EOL]     double[] errorScale = problem.getErrorScale(); [EOL]     if (isLast) { [EOL]         double[] interpolatedY = interpolator.getInterpolatedState(); [EOL]         double[] theoreticalY = problem.computeTheoreticalState(cT); [EOL]         for (int i = 0; i < interpolatedY.length; ++i) { [EOL]             double error = FastMath.abs(interpolatedY[i] - theoreticalY[i]); [EOL]             lastError = FastMath.max(error, lastError); [EOL]         } [EOL]         lastTime = cT; [EOL]     } [EOL]     for (int k = 0; k <= 20; ++k) { [EOL]         double time = pT + (k * (cT - pT)) / 20; [EOL]         interpolator.setInterpolatedTime(time); [EOL]         double[] interpolatedY = interpolator.getInterpolatedState(); [EOL]         double[] theoreticalY = problem.computeTheoreticalState(interpolator.getInterpolatedTime()); [EOL]         for (int i = 0; i < interpolatedY.length; ++i) { [EOL]             double error = errorScale[i] * FastMath.abs(interpolatedY[i] - theoreticalY[i]); [EOL]             maxValueError = FastMath.max(error, maxValueError); [EOL]         } [EOL]     } [EOL] } <line_num>: 72,119
public double getMaximalValueError() { [EOL]     return maxValueError; [EOL] } <line_num>: 125,127
public double getMaximalTimeError() { [EOL]     return maxTimeError; [EOL] } <line_num>: 133,135
public double getLastError() { [EOL]     return lastError; [EOL] } <line_num>: 141,143
public double getLastTime() { [EOL]     return lastTime; [EOL] } <line_num>: 149,151
