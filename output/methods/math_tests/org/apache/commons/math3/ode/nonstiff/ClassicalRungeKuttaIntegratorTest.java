public KeplerHandler(TestProblem3 pb) { [EOL]     this.pb = pb; [EOL]     maxError = 0; [EOL] } <line_num>: 257,260
public int getDimension() { [EOL]     return k.length; [EOL] } <line_num>: 51,53
public void computeDerivatives(double t, double[] y, double[] yDot) { [EOL]     for (int i = 0; i < y.length; ++i) { [EOL]         yDot[i] = k[i] * y[i]; [EOL]     } [EOL] } <line_num>: 55,59
public void init(double t0, double[] y0, double t) { [EOL] } <line_num>: 78,79
public void resetState(double t, double[] y) { [EOL] } <line_num>: 81,82
public double g(double t, double[] y) { [EOL]     return t - tEvent; [EOL] } <line_num>: 84,86
public Action eventOccurred(double t, double[] y, boolean increasing) { [EOL]     Assert.assertEquals(tEvent, t, 5.0e-6); [EOL]     return Action.CONTINUE; [EOL] } <line_num>: 88,91
@Test [EOL] public void testMissedEndEvent() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     final double t0 = 1878250320.0000029; [EOL]     final double tEvent = 1878250379.9999986; [EOL]     final double[] k = { 1.0e-4, 1.0e-5, 1.0e-6 }; [EOL]     FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() { [EOL]  [EOL]         public int getDimension() { [EOL]             return k.length; [EOL]         } [EOL]  [EOL]         public void computeDerivatives(double t, double[] y, double[] yDot) { [EOL]             for (int i = 0; i < y.length; ++i) { [EOL]                 yDot[i] = k[i] * y[i]; [EOL]             } [EOL]         } [EOL]     }; [EOL]     ClassicalRungeKuttaIntegrator integrator = new ClassicalRungeKuttaIntegrator(60.0); [EOL]     double[] y0 = new double[k.length]; [EOL]     for (int i = 0; i < y0.length; ++i) { [EOL]         y0[i] = i + 1; [EOL]     } [EOL]     double[] y = new double[k.length]; [EOL]     double finalT = integrator.integrate(ode, t0, y0, tEvent, y); [EOL]     Assert.assertEquals(tEvent, finalT, 5.0e-6); [EOL]     for (int i = 0; i < y.length; ++i) { [EOL]         Assert.assertEquals(y0[i] * FastMath.exp(k[i] * (finalT - t0)), y[i], 1.0e-9); [EOL]     } [EOL]     integrator.addEventHandler(new EventHandler() { [EOL]  [EOL]         public void init(double t0, double[] y0, double t) { [EOL]         } [EOL]  [EOL]         public void resetState(double t, double[] y) { [EOL]         } [EOL]  [EOL]         public double g(double t, double[] y) { [EOL]             return t - tEvent; [EOL]         } [EOL]  [EOL]         public Action eventOccurred(double t, double[] y, boolean increasing) { [EOL]             Assert.assertEquals(tEvent, t, 5.0e-6); [EOL]             return Action.CONTINUE; [EOL]         } [EOL]     }, Double.POSITIVE_INFINITY, 1.0e-20, 100); [EOL]     finalT = integrator.integrate(ode, t0, y0, tEvent + 120, y); [EOL]     Assert.assertEquals(tEvent + 120, finalT, 5.0e-6); [EOL]     for (int i = 0; i < y.length; ++i) { [EOL]         Assert.assertEquals(y0[i] * FastMath.exp(k[i] * (finalT - t0)), y[i], 1.0e-9); [EOL]     } [EOL] } <line_num>: 42,99
@Test [EOL] public void testSanityChecks() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     try { [EOL]         TestProblem1 pb = new TestProblem1(); [EOL]         new ClassicalRungeKuttaIntegrator(0.01).integrate(pb, 0.0, new double[pb.getDimension() + 10], 1.0, new double[pb.getDimension()]); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (DimensionMismatchException ie) { [EOL]     } [EOL]     try { [EOL]         TestProblem1 pb = new TestProblem1(); [EOL]         new ClassicalRungeKuttaIntegrator(0.01).integrate(pb, 0.0, new double[pb.getDimension()], 1.0, new double[pb.getDimension() + 10]); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (DimensionMismatchException ie) { [EOL]     } [EOL]     try { [EOL]         TestProblem1 pb = new TestProblem1(); [EOL]         new ClassicalRungeKuttaIntegrator(0.01).integrate(pb, 0.0, new double[pb.getDimension()], 0.0, new double[pb.getDimension()]); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (NumberIsTooSmallException ie) { [EOL]     } [EOL] } <line_num>: 101,129
@Test [EOL] public void testDecreasingSteps() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblemAbstract[] problems = TestProblemFactory.getProblems(); [EOL]     for (int k = 0; k < problems.length; ++k) { [EOL]         double previousValueError = Double.NaN; [EOL]         double previousTimeError = Double.NaN; [EOL]         for (int i = 4; i < 10; ++i) { [EOL]             TestProblemAbstract pb = problems[k].copy(); [EOL]             double step = (pb.getFinalTime() - pb.getInitialTime()) * FastMath.pow(2.0, -i); [EOL]             FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step); [EOL]             TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]             integ.addStepHandler(handler); [EOL]             EventHandler[] functions = pb.getEventsHandlers(); [EOL]             for (int l = 0; l < functions.length; ++l) { [EOL]                 integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000); [EOL]             } [EOL]             Assert.assertEquals(functions.length, integ.getEventHandlers().size()); [EOL]             double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]             if (functions.length == 0) { [EOL]                 Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10); [EOL]             } [EOL]             double error = handler.getMaximalValueError(); [EOL]             if (i > 4) { [EOL]                 Assert.assertTrue(error < 1.01 * FastMath.abs(previousValueError)); [EOL]             } [EOL]             previousValueError = error; [EOL]             double timeError = handler.getMaximalTimeError(); [EOL]             if (i > 4) { [EOL]                 Assert.assertTrue(timeError <= FastMath.abs(previousTimeError)); [EOL]             } [EOL]             previousTimeError = timeError; [EOL]             integ.clearEventHandlers(); [EOL]             Assert.assertEquals(0, integ.getEventHandlers().size()); [EOL]         } [EOL]     } [EOL] } <line_num>: 131,179
@Test [EOL] public void testSmallStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblem1 pb = new TestProblem1(); [EOL]     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001; [EOL]     FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step); [EOL]     TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]     integ.addStepHandler(handler); [EOL]     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]     Assert.assertTrue(handler.getLastError() < 2.0e-13); [EOL]     Assert.assertTrue(handler.getMaximalValueError() < 4.0e-12); [EOL]     Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); [EOL]     Assert.assertEquals("classical Runge-Kutta", integ.getName()); [EOL] } <line_num>: 181,199
@Test [EOL] public void testBigStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblem1 pb = new TestProblem1(); [EOL]     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2; [EOL]     FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step); [EOL]     TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]     integ.addStepHandler(handler); [EOL]     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]     Assert.assertTrue(handler.getLastError() > 0.0004); [EOL]     Assert.assertTrue(handler.getMaximalValueError() > 0.005); [EOL]     Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); [EOL] } <line_num>: 201,219
@Test [EOL] public void testBackward() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblem5 pb = new TestProblem5(); [EOL]     double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001; [EOL]     FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step); [EOL]     TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]     integ.addStepHandler(handler); [EOL]     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]     Assert.assertTrue(handler.getLastError() < 5.0e-10); [EOL]     Assert.assertTrue(handler.getMaximalValueError() < 7.0e-10); [EOL]     Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); [EOL]     Assert.assertEquals("classical Runge-Kutta", integ.getName()); [EOL] } <line_num>: 221,239
@Test [EOL] public void testKepler() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     final TestProblem3 pb = new TestProblem3(0.9); [EOL]     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003; [EOL]     FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step); [EOL]     integ.addStepHandler(new KeplerHandler(pb)); [EOL]     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL] } <line_num>: 241,254
public void init(double t0, double[] y0, double t) { [EOL]     maxError = 0; [EOL] } <line_num>: 261,263
public void handleStep(StepInterpolator interpolator, boolean isLast) throws MaxCountExceededException { [EOL]     double[] interpolatedY = interpolator.getInterpolatedState(); [EOL]     double[] theoreticalY = pb.computeTheoreticalState(interpolator.getCurrentTime()); [EOL]     double dx = interpolatedY[0] - theoreticalY[0]; [EOL]     double dy = interpolatedY[1] - theoreticalY[1]; [EOL]     double error = dx * dx + dy * dy; [EOL]     if (error > maxError) { [EOL]         maxError = error; [EOL]     } [EOL]     if (isLast) { [EOL]         Assert.assertTrue(maxError > 0.005); [EOL]     } [EOL] } <line_num>: 264,281
public void handleStep(StepInterpolator interpolator, boolean isLast) { [EOL]     if (!isLast) { [EOL]         Assert.assertEquals(step, interpolator.getCurrentTime() - interpolator.getPreviousTime(), 1.0e-12); [EOL]     } [EOL] } <line_num>: 293,299
public void init(double t0, double[] y0, double t) { [EOL] } <line_num>: 300,301
public void computeDerivatives(double t, double[] y, double[] dot) { [EOL]     dot[0] = 1.0; [EOL] } <line_num>: 304,306
public int getDimension() { [EOL]     return 1; [EOL] } <line_num>: 307,309
@Test [EOL] public void testStepSize() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     final double step = 1.23456; [EOL]     FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step); [EOL]     integ.addStepHandler(new StepHandler() { [EOL]  [EOL]         public void handleStep(StepInterpolator interpolator, boolean isLast) { [EOL]             if (!isLast) { [EOL]                 Assert.assertEquals(step, interpolator.getCurrentTime() - interpolator.getPreviousTime(), 1.0e-12); [EOL]             } [EOL]         } [EOL]  [EOL]         public void init(double t0, double[] y0, double t) { [EOL]         } [EOL]     }); [EOL]     integ.integrate(new FirstOrderDifferentialEquations() { [EOL]  [EOL]         public void computeDerivatives(double t, double[] y, double[] dot) { [EOL]             dot[0] = 1.0; [EOL]         } [EOL]  [EOL]         public int getDimension() { [EOL]             return 1; [EOL]         } [EOL]     }, 0.0, new double[] { 0.0 }, 5.0, new double[1]); [EOL] } <line_num>: 286,311
