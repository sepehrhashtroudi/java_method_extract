@Test(expected = DimensionMismatchException.class) [EOL] public void dimensionCheck() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblem1 pb = new TestProblem1(); [EOL]     FirstOrderIntegrator integ = new AdamsMoultonIntegrator(2, 0.0, 1.0, 1.0e-10, 1.0e-10); [EOL]     integ.integrate(pb, 0.0, new double[pb.getDimension() + 10], 1.0, new double[pb.getDimension() + 10]); [EOL] } <line_num>: 36,46
@Test(expected = NumberIsTooSmallException.class) [EOL] public void testMinStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblem1 pb = new TestProblem1(); [EOL]     double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime()); [EOL]     double maxStep = pb.getFinalTime() - pb.getInitialTime(); [EOL]     double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 }; [EOL]     double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 }; [EOL]     FirstOrderIntegrator integ = new AdamsMoultonIntegrator(4, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance); [EOL]     TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]     integ.addStepHandler(handler); [EOL]     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL] } <line_num>: 48,68
@Test [EOL] public void testIncreasingTolerance() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     int previousCalls = Integer.MAX_VALUE; [EOL]     for (int i = -12; i < -2; ++i) { [EOL]         TestProblem1 pb = new TestProblem1(); [EOL]         double minStep = 0; [EOL]         double maxStep = pb.getFinalTime() - pb.getInitialTime(); [EOL]         double scalAbsoluteTolerance = FastMath.pow(10.0, i); [EOL]         double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; [EOL]         FirstOrderIntegrator integ = new AdamsMoultonIntegrator(4, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); [EOL]         TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]         integ.addStepHandler(handler); [EOL]         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]         Assert.assertTrue(handler.getMaximalValueError() > (0.5 * scalAbsoluteTolerance)); [EOL]         Assert.assertTrue(handler.getMaximalValueError() < (11.0 * scalAbsoluteTolerance)); [EOL]         Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-16); [EOL]         int calls = pb.getCalls(); [EOL]         Assert.assertEquals(integ.getEvaluations(), calls); [EOL]         Assert.assertTrue(calls <= previousCalls); [EOL]         previousCalls = calls; [EOL]     } [EOL] } <line_num>: 70,106
@Test(expected = MaxCountExceededException.class) [EOL] public void exceedMaxEvaluations() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblem1 pb = new TestProblem1(); [EOL]     double range = pb.getFinalTime() - pb.getInitialTime(); [EOL]     AdamsMoultonIntegrator integ = new AdamsMoultonIntegrator(2, 0, range, 1.0e-12, 1.0e-12); [EOL]     TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]     integ.addStepHandler(handler); [EOL]     integ.setMaxEvaluations(650); [EOL]     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL] } <line_num>: 108,124
@Test [EOL] public void backward() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblem5 pb = new TestProblem5(); [EOL]     double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()); [EOL]     FirstOrderIntegrator integ = new AdamsMoultonIntegrator(4, 0, range, 1.0e-12, 1.0e-12); [EOL]     TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]     integ.addStepHandler(handler); [EOL]     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]     Assert.assertTrue(handler.getLastError() < 1.0e-9); [EOL]     Assert.assertTrue(handler.getMaximalValueError() < 1.0e-9); [EOL]     Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-16); [EOL]     Assert.assertEquals("Adams-Moulton", integ.getName()); [EOL] } <line_num>: 126,144
@Test [EOL] public void polynomial() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblem6 pb = new TestProblem6(); [EOL]     double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()); [EOL]     for (int nSteps = 2; nSteps < 8; ++nSteps) { [EOL]         AdamsMoultonIntegrator integ = new AdamsMoultonIntegrator(nSteps, 1.0e-6 * range, 0.1 * range, 1.0e-5, 1.0e-5); [EOL]         TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]         integ.addStepHandler(handler); [EOL]         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]         if (nSteps < 4) { [EOL]             Assert.assertTrue(handler.getMaximalValueError() > 7.0e-04); [EOL]         } else { [EOL]             Assert.assertTrue(handler.getMaximalValueError() < 3.0e-13); [EOL]         } [EOL]     } [EOL] } <line_num>: 146,167
