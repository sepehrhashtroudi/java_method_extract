public void computeDerivatives(double t, double[] y, double[] dot) { [EOL]     if (t < -0.5) { [EOL]         throw new LocalException(); [EOL]     } else { [EOL]         throw new RuntimeException("oops"); [EOL]     } [EOL] } <line_num>: 48,54
public int getDimension() { [EOL]     return 1; [EOL] } <line_num>: 55,57
@Test [EOL] public void testWrongDerivative() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     HighamHall54Integrator integrator = new HighamHall54Integrator(0.0, 1.0, 1.0e-10, 1.0e-10); [EOL]     FirstOrderDifferentialEquations equations = new FirstOrderDifferentialEquations() { [EOL]  [EOL]         public void computeDerivatives(double t, double[] y, double[] dot) { [EOL]             if (t < -0.5) { [EOL]                 throw new LocalException(); [EOL]             } else { [EOL]                 throw new RuntimeException("oops"); [EOL]             } [EOL]         } [EOL]  [EOL]         public int getDimension() { [EOL]             return 1; [EOL]         } [EOL]     }; [EOL]     try { [EOL]         integrator.integrate(equations, -1.0, new double[1], 0.0, new double[1]); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (LocalException de) { [EOL]     } [EOL]     try { [EOL]         integrator.integrate(equations, 0.0, new double[1], 1.0, new double[1]); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (RuntimeException de) { [EOL]     } [EOL] } <line_num>: 40,74
@Test(expected = NumberIsTooSmallException.class) [EOL] public void testMinStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblem1 pb = new TestProblem1(); [EOL]     double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime()); [EOL]     double maxStep = pb.getFinalTime() - pb.getInitialTime(); [EOL]     double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 }; [EOL]     double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 }; [EOL]     FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance); [EOL]     TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]     integ.addStepHandler(handler); [EOL]     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]     Assert.fail("an exception should have been thrown"); [EOL] } <line_num>: 76,97
@Test [EOL] public void testIncreasingTolerance() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     int previousCalls = Integer.MAX_VALUE; [EOL]     for (int i = -12; i < -2; ++i) { [EOL]         TestProblem1 pb = new TestProblem1(); [EOL]         double minStep = 0; [EOL]         double maxStep = pb.getFinalTime() - pb.getInitialTime(); [EOL]         double scalAbsoluteTolerance = FastMath.pow(10.0, i); [EOL]         double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; [EOL]         FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); [EOL]         TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]         integ.addStepHandler(handler); [EOL]         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]         Assert.assertTrue(handler.getMaximalValueError() < (1.3 * scalAbsoluteTolerance)); [EOL]         Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); [EOL]         int calls = pb.getCalls(); [EOL]         Assert.assertEquals(integ.getEvaluations(), calls); [EOL]         Assert.assertTrue(calls <= previousCalls); [EOL]         previousCalls = calls; [EOL]     } [EOL] } <line_num>: 99,134
@Test [EOL] public void testBackward() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblem5 pb = new TestProblem5(); [EOL]     double minStep = 0; [EOL]     double maxStep = pb.getFinalTime() - pb.getInitialTime(); [EOL]     double scalAbsoluteTolerance = 1.0e-8; [EOL]     double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; [EOL]     FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); [EOL]     TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]     integ.addStepHandler(handler); [EOL]     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]     Assert.assertTrue(handler.getLastError() < 5.0e-7); [EOL]     Assert.assertTrue(handler.getMaximalValueError() < 5.0e-7); [EOL]     Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); [EOL]     Assert.assertEquals("Higham-Hall 5(4)", integ.getName()); [EOL] } <line_num>: 136,159
@Test [EOL] public void testEvents() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblem4 pb = new TestProblem4(); [EOL]     double minStep = 0; [EOL]     double maxStep = pb.getFinalTime() - pb.getInitialTime(); [EOL]     double scalAbsoluteTolerance = 1.0e-8; [EOL]     double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; [EOL]     FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); [EOL]     TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]     integ.addStepHandler(handler); [EOL]     EventHandler[] functions = pb.getEventsHandlers(); [EOL]     double convergence = 1.0e-8 * maxStep; [EOL]     for (int l = 0; l < functions.length; ++l) { [EOL]         integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, convergence, 1000); [EOL]     } [EOL]     Assert.assertEquals(functions.length, integ.getEventHandlers().size()); [EOL]     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]     Assert.assertTrue(handler.getMaximalValueError() < 1.0e-7); [EOL]     Assert.assertEquals(0, handler.getMaximalTimeError(), convergence); [EOL]     Assert.assertEquals(12.0, handler.getLastTime(), convergence); [EOL]     integ.clearEventHandlers(); [EOL]     Assert.assertEquals(0, integ.getEventHandlers().size()); [EOL] } <line_num>: 161,194
public void init(double t0, double[] y0, double t) { [EOL] } <line_num>: 214,215
public Action eventOccurred(double t, double[] y, boolean increasing) { [EOL]     return Action.CONTINUE; [EOL] } <line_num>: 216,218
public double g(double t, double[] y) { [EOL]     double middle = (pb.getInitialTime() + pb.getFinalTime()) / 2; [EOL]     double offset = t - middle; [EOL]     if (offset > 0) { [EOL]         throw new LocalException(); [EOL]     } [EOL]     return offset; [EOL] } <line_num>: 219,226
public void resetState(double t, double[] y) { [EOL] } <line_num>: 227,228
@Test(expected = LocalException.class) [EOL] public void testEventsErrors() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     final TestProblem1 pb = new TestProblem1(); [EOL]     double minStep = 0; [EOL]     double maxStep = pb.getFinalTime() - pb.getInitialTime(); [EOL]     double scalAbsoluteTolerance = 1.0e-8; [EOL]     double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; [EOL]     FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); [EOL]     TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]     integ.addStepHandler(handler); [EOL]     integ.addEventHandler(new EventHandler() { [EOL]  [EOL]         public void init(double t0, double[] y0, double t) { [EOL]         } [EOL]  [EOL]         public Action eventOccurred(double t, double[] y, boolean increasing) { [EOL]             return Action.CONTINUE; [EOL]         } [EOL]  [EOL]         public double g(double t, double[] y) { [EOL]             double middle = (pb.getInitialTime() + pb.getFinalTime()) / 2; [EOL]             double offset = t - middle; [EOL]             if (offset > 0) { [EOL]                 throw new LocalException(); [EOL]             } [EOL]             return offset; [EOL]         } [EOL]  [EOL]         public void resetState(double t, double[] y) { [EOL]         } [EOL]     }, Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000); [EOL]     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL] } <line_num>: 196,235
public void init(double t0, double[] y0, double t) { [EOL] } <line_num>: 259,260
public Action eventOccurred(double t, double[] y, boolean increasing) { [EOL]     return Action.CONTINUE; [EOL] } <line_num>: 261,263
public double g(double t, double[] y) { [EOL]     double middle = (pb.getInitialTime() + pb.getFinalTime()) / 2; [EOL]     double offset = t - middle; [EOL]     return (offset > 0) ? (offset + 0.5) : (offset - 0.5); [EOL] } <line_num>: 264,268
public void resetState(double t, double[] y) { [EOL] } <line_num>: 269,270
@Test [EOL] public void testEventsNoConvergence() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     final TestProblem1 pb = new TestProblem1(); [EOL]     double minStep = 0; [EOL]     double maxStep = pb.getFinalTime() - pb.getInitialTime(); [EOL]     double scalAbsoluteTolerance = 1.0e-8; [EOL]     double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; [EOL]     FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); [EOL]     TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]     integ.addStepHandler(handler); [EOL]     integ.addEventHandler(new EventHandler() { [EOL]  [EOL]         public void init(double t0, double[] y0, double t) { [EOL]         } [EOL]  [EOL]         public Action eventOccurred(double t, double[] y, boolean increasing) { [EOL]             return Action.CONTINUE; [EOL]         } [EOL]  [EOL]         public double g(double t, double[] y) { [EOL]             double middle = (pb.getInitialTime() + pb.getFinalTime()) / 2; [EOL]             double offset = t - middle; [EOL]             return (offset > 0) ? (offset + 0.5) : (offset - 0.5); [EOL]         } [EOL]  [EOL]         public void resetState(double t, double[] y) { [EOL]         } [EOL]     }, Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 3); [EOL]     try { [EOL]         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (TooManyEvaluationsException tmee) { [EOL]     } [EOL] } <line_num>: 241,282
@Test [EOL] public void testSanityChecks() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     final TestProblem3 pb = new TestProblem3(0.9); [EOL]     double minStep = 0; [EOL]     double maxStep = pb.getFinalTime() - pb.getInitialTime(); [EOL]     try { [EOL]         FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]); [EOL]         integ.integrate(pb, pb.getInitialTime(), new double[6], pb.getFinalTime(), new double[pb.getDimension()]); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (DimensionMismatchException ie) { [EOL]     } [EOL]     try { [EOL]         FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]); [EOL]         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[6]); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (DimensionMismatchException ie) { [EOL]     } [EOL]     try { [EOL]         FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, new double[2], new double[4]); [EOL]         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (DimensionMismatchException ie) { [EOL]     } [EOL]     try { [EOL]         FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, new double[4], new double[2]); [EOL]         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (DimensionMismatchException ie) { [EOL]     } [EOL]     try { [EOL]         FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]); [EOL]         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getInitialTime(), new double[pb.getDimension()]); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (NumberIsTooSmallException ie) { [EOL]     } [EOL] } <line_num>: 284,342
@Test [EOL] public void testKepler() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     final TestProblem3 pb = new TestProblem3(0.9); [EOL]     double minStep = 0; [EOL]     double maxStep = pb.getFinalTime() - pb.getInitialTime(); [EOL]     double[] vecAbsoluteTolerance = { 1.0e-8, 1.0e-8, 1.0e-10, 1.0e-10 }; [EOL]     double[] vecRelativeTolerance = { 1.0e-10, 1.0e-10, 1.0e-8, 1.0e-8 }; [EOL]     FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance); [EOL]     TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]     integ.addStepHandler(handler); [EOL]     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]     Assert.assertEquals(0.0, handler.getMaximalValueError(), 1.5e-4); [EOL]     Assert.assertEquals("Higham-Hall 5(4)", integ.getName()); [EOL] } <line_num>: 344,365
