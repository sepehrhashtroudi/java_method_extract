public SchedulingChecker(int index) { [EOL]     this.index = index; [EOL] } <line_num>: 374,376
public KeplerHandler(TestProblem3 pb) { [EOL]     this.pb = pb; [EOL] } <line_num>: 404,406
public VariableHandler() { [EOL]     firstTime = true; [EOL]     minStep = 0; [EOL]     maxStep = 0; [EOL] } <line_num>: 442,446
public int getDimension() { [EOL]     return k.length; [EOL] } <line_num>: 50,52
public void computeDerivatives(double t, double[] y, double[] yDot) { [EOL]     for (int i = 0; i < y.length; ++i) { [EOL]         yDot[i] = k[i] * y[i]; [EOL]     } [EOL] } <line_num>: 54,58
public void init(double t0, double[] y0, double t) { [EOL] } <line_num>: 80,81
public void resetState(double t, double[] y) { [EOL] } <line_num>: 83,84
public double g(double t, double[] y) { [EOL]     return t - tEvent; [EOL] } <line_num>: 86,88
public Action eventOccurred(double t, double[] y, boolean increasing) { [EOL]     Assert.assertEquals(tEvent, t, 5.0e-6); [EOL]     return Action.CONTINUE; [EOL] } <line_num>: 90,93
@Test [EOL] public void testMissedEndEvent() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     final double t0 = 1878250320.0000029; [EOL]     final double tEvent = 1878250379.9999986; [EOL]     final double[] k = { 1.0e-4, 1.0e-5, 1.0e-6 }; [EOL]     FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() { [EOL]  [EOL]         public int getDimension() { [EOL]             return k.length; [EOL]         } [EOL]  [EOL]         public void computeDerivatives(double t, double[] y, double[] yDot) { [EOL]             for (int i = 0; i < y.length; ++i) { [EOL]                 yDot[i] = k[i] * y[i]; [EOL]             } [EOL]         } [EOL]     }; [EOL]     DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 100.0, 1.0e-10, 1.0e-10); [EOL]     double[] y0 = new double[k.length]; [EOL]     for (int i = 0; i < y0.length; ++i) { [EOL]         y0[i] = i + 1; [EOL]     } [EOL]     double[] y = new double[k.length]; [EOL]     integrator.setInitialStepSize(60.0); [EOL]     double finalT = integrator.integrate(ode, t0, y0, tEvent, y); [EOL]     Assert.assertEquals(tEvent, finalT, 5.0e-6); [EOL]     for (int i = 0; i < y.length; ++i) { [EOL]         Assert.assertEquals(y0[i] * FastMath.exp(k[i] * (finalT - t0)), y[i], 1.0e-9); [EOL]     } [EOL]     integrator.setInitialStepSize(60.0); [EOL]     integrator.addEventHandler(new EventHandler() { [EOL]  [EOL]         public void init(double t0, double[] y0, double t) { [EOL]         } [EOL]  [EOL]         public void resetState(double t, double[] y) { [EOL]         } [EOL]  [EOL]         public double g(double t, double[] y) { [EOL]             return t - tEvent; [EOL]         } [EOL]  [EOL]         public Action eventOccurred(double t, double[] y, boolean increasing) { [EOL]             Assert.assertEquals(tEvent, t, 5.0e-6); [EOL]             return Action.CONTINUE; [EOL]         } [EOL]     }, Double.POSITIVE_INFINITY, 1.0e-20, 100); [EOL]     finalT = integrator.integrate(ode, t0, y0, tEvent + 120, y); [EOL]     Assert.assertEquals(tEvent + 120, finalT, 5.0e-6); [EOL]     for (int i = 0; i < y.length; ++i) { [EOL]         Assert.assertEquals(y0[i] * FastMath.exp(k[i] * (finalT - t0)), y[i], 1.0e-9); [EOL]     } [EOL] } <line_num>: 41,101
@Test(expected = DimensionMismatchException.class) [EOL] public void testDimensionCheck() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblem1 pb = new TestProblem1(); [EOL]     DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 1.0, 1.0e-10, 1.0e-10); [EOL]     integrator.integrate(pb, 0.0, new double[pb.getDimension() + 10], 1.0, new double[pb.getDimension() + 10]); [EOL]     Assert.fail("an exception should have been thrown"); [EOL] } <line_num>: 103,114
@Test(expected = NumberIsTooSmallException.class) [EOL] public void testNullIntervalCheck() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblem1 pb = new TestProblem1(); [EOL]     DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 1.0, 1.0e-10, 1.0e-10); [EOL]     integrator.integrate(pb, 0.0, new double[pb.getDimension()], 0.0, new double[pb.getDimension()]); [EOL]     Assert.fail("an exception should have been thrown"); [EOL] } <line_num>: 116,127
@Test(expected = NumberIsTooSmallException.class) [EOL] public void testMinStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblem1 pb = new TestProblem1(); [EOL]     double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime()); [EOL]     double maxStep = pb.getFinalTime() - pb.getInitialTime(); [EOL]     double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 }; [EOL]     double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 }; [EOL]     FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance); [EOL]     TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]     integ.addStepHandler(handler); [EOL]     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]     Assert.fail("an exception should have been thrown"); [EOL] } <line_num>: 129,150
@Test [EOL] public void testIncreasingTolerance() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     int previousCalls = Integer.MAX_VALUE; [EOL]     AdaptiveStepsizeIntegrator integ = new DormandPrince853Integrator(0, Double.POSITIVE_INFINITY, Double.NaN, Double.NaN); [EOL]     for (int i = -12; i < -2; ++i) { [EOL]         TestProblem1 pb = new TestProblem1(); [EOL]         double minStep = 0; [EOL]         double maxStep = pb.getFinalTime() - pb.getInitialTime(); [EOL]         double scalAbsoluteTolerance = FastMath.pow(10.0, i); [EOL]         double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; [EOL]         integ.setStepSizeControl(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); [EOL]         TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]         integ.addStepHandler(handler); [EOL]         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]         Assert.assertTrue(handler.getMaximalValueError() < (1.3 * scalAbsoluteTolerance)); [EOL]         Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); [EOL]         int calls = pb.getCalls(); [EOL]         Assert.assertEquals(integ.getEvaluations(), calls); [EOL]         Assert.assertTrue(calls <= previousCalls); [EOL]         previousCalls = calls; [EOL]     } [EOL] } <line_num>: 152,188
public int getDimension() { [EOL]     return 1; [EOL] } <line_num>: 201,203
public void computeDerivatives(double t, double[] y, double[] yDot) { [EOL]     Assert.assertTrue(t >= FastMath.nextAfter(start, Double.NEGATIVE_INFINITY)); [EOL]     Assert.assertTrue(t <= FastMath.nextAfter(end, Double.POSITIVE_INFINITY)); [EOL]     yDot[0] = -100.0 * y[0]; [EOL] } <line_num>: 205,209
@Test [EOL] public void testTooLargeFirstStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     AdaptiveStepsizeIntegrator integ = new DormandPrince853Integrator(0, Double.POSITIVE_INFINITY, Double.NaN, Double.NaN); [EOL]     final double start = 0.0; [EOL]     final double end = 0.001; [EOL]     FirstOrderDifferentialEquations equations = new FirstOrderDifferentialEquations() { [EOL]  [EOL]         public int getDimension() { [EOL]             return 1; [EOL]         } [EOL]  [EOL]         public void computeDerivatives(double t, double[] y, double[] yDot) { [EOL]             Assert.assertTrue(t >= FastMath.nextAfter(start, Double.NEGATIVE_INFINITY)); [EOL]             Assert.assertTrue(t <= FastMath.nextAfter(end, Double.POSITIVE_INFINITY)); [EOL]             yDot[0] = -100.0 * y[0]; [EOL]         } [EOL]     }; [EOL]     integ.setStepSizeControl(0, 1.0, 1.0e-6, 1.0e-8); [EOL]     integ.integrate(equations, start, new double[] { 1.0 }, end, new double[1]); [EOL] } <line_num>: 190,216
@Test [EOL] public void testBackward() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblem5 pb = new TestProblem5(); [EOL]     double minStep = 0; [EOL]     double maxStep = pb.getFinalTime() - pb.getInitialTime(); [EOL]     double scalAbsoluteTolerance = 1.0e-8; [EOL]     double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; [EOL]     FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); [EOL]     TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]     integ.addStepHandler(handler); [EOL]     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]     Assert.assertTrue(handler.getLastError() < 1.1e-7); [EOL]     Assert.assertTrue(handler.getMaximalValueError() < 1.1e-7); [EOL]     Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); [EOL]     Assert.assertEquals("Dormand-Prince 8 (5, 3)", integ.getName()); [EOL] } <line_num>: 218,241
@Test [EOL] public void testEvents() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblem4 pb = new TestProblem4(); [EOL]     double minStep = 0; [EOL]     double maxStep = pb.getFinalTime() - pb.getInitialTime(); [EOL]     double scalAbsoluteTolerance = 1.0e-9; [EOL]     double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; [EOL]     FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); [EOL]     TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]     integ.addStepHandler(handler); [EOL]     EventHandler[] functions = pb.getEventsHandlers(); [EOL]     double convergence = 1.0e-8 * maxStep; [EOL]     for (int l = 0; l < functions.length; ++l) { [EOL]         integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, convergence, 1000); [EOL]     } [EOL]     Assert.assertEquals(functions.length, integ.getEventHandlers().size()); [EOL]     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]     Assert.assertEquals(0, handler.getMaximalValueError(), 2.1e-7); [EOL]     Assert.assertEquals(0, handler.getMaximalTimeError(), convergence); [EOL]     Assert.assertEquals(12.0, handler.getLastTime(), convergence); [EOL]     integ.clearEventHandlers(); [EOL]     Assert.assertEquals(0, integ.getEventHandlers().size()); [EOL] } <line_num>: 243,275
@Test [EOL] public void testKepler() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     final TestProblem3 pb = new TestProblem3(0.9); [EOL]     double minStep = 0; [EOL]     double maxStep = pb.getFinalTime() - pb.getInitialTime(); [EOL]     double scalAbsoluteTolerance = 1.0e-8; [EOL]     double scalRelativeTolerance = scalAbsoluteTolerance; [EOL]     FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); [EOL]     integ.addStepHandler(new KeplerHandler(pb)); [EOL]     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]     Assert.assertEquals(integ.getEvaluations(), pb.getCalls()); [EOL]     Assert.assertTrue(pb.getCalls() < 3300); [EOL] } <line_num>: 277,299
@Test [EOL] public void testVariableSteps() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     final TestProblem3 pb = new TestProblem3(0.9); [EOL]     double minStep = 0; [EOL]     double maxStep = pb.getFinalTime() - pb.getInitialTime(); [EOL]     double scalAbsoluteTolerance = 1.0e-8; [EOL]     double scalRelativeTolerance = scalAbsoluteTolerance; [EOL]     FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); [EOL]     integ.addStepHandler(new VariableHandler()); [EOL]     double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]     Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10); [EOL]     Assert.assertEquals("Dormand-Prince 8 (5, 3)", integ.getName()); [EOL] } <line_num>: 301,321
@Test [EOL] public void testUnstableDerivative() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0); [EOL]     FirstOrderIntegrator integ = new DormandPrince853Integrator(0.1, 10, 1.0e-12, 0.0); [EOL]     integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000); [EOL]     double[] y = { Double.NaN }; [EOL]     integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y); [EOL]     Assert.assertEquals(8.0, y[0], 1.0e-12); [EOL] } <line_num>: 323,334
public int getDimension() { [EOL]     return 2; [EOL] } <line_num>: 341,343
public void computeDerivatives(double t, double[] y, double[] yDot) { [EOL]     yDot[0] = y[1]; [EOL]     yDot[1] = -y[0]; [EOL] } <line_num>: 345,348
@Test [EOL] public void testEventsScheduling() { [EOL]     FirstOrderDifferentialEquations sincos = new FirstOrderDifferentialEquations() { [EOL]  [EOL]         public int getDimension() { [EOL]             return 2; [EOL]         } [EOL]  [EOL]         public void computeDerivatives(double t, double[] y, double[] yDot) { [EOL]             yDot[0] = y[1]; [EOL]             yDot[1] = -y[0]; [EOL]         } [EOL]     }; [EOL]     SchedulingChecker sinChecker = new SchedulingChecker(0); [EOL]     SchedulingChecker cosChecker = new SchedulingChecker(1); [EOL]     FirstOrderIntegrator integ = new DormandPrince853Integrator(0.001, 1.0, 1.0e-12, 0.0); [EOL]     integ.addEventHandler(sinChecker, 0.01, 1.0e-7, 100); [EOL]     integ.addStepHandler(sinChecker); [EOL]     integ.addEventHandler(cosChecker, 0.01, 1.0e-7, 100); [EOL]     integ.addStepHandler(cosChecker); [EOL]     double t0 = 0.5; [EOL]     double[] y0 = new double[] { FastMath.sin(t0), FastMath.cos(t0) }; [EOL]     double t = 10.0; [EOL]     double[] y = new double[2]; [EOL]     integ.integrate(sincos, t0, y0, t, y); [EOL] } <line_num>: 336,367
public void init(double t0, double[] y0, double t) { [EOL]     tMin = t0; [EOL] } <line_num>: 378,380
public void handleStep(StepInterpolator interpolator, boolean isLast) { [EOL]     tMin = interpolator.getCurrentTime(); [EOL] } <line_num>: 382,384
public double g(double t, double[] y) { [EOL]     Assert.assertTrue(t >= tMin); [EOL]     return y[index]; [EOL] } <line_num>: 386,391
public Action eventOccurred(double t, double[] y, boolean increasing) { [EOL]     return Action.RESET_STATE; [EOL] } <line_num>: 393,395
public void resetState(double t, double[] y) { [EOL] } <line_num>: 397,399
public void init(double t0, double[] y0, double t) { [EOL]     nbSteps = 0; [EOL]     maxError = 0; [EOL] } <line_num>: 407,410
public void handleStep(StepInterpolator interpolator, boolean isLast) throws MaxCountExceededException { [EOL]     ++nbSteps; [EOL]     for (int a = 1; a < 10; ++a) { [EOL]         double prev = interpolator.getPreviousTime(); [EOL]         double curr = interpolator.getCurrentTime(); [EOL]         double interp = ((10 - a) * prev + a * curr) / 10; [EOL]         interpolator.setInterpolatedTime(interp); [EOL]         double[] interpolatedY = interpolator.getInterpolatedState(); [EOL]         double[] theoreticalY = pb.computeTheoreticalState(interpolator.getInterpolatedTime()); [EOL]         double dx = interpolatedY[0] - theoreticalY[0]; [EOL]         double dy = interpolatedY[1] - theoreticalY[1]; [EOL]         double error = dx * dx + dy * dy; [EOL]         if (error > maxError) { [EOL]             maxError = error; [EOL]         } [EOL]     } [EOL]     if (isLast) { [EOL]         Assert.assertTrue(maxError < 2.4e-10); [EOL]         Assert.assertTrue(nbSteps < 150); [EOL]     } [EOL] } <line_num>: 411,435
public void init(double t0, double[] y0, double t) { [EOL]     firstTime = true; [EOL]     minStep = 0; [EOL]     maxStep = 0; [EOL] } <line_num>: 447,451
public void handleStep(StepInterpolator interpolator, boolean isLast) { [EOL]     double step = FastMath.abs(interpolator.getCurrentTime() - interpolator.getPreviousTime()); [EOL]     if (firstTime) { [EOL]         minStep = FastMath.abs(step); [EOL]         maxStep = minStep; [EOL]         firstTime = false; [EOL]     } else { [EOL]         if (step < minStep) { [EOL]             minStep = step; [EOL]         } [EOL]         if (step > maxStep) { [EOL]             maxStep = step; [EOL]         } [EOL]     } [EOL]     if (isLast) { [EOL]         Assert.assertTrue(minStep < (1.0 / 100.0)); [EOL]         Assert.assertTrue(maxStep > (1.0 / 2.0)); [EOL]     } [EOL] } <line_num>: 452,474
