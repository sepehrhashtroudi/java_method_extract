public KeplerHandler(TestProblem3 pb) { [EOL]     this.pb = pb; [EOL]     maxError = 0; [EOL] } <line_num>: 178,181
@Test(expected = DimensionMismatchException.class) [EOL] public void testDimensionCheck() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblem1 pb = new TestProblem1(); [EOL]     new ThreeEighthesIntegrator(0.01).integrate(pb, 0.0, new double[pb.getDimension() + 10], 1.0, new double[pb.getDimension() + 10]); [EOL]     Assert.fail("an exception should have been thrown"); [EOL] } <line_num>: 42,51
@Test [EOL] public void testDecreasingSteps() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblemAbstract[] problems = TestProblemFactory.getProblems(); [EOL]     for (int k = 0; k < problems.length; ++k) { [EOL]         double previousValueError = Double.NaN; [EOL]         double previousTimeError = Double.NaN; [EOL]         for (int i = 4; i < 10; ++i) { [EOL]             TestProblemAbstract pb = problems[k].copy(); [EOL]             double step = (pb.getFinalTime() - pb.getInitialTime()) * FastMath.pow(2.0, -i); [EOL]             FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step); [EOL]             TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]             integ.addStepHandler(handler); [EOL]             EventHandler[] functions = pb.getEventsHandlers(); [EOL]             for (int l = 0; l < functions.length; ++l) { [EOL]                 integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000); [EOL]             } [EOL]             double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]             if (functions.length == 0) { [EOL]                 Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10); [EOL]             } [EOL]             double error = handler.getMaximalValueError(); [EOL]             if (i > 4) { [EOL]                 Assert.assertTrue(error < 1.01 * FastMath.abs(previousValueError)); [EOL]             } [EOL]             previousValueError = error; [EOL]             double timeError = handler.getMaximalTimeError(); [EOL]             if (i > 4) { [EOL]                 Assert.assertTrue(timeError <= FastMath.abs(previousTimeError)); [EOL]             } [EOL]             previousTimeError = timeError; [EOL]         } [EOL]     } [EOL] } <line_num>: 53,98
@Test [EOL] public void testSmallStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblem1 pb = new TestProblem1(); [EOL]     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001; [EOL]     FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step); [EOL]     TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]     integ.addStepHandler(handler); [EOL]     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]     Assert.assertTrue(handler.getLastError() < 2.0e-13); [EOL]     Assert.assertTrue(handler.getMaximalValueError() < 4.0e-12); [EOL]     Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); [EOL]     Assert.assertEquals("3/8", integ.getName()); [EOL] } <line_num>: 100,119
@Test [EOL] public void testBigStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblem1 pb = new TestProblem1(); [EOL]     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2; [EOL]     FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step); [EOL]     TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]     integ.addStepHandler(handler); [EOL]     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]     Assert.assertTrue(handler.getLastError() > 0.0004); [EOL]     Assert.assertTrue(handler.getMaximalValueError() > 0.005); [EOL]     Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); [EOL] } <line_num>: 121,139
@Test [EOL] public void testBackward() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblem5 pb = new TestProblem5(); [EOL]     double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001; [EOL]     FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step); [EOL]     TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]     integ.addStepHandler(handler); [EOL]     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]     Assert.assertTrue(handler.getLastError() < 5.0e-10); [EOL]     Assert.assertTrue(handler.getMaximalValueError() < 7.0e-10); [EOL]     Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); [EOL]     Assert.assertEquals("3/8", integ.getName()); [EOL] } <line_num>: 141,159
@Test [EOL] public void testKepler() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     final TestProblem3 pb = new TestProblem3(0.9); [EOL]     double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003; [EOL]     FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step); [EOL]     integ.addStepHandler(new KeplerHandler(pb)); [EOL]     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL] } <line_num>: 161,174
public void init(double t0, double[] y0, double t) { [EOL]     maxError = 0; [EOL] } <line_num>: 183,185
public void handleStep(StepInterpolator interpolator, boolean isLast) throws MaxCountExceededException { [EOL]     double[] interpolatedY = interpolator.getInterpolatedState(); [EOL]     double[] theoreticalY = pb.computeTheoreticalState(interpolator.getCurrentTime()); [EOL]     double dx = interpolatedY[0] - theoreticalY[0]; [EOL]     double dy = interpolatedY[1] - theoreticalY[1]; [EOL]     double error = dx * dx + dy * dy; [EOL]     if (error > maxError) { [EOL]         maxError = error; [EOL]     } [EOL]     if (isLast) { [EOL]         Assert.assertTrue(maxError > 0.005); [EOL]     } [EOL] } <line_num>: 187,204
public void handleStep(StepInterpolator interpolator, boolean isLast) { [EOL]     if (!isLast) { [EOL]         Assert.assertEquals(step, interpolator.getCurrentTime() - interpolator.getPreviousTime(), 1.0e-12); [EOL]     } [EOL] } <line_num>: 218,224
public void init(double t0, double[] y0, double t) { [EOL] } <line_num>: 225,226
public void computeDerivatives(double t, double[] y, double[] dot) { [EOL]     dot[0] = 1.0; [EOL] } <line_num>: 229,231
public int getDimension() { [EOL]     return 1; [EOL] } <line_num>: 232,234
@Test [EOL] public void testStepSize() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     final double step = 1.23456; [EOL]     FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step); [EOL]     integ.addStepHandler(new StepHandler() { [EOL]  [EOL]         public void handleStep(StepInterpolator interpolator, boolean isLast) { [EOL]             if (!isLast) { [EOL]                 Assert.assertEquals(step, interpolator.getCurrentTime() - interpolator.getPreviousTime(), 1.0e-12); [EOL]             } [EOL]         } [EOL]  [EOL]         public void init(double t0, double[] y0, double t) { [EOL]         } [EOL]     }); [EOL]     integ.integrate(new FirstOrderDifferentialEquations() { [EOL]  [EOL]         public void computeDerivatives(double t, double[] y, double[] dot) { [EOL]             dot[0] = 1.0; [EOL]         } [EOL]  [EOL]         public int getDimension() { [EOL]             return 1; [EOL]         } [EOL]     }, 0.0, new double[] { 0.0 }, 5.0, new double[1]); [EOL] } <line_num>: 211,236
