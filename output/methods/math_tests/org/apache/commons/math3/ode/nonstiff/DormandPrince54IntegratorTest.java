public DP54SmallLastHandler(double minStep) { [EOL]     lastSeen = false; [EOL]     this.minStep = minStep; [EOL] } <line_num>: 130,133
public KeplerHandler(TestProblem3 pb) { [EOL]     this.pb = pb; [EOL] } <line_num>: 278,280
public VariableHandler() { [EOL]     firstTime = true; [EOL]     minStep = 0; [EOL]     maxStep = 0; [EOL] } <line_num>: 316,320
@Test(expected = DimensionMismatchException.class) [EOL] public void testDimensionCheck() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblem1 pb = new TestProblem1(); [EOL]     DormandPrince54Integrator integrator = new DormandPrince54Integrator(0.0, 1.0, 1.0e-10, 1.0e-10); [EOL]     integrator.integrate(pb, 0.0, new double[pb.getDimension() + 10], 1.0, new double[pb.getDimension() + 10]); [EOL] } <line_num>: 41,51
@Test(expected = NumberIsTooSmallException.class) [EOL] public void testMinStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblem1 pb = new TestProblem1(); [EOL]     double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime()); [EOL]     double maxStep = pb.getFinalTime() - pb.getInitialTime(); [EOL]     double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 }; [EOL]     double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 }; [EOL]     FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance); [EOL]     TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]     integ.addStepHandler(handler); [EOL]     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]     Assert.fail("an exception should have been thrown"); [EOL] } <line_num>: 53,74
@Test [EOL] public void testSmallLastStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblemAbstract pb = new TestProblem5(); [EOL]     double minStep = 1.25; [EOL]     double maxStep = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()); [EOL]     double scalAbsoluteTolerance = 6.0e-4; [EOL]     double scalRelativeTolerance = 6.0e-4; [EOL]     AdaptiveStepsizeIntegrator integ = new DormandPrince54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); [EOL]     DP54SmallLastHandler handler = new DP54SmallLastHandler(minStep); [EOL]     integ.addStepHandler(handler); [EOL]     integ.setInitialStepSize(1.7); [EOL]     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]     Assert.assertTrue(handler.wasLastSeen()); [EOL]     Assert.assertEquals("Dormand-Prince 5(4)", integ.getName()); [EOL] } <line_num>: 76,101
@Test [EOL] public void testBackward() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblem5 pb = new TestProblem5(); [EOL]     double minStep = 0; [EOL]     double maxStep = pb.getFinalTime() - pb.getInitialTime(); [EOL]     double scalAbsoluteTolerance = 1.0e-8; [EOL]     double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; [EOL]     FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); [EOL]     TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]     integ.addStepHandler(handler); [EOL]     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]     Assert.assertTrue(handler.getLastError() < 2.0e-7); [EOL]     Assert.assertTrue(handler.getMaximalValueError() < 2.0e-7); [EOL]     Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); [EOL]     Assert.assertEquals("Dormand-Prince 5(4)", integ.getName()); [EOL] } <line_num>: 103,126
public void init(double t0, double[] y0, double t) { [EOL] } <line_num>: 135,136
public void handleStep(StepInterpolator interpolator, boolean isLast) { [EOL]     if (isLast) { [EOL]         lastSeen = true; [EOL]         double h = interpolator.getCurrentTime() - interpolator.getPreviousTime(); [EOL]         Assert.assertTrue(FastMath.abs(h) < minStep); [EOL]     } [EOL] } <line_num>: 138,144
public boolean wasLastSeen() { [EOL]     return lastSeen; [EOL] } <line_num>: 146,148
@Test [EOL] public void testIncreasingTolerance() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     int previousCalls = Integer.MAX_VALUE; [EOL]     for (int i = -12; i < -2; ++i) { [EOL]         TestProblem1 pb = new TestProblem1(); [EOL]         double minStep = 0; [EOL]         double maxStep = pb.getFinalTime() - pb.getInitialTime(); [EOL]         double scalAbsoluteTolerance = FastMath.pow(10.0, i); [EOL]         double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; [EOL]         EmbeddedRungeKuttaIntegrator integ = new DormandPrince54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); [EOL]         TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]         integ.setSafety(0.8); [EOL]         integ.setMaxGrowth(5.0); [EOL]         integ.setMinReduction(0.3); [EOL]         integ.addStepHandler(handler); [EOL]         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]         Assert.assertEquals(0.8, integ.getSafety(), 1.0e-12); [EOL]         Assert.assertEquals(5.0, integ.getMaxGrowth(), 1.0e-12); [EOL]         Assert.assertEquals(0.3, integ.getMinReduction(), 1.0e-12); [EOL]         Assert.assertTrue(handler.getMaximalValueError() < (0.7 * scalAbsoluteTolerance)); [EOL]         Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); [EOL]         int calls = pb.getCalls(); [EOL]         Assert.assertEquals(integ.getEvaluations(), calls); [EOL]         Assert.assertTrue(calls <= previousCalls); [EOL]         previousCalls = calls; [EOL]     } [EOL] } <line_num>: 155,196
@Test [EOL] public void testEvents() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblem4 pb = new TestProblem4(); [EOL]     double minStep = 0; [EOL]     double maxStep = pb.getFinalTime() - pb.getInitialTime(); [EOL]     double scalAbsoluteTolerance = 1.0e-8; [EOL]     double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; [EOL]     FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); [EOL]     TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]     integ.addStepHandler(handler); [EOL]     EventHandler[] functions = pb.getEventsHandlers(); [EOL]     double convergence = 1.0e-8 * maxStep; [EOL]     for (int l = 0; l < functions.length; ++l) { [EOL]         integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, convergence, 1000); [EOL]     } [EOL]     Assert.assertEquals(functions.length, integ.getEventHandlers().size()); [EOL]     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]     Assert.assertTrue(handler.getMaximalValueError() < 5.0e-6); [EOL]     Assert.assertEquals(0, handler.getMaximalTimeError(), convergence); [EOL]     Assert.assertEquals(12.0, handler.getLastTime(), convergence); [EOL]     integ.clearEventHandlers(); [EOL]     Assert.assertEquals(0, integ.getEventHandlers().size()); [EOL] } <line_num>: 198,231
@Test [EOL] public void testKepler() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     final TestProblem3 pb = new TestProblem3(0.9); [EOL]     double minStep = 0; [EOL]     double maxStep = pb.getFinalTime() - pb.getInitialTime(); [EOL]     double scalAbsoluteTolerance = 1.0e-8; [EOL]     double scalRelativeTolerance = scalAbsoluteTolerance; [EOL]     FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); [EOL]     integ.addStepHandler(new KeplerHandler(pb)); [EOL]     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]     Assert.assertEquals(integ.getEvaluations(), pb.getCalls()); [EOL]     Assert.assertTrue(pb.getCalls() < 2800); [EOL] } <line_num>: 233,255
@Test [EOL] public void testVariableSteps() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     final TestProblem3 pb = new TestProblem3(0.9); [EOL]     double minStep = 0; [EOL]     double maxStep = pb.getFinalTime() - pb.getInitialTime(); [EOL]     double scalAbsoluteTolerance = 1.0e-8; [EOL]     double scalRelativeTolerance = scalAbsoluteTolerance; [EOL]     FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); [EOL]     integ.addStepHandler(new VariableHandler()); [EOL]     double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]     Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10); [EOL] } <line_num>: 257,275
public void init(double t0, double[] y0, double t) { [EOL]     nbSteps = 0; [EOL]     maxError = 0; [EOL] } <line_num>: 281,284
public void handleStep(StepInterpolator interpolator, boolean isLast) throws MaxCountExceededException { [EOL]     ++nbSteps; [EOL]     for (int a = 1; a < 10; ++a) { [EOL]         double prev = interpolator.getPreviousTime(); [EOL]         double curr = interpolator.getCurrentTime(); [EOL]         double interp = ((10 - a) * prev + a * curr) / 10; [EOL]         interpolator.setInterpolatedTime(interp); [EOL]         double[] interpolatedY = interpolator.getInterpolatedState(); [EOL]         double[] theoreticalY = pb.computeTheoreticalState(interpolator.getInterpolatedTime()); [EOL]         double dx = interpolatedY[0] - theoreticalY[0]; [EOL]         double dy = interpolatedY[1] - theoreticalY[1]; [EOL]         double error = dx * dx + dy * dy; [EOL]         if (error > maxError) { [EOL]             maxError = error; [EOL]         } [EOL]     } [EOL]     if (isLast) { [EOL]         Assert.assertTrue(maxError < 7.0e-10); [EOL]         Assert.assertTrue(nbSteps < 400); [EOL]     } [EOL] } <line_num>: 285,309
public void init(double t0, double[] y0, double t) { [EOL]     firstTime = true; [EOL]     minStep = 0; [EOL]     maxStep = 0; [EOL] } <line_num>: 321,325
public void handleStep(StepInterpolator interpolator, boolean isLast) { [EOL]     double step = FastMath.abs(interpolator.getCurrentTime() - interpolator.getPreviousTime()); [EOL]     if (firstTime) { [EOL]         minStep = FastMath.abs(step); [EOL]         maxStep = minStep; [EOL]         firstTime = false; [EOL]     } else { [EOL]         if (step < minStep) { [EOL]             minStep = step; [EOL]         } [EOL]         if (step > maxStep) { [EOL]             maxStep = step; [EOL]         } [EOL]     } [EOL]     if (isLast) { [EOL]         Assert.assertTrue(minStep < (1.0 / 450.0)); [EOL]         Assert.assertTrue(maxStep > (1.0 / 4.2)); [EOL]     } [EOL] } <line_num>: 326,348
