public Brusselator(double b) { [EOL]     super(B); [EOL]     this.b = b; [EOL] } <line_num>: 304,307
public ParamBrusselator(double b) { [EOL]     super(B); [EOL]     this.b = b; [EOL] } <line_num>: 357,360
public Circle(double[] y0, double cx, double cy, double omega) { [EOL]     super(CX, CY, OMEGA); [EOL]     this.y0 = y0.clone(); [EOL]     this.cx = cx; [EOL]     this.cy = cy; [EOL]     this.omega = omega; [EOL] } <line_num>: 409,415
public ParameterizedCircle(double[] y0, double cx, double cy, double omega) { [EOL]     super(CX, CY, OMEGA); [EOL]     this.y0 = y0.clone(); [EOL]     this.cx = cx; [EOL]     this.cy = cy; [EOL]     this.omega = omega; [EOL] } <line_num>: 505,511
@Test [EOL] public void testLowAccuracyExternalDifferentiation() throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException { [EOL]     FirstOrderIntegrator integ = new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-4, 1.0e-4 }, new double[] { 1.0e-4, 1.0e-4 }); [EOL]     double hP = 1.0e-12; [EOL]     SummaryStatistics residualsP0 = new SummaryStatistics(); [EOL]     SummaryStatistics residualsP1 = new SummaryStatistics(); [EOL]     for (double b = 2.88; b < 3.08; b += 0.001) { [EOL]         Brusselator brusselator = new Brusselator(b); [EOL]         double[] y = { 1.3, b }; [EOL]         integ.integrate(brusselator, 0, y, 20.0, y); [EOL]         double[] yP = { 1.3, b + hP }; [EOL]         integ.integrate(brusselator, 0, yP, 20.0, yP); [EOL]         residualsP0.addValue((yP[0] - y[0]) / hP - brusselator.dYdP0()); [EOL]         residualsP1.addValue((yP[1] - y[1]) / hP - brusselator.dYdP1()); [EOL]     } [EOL]     Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) > 500); [EOL]     Assert.assertTrue(residualsP0.getStandardDeviation() > 30); [EOL]     Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) > 700); [EOL]     Assert.assertTrue(residualsP1.getStandardDeviation() > 40); [EOL] } <line_num>: 33,64
@Test [EOL] public void testHighAccuracyExternalDifferentiation() throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException, UnknownParameterException { [EOL]     FirstOrderIntegrator integ = new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-10, 1.0e-10 }, new double[] { 1.0e-10, 1.0e-10 }); [EOL]     double hP = 1.0e-12; [EOL]     SummaryStatistics residualsP0 = new SummaryStatistics(); [EOL]     SummaryStatistics residualsP1 = new SummaryStatistics(); [EOL]     for (double b = 2.88; b < 3.08; b += 0.001) { [EOL]         ParamBrusselator brusselator = new ParamBrusselator(b); [EOL]         double[] y = { 1.3, b }; [EOL]         integ.integrate(brusselator, 0, y, 20.0, y); [EOL]         double[] yP = { 1.3, b + hP }; [EOL]         brusselator.setParameter("b", b + hP); [EOL]         integ.integrate(brusselator, 0, yP, 20.0, yP); [EOL]         residualsP0.addValue((yP[0] - y[0]) / hP - brusselator.dYdP0()); [EOL]         residualsP1.addValue((yP[1] - y[1]) / hP - brusselator.dYdP1()); [EOL]     } [EOL]     Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) > 0.02); [EOL]     Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) < 0.03); [EOL]     Assert.assertTrue(residualsP0.getStandardDeviation() > 0.003); [EOL]     Assert.assertTrue(residualsP0.getStandardDeviation() < 0.004); [EOL]     Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) > 0.04); [EOL]     Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) < 0.05); [EOL]     Assert.assertTrue(residualsP1.getStandardDeviation() > 0.007); [EOL]     Assert.assertTrue(residualsP1.getStandardDeviation() < 0.008); [EOL] } <line_num>: 66,93
@Test [EOL] public void testInternalDifferentiation() throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException, UnknownParameterException, MismatchedEquations { [EOL]     AbstractIntegrator integ = new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-4, 1.0e-4 }, new double[] { 1.0e-4, 1.0e-4 }); [EOL]     double hP = 1.0e-12; [EOL]     double hY = 1.0e-12; [EOL]     SummaryStatistics residualsP0 = new SummaryStatistics(); [EOL]     SummaryStatistics residualsP1 = new SummaryStatistics(); [EOL]     for (double b = 2.88; b < 3.08; b += 0.001) { [EOL]         ParamBrusselator brusselator = new ParamBrusselator(b); [EOL]         brusselator.setParameter(ParamBrusselator.B, b); [EOL]         double[] z = { 1.3, b }; [EOL]         double[][] dZdZ0 = new double[2][2]; [EOL]         double[] dZdP = new double[2]; [EOL]         JacobianMatrices jacob = new JacobianMatrices(brusselator, new double[] { hY, hY }, ParamBrusselator.B); [EOL]         jacob.setParameterizedODE(brusselator); [EOL]         jacob.setParameterStep(ParamBrusselator.B, hP); [EOL]         jacob.setInitialParameterJacobian(ParamBrusselator.B, new double[] { 0.0, 1.0 }); [EOL]         ExpandableStatefulODE efode = new ExpandableStatefulODE(brusselator); [EOL]         efode.setTime(0); [EOL]         efode.setPrimaryState(z); [EOL]         jacob.registerVariationalEquations(efode); [EOL]         integ.setMaxEvaluations(5000); [EOL]         integ.integrate(efode, 20.0); [EOL]         jacob.getCurrentMainSetJacobian(dZdZ0); [EOL]         jacob.getCurrentParameterJacobian(ParamBrusselator.B, dZdP); [EOL]         residualsP0.addValue(dZdP[0] - brusselator.dYdP0()); [EOL]         residualsP1.addValue(dZdP[1] - brusselator.dYdP1()); [EOL]     } [EOL]     Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) < 0.02); [EOL]     Assert.assertTrue(residualsP0.getStandardDeviation() < 0.003); [EOL]     Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) < 0.05); [EOL]     Assert.assertTrue(residualsP1.getStandardDeviation() < 0.01); [EOL] } <line_num>: 95,138
@Test [EOL] public void testAnalyticalDifferentiation() throws MaxCountExceededException, DimensionMismatchException, NumberIsTooSmallException, NoBracketingException, UnknownParameterException, MismatchedEquations { [EOL]     AbstractIntegrator integ = new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-4, 1.0e-4 }, new double[] { 1.0e-4, 1.0e-4 }); [EOL]     SummaryStatistics residualsP0 = new SummaryStatistics(); [EOL]     SummaryStatistics residualsP1 = new SummaryStatistics(); [EOL]     for (double b = 2.88; b < 3.08; b += 0.001) { [EOL]         Brusselator brusselator = new Brusselator(b); [EOL]         double[] z = { 1.3, b }; [EOL]         double[][] dZdZ0 = new double[2][2]; [EOL]         double[] dZdP = new double[2]; [EOL]         JacobianMatrices jacob = new JacobianMatrices(brusselator, Brusselator.B); [EOL]         jacob.addParameterJacobianProvider(brusselator); [EOL]         jacob.setInitialParameterJacobian(Brusselator.B, new double[] { 0.0, 1.0 }); [EOL]         ExpandableStatefulODE efode = new ExpandableStatefulODE(brusselator); [EOL]         efode.setTime(0); [EOL]         efode.setPrimaryState(z); [EOL]         jacob.registerVariationalEquations(efode); [EOL]         integ.setMaxEvaluations(5000); [EOL]         integ.integrate(efode, 20.0); [EOL]         jacob.getCurrentMainSetJacobian(dZdZ0); [EOL]         jacob.getCurrentParameterJacobian(Brusselator.B, dZdP); [EOL]         residualsP0.addValue(dZdP[0] - brusselator.dYdP0()); [EOL]         residualsP1.addValue(dZdP[1] - brusselator.dYdP1()); [EOL]     } [EOL]     Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) < 0.014); [EOL]     Assert.assertTrue(residualsP0.getStandardDeviation() < 0.003); [EOL]     Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) < 0.05); [EOL]     Assert.assertTrue(residualsP1.getStandardDeviation() < 0.01); [EOL] } <line_num>: 140,178
@Test [EOL] public void testFinalResult() throws MaxCountExceededException, DimensionMismatchException, NumberIsTooSmallException, NoBracketingException, UnknownParameterException, MismatchedEquations { [EOL]     AbstractIntegrator integ = new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-10, 1.0e-10 }, new double[] { 1.0e-10, 1.0e-10 }); [EOL]     double[] y = new double[] { 0.0, 1.0 }; [EOL]     Circle circle = new Circle(y, 1.0, 1.0, 0.1); [EOL]     JacobianMatrices jacob = new JacobianMatrices(circle, Circle.CX, Circle.CY, Circle.OMEGA); [EOL]     jacob.addParameterJacobianProvider(circle); [EOL]     jacob.setInitialMainStateJacobian(circle.exactDyDy0(0)); [EOL]     jacob.setInitialParameterJacobian(Circle.CX, circle.exactDyDcx(0)); [EOL]     jacob.setInitialParameterJacobian(Circle.CY, circle.exactDyDcy(0)); [EOL]     jacob.setInitialParameterJacobian(Circle.OMEGA, circle.exactDyDom(0)); [EOL]     ExpandableStatefulODE efode = new ExpandableStatefulODE(circle); [EOL]     efode.setTime(0); [EOL]     efode.setPrimaryState(y); [EOL]     jacob.registerVariationalEquations(efode); [EOL]     integ.setMaxEvaluations(5000); [EOL]     double t = 18 * FastMath.PI; [EOL]     integ.integrate(efode, t); [EOL]     y = efode.getPrimaryState(); [EOL]     for (int i = 0; i < y.length; ++i) { [EOL]         Assert.assertEquals(circle.exactY(t)[i], y[i], 1.0e-9); [EOL]     } [EOL]     double[][] dydy0 = new double[2][2]; [EOL]     jacob.getCurrentMainSetJacobian(dydy0); [EOL]     for (int i = 0; i < dydy0.length; ++i) { [EOL]         for (int j = 0; j < dydy0[i].length; ++j) { [EOL]             Assert.assertEquals(circle.exactDyDy0(t)[i][j], dydy0[i][j], 1.0e-9); [EOL]         } [EOL]     } [EOL]     double[] dydcx = new double[2]; [EOL]     jacob.getCurrentParameterJacobian(Circle.CX, dydcx); [EOL]     for (int i = 0; i < dydcx.length; ++i) { [EOL]         Assert.assertEquals(circle.exactDyDcx(t)[i], dydcx[i], 1.0e-7); [EOL]     } [EOL]     double[] dydcy = new double[2]; [EOL]     jacob.getCurrentParameterJacobian(Circle.CY, dydcy); [EOL]     for (int i = 0; i < dydcy.length; ++i) { [EOL]         Assert.assertEquals(circle.exactDyDcy(t)[i], dydcy[i], 1.0e-7); [EOL]     } [EOL]     double[] dydom = new double[2]; [EOL]     jacob.getCurrentParameterJacobian(Circle.OMEGA, dydom); [EOL]     for (int i = 0; i < dydom.length; ++i) { [EOL]         Assert.assertEquals(circle.exactDyDom(t)[i], dydom[i], 1.0e-7); [EOL]     } [EOL] } <line_num>: 180,234
@Test [EOL] public void testParameterizable() throws MaxCountExceededException, DimensionMismatchException, NumberIsTooSmallException, NoBracketingException, UnknownParameterException, MismatchedEquations { [EOL]     AbstractIntegrator integ = new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-10, 1.0e-10 }, new double[] { 1.0e-10, 1.0e-10 }); [EOL]     double[] y = new double[] { 0.0, 1.0 }; [EOL]     ParameterizedCircle pcircle = new ParameterizedCircle(y, 1.0, 1.0, 0.1); [EOL]     double hP = 1.0e-12; [EOL]     double hY = 1.0e-12; [EOL]     JacobianMatrices jacob = new JacobianMatrices(pcircle, new double[] { hY, hY }, ParameterizedCircle.CX, ParameterizedCircle.CY, ParameterizedCircle.OMEGA); [EOL]     jacob.setParameterizedODE(pcircle); [EOL]     jacob.setParameterStep(ParameterizedCircle.CX, hP); [EOL]     jacob.setParameterStep(ParameterizedCircle.CY, hP); [EOL]     jacob.setParameterStep(ParameterizedCircle.OMEGA, hP); [EOL]     jacob.setInitialMainStateJacobian(pcircle.exactDyDy0(0)); [EOL]     jacob.setInitialParameterJacobian(ParameterizedCircle.CX, pcircle.exactDyDcx(0)); [EOL]     jacob.setInitialParameterJacobian(ParameterizedCircle.CY, pcircle.exactDyDcy(0)); [EOL]     jacob.setInitialParameterJacobian(ParameterizedCircle.OMEGA, pcircle.exactDyDom(0)); [EOL]     ExpandableStatefulODE efode = new ExpandableStatefulODE(pcircle); [EOL]     efode.setTime(0); [EOL]     efode.setPrimaryState(y); [EOL]     jacob.registerVariationalEquations(efode); [EOL]     integ.setMaxEvaluations(50000); [EOL]     double t = 18 * FastMath.PI; [EOL]     integ.integrate(efode, t); [EOL]     y = efode.getPrimaryState(); [EOL]     for (int i = 0; i < y.length; ++i) { [EOL]         Assert.assertEquals(pcircle.exactY(t)[i], y[i], 1.0e-9); [EOL]     } [EOL]     double[][] dydy0 = new double[2][2]; [EOL]     jacob.getCurrentMainSetJacobian(dydy0); [EOL]     for (int i = 0; i < dydy0.length; ++i) { [EOL]         for (int j = 0; j < dydy0[i].length; ++j) { [EOL]             Assert.assertEquals(pcircle.exactDyDy0(t)[i][j], dydy0[i][j], 5.0e-4); [EOL]         } [EOL]     } [EOL]     double[] dydp0 = new double[2]; [EOL]     jacob.getCurrentParameterJacobian(ParameterizedCircle.CX, dydp0); [EOL]     for (int i = 0; i < dydp0.length; ++i) { [EOL]         Assert.assertEquals(pcircle.exactDyDcx(t)[i], dydp0[i], 5.0e-4); [EOL]     } [EOL]     double[] dydp1 = new double[2]; [EOL]     jacob.getCurrentParameterJacobian(ParameterizedCircle.OMEGA, dydp1); [EOL]     for (int i = 0; i < dydp1.length; ++i) { [EOL]         Assert.assertEquals(pcircle.exactDyDom(t)[i], dydp1[i], 1.0e-2); [EOL]     } [EOL] } <line_num>: 236,295
public int getDimension() { [EOL]     return 2; [EOL] } <line_num>: 309,311
public void computeDerivatives(double t, double[] y, double[] yDot) { [EOL]     double prod = y[0] * y[0] * y[1]; [EOL]     yDot[0] = 1 + prod - (b + 1) * y[0]; [EOL]     yDot[1] = b * y[0] - prod; [EOL] } <line_num>: 313,317
public void computeMainStateJacobian(double t, double[] y, double[] yDot, double[][] dFdY) { [EOL]     double p = 2 * y[0] * y[1]; [EOL]     double y02 = y[0] * y[0]; [EOL]     dFdY[0][0] = p - (1 + b); [EOL]     dFdY[0][1] = y02; [EOL]     dFdY[1][0] = b - p; [EOL]     dFdY[1][1] = -y02; [EOL] } <line_num>: 319,327
public void computeParameterJacobian(double t, double[] y, double[] yDot, String paramName, double[] dFdP) { [EOL]     if (isSupported(paramName)) { [EOL]         dFdP[0] = -y[0]; [EOL]         dFdP[1] = y[0]; [EOL]     } else { [EOL]         dFdP[0] = 0; [EOL]         dFdP[1] = 0; [EOL]     } [EOL] } <line_num>: 329,338
public double dYdP0() { [EOL]     return -1088.232716447743 + (1050.775747149553 + (-339.012934631828 + 36.52917025056327 * b) * b) * b; [EOL] } <line_num>: 340,342
public double dYdP1() { [EOL]     return 1502.824469929139 + (-1438.6974831849952 + (460.959476642384 - 49.43847385647082 * b) * b) * b; [EOL] } <line_num>: 344,346
public int getDimension() { [EOL]     return 2; [EOL] } <line_num>: 362,364
public double getParameter(final String name) throws UnknownParameterException { [EOL]     complainIfNotSupported(name); [EOL]     return b; [EOL] } <line_num>: 367,371
public void setParameter(final String name, final double value) throws UnknownParameterException { [EOL]     complainIfNotSupported(name); [EOL]     b = value; [EOL] } <line_num>: 374,378
public void computeDerivatives(double t, double[] y, double[] yDot) { [EOL]     double prod = y[0] * y[0] * y[1]; [EOL]     yDot[0] = 1 + prod - (b + 1) * y[0]; [EOL]     yDot[1] = b * y[0] - prod; [EOL] } <line_num>: 380,384
public double dYdP0() { [EOL]     return -1088.232716447743 + (1050.775747149553 + (-339.012934631828 + 36.52917025056327 * b) * b) * b; [EOL] } <line_num>: 386,388
public double dYdP1() { [EOL]     return 1502.824469929139 + (-1438.6974831849952 + (460.959476642384 - 49.43847385647082 * b) * b) * b; [EOL] } <line_num>: 390,392
public int getDimension() { [EOL]     return 2; [EOL] } <line_num>: 417,419
public void computeDerivatives(double t, double[] y, double[] yDot) { [EOL]     yDot[0] = omega * (cy - y[1]); [EOL]     yDot[1] = omega * (y[0] - cx); [EOL] } <line_num>: 421,424
public void computeMainStateJacobian(double t, double[] y, double[] yDot, double[][] dFdY) { [EOL]     dFdY[0][0] = 0; [EOL]     dFdY[0][1] = -omega; [EOL]     dFdY[1][0] = omega; [EOL]     dFdY[1][1] = 0; [EOL] } <line_num>: 426,432
public void computeParameterJacobian(double t, double[] y, double[] yDot, String paramName, double[] dFdP) throws UnknownParameterException { [EOL]     complainIfNotSupported(paramName); [EOL]     if (paramName.equals(CX)) { [EOL]         dFdP[0] = 0; [EOL]         dFdP[1] = -omega; [EOL]     } else if (paramName.equals(CY)) { [EOL]         dFdP[0] = omega; [EOL]         dFdP[1] = 0; [EOL]     } else { [EOL]         dFdP[0] = cy - y[1]; [EOL]         dFdP[1] = y[0] - cx; [EOL]     } [EOL] } <line_num>: 434,448
public double[] exactY(double t) { [EOL]     double cos = FastMath.cos(omega * t); [EOL]     double sin = FastMath.sin(omega * t); [EOL]     double dx0 = y0[0] - cx; [EOL]     double dy0 = y0[1] - cy; [EOL]     return new double[] { cx + cos * dx0 - sin * dy0, cy + sin * dx0 + cos * dy0 }; [EOL] } <line_num>: 450,459
public double[][] exactDyDy0(double t) { [EOL]     double cos = FastMath.cos(omega * t); [EOL]     double sin = FastMath.sin(omega * t); [EOL]     return new double[][] { { cos, -sin }, { sin, cos } }; [EOL] } <line_num>: 461,468
public double[] exactDyDcx(double t) { [EOL]     double cos = FastMath.cos(omega * t); [EOL]     double sin = FastMath.sin(omega * t); [EOL]     return new double[] { 1 - cos, -sin }; [EOL] } <line_num>: 470,474
public double[] exactDyDcy(double t) { [EOL]     double cos = FastMath.cos(omega * t); [EOL]     double sin = FastMath.sin(omega * t); [EOL]     return new double[] { sin, 1 - cos }; [EOL] } <line_num>: 476,480
public double[] exactDyDom(double t) { [EOL]     double cos = FastMath.cos(omega * t); [EOL]     double sin = FastMath.sin(omega * t); [EOL]     double dx0 = y0[0] - cx; [EOL]     double dy0 = y0[1] - cy; [EOL]     return new double[] { -t * (sin * dx0 + cos * dy0), t * (cos * dx0 - sin * dy0) }; [EOL] } <line_num>: 482,488
public int getDimension() { [EOL]     return 2; [EOL] } <line_num>: 513,515
public void computeDerivatives(double t, double[] y, double[] yDot) { [EOL]     yDot[0] = omega * (cy - y[1]); [EOL]     yDot[1] = omega * (y[0] - cx); [EOL] } <line_num>: 517,520
public double getParameter(final String name) throws UnknownParameterException { [EOL]     if (name.equals(CX)) { [EOL]         return cx; [EOL]     } else if (name.equals(CY)) { [EOL]         return cy; [EOL]     } else if (name.equals(OMEGA)) { [EOL]         return omega; [EOL]     } else { [EOL]         throw new UnknownParameterException(name); [EOL]     } [EOL] } <line_num>: 522,533
public void setParameter(final String name, final double value) throws UnknownParameterException { [EOL]     if (name.equals(CX)) { [EOL]         cx = value; [EOL]     } else if (name.equals(CY)) { [EOL]         cy = value; [EOL]     } else if (name.equals(OMEGA)) { [EOL]         omega = value; [EOL]     } else { [EOL]         throw new UnknownParameterException(name); [EOL]     } [EOL] } <line_num>: 535,546
public double[] exactY(double t) { [EOL]     double cos = FastMath.cos(omega * t); [EOL]     double sin = FastMath.sin(omega * t); [EOL]     double dx0 = y0[0] - cx; [EOL]     double dy0 = y0[1] - cy; [EOL]     return new double[] { cx + cos * dx0 - sin * dy0, cy + sin * dx0 + cos * dy0 }; [EOL] } <line_num>: 548,557
public double[][] exactDyDy0(double t) { [EOL]     double cos = FastMath.cos(omega * t); [EOL]     double sin = FastMath.sin(omega * t); [EOL]     return new double[][] { { cos, -sin }, { sin, cos } }; [EOL] } <line_num>: 559,566
public double[] exactDyDcx(double t) { [EOL]     double cos = FastMath.cos(omega * t); [EOL]     double sin = FastMath.sin(omega * t); [EOL]     return new double[] { 1 - cos, -sin }; [EOL] } <line_num>: 568,572
public double[] exactDyDcy(double t) { [EOL]     double cos = FastMath.cos(omega * t); [EOL]     double sin = FastMath.sin(omega * t); [EOL]     return new double[] { sin, 1 - cos }; [EOL] } <line_num>: 574,578
public double[] exactDyDom(double t) { [EOL]     double cos = FastMath.cos(omega * t); [EOL]     double sin = FastMath.sin(omega * t); [EOL]     double dx0 = y0[0] - cx; [EOL]     double dy0 = y0[1] - cy; [EOL]     return new double[] { -t * (sin * dx0 + cos * dy0), t * (cos * dx0 - sin * dy0) }; [EOL] } <line_num>: 580,586
