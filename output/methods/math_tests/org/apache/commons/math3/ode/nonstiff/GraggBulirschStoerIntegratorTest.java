public KeplerStepHandler(TestProblem3 pb) { [EOL]     this.pb = pb; [EOL] } <line_num>: 350,352
public VariableStepHandler() { [EOL]     firstTime = true; [EOL]     minStep = 0; [EOL]     maxStep = 0; [EOL] } <line_num>: 388,392
@Test(expected = DimensionMismatchException.class) [EOL] public void testDimensionCheck() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblem1 pb = new TestProblem1(); [EOL]     AdaptiveStepsizeIntegrator integrator = new GraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10); [EOL]     integrator.integrate(pb, 0.0, new double[pb.getDimension() + 10], 1.0, new double[pb.getDimension() + 10]); [EOL] } <line_num>: 42,52
@Test(expected = NumberIsTooSmallException.class) [EOL] public void testNullIntervalCheck() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblem1 pb = new TestProblem1(); [EOL]     GraggBulirschStoerIntegrator integrator = new GraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10); [EOL]     integrator.integrate(pb, 0.0, new double[pb.getDimension()], 0.0, new double[pb.getDimension()]); [EOL] } <line_num>: 54,64
@Test(expected = NumberIsTooSmallException.class) [EOL] public void testMinStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblem5 pb = new TestProblem5(); [EOL]     double minStep = 0.1 * FastMath.abs(pb.getFinalTime() - pb.getInitialTime()); [EOL]     double maxStep = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()); [EOL]     double[] vecAbsoluteTolerance = { 1.0e-20, 1.0e-21 }; [EOL]     double[] vecRelativeTolerance = { 1.0e-20, 1.0e-21 }; [EOL]     FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance); [EOL]     TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]     integ.addStepHandler(handler); [EOL]     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL] } <line_num>: 66,86
@Test [EOL] public void testBackward() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblem5 pb = new TestProblem5(); [EOL]     double minStep = 0; [EOL]     double maxStep = pb.getFinalTime() - pb.getInitialTime(); [EOL]     double scalAbsoluteTolerance = 1.0e-8; [EOL]     double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; [EOL]     FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); [EOL]     TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]     integ.addStepHandler(handler); [EOL]     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]     Assert.assertTrue(handler.getLastError() < 7.5e-9); [EOL]     Assert.assertTrue(handler.getMaximalValueError() < 8.1e-9); [EOL]     Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); [EOL]     Assert.assertEquals("Gragg-Bulirsch-Stoer", integ.getName()); [EOL] } <line_num>: 88,111
@Test [EOL] public void testIncreasingTolerance() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     int previousCalls = Integer.MAX_VALUE; [EOL]     for (int i = -12; i < -4; ++i) { [EOL]         TestProblem1 pb = new TestProblem1(); [EOL]         double minStep = 0; [EOL]         double maxStep = pb.getFinalTime() - pb.getInitialTime(); [EOL]         double absTolerance = FastMath.pow(10.0, i); [EOL]         double relTolerance = absTolerance; [EOL]         FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep, absTolerance, relTolerance); [EOL]         TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]         integ.addStepHandler(handler); [EOL]         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]         double ratio = handler.getMaximalValueError() / absTolerance; [EOL]         Assert.assertTrue(ratio < 2.4); [EOL]         Assert.assertTrue(ratio > 0.02); [EOL]         Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); [EOL]         int calls = pb.getCalls(); [EOL]         Assert.assertEquals(integ.getEvaluations(), calls); [EOL]         Assert.assertTrue(calls <= previousCalls); [EOL]         previousCalls = calls; [EOL]     } [EOL] } <line_num>: 113,150
@Test [EOL] public void testIntegratorControls() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblem3 pb = new TestProblem3(0.999); [EOL]     GraggBulirschStoerIntegrator integ = new GraggBulirschStoerIntegrator(0, pb.getFinalTime() - pb.getInitialTime(), 1.0e-8, 1.0e-10); [EOL]     double errorWithDefaultSettings = getMaxError(integ, pb); [EOL]     integ.setStabilityCheck(true, 2, 1, 0.99); [EOL]     Assert.assertTrue(errorWithDefaultSettings < getMaxError(integ, pb)); [EOL]     integ.setStabilityCheck(true, -1, -1, -1); [EOL]     integ.setControlFactors(0.5, 0.99, 0.1, 2.5); [EOL]     Assert.assertTrue(errorWithDefaultSettings < getMaxError(integ, pb)); [EOL]     integ.setControlFactors(-1, -1, -1, -1); [EOL]     integ.setOrderControl(10, 0.7, 0.95); [EOL]     Assert.assertTrue(errorWithDefaultSettings < getMaxError(integ, pb)); [EOL]     integ.setOrderControl(-1, -1, -1); [EOL]     integ.setInterpolationControl(true, 3); [EOL]     Assert.assertTrue(errorWithDefaultSettings < getMaxError(integ, pb)); [EOL]     integ.setInterpolationControl(true, -1); [EOL] } <line_num>: 152,181
private double getMaxError(FirstOrderIntegrator integrator, TestProblemAbstract pb) throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblemHandler handler = new TestProblemHandler(pb, integrator); [EOL]     integrator.addStepHandler(handler); [EOL]     integrator.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]     return handler.getMaximalValueError(); [EOL] } <line_num>: 183,192
@Test [EOL] public void testEvents() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     TestProblem4 pb = new TestProblem4(); [EOL]     double minStep = 0; [EOL]     double maxStep = pb.getFinalTime() - pb.getInitialTime(); [EOL]     double scalAbsoluteTolerance = 1.0e-10; [EOL]     double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; [EOL]     FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); [EOL]     TestProblemHandler handler = new TestProblemHandler(pb, integ); [EOL]     integ.addStepHandler(handler); [EOL]     EventHandler[] functions = pb.getEventsHandlers(); [EOL]     double convergence = 1.0e-8 * maxStep; [EOL]     for (int l = 0; l < functions.length; ++l) { [EOL]         integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, convergence, 1000); [EOL]     } [EOL]     Assert.assertEquals(functions.length, integ.getEventHandlers().size()); [EOL]     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]     Assert.assertTrue(handler.getMaximalValueError() < 4.0e-7); [EOL]     Assert.assertEquals(0, handler.getMaximalTimeError(), convergence); [EOL]     Assert.assertEquals(12.0, handler.getLastTime(), convergence); [EOL]     integ.clearEventHandlers(); [EOL]     Assert.assertEquals(0, integ.getEventHandlers().size()); [EOL] } <line_num>: 194,226
@Test [EOL] public void testKepler() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     final TestProblem3 pb = new TestProblem3(0.9); [EOL]     double minStep = 0; [EOL]     double maxStep = pb.getFinalTime() - pb.getInitialTime(); [EOL]     double absTolerance = 1.0e-6; [EOL]     double relTolerance = 1.0e-6; [EOL]     FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep, absTolerance, relTolerance); [EOL]     integ.addStepHandler(new KeplerStepHandler(pb)); [EOL]     integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]     Assert.assertEquals(integ.getEvaluations(), pb.getCalls()); [EOL]     Assert.assertTrue(pb.getCalls() < 2150); [EOL] } <line_num>: 228,250
@Test [EOL] public void testVariableSteps() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     final TestProblem3 pb = new TestProblem3(0.9); [EOL]     double minStep = 0; [EOL]     double maxStep = pb.getFinalTime() - pb.getInitialTime(); [EOL]     double absTolerance = 1.0e-8; [EOL]     double relTolerance = 1.0e-8; [EOL]     FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep, absTolerance, relTolerance); [EOL]     integ.addStepHandler(new VariableStepHandler()); [EOL]     double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); [EOL]     Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10); [EOL]     Assert.assertEquals("Gragg-Bulirsch-Stoer", integ.getName()); [EOL] } <line_num>: 252,271
public int getDimension() { [EOL]     return 1; [EOL] } <line_num>: 284,286
public void computeDerivatives(double t, double[] y, double[] yDot) { [EOL]     Assert.assertTrue(t >= FastMath.nextAfter(start, Double.NEGATIVE_INFINITY)); [EOL]     Assert.assertTrue(t <= FastMath.nextAfter(end, Double.POSITIVE_INFINITY)); [EOL]     yDot[0] = -100.0 * y[0]; [EOL] } <line_num>: 288,292
@Test [EOL] public void testTooLargeFirstStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     AdaptiveStepsizeIntegrator integ = new GraggBulirschStoerIntegrator(0, Double.POSITIVE_INFINITY, Double.NaN, Double.NaN); [EOL]     final double start = 0.0; [EOL]     final double end = 0.001; [EOL]     FirstOrderDifferentialEquations equations = new FirstOrderDifferentialEquations() { [EOL]  [EOL]         public int getDimension() { [EOL]             return 1; [EOL]         } [EOL]  [EOL]         public void computeDerivatives(double t, double[] y, double[] yDot) { [EOL]             Assert.assertTrue(t >= FastMath.nextAfter(start, Double.NEGATIVE_INFINITY)); [EOL]             Assert.assertTrue(t <= FastMath.nextAfter(end, Double.POSITIVE_INFINITY)); [EOL]             yDot[0] = -100.0 * y[0]; [EOL]         } [EOL]     }; [EOL]     integ.setStepSizeControl(0, 1.0, 1.0e-6, 1.0e-8); [EOL]     integ.integrate(equations, start, new double[] { 1.0 }, end, new double[1]); [EOL] } <line_num>: 273,299
@Test [EOL] public void testUnstableDerivative() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0); [EOL]     FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(0.1, 10, 1.0e-12, 0.0); [EOL]     integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000); [EOL]     double[] y = { Double.NaN }; [EOL]     integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y); [EOL]     Assert.assertEquals(8.0, y[0], 1.0e-12); [EOL] } <line_num>: 301,312
public void init(double t0, double[] y0, double t) { [EOL] } <line_num>: 321,322
public void handleStep(StepInterpolator interpolator, boolean isLast) throws MaxCountExceededException { [EOL]     double t = interpolator.getCurrentTime(); [EOL]     interpolator.setInterpolatedTime(t); [EOL]     double[] y = interpolator.getInterpolatedState(); [EOL]     double[] yDot = interpolator.getInterpolatedDerivatives(); [EOL]     Assert.assertEquals(3.0 * t - 5.0, y[0], 1.0e-14); [EOL]     Assert.assertEquals(3.0, yDot[0], 1.0e-14); [EOL] } <line_num>: 324,332
public int getDimension() { [EOL]     return 1; [EOL] } <line_num>: 338,340
public void computeDerivatives(double t, double[] y, double[] yDot) { [EOL]     yDot[0] = 3.0; [EOL] } <line_num>: 342,344
@Test [EOL] public void testIssue596() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { [EOL]     FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(1e-10, 100.0, 1e-7, 1e-7); [EOL]     integ.addStepHandler(new StepHandler() { [EOL]  [EOL]         public void init(double t0, double[] y0, double t) { [EOL]         } [EOL]  [EOL]         public void handleStep(StepInterpolator interpolator, boolean isLast) throws MaxCountExceededException { [EOL]             double t = interpolator.getCurrentTime(); [EOL]             interpolator.setInterpolatedTime(t); [EOL]             double[] y = interpolator.getInterpolatedState(); [EOL]             double[] yDot = interpolator.getInterpolatedDerivatives(); [EOL]             Assert.assertEquals(3.0 * t - 5.0, y[0], 1.0e-14); [EOL]             Assert.assertEquals(3.0, yDot[0], 1.0e-14); [EOL]         } [EOL]     }); [EOL]     double[] y = { 4.0 }; [EOL]     double t0 = 3.0; [EOL]     double tend = 10.0; [EOL]     integ.integrate(new FirstOrderDifferentialEquations() { [EOL]  [EOL]         public int getDimension() { [EOL]             return 1; [EOL]         } [EOL]  [EOL]         public void computeDerivatives(double t, double[] y, double[] yDot) { [EOL]             yDot[0] = 3.0; [EOL]         } [EOL]     }, t0, y, tend, y); [EOL] } <line_num>: 314,347
public void init(double t0, double[] y0, double t) { [EOL]     nbSteps = 0; [EOL]     maxError = 0; [EOL] } <line_num>: 353,356
public void handleStep(StepInterpolator interpolator, boolean isLast) throws MaxCountExceededException { [EOL]     ++nbSteps; [EOL]     for (int a = 1; a < 100; ++a) { [EOL]         double prev = interpolator.getPreviousTime(); [EOL]         double curr = interpolator.getCurrentTime(); [EOL]         double interp = ((100 - a) * prev + a * curr) / 100; [EOL]         interpolator.setInterpolatedTime(interp); [EOL]         double[] interpolatedY = interpolator.getInterpolatedState(); [EOL]         double[] theoreticalY = pb.computeTheoreticalState(interpolator.getInterpolatedTime()); [EOL]         double dx = interpolatedY[0] - theoreticalY[0]; [EOL]         double dy = interpolatedY[1] - theoreticalY[1]; [EOL]         double error = dx * dx + dy * dy; [EOL]         if (error > maxError) { [EOL]             maxError = error; [EOL]         } [EOL]     } [EOL]     if (isLast) { [EOL]         Assert.assertTrue(maxError < 2.7e-6); [EOL]         Assert.assertTrue(nbSteps < 80); [EOL]     } [EOL] } <line_num>: 357,381
public void init(double t0, double[] y0, double t) { [EOL]     firstTime = true; [EOL]     minStep = 0; [EOL]     maxStep = 0; [EOL] } <line_num>: 393,397
public void handleStep(StepInterpolator interpolator, boolean isLast) { [EOL]     double step = FastMath.abs(interpolator.getCurrentTime() - interpolator.getPreviousTime()); [EOL]     if (firstTime) { [EOL]         minStep = FastMath.abs(step); [EOL]         maxStep = minStep; [EOL]         firstTime = false; [EOL]     } else { [EOL]         if (step < minStep) { [EOL]             minStep = step; [EOL]         } [EOL]         if (step > maxStep) { [EOL]             maxStep = step; [EOL]         } [EOL]     } [EOL]     if (isLast) { [EOL]         Assert.assertTrue(minStep < 8.2e-3); [EOL]         Assert.assertTrue(maxStep > 1.5); [EOL]     } [EOL] } <line_num>: 398,420
