public Display() { [EOL]     setTitle("Commons-Math: Cluster algorithm comparison"); [EOL]     setSize(800, 800); [EOL]     setLayout(new GridBagLayout()); [EOL]     int nSamples = 1500; [EOL]     RandomGenerator rng = new Well19937c(0); [EOL]     List<List<DoublePoint>> datasets = new ArrayList<List<DoublePoint>>(); [EOL]     datasets.add(normalize(makeCircles(nSamples, true, 0.04, 0.5, rng), -1, 1, -1, 1)); [EOL]     datasets.add(normalize(makeMoons(nSamples, true, 0.04, rng), -1, 2, -1, 1)); [EOL]     datasets.add(normalize(makeBlobs(nSamples, 3, 1.0, -10, 10, true, rng), -12, 12, -12, 12)); [EOL]     datasets.add(normalize(makeRandom(nSamples), -1, 1, -1, 1)); [EOL]     List<Pair<String, Clusterer<DoublePoint>>> algorithms = new ArrayList<Pair<String, Clusterer<DoublePoint>>>(); [EOL]     algorithms.add(new Pair<String, Clusterer<DoublePoint>>("KMeans\n(k=2)", new KMeansPlusPlusClusterer<DoublePoint>(2))); [EOL]     algorithms.add(new Pair<String, Clusterer<DoublePoint>>("KMeans\n(k=3)", new KMeansPlusPlusClusterer<DoublePoint>(3))); [EOL]     algorithms.add(new Pair<String, Clusterer<DoublePoint>>("FuzzyKMeans\n(k=3, fuzzy=2)", new FuzzyKMeansClusterer<DoublePoint>(3, 2))); [EOL]     algorithms.add(new Pair<String, Clusterer<DoublePoint>>("FuzzyKMeans\n(k=3, fuzzy=10)", new FuzzyKMeansClusterer<DoublePoint>(3, 10))); [EOL]     algorithms.add(new Pair<String, Clusterer<DoublePoint>>("DBSCAN\n(eps=.1, min=3)", new DBSCANClusterer<DoublePoint>(0.1, 3))); [EOL]     GridBagConstraints c = new GridBagConstraints(); [EOL]     c.fill = GridBagConstraints.VERTICAL; [EOL]     c.gridx = 0; [EOL]     c.gridy = 0; [EOL]     c.insets = new Insets(2, 2, 2, 2); [EOL]     for (Pair<String, Clusterer<DoublePoint>> pair : algorithms) { [EOL]         JLabel text = new JLabel("<html><body>" + pair.getFirst().replace("\n", "<br>")); [EOL]         add(text, c); [EOL]         c.gridx++; [EOL]     } [EOL]     c.gridy++; [EOL]     for (List<DoublePoint> dataset : datasets) { [EOL]         c.gridx = 0; [EOL]         for (Pair<String, Clusterer<DoublePoint>> pair : algorithms) { [EOL]             long start = System.currentTimeMillis(); [EOL]             List<? extends Cluster<DoublePoint>> clusters = pair.getSecond().cluster(dataset); [EOL]             long end = System.currentTimeMillis(); [EOL]             add(new ClusterPlot(clusters, end - start), c); [EOL]             c.gridx++; [EOL]         } [EOL]         c.gridy++; [EOL]     } [EOL] } <line_num>: 185,233
public ClusterPlot(final List<? extends Cluster<DoublePoint>> clusters, long duration) { [EOL]     this.clusters = clusters; [EOL]     this.duration = duration; [EOL] } <line_num>: 245,248
public static List<Vector2D> makeCircles(int samples, boolean shuffle, double noise, double factor, final RandomGenerator random) { [EOL]     if (factor < 0 || factor > 1) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     NormalDistribution dist = new NormalDistribution(random, 0.0, noise, 1e-9); [EOL]     List<Vector2D> points = new ArrayList<Vector2D>(); [EOL]     double range = 2.0 * FastMath.PI; [EOL]     double step = range / (samples / 2.0 + 1); [EOL]     for (double angle = 0; angle < range; angle += step) { [EOL]         Vector2D outerCircle = new Vector2D(FastMath.cos(angle), FastMath.sin(angle)); [EOL]         Vector2D innerCircle = outerCircle.scalarMultiply(factor); [EOL]         points.add(outerCircle.add(generateNoiseVector(dist))); [EOL]         points.add(innerCircle.add(generateNoiseVector(dist))); [EOL]     } [EOL]     if (shuffle) { [EOL]         Collections.shuffle(points, new RandomAdaptor(random)); [EOL]     } [EOL]     return points; [EOL] } <line_num>: 62,85
public static List<Vector2D> makeMoons(int samples, boolean shuffle, double noise, RandomGenerator random) { [EOL]     NormalDistribution dist = new NormalDistribution(random, 0.0, noise, 1e-9); [EOL]     int nSamplesOut = samples / 2; [EOL]     int nSamplesIn = samples - nSamplesOut; [EOL]     List<Vector2D> points = new ArrayList<Vector2D>(); [EOL]     double range = FastMath.PI; [EOL]     double step = range / (nSamplesOut / 2.0); [EOL]     for (double angle = 0; angle < range; angle += step) { [EOL]         Vector2D outerCircle = new Vector2D(FastMath.cos(angle), FastMath.sin(angle)); [EOL]         points.add(outerCircle.add(generateNoiseVector(dist))); [EOL]     } [EOL]     step = range / (nSamplesIn / 2.0); [EOL]     for (double angle = 0; angle < range; angle += step) { [EOL]         Vector2D innerCircle = new Vector2D(1 - FastMath.cos(angle), 1 - FastMath.sin(angle) - 0.5); [EOL]         points.add(innerCircle.add(generateNoiseVector(dist))); [EOL]     } [EOL]     if (shuffle) { [EOL]         Collections.shuffle(points, new RandomAdaptor(random)); [EOL]     } [EOL]     return points; [EOL] } <line_num>: 87,112
public static List<Vector2D> makeBlobs(int samples, int centers, double clusterStd, double min, double max, boolean shuffle, RandomGenerator random) { [EOL]     NormalDistribution dist = new NormalDistribution(random, 0.0, clusterStd, 1e-9); [EOL]     double range = max - min; [EOL]     Vector2D[] centerPoints = new Vector2D[centers]; [EOL]     for (int i = 0; i < centers; i++) { [EOL]         double x = random.nextDouble() * range + min; [EOL]         double y = random.nextDouble() * range + min; [EOL]         centerPoints[i] = new Vector2D(x, y); [EOL]     } [EOL]     int[] nSamplesPerCenter = new int[centers]; [EOL]     int count = samples / centers; [EOL]     Arrays.fill(nSamplesPerCenter, count); [EOL]     for (int i = 0; i < samples % centers; i++) { [EOL]         nSamplesPerCenter[i]++; [EOL]     } [EOL]     List<Vector2D> points = new ArrayList<Vector2D>(); [EOL]     for (int i = 0; i < centers; i++) { [EOL]         for (int j = 0; j < nSamplesPerCenter[i]; j++) { [EOL]             Vector2D point = new Vector2D(dist.sample(), dist.sample()); [EOL]             points.add(point.add(centerPoints[i])); [EOL]         } [EOL]     } [EOL]     if (shuffle) { [EOL]         Collections.shuffle(points, new RandomAdaptor(random)); [EOL]     } [EOL]     return points; [EOL] } <line_num>: 114,148
public static List<Vector2D> makeRandom(int samples) { [EOL]     SobolSequenceGenerator generator = new SobolSequenceGenerator(2); [EOL]     generator.skipTo(999999); [EOL]     List<Vector2D> points = new ArrayList<Vector2D>(); [EOL]     for (double i = 0; i < samples; i++) { [EOL]         double[] vector = generator.nextVector(); [EOL]         vector[0] = vector[0] * 2 - 1; [EOL]         vector[1] = vector[1] * 2 - 1; [EOL]         Vector2D point = new Vector2D(vector); [EOL]         points.add(point); [EOL]     } [EOL]     return points; [EOL] } <line_num>: 150,163
public static Vector2D generateNoiseVector(NormalDistribution distribution) { [EOL]     return new Vector2D(distribution.sample(), distribution.sample()); [EOL] } <line_num>: 165,167
public static List<DoublePoint> normalize(final List<Vector2D> input, double minX, double maxX, double minY, double maxY) { [EOL]     double rangeX = maxX - minX; [EOL]     double rangeY = maxY - minY; [EOL]     List<DoublePoint> points = new ArrayList<DoublePoint>(); [EOL]     for (Vector2D p : input) { [EOL]         double[] arr = p.toArray(); [EOL]         arr[0] = (arr[0] - minX) / rangeX * 2 - 1; [EOL]         arr[1] = (arr[1] - minY) / rangeY * 2 - 1; [EOL]         points.add(new DoublePoint(arr)); [EOL]     } [EOL]     return points; [EOL] } <line_num>: 169,180
@Override [EOL] protected void paintComponent(Graphics g) { [EOL]     super.paintComponent(g); [EOL]     Graphics2D g2 = (Graphics2D) g; [EOL]     g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); [EOL]     int w = getWidth(); [EOL]     int h = getHeight(); [EOL]     g2.clearRect(0, 0, w, h); [EOL]     g2.setPaint(Color.black); [EOL]     g2.drawRect(0, 0, w - 1, h - 1); [EOL]     int index = 0; [EOL]     Color[] colors = new Color[] { Color.red, Color.blue, Color.green.darker() }; [EOL]     for (Cluster<DoublePoint> cluster : clusters) { [EOL]         g2.setPaint(colors[index++]); [EOL]         for (DoublePoint point : cluster.getPoints()) { [EOL]             Clusterable p = transform(point, w, h); [EOL]             double[] arr = p.getPoint(); [EOL]             g2.fill(new Ellipse2D.Double(arr[0] - 1, arr[1] - 1, 3, 3)); [EOL]         } [EOL]         if (cluster instanceof CentroidCluster) { [EOL]             Clusterable p = transform(((CentroidCluster<?>) cluster).getCenter(), w, h); [EOL]             double[] arr = p.getPoint(); [EOL]             Shape s = new Ellipse2D.Double(arr[0] - 4, arr[1] - 4, 8, 8); [EOL]             g2.fill(s); [EOL]             g2.setPaint(Color.black); [EOL]             g2.draw(s); [EOL]         } [EOL]     } [EOL]     g2.setPaint(Color.black); [EOL]     g2.drawString(String.format("%.2f s", duration / 1e3), w - 40, h - 5); [EOL] } <line_num>: 250,287
@Override [EOL] public Dimension getPreferredSize() { [EOL]     return new Dimension(150, 150); [EOL] } <line_num>: 289,292
private Clusterable transform(Clusterable point, int width, int height) { [EOL]     double[] arr = point.getPoint(); [EOL]     return new DoublePoint(new double[] { PAD + (arr[0] + 1) / 2.0 * (width - 2 * PAD), height - PAD - (arr[1] + 1) / 2.0 * (height - 2 * PAD) }); [EOL] } <line_num>: 294,298
public static void main(String[] args) { [EOL]     ExampleUtils.showExampleFrame(new Display()); [EOL] } <line_num>: 301,303
