Cigar() { [EOL]     this(1e3); [EOL] } <line_num>: 542,544
Cigar(double axisratio) { [EOL]     factor = axisratio * axisratio; [EOL] } <line_num>: 546,548
Tablet() { [EOL]     this(1e3); [EOL] } <line_num>: 561,563
Tablet(double axisratio) { [EOL]     factor = axisratio * axisratio; [EOL] } <line_num>: 565,567
CigTab() { [EOL]     this(1e4); [EOL] } <line_num>: 580,582
CigTab(double axisratio) { [EOL]     factor = axisratio; [EOL] } <line_num>: 584,586
TwoAxes() { [EOL]     this(1e6); [EOL] } <line_num>: 601,603
TwoAxes(double axisratio) { [EOL]     factor = axisratio * axisratio; [EOL] } <line_num>: 605,607
ElliRotated() { [EOL]     this(1e3); [EOL] } <line_num>: 621,623
ElliRotated(double axisratio) { [EOL]     factor = axisratio * axisratio; [EOL] } <line_num>: 625,627
Elli() { [EOL]     this(1e3); [EOL] } <line_num>: 642,644
Elli(double axisratio) { [EOL]     factor = axisratio * axisratio; [EOL] } <line_num>: 646,648
Ackley(double axra) { [EOL]     axisratio = axra; [EOL] } <line_num>: 698,700
public Ackley() { [EOL]     this(1); [EOL] } <line_num>: 702,704
Rastrigin() { [EOL]     this(1, 10); [EOL] } <line_num>: 726,728
Rastrigin(double axisratio, double amplitude) { [EOL]     this.axisratio = axisratio; [EOL]     this.amplitude = amplitude; [EOL] } <line_num>: 730,733
@Test(expected = NumberIsTooLargeException.class) [EOL] public void testInitOutofbounds1() { [EOL]     double[] startPoint = point(DIM, 3); [EOL]     double[] insigma = point(DIM, 0.3); [EOL]     double[][] boundaries = boundaries(DIM, -1, 2); [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 1.0), 0.0); [EOL]     doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL] } <line_num>: 49,59
@Test(expected = NumberIsTooSmallException.class) [EOL] public void testInitOutofbounds2() { [EOL]     double[] startPoint = point(DIM, -2); [EOL]     double[] insigma = point(DIM, 0.3); [EOL]     double[][] boundaries = boundaries(DIM, -1, 2); [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 1.0), 0.0); [EOL]     doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL] } <line_num>: 60,70
@Test(expected = DimensionMismatchException.class) [EOL] public void testBoundariesDimensionMismatch() { [EOL]     double[] startPoint = point(DIM, 0.5); [EOL]     double[] insigma = point(DIM, 0.3); [EOL]     double[][] boundaries = boundaries(DIM + 1, -1, 2); [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 1.0), 0.0); [EOL]     doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL] } <line_num>: 72,82
@Test(expected = NotPositiveException.class) [EOL] public void testInputSigmaNegative() { [EOL]     double[] startPoint = point(DIM, 0.5); [EOL]     double[] insigma = point(DIM, -0.5); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 1.0), 0.0); [EOL]     doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL] } <line_num>: 84,94
@Test(expected = OutOfRangeException.class) [EOL] public void testInputSigmaOutOfRange() { [EOL]     double[] startPoint = point(DIM, 0.5); [EOL]     double[] insigma = point(DIM, 1.1); [EOL]     double[][] boundaries = boundaries(DIM, -0.5, 0.5); [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 1.0), 0.0); [EOL]     doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL] } <line_num>: 96,106
@Test(expected = DimensionMismatchException.class) [EOL] public void testInputSigmaDimensionMismatch() { [EOL]     double[] startPoint = point(DIM, 0.5); [EOL]     double[] insigma = point(DIM + 1, 0.5); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 1.0), 0.0); [EOL]     doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL] } <line_num>: 108,118
@Test [EOL] @Retry(3) [EOL] public void testRosen() { [EOL]     double[] startPoint = point(DIM, 0.1); [EOL]     double[] insigma = point(DIM, 0.1); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 1.0), 0.0); [EOL]     doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL]     doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL] } <line_num>: 120,134
@Test [EOL] @Retry(3) [EOL] public void testMaximize() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[] insigma = point(DIM, 0.1); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 1.0); [EOL]     doTest(new MinusElli(), startPoint, insigma, boundaries, GoalType.MAXIMIZE, LAMBDA, true, 0, 1.0 - 1e-13, 2e-10, 5e-6, 100000, expected); [EOL]     doTest(new MinusElli(), startPoint, insigma, boundaries, GoalType.MAXIMIZE, LAMBDA, false, 0, 1.0 - 1e-13, 2e-10, 5e-6, 100000, expected); [EOL]     boundaries = boundaries(DIM, -0.3, 0.3); [EOL]     startPoint = point(DIM, 0.1); [EOL]     doTest(new MinusElli(), startPoint, insigma, boundaries, GoalType.MAXIMIZE, LAMBDA, true, 0, 1.0 - 1e-13, 2e-10, 5e-6, 100000, expected); [EOL] } <line_num>: 136,155
@Test [EOL] public void testEllipse() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[] insigma = point(DIM, 0.1); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new Elli(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL]     doTest(new Elli(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL] } <line_num>: 157,170
@Test [EOL] public void testElliRotated() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[] insigma = point(DIM, 0.1); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new ElliRotated(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL]     doTest(new ElliRotated(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL] } <line_num>: 172,185
@Test [EOL] public void testCigar() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[] insigma = point(DIM, 0.1); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new Cigar(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 200000, expected); [EOL]     doTest(new Cigar(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL] } <line_num>: 187,200
@Test [EOL] public void testCigarWithBoundaries() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[] insigma = point(DIM, 0.1); [EOL]     double[][] boundaries = boundaries(DIM, -1e100, Double.POSITIVE_INFINITY); [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new Cigar(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 200000, expected); [EOL]     doTest(new Cigar(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL] } <line_num>: 202,215
@Test [EOL] public void testTwoAxes() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[] insigma = point(DIM, 0.1); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new TwoAxes(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 2 * LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 200000, expected); [EOL]     doTest(new TwoAxes(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 2 * LAMBDA, false, 0, 1e-13, 1e-8, 1e-3, 200000, expected); [EOL] } <line_num>: 217,230
@Test [EOL] public void testCigTab() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[] insigma = point(DIM, 0.3); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new CigTab(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 5e-5, 100000, expected); [EOL]     doTest(new CigTab(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13, 1e-13, 5e-5, 100000, expected); [EOL] } <line_num>: 232,245
@Test [EOL] public void testSphere() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[] insigma = point(DIM, 0.1); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new Sphere(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL]     doTest(new Sphere(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL] } <line_num>: 247,260
@Test [EOL] public void testTablet() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[] insigma = point(DIM, 0.1); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new Tablet(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL]     doTest(new Tablet(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL] } <line_num>: 262,275
@Test [EOL] public void testDiffPow() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[] insigma = point(DIM, 0.1); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new DiffPow(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 10, true, 0, 1e-13, 1e-8, 1e-1, 100000, expected); [EOL]     doTest(new DiffPow(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 10, false, 0, 1e-13, 1e-8, 2e-1, 100000, expected); [EOL] } <line_num>: 277,290
@Test [EOL] public void testSsDiffPow() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[] insigma = point(DIM, 0.1); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new SsDiffPow(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 10, true, 0, 1e-13, 1e-4, 1e-1, 200000, expected); [EOL]     doTest(new SsDiffPow(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 10, false, 0, 1e-13, 1e-4, 1e-1, 200000, expected); [EOL] } <line_num>: 292,305
@Test [EOL] public void testAckley() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[] insigma = point(DIM, 1.0); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new Ackley(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 2 * LAMBDA, true, 0, 1e-13, 1e-9, 1e-5, 100000, expected); [EOL]     doTest(new Ackley(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 2 * LAMBDA, false, 0, 1e-13, 1e-9, 1e-5, 100000, expected); [EOL] } <line_num>: 307,320
@Test [EOL] public void testRastrigin() { [EOL]     double[] startPoint = point(DIM, 0.1); [EOL]     double[] insigma = point(DIM, 0.1); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new Rastrigin(), startPoint, insigma, boundaries, GoalType.MINIMIZE, (int) (200 * Math.sqrt(DIM)), true, 0, 1e-13, 1e-13, 1e-6, 200000, expected); [EOL]     doTest(new Rastrigin(), startPoint, insigma, boundaries, GoalType.MINIMIZE, (int) (200 * Math.sqrt(DIM)), false, 0, 1e-13, 1e-13, 1e-6, 200000, expected); [EOL] } <line_num>: 322,335
@Test [EOL] public void testConstrainedRosen() { [EOL]     double[] startPoint = point(DIM, 0.1); [EOL]     double[] insigma = point(DIM, 0.1); [EOL]     double[][] boundaries = boundaries(DIM, -1, 2); [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 1.0), 0.0); [EOL]     doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 2 * LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL]     doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 2 * LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); [EOL] } <line_num>: 337,350
@Test [EOL] public void testDiagonalRosen() { [EOL]     double[] startPoint = point(DIM, 0.1); [EOL]     double[] insigma = point(DIM, 0.1); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 1.0), 0.0); [EOL]     doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 1, 1e-13, 1e-10, 1e-4, 1000000, expected); [EOL] } <line_num>: 352,362
public double value(double[] parameters) { [EOL]     final double target = 1; [EOL]     final double error = target - parameters[0]; [EOL]     return error * error; [EOL] } <line_num>: 370,374
@Test [EOL] public void testMath864() { [EOL]     final CMAESOptimizer optimizer = new CMAESOptimizer(30000, 0, true, 10, 0, new MersenneTwister(), false, null); [EOL]     final MultivariateFunction fitnessFunction = new MultivariateFunction() { [EOL]  [EOL]         public double value(double[] parameters) { [EOL]             final double target = 1; [EOL]             final double error = target - parameters[0]; [EOL]             return error * error; [EOL]         } [EOL]     }; [EOL]     final double[] start = { 0 }; [EOL]     final double[] lower = { -1e6 }; [EOL]     final double[] upper = { 1.5 }; [EOL]     final double[] sigma = { 1e-1 }; [EOL]     final double[] result = optimizer.optimize(new MaxEval(10000), new ObjectiveFunction(fitnessFunction), GoalType.MINIMIZE, new CMAESOptimizer.PopulationSize(5), new CMAESOptimizer.Sigma(sigma), new InitialGuess(start), new SimpleBounds(lower, upper)).getPoint(); [EOL]     Assert.assertTrue("Out of bounds (" + result[0] + " > " + upper[0] + ")", result[0] <= upper[0]); [EOL] } <line_num>: 364,390
public double value(double[] parameters) { [EOL]     final double target = 11.1; [EOL]     final double error = target - parameters[0]; [EOL]     return error * error; [EOL] } <line_num>: 401,405
@Test [EOL] public void testFitAccuracyDependsOnBoundary() { [EOL]     final CMAESOptimizer optimizer = new CMAESOptimizer(30000, 0, true, 10, 0, new MersenneTwister(), false, null); [EOL]     final MultivariateFunction fitnessFunction = new MultivariateFunction() { [EOL]  [EOL]         public double value(double[] parameters) { [EOL]             final double target = 11.1; [EOL]             final double error = target - parameters[0]; [EOL]             return error * error; [EOL]         } [EOL]     }; [EOL]     final double[] start = { 1 }; [EOL]     PointValuePair result = optimizer.optimize(new MaxEval(100000), new ObjectiveFunction(fitnessFunction), GoalType.MINIMIZE, SimpleBounds.unbounded(1), new CMAESOptimizer.PopulationSize(5), new CMAESOptimizer.Sigma(new double[] { 1e-1 }), new InitialGuess(start)); [EOL]     final double resNoBound = result.getPoint()[0]; [EOL]     final double[] lower = { -20 }; [EOL]     final double[] upper = { 5e16 }; [EOL]     final double[] sigma = { 10 }; [EOL]     result = optimizer.optimize(new MaxEval(100000), new ObjectiveFunction(fitnessFunction), GoalType.MINIMIZE, new CMAESOptimizer.PopulationSize(5), new CMAESOptimizer.Sigma(sigma), new InitialGuess(start), new SimpleBounds(lower, upper)); [EOL]     final double resNearLo = result.getPoint()[0]; [EOL]     lower[0] = -5e16; [EOL]     upper[0] = 20; [EOL]     result = optimizer.optimize(new MaxEval(100000), new ObjectiveFunction(fitnessFunction), GoalType.MINIMIZE, new CMAESOptimizer.PopulationSize(5), new CMAESOptimizer.Sigma(sigma), new InitialGuess(start), new SimpleBounds(lower, upper)); [EOL]     final double resNearHi = result.getPoint()[0]; [EOL]     Assert.assertEquals(resNoBound, resNearLo, 1e-3); [EOL]     Assert.assertEquals(resNoBound, resNearHi, 1e-3); [EOL] } <line_num>: 395,453
private void doTest(MultivariateFunction func, double[] startPoint, double[] inSigma, double[][] boundaries, GoalType goal, int lambda, boolean isActive, int diagonalOnly, double stopValue, double fTol, double pointTol, int maxEvaluations, PointValuePair expected) { [EOL]     int dim = startPoint.length; [EOL]     CMAESOptimizer optim = new CMAESOptimizer(30000, stopValue, isActive, diagonalOnly, 0, new MersenneTwister(), false, null); [EOL]     PointValuePair result = boundaries == null ? optim.optimize(new MaxEval(maxEvaluations), new ObjectiveFunction(func), goal, new InitialGuess(startPoint), SimpleBounds.unbounded(dim), new CMAESOptimizer.Sigma(inSigma), new CMAESOptimizer.PopulationSize(lambda)) : optim.optimize(new MaxEval(maxEvaluations), new ObjectiveFunction(func), goal, new SimpleBounds(boundaries[0], boundaries[1]), new InitialGuess(startPoint), new CMAESOptimizer.Sigma(inSigma), new CMAESOptimizer.PopulationSize(lambda)); [EOL]     Assert.assertEquals(expected.getValue(), result.getValue(), fTol); [EOL]     for (int i = 0; i < dim; i++) { [EOL]         Assert.assertEquals(expected.getPoint()[i], result.getPoint()[i], pointTol); [EOL]     } [EOL]     Assert.assertTrue(optim.getIterations() > 0); [EOL] } <line_num>: 470,511
private static double[] point(int n, double value) { [EOL]     double[] ds = new double[n]; [EOL]     Arrays.fill(ds, value); [EOL]     return ds; [EOL] } <line_num>: 513,517
private static double[][] boundaries(int dim, double lower, double upper) { [EOL]     double[][] boundaries = new double[2][dim]; [EOL]     for (int i = 0; i < dim; i++) boundaries[0][i] = lower; [EOL]     for (int i = 0; i < dim; i++) boundaries[1][i] = upper; [EOL]     return boundaries; [EOL] } <line_num>: 519,527
public double value(double[] x) { [EOL]     double f = 0; [EOL]     for (int i = 0; i < x.length; ++i) f += x[i] * x[i]; [EOL]     return f; [EOL] } <line_num>: 531,536
public double value(double[] x) { [EOL]     double f = x[0] * x[0]; [EOL]     for (int i = 1; i < x.length; ++i) f += factor * x[i] * x[i]; [EOL]     return f; [EOL] } <line_num>: 550,555
public double value(double[] x) { [EOL]     double f = factor * x[0] * x[0]; [EOL]     for (int i = 1; i < x.length; ++i) f += x[i] * x[i]; [EOL]     return f; [EOL] } <line_num>: 569,574
public double value(double[] x) { [EOL]     int end = x.length - 1; [EOL]     double f = x[0] * x[0] / factor + factor * x[end] * x[end]; [EOL]     for (int i = 1; i < end; ++i) f += x[i] * x[i]; [EOL]     return f; [EOL] } <line_num>: 588,594
public double value(double[] x) { [EOL]     double f = 0; [EOL]     for (int i = 0; i < x.length; ++i) f += (i < x.length / 2 ? factor : 1) * x[i] * x[i]; [EOL]     return f; [EOL] } <line_num>: 609,614
public double value(double[] x) { [EOL]     double f = 0; [EOL]     x = B.Rotate(x); [EOL]     for (int i = 0; i < x.length; ++i) f += Math.pow(factor, i / (x.length - 1.)) * x[i] * x[i]; [EOL]     return f; [EOL] } <line_num>: 629,635
public double value(double[] x) { [EOL]     double f = 0; [EOL]     for (int i = 0; i < x.length; ++i) f += Math.pow(factor, i / (x.length - 1.)) * x[i] * x[i]; [EOL]     return f; [EOL] } <line_num>: 650,655
public double value(double[] x) { [EOL]     return 1.0 - (new Elli().value(x)); [EOL] } <line_num>: 660,662
public double value(double[] x) { [EOL]     double f = 0; [EOL]     for (int i = 0; i < x.length; ++i) f += Math.pow(Math.abs(x[i]), 2. + 10 * (double) i / (x.length - 1.)); [EOL]     return f; [EOL] } <line_num>: 667,673
public double value(double[] x) { [EOL]     double f = Math.pow(new DiffPow().value(x), 0.25); [EOL]     return f; [EOL] } <line_num>: 678,681
public double value(double[] x) { [EOL]     double f = 0; [EOL]     for (int i = 0; i < x.length - 1; ++i) f += 1e2 * (x[i] * x[i] - x[i + 1]) * (x[i] * x[i] - x[i + 1]) + (x[i] - 1.) * (x[i] - 1.); [EOL]     return f; [EOL] } <line_num>: 686,692
public double value(double[] x) { [EOL]     double f = 0; [EOL]     double res2 = 0; [EOL]     double fac = 0; [EOL]     for (int i = 0; i < x.length; ++i) { [EOL]         fac = Math.pow(axisratio, (i - 1.) / (x.length - 1.)); [EOL]         f += fac * fac * x[i] * x[i]; [EOL]         res2 += Math.cos(2. * Math.PI * fac * x[i]); [EOL]     } [EOL]     f = (20. - 20. * Math.exp(-0.2 * Math.sqrt(f / x.length)) + Math.exp(1.) - Math.exp(res2 / x.length)); [EOL]     return f; [EOL] } <line_num>: 706,718
public double value(double[] x) { [EOL]     double f = 0; [EOL]     double fac; [EOL]     for (int i = 0; i < x.length; ++i) { [EOL]         fac = Math.pow(axisratio, (i - 1.) / (x.length - 1.)); [EOL]         if (i == 0 && x[i] < 0) [EOL]             fac *= 1.; [EOL]         f += fac * fac * x[i] * x[i] + amplitude * (1. - Math.cos(2. * Math.PI * fac * x[i])); [EOL]     } [EOL]     return f; [EOL] } <line_num>: 735,746
double[] Rotate(double[] x) { [EOL]     GenBasis(x.length); [EOL]     double[] y = new double[x.length]; [EOL]     for (int i = 0; i < x.length; ++i) { [EOL]         y[i] = 0; [EOL]         for (int j = 0; j < x.length; ++j) y[i] += basis[i][j] * x[j]; [EOL]     } [EOL]     return y; [EOL] } <line_num>: 753,762
void GenBasis(int DIM) { [EOL]     if (basis != null ? basis.length == DIM : false) [EOL]         return; [EOL]     double sp; [EOL]     int i, j, k; [EOL]     basis = new double[DIM][DIM]; [EOL]     for (i = 0; i < DIM; ++i) { [EOL]         for (j = 0; j < DIM; ++j) basis[i][j] = rand.nextGaussian(); [EOL]         for (j = i - 1; j >= 0; --j) { [EOL]             for (sp = 0., k = 0; k < DIM; ++k) sp += basis[i][k] * basis[j][k]; [EOL]             for (k = 0; k < DIM; ++k) basis[i][k] -= sp * basis[j][k]; [EOL]         } [EOL]         for (sp = 0., k = 0; k < DIM; ++k) sp += basis[i][k] * basis[i][k]; [EOL]         for (k = 0; k < DIM; ++k) basis[i][k] /= Math.sqrt(sp); [EOL]     } [EOL] } <line_num>: 764,790
