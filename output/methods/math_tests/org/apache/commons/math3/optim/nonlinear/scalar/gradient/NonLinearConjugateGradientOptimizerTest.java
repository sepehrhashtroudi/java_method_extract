public LinearProblem(double[][] factors, double[] target) { [EOL]     this.factors = new BlockRealMatrix(factors); [EOL]     this.target = target; [EOL] } <line_num>: 425,429
@Test(expected = MathUnsupportedOperationException.class) [EOL] public void testBoundsUnsupported() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 2 } }, new double[] { 3 }); [EOL]     NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); [EOL]     optimizer.optimize(new MaxEval(100), problem.getObjectiveFunction(), problem.getObjectiveFunctionGradient(), GoalType.MINIMIZE, new InitialGuess(new double[] { 0 }), new SimpleBounds(new double[] { -1 }, new double[] { 1 })); [EOL] } <line_num>: 101,115
@Test [EOL] public void testTrivial() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 2 } }, new double[] { 3 }); [EOL]     NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); [EOL]     PointValuePair optimum = optimizer.optimize(new MaxEval(100), problem.getObjectiveFunction(), problem.getObjectiveFunctionGradient(), GoalType.MINIMIZE, new InitialGuess(new double[] { 0 })); [EOL]     Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10); [EOL]     Assert.assertEquals(0.0, optimum.getValue(), 1.0e-10); [EOL]     Assert.assertTrue(optimizer.getIterations() > 0); [EOL] } <line_num>: 117,135
@Test [EOL] public void testColumnsPermutation() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } }, new double[] { 4.0, 6.0, 1.0 }); [EOL]     NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); [EOL]     PointValuePair optimum = optimizer.optimize(new MaxEval(100), problem.getObjectiveFunction(), problem.getObjectiveFunctionGradient(), GoalType.MINIMIZE, new InitialGuess(new double[] { 0, 0 })); [EOL]     Assert.assertEquals(7.0, optimum.getPoint()[0], 1.0e-10); [EOL]     Assert.assertEquals(3.0, optimum.getPoint()[1], 1.0e-10); [EOL]     Assert.assertEquals(0.0, optimum.getValue(), 1.0e-10); [EOL] } <line_num>: 137,156
@Test [EOL] public void testNoDependency() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 2, 0, 0, 0, 0, 0 }, { 0, 2, 0, 0, 0, 0 }, { 0, 0, 2, 0, 0, 0 }, { 0, 0, 0, 2, 0, 0 }, { 0, 0, 0, 0, 2, 0 }, { 0, 0, 0, 0, 0, 2 } }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 }); [EOL]     NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); [EOL]     PointValuePair optimum = optimizer.optimize(new MaxEval(100), problem.getObjectiveFunction(), problem.getObjectiveFunctionGradient(), GoalType.MINIMIZE, new InitialGuess(new double[] { 0, 0, 0, 0, 0, 0 })); [EOL]     for (int i = 0; i < problem.target.length; ++i) { [EOL]         Assert.assertEquals(0.55 * i, optimum.getPoint()[i], 1.0e-10); [EOL]     } [EOL] } <line_num>: 158,180
@Test [EOL] public void testOneSet() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 1, 0, 0 }, { -1, 1, 0 }, { 0, -1, 1 } }, new double[] { 1, 1, 1 }); [EOL]     NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); [EOL]     PointValuePair optimum = optimizer.optimize(new MaxEval(100), problem.getObjectiveFunction(), problem.getObjectiveFunctionGradient(), GoalType.MINIMIZE, new InitialGuess(new double[] { 0, 0, 0 })); [EOL]     Assert.assertEquals(1.0, optimum.getPoint()[0], 1.0e-10); [EOL]     Assert.assertEquals(2.0, optimum.getPoint()[1], 1.0e-10); [EOL]     Assert.assertEquals(3.0, optimum.getPoint()[2], 1.0e-10); [EOL] } <line_num>: 182,202
public double[] precondition(double[] point, double[] r) { [EOL]     double[] d = r.clone(); [EOL]     d[0] /= 72.0; [EOL]     d[1] /= 30.0; [EOL]     d[2] /= 314.0; [EOL]     d[3] /= 260.0; [EOL]     d[4] /= 2 * (1 + epsilon * epsilon); [EOL]     d[5] /= 4.0; [EOL]     return d; [EOL] } <line_num>: 218,227
@Test [EOL] public void testTwoSets() { [EOL]     final double epsilon = 1.0e-7; [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 2, 1, 0, 4, 0, 0 }, { -4, -2, 3, -7, 0, 0 }, { 4, 1, -2, 8, 0, 0 }, { 0, -3, -12, -1, 0, 0 }, { 0, 0, 0, 0, epsilon, 1 }, { 0, 0, 0, 0, 1, 1 } }, new double[] { 2, -9, 2, 2, 1 + epsilon * epsilon, 2 }); [EOL]     final Preconditioner preconditioner = new Preconditioner() { [EOL]  [EOL]         public double[] precondition(double[] point, double[] r) { [EOL]             double[] d = r.clone(); [EOL]             d[0] /= 72.0; [EOL]             d[1] /= 30.0; [EOL]             d[2] /= 314.0; [EOL]             d[3] /= 260.0; [EOL]             d[4] /= 2 * (1 + epsilon * epsilon); [EOL]             d[5] /= 4.0; [EOL]             return d; [EOL]         } [EOL]     }; [EOL]     NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE, new SimpleValueChecker(1e-13, 1e-13), new BrentSolver(), preconditioner); [EOL]     PointValuePair optimum = optimizer.optimize(new MaxEval(100), problem.getObjectiveFunction(), problem.getObjectiveFunctionGradient(), GoalType.MINIMIZE, new InitialGuess(new double[] { 0, 0, 0, 0, 0, 0 })); [EOL]     Assert.assertEquals(3.0, optimum.getPoint()[0], 1.0e-10); [EOL]     Assert.assertEquals(4.0, optimum.getPoint()[1], 1.0e-10); [EOL]     Assert.assertEquals(-1.0, optimum.getPoint()[2], 1.0e-10); [EOL]     Assert.assertEquals(-2.0, optimum.getPoint()[3], 1.0e-10); [EOL]     Assert.assertEquals(1.0 + epsilon, optimum.getPoint()[4], 1.0e-10); [EOL]     Assert.assertEquals(1.0 - epsilon, optimum.getPoint()[5], 1.0e-10); [EOL] } <line_num>: 204,249
@Test [EOL] public void testNonInversible() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 1, 2, -3 }, { 2, 1, 3 }, { -3, 0, -9 } }, new double[] { 1, 1, 1 }); [EOL]     NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); [EOL]     PointValuePair optimum = optimizer.optimize(new MaxEval(100), problem.getObjectiveFunction(), problem.getObjectiveFunctionGradient(), GoalType.MINIMIZE, new InitialGuess(new double[] { 0, 0, 0 })); [EOL]     Assert.assertTrue(optimum.getValue() > 0.5); [EOL] } <line_num>: 251,268
@Test [EOL] public void testIllConditioned() { [EOL]     LinearProblem problem1 = new LinearProblem(new double[][] { { 10.0, 7.0, 8.0, 7.0 }, { 7.0, 5.0, 6.0, 5.0 }, { 8.0, 6.0, 10.0, 9.0 }, { 7.0, 5.0, 9.0, 10.0 } }, new double[] { 32, 23, 33, 31 }); [EOL]     NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE, new SimpleValueChecker(1e-13, 1e-13), new BrentSolver(1e-15, 1e-15)); [EOL]     PointValuePair optimum1 = optimizer.optimize(new MaxEval(200), problem1.getObjectiveFunction(), problem1.getObjectiveFunctionGradient(), GoalType.MINIMIZE, new InitialGuess(new double[] { 0, 1, 2, 3 })); [EOL]     Assert.assertEquals(1.0, optimum1.getPoint()[0], 1.0e-4); [EOL]     Assert.assertEquals(1.0, optimum1.getPoint()[1], 1.0e-4); [EOL]     Assert.assertEquals(1.0, optimum1.getPoint()[2], 1.0e-4); [EOL]     Assert.assertEquals(1.0, optimum1.getPoint()[3], 1.0e-4); [EOL]     LinearProblem problem2 = new LinearProblem(new double[][] { { 10.00, 7.00, 8.10, 7.20 }, { 7.08, 5.04, 6.00, 5.00 }, { 8.00, 5.98, 9.89, 9.00 }, { 6.99, 4.99, 9.00, 9.98 } }, new double[] { 32, 23, 33, 31 }); [EOL]     PointValuePair optimum2 = optimizer.optimize(new MaxEval(200), problem2.getObjectiveFunction(), problem2.getObjectiveFunctionGradient(), GoalType.MINIMIZE, new InitialGuess(new double[] { 0, 1, 2, 3 })); [EOL]     Assert.assertEquals(-81.0, optimum2.getPoint()[0], 1.0e-1); [EOL]     Assert.assertEquals(137.0, optimum2.getPoint()[1], 1.0e-1); [EOL]     Assert.assertEquals(-34.0, optimum2.getPoint()[2], 1.0e-1); [EOL]     Assert.assertEquals(22.0, optimum2.getPoint()[3], 1.0e-1); [EOL] } <line_num>: 270,310
@Test [EOL] public void testMoreEstimatedParametersSimple() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 3.0, 2.0, 0.0, 0.0 }, { 0.0, 1.0, -1.0, 1.0 }, { 2.0, 0.0, 1.0, 0.0 } }, new double[] { 7.0, 3.0, 5.0 }); [EOL]     NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); [EOL]     PointValuePair optimum = optimizer.optimize(new MaxEval(100), problem.getObjectiveFunction(), problem.getObjectiveFunctionGradient(), GoalType.MINIMIZE, new InitialGuess(new double[] { 7, 6, 5, 4 })); [EOL]     Assert.assertEquals(0, optimum.getValue(), 1.0e-10); [EOL] } <line_num>: 312,331
@Test [EOL] public void testMoreEstimatedParametersUnsorted() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 1.0, 1.0, 0.0, 0.0, 0.0, 0.0 }, { 0.0, 0.0, 1.0, 1.0, 1.0, 0.0 }, { 0.0, 0.0, 0.0, 0.0, 1.0, -1.0 }, { 0.0, 0.0, -1.0, 1.0, 0.0, 1.0 }, { 0.0, 0.0, 0.0, -1.0, 1.0, 0.0 } }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 }); [EOL]     NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); [EOL]     PointValuePair optimum = optimizer.optimize(new MaxEval(100), problem.getObjectiveFunction(), problem.getObjectiveFunctionGradient(), GoalType.MINIMIZE, new InitialGuess(new double[] { 2, 2, 2, 2, 2, 2 })); [EOL]     Assert.assertEquals(0, optimum.getValue(), 1.0e-10); [EOL] } <line_num>: 333,352
@Test [EOL] public void testRedundantEquations() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 1.0, 1.0 }, { 1.0, -1.0 }, { 1.0, 3.0 } }, new double[] { 3.0, 1.0, 5.0 }); [EOL]     NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); [EOL]     PointValuePair optimum = optimizer.optimize(new MaxEval(100), problem.getObjectiveFunction(), problem.getObjectiveFunctionGradient(), GoalType.MINIMIZE, new InitialGuess(new double[] { 1, 1 })); [EOL]     Assert.assertEquals(2.0, optimum.getPoint()[0], 1.0e-8); [EOL]     Assert.assertEquals(1.0, optimum.getPoint()[1], 1.0e-8); [EOL] } <line_num>: 354,374
@Test [EOL] public void testInconsistentEquations() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 1.0, 1.0 }, { 1.0, -1.0 }, { 1.0, 3.0 } }, new double[] { 3.0, 1.0, 4.0 }); [EOL]     NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); [EOL]     PointValuePair optimum = optimizer.optimize(new MaxEval(100), problem.getObjectiveFunction(), problem.getObjectiveFunctionGradient(), GoalType.MINIMIZE, new InitialGuess(new double[] { 1, 1 })); [EOL]     Assert.assertTrue(optimum.getValue() > 0.1); [EOL] } <line_num>: 376,395
@Test [EOL] public void testCircleFitting() { [EOL]     CircleScalar problem = new CircleScalar(); [EOL]     problem.addPoint(30.0, 68.0); [EOL]     problem.addPoint(50.0, -6.0); [EOL]     problem.addPoint(110.0, -20.0); [EOL]     problem.addPoint(35.0, 15.0); [EOL]     problem.addPoint(45.0, 97.0); [EOL]     NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE, new SimpleValueChecker(1e-30, 1e-30), new BrentSolver(1e-15, 1e-13)); [EOL]     PointValuePair optimum = optimizer.optimize(new MaxEval(100), problem.getObjectiveFunction(), problem.getObjectiveFunctionGradient(), GoalType.MINIMIZE, new InitialGuess(new double[] { 98.680, 47.345 })); [EOL]     Vector2D center = new Vector2D(optimum.getPointRef()[0], optimum.getPointRef()[1]); [EOL]     Assert.assertEquals(69.960161753, problem.getRadius(center), 1.0e-8); [EOL]     Assert.assertEquals(96.075902096, center.getX(), 1.0e-8); [EOL]     Assert.assertEquals(48.135167894, center.getY(), 1.0e-8); [EOL] } <line_num>: 397,419
public double value(double[] point) { [EOL]     double[] y = factors.operate(point); [EOL]     double sum = 0; [EOL]     for (int i = 0; i < y.length; ++i) { [EOL]         double ri = y[i] - target[i]; [EOL]         sum += ri * ri; [EOL]     } [EOL]     return sum; [EOL] } <line_num>: 433,441
public ObjectiveFunction getObjectiveFunction() { [EOL]     return new ObjectiveFunction(new MultivariateFunction() { [EOL]  [EOL]         public double value(double[] point) { [EOL]             double[] y = factors.operate(point); [EOL]             double sum = 0; [EOL]             for (int i = 0; i < y.length; ++i) { [EOL]                 double ri = y[i] - target[i]; [EOL]                 sum += ri * ri; [EOL]             } [EOL]             return sum; [EOL]         } [EOL]     }); [EOL] } <line_num>: 431,443
public double[] value(double[] point) { [EOL]     double[] r = factors.operate(point); [EOL]     for (int i = 0; i < r.length; ++i) { [EOL]         r[i] -= target[i]; [EOL]     } [EOL]     double[] p = factors.transpose().operate(r); [EOL]     for (int i = 0; i < p.length; ++i) { [EOL]         p[i] *= 2; [EOL]     } [EOL]     return p; [EOL] } <line_num>: 447,457
public ObjectiveFunctionGradient getObjectiveFunctionGradient() { [EOL]     return new ObjectiveFunctionGradient(new MultivariateVectorFunction() { [EOL]  [EOL]         public double[] value(double[] point) { [EOL]             double[] r = factors.operate(point); [EOL]             for (int i = 0; i < r.length; ++i) { [EOL]                 r[i] -= target[i]; [EOL]             } [EOL]             double[] p = factors.transpose().operate(r); [EOL]             for (int i = 0; i < p.length; ++i) { [EOL]                 p[i] *= 2; [EOL]             } [EOL]             return p; [EOL]         } [EOL]     }); [EOL] } <line_num>: 445,459
