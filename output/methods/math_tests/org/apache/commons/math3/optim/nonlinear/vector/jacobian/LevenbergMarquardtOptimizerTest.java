public QuadraticProblem() { [EOL]     x = new ArrayList<Double>(); [EOL]     y = new ArrayList<Double>(); [EOL] } <line_num>: 323,326
public BevingtonProblem() { [EOL]     time = new ArrayList<Double>(); [EOL]     count = new ArrayList<Double>(); [EOL] } <line_num>: 364,367
@Override [EOL] public AbstractLeastSquaresOptimizer createOptimizer() { [EOL]     return new LevenbergMarquardtOptimizer(); [EOL] } <line_num>: 106,109
@Test(expected = MathUnsupportedOperationException.class) [EOL] public void testConstraintsUnsupported() { [EOL]     createOptimizer().optimize(new MaxEval(100), new Target(new double[] { 2 }), new Weight(new double[] { 1 }), new InitialGuess(new double[] { 1, 2 }), new SimpleBounds(new double[] { -10, 0 }, new double[] { 20, 30 })); [EOL] } <line_num>: 111,119
@Override [EOL] @Test(expected = SingularMatrixException.class) [EOL] public void testNonInvertible() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 1, 2, -3 }, { 2, 1, 3 }, { -3, 0, -9 } }, new double[] { 1, 1, 1 }); [EOL]     AbstractLeastSquaresOptimizer optimizer = createOptimizer(); [EOL]     PointVectorValuePair optimum = optimizer.optimize(new MaxEval(100), problem.getModelFunction(), problem.getModelFunctionJacobian(), problem.getTarget(), new Weight(new double[] { 1, 1, 1 }), new InitialGuess(new double[] { 0, 0, 0 })); [EOL]     Assert.assertTrue(FastMath.sqrt(optimizer.getTargetSize()) * optimizer.getRMS() > 0.6); [EOL]     optimizer.computeCovariances(optimum.getPoint(), 1.5e-14); [EOL] } <line_num>: 121,145
@Test [EOL] public void testControlParameters() { [EOL]     CircleVectorial circle = new CircleVectorial(); [EOL]     circle.addPoint(30.0, 68.0); [EOL]     circle.addPoint(50.0, -6.0); [EOL]     circle.addPoint(110.0, -20.0); [EOL]     circle.addPoint(35.0, 15.0); [EOL]     circle.addPoint(45.0, 97.0); [EOL]     checkEstimate(circle.getModelFunction(), circle.getModelFunctionJacobian(), 0.1, 10, 1.0e-14, 1.0e-16, 1.0e-10, false); [EOL]     checkEstimate(circle.getModelFunction(), circle.getModelFunctionJacobian(), 0.1, 10, 1.0e-15, 1.0e-17, 1.0e-10, true); [EOL]     checkEstimate(circle.getModelFunction(), circle.getModelFunctionJacobian(), 0.1, 5, 1.0e-15, 1.0e-16, 1.0e-10, true); [EOL]     circle.addPoint(300, -300); [EOL]     checkEstimate(circle.getModelFunction(), circle.getModelFunctionJacobian(), 0.1, 20, 1.0e-18, 1.0e-16, 1.0e-10, true); [EOL] } <line_num>: 147,168
private void checkEstimate(ModelFunction problem, ModelFunctionJacobian problemJacobian, double initialStepBoundFactor, int maxCostEval, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, boolean shouldFail) { [EOL]     try { [EOL]         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer(initialStepBoundFactor, costRelativeTolerance, parRelativeTolerance, orthoTolerance, Precision.SAFE_MIN); [EOL]         optimizer.optimize(new MaxEval(maxCostEval), problem, problemJacobian, new Target(new double[] { 0, 0, 0, 0, 0 }), new Weight(new double[] { 1, 1, 1, 1, 1 }), new InitialGuess(new double[] { 98.680, 47.345 })); [EOL]         Assert.assertTrue(!shouldFail); [EOL]     } catch (DimensionMismatchException ee) { [EOL]         Assert.assertTrue(shouldFail); [EOL]     } catch (TooManyEvaluationsException ee) { [EOL]         Assert.assertTrue(shouldFail); [EOL]     } [EOL] } <line_num>: 170,194
@Test [EOL] public void testBevington() { [EOL]     final double[][] dataPoints = { { 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180, 195, 210, 225, 240, 255, 270, 285, 300, 315, 330, 345, 360, 375, 390, 405, 420, 435, 450, 465, 480, 495, 510, 525, 540, 555, 570, 585, 600, 615, 630, 645, 660, 675, 690, 705, 720, 735, 750, 765, 780, 795, 810, 825, 840, 855, 870, 885 }, { 775, 479, 380, 302, 185, 157, 137, 119, 110, 89, 74, 61, 66, 68, 48, 54, 51, 46, 55, 29, 28, 37, 49, 26, 35, 29, 31, 24, 25, 35, 24, 30, 26, 28, 21, 18, 20, 27, 17, 17, 14, 17, 24, 11, 22, 17, 12, 10, 13, 16, 9, 9, 14, 21, 17, 13, 12, 18, 10 } }; [EOL]     final BevingtonProblem problem = new BevingtonProblem(); [EOL]     final int len = dataPoints[0].length; [EOL]     final double[] weights = new double[len]; [EOL]     for (int i = 0; i < len; i++) { [EOL]         problem.addPoint(dataPoints[0][i], dataPoints[1][i]); [EOL]         weights[i] = 1 / dataPoints[1][i]; [EOL]     } [EOL]     final LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer(); [EOL]     final PointVectorValuePair optimum = optimizer.optimize(new MaxEval(100), problem.getModelFunction(), problem.getModelFunctionJacobian(), new Target(dataPoints[1]), new Weight(weights), new InitialGuess(new double[] { 10, 900, 80, 27, 225 })); [EOL]     final double[] solution = optimum.getPoint(); [EOL]     final double[] expectedSolution = { 10.4, 958.3, 131.4, 33.9, 205.0 }; [EOL]     final double[][] covarMatrix = optimizer.computeCovariances(solution, 1e-14); [EOL]     final double[][] expectedCovarMatrix = { { 3.38, -3.69, 27.98, -2.34, -49.24 }, { -3.69, 2492.26, 81.89, -69.21, -8.9 }, { 27.98, 81.89, 468.99, -44.22, -615.44 }, { -2.34, -69.21, -44.22, 6.39, 53.80 }, { -49.24, -8.9, -615.44, 53.8, 929.45 } }; [EOL]     final int numParams = expectedSolution.length; [EOL]     for (int i = 0; i < numParams; i++) { [EOL]         final double error = FastMath.sqrt(expectedCovarMatrix[i][i]); [EOL]         Assert.assertEquals("Parameter " + i, expectedSolution[i], solution[i], error); [EOL]     } [EOL]     for (int i = 0; i < numParams; i++) { [EOL]         for (int j = 0; j < numParams; j++) { [EOL]             Assert.assertEquals("Covariance matrix [" + i + "][" + j + "]", expectedCovarMatrix[i][j], covarMatrix[i][j], FastMath.abs(0.1 * expectedCovarMatrix[i][j])); [EOL]         } [EOL]     } [EOL] } <line_num>: 203,274
@Test [EOL] public void testCircleFitting2() { [EOL]     final double xCenter = 123.456; [EOL]     final double yCenter = 654.321; [EOL]     final double xSigma = 10; [EOL]     final double ySigma = 15; [EOL]     final double radius = 111.111; [EOL]     final long seed = 59421061L; [EOL]     final RandomCirclePointGenerator factory = new RandomCirclePointGenerator(xCenter, yCenter, radius, xSigma, ySigma, seed); [EOL]     final CircleProblem circle = new CircleProblem(xSigma, ySigma); [EOL]     final int numPoints = 10; [EOL]     for (Vector2D p : factory.generate(numPoints)) { [EOL]         circle.addPoint(p.getX(), p.getY()); [EOL]     } [EOL]     final double[] init = { 90, 659, 115 }; [EOL]     final LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer(); [EOL]     final PointVectorValuePair optimum = optimizer.optimize(new MaxEval(100), circle.getModelFunction(), circle.getModelFunctionJacobian(), new Target(circle.target()), new Weight(circle.weight()), new InitialGuess(init)); [EOL]     final double[] paramFound = optimum.getPoint(); [EOL]     final double[] asymptoticStandardErrorFound = optimizer.computeSigma(paramFound, 1e-14); [EOL]     Assert.assertEquals(xCenter, paramFound[0], asymptoticStandardErrorFound[0]); [EOL]     Assert.assertEquals(yCenter, paramFound[1], asymptoticStandardErrorFound[1]); [EOL]     Assert.assertEquals(radius, paramFound[2], asymptoticStandardErrorFound[2]); [EOL] } <line_num>: 276,317
public void addPoint(double x, double y) { [EOL]     this.x.add(x); [EOL]     this.y.add(y); [EOL] } <line_num>: 328,331
public double[] value(double[] variables) { [EOL]     double[] values = new double[x.size()]; [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         values[i] = (variables[0] * x.get(i) + variables[1]) * x.get(i) + variables[2]; [EOL]     } [EOL]     return values; [EOL] } <line_num>: 335,341
public ModelFunction getModelFunction() { [EOL]     return new ModelFunction(new MultivariateVectorFunction() { [EOL]  [EOL]         public double[] value(double[] variables) { [EOL]             double[] values = new double[x.size()]; [EOL]             for (int i = 0; i < values.length; ++i) { [EOL]                 values[i] = (variables[0] * x.get(i) + variables[1]) * x.get(i) + variables[2]; [EOL]             } [EOL]             return values; [EOL]         } [EOL]     }); [EOL] } <line_num>: 333,343
public double[][] value(double[] params) { [EOL]     double[][] jacobian = new double[x.size()][3]; [EOL]     for (int i = 0; i < jacobian.length; ++i) { [EOL]         jacobian[i][0] = x.get(i) * x.get(i); [EOL]         jacobian[i][1] = x.get(i); [EOL]         jacobian[i][2] = 1.0; [EOL]     } [EOL]     return jacobian; [EOL] } <line_num>: 347,355
public ModelFunctionJacobian getModelFunctionJacobian() { [EOL]     return new ModelFunctionJacobian(new MultivariateMatrixFunction() { [EOL]  [EOL]         public double[][] value(double[] params) { [EOL]             double[][] jacobian = new double[x.size()][3]; [EOL]             for (int i = 0; i < jacobian.length; ++i) { [EOL]                 jacobian[i][0] = x.get(i) * x.get(i); [EOL]                 jacobian[i][1] = x.get(i); [EOL]                 jacobian[i][2] = 1.0; [EOL]             } [EOL]             return jacobian; [EOL]         } [EOL]     }); [EOL] } <line_num>: 345,357
public void addPoint(double t, double c) { [EOL]     time.add(t); [EOL]     count.add(c); [EOL] } <line_num>: 369,372
public double[] value(double[] params) { [EOL]     double[] values = new double[time.size()]; [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         final double t = time.get(i); [EOL]         values[i] = params[0] + params[1] * Math.exp(-t / params[3]) + params[2] * Math.exp(-t / params[4]); [EOL]     } [EOL]     return values; [EOL] } <line_num>: 376,385
public ModelFunction getModelFunction() { [EOL]     return new ModelFunction(new MultivariateVectorFunction() { [EOL]  [EOL]         public double[] value(double[] params) { [EOL]             double[] values = new double[time.size()]; [EOL]             for (int i = 0; i < values.length; ++i) { [EOL]                 final double t = time.get(i); [EOL]                 values[i] = params[0] + params[1] * Math.exp(-t / params[3]) + params[2] * Math.exp(-t / params[4]); [EOL]             } [EOL]             return values; [EOL]         } [EOL]     }); [EOL] } <line_num>: 374,387
public double[][] value(double[] params) { [EOL]     double[][] jacobian = new double[time.size()][5]; [EOL]     for (int i = 0; i < jacobian.length; ++i) { [EOL]         final double t = time.get(i); [EOL]         jacobian[i][0] = 1; [EOL]         final double p3 = params[3]; [EOL]         final double p4 = params[4]; [EOL]         final double tOp3 = t / p3; [EOL]         final double tOp4 = t / p4; [EOL]         jacobian[i][1] = Math.exp(-tOp3); [EOL]         jacobian[i][2] = Math.exp(-tOp4); [EOL]         jacobian[i][3] = params[1] * Math.exp(-tOp3) * tOp3 / p3; [EOL]         jacobian[i][4] = params[2] * Math.exp(-tOp4) * tOp4 / p4; [EOL]     } [EOL]     return jacobian; [EOL] } <line_num>: 391,408
public ModelFunctionJacobian getModelFunctionJacobian() { [EOL]     return new ModelFunctionJacobian(new MultivariateMatrixFunction() { [EOL]  [EOL]         public double[][] value(double[] params) { [EOL]             double[][] jacobian = new double[time.size()][5]; [EOL]             for (int i = 0; i < jacobian.length; ++i) { [EOL]                 final double t = time.get(i); [EOL]                 jacobian[i][0] = 1; [EOL]                 final double p3 = params[3]; [EOL]                 final double p4 = params[4]; [EOL]                 final double tOp3 = t / p3; [EOL]                 final double tOp4 = t / p4; [EOL]                 jacobian[i][1] = Math.exp(-tOp3); [EOL]                 jacobian[i][2] = Math.exp(-tOp4); [EOL]                 jacobian[i][3] = params[1] * Math.exp(-tOp3) * tOp3 / p3; [EOL]                 jacobian[i][4] = params[2] * Math.exp(-tOp4) * tOp4 / p4; [EOL]             } [EOL]             return jacobian; [EOL]         } [EOL]     }); [EOL] } <line_num>: 389,410
