Cigar() { [EOL]     this(1e3); [EOL] } <line_num>: 382,384
Cigar(double axisratio) { [EOL]     factor = axisratio * axisratio; [EOL] } <line_num>: 386,388
Tablet() { [EOL]     this(1e3); [EOL] } <line_num>: 401,403
Tablet(double axisratio) { [EOL]     factor = axisratio * axisratio; [EOL] } <line_num>: 405,407
CigTab() { [EOL]     this(1e4); [EOL] } <line_num>: 420,422
CigTab(double axisratio) { [EOL]     factor = axisratio; [EOL] } <line_num>: 424,426
TwoAxes() { [EOL]     this(1e6); [EOL] } <line_num>: 441,443
TwoAxes(double axisratio) { [EOL]     factor = axisratio * axisratio; [EOL] } <line_num>: 445,447
ElliRotated() { [EOL]     this(1e3); [EOL] } <line_num>: 461,463
ElliRotated(double axisratio) { [EOL]     factor = axisratio * axisratio; [EOL] } <line_num>: 465,467
Elli() { [EOL]     this(1e3); [EOL] } <line_num>: 482,484
Elli(double axisratio) { [EOL]     factor = axisratio * axisratio; [EOL] } <line_num>: 486,488
Ackley(double axra) { [EOL]     axisratio = axra; [EOL] } <line_num>: 542,544
public Ackley() { [EOL]     this(1); [EOL] } <line_num>: 546,548
Rastrigin() { [EOL]     this(1, 10); [EOL] } <line_num>: 570,572
Rastrigin(double axisratio, double amplitude) { [EOL]     this.axisratio = axisratio; [EOL]     this.amplitude = amplitude; [EOL] } <line_num>: 574,577
@Test(expected = NumberIsTooLargeException.class) [EOL] public void testInitOutOfBounds() { [EOL]     double[] startPoint = point(DIM, 3); [EOL]     double[][] boundaries = boundaries(DIM, -1, 2); [EOL]     doTest(new Rosen(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 2000, null); [EOL] } <line_num>: 43,50
@Test(expected = DimensionMismatchException.class) [EOL] public void testBoundariesDimensionMismatch() { [EOL]     double[] startPoint = point(DIM, 0.5); [EOL]     double[][] boundaries = boundaries(DIM + 1, -1, 2); [EOL]     doTest(new Rosen(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 2000, null); [EOL] } <line_num>: 52,59
@Test(expected = NumberIsTooSmallException.class) [EOL] public void testProblemDimensionTooSmall() { [EOL]     double[] startPoint = point(1, 0.5); [EOL]     doTest(new Rosen(), startPoint, null, GoalType.MINIMIZE, 1e-13, 1e-6, 2000, null); [EOL] } <line_num>: 61,67
@Test(expected = TooManyEvaluationsException.class) [EOL] public void testMaxEvaluations() { [EOL]     final int lowMaxEval = 2; [EOL]     double[] startPoint = point(DIM, 0.1); [EOL]     double[][] boundaries = null; [EOL]     doTest(new Rosen(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, lowMaxEval, null); [EOL] } <line_num>: 69,77
@Test [EOL] public void testRosen() { [EOL]     double[] startPoint = point(DIM, 0.1); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 1.0), 0.0); [EOL]     doTest(new Rosen(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 2000, expected); [EOL] } <line_num>: 79,87
@Test [EOL] public void testMaximize() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 1.0); [EOL]     doTest(new MinusElli(), startPoint, boundaries, GoalType.MAXIMIZE, 2e-10, 5e-6, 1000, expected); [EOL]     boundaries = boundaries(DIM, -0.3, 0.3); [EOL]     startPoint = point(DIM, 0.1); [EOL]     doTest(new MinusElli(), startPoint, boundaries, GoalType.MAXIMIZE, 2e-10, 5e-6, 1000, expected); [EOL] } <line_num>: 89,102
@Test [EOL] public void testEllipse() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new Elli(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 1000, expected); [EOL] } <line_num>: 104,113
@Test [EOL] public void testElliRotated() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new ElliRotated(), startPoint, boundaries, GoalType.MINIMIZE, 1e-12, 1e-6, 10000, expected); [EOL] } <line_num>: 115,124
@Test [EOL] public void testCigar() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new Cigar(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 100, expected); [EOL] } <line_num>: 126,135
@Test [EOL] public void testTwoAxes() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new TwoAxes(), startPoint, boundaries, GoalType.MINIMIZE, 2 * 1e-13, 1e-6, 100, expected); [EOL] } <line_num>: 137,146
@Test [EOL] public void testCigTab() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new CigTab(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 5e-5, 100, expected); [EOL] } <line_num>: 148,157
@Test [EOL] public void testSphere() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new Sphere(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 100, expected); [EOL] } <line_num>: 159,168
@Test [EOL] public void testTablet() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new Tablet(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 100, expected); [EOL] } <line_num>: 170,179
@Test [EOL] public void testDiffPow() { [EOL] } <line_num>: 181,182
@Test [EOL] public void testSsDiffPow() { [EOL]     double[] startPoint = point(DIM / 2, 1.0); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM / 2, 0.0), 0.0); [EOL]     doTest(new SsDiffPow(), startPoint, boundaries, GoalType.MINIMIZE, 1e-2, 1.3e-1, 50000, expected); [EOL] } <line_num>: 195,204
@Test [EOL] public void testAckley() { [EOL] } <line_num>: 206,207
@Test [EOL] public void testRastrigin() { [EOL]     double[] startPoint = point(DIM, 1.0); [EOL]     double[][] boundaries = null; [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 0.0), 0.0); [EOL]     doTest(new Rastrigin(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 1000, expected); [EOL] } <line_num>: 220,230
@Test [EOL] public void testConstrainedRosen() { [EOL]     double[] startPoint = point(DIM, 0.1); [EOL]     double[][] boundaries = boundaries(DIM, -1, 2); [EOL]     PointValuePair expected = new PointValuePair(point(DIM, 1.0), 0.0); [EOL]     doTest(new Rosen(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 2000, expected); [EOL] } <line_num>: 232,242
@Ignore [EOL] @Test [EOL] public void testConstrainedRosenWithMoreInterpolationPoints() { [EOL]     final double[] startPoint = point(DIM, 0.1); [EOL]     final double[][] boundaries = boundaries(DIM, -1, 2); [EOL]     final PointValuePair expected = new PointValuePair(point(DIM, 1.0), 0.0); [EOL]     final int maxAdditionalPoints = 47; [EOL]     for (int num = 1; num <= maxAdditionalPoints; num++) { [EOL]         doTest(new Rosen(), startPoint, boundaries, GoalType.MINIMIZE, 1e-12, 1e-6, 2000, num, expected, "num=" + num); [EOL]     } [EOL] } <line_num>: 247,268
private void doTest(MultivariateFunction func, double[] startPoint, double[][] boundaries, GoalType goal, double fTol, double pointTol, int maxEvaluations, PointValuePair expected) { [EOL]     doTest(func, startPoint, boundaries, goal, fTol, pointTol, maxEvaluations, 0, expected, ""); [EOL] } <line_num>: 280,298
private void doTest(MultivariateFunction func, double[] startPoint, double[][] boundaries, GoalType goal, double fTol, double pointTol, int maxEvaluations, int additionalInterpolationPoints, PointValuePair expected, String assertMsg) { [EOL]     int dim = startPoint.length; [EOL]     final int numIterpolationPoints = 2 * dim + 1 + additionalInterpolationPoints; [EOL]     BOBYQAOptimizer optim = new BOBYQAOptimizer(numIterpolationPoints); [EOL]     PointValuePair result = boundaries == null ? optim.optimize(new MaxEval(maxEvaluations), new ObjectiveFunction(func), goal, SimpleBounds.unbounded(dim), new InitialGuess(startPoint)) : optim.optimize(new MaxEval(maxEvaluations), new ObjectiveFunction(func), goal, new InitialGuess(startPoint), new SimpleBounds(boundaries[0], boundaries[1])); [EOL]     Assert.assertEquals(assertMsg, expected.getValue(), result.getValue(), fTol); [EOL]     for (int i = 0; i < dim; i++) { [EOL]         Assert.assertEquals(expected.getPoint()[i], result.getPoint()[i], pointTol); [EOL]     } [EOL] } <line_num>: 312,351
private static double[] point(int n, double value) { [EOL]     double[] ds = new double[n]; [EOL]     Arrays.fill(ds, value); [EOL]     return ds; [EOL] } <line_num>: 353,357
private static double[][] boundaries(int dim, double lower, double upper) { [EOL]     double[][] boundaries = new double[2][dim]; [EOL]     for (int i = 0; i < dim; i++) boundaries[0][i] = lower; [EOL]     for (int i = 0; i < dim; i++) boundaries[1][i] = upper; [EOL]     return boundaries; [EOL] } <line_num>: 359,367
public double value(double[] x) { [EOL]     double f = 0; [EOL]     for (int i = 0; i < x.length; ++i) f += x[i] * x[i]; [EOL]     return f; [EOL] } <line_num>: 371,376
public double value(double[] x) { [EOL]     double f = x[0] * x[0]; [EOL]     for (int i = 1; i < x.length; ++i) f += factor * x[i] * x[i]; [EOL]     return f; [EOL] } <line_num>: 390,395
public double value(double[] x) { [EOL]     double f = factor * x[0] * x[0]; [EOL]     for (int i = 1; i < x.length; ++i) f += x[i] * x[i]; [EOL]     return f; [EOL] } <line_num>: 409,414
public double value(double[] x) { [EOL]     int end = x.length - 1; [EOL]     double f = x[0] * x[0] / factor + factor * x[end] * x[end]; [EOL]     for (int i = 1; i < end; ++i) f += x[i] * x[i]; [EOL]     return f; [EOL] } <line_num>: 428,434
public double value(double[] x) { [EOL]     double f = 0; [EOL]     for (int i = 0; i < x.length; ++i) f += (i < x.length / 2 ? factor : 1) * x[i] * x[i]; [EOL]     return f; [EOL] } <line_num>: 449,454
public double value(double[] x) { [EOL]     double f = 0; [EOL]     x = B.Rotate(x); [EOL]     for (int i = 0; i < x.length; ++i) f += Math.pow(factor, i / (x.length - 1.)) * x[i] * x[i]; [EOL]     return f; [EOL] } <line_num>: 469,475
public double value(double[] x) { [EOL]     double f = 0; [EOL]     for (int i = 0; i < x.length; ++i) f += Math.pow(factor, i / (x.length - 1.)) * x[i] * x[i]; [EOL]     return f; [EOL] } <line_num>: 490,495
public double value(double[] x) { [EOL]     return 1.0 - elli.value(x); [EOL] } <line_num>: 500,502
public double value(double[] x) { [EOL]     double f = 0; [EOL]     for (int i = 0; i < x.length; ++i) f += Math.pow(Math.abs(x[i]), 2. + 10 * (double) i / (x.length - 1.)); [EOL]     return f; [EOL] } <line_num>: 507,517
public double value(double[] x) { [EOL]     double f = Math.pow(new DiffPow().value(x), 0.25); [EOL]     return f; [EOL] } <line_num>: 522,525
public double value(double[] x) { [EOL]     double f = 0; [EOL]     for (int i = 0; i < x.length - 1; ++i) f += 1e2 * (x[i] * x[i] - x[i + 1]) * (x[i] * x[i] - x[i + 1]) + (x[i] - 1.) * (x[i] - 1.); [EOL]     return f; [EOL] } <line_num>: 530,536
public double value(double[] x) { [EOL]     double f = 0; [EOL]     double res2 = 0; [EOL]     double fac = 0; [EOL]     for (int i = 0; i < x.length; ++i) { [EOL]         fac = Math.pow(axisratio, (i - 1.) / (x.length - 1.)); [EOL]         f += fac * fac * x[i] * x[i]; [EOL]         res2 += Math.cos(2. * Math.PI * fac * x[i]); [EOL]     } [EOL]     f = (20. - 20. * Math.exp(-0.2 * Math.sqrt(f / x.length)) + Math.exp(1.) - Math.exp(res2 / x.length)); [EOL]     return f; [EOL] } <line_num>: 550,562
public double value(double[] x) { [EOL]     double f = 0; [EOL]     double fac; [EOL]     for (int i = 0; i < x.length; ++i) { [EOL]         fac = Math.pow(axisratio, (i - 1.) / (x.length - 1.)); [EOL]         if (i == 0 && x[i] < 0) [EOL]             fac *= 1.; [EOL]         f += fac * fac * x[i] * x[i] + amplitude * (1. - Math.cos(2. * Math.PI * fac * x[i])); [EOL]     } [EOL]     return f; [EOL] } <line_num>: 579,590
double[] Rotate(double[] x) { [EOL]     GenBasis(x.length); [EOL]     double[] y = new double[x.length]; [EOL]     for (int i = 0; i < x.length; ++i) { [EOL]         y[i] = 0; [EOL]         for (int j = 0; j < x.length; ++j) y[i] += basis[i][j] * x[j]; [EOL]     } [EOL]     return y; [EOL] } <line_num>: 597,606
void GenBasis(int DIM) { [EOL]     if (basis != null ? basis.length == DIM : false) [EOL]         return; [EOL]     double sp; [EOL]     int i, j, k; [EOL]     basis = new double[DIM][DIM]; [EOL]     for (i = 0; i < DIM; ++i) { [EOL]         for (j = 0; j < DIM; ++j) basis[i][j] = rand.nextGaussian(); [EOL]         for (j = i - 1; j >= 0; --j) { [EOL]             for (sp = 0., k = 0; k < DIM; ++k) sp += basis[i][k] * basis[j][k]; [EOL]             for (k = 0; k < DIM; ++k) basis[i][k] -= sp * basis[j][k]; [EOL]         } [EOL]         for (sp = 0., k = 0; k < DIM; ++k) sp += basis[i][k] * basis[i][k]; [EOL]         for (k = 0; k < DIM; ++k) basis[i][k] /= Math.sqrt(sp); [EOL]     } [EOL] } <line_num>: 608,634
