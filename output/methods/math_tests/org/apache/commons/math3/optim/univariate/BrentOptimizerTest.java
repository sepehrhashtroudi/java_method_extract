@Test [EOL] public void testSinMin() { [EOL]     UnivariateFunction f = new Sin(); [EOL]     UnivariateOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14); [EOL]     Assert.assertEquals(3 * Math.PI / 2, optimizer.optimize(new MaxEval(200), new UnivariateObjectiveFunction(f), GoalType.MINIMIZE, new SearchInterval(4, 5)).getPoint(), 1e-8); [EOL]     Assert.assertTrue(optimizer.getEvaluations() <= 50); [EOL]     Assert.assertEquals(200, optimizer.getMaxEvaluations()); [EOL]     Assert.assertEquals(3 * Math.PI / 2, optimizer.optimize(new MaxEval(200), new UnivariateObjectiveFunction(f), GoalType.MINIMIZE, new SearchInterval(1, 5)).getPoint(), 1e-8); [EOL]     Assert.assertTrue(optimizer.getEvaluations() <= 100); [EOL]     Assert.assertTrue(optimizer.getEvaluations() >= 15); [EOL]     try { [EOL]         optimizer.optimize(new MaxEval(10), new UnivariateObjectiveFunction(f), GoalType.MINIMIZE, new SearchInterval(4, 5)); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (TooManyEvaluationsException fee) { [EOL]     } [EOL] } <line_num>: 41,66
@Test [EOL] public void testSinMinWithValueChecker() { [EOL]     final UnivariateFunction f = new Sin(); [EOL]     final ConvergenceChecker<UnivariatePointValuePair> checker = new SimpleUnivariateValueChecker(1e-5, 1e-14); [EOL]     final UnivariateOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14, checker); [EOL]     final UnivariatePointValuePair result = optimizer.optimize(new MaxEval(200), new UnivariateObjectiveFunction(f), GoalType.MINIMIZE, new SearchInterval(4, 5)); [EOL]     Assert.assertEquals(3 * Math.PI / 2, result.getPoint(), 1e-3); [EOL] } <line_num>: 68,81
public double value(double x) { [EOL]     if (x < lower) { [EOL]         throw new NumberIsTooSmallException(x, lower, true); [EOL]     } else if (x > upper) { [EOL]         throw new NumberIsTooLargeException(x, upper, true); [EOL]     } else { [EOL]         return x; [EOL]     } [EOL] } <line_num>: 88,96
@Test [EOL] public void testBoundaries() { [EOL]     final double lower = -1.0; [EOL]     final double upper = +1.0; [EOL]     UnivariateFunction f = new UnivariateFunction() { [EOL]  [EOL]         public double value(double x) { [EOL]             if (x < lower) { [EOL]                 throw new NumberIsTooSmallException(x, lower, true); [EOL]             } else if (x > upper) { [EOL]                 throw new NumberIsTooLargeException(x, upper, true); [EOL]             } else { [EOL]                 return x; [EOL]             } [EOL]         } [EOL]     }; [EOL]     UnivariateOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14); [EOL]     Assert.assertEquals(lower, optimizer.optimize(new MaxEval(100), new UnivariateObjectiveFunction(f), GoalType.MINIMIZE, new SearchInterval(lower, upper)).getPoint(), 1.0e-8); [EOL]     Assert.assertEquals(upper, optimizer.optimize(new MaxEval(100), new UnivariateObjectiveFunction(f), GoalType.MAXIMIZE, new SearchInterval(lower, upper)).getPoint(), 1.0e-8); [EOL] } <line_num>: 83,111
@Test [EOL] public void testQuinticMin() { [EOL]     UnivariateFunction f = new QuinticFunction(); [EOL]     UnivariateOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14); [EOL]     Assert.assertEquals(-0.27195613, optimizer.optimize(new MaxEval(200), new UnivariateObjectiveFunction(f), GoalType.MINIMIZE, new SearchInterval(-0.3, -0.2)).getPoint(), 1.0e-8); [EOL]     Assert.assertEquals(0.82221643, optimizer.optimize(new MaxEval(200), new UnivariateObjectiveFunction(f), GoalType.MINIMIZE, new SearchInterval(0.3, 0.9)).getPoint(), 1.0e-8); [EOL]     Assert.assertTrue(optimizer.getEvaluations() <= 50); [EOL]     Assert.assertEquals(-0.27195613, optimizer.optimize(new MaxEval(200), new UnivariateObjectiveFunction(f), GoalType.MINIMIZE, new SearchInterval(-1.0, 0.2)).getPoint(), 1.0e-8); [EOL]     Assert.assertTrue(optimizer.getEvaluations() <= 50); [EOL] } <line_num>: 113,134
@Test [EOL] public void testQuinticMinStatistics() { [EOL]     UnivariateFunction f = new QuinticFunction(); [EOL]     UnivariateOptimizer optimizer = new BrentOptimizer(1e-11, 1e-14); [EOL]     final DescriptiveStatistics[] stat = new DescriptiveStatistics[2]; [EOL]     for (int i = 0; i < stat.length; i++) { [EOL]         stat[i] = new DescriptiveStatistics(); [EOL]     } [EOL]     final double min = -0.75; [EOL]     final double max = 0.25; [EOL]     final int nSamples = 200; [EOL]     final double delta = (max - min) / nSamples; [EOL]     for (int i = 0; i < nSamples; i++) { [EOL]         final double start = min + i * delta; [EOL]         stat[0].addValue(optimizer.optimize(new MaxEval(40), new UnivariateObjectiveFunction(f), GoalType.MINIMIZE, new SearchInterval(min, max, start)).getPoint()); [EOL]         stat[1].addValue(optimizer.getEvaluations()); [EOL]     } [EOL]     final double meanOptValue = stat[0].getMean(); [EOL]     final double medianEval = stat[1].getPercentile(50); [EOL]     Assert.assertTrue(meanOptValue > -0.2719561281); [EOL]     Assert.assertTrue(meanOptValue < -0.2719561280); [EOL]     Assert.assertEquals(23, (int) medianEval); [EOL] } <line_num>: 136,165
@Test [EOL] public void testQuinticMax() { [EOL]     UnivariateFunction f = new QuinticFunction(); [EOL]     UnivariateOptimizer optimizer = new BrentOptimizer(1e-12, 1e-14); [EOL]     Assert.assertEquals(0.27195613, optimizer.optimize(new MaxEval(100), new UnivariateObjectiveFunction(f), GoalType.MAXIMIZE, new SearchInterval(0.2, 0.3)).getPoint(), 1e-8); [EOL]     try { [EOL]         optimizer.optimize(new MaxEval(5), new UnivariateObjectiveFunction(f), GoalType.MAXIMIZE, new SearchInterval(0.2, 0.3)); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (TooManyEvaluationsException miee) { [EOL]     } [EOL] } <line_num>: 167,186
@Test [EOL] public void testMinEndpoints() { [EOL]     UnivariateFunction f = new Sin(); [EOL]     UnivariateOptimizer optimizer = new BrentOptimizer(1e-8, 1e-14); [EOL]     double result = optimizer.optimize(new MaxEval(50), new UnivariateObjectiveFunction(f), GoalType.MINIMIZE, new SearchInterval(3 * Math.PI / 2, 5)).getPoint(); [EOL]     Assert.assertEquals(3 * Math.PI / 2, result, 1e-6); [EOL]     result = optimizer.optimize(new MaxEval(50), new UnivariateObjectiveFunction(f), GoalType.MINIMIZE, new SearchInterval(4, 3 * Math.PI / 2)).getPoint(); [EOL]     Assert.assertEquals(3 * Math.PI / 2, result, 1e-6); [EOL] } <line_num>: 188,205
public double value(double x) { [EOL]     final double sqrtX = FastMath.sqrt(x); [EOL]     final double a = 1e2 * sqrtX; [EOL]     final double b = 1e6 / x; [EOL]     final double c = 1e4 / sqrtX; [EOL]     return a + b + c; [EOL] } <line_num>: 210,217
@Test [EOL] public void testMath832() { [EOL]     final UnivariateFunction f = new UnivariateFunction() { [EOL]  [EOL]         public double value(double x) { [EOL]             final double sqrtX = FastMath.sqrt(x); [EOL]             final double a = 1e2 * sqrtX; [EOL]             final double b = 1e6 / x; [EOL]             final double c = 1e4 / sqrtX; [EOL]             return a + b + c; [EOL]         } [EOL]     }; [EOL]     UnivariateOptimizer optimizer = new BrentOptimizer(1e-10, 1e-8); [EOL]     final double result = optimizer.optimize(new MaxEval(1483), new UnivariateObjectiveFunction(f), GoalType.MINIMIZE, new SearchInterval(Double.MIN_VALUE, Double.MAX_VALUE)).getPoint(); [EOL]     Assert.assertEquals(804.9355825, result, 1e-6); [EOL] } <line_num>: 207,228
@Test [EOL] public void testKeepInitIfBest() { [EOL]     final double minSin = 3 * Math.PI / 2; [EOL]     final double offset = 1e-8; [EOL]     final double delta = 1e-7; [EOL]     final UnivariateFunction f1 = new Sin(); [EOL]     final UnivariateFunction f2 = new StepFunction(new double[] { minSin, minSin + offset, minSin + 2 * offset }, new double[] { 0, -1, 0 }); [EOL]     final UnivariateFunction f = FunctionUtils.add(f1, f2); [EOL]     final double relTol = 1e-8; [EOL]     final UnivariateOptimizer optimizer = new BrentOptimizer(relTol, 1e-100); [EOL]     final double init = minSin + 1.5 * offset; [EOL]     final UnivariatePointValuePair result = optimizer.optimize(new MaxEval(200), new UnivariateObjectiveFunction(f), GoalType.MINIMIZE, new SearchInterval(minSin - 6.789 * delta, minSin + 9.876 * delta, init)); [EOL]     final int numEval = optimizer.getEvaluations(); [EOL]     final double sol = result.getPoint(); [EOL]     final double expected = init; [EOL]     Assert.assertTrue("Best point not reported", f.value(sol) <= f.value(expected)); [EOL] } <line_num>: 235,267
@Test [EOL] public void testMath855() { [EOL]     final double minSin = 3 * Math.PI / 2; [EOL]     final double offset = 1e-8; [EOL]     final double delta = 1e-7; [EOL]     final UnivariateFunction f1 = new Sin(); [EOL]     final UnivariateFunction f2 = new StepFunction(new double[] { minSin, minSin + offset, minSin + 5 * offset }, new double[] { 0, -1, 0 }); [EOL]     final UnivariateFunction f = FunctionUtils.add(f1, f2); [EOL]     final UnivariateOptimizer optimizer = new BrentOptimizer(1e-8, 1e-100); [EOL]     final UnivariatePointValuePair result = optimizer.optimize(new MaxEval(200), new UnivariateObjectiveFunction(f), GoalType.MINIMIZE, new SearchInterval(minSin - 6.789 * delta, minSin + 9.876 * delta)); [EOL]     final int numEval = optimizer.getEvaluations(); [EOL]     final double sol = result.getPoint(); [EOL]     final double expected = 4.712389027602411; [EOL]     Assert.assertTrue("Best point not reported", f.value(sol) <= f.value(expected)); [EOL] } <line_num>: 274,300
