public RandomGeneratorAbstractTest() { [EOL]     generator = makeGenerator(); [EOL]     randomData = new RandomDataGenerator(generator); [EOL] } <line_num>: 58,61
protected abstract RandomGenerator makeGenerator(); <line_num>: 53,53
@Before [EOL] public void setUp() { [EOL]     generator = makeGenerator(); [EOL] } <line_num>: 66,69
@Override [EOL] public void testNextSecureLongIAE() { [EOL] } <line_num>: 72,73
@Override [EOL] public void testNextSecureLongNegativeToPositiveRange() { [EOL] } <line_num>: 74,75
@Override [EOL] public void testNextSecureLongNegativeRange() { [EOL] } <line_num>: 76,77
@Override [EOL] public void testNextSecureLongPositiveRange() { [EOL] } <line_num>: 78,79
@Override [EOL] public void testNextSecureIntIAE() { [EOL] } <line_num>: 80,81
@Override [EOL] public void testNextSecureIntNegativeToPositiveRange() { [EOL] } <line_num>: 82,83
@Override [EOL] public void testNextSecureIntNegativeRange() { [EOL] } <line_num>: 84,85
@Override [EOL] public void testNextSecureIntPositiveRange() { [EOL] } <line_num>: 86,87
@Override [EOL] public void testNextSecureHex() { [EOL] } <line_num>: 88,89
@Test [EOL] public void testNextIntDirect() { [EOL]     int[] testValues = new int[] { 4, 10, 12, 32, 100, 10000, 0, 0, 0, 0 }; [EOL]     for (int i = 6; i < 10; i++) { [EOL]         final int val = generator.nextInt(); [EOL]         testValues[i] = val < 0 ? -val : val + 1; [EOL]     } [EOL]     final int numTests = 1000; [EOL]     for (int i = 0; i < testValues.length; i++) { [EOL]         final int n = testValues[i]; [EOL]         int[] binUpperBounds; [EOL]         if (n < 32) { [EOL]             binUpperBounds = new int[n]; [EOL]             for (int k = 0; k < n; k++) { [EOL]                 binUpperBounds[k] = k; [EOL]             } [EOL]         } else { [EOL]             binUpperBounds = new int[10]; [EOL]             final int step = n / 10; [EOL]             for (int k = 0; k < 9; k++) { [EOL]                 binUpperBounds[k] = (k + 1) * step; [EOL]             } [EOL]             binUpperBounds[9] = n - 1; [EOL]         } [EOL]         int numFailures = 0; [EOL]         final int binCount = binUpperBounds.length; [EOL]         final long[] observed = new long[binCount]; [EOL]         final double[] expected = new double[binCount]; [EOL]         expected[0] = binUpperBounds[0] == 0 ? (double) smallSampleSize / (double) n : (double) ((binUpperBounds[0] + 1) * smallSampleSize) / (double) n; [EOL]         for (int k = 1; k < binCount; k++) { [EOL]             expected[k] = (double) smallSampleSize * (double) (binUpperBounds[k] - binUpperBounds[k - 1]) / n; [EOL]         } [EOL]         for (int j = 0; j < numTests; j++) { [EOL]             Arrays.fill(observed, 0); [EOL]             for (int k = 0; k < smallSampleSize; k++) { [EOL]                 final int value = generator.nextInt(n); [EOL]                 Assert.assertTrue("nextInt range", (value >= 0) && (value < n)); [EOL]                 for (int l = 0; l < binCount; l++) { [EOL]                     if (binUpperBounds[l] >= value) { [EOL]                         observed[l]++; [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (testStatistic.chiSquareTest(expected, observed) < 0.01) { [EOL]                 numFailures++; [EOL]             } [EOL]         } [EOL]         if ((double) numFailures / (double) numTests > 0.02) { [EOL]             Assert.fail("Too many failures for n = " + n + " " + numFailures + " out of " + numTests + " tests failed."); [EOL]         } [EOL]     } [EOL] } <line_num>: 91,162
@Test [EOL] public void testNextIntIAE2() { [EOL]     try { [EOL]         generator.nextInt(-1); [EOL]         Assert.fail("MathIllegalArgumentException expected"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         generator.nextInt(0); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 164,177
@Test [EOL] public void testNextLongDirect() { [EOL]     long q1 = Long.MAX_VALUE / 4; [EOL]     long q2 = 2 * q1; [EOL]     long q3 = 3 * q1; [EOL]     Frequency freq = new Frequency(); [EOL]     long val = 0; [EOL]     int value = 0; [EOL]     for (int i = 0; i < smallSampleSize; i++) { [EOL]         val = generator.nextLong(); [EOL]         val = val < 0 ? -val : val; [EOL]         if (val < q1) { [EOL]             value = 0; [EOL]         } else if (val < q2) { [EOL]             value = 1; [EOL]         } else if (val < q3) { [EOL]             value = 2; [EOL]         } else { [EOL]             value = 3; [EOL]         } [EOL]         freq.addValue(value); [EOL]     } [EOL]     long[] observed = new long[4]; [EOL]     for (int i = 0; i < 4; i++) { [EOL]         observed[i] = freq.getCount(i); [EOL]     } [EOL]     Assert.assertTrue("chi-square test -- will fail about 1 in 1000 times", testStatistic.chiSquare(expected, observed) < 16.27); [EOL] } <line_num>: 179,212
@Test [EOL] public void testNextBooleanDirect() { [EOL]     long halfSampleSize = smallSampleSize / 2; [EOL]     double[] expected = { halfSampleSize, halfSampleSize }; [EOL]     long[] observed = new long[2]; [EOL]     for (int i = 0; i < smallSampleSize; i++) { [EOL]         if (generator.nextBoolean()) { [EOL]             observed[0]++; [EOL]         } else { [EOL]             observed[1]++; [EOL]         } [EOL]     } [EOL]     Assert.assertTrue("chi-square test -- will fail about 1 in 1000 times", testStatistic.chiSquare(expected, observed) < 10.828); [EOL] } <line_num>: 214,231
@Test [EOL] public void testNextFloatDirect() { [EOL]     Frequency freq = new Frequency(); [EOL]     float val = 0; [EOL]     int value = 0; [EOL]     for (int i = 0; i < smallSampleSize; i++) { [EOL]         val = generator.nextFloat(); [EOL]         if (val < 0.25) { [EOL]             value = 0; [EOL]         } else if (val < 0.5) { [EOL]             value = 1; [EOL]         } else if (val < 0.75) { [EOL]             value = 2; [EOL]         } else { [EOL]             value = 3; [EOL]         } [EOL]         freq.addValue(value); [EOL]     } [EOL]     long[] observed = new long[4]; [EOL]     for (int i = 0; i < 4; i++) { [EOL]         observed[i] = freq.getCount(i); [EOL]     } [EOL]     Assert.assertTrue("chi-square test -- will fail about 1 in 1000 times", testStatistic.chiSquare(expected, observed) < 16.27); [EOL] } <line_num>: 233,261
@Test [EOL] public void testDoubleDirect() { [EOL]     SummaryStatistics sample = new SummaryStatistics(); [EOL]     final int N = 10000; [EOL]     for (int i = 0; i < N; ++i) { [EOL]         sample.addValue(generator.nextDouble()); [EOL]     } [EOL]     Assert.assertEquals("Note: This test will fail randomly about 1 in 100 times.", 0.5, sample.getMean(), FastMath.sqrt(N / 12.0) * 2.576); [EOL]     Assert.assertEquals(1.0 / (2.0 * FastMath.sqrt(3.0)), sample.getStandardDeviation(), 0.01); [EOL] } <line_num>: 263,274
@Test [EOL] public void testFloatDirect() { [EOL]     SummaryStatistics sample = new SummaryStatistics(); [EOL]     final int N = 1000; [EOL]     for (int i = 0; i < N; ++i) { [EOL]         sample.addValue(generator.nextFloat()); [EOL]     } [EOL]     Assert.assertEquals("Note: This test will fail randomly about 1 in 100 times.", 0.5, sample.getMean(), FastMath.sqrt(N / 12.0) * 2.576); [EOL]     Assert.assertEquals(1.0 / (2.0 * FastMath.sqrt(3.0)), sample.getStandardDeviation(), 0.01); [EOL] } <line_num>: 276,287
@Test(expected = MathIllegalArgumentException.class) [EOL] public void testNextIntNeg() { [EOL]     generator.nextInt(-1); [EOL] } <line_num>: 289,292
@Test [EOL] public void testNextInt2() { [EOL]     int walk = 0; [EOL]     final int N = 10000; [EOL]     for (int k = 0; k < N; ++k) { [EOL]         if (generator.nextInt() >= 0) { [EOL]             ++walk; [EOL]         } else { [EOL]             --walk; [EOL]         } [EOL]     } [EOL]     Assert.assertTrue("Walked too far astray: " + walk + "\nNote: This " + "test will fail randomly about 1 in 100 times.", FastMath.abs(walk) < FastMath.sqrt(N) * 2.576); [EOL] } <line_num>: 294,308
@Test [EOL] public void testNextLong2() { [EOL]     int walk = 0; [EOL]     final int N = 1000; [EOL]     for (int k = 0; k < N; ++k) { [EOL]         if (generator.nextLong() >= 0) { [EOL]             ++walk; [EOL]         } else { [EOL]             --walk; [EOL]         } [EOL]     } [EOL]     Assert.assertTrue("Walked too far astray: " + walk + "\nNote: This " + "test will fail randomly about 1 in 100 times.", FastMath.abs(walk) < FastMath.sqrt(N) * 2.576); [EOL] } <line_num>: 310,324
@Test [EOL] public void testNexBoolean2() { [EOL]     int walk = 0; [EOL]     final int N = 10000; [EOL]     for (int k = 0; k < N; ++k) { [EOL]         if (generator.nextBoolean()) { [EOL]             ++walk; [EOL]         } else { [EOL]             --walk; [EOL]         } [EOL]     } [EOL]     Assert.assertTrue("Walked too far astray: " + walk + "\nNote: This " + "test will fail randomly about 1 in 100 times.", FastMath.abs(walk) < FastMath.sqrt(N) * 2.576); [EOL] } <line_num>: 326,340
@Test [EOL] public void testNexBytes() { [EOL]     long[] count = new long[256]; [EOL]     byte[] bytes = new byte[10]; [EOL]     double[] expected = new double[256]; [EOL]     final int sampleSize = 100000; [EOL]     for (int i = 0; i < 256; i++) { [EOL]         expected[i] = (double) sampleSize / 265f; [EOL]     } [EOL]     for (int k = 0; k < sampleSize; ++k) { [EOL]         generator.nextBytes(bytes); [EOL]         for (byte b : bytes) { [EOL]             ++count[b + 128]; [EOL]         } [EOL]     } [EOL]     TestUtils.assertChiSquareAccept(expected, count, 0.001); [EOL] } <line_num>: 342,362
@Test [EOL] public void testSeeding() { [EOL]     RandomGenerator gen = makeGenerator(); [EOL]     RandomGenerator gen1 = makeGenerator(); [EOL]     checkSameSequence(gen, gen1); [EOL]     gen.setSeed(100); [EOL]     gen1 = makeGenerator(); [EOL]     gen1.setSeed(100); [EOL]     checkSameSequence(gen, gen1); [EOL] } <line_num>: 364,376
private void checkSameSequence(RandomGenerator gen1, RandomGenerator gen2) { [EOL]     final int len = 11; [EOL]     final double[][] values = new double[2][len]; [EOL]     for (int i = 0; i < len; i++) { [EOL]         values[0][i] = gen1.nextDouble(); [EOL]     } [EOL]     for (int i = 0; i < len; i++) { [EOL]         values[1][i] = gen2.nextDouble(); [EOL]     } [EOL]     Assert.assertTrue(Arrays.equals(values[0], values[1])); [EOL]     for (int i = 0; i < len; i++) { [EOL]         values[0][i] = gen1.nextFloat(); [EOL]     } [EOL]     for (int i = 0; i < len; i++) { [EOL]         values[1][i] = gen2.nextFloat(); [EOL]     } [EOL]     Assert.assertTrue(Arrays.equals(values[0], values[1])); [EOL]     for (int i = 0; i < len; i++) { [EOL]         values[0][i] = gen1.nextInt(); [EOL]     } [EOL]     for (int i = 0; i < len; i++) { [EOL]         values[1][i] = gen2.nextInt(); [EOL]     } [EOL]     Assert.assertTrue(Arrays.equals(values[0], values[1])); [EOL]     for (int i = 0; i < len; i++) { [EOL]         values[0][i] = gen1.nextLong(); [EOL]     } [EOL]     for (int i = 0; i < len; i++) { [EOL]         values[1][i] = gen2.nextLong(); [EOL]     } [EOL]     Assert.assertTrue(Arrays.equals(values[0], values[1])); [EOL]     for (int i = 0; i < len; i++) { [EOL]         values[0][i] = gen1.nextInt(len); [EOL]     } [EOL]     for (int i = 0; i < len; i++) { [EOL]         values[1][i] = gen2.nextInt(len); [EOL]     } [EOL]     Assert.assertTrue(Arrays.equals(values[0], values[1])); [EOL]     for (int i = 0; i < len; i++) { [EOL]         values[0][i] = gen1.nextBoolean() ? 1 : 0; [EOL]     } [EOL]     for (int i = 0; i < len; i++) { [EOL]         values[1][i] = gen2.nextBoolean() ? 1 : 0; [EOL]     } [EOL]     Assert.assertTrue(Arrays.equals(values[0], values[1])); [EOL]     for (int i = 0; i < len; i++) { [EOL]         values[0][i] = gen1.nextGaussian(); [EOL]     } [EOL]     for (int i = 0; i < len; i++) { [EOL]         values[1][i] = gen2.nextGaussian(); [EOL]     } [EOL]     Assert.assertTrue(Arrays.equals(values[0], values[1])); [EOL] } <line_num>: 378,430
