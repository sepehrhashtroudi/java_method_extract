public RandomDataGeneratorTest() { [EOL]     randomData = new RandomDataGenerator(); [EOL]     randomData.reSeed(1000); [EOL] } <line_num>: 61,64
@Test [EOL] public void testNextIntExtremeValues() { [EOL]     int x = randomData.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE); [EOL]     int y = randomData.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE); [EOL]     Assert.assertFalse(x == y); [EOL] } <line_num>: 74,79
@Test [EOL] public void testNextLongExtremeValues() { [EOL]     long x = randomData.nextLong(Long.MIN_VALUE, Long.MAX_VALUE); [EOL]     long y = randomData.nextLong(Long.MIN_VALUE, Long.MAX_VALUE); [EOL]     Assert.assertFalse(x == y); [EOL] } <line_num>: 81,86
@Test [EOL] public void testNextUniformExtremeValues() { [EOL]     double x = randomData.nextUniform(-Double.MAX_VALUE, Double.MAX_VALUE); [EOL]     double y = randomData.nextUniform(-Double.MAX_VALUE, Double.MAX_VALUE); [EOL]     Assert.assertFalse(x == y); [EOL]     Assert.assertFalse(Double.isNaN(x)); [EOL]     Assert.assertFalse(Double.isNaN(y)); [EOL]     Assert.assertFalse(Double.isInfinite(x)); [EOL]     Assert.assertFalse(Double.isInfinite(y)); [EOL] } <line_num>: 88,97
@Test [EOL] public void testNextIntIAE() { [EOL]     try { [EOL]         randomData.nextInt(4, 3); [EOL]         Assert.fail("MathIllegalArgumentException expected"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 99,107
@Test [EOL] public void testNextIntNegativeToPositiveRange() { [EOL]     for (int i = 0; i < 5; i++) { [EOL]         checkNextIntUniform(-3, 5); [EOL]         checkNextIntUniform(-3, 6); [EOL]     } [EOL] } <line_num>: 109,115
@Test [EOL] public void testNextIntNegativeRange() { [EOL]     for (int i = 0; i < 5; i++) { [EOL]         checkNextIntUniform(-7, -4); [EOL]         checkNextIntUniform(-15, -2); [EOL]         checkNextIntUniform(Integer.MIN_VALUE + 1, Integer.MIN_VALUE + 12); [EOL]     } [EOL] } <line_num>: 117,124
@Test [EOL] public void testNextIntPositiveRange() { [EOL]     for (int i = 0; i < 5; i++) { [EOL]         checkNextIntUniform(0, 3); [EOL]         checkNextIntUniform(2, 12); [EOL]         checkNextIntUniform(1, 2); [EOL]         checkNextIntUniform(Integer.MAX_VALUE - 12, Integer.MAX_VALUE - 1); [EOL]     } [EOL] } <line_num>: 126,134
private void checkNextIntUniform(int min, int max) { [EOL]     final Frequency freq = new Frequency(); [EOL]     for (int i = 0; i < smallSampleSize; i++) { [EOL]         final int value = randomData.nextInt(min, max); [EOL]         Assert.assertTrue("nextInt range", (value >= min) && (value <= max)); [EOL]         freq.addValue(value); [EOL]     } [EOL]     final int len = max - min + 1; [EOL]     final long[] observed = new long[len]; [EOL]     for (int i = 0; i < len; i++) { [EOL]         observed[i] = freq.getCount(min + i); [EOL]     } [EOL]     final double[] expected = new double[len]; [EOL]     for (int i = 0; i < len; i++) { [EOL]         expected[i] = 1d / len; [EOL]     } [EOL]     TestUtils.assertChiSquareAccept(expected, observed, 0.001); [EOL] } <line_num>: 136,154
@Test [EOL] public void testNextIntWideRange() { [EOL]     int lower = -0x6543210F; [EOL]     int upper = 0x456789AB; [EOL]     int max = Integer.MIN_VALUE; [EOL]     int min = Integer.MAX_VALUE; [EOL]     for (int i = 0; i < 1000000; ++i) { [EOL]         int r = randomData.nextInt(lower, upper); [EOL]         max = FastMath.max(max, r); [EOL]         min = FastMath.min(min, r); [EOL]         Assert.assertTrue(r >= lower); [EOL]         Assert.assertTrue(r <= upper); [EOL]     } [EOL]     double ratio = (((double) max) - ((double) min)) / (((double) upper) - ((double) lower)); [EOL]     Assert.assertTrue(ratio > 0.99999); [EOL] } <line_num>: 156,172
@Test [EOL] public void testNextLongIAE() { [EOL]     try { [EOL]         randomData.nextLong(4, 3); [EOL]         Assert.fail("MathIllegalArgumentException expected"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 174,182
@Test [EOL] public void testNextLongNegativeToPositiveRange() { [EOL]     for (int i = 0; i < 5; i++) { [EOL]         checkNextLongUniform(-3, 5); [EOL]         checkNextLongUniform(-3, 6); [EOL]     } [EOL] } <line_num>: 184,190
@Test [EOL] public void testNextLongNegativeRange() { [EOL]     for (int i = 0; i < 5; i++) { [EOL]         checkNextLongUniform(-7, -4); [EOL]         checkNextLongUniform(-15, -2); [EOL]         checkNextLongUniform(Long.MIN_VALUE + 1, Long.MIN_VALUE + 12); [EOL]     } [EOL] } <line_num>: 192,199
@Test [EOL] public void testNextLongPositiveRange() { [EOL]     for (int i = 0; i < 5; i++) { [EOL]         checkNextLongUniform(0, 3); [EOL]         checkNextLongUniform(2, 12); [EOL]         checkNextLongUniform(Long.MAX_VALUE - 12, Long.MAX_VALUE - 1); [EOL]     } [EOL] } <line_num>: 201,208
private void checkNextLongUniform(long min, long max) { [EOL]     final Frequency freq = new Frequency(); [EOL]     for (int i = 0; i < smallSampleSize; i++) { [EOL]         final long value = randomData.nextLong(min, max); [EOL]         Assert.assertTrue("nextLong range: " + value + " " + min + " " + max, (value >= min) && (value <= max)); [EOL]         freq.addValue(value); [EOL]     } [EOL]     final int len = ((int) (max - min)) + 1; [EOL]     final long[] observed = new long[len]; [EOL]     for (int i = 0; i < len; i++) { [EOL]         observed[i] = freq.getCount(min + i); [EOL]     } [EOL]     final double[] expected = new double[len]; [EOL]     for (int i = 0; i < len; i++) { [EOL]         expected[i] = 1d / len; [EOL]     } [EOL]     TestUtils.assertChiSquareAccept(expected, observed, 0.01); [EOL] } <line_num>: 210,229
@Test [EOL] public void testNextLongWideRange() { [EOL]     long lower = -0x6543210FEDCBA987L; [EOL]     long upper = 0x456789ABCDEF0123L; [EOL]     long max = Long.MIN_VALUE; [EOL]     long min = Long.MAX_VALUE; [EOL]     for (int i = 0; i < 10000000; ++i) { [EOL]         long r = randomData.nextLong(lower, upper); [EOL]         max = FastMath.max(max, r); [EOL]         min = FastMath.min(min, r); [EOL]         Assert.assertTrue(r >= lower); [EOL]         Assert.assertTrue(r <= upper); [EOL]     } [EOL]     double ratio = (((double) max) - ((double) min)) / (((double) upper) - ((double) lower)); [EOL]     Assert.assertTrue(ratio > 0.99999); [EOL] } <line_num>: 231,247
@Test [EOL] public void testNextSecureLongIAE() { [EOL]     try { [EOL]         randomData.nextSecureLong(4, 3); [EOL]         Assert.fail("MathIllegalArgumentException expected"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 249,257
@Test [EOL] @Retry(3) [EOL] public void testNextSecureLongNegativeToPositiveRange() { [EOL]     for (int i = 0; i < 5; i++) { [EOL]         checkNextSecureLongUniform(-3, 5); [EOL]         checkNextSecureLongUniform(-3, 6); [EOL]     } [EOL] } <line_num>: 259,266
@Test [EOL] @Retry(3) [EOL] public void testNextSecureLongNegativeRange() { [EOL]     for (int i = 0; i < 5; i++) { [EOL]         checkNextSecureLongUniform(-7, -4); [EOL]         checkNextSecureLongUniform(-15, -2); [EOL]     } [EOL] } <line_num>: 268,275
@Test [EOL] @Retry(3) [EOL] public void testNextSecureLongPositiveRange() { [EOL]     for (int i = 0; i < 5; i++) { [EOL]         checkNextSecureLongUniform(0, 3); [EOL]         checkNextSecureLongUniform(2, 12); [EOL]     } [EOL] } <line_num>: 277,284
private void checkNextSecureLongUniform(int min, int max) { [EOL]     final Frequency freq = new Frequency(); [EOL]     for (int i = 0; i < smallSampleSize; i++) { [EOL]         final long value = randomData.nextSecureLong(min, max); [EOL]         Assert.assertTrue("nextLong range", (value >= min) && (value <= max)); [EOL]         freq.addValue(value); [EOL]     } [EOL]     final int len = max - min + 1; [EOL]     final long[] observed = new long[len]; [EOL]     for (int i = 0; i < len; i++) { [EOL]         observed[i] = freq.getCount(min + i); [EOL]     } [EOL]     final double[] expected = new double[len]; [EOL]     for (int i = 0; i < len; i++) { [EOL]         expected[i] = 1d / len; [EOL]     } [EOL]     TestUtils.assertChiSquareAccept(expected, observed, 0.0001); [EOL] } <line_num>: 286,304
@Test [EOL] public void testNextSecureIntIAE() { [EOL]     try { [EOL]         randomData.nextSecureInt(4, 3); [EOL]         Assert.fail("MathIllegalArgumentException expected"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 306,314
@Test [EOL] @Retry(3) [EOL] public void testNextSecureIntNegativeToPositiveRange() { [EOL]     for (int i = 0; i < 5; i++) { [EOL]         checkNextSecureIntUniform(-3, 5); [EOL]         checkNextSecureIntUniform(-3, 6); [EOL]     } [EOL] } <line_num>: 316,323
@Test [EOL] @Retry(3) [EOL] public void testNextSecureIntNegativeRange() { [EOL]     for (int i = 0; i < 5; i++) { [EOL]         checkNextSecureIntUniform(-7, -4); [EOL]         checkNextSecureIntUniform(-15, -2); [EOL]     } [EOL] } <line_num>: 325,332
@Test [EOL] @Retry(3) [EOL] public void testNextSecureIntPositiveRange() { [EOL]     for (int i = 0; i < 5; i++) { [EOL]         checkNextSecureIntUniform(0, 3); [EOL]         checkNextSecureIntUniform(2, 12); [EOL]     } [EOL] } <line_num>: 334,341
private void checkNextSecureIntUniform(int min, int max) { [EOL]     final Frequency freq = new Frequency(); [EOL]     for (int i = 0; i < smallSampleSize; i++) { [EOL]         final int value = randomData.nextSecureInt(min, max); [EOL]         Assert.assertTrue("nextInt range", (value >= min) && (value <= max)); [EOL]         freq.addValue(value); [EOL]     } [EOL]     final int len = max - min + 1; [EOL]     final long[] observed = new long[len]; [EOL]     for (int i = 0; i < len; i++) { [EOL]         observed[i] = freq.getCount(min + i); [EOL]     } [EOL]     final double[] expected = new double[len]; [EOL]     for (int i = 0; i < len; i++) { [EOL]         expected[i] = 1d / len; [EOL]     } [EOL]     TestUtils.assertChiSquareAccept(expected, observed, 0.0001); [EOL] } <line_num>: 343,361
@Test [EOL] public void testNextPoisson() { [EOL]     try { [EOL]         randomData.nextPoisson(0); [EOL]         Assert.fail("zero mean -- expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         randomData.nextPoisson(-1); [EOL]         Assert.fail("negative mean supplied -- MathIllegalArgumentException expected"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         randomData.nextPoisson(0); [EOL]         Assert.fail("0 mean supplied -- MathIllegalArgumentException expected"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     final double mean = 4.0d; [EOL]     final int len = 5; [EOL]     PoissonDistribution poissonDistribution = new PoissonDistribution(mean); [EOL]     Frequency f = new Frequency(); [EOL]     randomData.reSeed(1000); [EOL]     for (int i = 0; i < largeSampleSize; i++) { [EOL]         f.addValue(randomData.nextPoisson(mean)); [EOL]     } [EOL]     final long[] observed = new long[len]; [EOL]     for (int i = 0; i < len; i++) { [EOL]         observed[i] = f.getCount(i + 1); [EOL]     } [EOL]     final double[] expected = new double[len]; [EOL]     for (int i = 0; i < len; i++) { [EOL]         expected[i] = poissonDistribution.probability(i + 1) * largeSampleSize; [EOL]     } [EOL]     TestUtils.assertChiSquareAccept(expected, observed, 0.0001); [EOL] } <line_num>: 370,409
@Test [EOL] public void testNextPoissonConsistency() { [EOL]     for (int i = 1; i < 100; i++) { [EOL]         checkNextPoissonConsistency(i); [EOL]     } [EOL]     for (int i = 1; i < 10; i++) { [EOL]         checkNextPoissonConsistency(randomData.nextUniform(1, 1000)); [EOL]     } [EOL]     for (int i = 1; i < 10; i++) { [EOL]         checkNextPoissonConsistency(randomData.nextUniform(1000, 10000)); [EOL]     } [EOL] } <line_num>: 411,426
public void checkNextPoissonConsistency(double mean) { [EOL]     final int sampleSize = 1000; [EOL]     final int minExpectedCount = 7; [EOL]     long maxObservedValue = 0; [EOL]     final double alpha = 0.001; [EOL]     Frequency frequency = new Frequency(); [EOL]     for (int i = 0; i < sampleSize; i++) { [EOL]         long value = randomData.nextPoisson(mean); [EOL]         if (value > maxObservedValue) { [EOL]             maxObservedValue = value; [EOL]         } [EOL]         frequency.addValue(value); [EOL]     } [EOL]     PoissonDistribution poissonDistribution = new PoissonDistribution(mean); [EOL]     int lower = 1; [EOL]     while (poissonDistribution.cumulativeProbability(lower - 1) * sampleSize < minExpectedCount) { [EOL]         lower++; [EOL]     } [EOL]     int upper = (int) (5 * mean); [EOL]     while ((1 - poissonDistribution.cumulativeProbability(upper - 1)) * sampleSize < minExpectedCount) { [EOL]         upper--; [EOL]     } [EOL]     int binWidth = 0; [EOL]     boolean widthSufficient = false; [EOL]     double lowerBinMass = 0; [EOL]     double upperBinMass = 0; [EOL]     while (!widthSufficient) { [EOL]         binWidth++; [EOL]         lowerBinMass = poissonDistribution.cumulativeProbability(lower - 1, lower + binWidth - 1); [EOL]         upperBinMass = poissonDistribution.cumulativeProbability(upper - binWidth - 1, upper - 1); [EOL]         widthSufficient = FastMath.min(lowerBinMass, upperBinMass) * sampleSize >= minExpectedCount; [EOL]     } [EOL]     List<Integer> binBounds = new ArrayList<Integer>(); [EOL]     binBounds.add(lower); [EOL]     int bound = lower + binWidth; [EOL]     while (bound < upper - binWidth) { [EOL]         binBounds.add(bound); [EOL]         bound += binWidth; [EOL]     } [EOL]     binBounds.add(upper); [EOL]     final int binCount = binBounds.size() + 1; [EOL]     long[] observed = new long[binCount]; [EOL]     double[] expected = new double[binCount]; [EOL]     observed[0] = 0; [EOL]     for (int i = 0; i < lower; i++) { [EOL]         observed[0] += frequency.getCount(i); [EOL]     } [EOL]     expected[0] = poissonDistribution.cumulativeProbability(lower - 1) * sampleSize; [EOL]     observed[binCount - 1] = 0; [EOL]     for (int i = upper; i <= maxObservedValue; i++) { [EOL]         observed[binCount - 1] += frequency.getCount(i); [EOL]     } [EOL]     expected[binCount - 1] = (1 - poissonDistribution.cumulativeProbability(upper - 1)) * sampleSize; [EOL]     for (int i = 1; i < binCount - 1; i++) { [EOL]         observed[i] = 0; [EOL]         for (int j = binBounds.get(i - 1); j < binBounds.get(i); j++) { [EOL]             observed[i] += frequency.getCount(j); [EOL]         } [EOL]         expected[i] = (poissonDistribution.cumulativeProbability(binBounds.get(i) - 1) - poissonDistribution.cumulativeProbability(binBounds.get(i - 1) - 1)) * sampleSize; [EOL]     } [EOL]     ChiSquareTest chiSquareTest = new ChiSquareTest(); [EOL]     if (chiSquareTest.chiSquareTest(expected, observed, alpha)) { [EOL]         StringBuilder msgBuffer = new StringBuilder(); [EOL]         DecimalFormat df = new DecimalFormat("#.##"); [EOL]         msgBuffer.append("Chisquare test failed for mean = "); [EOL]         msgBuffer.append(mean); [EOL]         msgBuffer.append(" p-value = "); [EOL]         msgBuffer.append(chiSquareTest.chiSquareTest(expected, observed)); [EOL]         msgBuffer.append(" chisquare statistic = "); [EOL]         msgBuffer.append(chiSquareTest.chiSquare(expected, observed)); [EOL]         msgBuffer.append(". \n"); [EOL]         msgBuffer.append("bin\t\texpected\tobserved\n"); [EOL]         for (int i = 0; i < expected.length; i++) { [EOL]             msgBuffer.append("["); [EOL]             msgBuffer.append(i == 0 ? 1 : binBounds.get(i - 1)); [EOL]             msgBuffer.append(","); [EOL]             msgBuffer.append(i == binBounds.size() ? "inf" : binBounds.get(i)); [EOL]             msgBuffer.append(")"); [EOL]             msgBuffer.append("\t\t"); [EOL]             msgBuffer.append(df.format(expected[i])); [EOL]             msgBuffer.append("\t\t"); [EOL]             msgBuffer.append(observed[i]); [EOL]             msgBuffer.append("\n"); [EOL]         } [EOL]         msgBuffer.append("This test can fail randomly due to sampling error with probability "); [EOL]         msgBuffer.append(alpha); [EOL]         msgBuffer.append("."); [EOL]         Assert.fail(msgBuffer.toString()); [EOL]     } [EOL] } <line_num>: 437,555
@Test [EOL] public void testNextHex() { [EOL]     try { [EOL]         randomData.nextHexString(-1); [EOL]         Assert.fail("negative length supplied -- MathIllegalArgumentException expected"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         randomData.nextHexString(0); [EOL]         Assert.fail("zero length supplied -- MathIllegalArgumentException expected"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     String hexString = randomData.nextHexString(3); [EOL]     if (hexString.length() != 3) { [EOL]         Assert.fail("incorrect length for generated string"); [EOL]     } [EOL]     hexString = randomData.nextHexString(1); [EOL]     if (hexString.length() != 1) { [EOL]         Assert.fail("incorrect length for generated string"); [EOL]     } [EOL]     try { [EOL]         hexString = randomData.nextHexString(0); [EOL]         Assert.fail("zero length requested -- expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     Frequency f = new Frequency(); [EOL]     for (int i = 0; i < smallSampleSize; i++) { [EOL]         hexString = randomData.nextHexString(100); [EOL]         if (hexString.length() != 100) { [EOL]             Assert.fail("incorrect length for generated string"); [EOL]         } [EOL]         for (int j = 0; j < hexString.length(); j++) { [EOL]             f.addValue(hexString.substring(j, j + 1)); [EOL]         } [EOL]     } [EOL]     double[] expected = new double[16]; [EOL]     long[] observed = new long[16]; [EOL]     for (int i = 0; i < 16; i++) { [EOL]         expected[i] = (double) smallSampleSize * 100 / 16; [EOL]         observed[i] = f.getCount(hex[i]); [EOL]     } [EOL]     TestUtils.assertChiSquareAccept(expected, observed, 0.001); [EOL] } <line_num>: 558,603
@Test [EOL] @Retry(3) [EOL] public void testNextSecureHex() { [EOL]     try { [EOL]         randomData.nextSecureHexString(-1); [EOL]         Assert.fail("negative length -- MathIllegalArgumentException expected"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         randomData.nextSecureHexString(0); [EOL]         Assert.fail("zero length -- MathIllegalArgumentException expected"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     String hexString = randomData.nextSecureHexString(3); [EOL]     if (hexString.length() != 3) { [EOL]         Assert.fail("incorrect length for generated string"); [EOL]     } [EOL]     hexString = randomData.nextSecureHexString(1); [EOL]     if (hexString.length() != 1) { [EOL]         Assert.fail("incorrect length for generated string"); [EOL]     } [EOL]     try { [EOL]         hexString = randomData.nextSecureHexString(0); [EOL]         Assert.fail("zero length requested -- expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     Frequency f = new Frequency(); [EOL]     for (int i = 0; i < smallSampleSize; i++) { [EOL]         hexString = randomData.nextSecureHexString(100); [EOL]         if (hexString.length() != 100) { [EOL]             Assert.fail("incorrect length for generated string"); [EOL]         } [EOL]         for (int j = 0; j < hexString.length(); j++) { [EOL]             f.addValue(hexString.substring(j, j + 1)); [EOL]         } [EOL]     } [EOL]     double[] expected = new double[16]; [EOL]     long[] observed = new long[16]; [EOL]     for (int i = 0; i < 16; i++) { [EOL]         expected[i] = (double) smallSampleSize * 100 / 16; [EOL]         observed[i] = f.getCount(hex[i]); [EOL]     } [EOL]     TestUtils.assertChiSquareAccept(expected, observed, 0.001); [EOL] } <line_num>: 606,652
@Test [EOL] public void testNextUniformIAE() { [EOL]     try { [EOL]         randomData.nextUniform(4, 3); [EOL]         Assert.fail("MathIllegalArgumentException expected"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         randomData.nextUniform(0, Double.POSITIVE_INFINITY); [EOL]         Assert.fail("MathIllegalArgumentException expected"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         randomData.nextUniform(Double.NEGATIVE_INFINITY, 0); [EOL]         Assert.fail("MathIllegalArgumentException expected"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         randomData.nextUniform(0, Double.NaN); [EOL]         Assert.fail("MathIllegalArgumentException expected"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         randomData.nextUniform(Double.NaN, 0); [EOL]         Assert.fail("MathIllegalArgumentException expected"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 654,686
@Test [EOL] public void testNextUniformUniformPositiveBounds() { [EOL]     for (int i = 0; i < 5; i++) { [EOL]         checkNextUniformUniform(0, 10); [EOL]     } [EOL] } <line_num>: 688,693
@Test [EOL] public void testNextUniformUniformNegativeToPositiveBounds() { [EOL]     for (int i = 0; i < 5; i++) { [EOL]         checkNextUniformUniform(-3, 5); [EOL]     } [EOL] } <line_num>: 695,700
@Test [EOL] public void testNextUniformUniformNegaiveBounds() { [EOL]     for (int i = 0; i < 5; i++) { [EOL]         checkNextUniformUniform(-7, -3); [EOL]     } [EOL] } <line_num>: 702,707
@Test [EOL] public void testNextUniformUniformMaximalInterval() { [EOL]     for (int i = 0; i < 5; i++) { [EOL]         checkNextUniformUniform(-Double.MAX_VALUE, Double.MAX_VALUE); [EOL]     } [EOL] } <line_num>: 709,714
private void checkNextUniformUniform(double min, double max) { [EOL]     final int binCount = 5; [EOL]     final double binSize = max / binCount - min / binCount; [EOL]     final double[] binBounds = new double[binCount - 1]; [EOL]     binBounds[0] = min + binSize; [EOL]     for (int i = 1; i < binCount - 1; i++) { [EOL]         binBounds[i] = binBounds[i - 1] + binSize; [EOL]     } [EOL]     final Frequency freq = new Frequency(); [EOL]     for (int i = 0; i < smallSampleSize; i++) { [EOL]         final double value = randomData.nextUniform(min, max); [EOL]         Assert.assertTrue("nextUniform range", (value > min) && (value < max)); [EOL]         int j = 0; [EOL]         while (j < binCount - 1 && value > binBounds[j]) { [EOL]             j++; [EOL]         } [EOL]         freq.addValue(j); [EOL]     } [EOL]     final long[] observed = new long[binCount]; [EOL]     for (int i = 0; i < binCount; i++) { [EOL]         observed[i] = freq.getCount(i); [EOL]     } [EOL]     final double[] expected = new double[binCount]; [EOL]     for (int i = 0; i < binCount; i++) { [EOL]         expected[i] = 1d / binCount; [EOL]     } [EOL]     TestUtils.assertChiSquareAccept(expected, observed, 0.01); [EOL] } <line_num>: 716,748
@Test [EOL] public void testNextUniformExclusiveEndpoints() { [EOL]     for (int i = 0; i < 1000; i++) { [EOL]         double u = randomData.nextUniform(0.99, 1); [EOL]         Assert.assertTrue(u > 0.99 && u < 1); [EOL]     } [EOL] } <line_num>: 751,757
@Test [EOL] public void testNextGaussian() { [EOL]     try { [EOL]         randomData.nextGaussian(0, 0); [EOL]         Assert.fail("zero sigma -- MathIllegalArgumentException expected"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     double[] quartiles = TestUtils.getDistributionQuartiles(new NormalDistribution(0, 1)); [EOL]     long[] counts = new long[4]; [EOL]     randomData.reSeed(1000); [EOL]     for (int i = 0; i < 1000; i++) { [EOL]         double value = randomData.nextGaussian(0, 1); [EOL]         TestUtils.updateCounts(value, counts, quartiles); [EOL]     } [EOL]     TestUtils.assertChiSquareAccept(expected, counts, 0.001); [EOL] } <line_num>: 760,776
@Test [EOL] public void testNextExponential() { [EOL]     try { [EOL]         randomData.nextExponential(-1); [EOL]         Assert.fail("negative mean -- expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         randomData.nextExponential(0); [EOL]         Assert.fail("zero mean -- expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     double[] quartiles; [EOL]     long[] counts; [EOL]     quartiles = TestUtils.getDistributionQuartiles(new ExponentialDistribution(1)); [EOL]     counts = new long[4]; [EOL]     randomData.reSeed(1000); [EOL]     for (int i = 0; i < 1000; i++) { [EOL]         double value = randomData.nextExponential(1); [EOL]         TestUtils.updateCounts(value, counts, quartiles); [EOL]     } [EOL]     TestUtils.assertChiSquareAccept(expected, counts, 0.001); [EOL]     quartiles = TestUtils.getDistributionQuartiles(new ExponentialDistribution(5)); [EOL]     counts = new long[4]; [EOL]     randomData.reSeed(1000); [EOL]     for (int i = 0; i < 1000; i++) { [EOL]         double value = randomData.nextExponential(5); [EOL]         TestUtils.updateCounts(value, counts, quartiles); [EOL]     } [EOL]     TestUtils.assertChiSquareAccept(expected, counts, 0.001); [EOL] } <line_num>: 779,815
@Test [EOL] public void testConfig() { [EOL]     randomData.reSeed(1000); [EOL]     double v = randomData.nextUniform(0, 1); [EOL]     randomData.reSeed(); [EOL]     Assert.assertTrue("different seeds", Math.abs(v - randomData.nextUniform(0, 1)) > 10E-12); [EOL]     randomData.reSeed(1000); [EOL]     Assert.assertEquals("same seeds", v, randomData.nextUniform(0, 1), 10E-12); [EOL]     randomData.reSeedSecure(1000); [EOL]     String hex = randomData.nextSecureHexString(40); [EOL]     randomData.reSeedSecure(); [EOL]     Assert.assertTrue("different seeds", !hex.equals(randomData.nextSecureHexString(40))); [EOL]     randomData.reSeedSecure(1000); [EOL]     Assert.assertTrue("same seeds", !hex.equals(randomData.nextSecureHexString(40))); [EOL]     RandomDataGenerator rd = new RandomDataGenerator(); [EOL]     rd.reSeed(100); [EOL]     rd.nextLong(1, 2); [EOL]     RandomDataGenerator rd2 = new RandomDataGenerator(); [EOL]     rd2.reSeedSecure(2000); [EOL]     rd2.nextSecureLong(1, 2); [EOL]     rd = new RandomDataGenerator(); [EOL]     rd.reSeed(); [EOL]     rd.nextLong(1, 2); [EOL]     rd2 = new RandomDataGenerator(); [EOL]     rd2.reSeedSecure(); [EOL]     rd2.nextSecureLong(1, 2); [EOL] } <line_num>: 818,865
@Test [EOL] public void testNextSample() { [EOL]     Object[][] c = { { "0", "1" }, { "0", "2" }, { "0", "3" }, { "0", "4" }, { "1", "2" }, { "1", "3" }, { "1", "4" }, { "2", "3" }, { "2", "4" }, { "3", "4" } }; [EOL]     long[] observed = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; [EOL]     double[] expected = { 100, 100, 100, 100, 100, 100, 100, 100, 100, 100 }; [EOL]     HashSet<Object> cPop = new HashSet<Object>(); [EOL]     for (int i = 0; i < 5; i++) { [EOL]         cPop.add(Integer.toString(i)); [EOL]     } [EOL]     Object[] sets = new Object[10]; [EOL]     for (int i = 0; i < 10; i++) { [EOL]         HashSet<Object> hs = new HashSet<Object>(); [EOL]         hs.add(c[i][0]); [EOL]         hs.add(c[i][1]); [EOL]         sets[i] = hs; [EOL]     } [EOL]     for (int i = 0; i < 1000; i++) { [EOL]         Object[] cSamp = randomData.nextSample(cPop, 2); [EOL]         observed[findSample(sets, cSamp)]++; [EOL]     } [EOL]     Assert.assertTrue("chi-square test -- will fail about 1 in 1000 times", testStatistic.chiSquare(expected, observed) < 27.88); [EOL]     HashSet<Object> hs = new HashSet<Object>(); [EOL]     hs.add("one"); [EOL]     Object[] one = randomData.nextSample(hs, 1); [EOL]     String oneString = (String) one[0]; [EOL]     if ((one.length != 1) || !oneString.equals("one")) { [EOL]         Assert.fail("bad sample for set size = 1, sample size = 1"); [EOL]     } [EOL]     try { [EOL]         one = randomData.nextSample(hs, 2); [EOL]         Assert.fail("sample size > set size, expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         hs = new HashSet<Object>(); [EOL]         one = randomData.nextSample(hs, 0); [EOL]         Assert.fail("n = k = 0, expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 868,926
@SuppressWarnings("unchecked") [EOL] private int findSample(Object[] u, Object[] samp) { [EOL]     for (int i = 0; i < u.length; i++) { [EOL]         HashSet<Object> set = (HashSet<Object>) u[i]; [EOL]         HashSet<Object> sampSet = new HashSet<Object>(); [EOL]         for (int j = 0; j < samp.length; j++) { [EOL]             sampSet.add(samp[j]); [EOL]         } [EOL]         if (set.equals(sampSet)) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     Assert.fail("sample not found:{" + samp[0] + "," + samp[1] + "}"); [EOL]     return -1; [EOL] } <line_num>: 928,942
@Test [EOL] public void testNextPermutation() { [EOL]     int[][] p = { { 0, 1, 2 }, { 0, 2, 1 }, { 1, 0, 2 }, { 1, 2, 0 }, { 2, 0, 1 }, { 2, 1, 0 } }; [EOL]     long[] observed = { 0, 0, 0, 0, 0, 0 }; [EOL]     double[] expected = { 100, 100, 100, 100, 100, 100 }; [EOL]     for (int i = 0; i < 600; i++) { [EOL]         int[] perm = randomData.nextPermutation(3, 3); [EOL]         observed[findPerm(p, perm)]++; [EOL]     } [EOL]     String[] labels = { "{0, 1, 2}", "{ 0, 2, 1 }", "{ 1, 0, 2 }", "{ 1, 2, 0 }", "{ 2, 0, 1 }", "{ 2, 1, 0 }" }; [EOL]     TestUtils.assertChiSquareAccept(labels, expected, observed, 0.001); [EOL]     int[] perm = randomData.nextPermutation(1, 1); [EOL]     if ((perm.length != 1) || (perm[0] != 0)) { [EOL]         Assert.fail("bad permutation for n = 1, sample k = 1"); [EOL]         try { [EOL]             perm = randomData.nextPermutation(2, 3); [EOL]             Assert.fail("permutation k > n, expecting MathIllegalArgumentException"); [EOL]         } catch (MathIllegalArgumentException ex) { [EOL]         } [EOL]         try { [EOL]             perm = randomData.nextPermutation(0, 0); [EOL]             Assert.fail("permutation k = n = 0, expecting MathIllegalArgumentException"); [EOL]         } catch (MathIllegalArgumentException ex) { [EOL]         } [EOL]         try { [EOL]             perm = randomData.nextPermutation(-1, -3); [EOL]             Assert.fail("permutation k < n < 0, expecting MathIllegalArgumentException"); [EOL]         } catch (MathIllegalArgumentException ex) { [EOL]         } [EOL]     } [EOL] } <line_num>: 945,991
private int findPerm(int[][] p, int[] samp) { [EOL]     for (int i = 0; i < p.length; i++) { [EOL]         boolean good = true; [EOL]         for (int j = 0; j < samp.length; j++) { [EOL]             if (samp[j] != p[i][j]) { [EOL]                 good = false; [EOL]             } [EOL]         } [EOL]         if (good) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     Assert.fail("permutation not found"); [EOL]     return -1; [EOL] } <line_num>: 998,1012
@Test [EOL] public void testNextInversionDeviate() { [EOL]     RandomGenerator rg = new Well19937c(100); [EOL]     RandomDataGenerator rdg = new RandomDataGenerator(rg); [EOL]     double[] quantiles = new double[10]; [EOL]     for (int i = 0; i < 10; i++) { [EOL]         quantiles[i] = rdg.nextUniform(0, 1); [EOL]     } [EOL]     rg.setSeed(100); [EOL]     BetaDistribution betaDistribution = new BetaDistribution(rg, 2, 4, BetaDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY); [EOL]     for (int i = 0; i < 10; i++) { [EOL]         double value = betaDistribution.sample(); [EOL]         Assert.assertEquals(betaDistribution.cumulativeProbability(value), quantiles[i], 10E-9); [EOL]     } [EOL] } <line_num>: 1014,1036
@Test [EOL] public void testNextBeta() { [EOL]     double[] quartiles = TestUtils.getDistributionQuartiles(new BetaDistribution(2, 5)); [EOL]     long[] counts = new long[4]; [EOL]     randomData.reSeed(1000); [EOL]     for (int i = 0; i < 1000; i++) { [EOL]         double value = randomData.nextBeta(2, 5); [EOL]         TestUtils.updateCounts(value, counts, quartiles); [EOL]     } [EOL]     TestUtils.assertChiSquareAccept(expected, counts, 0.001); [EOL] } <line_num>: 1038,1048
@Test [EOL] public void testNextCauchy() { [EOL]     double[] quartiles = TestUtils.getDistributionQuartiles(new CauchyDistribution(1.2, 2.1)); [EOL]     long[] counts = new long[4]; [EOL]     randomData.reSeed(1000); [EOL]     for (int i = 0; i < 1000; i++) { [EOL]         double value = randomData.nextCauchy(1.2, 2.1); [EOL]         TestUtils.updateCounts(value, counts, quartiles); [EOL]     } [EOL]     TestUtils.assertChiSquareAccept(expected, counts, 0.001); [EOL] } <line_num>: 1050,1060
@Test [EOL] public void testNextChiSquare() { [EOL]     double[] quartiles = TestUtils.getDistributionQuartiles(new ChiSquaredDistribution(12)); [EOL]     long[] counts = new long[4]; [EOL]     randomData.reSeed(1000); [EOL]     for (int i = 0; i < 1000; i++) { [EOL]         double value = randomData.nextChiSquare(12); [EOL]         TestUtils.updateCounts(value, counts, quartiles); [EOL]     } [EOL]     TestUtils.assertChiSquareAccept(expected, counts, 0.001); [EOL] } <line_num>: 1062,1072
@Test [EOL] public void testNextF() { [EOL]     double[] quartiles = TestUtils.getDistributionQuartiles(new FDistribution(12, 5)); [EOL]     long[] counts = new long[4]; [EOL]     randomData.reSeed(1000); [EOL]     for (int i = 0; i < 1000; i++) { [EOL]         double value = randomData.nextF(12, 5); [EOL]         TestUtils.updateCounts(value, counts, quartiles); [EOL]     } [EOL]     TestUtils.assertChiSquareAccept(expected, counts, 0.001); [EOL] } <line_num>: 1074,1084
@Test [EOL] public void testNextGamma() { [EOL]     double[] quartiles; [EOL]     long[] counts; [EOL]     quartiles = TestUtils.getDistributionQuartiles(new GammaDistribution(4, 2)); [EOL]     counts = new long[4]; [EOL]     randomData.reSeed(1000); [EOL]     for (int i = 0; i < 1000; i++) { [EOL]         double value = randomData.nextGamma(4, 2); [EOL]         TestUtils.updateCounts(value, counts, quartiles); [EOL]     } [EOL]     TestUtils.assertChiSquareAccept(expected, counts, 0.001); [EOL]     quartiles = TestUtils.getDistributionQuartiles(new GammaDistribution(0.3, 3)); [EOL]     counts = new long[4]; [EOL]     randomData.reSeed(1000); [EOL]     for (int i = 0; i < 1000; i++) { [EOL]         double value = randomData.nextGamma(0.3, 3); [EOL]         TestUtils.updateCounts(value, counts, quartiles); [EOL]     } [EOL]     TestUtils.assertChiSquareAccept(expected, counts, 0.001); [EOL] } <line_num>: 1086,1110
@Test [EOL] public void testNextT() { [EOL]     double[] quartiles = TestUtils.getDistributionQuartiles(new TDistribution(10)); [EOL]     long[] counts = new long[4]; [EOL]     randomData.reSeed(1000); [EOL]     for (int i = 0; i < 1000; i++) { [EOL]         double value = randomData.nextT(10); [EOL]         TestUtils.updateCounts(value, counts, quartiles); [EOL]     } [EOL]     TestUtils.assertChiSquareAccept(expected, counts, 0.001); [EOL] } <line_num>: 1112,1122
@Test [EOL] public void testNextWeibull() { [EOL]     double[] quartiles = TestUtils.getDistributionQuartiles(new WeibullDistribution(1.2, 2.1)); [EOL]     long[] counts = new long[4]; [EOL]     randomData.reSeed(1000); [EOL]     for (int i = 0; i < 1000; i++) { [EOL]         double value = randomData.nextWeibull(1.2, 2.1); [EOL]         TestUtils.updateCounts(value, counts, quartiles); [EOL]     } [EOL]     TestUtils.assertChiSquareAccept(expected, counts, 0.001); [EOL] } <line_num>: 1124,1134
@Test [EOL] public void testNextBinomial() { [EOL]     BinomialDistributionTest testInstance = new BinomialDistributionTest(); [EOL]     int[] densityPoints = testInstance.makeDensityTestPoints(); [EOL]     double[] densityValues = testInstance.makeDensityTestValues(); [EOL]     int sampleSize = 1000; [EOL]     int length = TestUtils.eliminateZeroMassPoints(densityPoints, densityValues); [EOL]     BinomialDistribution distribution = (BinomialDistribution) testInstance.makeDistribution(); [EOL]     double[] expectedCounts = new double[length]; [EOL]     long[] observedCounts = new long[length]; [EOL]     for (int i = 0; i < length; i++) { [EOL]         expectedCounts[i] = sampleSize * densityValues[i]; [EOL]     } [EOL]     randomData.reSeed(1000); [EOL]     for (int i = 0; i < sampleSize; i++) { [EOL]         int value = randomData.nextBinomial(distribution.getNumberOfTrials(), distribution.getProbabilityOfSuccess()); [EOL]         for (int j = 0; j < length; j++) { [EOL]             if (value == densityPoints[j]) { [EOL]                 observedCounts[j]++; [EOL]             } [EOL]         } [EOL]     } [EOL]     TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001); [EOL] } <line_num>: 1136,1160
@Test [EOL] public void testNextHypergeometric() { [EOL]     HypergeometricDistributionTest testInstance = new HypergeometricDistributionTest(); [EOL]     int[] densityPoints = testInstance.makeDensityTestPoints(); [EOL]     double[] densityValues = testInstance.makeDensityTestValues(); [EOL]     int sampleSize = 1000; [EOL]     int length = TestUtils.eliminateZeroMassPoints(densityPoints, densityValues); [EOL]     HypergeometricDistribution distribution = (HypergeometricDistribution) testInstance.makeDistribution(); [EOL]     double[] expectedCounts = new double[length]; [EOL]     long[] observedCounts = new long[length]; [EOL]     for (int i = 0; i < length; i++) { [EOL]         expectedCounts[i] = sampleSize * densityValues[i]; [EOL]     } [EOL]     randomData.reSeed(1000); [EOL]     for (int i = 0; i < sampleSize; i++) { [EOL]         int value = randomData.nextHypergeometric(distribution.getPopulationSize(), distribution.getNumberOfSuccesses(), distribution.getSampleSize()); [EOL]         for (int j = 0; j < length; j++) { [EOL]             if (value == densityPoints[j]) { [EOL]                 observedCounts[j]++; [EOL]             } [EOL]         } [EOL]     } [EOL]     TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001); [EOL] } <line_num>: 1162,1186
@Test [EOL] public void testNextPascal() { [EOL]     PascalDistributionTest testInstance = new PascalDistributionTest(); [EOL]     int[] densityPoints = testInstance.makeDensityTestPoints(); [EOL]     double[] densityValues = testInstance.makeDensityTestValues(); [EOL]     int sampleSize = 1000; [EOL]     int length = TestUtils.eliminateZeroMassPoints(densityPoints, densityValues); [EOL]     PascalDistribution distribution = (PascalDistribution) testInstance.makeDistribution(); [EOL]     double[] expectedCounts = new double[length]; [EOL]     long[] observedCounts = new long[length]; [EOL]     for (int i = 0; i < length; i++) { [EOL]         expectedCounts[i] = sampleSize * densityValues[i]; [EOL]     } [EOL]     randomData.reSeed(1000); [EOL]     for (int i = 0; i < sampleSize; i++) { [EOL]         int value = randomData.nextPascal(distribution.getNumberOfSuccesses(), distribution.getProbabilityOfSuccess()); [EOL]         for (int j = 0; j < length; j++) { [EOL]             if (value == densityPoints[j]) { [EOL]                 observedCounts[j]++; [EOL]             } [EOL]         } [EOL]     } [EOL]     TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001); [EOL] } <line_num>: 1188,1211
@Test [EOL] public void testNextZipf() { [EOL]     ZipfDistributionTest testInstance = new ZipfDistributionTest(); [EOL]     int[] densityPoints = testInstance.makeDensityTestPoints(); [EOL]     double[] densityValues = testInstance.makeDensityTestValues(); [EOL]     int sampleSize = 1000; [EOL]     int length = TestUtils.eliminateZeroMassPoints(densityPoints, densityValues); [EOL]     ZipfDistribution distribution = (ZipfDistribution) testInstance.makeDistribution(); [EOL]     double[] expectedCounts = new double[length]; [EOL]     long[] observedCounts = new long[length]; [EOL]     for (int i = 0; i < length; i++) { [EOL]         expectedCounts[i] = sampleSize * densityValues[i]; [EOL]     } [EOL]     randomData.reSeed(1000); [EOL]     for (int i = 0; i < sampleSize; i++) { [EOL]         int value = randomData.nextZipf(distribution.getNumberOfElements(), distribution.getExponent()); [EOL]         for (int j = 0; j < length; j++) { [EOL]             if (value == densityPoints[j]) { [EOL]                 observedCounts[j]++; [EOL]             } [EOL]         } [EOL]     } [EOL]     TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001); [EOL] } <line_num>: 1213,1236
@Test [EOL] public void testReseed() { [EOL]     PoissonDistribution x = new PoissonDistribution(3.0); [EOL]     x.reseedRandomGenerator(0); [EOL]     final double u = x.sample(); [EOL]     PoissonDistribution y = new PoissonDistribution(3.0); [EOL]     y.reseedRandomGenerator(0); [EOL]     Assert.assertEquals(u, y.sample(), 0); [EOL] } <line_num>: 1238,1249
