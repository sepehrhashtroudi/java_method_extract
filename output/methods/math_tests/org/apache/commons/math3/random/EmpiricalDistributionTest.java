public ConstantKernelEmpiricalDistribution(int i) { [EOL]     super(i); [EOL] } <line_num>: 499,501
public UniformKernelEmpiricalDistribution(int i) { [EOL]     super(i); [EOL] } <line_num>: 514,516
public ConstantDistribution(double c) { [EOL]     this.c = c; [EOL] } <line_num>: 533,535
@Override [EOL] @Before [EOL] public void setUp() { [EOL]     super.setUp(); [EOL]     empiricalDistribution = new EmpiricalDistribution(100); [EOL]     url = getClass().getResource("testData.txt"); [EOL]     final ArrayList<Double> list = new ArrayList<Double>(); [EOL]     try { [EOL]         empiricalDistribution2 = new EmpiricalDistribution(100); [EOL]         BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream())); [EOL]         String str = null; [EOL]         while ((str = in.readLine()) != null) { [EOL]             list.add(Double.valueOf(str)); [EOL]         } [EOL]         in.close(); [EOL]         in = null; [EOL]     } catch (IOException ex) { [EOL]         Assert.fail("IOException " + ex); [EOL]     } [EOL]     dataArray = new double[list.size()]; [EOL]     int i = 0; [EOL]     for (Double data : list) { [EOL]         dataArray[i] = data.doubleValue(); [EOL]         i++; [EOL]     } [EOL] } <line_num>: 58,88
@Test [EOL] public void testLoad() throws Exception { [EOL]     empiricalDistribution.load(url); [EOL]     checkDistribution(); [EOL]     File file = new File(url.toURI()); [EOL]     empiricalDistribution.load(file); [EOL]     checkDistribution(); [EOL] } <line_num>: 95,105
private void checkDistribution() { [EOL]     Assert.assertEquals(empiricalDistribution.getSampleStats().getN(), 1000, 10E-7); [EOL]     Assert.assertEquals(empiricalDistribution.getSampleStats().getMean(), 5.069831575018909, 10E-7); [EOL]     Assert.assertEquals(empiricalDistribution.getSampleStats().getStandardDeviation(), 1.0173699343977738, 10E-7); [EOL] } <line_num>: 107,116
@Test [EOL] public void testDoubleLoad() throws Exception { [EOL]     empiricalDistribution2.load(dataArray); [EOL]     Assert.assertEquals(empiricalDistribution2.getSampleStats().getN(), 1000, 10E-7); [EOL]     Assert.assertEquals(empiricalDistribution2.getSampleStats().getMean(), 5.069831575018909, 10E-7); [EOL]     Assert.assertEquals(empiricalDistribution2.getSampleStats().getStandardDeviation(), 1.0173699343977738, 10E-7); [EOL]     double[] bounds = empiricalDistribution2.getGeneratorUpperBounds(); [EOL]     Assert.assertEquals(bounds.length, 100); [EOL]     Assert.assertEquals(bounds[99], 1.0, 10e-12); [EOL] } <line_num>: 124,140
@Test [EOL] public void testNext() throws Exception { [EOL]     tstGen(0.1); [EOL]     tstDoubleGen(0.1); [EOL] } <line_num>: 147,151
@Test [EOL] public void testNexFail() { [EOL]     try { [EOL]         empiricalDistribution.getNextValue(); [EOL]         empiricalDistribution2.getNextValue(); [EOL]         Assert.fail("Expecting IllegalStateException"); [EOL]     } catch (IllegalStateException ex) { [EOL]     } [EOL] } <line_num>: 157,166
@Test [EOL] public void testGridTooFine() throws Exception { [EOL]     empiricalDistribution = new EmpiricalDistribution(1001); [EOL]     tstGen(0.1); [EOL]     empiricalDistribution2 = new EmpiricalDistribution(1001); [EOL]     tstDoubleGen(0.1); [EOL] } <line_num>: 171,177
@Test [EOL] public void testGridTooFat() throws Exception { [EOL]     empiricalDistribution = new EmpiricalDistribution(1); [EOL]     tstGen(5); [EOL]     empiricalDistribution2 = new EmpiricalDistribution(1); [EOL]     tstDoubleGen(5); [EOL] } <line_num>: 182,189
@Test [EOL] public void testBinIndexOverflow() throws Exception { [EOL]     double[] x = new double[] { 9474.94326071674, 2080107.8865462579 }; [EOL]     new EmpiricalDistribution().load(x); [EOL] } <line_num>: 194,198
@Test [EOL] public void testSerialization() { [EOL]     EmpiricalDistribution dist = new EmpiricalDistribution(); [EOL]     EmpiricalDistribution dist2 = (EmpiricalDistribution) TestUtils.serializeAndRecover(dist); [EOL]     verifySame(dist, dist2); [EOL]     empiricalDistribution2.load(dataArray); [EOL]     dist2 = (EmpiricalDistribution) TestUtils.serializeAndRecover(empiricalDistribution2); [EOL]     verifySame(empiricalDistribution2, dist2); [EOL] } <line_num>: 200,211
@Test(expected = NullArgumentException.class) [EOL] public void testLoadNullDoubleArray() { [EOL]     new EmpiricalDistribution().load((double[]) null); [EOL] } <line_num>: 213,216
@Test(expected = NullArgumentException.class) [EOL] public void testLoadNullURL() throws Exception { [EOL]     new EmpiricalDistribution().load((URL) null); [EOL] } <line_num>: 218,221
@Test(expected = NullArgumentException.class) [EOL] public void testLoadNullFile() throws Exception { [EOL]     new EmpiricalDistribution().load((File) null); [EOL] } <line_num>: 223,226
@Test [EOL] public void testGetBinUpperBounds() { [EOL]     double[] testData = { 0, 1, 1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10 }; [EOL]     EmpiricalDistribution dist = new EmpiricalDistribution(5); [EOL]     dist.load(testData); [EOL]     double[] expectedBinUpperBounds = { 2, 4, 6, 8, 10 }; [EOL]     double[] expectedGeneratorUpperBounds = { 4d / 13d, 7d / 13d, 9d / 13d, 11d / 13d, 1 }; [EOL]     double tol = 10E-12; [EOL]     TestUtils.assertEquals(expectedBinUpperBounds, dist.getUpperBounds(), tol); [EOL]     TestUtils.assertEquals(expectedGeneratorUpperBounds, dist.getGeneratorUpperBounds(), tol); [EOL] } <line_num>: 231,241
@Test [EOL] public void testGeneratorConfig() { [EOL]     double[] testData = { 0, 1, 2, 3, 4 }; [EOL]     RandomGenerator generator = new RandomAdaptorTest.ConstantGenerator(0.5); [EOL]     EmpiricalDistribution dist = new EmpiricalDistribution(5, generator); [EOL]     dist.load(testData); [EOL]     for (int i = 0; i < 5; i++) { [EOL]         Assert.assertEquals(2.0, dist.getNextValue(), 0d); [EOL]     } [EOL]     dist = new EmpiricalDistribution(5, (RandomGenerator) null); [EOL]     dist.load(testData); [EOL]     dist.getNextValue(); [EOL] } <line_num>: 243,258
@Test [EOL] public void testReSeed() throws Exception { [EOL]     empiricalDistribution.load(url); [EOL]     empiricalDistribution.reSeed(100); [EOL]     final double[] values = new double[10]; [EOL]     for (int i = 0; i < 10; i++) { [EOL]         values[i] = empiricalDistribution.getNextValue(); [EOL]     } [EOL]     empiricalDistribution.reSeed(100); [EOL]     for (int i = 0; i < 10; i++) { [EOL]         Assert.assertEquals(values[i], empiricalDistribution.getNextValue(), 0d); [EOL]     } [EOL] } <line_num>: 260,272
private void verifySame(EmpiricalDistribution d1, EmpiricalDistribution d2) { [EOL]     Assert.assertEquals(d1.isLoaded(), d2.isLoaded()); [EOL]     Assert.assertEquals(d1.getBinCount(), d2.getBinCount()); [EOL]     Assert.assertEquals(d1.getSampleStats(), d2.getSampleStats()); [EOL]     if (d1.isLoaded()) { [EOL]         for (int i = 0; i < d1.getUpperBounds().length; i++) { [EOL]             Assert.assertEquals(d1.getUpperBounds()[i], d2.getUpperBounds()[i], 0); [EOL]         } [EOL]         Assert.assertEquals(d1.getBinStats(), d2.getBinStats()); [EOL]     } [EOL] } <line_num>: 274,284
private void tstGen(double tolerance) throws Exception { [EOL]     empiricalDistribution.load(url); [EOL]     empiricalDistribution.reSeed(1000); [EOL]     SummaryStatistics stats = new SummaryStatistics(); [EOL]     for (int i = 1; i < 1000; i++) { [EOL]         stats.addValue(empiricalDistribution.getNextValue()); [EOL]     } [EOL]     Assert.assertEquals("mean", 5.069831575018909, stats.getMean(), tolerance); [EOL]     Assert.assertEquals("std dev", 1.0173699343977738, stats.getStandardDeviation(), tolerance); [EOL] } <line_num>: 286,295
private void tstDoubleGen(double tolerance) throws Exception { [EOL]     empiricalDistribution2.load(dataArray); [EOL]     empiricalDistribution2.reSeed(1000); [EOL]     SummaryStatistics stats = new SummaryStatistics(); [EOL]     for (int i = 1; i < 1000; i++) { [EOL]         stats.addValue(empiricalDistribution2.getNextValue()); [EOL]     } [EOL]     Assert.assertEquals("mean", 5.069831575018909, stats.getMean(), tolerance); [EOL]     Assert.assertEquals("std dev", 1.0173699343977738, stats.getStandardDeviation(), tolerance); [EOL] } <line_num>: 297,306
@Override [EOL] public RealDistribution makeDistribution() { [EOL]     final double[] sourceData = new double[n + 1]; [EOL]     for (int i = 0; i < n + 1; i++) { [EOL]         sourceData[i] = i; [EOL]     } [EOL]     EmpiricalDistribution dist = new EmpiricalDistribution(); [EOL]     dist.load(sourceData); [EOL]     return dist; [EOL] } <line_num>: 310,320
@Override [EOL] public double[] makeCumulativeTestPoints() { [EOL]     final double[] testPoints = new double[] { 9, 10, 15, 1000, 5004, 9999 }; [EOL]     return testPoints; [EOL] } <line_num>: 328,332
@Override [EOL] public double[] makeCumulativeTestValues() { [EOL]     final double[] testPoints = getCumulativeTestPoints(); [EOL]     final double[] cumValues = new double[testPoints.length]; [EOL]     final EmpiricalDistribution empiricalDistribution = (EmpiricalDistribution) makeDistribution(); [EOL]     final double[] binBounds = empiricalDistribution.getUpperBounds(); [EOL]     for (int i = 0; i < testPoints.length; i++) { [EOL]         final int bin = findBin(testPoints[i]); [EOL]         final double lower = bin == 0 ? empiricalDistribution.getSupportLowerBound() : binBounds[bin - 1]; [EOL]         final double upper = binBounds[bin]; [EOL]         final double bMinus = bin == 0 ? 0 : (bin - 1) * binMass + firstBinMass; [EOL]         final RealDistribution kernel = findKernel(lower, upper); [EOL]         final double withinBinKernelMass = kernel.cumulativeProbability(lower, upper); [EOL]         final double kernelCum = kernel.cumulativeProbability(lower, testPoints[i]); [EOL]         cumValues[i] = bMinus + (bin == 0 ? firstBinMass : binMass) * kernelCum / withinBinKernelMass; [EOL]     } [EOL]     return cumValues; [EOL] } <line_num>: 335,360
@Override [EOL] public double[] makeDensityTestValues() { [EOL]     final double[] testPoints = getCumulativeTestPoints(); [EOL]     final double[] densityValues = new double[testPoints.length]; [EOL]     final EmpiricalDistribution empiricalDistribution = (EmpiricalDistribution) makeDistribution(); [EOL]     final double[] binBounds = empiricalDistribution.getUpperBounds(); [EOL]     for (int i = 0; i < testPoints.length; i++) { [EOL]         final int bin = findBin(testPoints[i]); [EOL]         final double lower = bin == 0 ? empiricalDistribution.getSupportLowerBound() : binBounds[bin - 1]; [EOL]         final double upper = binBounds[bin]; [EOL]         final RealDistribution kernel = findKernel(lower, upper); [EOL]         final double withinBinKernelMass = kernel.cumulativeProbability(lower, upper); [EOL]         final double density = kernel.density(testPoints[i]); [EOL]         densityValues[i] = density * (bin == 0 ? firstBinMass : binMass) / withinBinKernelMass; [EOL]     } [EOL]     return densityValues; [EOL] } <line_num>: 362,379
public double value(double x) { [EOL]     return distribution.density(x); [EOL] } <line_num>: 395,397
@Override [EOL] @Test [EOL] public void testDensityIntegrals() { [EOL]     final RealDistribution distribution = makeDistribution(); [EOL]     final double tol = 1.0e-9; [EOL]     final BaseAbstractUnivariateIntegrator integrator = new IterativeLegendreGaussIntegrator(5, 1.0e-12, 1.0e-10); [EOL]     final UnivariateFunction d = new UnivariateFunction() { [EOL]  [EOL]         public double value(double x) { [EOL]             return distribution.density(x); [EOL]         } [EOL]     }; [EOL]     final double[] lower = { 0, 5, 1000, 5001, 9995 }; [EOL]     final double[] upper = { 5, 12, 1030, 5010, 10000 }; [EOL]     for (int i = 1; i < 5; i++) { [EOL]         Assert.assertEquals(distribution.cumulativeProbability(lower[i], upper[i]), integrator.integrate(1000000, d, lower[i], upper[i]), tol); [EOL]     } [EOL] } <line_num>: 387,409
private int findBin(double x) { [EOL]     final double nMinus = Math.floor(x / 10); [EOL]     final int bin = (int) Math.round(nMinus); [EOL]     return Math.floor(x / 10) == x / 10 ? bin - 1 : bin; [EOL] } <line_num>: 414,420
private RealDistribution findKernel(double lower, double upper) { [EOL]     if (lower < 1) { [EOL]         return new NormalDistribution(5d, 3.3166247903554); [EOL]     } else { [EOL]         return new NormalDistribution((upper + lower + 1) / 2d, 3.0276503540974917); [EOL]     } [EOL] } <line_num>: 429,435
@Test [EOL] public void testKernelOverrideConstant() { [EOL]     final EmpiricalDistribution dist = new ConstantKernelEmpiricalDistribution(5); [EOL]     final double[] data = { 1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d, 10d, 11d, 12d, 13d, 14d, 15d }; [EOL]     dist.load(data); [EOL]     double[] values = { 2d, 5d, 8d, 11d, 14d }; [EOL]     for (int i = 0; i < 20; i++) { [EOL]         Assert.assertTrue(Arrays.binarySearch(values, dist.sample()) >= 0); [EOL]     } [EOL]     final double tol = 10E-12; [EOL]     Assert.assertEquals(0.0, dist.cumulativeProbability(1), tol); [EOL]     Assert.assertEquals(0.2, dist.cumulativeProbability(2), tol); [EOL]     Assert.assertEquals(0.6, dist.cumulativeProbability(10), tol); [EOL]     Assert.assertEquals(0.8, dist.cumulativeProbability(12), tol); [EOL]     Assert.assertEquals(0.8, dist.cumulativeProbability(13), tol); [EOL]     Assert.assertEquals(1.0, dist.cumulativeProbability(15), tol); [EOL]     Assert.assertEquals(2.0, dist.inverseCumulativeProbability(0.1), tol); [EOL]     Assert.assertEquals(2.0, dist.inverseCumulativeProbability(0.2), tol); [EOL]     Assert.assertEquals(5.0, dist.inverseCumulativeProbability(0.3), tol); [EOL]     Assert.assertEquals(5.0, dist.inverseCumulativeProbability(0.4), tol); [EOL]     Assert.assertEquals(8.0, dist.inverseCumulativeProbability(0.5), tol); [EOL]     Assert.assertEquals(8.0, dist.inverseCumulativeProbability(0.6), tol); [EOL] } <line_num>: 437,461
@Test [EOL] public void testKernelOverrideUniform() { [EOL]     final EmpiricalDistribution dist = new UniformKernelEmpiricalDistribution(5); [EOL]     final double[] data = { 1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d, 10d, 11d, 12d, 13d, 14d, 15d }; [EOL]     dist.load(data); [EOL]     final double[] bounds = { 3d, 6d, 9d, 12d }; [EOL]     final double tol = 10E-12; [EOL]     for (int i = 0; i < 20; i++) { [EOL]         final double v = dist.sample(); [EOL]         for (int j = 0; j < bounds.length; j++) { [EOL]             Assert.assertFalse(v > bounds[j] + tol && v < bounds[j] + 1 - tol); [EOL]         } [EOL]     } [EOL]     Assert.assertEquals(0.0, dist.cumulativeProbability(1), tol); [EOL]     Assert.assertEquals(0.1, dist.cumulativeProbability(2), tol); [EOL]     Assert.assertEquals(0.6, dist.cumulativeProbability(10), tol); [EOL]     Assert.assertEquals(0.8, dist.cumulativeProbability(12), tol); [EOL]     Assert.assertEquals(0.8, dist.cumulativeProbability(13), tol); [EOL]     Assert.assertEquals(1.0, dist.cumulativeProbability(15), tol); [EOL]     Assert.assertEquals(2.0, dist.inverseCumulativeProbability(0.1), tol); [EOL]     Assert.assertEquals(3.0, dist.inverseCumulativeProbability(0.2), tol); [EOL]     Assert.assertEquals(5.0, dist.inverseCumulativeProbability(0.3), tol); [EOL]     Assert.assertEquals(6.0, dist.inverseCumulativeProbability(0.4), tol); [EOL]     Assert.assertEquals(8.0, dist.inverseCumulativeProbability(0.5), tol); [EOL]     Assert.assertEquals(9.0, dist.inverseCumulativeProbability(0.6), tol); [EOL] } <line_num>: 463,491
@Override [EOL] protected RealDistribution getKernel(SummaryStatistics bStats) { [EOL]     return new ConstantDistribution(bStats.getMean()); [EOL] } <line_num>: 503,506
@Override [EOL] protected RealDistribution getKernel(SummaryStatistics bStats) { [EOL]     return new UniformRealDistribution(randomData.getRandomGenerator(), bStats.getMin(), bStats.getMax(), UniformRealDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY); [EOL] } <line_num>: 517,521
public double density(double x) { [EOL]     return 0; [EOL] } <line_num>: 537,539
public double cumulativeProbability(double x) { [EOL]     return x < c ? 0 : 1; [EOL] } <line_num>: 541,543
@Override [EOL] public double inverseCumulativeProbability(double p) { [EOL]     if (p < 0.0 || p > 1.0) { [EOL]         throw new OutOfRangeException(p, 0, 1); [EOL]     } [EOL]     return c; [EOL] } <line_num>: 545,551
public double getNumericalMean() { [EOL]     return c; [EOL] } <line_num>: 553,555
public double getNumericalVariance() { [EOL]     return 0; [EOL] } <line_num>: 557,559
public double getSupportLowerBound() { [EOL]     return c; [EOL] } <line_num>: 561,563
public double getSupportUpperBound() { [EOL]     return c; [EOL] } <line_num>: 565,567
public boolean isSupportLowerBoundInclusive() { [EOL]     return false; [EOL] } <line_num>: 569,571
public boolean isSupportUpperBoundInclusive() { [EOL]     return true; [EOL] } <line_num>: 573,575
public boolean isSupportConnected() { [EOL]     return true; [EOL] } <line_num>: 577,579
@Override [EOL] public double sample() { [EOL]     return c; [EOL] } <line_num>: 581,584
