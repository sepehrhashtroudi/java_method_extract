public LinearProblem(double[][] factors, double[] target) { [EOL]     this.factors = new BlockRealMatrix(factors); [EOL]     this.target = target; [EOL] } <line_num>: 692,695
public abstract T createOptimizer(); <line_num>: 51,51
public abstract int getMaxIterations(); <line_num>: 57,57
public double[] value(double[] point) { [EOL]     return new double[] { factor1 * factor1 * point[0] }; [EOL] } <line_num>: 68,72
public double[][] value(double[] point) { [EOL]     return new double[][] { { 2 * factor1 * point[0] } }; [EOL] } <line_num>: 74,78
public double[] value(double[] point) { [EOL]     return new double[] { factor2 * factor2 * point[0] }; [EOL] } <line_num>: 109,113
public double[][] value(double[] point) { [EOL]     return new double[][] { { 2 * factor2 * point[0] } }; [EOL] } <line_num>: 115,119
@Test [EOL] public void testShallowCopy() { [EOL]     final int maxEval1 = 12; [EOL]     final int maxIter1 = 23; [EOL]     final double[] target1 = { 3.4 }; [EOL]     final double[] weight1 = { 4.5 }; [EOL]     final double[] start1 = { 5.6 }; [EOL]     final double factor1 = 6.7; [EOL]     final MultivariateVectorFunction model1 = new MultivariateVectorFunction() { [EOL]  [EOL]         public double[] value(double[] point) { [EOL]             return new double[] { factor1 * factor1 * point[0] }; [EOL]         } [EOL]     }; [EOL]     final MultivariateMatrixFunction jac1 = new MultivariateMatrixFunction() { [EOL]  [EOL]         public double[][] value(double[] point) { [EOL]             return new double[][] { { 2 * factor1 * point[0] } }; [EOL]         } [EOL]     }; [EOL]     final T optim1 = createOptimizer().withMaxEvaluations(maxEval1).withMaxIterations(maxIter1).withTarget(target1).withWeight(new DiagonalMatrix(weight1)).withStartPoint(start1).withModelAndJacobian(model1, jac1); [EOL]     final T optim2 = optim1.shallowCopy(); [EOL]     Assert.assertTrue(optim1.getMaxEvaluations() == optim2.getMaxEvaluations()); [EOL]     Assert.assertTrue(optim1.getMaxIterations() == optim2.getMaxIterations()); [EOL]     Assert.assertTrue(optim1.getTarget()[0] == optim2.getTarget()[0]); [EOL]     Assert.assertTrue(optim1.getWeight().getEntry(0, 0) == optim2.getWeight().getEntry(0, 0)); [EOL]     Assert.assertTrue(optim1.getStart()[0] == optim2.getStart()[0]); [EOL]     Assert.assertTrue(optim1.getModel().value(new double[] { 32 })[0] == optim2.getModel().value(new double[] { 32 })[0]); [EOL]     Assert.assertTrue(optim1.getJacobian().value(new double[] { 54 })[0][0] == optim2.getJacobian().value(new double[] { 54 })[0][0]); [EOL]     final int maxEval2 = 122; [EOL]     final int maxIter2 = 232; [EOL]     final double[] target2 = { 3.42 }; [EOL]     final double[] weight2 = { 4.52 }; [EOL]     final double[] start2 = { 5.62 }; [EOL]     final double factor2 = 6.72; [EOL]     final MultivariateVectorFunction model2 = new MultivariateVectorFunction() { [EOL]  [EOL]         public double[] value(double[] point) { [EOL]             return new double[] { factor2 * factor2 * point[0] }; [EOL]         } [EOL]     }; [EOL]     final MultivariateMatrixFunction jac2 = new MultivariateMatrixFunction() { [EOL]  [EOL]         public double[][] value(double[] point) { [EOL]             return new double[][] { { 2 * factor2 * point[0] } }; [EOL]         } [EOL]     }; [EOL]     optim2.withMaxEvaluations(maxEval2).withMaxIterations(maxIter2).withTarget(target2).withWeight(new DiagonalMatrix(weight2)).withStartPoint(start2).withModelAndJacobian(model2, jac2); [EOL]     Assert.assertFalse(optim1.getMaxEvaluations() == optim2.getMaxEvaluations()); [EOL]     Assert.assertFalse(optim1.getMaxIterations() == optim2.getMaxIterations()); [EOL]     Assert.assertFalse(optim1.getTarget()[0] == optim2.getTarget()[0]); [EOL]     Assert.assertFalse(optim1.getWeight().getEntry(0, 0) == optim2.getWeight().getEntry(0, 0)); [EOL]     Assert.assertFalse(optim1.getStart()[0] == optim2.getStart()[0]); [EOL]     Assert.assertFalse(optim1.getModel().value(new double[] { 32 })[0] == optim2.getModel().value(new double[] { 32 })[0]); [EOL]     Assert.assertFalse(optim1.getJacobian().value(new double[] { 54 })[0][0] == optim2.getJacobian().value(new double[] { 54 })[0][0]); [EOL] } <line_num>: 59,138
public double[] value(double[] point) { [EOL]     return new double[] { FastMath.pow(point[0], 4) }; [EOL] } <line_num>: 149,153
public double[][] value(double[] point) { [EOL]     return new double[][] { { 0.25 * FastMath.pow(point[0], 3) } }; [EOL] } <line_num>: 155,159
@Test [EOL] public void testGetIterations() { [EOL]     T optim = createOptimizer().withMaxEvaluations(100).withMaxIterations(getMaxIterations()).withTarget(new double[] { 1 }).withWeight(new DiagonalMatrix(new double[] { 1 })).withStartPoint(new double[] { 3 }).withModelAndJacobian(new MultivariateVectorFunction() { [EOL]  [EOL]         public double[] value(double[] point) { [EOL]             return new double[] { FastMath.pow(point[0], 4) }; [EOL]         } [EOL]     }, new MultivariateMatrixFunction() { [EOL]  [EOL]         public double[][] value(double[] point) { [EOL]             return new double[][] { { 0.25 * FastMath.pow(point[0], 3) } }; [EOL]         } [EOL]     }); [EOL]     optim.optimize(); [EOL]     Assert.assertTrue(optim.getIterations() > 0); [EOL] } <line_num>: 140,164
@Test [EOL] public void testTrivial() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 2 } }, new double[] { 3 }); [EOL]     T optimizer = createOptimizer().withMaxEvaluations(100).withMaxIterations(getMaxIterations()).withModelAndJacobian(problem.getModelFunction(), problem.getModelFunctionJacobian()).withTarget(problem.getTarget()).withWeight(new DiagonalMatrix(new double[] { 1 })).withStartPoint(new double[] { 0 }); [EOL]     PointVectorValuePair optimum = optimizer.optimize(); [EOL]     Assert.assertEquals(0, optimizer.computeRMS(optimum.getPoint()), 1e-10); [EOL]     Assert.assertEquals(1.5, optimum.getPoint()[0], 1e-10); [EOL]     Assert.assertEquals(3.0, optimum.getValue()[0], 1e-10); [EOL] } <line_num>: 166,185
@Test [EOL] public void testQRColumnsPermutation() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 1, -1 }, { 0, 2 }, { 1, -2 } }, new double[] { 4, 6, 1 }); [EOL]     T optimizer = createOptimizer().withMaxEvaluations(100).withMaxIterations(getMaxIterations()).withModelAndJacobian(problem.getModelFunction(), problem.getModelFunctionJacobian()).withTarget(problem.getTarget()).withWeight(new DiagonalMatrix(new double[] { 1, 1, 1 })).withStartPoint(new double[] { 0, 0 }); [EOL]     PointVectorValuePair optimum = optimizer.optimize(); [EOL]     Assert.assertEquals(0, optimizer.computeRMS(optimum.getPoint()), 1e-10); [EOL]     Assert.assertEquals(7, optimum.getPoint()[0], 1e-10); [EOL]     Assert.assertEquals(3, optimum.getPoint()[1], 1e-10); [EOL]     Assert.assertEquals(4, optimum.getValue()[0], 1e-10); [EOL]     Assert.assertEquals(6, optimum.getValue()[1], 1e-10); [EOL]     Assert.assertEquals(1, optimum.getValue()[2], 1e-10); [EOL] } <line_num>: 187,210
@Test [EOL] public void testNoDependency() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 2, 0, 0, 0, 0, 0 }, { 0, 2, 0, 0, 0, 0 }, { 0, 0, 2, 0, 0, 0 }, { 0, 0, 0, 2, 0, 0 }, { 0, 0, 0, 0, 2, 0 }, { 0, 0, 0, 0, 0, 2 } }, new double[] { 0, 1.1, 2.2, 3.3, 4.4, 5.5 }); [EOL]     T optimizer = createOptimizer().withMaxEvaluations(100).withMaxIterations(getMaxIterations()).withModelAndJacobian(problem.getModelFunction(), problem.getModelFunctionJacobian()).withTarget(problem.getTarget()).withWeight(new DiagonalMatrix(new double[] { 1, 1, 1, 1, 1, 1 })).withStartPoint(new double[] { 0, 0, 0, 0, 0, 0 }); [EOL]     double[] optimum = optimizer.optimize().getPoint(); [EOL]     Assert.assertEquals(0, optimizer.computeRMS(optimum), 1e-10); [EOL]     for (int i = 0; i < problem.target.length; ++i) { [EOL]         Assert.assertEquals(0.55 * i, optimum[i], 1e-10); [EOL]     } [EOL] } <line_num>: 212,236
@Test [EOL] public void testOneSet() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 1, 0, 0 }, { -1, 1, 0 }, { 0, -1, 1 } }, new double[] { 1, 1, 1 }); [EOL]     T optimizer = createOptimizer().withMaxEvaluations(100).withMaxIterations(getMaxIterations()).withModelAndJacobian(problem.getModelFunction(), problem.getModelFunctionJacobian()).withTarget(problem.getTarget()).withWeight(new DiagonalMatrix(new double[] { 1, 1, 1 })).withStartPoint(new double[] { 0, 0, 0 }); [EOL]     double[] optimum = optimizer.optimize().getPoint(); [EOL]     Assert.assertEquals(0, optimizer.computeRMS(optimum), 1e-10); [EOL]     Assert.assertEquals(1, optimum[0], 1e-10); [EOL]     Assert.assertEquals(2, optimum[1], 1e-10); [EOL]     Assert.assertEquals(3, optimum[2], 1e-10); [EOL] } <line_num>: 238,260
@Test [EOL] public void testTwoSets() { [EOL]     double epsilon = 1e-7; [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 2, 1, 0, 4, 0, 0 }, { -4, -2, 3, -7, 0, 0 }, { 4, 1, -2, 8, 0, 0 }, { 0, -3, -12, -1, 0, 0 }, { 0, 0, 0, 0, epsilon, 1 }, { 0, 0, 0, 0, 1, 1 } }, new double[] { 2, -9, 2, 2, 1 + epsilon * epsilon, 2 }); [EOL]     T optimizer = createOptimizer().withMaxEvaluations(100).withMaxIterations(getMaxIterations()).withModelAndJacobian(problem.getModelFunction(), problem.getModelFunctionJacobian()).withTarget(problem.getTarget()).withWeight(new DiagonalMatrix(new double[] { 1, 1, 1, 1, 1, 1 })).withStartPoint(new double[] { 0, 0, 0, 0, 0, 0 }); [EOL]     double[] optimum = optimizer.optimize().getPoint(); [EOL]     Assert.assertEquals(0, optimizer.computeRMS(optimum), 1e-10); [EOL]     Assert.assertEquals(3, optimum[0], 1e-10); [EOL]     Assert.assertEquals(4, optimum[1], 1e-10); [EOL]     Assert.assertEquals(-1, optimum[2], 1e-10); [EOL]     Assert.assertEquals(-2, optimum[3], 1e-10); [EOL]     Assert.assertEquals(1 + epsilon, optimum[4], 1e-10); [EOL]     Assert.assertEquals(1 - epsilon, optimum[5], 1e-10); [EOL] } <line_num>: 262,292
@Test(expected = ConvergenceException.class) [EOL] public void testNonInvertible() throws Exception { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 1, 2, -3 }, { 2, 1, 3 }, { -3, 0, -9 } }, new double[] { 1, 1, 1 }); [EOL]     T optimizer = createOptimizer().withMaxEvaluations(100).withMaxIterations(getMaxIterations()).withModelAndJacobian(problem.getModelFunction(), problem.getModelFunctionJacobian()).withTarget(problem.getTarget()).withWeight(new DiagonalMatrix(new double[] { 1, 1, 1 })).withStartPoint(new double[] { 0, 0, 0 }); [EOL]     optimizer.optimize(); [EOL] } <line_num>: 294,312
@Test [EOL] public void testIllConditioned() { [EOL]     LinearProblem problem1 = new LinearProblem(new double[][] { { 10, 7, 8, 7 }, { 7, 5, 6, 5 }, { 8, 6, 10, 9 }, { 7, 5, 9, 10 } }, new double[] { 32, 23, 33, 31 }); [EOL]     T optimizer = createOptimizer().withMaxEvaluations(100).withMaxIterations(getMaxIterations()).withModelAndJacobian(problem1.getModelFunction(), problem1.getModelFunctionJacobian()).withTarget(problem1.getTarget()).withWeight(new DiagonalMatrix(new double[] { 1, 1, 1, 1 })).withStartPoint(new double[] { 0, 1, 2, 3 }); [EOL]     double[] optimum = optimizer.optimize().getPoint(); [EOL]     Assert.assertEquals(0, optimizer.computeRMS(optimum), 1e-10); [EOL]     Assert.assertEquals(1, optimum[0], 1e-10); [EOL]     Assert.assertEquals(1, optimum[1], 1e-10); [EOL]     Assert.assertEquals(1, optimum[2], 1e-10); [EOL]     Assert.assertEquals(1, optimum[3], 1e-10); [EOL]     LinearProblem problem2 = new LinearProblem(new double[][] { { 10.00, 7.00, 8.10, 7.20 }, { 7.08, 5.04, 6.00, 5.00 }, { 8.00, 5.98, 9.89, 9.00 }, { 6.99, 4.99, 9.00, 9.98 } }, new double[] { 32, 23, 33, 31 }); [EOL]     optimizer = optimizer.withModelAndJacobian(problem2.getModelFunction(), problem2.getModelFunctionJacobian()).withTarget(problem2.getTarget()); [EOL]     optimum = optimizer.optimize().getPoint(); [EOL]     Assert.assertEquals(0, optimizer.computeRMS(optimum), 1e-10); [EOL]     Assert.assertEquals(-81, optimum[0], 1e-8); [EOL]     Assert.assertEquals(137, optimum[1], 1e-8); [EOL]     Assert.assertEquals(-34, optimum[2], 1e-8); [EOL]     Assert.assertEquals(22, optimum[3], 1e-8); [EOL] } <line_num>: 314,358
@Test [EOL] public void testMoreEstimatedParametersSimple() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 3, 2, 0, 0 }, { 0, 1, -1, 1 }, { 2, 0, 1, 0 } }, new double[] { 7, 3, 5 }); [EOL]     T optimizer = createOptimizer().withMaxEvaluations(100).withMaxIterations(getMaxIterations()).withModelAndJacobian(problem.getModelFunction(), problem.getModelFunctionJacobian()).withTarget(problem.getTarget()).withWeight(new DiagonalMatrix(new double[] { 1, 1, 1 })).withStartPoint(new double[] { 7, 6, 5, 4 }); [EOL]     double[] optimum = optimizer.optimize().getPoint(); [EOL]     Assert.assertEquals(0, optimizer.computeRMS(optimum), 1e-10); [EOL] } <line_num>: 360,379
@Test [EOL] public void testMoreEstimatedParametersUnsorted() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 1, 1, 0, 0, 0, 0 }, { 0, 0, 1, 1, 1, 0 }, { 0, 0, 0, 0, 1, -1 }, { 0, 0, -1, 1, 0, 1 }, { 0, 0, 0, -1, 1, 0 } }, new double[] { 3, 12, -1, 7, 1 }); [EOL]     T optimizer = createOptimizer().withMaxEvaluations(100).withMaxIterations(getMaxIterations()).withModelAndJacobian(problem.getModelFunction(), problem.getModelFunctionJacobian()).withTarget(problem.getTarget()).withWeight(new DiagonalMatrix(new double[] { 1, 1, 1, 1, 1 })).withStartPoint(new double[] { 2, 2, 2, 2, 2, 2 }); [EOL]     double[] optimum = optimizer.optimize().getPoint(); [EOL]     Assert.assertEquals(0, optimizer.computeRMS(optimum), 1e-10); [EOL]     Assert.assertEquals(3, optimum[2], 1e-10); [EOL]     Assert.assertEquals(4, optimum[3], 1e-10); [EOL]     Assert.assertEquals(5, optimum[4], 1e-10); [EOL]     Assert.assertEquals(6, optimum[5], 1e-10); [EOL] } <line_num>: 381,407
@Test [EOL] public void testRedundantEquations() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 1, 1 }, { 1, -1 }, { 1, 3 } }, new double[] { 3, 1, 5 }); [EOL]     T optimizer = createOptimizer().withMaxEvaluations(100).withMaxIterations(getMaxIterations()).withModelAndJacobian(problem.getModelFunction(), problem.getModelFunctionJacobian()).withTarget(problem.getTarget()).withWeight(new DiagonalMatrix(new double[] { 1, 1, 1 })).withStartPoint(new double[] { 1, 1 }); [EOL]     double[] optimum = optimizer.optimize().getPoint(); [EOL]     Assert.assertEquals(0, optimizer.computeRMS(optimum), 1e-10); [EOL]     Assert.assertEquals(2, optimum[0], 1e-10); [EOL]     Assert.assertEquals(1, optimum[1], 1e-10); [EOL] } <line_num>: 409,431
@Test [EOL] public void testInconsistentEquations() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 1, 1 }, { 1, -1 }, { 1, 3 } }, new double[] { 3, 1, 4 }); [EOL]     T optimizer = createOptimizer().withMaxEvaluations(100).withMaxIterations(getMaxIterations()).withModelAndJacobian(problem.getModelFunction(), problem.getModelFunctionJacobian()).withTarget(problem.getTarget()).withWeight(new DiagonalMatrix(new double[] { 1, 1, 1 })).withStartPoint(new double[] { 1, 1 }); [EOL]     double[] optimum = optimizer.optimize().getPoint(); [EOL]     Assert.assertTrue(optimizer.computeRMS(optimum) > 0.1); [EOL] } <line_num>: 433,453
@Test(expected = DimensionMismatchException.class) [EOL] public void testInconsistentSizes1() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 }); [EOL]     T optimizer = createOptimizer().withMaxEvaluations(100).withMaxIterations(getMaxIterations()).withModelAndJacobian(problem.getModelFunction(), problem.getModelFunctionJacobian()).withTarget(problem.getTarget()).withWeight(new DiagonalMatrix(new double[] { 1, 1 })).withStartPoint(new double[] { 0, 0 }); [EOL]     double[] optimum = optimizer.optimize().getPoint(); [EOL]     Assert.assertEquals(0, optimizer.computeRMS(optimum), 1e-10); [EOL]     Assert.assertEquals(-1, optimum[0], 1e-10); [EOL]     Assert.assertEquals(1, optimum[1], 1e-10); [EOL]     optimizer.withWeight(new DiagonalMatrix(new double[] { 1 })).optimize(); [EOL] } <line_num>: 455,477
@Test(expected = DimensionMismatchException.class) [EOL] public void testInconsistentSizes2() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 }); [EOL]     T optimizer = createOptimizer().withMaxEvaluations(100).withMaxIterations(getMaxIterations()).withModelAndJacobian(problem.getModelFunction(), problem.getModelFunctionJacobian()).withTarget(problem.getTarget()).withWeight(new DiagonalMatrix(new double[] { 1, 1 })).withStartPoint(new double[] { 0, 0 }); [EOL]     double[] optimum = optimizer.optimize().getPoint(); [EOL]     Assert.assertEquals(0, optimizer.computeRMS(optimum), 1e-10); [EOL]     Assert.assertEquals(-1, optimum[0], 1e-10); [EOL]     Assert.assertEquals(1, optimum[1], 1e-10); [EOL]     optimizer.withTarget(new double[] { 1 }).withWeight(new DiagonalMatrix(new double[] { 1 })).optimize(); [EOL] } <line_num>: 479,504
@Test [EOL] public void testCircleFitting() { [EOL]     CircleVectorial circle = new CircleVectorial(); [EOL]     circle.addPoint(30, 68); [EOL]     circle.addPoint(50, -6); [EOL]     circle.addPoint(110, -20); [EOL]     circle.addPoint(35, 15); [EOL]     circle.addPoint(45, 97); [EOL]     T optimizer = createOptimizer().withMaxEvaluations(100).withMaxIterations(getMaxIterations()).withModelAndJacobian(circle.getModelFunction(), circle.getModelFunctionJacobian()).withTarget(new double[] { 0, 0, 0, 0, 0 }).withWeight(new DiagonalMatrix(new double[] { 1, 1, 1, 1, 1 })).withStartPoint(new double[] { 98.680, 47.345 }); [EOL]     double[] optimum = optimizer.optimize().getPoint(); [EOL]     Assert.assertTrue(optimizer.getEvaluations() < 10); [EOL]     double rms = optimizer.computeRMS(optimum); [EOL]     Assert.assertEquals(1.768262623567235, FastMath.sqrt(circle.getN()) * rms, 1e-10); [EOL]     Vector2D center = new Vector2D(optimum[0], optimum[1]); [EOL]     Assert.assertEquals(69.96016176931406, circle.getRadius(center), 1e-6); [EOL]     Assert.assertEquals(96.07590211815305, center.getX(), 1e-6); [EOL]     Assert.assertEquals(48.13516790438953, center.getY(), 1e-6); [EOL]     double[][] cov = optimizer.computeCovariances(optimum, 1e-14); [EOL]     Assert.assertEquals(1.839, cov[0][0], 0.001); [EOL]     Assert.assertEquals(0.731, cov[0][1], 0.001); [EOL]     Assert.assertEquals(cov[0][1], cov[1][0], 1e-14); [EOL]     Assert.assertEquals(0.786, cov[1][1], 0.001); [EOL]     double r = circle.getRadius(center); [EOL]     for (double d = 0; d < 2 * FastMath.PI; d += 0.01) { [EOL]         circle.addPoint(center.getX() + r * FastMath.cos(d), center.getY() + r * FastMath.sin(d)); [EOL]     } [EOL]     double[] target = new double[circle.getN()]; [EOL]     Arrays.fill(target, 0); [EOL]     double[] weights = new double[circle.getN()]; [EOL]     Arrays.fill(weights, 2); [EOL]     optimizer = optimizer.withTarget(target).withWeight(new DiagonalMatrix(weights)); [EOL]     optimum = optimizer.optimize().getPoint(); [EOL]     cov = optimizer.computeCovariances(optimum, 1e-14); [EOL]     Assert.assertEquals(0.0016, cov[0][0], 0.001); [EOL]     Assert.assertEquals(3.2e-7, cov[0][1], 1e-9); [EOL]     Assert.assertEquals(cov[0][1], cov[1][0], 1e-14); [EOL]     Assert.assertEquals(0.0016, cov[1][1], 0.001); [EOL] } <line_num>: 506,559
@Test [EOL] public void testCircleFittingBadInit() { [EOL]     CircleVectorial circle = new CircleVectorial(); [EOL]     double[][] points = circlePoints; [EOL]     double[] target = new double[points.length]; [EOL]     Arrays.fill(target, 0); [EOL]     double[] weights = new double[points.length]; [EOL]     Arrays.fill(weights, 2); [EOL]     for (int i = 0; i < points.length; ++i) { [EOL]         circle.addPoint(points[i][0], points[i][1]); [EOL]     } [EOL]     T optimizer = createOptimizer().withMaxEvaluations(100).withMaxIterations(getMaxIterations()).withModelAndJacobian(circle.getModelFunction(), circle.getModelFunctionJacobian()).withTarget(target).withWeight(new DiagonalMatrix(weights)).withStartPoint(new double[] { -12, -12 }); [EOL]     double[] optimum = optimizer.optimize().getPoint(); [EOL]     Vector2D center = new Vector2D(optimum[0], optimum[1]); [EOL]     Assert.assertTrue(optimizer.getEvaluations() < 25); [EOL]     Assert.assertEquals(0.043, optimizer.computeRMS(optimum), 1e-3); [EOL]     Assert.assertEquals(0.292235, circle.getRadius(center), 1e-6); [EOL]     Assert.assertEquals(-0.151738, center.getX(), 1e-6); [EOL]     Assert.assertEquals(0.2075001, center.getY(), 1e-6); [EOL] } <line_num>: 561,589
@Test [EOL] public void testCircleFittingGoodInit() { [EOL]     CircleVectorial circle = new CircleVectorial(); [EOL]     double[][] points = circlePoints; [EOL]     double[] target = new double[points.length]; [EOL]     Arrays.fill(target, 0); [EOL]     double[] weights = new double[points.length]; [EOL]     Arrays.fill(weights, 2); [EOL]     for (int i = 0; i < points.length; ++i) { [EOL]         circle.addPoint(points[i][0], points[i][1]); [EOL]     } [EOL]     T optimizer = createOptimizer().withMaxEvaluations(100).withMaxIterations(getMaxIterations()).withModelAndJacobian(circle.getModelFunction(), circle.getModelFunctionJacobian()).withTarget(target).withWeight(new DiagonalMatrix(weights)).withStartPoint(new double[] { 0, 0 }); [EOL]     double[] optimum = optimizer.optimize().getPoint(); [EOL]     Assert.assertEquals(-0.1517383071957963, optimum[0], 1e-6); [EOL]     Assert.assertEquals(0.2074999736353867, optimum[1], 1e-6); [EOL]     Assert.assertEquals(0.04268731682389561, optimizer.computeRMS(optimum), 1e-8); [EOL] } <line_num>: 591,616
public void doTestStRD(final StatisticalReferenceDataset dataset, final double errParams, final double errParamsSd) { [EOL]     final double[] w = new double[dataset.getNumObservations()]; [EOL]     Arrays.fill(w, 1); [EOL]     final double[][] data = dataset.getData(); [EOL]     final double[] initial = dataset.getStartingPoint(0); [EOL]     final StatisticalReferenceDataset.LeastSquaresProblem problem = dataset.getLeastSquaresProblem(); [EOL]     final T optimizer = createOptimizer().withMaxEvaluations(100).withMaxIterations(getMaxIterations()).withModelAndJacobian(problem.getModelFunction(), problem.getModelFunctionJacobian()).withTarget(data[1]).withWeight(new DiagonalMatrix(w)).withStartPoint(initial); [EOL]     final double[] actual = optimizer.optimize().getPoint(); [EOL]     for (int i = 0; i < actual.length; i++) { [EOL]         double expected = dataset.getParameter(i); [EOL]         double delta = FastMath.abs(errParams * expected); [EOL]         Assert.assertEquals(dataset.getName() + ", param #" + i, expected, actual[i], delta); [EOL]     } [EOL] } <line_num>: 650,676
@Test [EOL] public void testKirby2() throws IOException { [EOL]     doTestStRD(StatisticalReferenceDatasetFactory.createKirby2(), 1E-7, 1E-7); [EOL] } <line_num>: 678,681
@Test [EOL] public void testHahn1() throws IOException { [EOL]     doTestStRD(StatisticalReferenceDatasetFactory.createHahn1(), 1E-7, 1E-4); [EOL] } <line_num>: 683,686
public double[] getTarget() { [EOL]     return target; [EOL] } <line_num>: 697,699
public double[] value(double[] params) { [EOL]     return factors.operate(params); [EOL] } <line_num>: 703,705
public MultivariateVectorFunction getModelFunction() { [EOL]     return new MultivariateVectorFunction() { [EOL]  [EOL]         public double[] value(double[] params) { [EOL]             return factors.operate(params); [EOL]         } [EOL]     }; [EOL] } <line_num>: 701,707
public double[][] value(double[] params) { [EOL]     return factors.getData(); [EOL] } <line_num>: 711,713
public MultivariateMatrixFunction getModelFunctionJacobian() { [EOL]     return new MultivariateMatrixFunction() { [EOL]  [EOL]         public double[][] value(double[] params) { [EOL]             return factors.getData(); [EOL]         } [EOL]     }; [EOL] } <line_num>: 709,715
