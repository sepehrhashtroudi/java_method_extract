public QuadraticProblem() { [EOL]     x = new ArrayList<Double>(); [EOL]     y = new ArrayList<Double>(); [EOL] } <line_num>: 314,317
public BevingtonProblem() { [EOL]     time = new ArrayList<Double>(); [EOL]     count = new ArrayList<Double>(); [EOL] } <line_num>: 355,358
@Override [EOL] public LevenbergMarquardtOptimizer createOptimizer() { [EOL]     return LevenbergMarquardtOptimizer.create(); [EOL] } <line_num>: 50,53
@Override [EOL] public int getMaxIterations() { [EOL]     return 25; [EOL] } <line_num>: 55,58
@Override [EOL] @Test [EOL] public void testShallowCopy() { [EOL]     super.testShallowCopy(); [EOL]     final double initStep1 = 1e-1; [EOL]     final double costTol1 = 1e-1; [EOL]     final double parTol1 = 1e-1; [EOL]     final double orthoTol1 = 1e-1; [EOL]     final double threshold1 = 1e-1; [EOL]     final LevenbergMarquardtOptimizer optim1 = createOptimizer().withInitialStepBoundFactor(initStep1).withCostRelativeTolerance(costTol1).withParameterRelativeTolerance(parTol1).withOrthoTolerance(orthoTol1).withRankingThreshold(threshold1); [EOL]     final LevenbergMarquardtOptimizer optim2 = optim1.shallowCopy(); [EOL]     Assert.assertTrue(optim1.getInitialStepBoundFactor() == optim2.getInitialStepBoundFactor()); [EOL]     Assert.assertTrue(optim1.getCostRelativeTolerance() == optim2.getCostRelativeTolerance()); [EOL]     Assert.assertTrue(optim1.getParameterRelativeTolerance() == optim2.getParameterRelativeTolerance()); [EOL]     Assert.assertTrue(optim1.getOrthoTolerance() == optim2.getOrthoTolerance()); [EOL]     Assert.assertTrue(optim1.getRankingThreshold() == optim2.getRankingThreshold()); [EOL]     final double initStep2 = 2e-1; [EOL]     final double costTol2 = 2e-1; [EOL]     final double parTol2 = 2e-1; [EOL]     final double orthoTol2 = 2e-1; [EOL]     final double threshold2 = 2e-1; [EOL]     optim2.withInitialStepBoundFactor(initStep2).withCostRelativeTolerance(costTol2).withParameterRelativeTolerance(parTol2).withOrthoTolerance(orthoTol2).withRankingThreshold(threshold2); [EOL]     Assert.assertFalse(optim1.getInitialStepBoundFactor() == optim2.getInitialStepBoundFactor()); [EOL]     Assert.assertFalse(optim1.getCostRelativeTolerance() == optim2.getCostRelativeTolerance()); [EOL]     Assert.assertFalse(optim1.getParameterRelativeTolerance() == optim2.getParameterRelativeTolerance()); [EOL]     Assert.assertFalse(optim1.getOrthoTolerance() == optim2.getOrthoTolerance()); [EOL]     Assert.assertFalse(optim1.getRankingThreshold() == optim2.getRankingThreshold()); [EOL] } <line_num>: 60,105
@Override [EOL] @Test(expected = SingularMatrixException.class) [EOL] public void testNonInvertible() { [EOL]     LinearProblem problem = new LinearProblem(new double[][] { { 1, 2, -3 }, { 2, 1, 3 }, { -3, 0, -9 } }, new double[] { 1, 1, 1 }); [EOL]     final LevenbergMarquardtOptimizer optimizer = createOptimizer().withMaxEvaluations(100).withMaxIterations(20).withModelAndJacobian(problem.getModelFunction(), problem.getModelFunctionJacobian()).withTarget(problem.getTarget()).withWeight(new DiagonalMatrix(new double[] { 1, 1, 1 })).withStartPoint(new double[] { 0, 0, 0 }); [EOL]     final double[] optimum = optimizer.optimize().getPoint(); [EOL]     Assert.assertTrue(FastMath.sqrt(optimizer.getTarget().length) * optimizer.computeRMS(optimum) > 0.6); [EOL]     optimizer.computeCovariances(optimum, 1.5e-14); [EOL] } <line_num>: 107,133
@Test [EOL] public void testControlParameters() { [EOL]     CircleVectorial circle = new CircleVectorial(); [EOL]     circle.addPoint(30.0, 68.0); [EOL]     circle.addPoint(50.0, -6.0); [EOL]     circle.addPoint(110.0, -20.0); [EOL]     circle.addPoint(35.0, 15.0); [EOL]     circle.addPoint(45.0, 97.0); [EOL]     checkEstimate(circle.getModelFunction(), circle.getModelFunctionJacobian(), 0.1, 10, 1.0e-14, 1.0e-16, 1.0e-10, false); [EOL]     checkEstimate(circle.getModelFunction(), circle.getModelFunctionJacobian(), 0.1, 10, 1.0e-15, 1.0e-17, 1.0e-10, true); [EOL]     checkEstimate(circle.getModelFunction(), circle.getModelFunctionJacobian(), 0.1, 5, 1.0e-15, 1.0e-16, 1.0e-10, true); [EOL]     circle.addPoint(300, -300); [EOL]     checkEstimate(circle.getModelFunction(), circle.getModelFunctionJacobian(), 0.1, 20, 1.0e-18, 1.0e-16, 1.0e-10, true); [EOL] } <line_num>: 135,156
private void checkEstimate(MultivariateVectorFunction problem, MultivariateMatrixFunction problemJacobian, double initialStepBoundFactor, int maxCostEval, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, boolean shouldFail) { [EOL]     try { [EOL]         final LevenbergMarquardtOptimizer optimizer = LevenbergMarquardtOptimizer.create().withInitialStepBoundFactor(initialStepBoundFactor).withCostRelativeTolerance(costRelativeTolerance).withParameterRelativeTolerance(parRelativeTolerance).withOrthoTolerance(orthoTolerance).withRankingThreshold(Precision.SAFE_MIN).withMaxEvaluations(maxCostEval).withMaxIterations(100).withModelAndJacobian(problem, problemJacobian).withTarget(new double[] { 0, 0, 0, 0, 0 }).withWeight(new DiagonalMatrix(new double[] { 1, 1, 1, 1, 1 })).withStartPoint(new double[] { 98.680, 47.345 }); [EOL]         optimizer.optimize(); [EOL]         Assert.assertTrue(!shouldFail); [EOL]     } catch (DimensionMismatchException ee) { [EOL]         Assert.assertTrue(shouldFail); [EOL]     } catch (TooManyEvaluationsException ee) { [EOL]         Assert.assertTrue(shouldFail); [EOL]     } [EOL] } <line_num>: 158,185
@Test [EOL] public void testBevington() { [EOL]     final double[][] dataPoints = { { 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180, 195, 210, 225, 240, 255, 270, 285, 300, 315, 330, 345, 360, 375, 390, 405, 420, 435, 450, 465, 480, 495, 510, 525, 540, 555, 570, 585, 600, 615, 630, 645, 660, 675, 690, 705, 720, 735, 750, 765, 780, 795, 810, 825, 840, 855, 870, 885 }, { 775, 479, 380, 302, 185, 157, 137, 119, 110, 89, 74, 61, 66, 68, 48, 54, 51, 46, 55, 29, 28, 37, 49, 26, 35, 29, 31, 24, 25, 35, 24, 30, 26, 28, 21, 18, 20, 27, 17, 17, 14, 17, 24, 11, 22, 17, 12, 10, 13, 16, 9, 9, 14, 21, 17, 13, 12, 18, 10 } }; [EOL]     final BevingtonProblem problem = new BevingtonProblem(); [EOL]     final int len = dataPoints[0].length; [EOL]     final double[] weights = new double[len]; [EOL]     for (int i = 0; i < len; i++) { [EOL]         problem.addPoint(dataPoints[0][i], dataPoints[1][i]); [EOL]         weights[i] = 1 / dataPoints[1][i]; [EOL]     } [EOL]     final LevenbergMarquardtOptimizer optimizer = LevenbergMarquardtOptimizer.create().withMaxEvaluations(100).withMaxIterations(20).withModelAndJacobian(problem.getModelFunction(), problem.getModelFunctionJacobian()).withTarget(dataPoints[1]).withWeight(new DiagonalMatrix(weights)).withStartPoint(new double[] { 10, 900, 80, 27, 225 }); [EOL]     final PointVectorValuePair optimum = optimizer.optimize(); [EOL]     final double[] solution = optimum.getPoint(); [EOL]     final double[] expectedSolution = { 10.4, 958.3, 131.4, 33.9, 205.0 }; [EOL]     final double[][] covarMatrix = optimizer.computeCovariances(solution, 1e-14); [EOL]     final double[][] expectedCovarMatrix = { { 3.38, -3.69, 27.98, -2.34, -49.24 }, { -3.69, 2492.26, 81.89, -69.21, -8.9 }, { 27.98, 81.89, 468.99, -44.22, -615.44 }, { -2.34, -69.21, -44.22, 6.39, 53.80 }, { -49.24, -8.9, -615.44, 53.8, 929.45 } }; [EOL]     final int numParams = expectedSolution.length; [EOL]     for (int i = 0; i < numParams; i++) { [EOL]         final double error = FastMath.sqrt(expectedCovarMatrix[i][i]); [EOL]         Assert.assertEquals("Parameter " + i, expectedSolution[i], solution[i], error); [EOL]     } [EOL]     for (int i = 0; i < numParams; i++) { [EOL]         for (int j = 0; j < numParams; j++) { [EOL]             Assert.assertEquals("Covariance matrix [" + i + "][" + j + "]", expectedCovarMatrix[i][j], covarMatrix[i][j], FastMath.abs(0.1 * expectedCovarMatrix[i][j])); [EOL]         } [EOL]     } [EOL] } <line_num>: 194,264
@Test [EOL] public void testCircleFitting2() { [EOL]     final double xCenter = 123.456; [EOL]     final double yCenter = 654.321; [EOL]     final double xSigma = 10; [EOL]     final double ySigma = 15; [EOL]     final double radius = 111.111; [EOL]     final long seed = 59421061L; [EOL]     final RandomCirclePointGenerator factory = new RandomCirclePointGenerator(xCenter, yCenter, radius, xSigma, ySigma, seed); [EOL]     final CircleProblem circle = new CircleProblem(xSigma, ySigma); [EOL]     final int numPoints = 10; [EOL]     for (Vector2D p : factory.generate(numPoints)) { [EOL]         circle.addPoint(p.getX(), p.getY()); [EOL]     } [EOL]     final double[] init = { 90, 659, 115 }; [EOL]     final LevenbergMarquardtOptimizer optimizer = LevenbergMarquardtOptimizer.create().withMaxEvaluations(100).withMaxIterations(50).withModelAndJacobian(circle.getModelFunction(), circle.getModelFunctionJacobian()).withTarget(circle.target()).withWeight(new DiagonalMatrix(circle.weight())).withStartPoint(init); [EOL]     final PointVectorValuePair optimum = optimizer.optimize(); [EOL]     final double[] paramFound = optimum.getPoint(); [EOL]     final double[] asymptoticStandardErrorFound = optimizer.computeSigma(paramFound, 1e-14); [EOL]     Assert.assertEquals(xCenter, paramFound[0], asymptoticStandardErrorFound[0]); [EOL]     Assert.assertEquals(yCenter, paramFound[1], asymptoticStandardErrorFound[1]); [EOL]     Assert.assertEquals(radius, paramFound[2], asymptoticStandardErrorFound[2]); [EOL] } <line_num>: 266,308
public void addPoint(double x, double y) { [EOL]     this.x.add(x); [EOL]     this.y.add(y); [EOL] } <line_num>: 319,322
public double[] value(double[] variables) { [EOL]     double[] values = new double[x.size()]; [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         values[i] = (variables[0] * x.get(i) + variables[1]) * x.get(i) + variables[2]; [EOL]     } [EOL]     return values; [EOL] } <line_num>: 326,332
public MultivariateVectorFunction getModelFunction() { [EOL]     return new MultivariateVectorFunction() { [EOL]  [EOL]         public double[] value(double[] variables) { [EOL]             double[] values = new double[x.size()]; [EOL]             for (int i = 0; i < values.length; ++i) { [EOL]                 values[i] = (variables[0] * x.get(i) + variables[1]) * x.get(i) + variables[2]; [EOL]             } [EOL]             return values; [EOL]         } [EOL]     }; [EOL] } <line_num>: 324,334
public double[][] value(double[] params) { [EOL]     double[][] jacobian = new double[x.size()][3]; [EOL]     for (int i = 0; i < jacobian.length; ++i) { [EOL]         jacobian[i][0] = x.get(i) * x.get(i); [EOL]         jacobian[i][1] = x.get(i); [EOL]         jacobian[i][2] = 1.0; [EOL]     } [EOL]     return jacobian; [EOL] } <line_num>: 338,346
public MultivariateMatrixFunction getModelFunctionJacobian() { [EOL]     return new MultivariateMatrixFunction() { [EOL]  [EOL]         public double[][] value(double[] params) { [EOL]             double[][] jacobian = new double[x.size()][3]; [EOL]             for (int i = 0; i < jacobian.length; ++i) { [EOL]                 jacobian[i][0] = x.get(i) * x.get(i); [EOL]                 jacobian[i][1] = x.get(i); [EOL]                 jacobian[i][2] = 1.0; [EOL]             } [EOL]             return jacobian; [EOL]         } [EOL]     }; [EOL] } <line_num>: 336,348
public void addPoint(double t, double c) { [EOL]     time.add(t); [EOL]     count.add(c); [EOL] } <line_num>: 360,363
public double[] value(double[] params) { [EOL]     double[] values = new double[time.size()]; [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         final double t = time.get(i); [EOL]         values[i] = params[0] + params[1] * Math.exp(-t / params[3]) + params[2] * Math.exp(-t / params[4]); [EOL]     } [EOL]     return values; [EOL] } <line_num>: 367,376
public MultivariateVectorFunction getModelFunction() { [EOL]     return new MultivariateVectorFunction() { [EOL]  [EOL]         public double[] value(double[] params) { [EOL]             double[] values = new double[time.size()]; [EOL]             for (int i = 0; i < values.length; ++i) { [EOL]                 final double t = time.get(i); [EOL]                 values[i] = params[0] + params[1] * Math.exp(-t / params[3]) + params[2] * Math.exp(-t / params[4]); [EOL]             } [EOL]             return values; [EOL]         } [EOL]     }; [EOL] } <line_num>: 365,378
public double[][] value(double[] params) { [EOL]     double[][] jacobian = new double[time.size()][5]; [EOL]     for (int i = 0; i < jacobian.length; ++i) { [EOL]         final double t = time.get(i); [EOL]         jacobian[i][0] = 1; [EOL]         final double p3 = params[3]; [EOL]         final double p4 = params[4]; [EOL]         final double tOp3 = t / p3; [EOL]         final double tOp4 = t / p4; [EOL]         jacobian[i][1] = Math.exp(-tOp3); [EOL]         jacobian[i][2] = Math.exp(-tOp4); [EOL]         jacobian[i][3] = params[1] * Math.exp(-tOp3) * tOp3 / p3; [EOL]         jacobian[i][4] = params[2] * Math.exp(-tOp4) * tOp4 / p4; [EOL]     } [EOL]     return jacobian; [EOL] } <line_num>: 382,399
public MultivariateMatrixFunction getModelFunctionJacobian() { [EOL]     return new MultivariateMatrixFunction() { [EOL]  [EOL]         public double[][] value(double[] params) { [EOL]             double[][] jacobian = new double[time.size()][5]; [EOL]             for (int i = 0; i < jacobian.length; ++i) { [EOL]                 final double t = time.get(i); [EOL]                 jacobian[i][0] = 1; [EOL]                 final double p3 = params[3]; [EOL]                 final double p4 = params[4]; [EOL]                 final double tOp3 = t / p3; [EOL]                 final double tOp4 = t / p4; [EOL]                 jacobian[i][1] = Math.exp(-tOp3); [EOL]                 jacobian[i][2] = Math.exp(-tOp4); [EOL]                 jacobian[i][3] = params[1] * Math.exp(-tOp3) * tOp3 / p3; [EOL]                 jacobian[i][4] = params[2] * Math.exp(-tOp4) * tOp4 / p4; [EOL]             } [EOL]             return jacobian; [EOL]         } [EOL]     }; [EOL] } <line_num>: 380,401
