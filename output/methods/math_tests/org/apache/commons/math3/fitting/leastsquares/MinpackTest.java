protected MinpackFunction(int m, double[] startParams, double theoreticalMinCost, double[] theoreticalMinParams) { [EOL]     this.m = m; [EOL]     this.n = startParams.length; [EOL]     this.startParams = startParams.clone(); [EOL]     this.theoreticalMinCost = theoreticalMinCost; [EOL]     this.theoreticalMinParams = theoreticalMinParams; [EOL]     this.costAccuracy = 1.0e-8; [EOL]     this.paramsAccuracy = 1.0e-5; [EOL] } <line_num>: 536,546
public LinearFullRankFunction(int m, int n, double x0, double theoreticalStartCost, double theoreticalMinCost) { [EOL]     super(m, buildArray(n, x0), theoreticalMinCost, buildArray(n, -1.0)); [EOL] } <line_num>: 616,621
public LinearRank1Function(int m, int n, double x0, double theoreticalStartCost, double theoreticalMinCost) { [EOL]     super(m, buildArray(n, x0), theoreticalMinCost, null); [EOL] } <line_num>: 655,659
public LinearRank1ZeroColsAndRowsFunction(int m, int n, double x0) { [EOL]     super(m, buildArray(n, x0), FastMath.sqrt((m * (m + 3) - 6) / (2.0 * (2 * m - 3))), null); [EOL] } <line_num>: 690,694
public RosenbrockFunction(double[] startParams, double theoreticalStartCost) { [EOL]     super(2, startParams, 0.0, buildArray(2, 1.0)); [EOL] } <line_num>: 733,735
public HelicalValleyFunction(double[] startParams, double theoreticalStartCost) { [EOL]     super(3, startParams, 0.0, new double[] { 1.0, 0.0, 0.0 }); [EOL] } <line_num>: 753,756
public PowellSingularFunction(double[] startParams, double theoreticalStartCost) { [EOL]     super(4, startParams, 0.0, buildArray(4, 0.0)); [EOL] } <line_num>: 800,803
public FreudensteinRothFunction(double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { [EOL]     super(2, startParams, theoreticalMinCost, theoreticalMinParams); [EOL] } <line_num>: 840,846
public BardFunction(double x0, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { [EOL]     super(15, buildArray(3, x0), theoreticalMinCost, theoreticalMinParams); [EOL] } <line_num>: 871,877
public KowalikOsborneFunction(double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { [EOL]     super(11, startParams, theoreticalMinCost, theoreticalMinParams); [EOL]     if (theoreticalStartCost > 20.0) { [EOL]         setCostAccuracy(2.0e-4); [EOL]         setParamsAccuracy(5.0e-3); [EOL]     } [EOL] } <line_num>: 920,930
public MeyerFunction(double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { [EOL]     super(16, startParams, theoreticalMinCost, theoreticalMinParams); [EOL]     if (theoreticalStartCost > 1.0e6) { [EOL]         setCostAccuracy(7.0e-3); [EOL]         setParamsAccuracy(2.0e-2); [EOL]     } [EOL] } <line_num>: 976,986
public WatsonFunction(int n, double x0, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { [EOL]     super(31, buildArray(n, x0), theoreticalMinCost, theoreticalMinParams); [EOL] } <line_num>: 1027,1033
public Box3DimensionalFunction(int m, double[] startParams, double theoreticalStartCost) { [EOL]     super(m, startParams, 0.0, new double[] { 1.0, 10.0, 1.0 }); [EOL] } <line_num>: 1098,1102
public JennrichSampsonFunction(int m, double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { [EOL]     super(m, startParams, theoreticalMinCost, theoreticalMinParams); [EOL] } <line_num>: 1138,1144
public BrownDennisFunction(int m, double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { [EOL]     super(m, startParams, theoreticalMinCost, theoreticalMinParams); [EOL]     setCostAccuracy(2.5e-8); [EOL] } <line_num>: 1174,1181
public ChebyquadFunction(int n, int m, double factor, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { [EOL]     super(m, buildChebyquadArray(n, factor), theoreticalMinCost, theoreticalMinParams); [EOL] } <line_num>: 1231,1237
public BrownAlmostLinearFunction(int m, double factor, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { [EOL]     super(m, buildArray(m, factor), theoreticalMinCost, theoreticalMinParams); [EOL] } <line_num>: 1300,1306
public Osborne1Function(double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { [EOL]     super(33, startParams, theoreticalMinCost, theoreticalMinParams); [EOL] } <line_num>: 1361,1367
public Osborne2Function(double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { [EOL]     super(65, startParams, theoreticalMinCost, theoreticalMinParams); [EOL] } <line_num>: 1414,1420
@Test [EOL] public void testMinpackLinearFullRank() { [EOL]     minpackTest(new LinearFullRankFunction(10, 5, 1.0, 5.0, 2.23606797749979), false); [EOL]     minpackTest(new LinearFullRankFunction(50, 5, 1.0, 8.06225774829855, 6.70820393249937), false); [EOL] } <line_num>: 95,101
@Test [EOL] public void testMinpackLinearRank1() { [EOL]     minpackTest(new LinearRank1Function(10, 5, 1.0, 291.521868819476, 1.4638501094228), false); [EOL]     minpackTest(new LinearRank1Function(50, 5, 1.0, 3101.60039334535, 3.48263016573496), false); [EOL] } <line_num>: 103,109
@Test [EOL] public void testMinpackLinearRank1ZeroColsAndRows() { [EOL]     minpackTest(new LinearRank1ZeroColsAndRowsFunction(10, 5, 1.0), false); [EOL]     minpackTest(new LinearRank1ZeroColsAndRowsFunction(50, 5, 1.0), false); [EOL] } <line_num>: 111,115
@Test [EOL] public void testMinpackRosenbrok() { [EOL]     minpackTest(new RosenbrockFunction(new double[] { -1.2, 1.0 }, FastMath.sqrt(24.2)), false); [EOL]     minpackTest(new RosenbrockFunction(new double[] { -12.0, 10.0 }, FastMath.sqrt(1795769.0)), false); [EOL]     minpackTest(new RosenbrockFunction(new double[] { -120.0, 100.0 }, 11.0 * FastMath.sqrt(169000121.0)), false); [EOL] } <line_num>: 117,125
@Test [EOL] public void testMinpackHelicalValley() { [EOL]     minpackTest(new HelicalValleyFunction(new double[] { -1.0, 0.0, 0.0 }, 50.0), false); [EOL]     minpackTest(new HelicalValleyFunction(new double[] { -10.0, 0.0, 0.0 }, 102.95630140987), false); [EOL]     minpackTest(new HelicalValleyFunction(new double[] { -100.0, 0.0, 0.0 }, 991.261822123701), false); [EOL] } <line_num>: 127,135
@Test [EOL] public void testMinpackPowellSingular() { [EOL]     minpackTest(new PowellSingularFunction(new double[] { 3.0, -1.0, 0.0, 1.0 }, 14.6628782986152), false); [EOL]     minpackTest(new PowellSingularFunction(new double[] { 30.0, -10.0, 0.0, 10.0 }, 1270.9838708654), false); [EOL]     minpackTest(new PowellSingularFunction(new double[] { 300.0, -100.0, 0.0, 100.0 }, 126887.903284750), false); [EOL] } <line_num>: 137,145
@Test [EOL] public void testMinpackFreudensteinRoth() { [EOL]     minpackTest(new FreudensteinRothFunction(new double[] { 0.5, -2.0 }, 20.0124960961895, 6.99887517584575, new double[] { 11.4124844654993, -0.896827913731509 }), false); [EOL]     minpackTest(new FreudensteinRothFunction(new double[] { 5.0, -20.0 }, 12432.833948863, 6.9988751744895, new double[] { 11.41300466147456, -0.896796038685959 }), false); [EOL]     minpackTest(new FreudensteinRothFunction(new double[] { 50.0, -200.0 }, 11426454.595762, 6.99887517242903, new double[] { 11.412781785788564, -0.8968051074920405 }), false); [EOL] } <line_num>: 147,167
@Test [EOL] public void testMinpackBard() { [EOL]     minpackTest(new BardFunction(1.0, 6.45613629515967, 0.0906359603390466, new double[] { 0.0824105765758334, 1.1330366534715, 2.34369463894115 }), false); [EOL]     minpackTest(new BardFunction(10.0, 36.1418531596785, 4.17476870138539, new double[] { 0.840666673818329, -158848033.259565, -164378671.653535 }), false); [EOL]     minpackTest(new BardFunction(100.0, 384.114678637399, 4.17476870135969, new double[] { 0.840666673867645, -158946167.205518, -164464906.857771 }), false); [EOL] } <line_num>: 169,189
@Test [EOL] public void testMinpackKowalikOsborne() { [EOL]     minpackTest(new KowalikOsborneFunction(new double[] { 0.25, 0.39, 0.415, 0.39 }, 0.0728915102882945, 0.017535837721129, new double[] { 0.192807810476249, 0.191262653354071, 0.123052801046931, 0.136053221150517 }), false); [EOL]     minpackTest(new KowalikOsborneFunction(new double[] { 2.5, 3.9, 4.15, 3.9 }, 2.97937007555202, 0.032052192917937, new double[] { 728675.473768287, -14.0758803129393, -32977797.7841797, -20571594.1977912 }), false); [EOL]     minpackTest(new KowalikOsborneFunction(new double[] { 25.0, 39.0, 41.5, 39.0 }, 29.9590617016037, 0.0175364017658228, new double[] { 0.192948328597594, 0.188053165007911, 0.122430604321144, 0.134575665392506 }), false); [EOL] } <line_num>: 191,220
@Test [EOL] public void testMinpackMeyer() { [EOL]     minpackTest(new MeyerFunction(new double[] { 0.02, 4000.0, 250.0 }, 41153.4665543031, 9.37794514651874, new double[] { 0.00560963647102661, 6181.34634628659, 345.223634624144 }), false); [EOL]     minpackTest(new MeyerFunction(new double[] { 0.2, 40000.0, 2500.0 }, 4168216.89130846, 792.917871779501, new double[] { 1.42367074157994e-11, 33695.7133432541, 901.268527953801 }), true); [EOL] } <line_num>: 222,238
@Test [EOL] public void testMinpackWatson() { [EOL]     minpackTest(new WatsonFunction(6, 0.0, 5.47722557505166, 0.0478295939097601, new double[] { -0.0157249615083782, 1.01243488232965, -0.232991722387673, 1.26043101102818, -1.51373031394421, 0.99299727291842 }), false); [EOL]     minpackTest(new WatsonFunction(6, 10.0, 6433.12578950026, 0.0478295939096951, new double[] { -0.0157251901386677, 1.01243485860105, -0.232991545843829, 1.26042932089163, -1.51372776706575, 0.99299573426328 }), false); [EOL]     minpackTest(new WatsonFunction(6, 100.0, 674256.040605213, 0.047829593911544, new double[] { -0.0157247019712586, 1.01243490925658, -0.232991922761641, 1.26043292929555, -1.51373320452707, 0.99299901922322 }), false); [EOL]     minpackTest(new WatsonFunction(9, 0.0, 5.47722557505166, 0.00118311459212420, new double[] { -0.153070644166722e-4, 0.999789703934597, 0.0147639634910978, 0.146342330145992, 1.00082109454817, -2.61773112070507, 4.10440313943354, -3.14361226236241, 1.05262640378759 }), false); [EOL]     minpackTest(new WatsonFunction(9, 10.0, 12088.127069307, 0.00118311459212513, new double[] { -0.153071334849279e-4, 0.999789703941234, 0.0147639629786217, 0.146342334818836, 1.00082107321386, -2.61773107084722, 4.10440307655564, -3.14361222178686, 1.05262639322589 }), false); [EOL]     minpackTest(new WatsonFunction(9, 100.0, 1269109.29043834, 0.00118311459212384, new double[] { -0.153069523352176e-4, 0.999789703958371, 0.0147639625185392, 0.146342341096326, 1.00082104729164, -2.61773101573645, 4.10440301427286, -3.14361218602503, 1.05262638516774 }), false); [EOL]     minpackTest(new WatsonFunction(12, 0.0, 5.47722557505166, 0.217310402535861e-4, new double[] { -0.660266001396382e-8, 1.00000164411833, -0.000563932146980154, 0.347820540050756, -0.156731500244233, 1.05281515825593, -3.24727109519451, 7.2884347837505, -10.271848098614, 9.07411353715783, -4.54137541918194, 1.01201187975044 }), false); [EOL]     minpackTest(new WatsonFunction(12, 10.0, 19220.7589790951, 0.217310402518509e-4, new double[] { -0.663710223017410e-8, 1.00000164411787, -0.000563932208347327, 0.347820540486998, -0.156731503955652, 1.05281517654573, -3.2472711515214, 7.28843489430665, -10.2718482369638, 9.07411364383733, -4.54137546533666, 1.01201188830857 }), false); [EOL]     minpackTest(new WatsonFunction(12, 100.0, 2018918.04462367, 0.217310402539845e-4, new double[] { -0.663806046485249e-8, 1.00000164411786, -0.000563932210324959, 0.347820540503588, -0.156731504091375, 1.05281517718031, -3.24727115337025, 7.28843489775302, -10.2718482410813, 9.07411364688464, -4.54137546660822, 1.0120118885369 }), false); [EOL] } <line_num>: 240,320
@Test [EOL] public void testMinpackBox3Dimensional() { [EOL]     minpackTest(new Box3DimensionalFunction(10, new double[] { 0.0, 10.0, 20.0 }, 32.1115837449572), false); [EOL] } <line_num>: 322,326
@Test [EOL] public void testMinpackJennrichSampson() { [EOL]     minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 }, 64.5856498144943, 11.1517793413499, new double[] { 0.2578199266368004, 0.25782997676455244 }), false); [EOL] } <line_num>: 328,336
@Test [EOL] public void testMinpackBrownDennis() { [EOL]     minpackTest(new BrownDennisFunction(20, new double[] { 25.0, 5.0, -5.0, -1.0 }, 2815.43839161816, 292.954288244866, new double[] { -11.59125141003, 13.2024883984741, -0.403574643314272, 0.236736269844604 }), false); [EOL]     minpackTest(new BrownDennisFunction(20, new double[] { 250.0, 50.0, -50.0, -10.0 }, 555073.354173069, 292.954270581415, new double[] { -11.5959274272203, 13.2041866926242, -0.403417362841545, 0.236771143410386 }), false); [EOL]     minpackTest(new BrownDennisFunction(20, new double[] { 2500.0, 500.0, -500.0, -100.0 }, 61211252.2338581, 292.954306151134, new double[] { -11.5902596937374, 13.2020628854665, -0.403688070279258, 0.236665033746463 }), false); [EOL] } <line_num>: 338,361
@Test [EOL] public void testMinpackChebyquad() { [EOL]     minpackTest(new ChebyquadFunction(1, 8, 1.0, 1.88623796907732, 1.88623796907732, new double[] { 0.5 }), false); [EOL]     minpackTest(new ChebyquadFunction(1, 8, 10.0, 5383344372.34005, 1.88424820499951, new double[] { 0.9817314924684 }), false); [EOL]     minpackTest(new ChebyquadFunction(1, 8, 100.0, 0.118088726698392e19, 1.88424820499347, new double[] { 0.9817314852934 }), false); [EOL]     minpackTest(new ChebyquadFunction(8, 8, 1.0, 0.196513862833975, 0.0593032355046727, new double[] { 0.0431536648587336, 0.193091637843267, 0.266328593812698, 0.499999334628884, 0.500000665371116, 0.733671406187302, 0.806908362156733, 0.956846335141266 }), false); [EOL]     minpackTest(new ChebyquadFunction(9, 9, 1.0, 0.16994993465202, 0.0, new double[] { 0.0442053461357828, 0.199490672309881, 0.23561910847106, 0.416046907892598, 0.5, 0.583953092107402, 0.764380891528940, 0.800509327690119, 0.955794653864217 }), false); [EOL]     minpackTest(new ChebyquadFunction(10, 10, 1.0, 0.183747831178711, 0.0806471004038253, new double[] { 0.0596202671753563, 0.166708783805937, 0.239171018813509, 0.398885290346268, 0.398883667870681, 0.601116332129320, 0.60111470965373, 0.760828981186491, 0.833291216194063, 0.940379732824644 }), false); [EOL] } <line_num>: 363,400
@Test [EOL] public void testMinpackBrownAlmostLinear() { [EOL]     minpackTest(new BrownAlmostLinearFunction(10, 0.5, 16.5302162063499, 0.0, new double[] { 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 1.20569696650138 }), false); [EOL]     minpackTest(new BrownAlmostLinearFunction(10, 5.0, 9765624.00089211, 0.0, new double[] { 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 1.20569696650135 }), false); [EOL]     minpackTest(new BrownAlmostLinearFunction(10, 50.0, 0.9765625e17, 0.0, new double[] { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 }), false); [EOL]     minpackTest(new BrownAlmostLinearFunction(30, 0.5, 83.476044467848, 0.0, new double[] { 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 1.06737350671578 }), false); [EOL]     minpackTest(new BrownAlmostLinearFunction(40, 0.5, 128.026364472323, 0.0, new double[] { 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 0.999999999999121 }), false); [EOL] } <line_num>: 402,469
@Test [EOL] public void testMinpackOsborne1() { [EOL]     minpackTest(new Osborne1Function(new double[] { 0.5, 1.5, -1.0, 0.01, 0.02 }, 0.937564021037838, 0.00739249260904843, new double[] { 0.375410049244025, 1.93584654543108, -1.46468676748716, 0.0128675339110439, 0.0221227011813076 }), false); [EOL] } <line_num>: 471,480
@Test [EOL] public void testMinpackOsborne2() { [EOL]     minpackTest(new Osborne2Function(new double[] { 1.3, 0.65, 0.65, 0.7, 0.6, 3.0, 5.0, 7.0, 2.0, 4.5, 5.5 }, 1.44686540984712, 0.20034404483314, new double[] { 1.30997663810096, 0.43155248076, 0.633661261602859, 0.599428560991695, 0.754179768272449, 0.904300082378518, 1.36579949521007, 4.82373199748107, 2.39868475104871, 4.56887554791452, 5.67534206273052 }), false); [EOL] } <line_num>: 482,497
private void minpackTest(MinpackFunction function, boolean exceptionExpected) { [EOL]     final double tol = 2.22044604926e-16; [EOL]     final double sqrtTol = FastMath.sqrt(tol); [EOL]     LevenbergMarquardtOptimizer optimizer = LevenbergMarquardtOptimizer.create(); [EOL]     optimizer = optimizer.withInitialStepBoundFactor(optimizer.getInitialStepBoundFactor()).withCostRelativeTolerance(sqrtTol).withParameterRelativeTolerance(sqrtTol).withOrthoTolerance(tol).withRankingThreshold(optimizer.getRankingThreshold()).withMaxEvaluations(400 * (function.getN() + 1)).withMaxIterations(2000).withModelAndJacobian(function.getModelFunction(), function.getModelFunctionJacobian()).withTarget(function.getTarget()).withWeight(new DiagonalMatrix(function.getWeight())).withStartPoint(function.getStartPoint()); [EOL]     try { [EOL]         final double[] optimum = optimizer.optimize().getPoint(); [EOL]         Assert.assertFalse(exceptionExpected); [EOL]         function.checkTheoreticalMinCost(optimizer.computeRMS(optimum)); [EOL]         function.checkTheoreticalMinParams(optimum); [EOL]     } catch (TooManyEvaluationsException e) { [EOL]         Assert.assertTrue(exceptionExpected); [EOL]     } [EOL] } <line_num>: 499,525
protected static double[] buildArray(int n, double x) { [EOL]     double[] array = new double[n]; [EOL]     Arrays.fill(array, x); [EOL]     return array; [EOL] } <line_num>: 548,552
public double[] getTarget() { [EOL]     return buildArray(m, 0.0); [EOL] } <line_num>: 554,556
public double[] getWeight() { [EOL]     return buildArray(m, 1.0); [EOL] } <line_num>: 558,560
public double[] getStartPoint() { [EOL]     return startParams.clone(); [EOL] } <line_num>: 562,564
protected void setCostAccuracy(double costAccuracy) { [EOL]     this.costAccuracy = costAccuracy; [EOL] } <line_num>: 566,568
protected void setParamsAccuracy(double paramsAccuracy) { [EOL]     this.paramsAccuracy = paramsAccuracy; [EOL] } <line_num>: 570,572
public int getN() { [EOL]     return startParams.length; [EOL] } <line_num>: 574,576
public void checkTheoreticalMinCost(double rms) { [EOL]     double threshold = costAccuracy * (1.0 + theoreticalMinCost); [EOL]     Assert.assertEquals(theoreticalMinCost, FastMath.sqrt(m) * rms, threshold); [EOL] } <line_num>: 578,581
public void checkTheoreticalMinParams(double[] params) { [EOL]     if (theoreticalMinParams != null) { [EOL]         for (int i = 0; i < theoreticalMinParams.length; ++i) { [EOL]             double mi = theoreticalMinParams[i]; [EOL]             double vi = params[i]; [EOL]             Assert.assertEquals(mi, vi, paramsAccuracy * (1.0 + FastMath.abs(mi))); [EOL]         } [EOL]     } [EOL] } <line_num>: 583,591
public double[] value(double[] point) { [EOL]     return computeValue(point); [EOL] } <line_num>: 595,597
public MultivariateVectorFunction getModelFunction() { [EOL]     return new MultivariateVectorFunction() { [EOL]  [EOL]         public double[] value(double[] point) { [EOL]             return computeValue(point); [EOL]         } [EOL]     }; [EOL] } <line_num>: 593,599
public double[][] value(double[] point) { [EOL]     return computeJacobian(point); [EOL] } <line_num>: 603,605
public MultivariateMatrixFunction getModelFunctionJacobian() { [EOL]     return new MultivariateMatrixFunction() { [EOL]  [EOL]         public double[][] value(double[] point) { [EOL]             return computeJacobian(point); [EOL]         } [EOL]     }; [EOL] } <line_num>: 601,607
public abstract double[][] computeJacobian(double[] variables); <line_num>: 609,609
public abstract double[] computeValue(double[] variables); <line_num>: 610,610
@Override [EOL] public double[][] computeJacobian(double[] variables) { [EOL]     double t = 2.0 / m; [EOL]     double[][] jacobian = new double[m][]; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         jacobian[i] = new double[n]; [EOL]         for (int j = 0; j < n; ++j) { [EOL]             jacobian[i][j] = (i == j) ? (1 - t) : -t; [EOL]         } [EOL]     } [EOL]     return jacobian; [EOL] } <line_num>: 623,634
@Override [EOL] public double[] computeValue(double[] variables) { [EOL]     double sum = 0; [EOL]     for (int i = 0; i < n; ++i) { [EOL]         sum += variables[i]; [EOL]     } [EOL]     double t = 1 + 2 * sum / m; [EOL]     double[] f = new double[m]; [EOL]     for (int i = 0; i < n; ++i) { [EOL]         f[i] = variables[i] - t; [EOL]     } [EOL]     Arrays.fill(f, n, m, -t); [EOL]     return f; [EOL] } <line_num>: 636,649
@Override [EOL] public double[][] computeJacobian(double[] variables) { [EOL]     double[][] jacobian = new double[m][]; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         jacobian[i] = new double[n]; [EOL]         for (int j = 0; j < n; ++j) { [EOL]             jacobian[i][j] = (i + 1) * (j + 1); [EOL]         } [EOL]     } [EOL]     return jacobian; [EOL] } <line_num>: 661,671
@Override [EOL] public double[] computeValue(double[] variables) { [EOL]     double[] f = new double[m]; [EOL]     double sum = 0; [EOL]     for (int i = 0; i < n; ++i) { [EOL]         sum += (i + 1) * variables[i]; [EOL]     } [EOL]     for (int i = 0; i < m; ++i) { [EOL]         f[i] = (i + 1) * sum - 1; [EOL]     } [EOL]     return f; [EOL] } <line_num>: 673,684
@Override [EOL] public double[][] computeJacobian(double[] variables) { [EOL]     double[][] jacobian = new double[m][]; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         jacobian[i] = new double[n]; [EOL]         jacobian[i][0] = 0; [EOL]         for (int j = 1; j < (n - 1); ++j) { [EOL]             if (i == 0) { [EOL]                 jacobian[i][j] = 0; [EOL]             } else if (i != (m - 1)) { [EOL]                 jacobian[i][j] = i * (j + 1); [EOL]             } else { [EOL]                 jacobian[i][j] = 0; [EOL]             } [EOL]         } [EOL]         jacobian[i][n - 1] = 0; [EOL]     } [EOL]     return jacobian; [EOL] } <line_num>: 696,714
@Override [EOL] public double[] computeValue(double[] variables) { [EOL]     double[] f = new double[m]; [EOL]     double sum = 0; [EOL]     for (int i = 1; i < (n - 1); ++i) { [EOL]         sum += (i + 1) * variables[i]; [EOL]     } [EOL]     for (int i = 0; i < (m - 1); ++i) { [EOL]         f[i] = i * sum - 1; [EOL]     } [EOL]     f[m - 1] = -1; [EOL]     return f; [EOL] } <line_num>: 716,728
@Override [EOL] public double[][] computeJacobian(double[] variables) { [EOL]     double x1 = variables[0]; [EOL]     return new double[][] { { -20 * x1, 10 }, { -1, 0 } }; [EOL] } <line_num>: 737,741
@Override [EOL] public double[] computeValue(double[] variables) { [EOL]     double x1 = variables[0]; [EOL]     double x2 = variables[1]; [EOL]     return new double[] { 10 * (x2 - x1 * x1), 1 - x1 }; [EOL] } <line_num>: 743,748
@Override [EOL] public double[][] computeJacobian(double[] variables) { [EOL]     double x1 = variables[0]; [EOL]     double x2 = variables[1]; [EOL]     double tmpSquare = x1 * x1 + x2 * x2; [EOL]     double tmp1 = twoPi * tmpSquare; [EOL]     double tmp2 = FastMath.sqrt(tmpSquare); [EOL]     return new double[][] { { 100 * x2 / tmp1, -100 * x1 / tmp1, 10 }, { 10 * x1 / tmp2, 10 * x2 / tmp2, 0 }, { 0, 0, 1 } }; [EOL] } <line_num>: 758,770
@Override [EOL] public double[] computeValue(double[] variables) { [EOL]     double x1 = variables[0]; [EOL]     double x2 = variables[1]; [EOL]     double x3 = variables[2]; [EOL]     double tmp1; [EOL]     if (x1 == 0) { [EOL]         tmp1 = (x2 >= 0) ? 0.25 : -0.25; [EOL]     } else { [EOL]         tmp1 = FastMath.atan(x2 / x1) / twoPi; [EOL]         if (x1 < 0) { [EOL]             tmp1 += 0.5; [EOL]         } [EOL]     } [EOL]     double tmp2 = FastMath.sqrt(x1 * x1 + x2 * x2); [EOL]     return new double[] { 10.0 * (x3 - 10 * tmp1), 10.0 * (tmp2 - 1), x3 }; [EOL] } <line_num>: 772,792
@Override [EOL] public double[][] computeJacobian(double[] variables) { [EOL]     double x1 = variables[0]; [EOL]     double x2 = variables[1]; [EOL]     double x3 = variables[2]; [EOL]     double x4 = variables[3]; [EOL]     return new double[][] { { 1, 10, 0, 0 }, { 0, 0, sqrt5, -sqrt5 }, { 0, 2 * (x2 - 2 * x3), -4 * (x2 - 2 * x3), 0 }, { 2 * sqrt10 * (x1 - x4), 0, 0, -2 * sqrt10 * (x1 - x4) } }; [EOL] } <line_num>: 805,817
@Override [EOL] public double[] computeValue(double[] variables) { [EOL]     double x1 = variables[0]; [EOL]     double x2 = variables[1]; [EOL]     double x3 = variables[2]; [EOL]     double x4 = variables[3]; [EOL]     return new double[] { x1 + 10 * x2, sqrt5 * (x3 - x4), (x2 - 2 * x3) * (x2 - 2 * x3), sqrt10 * (x1 - x4) * (x1 - x4) }; [EOL] } <line_num>: 819,831
@Override [EOL] public double[][] computeJacobian(double[] variables) { [EOL]     double x2 = variables[1]; [EOL]     return new double[][] { { 1, x2 * (10 - 3 * x2) - 2 }, { 1, x2 * (2 + 3 * x2) - 14 } }; [EOL] } <line_num>: 848,855
@Override [EOL] public double[] computeValue(double[] variables) { [EOL]     double x1 = variables[0]; [EOL]     double x2 = variables[1]; [EOL]     return new double[] { -13.0 + x1 + ((5.0 - x2) * x2 - 2.0) * x2, -29.0 + x1 + ((1.0 + x2) * x2 - 14.0) * x2 }; [EOL] } <line_num>: 857,865
@Override [EOL] public double[][] computeJacobian(double[] variables) { [EOL]     double x2 = variables[1]; [EOL]     double x3 = variables[2]; [EOL]     double[][] jacobian = new double[m][]; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         double tmp1 = i + 1; [EOL]         double tmp2 = 15 - i; [EOL]         double tmp3 = (i <= 7) ? tmp1 : tmp2; [EOL]         double tmp4 = x2 * tmp2 + x3 * tmp3; [EOL]         tmp4 *= tmp4; [EOL]         jacobian[i] = new double[] { -1, tmp1 * tmp2 / tmp4, tmp1 * tmp3 / tmp4 }; [EOL]     } [EOL]     return jacobian; [EOL] } <line_num>: 879,893
@Override [EOL] public double[] computeValue(double[] variables) { [EOL]     double x1 = variables[0]; [EOL]     double x2 = variables[1]; [EOL]     double x3 = variables[2]; [EOL]     double[] f = new double[m]; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         double tmp1 = i + 1; [EOL]         double tmp2 = 15 - i; [EOL]         double tmp3 = (i <= 7) ? tmp1 : tmp2; [EOL]         f[i] = y[i] - (x1 + tmp1 / (x2 * tmp2 + x3 * tmp3)); [EOL]     } [EOL]     return f; [EOL] } <line_num>: 895,908
@Override [EOL] public double[][] computeJacobian(double[] variables) { [EOL]     double x1 = variables[0]; [EOL]     double x2 = variables[1]; [EOL]     double x3 = variables[2]; [EOL]     double x4 = variables[3]; [EOL]     double[][] jacobian = new double[m][]; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         double tmp = v[i] * (v[i] + x3) + x4; [EOL]         double j1 = -v[i] * (v[i] + x2) / tmp; [EOL]         double j2 = -v[i] * x1 / tmp; [EOL]         double j3 = j1 * j2; [EOL]         double j4 = j3 / v[i]; [EOL]         jacobian[i] = new double[] { j1, j2, j3, j4 }; [EOL]     } [EOL]     return jacobian; [EOL] } <line_num>: 932,948
@Override [EOL] public double[] computeValue(double[] variables) { [EOL]     double x1 = variables[0]; [EOL]     double x2 = variables[1]; [EOL]     double x3 = variables[2]; [EOL]     double x4 = variables[3]; [EOL]     double[] f = new double[m]; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         f[i] = y[i] - x1 * (v[i] * (v[i] + x2)) / (v[i] * (v[i] + x3) + x4); [EOL]     } [EOL]     return f; [EOL] } <line_num>: 950,961
@Override [EOL] public double[][] computeJacobian(double[] variables) { [EOL]     double x1 = variables[0]; [EOL]     double x2 = variables[1]; [EOL]     double x3 = variables[2]; [EOL]     double[][] jacobian = new double[m][]; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         double temp = 5.0 * (i + 1) + 45.0 + x3; [EOL]         double tmp1 = x2 / temp; [EOL]         double tmp2 = FastMath.exp(tmp1); [EOL]         double tmp3 = x1 * tmp2 / temp; [EOL]         jacobian[i] = new double[] { tmp2, tmp3, -tmp1 * tmp3 }; [EOL]     } [EOL]     return jacobian; [EOL] } <line_num>: 988,1002
@Override [EOL] public double[] computeValue(double[] variables) { [EOL]     double x1 = variables[0]; [EOL]     double x2 = variables[1]; [EOL]     double x3 = variables[2]; [EOL]     double[] f = new double[m]; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         f[i] = x1 * FastMath.exp(x2 / (5.0 * (i + 1) + 45.0 + x3)) - y[i]; [EOL]     } [EOL]     return f; [EOL] } <line_num>: 1004,1014
@Override [EOL] public double[][] computeJacobian(double[] variables) { [EOL]     double[][] jacobian = new double[m][]; [EOL]     for (int i = 0; i < (m - 2); ++i) { [EOL]         double div = (i + 1) / 29.0; [EOL]         double s2 = 0.0; [EOL]         double dx = 1.0; [EOL]         for (int j = 0; j < n; ++j) { [EOL]             s2 += dx * variables[j]; [EOL]             dx *= div; [EOL]         } [EOL]         double temp = 2 * div * s2; [EOL]         dx = 1.0 / div; [EOL]         jacobian[i] = new double[n]; [EOL]         for (int j = 0; j < n; ++j) { [EOL]             jacobian[i][j] = dx * (j - temp); [EOL]             dx *= div; [EOL]         } [EOL]     } [EOL]     jacobian[m - 2] = new double[n]; [EOL]     jacobian[m - 2][0] = 1; [EOL]     jacobian[m - 1] = new double[n]; [EOL]     jacobian[m - 1][0] = -2 * variables[0]; [EOL]     jacobian[m - 1][1] = 1; [EOL]     return jacobian; [EOL] } <line_num>: 1035,1064
@Override [EOL] public double[] computeValue(double[] variables) { [EOL]     double[] f = new double[m]; [EOL]     for (int i = 0; i < (m - 2); ++i) { [EOL]         double div = (i + 1) / 29.0; [EOL]         double s1 = 0; [EOL]         double dx = 1; [EOL]         for (int j = 1; j < n; ++j) { [EOL]             s1 += j * dx * variables[j]; [EOL]             dx *= div; [EOL]         } [EOL]         double s2 = 0; [EOL]         dx = 1; [EOL]         for (int j = 0; j < n; ++j) { [EOL]             s2 += dx * variables[j]; [EOL]             dx *= div; [EOL]         } [EOL]         f[i] = s1 - s2 * s2 - 1; [EOL]     } [EOL]     double x1 = variables[0]; [EOL]     double x2 = variables[1]; [EOL]     f[m - 2] = x1; [EOL]     f[m - 1] = x2 - x1 * x1 - 1; [EOL]     return f; [EOL] } <line_num>: 1066,1092
@Override [EOL] public double[][] computeJacobian(double[] variables) { [EOL]     double x1 = variables[0]; [EOL]     double x2 = variables[1]; [EOL]     double[][] jacobian = new double[m][]; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         double tmp = (i + 1) / 10.0; [EOL]         jacobian[i] = new double[] { -tmp * FastMath.exp(-tmp * x1), tmp * FastMath.exp(-tmp * x2), FastMath.exp(-i - 1) - FastMath.exp(-tmp) }; [EOL]     } [EOL]     return jacobian; [EOL] } <line_num>: 1104,1118
@Override [EOL] public double[] computeValue(double[] variables) { [EOL]     double x1 = variables[0]; [EOL]     double x2 = variables[1]; [EOL]     double x3 = variables[2]; [EOL]     double[] f = new double[m]; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         double tmp = (i + 1) / 10.0; [EOL]         f[i] = FastMath.exp(-tmp * x1) - FastMath.exp(-tmp * x2) + (FastMath.exp(-i - 1) - FastMath.exp(-tmp)) * x3; [EOL]     } [EOL]     return f; [EOL] } <line_num>: 1120,1132
@Override [EOL] public double[][] computeJacobian(double[] variables) { [EOL]     double x1 = variables[0]; [EOL]     double x2 = variables[1]; [EOL]     double[][] jacobian = new double[m][]; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         double t = i + 1; [EOL]         jacobian[i] = new double[] { -t * FastMath.exp(t * x1), -t * FastMath.exp(t * x2) }; [EOL]     } [EOL]     return jacobian; [EOL] } <line_num>: 1146,1156
@Override [EOL] public double[] computeValue(double[] variables) { [EOL]     double x1 = variables[0]; [EOL]     double x2 = variables[1]; [EOL]     double[] f = new double[m]; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         double temp = i + 1; [EOL]         f[i] = 2 + 2 * temp - FastMath.exp(temp * x1) - FastMath.exp(temp * x2); [EOL]     } [EOL]     return f; [EOL] } <line_num>: 1158,1168
@Override [EOL] public double[][] computeJacobian(double[] variables) { [EOL]     double x1 = variables[0]; [EOL]     double x2 = variables[1]; [EOL]     double x3 = variables[2]; [EOL]     double x4 = variables[3]; [EOL]     double[][] jacobian = new double[m][]; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         double temp = (i + 1) / 5.0; [EOL]         double ti = FastMath.sin(temp); [EOL]         double tmp1 = x1 + temp * x2 - FastMath.exp(temp); [EOL]         double tmp2 = x3 + ti * x4 - FastMath.cos(temp); [EOL]         jacobian[i] = new double[] { 2 * tmp1, 2 * temp * tmp1, 2 * tmp2, 2 * ti * tmp2 }; [EOL]     } [EOL]     return jacobian; [EOL] } <line_num>: 1183,1200
@Override [EOL] public double[] computeValue(double[] variables) { [EOL]     double x1 = variables[0]; [EOL]     double x2 = variables[1]; [EOL]     double x3 = variables[2]; [EOL]     double x4 = variables[3]; [EOL]     double[] f = new double[m]; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         double temp = (i + 1) / 5.0; [EOL]         double tmp1 = x1 + temp * x2 - FastMath.exp(temp); [EOL]         double tmp2 = x3 + FastMath.sin(temp) * x4 - FastMath.cos(temp); [EOL]         f[i] = tmp1 * tmp1 + tmp2 * tmp2; [EOL]     } [EOL]     return f; [EOL] } <line_num>: 1202,1216
private static double[] buildChebyquadArray(int n, double factor) { [EOL]     double[] array = new double[n]; [EOL]     double inv = factor / (n + 1); [EOL]     for (int i = 0; i < n; ++i) { [EOL]         array[i] = (i + 1) * inv; [EOL]     } [EOL]     return array; [EOL] } <line_num>: 1222,1229
@Override [EOL] public double[][] computeJacobian(double[] variables) { [EOL]     double[][] jacobian = new double[m][]; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         jacobian[i] = new double[n]; [EOL]     } [EOL]     double dx = 1.0 / n; [EOL]     for (int j = 0; j < n; ++j) { [EOL]         double tmp1 = 1; [EOL]         double tmp2 = 2 * variables[j] - 1; [EOL]         double temp = 2 * tmp2; [EOL]         double tmp3 = 0; [EOL]         double tmp4 = 2; [EOL]         for (int i = 0; i < m; ++i) { [EOL]             jacobian[i][j] = dx * tmp4; [EOL]             double ti = 4 * tmp2 + temp * tmp4 - tmp3; [EOL]             tmp3 = tmp4; [EOL]             tmp4 = ti; [EOL]             ti = temp * tmp2 - tmp1; [EOL]             tmp1 = tmp2; [EOL]             tmp2 = ti; [EOL]         } [EOL]     } [EOL]     return jacobian; [EOL] } <line_num>: 1239,1265
@Override [EOL] public double[] computeValue(double[] variables) { [EOL]     double[] f = new double[m]; [EOL]     for (int j = 0; j < n; ++j) { [EOL]         double tmp1 = 1; [EOL]         double tmp2 = 2 * variables[j] - 1; [EOL]         double temp = 2 * tmp2; [EOL]         for (int i = 0; i < m; ++i) { [EOL]             f[i] += tmp2; [EOL]             double ti = temp * tmp2 - tmp1; [EOL]             tmp1 = tmp2; [EOL]             tmp2 = ti; [EOL]         } [EOL]     } [EOL]     double dx = 1.0 / n; [EOL]     boolean iev = false; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         f[i] *= dx; [EOL]         if (iev) { [EOL]             f[i] += 1.0 / (i * (i + 2)); [EOL]         } [EOL]         iev = !iev; [EOL]     } [EOL]     return f; [EOL] } <line_num>: 1267,1294
@Override [EOL] public double[][] computeJacobian(double[] variables) { [EOL]     double[][] jacobian = new double[m][]; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         jacobian[i] = new double[n]; [EOL]     } [EOL]     double prod = 1; [EOL]     for (int j = 0; j < n; ++j) { [EOL]         prod *= variables[j]; [EOL]         for (int i = 0; i < n; ++i) { [EOL]             jacobian[i][j] = 1; [EOL]         } [EOL]         jacobian[j][j] = 2; [EOL]     } [EOL]     for (int j = 0; j < n; ++j) { [EOL]         double temp = variables[j]; [EOL]         if (temp == 0) { [EOL]             temp = 1; [EOL]             prod = 1; [EOL]             for (int k = 0; k < n; ++k) { [EOL]                 if (k != j) { [EOL]                     prod *= variables[k]; [EOL]                 } [EOL]             } [EOL]         } [EOL]         jacobian[n - 1][j] = prod / temp; [EOL]     } [EOL]     return jacobian; [EOL] } <line_num>: 1308,1339
@Override [EOL] public double[] computeValue(double[] variables) { [EOL]     double[] f = new double[m]; [EOL]     double sum = -(n + 1); [EOL]     double prod = 1; [EOL]     for (int j = 0; j < n; ++j) { [EOL]         sum += variables[j]; [EOL]         prod *= variables[j]; [EOL]     } [EOL]     for (int i = 0; i < n; ++i) { [EOL]         f[i] = variables[i] + sum; [EOL]     } [EOL]     f[n - 1] = prod - 1; [EOL]     return f; [EOL] } <line_num>: 1341,1355
@Override [EOL] public double[][] computeJacobian(double[] variables) { [EOL]     double x2 = variables[1]; [EOL]     double x3 = variables[2]; [EOL]     double x4 = variables[3]; [EOL]     double x5 = variables[4]; [EOL]     double[][] jacobian = new double[m][]; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         double temp = 10.0 * i; [EOL]         double tmp1 = FastMath.exp(-temp * x4); [EOL]         double tmp2 = FastMath.exp(-temp * x5); [EOL]         jacobian[i] = new double[] { -1, -tmp1, -tmp2, temp * x2 * tmp1, temp * x3 * tmp2 }; [EOL]     } [EOL]     return jacobian; [EOL] } <line_num>: 1369,1385
@Override [EOL] public double[] computeValue(double[] variables) { [EOL]     double x1 = variables[0]; [EOL]     double x2 = variables[1]; [EOL]     double x3 = variables[2]; [EOL]     double x4 = variables[3]; [EOL]     double x5 = variables[4]; [EOL]     double[] f = new double[m]; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         double temp = 10.0 * i; [EOL]         double tmp1 = FastMath.exp(-temp * x4); [EOL]         double tmp2 = FastMath.exp(-temp * x5); [EOL]         f[i] = y[i] - (x1 + x2 * tmp1 + x3 * tmp2); [EOL]     } [EOL]     return f; [EOL] } <line_num>: 1387,1402
@Override [EOL] public double[][] computeJacobian(double[] variables) { [EOL]     double x01 = variables[0]; [EOL]     double x02 = variables[1]; [EOL]     double x03 = variables[2]; [EOL]     double x04 = variables[3]; [EOL]     double x05 = variables[4]; [EOL]     double x06 = variables[5]; [EOL]     double x07 = variables[6]; [EOL]     double x08 = variables[7]; [EOL]     double x09 = variables[8]; [EOL]     double x10 = variables[9]; [EOL]     double x11 = variables[10]; [EOL]     double[][] jacobian = new double[m][]; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         double temp = i / 10.0; [EOL]         double tmp1 = FastMath.exp(-x05 * temp); [EOL]         double tmp2 = FastMath.exp(-x06 * (temp - x09) * (temp - x09)); [EOL]         double tmp3 = FastMath.exp(-x07 * (temp - x10) * (temp - x10)); [EOL]         double tmp4 = FastMath.exp(-x08 * (temp - x11) * (temp - x11)); [EOL]         jacobian[i] = new double[] { -tmp1, -tmp2, -tmp3, -tmp4, temp * x01 * tmp1, x02 * (temp - x09) * (temp - x09) * tmp2, x03 * (temp - x10) * (temp - x10) * tmp3, x04 * (temp - x11) * (temp - x11) * tmp4, -2 * x02 * x06 * (temp - x09) * tmp2, -2 * x03 * x07 * (temp - x10) * tmp3, -2 * x04 * x08 * (temp - x11) * tmp4 }; [EOL]     } [EOL]     return jacobian; [EOL] } <line_num>: 1422,1457
@Override [EOL] public double[] computeValue(double[] variables) { [EOL]     double x01 = variables[0]; [EOL]     double x02 = variables[1]; [EOL]     double x03 = variables[2]; [EOL]     double x04 = variables[3]; [EOL]     double x05 = variables[4]; [EOL]     double x06 = variables[5]; [EOL]     double x07 = variables[6]; [EOL]     double x08 = variables[7]; [EOL]     double x09 = variables[8]; [EOL]     double x10 = variables[9]; [EOL]     double x11 = variables[10]; [EOL]     double[] f = new double[m]; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         double temp = i / 10.0; [EOL]         double tmp1 = FastMath.exp(-x05 * temp); [EOL]         double tmp2 = FastMath.exp(-x06 * (temp - x09) * (temp - x09)); [EOL]         double tmp3 = FastMath.exp(-x07 * (temp - x10) * (temp - x10)); [EOL]         double tmp4 = FastMath.exp(-x08 * (temp - x11) * (temp - x11)); [EOL]         f[i] = y[i] - (x01 * tmp1 + x02 * tmp2 + x03 * tmp3 + x04 * tmp4); [EOL]     } [EOL]     return f; [EOL] } <line_num>: 1459,1482
