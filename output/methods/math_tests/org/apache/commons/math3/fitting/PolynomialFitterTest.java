@Test [EOL] public void testFit() { [EOL]     final RealDistribution rng = new UniformRealDistribution(-100, 100); [EOL]     rng.reseedRandomGenerator(64925784252L); [EOL]     final LevenbergMarquardtOptimizer optim = new LevenbergMarquardtOptimizer(); [EOL]     final PolynomialFitter fitter = new PolynomialFitter(optim); [EOL]     final double[] coeff = { 12.9, -3.4, 2.1 }; [EOL]     final PolynomialFunction f = new PolynomialFunction(coeff); [EOL]     for (int i = 0; i < 100; i++) { [EOL]         final double x = rng.sample(); [EOL]         fitter.addObservedPoint(x, f.value(x)); [EOL]     } [EOL]     final double[] best = fitter.fit(new double[] { -1e-20, 3e15, -5e25 }); [EOL]     TestUtils.assertEquals("best != coeff", coeff, best, 1e-12); [EOL] } <line_num>: 40,60
@Test [EOL] public void testNoError() { [EOL]     Random randomizer = new Random(64925784252l); [EOL]     for (int degree = 1; degree < 10; ++degree) { [EOL]         PolynomialFunction p = buildRandomPolynomial(degree, randomizer); [EOL]         PolynomialFitter fitter = new PolynomialFitter(new LevenbergMarquardtOptimizer()); [EOL]         for (int i = 0; i <= degree; ++i) { [EOL]             fitter.addObservedPoint(1.0, i, p.value(i)); [EOL]         } [EOL]         final double[] init = new double[degree + 1]; [EOL]         PolynomialFunction fitted = new PolynomialFunction(fitter.fit(init)); [EOL]         for (double x = -1.0; x < 1.0; x += 0.01) { [EOL]             double error = FastMath.abs(p.value(x) - fitted.value(x)) / (1.0 + FastMath.abs(p.value(x))); [EOL]             Assert.assertEquals(0.0, error, 1.0e-6); [EOL]         } [EOL]     } [EOL] } <line_num>: 62,82
@Test [EOL] public void testSmallError() { [EOL]     Random randomizer = new Random(53882150042l); [EOL]     double maxError = 0; [EOL]     for (int degree = 0; degree < 10; ++degree) { [EOL]         PolynomialFunction p = buildRandomPolynomial(degree, randomizer); [EOL]         PolynomialFitter fitter = new PolynomialFitter(new LevenbergMarquardtOptimizer()); [EOL]         for (double x = -1.0; x < 1.0; x += 0.01) { [EOL]             fitter.addObservedPoint(1.0, x, p.value(x) + 0.1 * randomizer.nextGaussian()); [EOL]         } [EOL]         final double[] init = new double[degree + 1]; [EOL]         PolynomialFunction fitted = new PolynomialFunction(fitter.fit(init)); [EOL]         for (double x = -1.0; x < 1.0; x += 0.01) { [EOL]             double error = FastMath.abs(p.value(x) - fitted.value(x)) / (1.0 + FastMath.abs(p.value(x))); [EOL]             maxError = FastMath.max(maxError, error); [EOL]             Assert.assertTrue(FastMath.abs(error) < 0.1); [EOL]         } [EOL]     } [EOL]     Assert.assertTrue(maxError > 0.01); [EOL] } <line_num>: 84,108
@Test [EOL] public void testMath798() { [EOL]     final double tol = 1e-14; [EOL]     final SimpleVectorValueChecker checker = new SimpleVectorValueChecker(tol, tol); [EOL]     final double[] init = new double[] { 0, 0 }; [EOL]     final int maxEval = 3; [EOL]     final double[] lm = doMath798(new LevenbergMarquardtOptimizer(checker), maxEval, init); [EOL]     final double[] gn = doMath798(new GaussNewtonOptimizer(checker), maxEval, init); [EOL]     for (int i = 0; i <= 1; i++) { [EOL]         Assert.assertEquals(lm[i], gn[i], tol); [EOL]     } [EOL] } <line_num>: 110,123
@Test(expected = TooManyEvaluationsException.class) [EOL] public void testMath798WithToleranceTooLow() { [EOL]     final double tol = 1e-100; [EOL]     final SimpleVectorValueChecker checker = new SimpleVectorValueChecker(tol, tol); [EOL]     final double[] init = new double[] { 0, 0 }; [EOL]     final int maxEval = 10000; [EOL]     @SuppressWarnings("unused") [EOL]     final double[] gn = doMath798(new GaussNewtonOptimizer(checker), maxEval, init); [EOL] } <line_num>: 131,140
@Test [EOL] public void testMath798WithToleranceTooLowButNoException() { [EOL]     final double tol = 1e-100; [EOL]     final double[] init = new double[] { 0, 0 }; [EOL]     final int maxEval = 10000; [EOL]     final SimpleVectorValueChecker checker = new SimpleVectorValueChecker(tol, tol, maxEval); [EOL]     final double[] lm = doMath798(new LevenbergMarquardtOptimizer(checker), maxEval, init); [EOL]     final double[] gn = doMath798(new GaussNewtonOptimizer(checker), maxEval, init); [EOL]     for (int i = 0; i <= 1; i++) { [EOL]         Assert.assertEquals(lm[i], gn[i], 1e-15); [EOL]     } [EOL] } <line_num>: 149,162
private double[] doMath798(MultivariateVectorOptimizer optimizer, int maxEval, double[] init) { [EOL]     final CurveFitter<Parametric> fitter = new CurveFitter<Parametric>(optimizer); [EOL]     fitter.addObservedPoint(-0.2, -7.12442E-13); [EOL]     fitter.addObservedPoint(-0.199, -4.33397E-13); [EOL]     fitter.addObservedPoint(-0.198, -2.823E-13); [EOL]     fitter.addObservedPoint(-0.197, -1.40405E-13); [EOL]     fitter.addObservedPoint(-0.196, -7.80821E-15); [EOL]     fitter.addObservedPoint(-0.195, 6.20484E-14); [EOL]     fitter.addObservedPoint(-0.194, 7.24673E-14); [EOL]     fitter.addObservedPoint(-0.193, 1.47152E-13); [EOL]     fitter.addObservedPoint(-0.192, 1.9629E-13); [EOL]     fitter.addObservedPoint(-0.191, 2.12038E-13); [EOL]     fitter.addObservedPoint(-0.19, 2.46906E-13); [EOL]     fitter.addObservedPoint(-0.189, 2.77495E-13); [EOL]     fitter.addObservedPoint(-0.188, 2.51281E-13); [EOL]     fitter.addObservedPoint(-0.187, 2.64001E-13); [EOL]     fitter.addObservedPoint(-0.186, 2.8882E-13); [EOL]     fitter.addObservedPoint(-0.185, 3.13604E-13); [EOL]     fitter.addObservedPoint(-0.184, 3.14248E-13); [EOL]     fitter.addObservedPoint(-0.183, 3.1172E-13); [EOL]     fitter.addObservedPoint(-0.182, 3.12912E-13); [EOL]     fitter.addObservedPoint(-0.181, 3.06761E-13); [EOL]     fitter.addObservedPoint(-0.18, 2.8559E-13); [EOL]     fitter.addObservedPoint(-0.179, 2.86806E-13); [EOL]     fitter.addObservedPoint(-0.178, 2.985E-13); [EOL]     fitter.addObservedPoint(-0.177, 2.67148E-13); [EOL]     fitter.addObservedPoint(-0.176, 2.94173E-13); [EOL]     fitter.addObservedPoint(-0.175, 3.27528E-13); [EOL]     fitter.addObservedPoint(-0.174, 3.33858E-13); [EOL]     fitter.addObservedPoint(-0.173, 2.97511E-13); [EOL]     fitter.addObservedPoint(-0.172, 2.8615E-13); [EOL]     fitter.addObservedPoint(-0.171, 2.84624E-13); [EOL]     final double[] coeff = fitter.fit(maxEval, new PolynomialFunction.Parametric(), init); [EOL]     return coeff; [EOL] } <line_num>: 170,210
@Test [EOL] public void testRedundantSolvable() { [EOL]     checkUnsolvableProblem(new LevenbergMarquardtOptimizer(), true); [EOL] } <line_num>: 212,216
@Test [EOL] public void testRedundantUnsolvable() { [EOL]     checkUnsolvableProblem(new GaussNewtonOptimizer(true, new SimpleVectorValueChecker(1e-15, 1e-15)), false); [EOL] } <line_num>: 218,222
@Test [EOL] public void testLargeSample() { [EOL]     Random randomizer = new Random(0x5551480dca5b369bl); [EOL]     double maxError = 0; [EOL]     for (int degree = 0; degree < 10; ++degree) { [EOL]         PolynomialFunction p = buildRandomPolynomial(degree, randomizer); [EOL]         PolynomialFitter fitter = new PolynomialFitter(new LevenbergMarquardtOptimizer()); [EOL]         for (int i = 0; i < 40000; ++i) { [EOL]             double x = -1.0 + i / 20000.0; [EOL]             fitter.addObservedPoint(1.0, x, p.value(x) + 0.1 * randomizer.nextGaussian()); [EOL]         } [EOL]         final double[] init = new double[degree + 1]; [EOL]         PolynomialFunction fitted = new PolynomialFunction(fitter.fit(init)); [EOL]         for (double x = -1.0; x < 1.0; x += 0.01) { [EOL]             double error = FastMath.abs(p.value(x) - fitted.value(x)) / (1.0 + FastMath.abs(p.value(x))); [EOL]             maxError = FastMath.max(maxError, error); [EOL]             Assert.assertTrue(FastMath.abs(error) < 0.01); [EOL]         } [EOL]     } [EOL]     Assert.assertTrue(maxError > 0.001); [EOL] } <line_num>: 224,249
private void checkUnsolvableProblem(MultivariateVectorOptimizer optimizer, boolean solvable) { [EOL]     Random randomizer = new Random(1248788532l); [EOL]     for (int degree = 0; degree < 10; ++degree) { [EOL]         PolynomialFunction p = buildRandomPolynomial(degree, randomizer); [EOL]         PolynomialFitter fitter = new PolynomialFitter(optimizer); [EOL]         for (double x = -1.0; x < 1.0; x += 0.01) { [EOL]             fitter.addObservedPoint(1.0, 0.0, p.value(0.0)); [EOL]         } [EOL]         try { [EOL]             final double[] init = new double[degree + 1]; [EOL]             fitter.fit(init); [EOL]             Assert.assertTrue(solvable || (degree == 0)); [EOL]         } catch (ConvergenceException e) { [EOL]             Assert.assertTrue((!solvable) && (degree > 0)); [EOL]         } [EOL]     } [EOL] } <line_num>: 251,275
private PolynomialFunction buildRandomPolynomial(int degree, Random randomizer) { [EOL]     final double[] coefficients = new double[degree + 1]; [EOL]     for (int i = 0; i <= degree; ++i) { [EOL]         coefficients[i] = randomizer.nextGaussian(); [EOL]     } [EOL]     return new PolynomialFunction(coefficients); [EOL] } <line_num>: 277,283
