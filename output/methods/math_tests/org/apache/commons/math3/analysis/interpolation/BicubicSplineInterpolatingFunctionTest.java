@Test [EOL] public void testPreconditions() { [EOL]     double[] xval = new double[] { 3, 4, 5, 6.5 }; [EOL]     double[] yval = new double[] { -4, -3, -1, 2.5 }; [EOL]     double[][] zval = new double[xval.length][yval.length]; [EOL]     @SuppressWarnings("unused") [EOL]     BivariateFunction bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, zval, zval, zval); [EOL]     double[] wxval = new double[] { 3, 2, 5, 6.5 }; [EOL]     try { [EOL]         bcf = new BicubicSplineInterpolatingFunction(wxval, yval, zval, zval, zval, zval); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (MathIllegalArgumentException e) { [EOL]     } [EOL]     double[] wyval = new double[] { -4, -1, -1, 2.5 }; [EOL]     try { [EOL]         bcf = new BicubicSplineInterpolatingFunction(xval, wyval, zval, zval, zval, zval); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (MathIllegalArgumentException e) { [EOL]     } [EOL]     double[][] wzval = new double[xval.length][yval.length - 1]; [EOL]     try { [EOL]         bcf = new BicubicSplineInterpolatingFunction(xval, yval, wzval, zval, zval, zval); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (DimensionMismatchException e) { [EOL]     } [EOL]     try { [EOL]         bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, wzval, zval, zval); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (DimensionMismatchException e) { [EOL]     } [EOL]     try { [EOL]         bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, zval, wzval, zval); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (DimensionMismatchException e) { [EOL]     } [EOL]     try { [EOL]         bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, zval, zval, wzval); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (DimensionMismatchException e) { [EOL]     } [EOL]     wzval = new double[xval.length - 1][yval.length]; [EOL]     try { [EOL]         bcf = new BicubicSplineInterpolatingFunction(xval, yval, wzval, zval, zval, zval); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (DimensionMismatchException e) { [EOL]     } [EOL]     try { [EOL]         bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, wzval, zval, zval); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (DimensionMismatchException e) { [EOL]     } [EOL]     try { [EOL]         bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, zval, wzval, zval); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (DimensionMismatchException e) { [EOL]     } [EOL]     try { [EOL]         bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, zval, zval, wzval); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (DimensionMismatchException e) { [EOL]     } [EOL] } <line_num>: 39,114
public double value(double x, double y) { [EOL]     return 2 * x - 3 * y + 5; [EOL] } <line_num>: 127,129
@Ignore [EOL] @Test [EOL] public void testPlane() { [EOL]     double[] xval = new double[] { 3, 4, 5, 6.5 }; [EOL]     double[] yval = new double[] { -4, -3, -1, 2, 2.5 }; [EOL]     BivariateFunction f = new BivariateFunction() { [EOL]  [EOL]         public double value(double x, double y) { [EOL]             return 2 * x - 3 * y + 5; [EOL]         } [EOL]     }; [EOL]     double[][] zval = new double[xval.length][yval.length]; [EOL]     for (int i = 0; i < xval.length; i++) { [EOL]         for (int j = 0; j < yval.length; j++) { [EOL]             zval[i][j] = f.value(xval[i], yval[j]); [EOL]         } [EOL]     } [EOL]     double[][] dZdX = new double[xval.length][yval.length]; [EOL]     for (int i = 0; i < xval.length; i++) { [EOL]         for (int j = 0; j < yval.length; j++) { [EOL]             dZdX[i][j] = 2; [EOL]         } [EOL]     } [EOL]     double[][] dZdY = new double[xval.length][yval.length]; [EOL]     for (int i = 0; i < xval.length; i++) { [EOL]         for (int j = 0; j < yval.length; j++) { [EOL]             dZdY[i][j] = -3; [EOL]         } [EOL]     } [EOL]     double[][] dZdXdY = new double[xval.length][yval.length]; [EOL]     for (int i = 0; i < xval.length; i++) { [EOL]         for (int j = 0; j < yval.length; j++) { [EOL]             dZdXdY[i][j] = 0; [EOL]         } [EOL]     } [EOL]     BivariateFunction bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, dZdX, dZdY, dZdXdY); [EOL]     double x, y; [EOL]     double expected, result; [EOL]     x = 4; [EOL]     y = -3; [EOL]     expected = f.value(x, y); [EOL]     result = bcf.value(x, y); [EOL]     Assert.assertEquals("On sample point", expected, result, 1e-15); [EOL]     x = 4.5; [EOL]     y = -1.5; [EOL]     expected = f.value(x, y); [EOL]     result = bcf.value(x, y); [EOL]     Assert.assertEquals("Half-way between sample points (middle of the patch)", expected, result, 0.3); [EOL]     x = 3.5; [EOL]     y = -3.5; [EOL]     expected = f.value(x, y); [EOL]     result = bcf.value(x, y); [EOL]     Assert.assertEquals("Half-way between sample points (border of the patch)", expected, result, 0.3); [EOL] } <line_num>: 121,184
public double value(double x, double y) { [EOL]     return 2 * x * x - 3 * y * y + 4 * x * y - 5; [EOL] } <line_num>: 197,199
public double value(double x, double y) { [EOL]     return 4 * (x + y); [EOL] } <line_num>: 210,212
public double value(double x, double y) { [EOL]     return 4 * x - 6 * y; [EOL] } <line_num>: 222,224
@Ignore [EOL] @Test [EOL] public void testParaboloid() { [EOL]     double[] xval = new double[] { 3, 4, 5, 6.5 }; [EOL]     double[] yval = new double[] { -4, -3, -1, 2, 2.5 }; [EOL]     BivariateFunction f = new BivariateFunction() { [EOL]  [EOL]         public double value(double x, double y) { [EOL]             return 2 * x * x - 3 * y * y + 4 * x * y - 5; [EOL]         } [EOL]     }; [EOL]     double[][] zval = new double[xval.length][yval.length]; [EOL]     for (int i = 0; i < xval.length; i++) { [EOL]         for (int j = 0; j < yval.length; j++) { [EOL]             zval[i][j] = f.value(xval[i], yval[j]); [EOL]         } [EOL]     } [EOL]     double[][] dZdX = new double[xval.length][yval.length]; [EOL]     BivariateFunction dfdX = new BivariateFunction() { [EOL]  [EOL]         public double value(double x, double y) { [EOL]             return 4 * (x + y); [EOL]         } [EOL]     }; [EOL]     for (int i = 0; i < xval.length; i++) { [EOL]         for (int j = 0; j < yval.length; j++) { [EOL]             dZdX[i][j] = dfdX.value(xval[i], yval[j]); [EOL]         } [EOL]     } [EOL]     double[][] dZdY = new double[xval.length][yval.length]; [EOL]     BivariateFunction dfdY = new BivariateFunction() { [EOL]  [EOL]         public double value(double x, double y) { [EOL]             return 4 * x - 6 * y; [EOL]         } [EOL]     }; [EOL]     for (int i = 0; i < xval.length; i++) { [EOL]         for (int j = 0; j < yval.length; j++) { [EOL]             dZdY[i][j] = dfdY.value(xval[i], yval[j]); [EOL]         } [EOL]     } [EOL]     double[][] dZdXdY = new double[xval.length][yval.length]; [EOL]     for (int i = 0; i < xval.length; i++) { [EOL]         for (int j = 0; j < yval.length; j++) { [EOL]             dZdXdY[i][j] = 4; [EOL]         } [EOL]     } [EOL]     BivariateFunction bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, dZdX, dZdY, dZdXdY); [EOL]     double x, y; [EOL]     double expected, result; [EOL]     x = 4; [EOL]     y = -3; [EOL]     expected = f.value(x, y); [EOL]     result = bcf.value(x, y); [EOL]     Assert.assertEquals("On sample point", expected, result, 1e-15); [EOL]     x = 4.5; [EOL]     y = -1.5; [EOL]     expected = f.value(x, y); [EOL]     result = bcf.value(x, y); [EOL]     Assert.assertEquals("Half-way between sample points (middle of the patch)", expected, result, 2); [EOL]     x = 3.5; [EOL]     y = -3.5; [EOL]     expected = f.value(x, y); [EOL]     result = bcf.value(x, y); [EOL]     Assert.assertEquals("Half-way between sample points (border of the patch)", expected, result, 2); [EOL] } <line_num>: 191,264
public double value(double x, double y) { [EOL]     final double x2 = x * x; [EOL]     final double y2 = y * y; [EOL]     final double y3 = y2 * y; [EOL]     final double yFactor = 2 + 3 * y + 4 * y2 + 5 * y3; [EOL]     return yFactor * (2 + 6 * x + 12 * x2); [EOL] } <line_num>: 289,295
public double value(double x, double y) { [EOL]     final double x2 = x * x; [EOL]     final double x3 = x2 * x; [EOL]     final double y2 = y * y; [EOL]     final double xFactor = 1 + 2 * x + 3 * x2 + 4 * x3; [EOL]     return xFactor * (3 + 8 * y + 15 * y2); [EOL] } <line_num>: 301,307
public double value(double x, double y) { [EOL]     final double y2 = y * y; [EOL]     final double y3 = y2 * y; [EOL]     final double yFactor = 2 + 3 * y + 4 * y2 + 5 * y3; [EOL]     return yFactor * (6 + 24 * x); [EOL] } <line_num>: 313,318
public double value(double x, double y) { [EOL]     final double x2 = x * x; [EOL]     final double x3 = x2 * x; [EOL]     final double xFactor = 1 + 2 * x + 3 * x2 + 4 * x3; [EOL]     return xFactor * (8 + 30 * y); [EOL] } <line_num>: 324,329
public double value(double x, double y) { [EOL]     final double x2 = x * x; [EOL]     final double y2 = y * y; [EOL]     final double yFactor = 3 + 8 * y + 15 * y2; [EOL]     return yFactor * (2 + 6 * x + 12 * x2); [EOL] } <line_num>: 335,340
@Ignore [EOL] @Test [EOL] public void testSplinePartialDerivatives() { [EOL]     final int N = 4; [EOL]     final double[] coeff = new double[16]; [EOL]     for (int i = 0; i < N; i++) { [EOL]         for (int j = 0; j < N; j++) { [EOL]             coeff[i + N * j] = (i + 1) * (j + 2); [EOL]         } [EOL]     } [EOL]     final BicubicSplineFunction f = new BicubicSplineFunction(coeff); [EOL]     BivariateFunction derivative; [EOL]     final double x = 0.435; [EOL]     final double y = 0.776; [EOL]     final double tol = 1e-13; [EOL]     derivative = new BivariateFunction() { [EOL]  [EOL]         public double value(double x, double y) { [EOL]             final double x2 = x * x; [EOL]             final double y2 = y * y; [EOL]             final double y3 = y2 * y; [EOL]             final double yFactor = 2 + 3 * y + 4 * y2 + 5 * y3; [EOL]             return yFactor * (2 + 6 * x + 12 * x2); [EOL]         } [EOL]     }; [EOL]     Assert.assertEquals("dFdX", derivative.value(x, y), f.partialDerivativeX().value(x, y), tol); [EOL]     derivative = new BivariateFunction() { [EOL]  [EOL]         public double value(double x, double y) { [EOL]             final double x2 = x * x; [EOL]             final double x3 = x2 * x; [EOL]             final double y2 = y * y; [EOL]             final double xFactor = 1 + 2 * x + 3 * x2 + 4 * x3; [EOL]             return xFactor * (3 + 8 * y + 15 * y2); [EOL]         } [EOL]     }; [EOL]     Assert.assertEquals("dFdY", derivative.value(x, y), f.partialDerivativeY().value(x, y), tol); [EOL]     derivative = new BivariateFunction() { [EOL]  [EOL]         public double value(double x, double y) { [EOL]             final double y2 = y * y; [EOL]             final double y3 = y2 * y; [EOL]             final double yFactor = 2 + 3 * y + 4 * y2 + 5 * y3; [EOL]             return yFactor * (6 + 24 * x); [EOL]         } [EOL]     }; [EOL]     Assert.assertEquals("d2FdX2", derivative.value(x, y), f.partialDerivativeXX().value(x, y), tol); [EOL]     derivative = new BivariateFunction() { [EOL]  [EOL]         public double value(double x, double y) { [EOL]             final double x2 = x * x; [EOL]             final double x3 = x2 * x; [EOL]             final double xFactor = 1 + 2 * x + 3 * x2 + 4 * x3; [EOL]             return xFactor * (8 + 30 * y); [EOL]         } [EOL]     }; [EOL]     Assert.assertEquals("d2FdY2", derivative.value(x, y), f.partialDerivativeYY().value(x, y), tol); [EOL]     derivative = new BivariateFunction() { [EOL]  [EOL]         public double value(double x, double y) { [EOL]             final double x2 = x * x; [EOL]             final double y2 = y * y; [EOL]             final double yFactor = 3 + 8 * y + 15 * y2; [EOL]             return yFactor * (2 + 6 * x + 12 * x2); [EOL]         } [EOL]     }; [EOL]     Assert.assertEquals("d2FdXdY", derivative.value(x, y), f.partialDerivativeXY().value(x, y), tol); [EOL] } <line_num>: 271,344
public double value(double x, double y) { [EOL]     final double x2 = x * x; [EOL]     final double x3 = x2 * x; [EOL]     final double y2 = y * y; [EOL]     final double y3 = y2 * y; [EOL]     return 5 - 3 * x + 2 * y - x * y + 2 * x2 - 3 * y2 + 4 * x2 * y - x * y2 - 3 * x3 + y3; [EOL] } <line_num>: 366,376
public double value(double x, double y) { [EOL]     final double x2 = x * x; [EOL]     final double y2 = y * y; [EOL]     return -3 - y + 4 * x + 8 * x * y - y2 - 9 * x2; [EOL] } <line_num>: 387,391
public double value(double x, double y) { [EOL]     final double x2 = x * x; [EOL]     final double y2 = y * y; [EOL]     return 2 - x - 6 * y + 4 * x2 - 2 * x * y + 3 * y2; [EOL] } <line_num>: 401,405
public double value(double x, double y) { [EOL]     return -1 + 8 * x - 2 * y; [EOL] } <line_num>: 415,417
@Ignore [EOL] @Test [EOL] public void testMatchingPartialDerivatives() { [EOL]     final int sz = 21; [EOL]     double[] val = new double[sz]; [EOL]     final double delta = 1d / (sz - 1); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         val[i] = i * delta; [EOL]     } [EOL]     BivariateFunction f = new BivariateFunction() { [EOL]  [EOL]         public double value(double x, double y) { [EOL]             final double x2 = x * x; [EOL]             final double x3 = x2 * x; [EOL]             final double y2 = y * y; [EOL]             final double y3 = y2 * y; [EOL]             return 5 - 3 * x + 2 * y - x * y + 2 * x2 - 3 * y2 + 4 * x2 * y - x * y2 - 3 * x3 + y3; [EOL]         } [EOL]     }; [EOL]     double[][] fval = new double[sz][sz]; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         for (int j = 0; j < sz; j++) { [EOL]             fval[i][j] = f.value(val[i], val[j]); [EOL]         } [EOL]     } [EOL]     double[][] dFdX = new double[sz][sz]; [EOL]     BivariateFunction dfdX = new BivariateFunction() { [EOL]  [EOL]         public double value(double x, double y) { [EOL]             final double x2 = x * x; [EOL]             final double y2 = y * y; [EOL]             return -3 - y + 4 * x + 8 * x * y - y2 - 9 * x2; [EOL]         } [EOL]     }; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         for (int j = 0; j < sz; j++) { [EOL]             dFdX[i][j] = dfdX.value(val[i], val[j]); [EOL]         } [EOL]     } [EOL]     double[][] dFdY = new double[sz][sz]; [EOL]     BivariateFunction dfdY = new BivariateFunction() { [EOL]  [EOL]         public double value(double x, double y) { [EOL]             final double x2 = x * x; [EOL]             final double y2 = y * y; [EOL]             return 2 - x - 6 * y + 4 * x2 - 2 * x * y + 3 * y2; [EOL]         } [EOL]     }; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         for (int j = 0; j < sz; j++) { [EOL]             dFdY[i][j] = dfdY.value(val[i], val[j]); [EOL]         } [EOL]     } [EOL]     double[][] d2FdXdY = new double[sz][sz]; [EOL]     BivariateFunction d2fdXdY = new BivariateFunction() { [EOL]  [EOL]         public double value(double x, double y) { [EOL]             return -1 + 8 * x - 2 * y; [EOL]         } [EOL]     }; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         for (int j = 0; j < sz; j++) { [EOL]             d2FdXdY[i][j] = d2fdXdY.value(val[i], val[j]); [EOL]         } [EOL]     } [EOL]     BicubicSplineInterpolatingFunction bcf = new BicubicSplineInterpolatingFunction(val, val, fval, dFdX, dFdY, d2FdXdY); [EOL]     double x, y; [EOL]     double expected, result; [EOL]     final double tol = 1e-12; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         x = val[i]; [EOL]         for (int j = 0; j < sz; j++) { [EOL]             y = val[j]; [EOL]             expected = dfdX.value(x, y); [EOL]             result = bcf.partialDerivativeX(x, y); [EOL]             Assert.assertEquals(x + " " + y + " dFdX", expected, result, tol); [EOL]             expected = dfdY.value(x, y); [EOL]             result = bcf.partialDerivativeY(x, y); [EOL]             Assert.assertEquals(x + " " + y + " dFdY", expected, result, tol); [EOL]             expected = d2fdXdY.value(x, y); [EOL]             result = bcf.partialDerivativeXY(x, y); [EOL]             Assert.assertEquals(x + " " + y + " d2FdXdY", expected, result, tol); [EOL]         } [EOL]     } [EOL] } <line_num>: 355,450
public double value(double x, double y) { [EOL]     return 2 * x - 3 * y + 5; [EOL] } <line_num>: 471,473
@Test [EOL] public void testInterpolation1() { [EOL]     final int sz = 21; [EOL]     double[] xval = new double[sz]; [EOL]     double[] yval = new double[sz]; [EOL]     final double delta = 1d / (sz - 1); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         xval[i] = -1 + 15 * i * delta; [EOL]         yval[i] = -20 + 30 * i * delta; [EOL]     } [EOL]     BivariateFunction f = new BivariateFunction() { [EOL]  [EOL]         public double value(double x, double y) { [EOL]             return 2 * x - 3 * y + 5; [EOL]         } [EOL]     }; [EOL]     double[][] zval = new double[xval.length][yval.length]; [EOL]     for (int i = 0; i < xval.length; i++) { [EOL]         for (int j = 0; j < yval.length; j++) { [EOL]             zval[i][j] = f.value(xval[i], yval[j]); [EOL]         } [EOL]     } [EOL]     double[][] dZdX = new double[xval.length][yval.length]; [EOL]     for (int i = 0; i < xval.length; i++) { [EOL]         for (int j = 0; j < yval.length; j++) { [EOL]             dZdX[i][j] = 2; [EOL]         } [EOL]     } [EOL]     double[][] dZdY = new double[xval.length][yval.length]; [EOL]     for (int i = 0; i < xval.length; i++) { [EOL]         for (int j = 0; j < yval.length; j++) { [EOL]             dZdY[i][j] = -3; [EOL]         } [EOL]     } [EOL]     double[][] dZdXdY = new double[xval.length][yval.length]; [EOL]     for (int i = 0; i < xval.length; i++) { [EOL]         for (int j = 0; j < yval.length; j++) { [EOL]             dZdXdY[i][j] = 0; [EOL]         } [EOL]     } [EOL]     final BivariateFunction bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, dZdX, dZdY, dZdXdY); [EOL]     double x, y; [EOL]     final RandomGenerator rng = new Well19937c(1234567L); [EOL]     final UniformRealDistribution distX = new UniformRealDistribution(rng, xval[0], xval[xval.length - 1]); [EOL]     final UniformRealDistribution distY = new UniformRealDistribution(rng, yval[0], yval[yval.length - 1]); [EOL]     final int numSamples = 50; [EOL]     final double tol = 6; [EOL]     for (int i = 0; i < numSamples; i++) { [EOL]         x = distX.sample(); [EOL]         for (int j = 0; j < numSamples; j++) { [EOL]             y = distY.sample(); [EOL]             Assert.assertEquals(f.value(x, y), bcf.value(x, y), tol); [EOL]         } [EOL]     } [EOL] } <line_num>: 457,525
public double value(double x, double y) { [EOL]     return 2 * x * x - 3 * y * y + 4 * x * y - 5; [EOL] } <line_num>: 546,548
public double value(double x, double y) { [EOL]     return 4 * (x + y); [EOL] } <line_num>: 559,561
public double value(double x, double y) { [EOL]     return 4 * x - 6 * y; [EOL] } <line_num>: 571,573
@Test [EOL] public void testInterpolation2() { [EOL]     final int sz = 21; [EOL]     double[] xval = new double[sz]; [EOL]     double[] yval = new double[sz]; [EOL]     final double delta = 1d / (sz - 1); [EOL]     for (int i = 0; i < sz; i++) { [EOL]         xval[i] = -1 + 15 * i * delta; [EOL]         yval[i] = -20 + 30 * i * delta; [EOL]     } [EOL]     BivariateFunction f = new BivariateFunction() { [EOL]  [EOL]         public double value(double x, double y) { [EOL]             return 2 * x * x - 3 * y * y + 4 * x * y - 5; [EOL]         } [EOL]     }; [EOL]     double[][] zval = new double[xval.length][yval.length]; [EOL]     for (int i = 0; i < xval.length; i++) { [EOL]         for (int j = 0; j < yval.length; j++) { [EOL]             zval[i][j] = f.value(xval[i], yval[j]); [EOL]         } [EOL]     } [EOL]     double[][] dZdX = new double[xval.length][yval.length]; [EOL]     BivariateFunction dfdX = new BivariateFunction() { [EOL]  [EOL]         public double value(double x, double y) { [EOL]             return 4 * (x + y); [EOL]         } [EOL]     }; [EOL]     for (int i = 0; i < xval.length; i++) { [EOL]         for (int j = 0; j < yval.length; j++) { [EOL]             dZdX[i][j] = dfdX.value(xval[i], yval[j]); [EOL]         } [EOL]     } [EOL]     double[][] dZdY = new double[xval.length][yval.length]; [EOL]     BivariateFunction dfdY = new BivariateFunction() { [EOL]  [EOL]         public double value(double x, double y) { [EOL]             return 4 * x - 6 * y; [EOL]         } [EOL]     }; [EOL]     for (int i = 0; i < xval.length; i++) { [EOL]         for (int j = 0; j < yval.length; j++) { [EOL]             dZdY[i][j] = dfdY.value(xval[i], yval[j]); [EOL]         } [EOL]     } [EOL]     double[][] dZdXdY = new double[xval.length][yval.length]; [EOL]     for (int i = 0; i < xval.length; i++) { [EOL]         for (int j = 0; j < yval.length; j++) { [EOL]             dZdXdY[i][j] = 4; [EOL]         } [EOL]     } [EOL]     BivariateFunction bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, dZdX, dZdY, dZdXdY); [EOL]     double x, y; [EOL]     final RandomGenerator rng = new Well19937c(1234567L); [EOL]     final UniformRealDistribution distX = new UniformRealDistribution(rng, xval[0], xval[xval.length - 1]); [EOL]     final UniformRealDistribution distY = new UniformRealDistribution(rng, yval[0], yval[yval.length - 1]); [EOL]     final double tol = 224; [EOL]     double max = 0; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         x = distX.sample(); [EOL]         for (int j = 0; j < sz; j++) { [EOL]             y = distY.sample(); [EOL]             Assert.assertEquals(f.value(x, y), bcf.value(x, y), tol); [EOL]         } [EOL]     } [EOL] } <line_num>: 532,609
@Test [EOL] public void testIsValidPoint() { [EOL]     final double xMin = -12; [EOL]     final double xMax = 34; [EOL]     final double yMin = 5; [EOL]     final double yMax = 67; [EOL]     final double[] xval = new double[] { xMin, xMax }; [EOL]     final double[] yval = new double[] { yMin, yMax }; [EOL]     final double[][] f = new double[][] { { 1, 2 }, { 3, 4 } }; [EOL]     final double[][] dFdX = f; [EOL]     final double[][] dFdY = f; [EOL]     final double[][] dFdXdY = f; [EOL]     final BicubicSplineInterpolatingFunction bcf = new BicubicSplineInterpolatingFunction(xval, yval, f, dFdX, dFdY, dFdXdY); [EOL]     double x, y; [EOL]     x = xMin; [EOL]     y = yMin; [EOL]     Assert.assertTrue(bcf.isValidPoint(x, y)); [EOL]     bcf.value(x, y); [EOL]     x = xMax; [EOL]     y = yMax; [EOL]     Assert.assertTrue(bcf.isValidPoint(x, y)); [EOL]     bcf.value(x, y); [EOL]     final double xRange = xMax - xMin; [EOL]     final double yRange = yMax - yMin; [EOL]     x = xMin + xRange / 3.4; [EOL]     y = yMin + yRange / 1.2; [EOL]     Assert.assertTrue(bcf.isValidPoint(x, y)); [EOL]     bcf.value(x, y); [EOL]     final double small = 1e-8; [EOL]     x = xMin - small; [EOL]     y = yMax; [EOL]     Assert.assertFalse(bcf.isValidPoint(x, y)); [EOL]     try { [EOL]         bcf.value(x, y); [EOL]         Assert.fail("OutOfRangeException expected"); [EOL]     } catch (OutOfRangeException expected) { [EOL]     } [EOL]     x = xMin; [EOL]     y = yMax + small; [EOL]     Assert.assertFalse(bcf.isValidPoint(x, y)); [EOL]     try { [EOL]         bcf.value(x, y); [EOL]         Assert.fail("OutOfRangeException expected"); [EOL]     } catch (OutOfRangeException expected) { [EOL]     } [EOL] } <line_num>: 611,669
