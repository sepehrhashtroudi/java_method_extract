@Test [EOL] public void testSinFunction() { [EOL]     UnivariateFunction f = new Sin(); [EOL]     BaseAbstractUnivariateIntegrator integrator = new IterativeLegendreGaussIntegrator(5, 1.0e-14, 1.0e-10, 2, 15); [EOL]     double min, max, expected, result, tolerance; [EOL]     min = 0; [EOL]     max = FastMath.PI; [EOL]     expected = 2; [EOL]     tolerance = FastMath.max(integrator.getAbsoluteAccuracy(), FastMath.abs(expected * integrator.getRelativeAccuracy())); [EOL]     result = integrator.integrate(10000, f, min, max); [EOL]     Assert.assertEquals(expected, result, tolerance); [EOL]     min = -FastMath.PI / 3; [EOL]     max = 0; [EOL]     expected = -0.5; [EOL]     tolerance = FastMath.max(integrator.getAbsoluteAccuracy(), FastMath.abs(expected * integrator.getRelativeAccuracy())); [EOL]     result = integrator.integrate(10000, f, min, max); [EOL]     Assert.assertEquals(expected, result, tolerance); [EOL] } <line_num>: 34,52
@Test [EOL] public void testQuinticFunction() { [EOL]     UnivariateFunction f = new QuinticFunction(); [EOL]     UnivariateIntegrator integrator = new IterativeLegendreGaussIntegrator(3, BaseAbstractUnivariateIntegrator.DEFAULT_RELATIVE_ACCURACY, BaseAbstractUnivariateIntegrator.DEFAULT_ABSOLUTE_ACCURACY, BaseAbstractUnivariateIntegrator.DEFAULT_MIN_ITERATIONS_COUNT, 64); [EOL]     double min, max, expected, result; [EOL]     min = 0; [EOL]     max = 1; [EOL]     expected = -1.0 / 48; [EOL]     result = integrator.integrate(10000, f, min, max); [EOL]     Assert.assertEquals(expected, result, 1.0e-16); [EOL]     min = 0; [EOL]     max = 0.5; [EOL]     expected = 11.0 / 768; [EOL]     result = integrator.integrate(10000, f, min, max); [EOL]     Assert.assertEquals(expected, result, 1.0e-16); [EOL]     min = -1; [EOL]     max = 4; [EOL]     expected = 2048 / 3.0 - 78 + 1.0 / 48; [EOL]     result = integrator.integrate(10000, f, min, max); [EOL]     Assert.assertEquals(expected, result, 1.0e-16); [EOL] } <line_num>: 54,76
@Test [EOL] public void testExactIntegration() { [EOL]     Random random = new Random(86343623467878363l); [EOL]     for (int n = 2; n < 6; ++n) { [EOL]         IterativeLegendreGaussIntegrator integrator = new IterativeLegendreGaussIntegrator(n, BaseAbstractUnivariateIntegrator.DEFAULT_RELATIVE_ACCURACY, BaseAbstractUnivariateIntegrator.DEFAULT_ABSOLUTE_ACCURACY, BaseAbstractUnivariateIntegrator.DEFAULT_MIN_ITERATIONS_COUNT, 64); [EOL]         for (int degree = 0; degree <= 2 * n - 1; ++degree) { [EOL]             for (int i = 0; i < 10; ++i) { [EOL]                 double[] coeff = new double[degree + 1]; [EOL]                 for (int k = 0; k < coeff.length; ++k) { [EOL]                     coeff[k] = 2 * random.nextDouble() - 1; [EOL]                 } [EOL]                 PolynomialFunction p = new PolynomialFunction(coeff); [EOL]                 double result = integrator.integrate(10000, p, -5.0, 15.0); [EOL]                 double reference = exactIntegration(p, -5.0, 15.0); [EOL]                 Assert.assertEquals(n + " " + degree + " " + i, reference, result, 1.0e-12 * (1.0 + FastMath.abs(reference))); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 78,104
@Test [EOL] public void testNormalDistributionWithLargeSigma() { [EOL]     final double sigma = 1000; [EOL]     final double mean = 0; [EOL]     final double factor = 1 / (sigma * FastMath.sqrt(2 * FastMath.PI)); [EOL]     final UnivariateFunction normal = new Gaussian(factor, mean, sigma); [EOL]     final double tol = 1e-2; [EOL]     final IterativeLegendreGaussIntegrator integrator = new IterativeLegendreGaussIntegrator(5, tol, tol); [EOL]     final double a = -5000; [EOL]     final double b = 5000; [EOL]     final double s = integrator.integrate(50, normal, a, b); [EOL]     Assert.assertEquals(1, s, 1e-5); [EOL] } <line_num>: 107,122
public double value(double x) { [EOL]     return (x >= 0 && x <= 5) ? value : 0.0; [EOL] } <line_num>: 128,130
@Test [EOL] public void testIssue464() { [EOL]     final double value = 0.2; [EOL]     UnivariateFunction f = new UnivariateFunction() { [EOL]  [EOL]         public double value(double x) { [EOL]             return (x >= 0 && x <= 5) ? value : 0.0; [EOL]         } [EOL]     }; [EOL]     IterativeLegendreGaussIntegrator gauss = new IterativeLegendreGaussIntegrator(5, 3, 100); [EOL]     double maxX = 0.32462367623786328; [EOL]     Assert.assertEquals(maxX * value, gauss.integrate(Integer.MAX_VALUE, f, -10, maxX), 1.0e-7); [EOL]     Assert.assertTrue(gauss.getEvaluations() > 37000000); [EOL]     Assert.assertTrue(gauss.getIterations() < 30); [EOL]     try { [EOL]         gauss.integrate(1000, f, -10, maxX); [EOL]         Assert.fail("expected TooManyEvaluationsException"); [EOL]     } catch (TooManyEvaluationsException tmee) { [EOL]         Assert.assertEquals(1000, tmee.getMax()); [EOL]     } [EOL]     double sum1 = gauss.integrate(1000, f, -10, 0); [EOL]     int eval1 = gauss.getEvaluations(); [EOL]     double sum2 = gauss.integrate(1000, f, 0, maxX); [EOL]     int eval2 = gauss.getEvaluations(); [EOL]     Assert.assertEquals(maxX * value, sum1 + sum2, 1.0e-7); [EOL]     Assert.assertTrue(eval1 + eval2 < 200); [EOL] } <line_num>: 124,158
private double exactIntegration(PolynomialFunction p, double a, double b) { [EOL]     final double[] coeffs = p.getCoefficients(); [EOL]     double yb = coeffs[coeffs.length - 1] / coeffs.length; [EOL]     double ya = yb; [EOL]     for (int i = coeffs.length - 2; i >= 0; --i) { [EOL]         yb = yb * b + coeffs[i] / (i + 1); [EOL]         ya = ya * a + coeffs[i] / (i + 1); [EOL]     } [EOL]     return yb * b - ya * a; [EOL] } <line_num>: 160,169
