@Test [EOL] public void testHash() { [EOL]     double[] testArray = { Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 1d, 0d, 1E-14, (1 + 1E-14), Double.MIN_VALUE, Double.MAX_VALUE }; [EOL]     for (int i = 0; i < testArray.length; i++) { [EOL]         for (int j = 0; j < testArray.length; j++) { [EOL]             if (i == j) { [EOL]                 Assert.assertEquals(MathUtils.hash(testArray[i]), MathUtils.hash(testArray[j])); [EOL]                 Assert.assertEquals(MathUtils.hash(testArray[j]), MathUtils.hash(testArray[i])); [EOL]             } else { [EOL]                 Assert.assertTrue(MathUtils.hash(testArray[i]) != MathUtils.hash(testArray[j])); [EOL]                 Assert.assertTrue(MathUtils.hash(testArray[j]) != MathUtils.hash(testArray[i])); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 32,55
@Test [EOL] public void testArrayHash() { [EOL]     Assert.assertEquals(0, MathUtils.hash((double[]) null)); [EOL]     Assert.assertEquals(MathUtils.hash(new double[] { Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 1d, 0d }), MathUtils.hash(new double[] { Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 1d, 0d })); [EOL]     Assert.assertFalse(MathUtils.hash(new double[] { 1d }) == MathUtils.hash(new double[] { FastMath.nextAfter(1d, 2d) })); [EOL]     Assert.assertFalse(MathUtils.hash(new double[] { 1d }) == MathUtils.hash(new double[] { 1d, 1d })); [EOL] } <line_num>: 57,72
@Test [EOL] public void testPermutedArrayHash() { [EOL]     double[] original = new double[10]; [EOL]     double[] permuted = new double[10]; [EOL]     RandomDataImpl random = new RandomDataImpl(); [EOL]     for (int i = 0; i < 10; i++) { [EOL]         final RealDistribution u = new UniformRealDistribution(i + 0.5, i + 0.75); [EOL]         original[i] = u.sample(); [EOL]     } [EOL]     boolean isIdentity = true; [EOL]     do { [EOL]         int[] permutation = random.nextPermutation(10, 10); [EOL]         for (int i = 0; i < 10; i++) { [EOL]             if (i != permutation[i]) { [EOL]                 isIdentity = false; [EOL]             } [EOL]             permuted[i] = original[permutation[i]]; [EOL]         } [EOL]     } while (isIdentity); [EOL]     Assert.assertFalse(MathUtils.hash(original) == MathUtils.hash(permuted)); [EOL] } <line_num>: 77,103
@Test [EOL] public void testIndicatorByte() { [EOL]     Assert.assertEquals((byte) 1, MathUtils.copySign((byte) 1, (byte) 2)); [EOL]     Assert.assertEquals((byte) 1, MathUtils.copySign((byte) 1, (byte) 0)); [EOL]     Assert.assertEquals((byte) (-1), MathUtils.copySign((byte) 1, (byte) (-2))); [EOL] } <line_num>: 105,110
@Test [EOL] public void testIndicatorInt() { [EOL]     Assert.assertEquals(1, MathUtils.copySign(1, 2)); [EOL]     Assert.assertEquals(1, MathUtils.copySign(1, 0)); [EOL]     Assert.assertEquals((-1), MathUtils.copySign(1, -2)); [EOL] } <line_num>: 112,117
@Test [EOL] public void testIndicatorLong() { [EOL]     Assert.assertEquals(1L, MathUtils.copySign(1L, 2L)); [EOL]     Assert.assertEquals(1L, MathUtils.copySign(1L, 0L)); [EOL]     Assert.assertEquals(-1L, MathUtils.copySign(1L, -2L)); [EOL] } <line_num>: 119,124
@Test [EOL] public void testIndicatorShort() { [EOL]     Assert.assertEquals((short) 1, MathUtils.copySign((short) 1, (short) 2)); [EOL]     Assert.assertEquals((short) 1, MathUtils.copySign((short) 1, (short) 0)); [EOL]     Assert.assertEquals((short) (-1), MathUtils.copySign((short) 1, (short) (-2))); [EOL] } <line_num>: 126,131
@Test [EOL] public void testNormalizeAngle() { [EOL]     for (double a = -15.0; a <= 15.0; a += 0.1) { [EOL]         for (double b = -15.0; b <= 15.0; b += 0.2) { [EOL]             double c = MathUtils.normalizeAngle(a, b); [EOL]             Assert.assertTrue((b - FastMath.PI) <= c); [EOL]             Assert.assertTrue(c <= (b + FastMath.PI)); [EOL]             double twoK = FastMath.rint((a - c) / FastMath.PI); [EOL]             Assert.assertEquals(c, a - twoK * FastMath.PI, 1.0e-14); [EOL]         } [EOL]     } [EOL] } <line_num>: 133,144
@Test [EOL] public void testReduce() { [EOL]     final double period = -12.222; [EOL]     final double offset = 13; [EOL]     final double delta = 1.5; [EOL]     double orig = offset + 122456789 * period + delta; [EOL]     double expected = delta; [EOL]     Assert.assertEquals(expected, MathUtils.reduce(orig, period, offset), 1e-7); [EOL]     Assert.assertEquals(expected, MathUtils.reduce(orig, -period, offset), 1e-7); [EOL]     orig = offset - 123356789 * period - delta; [EOL]     expected = Math.abs(period) - delta; [EOL]     Assert.assertEquals(expected, MathUtils.reduce(orig, period, offset), 1e-6); [EOL]     Assert.assertEquals(expected, MathUtils.reduce(orig, -period, offset), 1e-6); [EOL]     orig = offset - 123446789 * period + delta; [EOL]     expected = delta; [EOL]     Assert.assertEquals(expected, MathUtils.reduce(orig, period, offset), 1e-6); [EOL]     Assert.assertEquals(expected, MathUtils.reduce(orig, -period, offset), 1e-6); [EOL]     Assert.assertTrue(Double.isNaN(MathUtils.reduce(orig, Double.NaN, offset))); [EOL]     Assert.assertTrue(Double.isNaN(MathUtils.reduce(Double.NaN, period, offset))); [EOL]     Assert.assertTrue(Double.isNaN(MathUtils.reduce(orig, period, Double.NaN))); [EOL]     Assert.assertTrue(Double.isNaN(MathUtils.reduce(orig, period, Double.POSITIVE_INFINITY))); [EOL]     Assert.assertTrue(Double.isNaN(MathUtils.reduce(Double.POSITIVE_INFINITY, period, offset))); [EOL]     Assert.assertTrue(Double.isNaN(MathUtils.reduce(orig, Double.POSITIVE_INFINITY, offset))); [EOL]     Assert.assertTrue(Double.isNaN(MathUtils.reduce(orig, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY))); [EOL]     Assert.assertTrue(Double.isNaN(MathUtils.reduce(Double.POSITIVE_INFINITY, period, Double.POSITIVE_INFINITY))); [EOL]     Assert.assertTrue(Double.isNaN(MathUtils.reduce(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, offset))); [EOL]     Assert.assertTrue(Double.isNaN(MathUtils.reduce(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY))); [EOL] } <line_num>: 146,197
@Test [EOL] public void testReduceComparedWithNormalizeAngle() { [EOL]     final double tol = Math.ulp(1d); [EOL]     final double period = 2 * Math.PI; [EOL]     for (double a = -15; a <= 15; a += 0.5) { [EOL]         for (double center = -15; center <= 15; center += 1) { [EOL]             final double nA = MathUtils.normalizeAngle(a, center); [EOL]             final double offset = center - Math.PI; [EOL]             final double r = MathUtils.reduce(a, period, offset); [EOL]             Assert.assertEquals(nA, r + offset, tol); [EOL]         } [EOL]     } [EOL] } <line_num>: 199,211
@Test [EOL] public void testSignByte() { [EOL]     final byte one = (byte) 1; [EOL]     Assert.assertEquals((byte) 1, MathUtils.copySign(one, (byte) 2)); [EOL]     Assert.assertEquals((byte) (-1), MathUtils.copySign(one, (byte) (-2))); [EOL] } <line_num>: 213,218
@Test [EOL] public void testSignInt() { [EOL]     final int one = 1; [EOL]     Assert.assertEquals(1, MathUtils.copySign(one, 2)); [EOL]     Assert.assertEquals((-1), MathUtils.copySign(one, -2)); [EOL] } <line_num>: 220,225
@Test [EOL] public void testSignLong() { [EOL]     final long one = 1L; [EOL]     Assert.assertEquals(1L, MathUtils.copySign(one, 2L)); [EOL]     Assert.assertEquals(-1L, MathUtils.copySign(one, -2L)); [EOL] } <line_num>: 227,232
@Test [EOL] public void testSignShort() { [EOL]     final short one = (short) 1; [EOL]     Assert.assertEquals((short) 1, MathUtils.copySign(one, (short) 2)); [EOL]     Assert.assertEquals((short) (-1), MathUtils.copySign(one, (short) (-2))); [EOL] } <line_num>: 234,239
@Test [EOL] public void testCheckFinite() { [EOL]     try { [EOL]         MathUtils.checkFinite(Double.POSITIVE_INFINITY); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (NotFiniteNumberException e) { [EOL]     } [EOL]     try { [EOL]         MathUtils.checkFinite(Double.NEGATIVE_INFINITY); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (NotFiniteNumberException e) { [EOL]     } [EOL]     try { [EOL]         MathUtils.checkFinite(Double.NaN); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (NotFiniteNumberException e) { [EOL]     } [EOL]     try { [EOL]         MathUtils.checkFinite(new double[] { 0, -1, Double.POSITIVE_INFINITY, -2, 3 }); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (NotFiniteNumberException e) { [EOL]     } [EOL]     try { [EOL]         MathUtils.checkFinite(new double[] { 1, Double.NEGATIVE_INFINITY, -2, 3 }); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (NotFiniteNumberException e) { [EOL]     } [EOL]     try { [EOL]         MathUtils.checkFinite(new double[] { 4, 3, -1, Double.NaN, -2, 1 }); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (NotFiniteNumberException e) { [EOL]     } [EOL] } <line_num>: 241,280
@Test [EOL] public void testCheckNotNull1() { [EOL]     try { [EOL]         Object obj = null; [EOL]         MathUtils.checkNotNull(obj); [EOL]     } catch (NullArgumentException e) { [EOL]     } [EOL] } <line_num>: 282,290
@Test [EOL] public void testCheckNotNull2() { [EOL]     try { [EOL]         double[] array = null; [EOL]         MathUtils.checkNotNull(array, LocalizedFormats.INPUT_ARRAY); [EOL]     } catch (NullArgumentException e) { [EOL]     } [EOL] } <line_num>: 292,300
@Test [EOL] public void testCopySignByte() { [EOL]     byte a = MathUtils.copySign(Byte.MIN_VALUE, (byte) -1); [EOL]     Assert.assertEquals(Byte.MIN_VALUE, a); [EOL]     final byte minValuePlusOne = Byte.MIN_VALUE + (byte) 1; [EOL]     a = MathUtils.copySign(minValuePlusOne, (byte) 1); [EOL]     Assert.assertEquals(Byte.MAX_VALUE, a); [EOL]     a = MathUtils.copySign(Byte.MAX_VALUE, (byte) -1); [EOL]     Assert.assertEquals(minValuePlusOne, a); [EOL]     final byte one = 1; [EOL]     byte val = -2; [EOL]     a = MathUtils.copySign(val, one); [EOL]     Assert.assertEquals(-val, a); [EOL]     final byte minusOne = -one; [EOL]     val = 2; [EOL]     a = MathUtils.copySign(val, minusOne); [EOL]     Assert.assertEquals(-val, a); [EOL]     val = 0; [EOL]     a = MathUtils.copySign(val, minusOne); [EOL]     Assert.assertEquals(val, a); [EOL]     val = 0; [EOL]     a = MathUtils.copySign(val, one); [EOL]     Assert.assertEquals(val, a); [EOL] } <line_num>: 302,331
@Test(expected = MathArithmeticException.class) [EOL] public void testCopySignByte2() { [EOL]     MathUtils.copySign(Byte.MIN_VALUE, (byte) 1); [EOL] } <line_num>: 333,336
