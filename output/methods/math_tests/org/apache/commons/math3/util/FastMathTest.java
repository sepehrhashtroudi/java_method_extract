@Before [EOL] public void setUp() { [EOL]     field = new DfpField(40); [EOL]     generator = new MersenneTwister(6176597458463500194l); [EOL] } <line_num>: 43,47
@Test [EOL] public void testMinMaxDouble() { [EOL]     double[][] pairs = { { -50.0, 50.0 }, { Double.POSITIVE_INFINITY, 1.0 }, { Double.NEGATIVE_INFINITY, 1.0 }, { Double.NaN, 1.0 }, { Double.POSITIVE_INFINITY, 0.0 }, { Double.NEGATIVE_INFINITY, 0.0 }, { Double.NaN, 0.0 }, { Double.NaN, Double.NEGATIVE_INFINITY }, { Double.NaN, Double.POSITIVE_INFINITY }, { Precision.SAFE_MIN, Precision.EPSILON } }; [EOL]     for (double[] pair : pairs) { [EOL]         Assert.assertEquals("min(" + pair[0] + ", " + pair[1] + ")", Math.min(pair[0], pair[1]), FastMath.min(pair[0], pair[1]), Precision.EPSILON); [EOL]         Assert.assertEquals("min(" + pair[1] + ", " + pair[0] + ")", Math.min(pair[1], pair[0]), FastMath.min(pair[1], pair[0]), Precision.EPSILON); [EOL]         Assert.assertEquals("max(" + pair[0] + ", " + pair[1] + ")", Math.max(pair[0], pair[1]), FastMath.max(pair[0], pair[1]), Precision.EPSILON); [EOL]         Assert.assertEquals("max(" + pair[1] + ", " + pair[0] + ")", Math.max(pair[1], pair[0]), FastMath.max(pair[1], pair[0]), Precision.EPSILON); [EOL]     } [EOL] } <line_num>: 49,81
@Test [EOL] public void testMinMaxFloat() { [EOL]     float[][] pairs = { { -50.0f, 50.0f }, { Float.POSITIVE_INFINITY, 1.0f }, { Float.NEGATIVE_INFINITY, 1.0f }, { Float.NaN, 1.0f }, { Float.POSITIVE_INFINITY, 0.0f }, { Float.NEGATIVE_INFINITY, 0.0f }, { Float.NaN, 0.0f }, { Float.NaN, Float.NEGATIVE_INFINITY }, { Float.NaN, Float.POSITIVE_INFINITY } }; [EOL]     for (float[] pair : pairs) { [EOL]         Assert.assertEquals("min(" + pair[0] + ", " + pair[1] + ")", Math.min(pair[0], pair[1]), FastMath.min(pair[0], pair[1]), Precision.EPSILON); [EOL]         Assert.assertEquals("min(" + pair[1] + ", " + pair[0] + ")", Math.min(pair[1], pair[0]), FastMath.min(pair[1], pair[0]), Precision.EPSILON); [EOL]         Assert.assertEquals("max(" + pair[0] + ", " + pair[1] + ")", Math.max(pair[0], pair[1]), FastMath.max(pair[0], pair[1]), Precision.EPSILON); [EOL]         Assert.assertEquals("max(" + pair[1] + ", " + pair[0] + ")", Math.max(pair[1], pair[0]), FastMath.max(pair[1], pair[0]), Precision.EPSILON); [EOL]     } [EOL] } <line_num>: 83,114
@Test [EOL] public void testConstants() { [EOL]     Assert.assertEquals(Math.PI, FastMath.PI, 1.0e-20); [EOL]     Assert.assertEquals(Math.E, FastMath.E, 1.0e-20); [EOL] } <line_num>: 116,120
@Test [EOL] public void testAtan2() { [EOL]     double y1 = 1.2713504628280707e10; [EOL]     double x1 = -5.674940885228782e-10; [EOL]     Assert.assertEquals(Math.atan2(y1, x1), FastMath.atan2(y1, x1), 2 * Precision.EPSILON); [EOL]     double y2 = 0.0; [EOL]     double x2 = Double.POSITIVE_INFINITY; [EOL]     Assert.assertEquals(Math.atan2(y2, x2), FastMath.atan2(y2, x2), Precision.SAFE_MIN); [EOL] } <line_num>: 122,130
@Test [EOL] public void testHyperbolic() { [EOL]     double maxErr = 0; [EOL]     for (double x = -30; x < 30; x += 0.001) { [EOL]         double tst = FastMath.sinh(x); [EOL]         double ref = Math.sinh(x); [EOL]         maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref)); [EOL]     } [EOL]     Assert.assertEquals(0, maxErr, 2); [EOL]     maxErr = 0; [EOL]     for (double x = -30; x < 30; x += 0.001) { [EOL]         double tst = FastMath.cosh(x); [EOL]         double ref = Math.cosh(x); [EOL]         maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref)); [EOL]     } [EOL]     Assert.assertEquals(0, maxErr, 2); [EOL]     maxErr = 0; [EOL]     for (double x = -0.5; x < 0.5; x += 0.001) { [EOL]         double tst = FastMath.tanh(x); [EOL]         double ref = Math.tanh(x); [EOL]         maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref)); [EOL]     } [EOL]     Assert.assertEquals(0, maxErr, 4); [EOL] } <line_num>: 132,158
@Test [EOL] public void testMath904() { [EOL]     final double x = -1; [EOL]     final double y = (5 + 1e-15) * 1e15; [EOL]     Assert.assertEquals(Math.pow(x, y), FastMath.pow(x, y), 0); [EOL]     Assert.assertEquals(Math.pow(x, -y), FastMath.pow(x, -y), 0); [EOL] } <line_num>: 160,168
@Test [EOL] public void testMath905LargePositive() { [EOL]     final double start = StrictMath.log(Double.MAX_VALUE); [EOL]     final double endT = StrictMath.sqrt(2) * StrictMath.sqrt(Double.MAX_VALUE); [EOL]     final double end = 2 * StrictMath.log(endT); [EOL]     double maxErr = 0; [EOL]     for (double x = start; x < end; x += 1e-3) { [EOL]         final double tst = FastMath.cosh(x); [EOL]         final double ref = Math.cosh(x); [EOL]         maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref)); [EOL]     } [EOL]     Assert.assertEquals(0, maxErr, 3); [EOL]     for (double x = start; x < end; x += 1e-3) { [EOL]         final double tst = FastMath.sinh(x); [EOL]         final double ref = Math.sinh(x); [EOL]         maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref)); [EOL]     } [EOL]     Assert.assertEquals(0, maxErr, 3); [EOL] } <line_num>: 170,190
@Test [EOL] public void testMath905LargeNegative() { [EOL]     final double start = -StrictMath.log(Double.MAX_VALUE); [EOL]     final double endT = StrictMath.sqrt(2) * StrictMath.sqrt(Double.MAX_VALUE); [EOL]     final double end = -2 * StrictMath.log(endT); [EOL]     double maxErr = 0; [EOL]     for (double x = start; x > end; x -= 1e-3) { [EOL]         final double tst = FastMath.cosh(x); [EOL]         final double ref = Math.cosh(x); [EOL]         maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref)); [EOL]     } [EOL]     Assert.assertEquals(0, maxErr, 3); [EOL]     for (double x = start; x > end; x -= 1e-3) { [EOL]         final double tst = FastMath.sinh(x); [EOL]         final double ref = Math.sinh(x); [EOL]         maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref)); [EOL]     } [EOL]     Assert.assertEquals(0, maxErr, 3); [EOL] } <line_num>: 192,212
@Test [EOL] public void testHyperbolicInverses() { [EOL]     double maxErr = 0; [EOL]     for (double x = -30; x < 30; x += 0.01) { [EOL]         maxErr = FastMath.max(maxErr, FastMath.abs(x - FastMath.sinh(FastMath.asinh(x))) / (2 * FastMath.ulp(x))); [EOL]     } [EOL]     Assert.assertEquals(0, maxErr, 3); [EOL]     maxErr = 0; [EOL]     for (double x = 1; x < 30; x += 0.01) { [EOL]         maxErr = FastMath.max(maxErr, FastMath.abs(x - FastMath.cosh(FastMath.acosh(x))) / (2 * FastMath.ulp(x))); [EOL]     } [EOL]     Assert.assertEquals(0, maxErr, 2); [EOL]     maxErr = 0; [EOL]     for (double x = -1 + Precision.EPSILON; x < 1 - Precision.EPSILON; x += 0.0001) { [EOL]         maxErr = FastMath.max(maxErr, FastMath.abs(x - FastMath.tanh(FastMath.atanh(x))) / (2 * FastMath.ulp(x))); [EOL]     } [EOL]     Assert.assertEquals(0, maxErr, 2); [EOL] } <line_num>: 214,234
@Test [EOL] public void testLogAccuracy() { [EOL]     double maxerrulp = 0.0; [EOL]     for (int i = 0; i < NUMBER_OF_TRIALS; i++) { [EOL]         double x = Math.exp(generator.nextDouble() * 1416.0 - 708.0) * generator.nextDouble(); [EOL]         double tst = FastMath.log(x); [EOL]         double ref = DfpMath.log(field.newDfp(x)).toDouble(); [EOL]         double err = (tst - ref) / ref; [EOL]         if (err != 0.0) { [EOL]             double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); [EOL]             double errulp = field.newDfp(tst).subtract(DfpMath.log(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); [EOL]             maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); [EOL]         } [EOL]     } [EOL]     Assert.assertTrue("log() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); [EOL] } <line_num>: 236,259
@Test [EOL] public void testLog10Accuracy() { [EOL]     double maxerrulp = 0.0; [EOL]     for (int i = 0; i < NUMBER_OF_TRIALS; i++) { [EOL]         double x = Math.exp(generator.nextDouble() * 1416.0 - 708.0) * generator.nextDouble(); [EOL]         double tst = FastMath.log10(x); [EOL]         double ref = DfpMath.log(field.newDfp(x)).divide(DfpMath.log(field.newDfp("10"))).toDouble(); [EOL]         double err = (tst - ref) / ref; [EOL]         if (err != 0.0) { [EOL]             double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); [EOL]             double errulp = field.newDfp(tst).subtract(DfpMath.log(field.newDfp(x)).divide(DfpMath.log(field.newDfp("10")))).divide(field.newDfp(ulp)).toDouble(); [EOL]             maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); [EOL]         } [EOL]     } [EOL]     Assert.assertTrue("log10() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); [EOL] } <line_num>: 261,283
@Test [EOL] public void testLog1pAccuracy() { [EOL]     double maxerrulp = 0.0; [EOL]     for (int i = 0; i < NUMBER_OF_TRIALS; i++) { [EOL]         double x = Math.exp(generator.nextDouble() * 10.0 - 5.0) * generator.nextDouble(); [EOL]         double tst = FastMath.log1p(x); [EOL]         double ref = DfpMath.log(field.newDfp(x).add(field.getOne())).toDouble(); [EOL]         double err = (tst - ref) / ref; [EOL]         if (err != 0.0) { [EOL]             double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); [EOL]             double errulp = field.newDfp(tst).subtract(DfpMath.log(field.newDfp(x).add(field.getOne()))).divide(field.newDfp(ulp)).toDouble(); [EOL]             maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); [EOL]         } [EOL]     } [EOL]     Assert.assertTrue("log1p() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); [EOL] } <line_num>: 285,307
@Test [EOL] public void testLog1pSpecialCases() { [EOL]     Assert.assertTrue("Logp of -1.0 should be -Inf", Double.isInfinite(FastMath.log1p(-1.0))); [EOL] } <line_num>: 309,314
@Test [EOL] public void testLogSpecialCases() { [EOL]     Assert.assertTrue("Log of zero should be -Inf", Double.isInfinite(FastMath.log(0.0))); [EOL]     Assert.assertTrue("Log of -zero should be -Inf", Double.isInfinite(FastMath.log(-0.0))); [EOL]     Assert.assertTrue("Log of NaN should be NaN", Double.isNaN(FastMath.log(Double.NaN))); [EOL]     Assert.assertTrue("Log of negative number should be NaN", Double.isNaN(FastMath.log(-1.0))); [EOL]     Assert.assertEquals("Log of Double.MIN_VALUE should be -744.4400719213812", -744.4400719213812, FastMath.log(Double.MIN_VALUE), Precision.EPSILON); [EOL]     Assert.assertTrue("Log of infinity should be infinity", Double.isInfinite(FastMath.log(Double.POSITIVE_INFINITY))); [EOL] } <line_num>: 316,330
@Test [EOL] public void testExpSpecialCases() { [EOL]     Assert.assertEquals(Double.MIN_VALUE, FastMath.exp(-745.1332191019411), Precision.EPSILON); [EOL]     Assert.assertEquals("exp(-745.1332191019412) should be 0.0", 0.0, FastMath.exp(-745.1332191019412), Precision.EPSILON); [EOL]     Assert.assertTrue("exp of NaN should be NaN", Double.isNaN(FastMath.exp(Double.NaN))); [EOL]     Assert.assertTrue("exp of infinity should be infinity", Double.isInfinite(FastMath.exp(Double.POSITIVE_INFINITY))); [EOL]     Assert.assertEquals("exp of -infinity should be 0.0", 0.0, FastMath.exp(Double.NEGATIVE_INFINITY), Precision.EPSILON); [EOL]     Assert.assertEquals("exp(1) should be Math.E", Math.E, FastMath.exp(1.0), Precision.EPSILON); [EOL] } <line_num>: 331,346
@Test [EOL] public void testPowSpecialCases() { [EOL]     Assert.assertEquals("pow(-1, 0) should be 1.0", 1.0, FastMath.pow(-1.0, 0.0), Precision.EPSILON); [EOL]     Assert.assertEquals("pow(-1, -0) should be 1.0", 1.0, FastMath.pow(-1.0, -0.0), Precision.EPSILON); [EOL]     Assert.assertEquals("pow(PI, 1.0) should be PI", FastMath.PI, FastMath.pow(FastMath.PI, 1.0), Precision.EPSILON); [EOL]     Assert.assertEquals("pow(-PI, 1.0) should be -PI", -FastMath.PI, FastMath.pow(-FastMath.PI, 1.0), Precision.EPSILON); [EOL]     Assert.assertTrue("pow(PI, NaN) should be NaN", Double.isNaN(FastMath.pow(Math.PI, Double.NaN))); [EOL]     Assert.assertTrue("pow(NaN, PI) should be NaN", Double.isNaN(FastMath.pow(Double.NaN, Math.PI))); [EOL]     Assert.assertTrue("pow(2.0, Infinity) should be Infinity", Double.isInfinite(FastMath.pow(2.0, Double.POSITIVE_INFINITY))); [EOL]     Assert.assertTrue("pow(0.5, -Infinity) should be Infinity", Double.isInfinite(FastMath.pow(0.5, Double.NEGATIVE_INFINITY))); [EOL]     Assert.assertEquals("pow(0.5, Infinity) should be 0.0", 0.0, FastMath.pow(0.5, Double.POSITIVE_INFINITY), Precision.EPSILON); [EOL]     Assert.assertEquals("pow(2.0, -Infinity) should be 0.0", 0.0, FastMath.pow(2.0, Double.NEGATIVE_INFINITY), Precision.EPSILON); [EOL]     Assert.assertEquals("pow(0.0, 0.5) should be 0.0", 0.0, FastMath.pow(0.0, 0.5), Precision.EPSILON); [EOL]     Assert.assertEquals("pow(Infinity, -0.5) should be 0.0", 0.0, FastMath.pow(Double.POSITIVE_INFINITY, -0.5), Precision.EPSILON); [EOL]     Assert.assertTrue("pow(0.0, -0.5) should be Inf", Double.isInfinite(FastMath.pow(0.0, -0.5))); [EOL]     Assert.assertTrue("pow(Inf, 0.5) should be Inf", Double.isInfinite(FastMath.pow(Double.POSITIVE_INFINITY, 0.5))); [EOL]     Assert.assertTrue("pow(-0.0, -3.0) should be -Inf", Double.isInfinite(FastMath.pow(-0.0, -3.0))); [EOL]     Assert.assertTrue("pow(-Inf, -3.0) should be -Inf", Double.isInfinite(FastMath.pow(Double.NEGATIVE_INFINITY, 3.0))); [EOL]     Assert.assertTrue("pow(-0.0, -3.5) should be Inf", Double.isInfinite(FastMath.pow(-0.0, -3.5))); [EOL]     Assert.assertTrue("pow(Inf, 3.5) should be Inf", Double.isInfinite(FastMath.pow(Double.POSITIVE_INFINITY, 3.5))); [EOL]     Assert.assertEquals("pow(-2.0, 3.0) should be -8.0", -8.0, FastMath.pow(-2.0, 3.0), Precision.EPSILON); [EOL]     Assert.assertTrue("pow(-2.0, 3.5) should be NaN", Double.isNaN(FastMath.pow(-2.0, 3.5))); [EOL]     Assert.assertTrue("pow(+Inf, NaN) should be NaN", Double.isNaN(FastMath.pow(Double.POSITIVE_INFINITY, Double.NaN))); [EOL]     Assert.assertTrue("pow(1.0, +Inf) should be NaN", Double.isNaN(FastMath.pow(1.0, Double.POSITIVE_INFINITY))); [EOL]     Assert.assertTrue("pow(-Inf, NaN) should be NaN", Double.isNaN(FastMath.pow(Double.NEGATIVE_INFINITY, Double.NaN))); [EOL]     Assert.assertEquals("pow(-Inf, -1.0) should be 0.0", 0.0, FastMath.pow(Double.NEGATIVE_INFINITY, -1.0), Precision.EPSILON); [EOL]     Assert.assertEquals("pow(-Inf, -2.0) should be 0.0", 0.0, FastMath.pow(Double.NEGATIVE_INFINITY, -2.0), Precision.EPSILON); [EOL]     Assert.assertTrue("pow(-Inf, 1.0) should be -Inf", Double.isInfinite(FastMath.pow(Double.NEGATIVE_INFINITY, 1.0))); [EOL]     Assert.assertTrue("pow(-Inf, 2.0) should be +Inf", Double.isInfinite(FastMath.pow(Double.NEGATIVE_INFINITY, 2.0))); [EOL]     Assert.assertTrue("pow(1.0, -Inf) should be NaN", Double.isNaN(FastMath.pow(1.0, Double.NEGATIVE_INFINITY))); [EOL] } <line_num>: 348,409
@Test [EOL] public void testAtan2SpecialCases() { [EOL]     Assert.assertTrue("atan2(NaN, 0.0) should be NaN", Double.isNaN(FastMath.atan2(Double.NaN, 0.0))); [EOL]     Assert.assertTrue("atan2(0.0, NaN) should be NaN", Double.isNaN(FastMath.atan2(0.0, Double.NaN))); [EOL]     Assert.assertEquals("atan2(0.0, 0.0) should be 0.0", 0.0, FastMath.atan2(0.0, 0.0), Precision.EPSILON); [EOL]     Assert.assertEquals("atan2(0.0, 0.001) should be 0.0", 0.0, FastMath.atan2(0.0, 0.001), Precision.EPSILON); [EOL]     Assert.assertEquals("atan2(0.1, +Inf) should be 0.0", 0.0, FastMath.atan2(0.1, Double.POSITIVE_INFINITY), Precision.EPSILON); [EOL]     Assert.assertEquals("atan2(-0.0, 0.0) should be -0.0", -0.0, FastMath.atan2(-0.0, 0.0), Precision.EPSILON); [EOL]     Assert.assertEquals("atan2(-0.0, 0.001) should be -0.0", -0.0, FastMath.atan2(-0.0, 0.001), Precision.EPSILON); [EOL]     Assert.assertEquals("atan2(-0.0, +Inf) should be -0.0", -0.0, FastMath.atan2(-0.1, Double.POSITIVE_INFINITY), Precision.EPSILON); [EOL]     Assert.assertEquals("atan2(0.0, -0.0) should be PI", FastMath.PI, FastMath.atan2(0.0, -0.0), Precision.EPSILON); [EOL]     Assert.assertEquals("atan2(0.1, -Inf) should be PI", FastMath.PI, FastMath.atan2(0.1, Double.NEGATIVE_INFINITY), Precision.EPSILON); [EOL]     Assert.assertEquals("atan2(-0.0, -0.0) should be -PI", -FastMath.PI, FastMath.atan2(-0.0, -0.0), Precision.EPSILON); [EOL]     Assert.assertEquals("atan2(0.1, -Inf) should be -PI", -FastMath.PI, FastMath.atan2(-0.1, Double.NEGATIVE_INFINITY), Precision.EPSILON); [EOL]     Assert.assertEquals("atan2(0.1, 0.0) should be PI/2", FastMath.PI / 2.0, FastMath.atan2(0.1, 0.0), Precision.EPSILON); [EOL]     Assert.assertEquals("atan2(0.1, -0.0) should be PI/2", FastMath.PI / 2.0, FastMath.atan2(0.1, -0.0), Precision.EPSILON); [EOL]     Assert.assertEquals("atan2(Inf, 0.1) should be PI/2", FastMath.PI / 2.0, FastMath.atan2(Double.POSITIVE_INFINITY, 0.1), Precision.EPSILON); [EOL]     Assert.assertEquals("atan2(Inf, -0.1) should be PI/2", FastMath.PI / 2.0, FastMath.atan2(Double.POSITIVE_INFINITY, -0.1), Precision.EPSILON); [EOL]     Assert.assertEquals("atan2(-0.1, 0.0) should be -PI/2", -FastMath.PI / 2.0, FastMath.atan2(-0.1, 0.0), Precision.EPSILON); [EOL]     Assert.assertEquals("atan2(-0.1, -0.0) should be -PI/2", -FastMath.PI / 2.0, FastMath.atan2(-0.1, -0.0), Precision.EPSILON); [EOL]     Assert.assertEquals("atan2(-Inf, 0.1) should be -PI/2", -FastMath.PI / 2.0, FastMath.atan2(Double.NEGATIVE_INFINITY, 0.1), Precision.EPSILON); [EOL]     Assert.assertEquals("atan2(-Inf, -0.1) should be -PI/2", -FastMath.PI / 2.0, FastMath.atan2(Double.NEGATIVE_INFINITY, -0.1), Precision.EPSILON); [EOL]     Assert.assertEquals("atan2(Inf, Inf) should be PI/4", FastMath.PI / 4.0, FastMath.atan2(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY), Precision.EPSILON); [EOL]     Assert.assertEquals("atan2(Inf, -Inf) should be PI * 3/4", FastMath.PI * 3.0 / 4.0, FastMath.atan2(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY), Precision.EPSILON); [EOL]     Assert.assertEquals("atan2(-Inf, Inf) should be -PI/4", -FastMath.PI / 4.0, FastMath.atan2(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY), Precision.EPSILON); [EOL]     Assert.assertEquals("atan2(-Inf, -Inf) should be -PI * 3/4", -FastMath.PI * 3.0 / 4.0, FastMath.atan2(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY), Precision.EPSILON); [EOL] } <line_num>: 411,465
@Test [EOL] public void testPowAccuracy() { [EOL]     double maxerrulp = 0.0; [EOL]     for (int i = 0; i < NUMBER_OF_TRIALS; i++) { [EOL]         double x = (generator.nextDouble() * 2.0 + 0.25); [EOL]         double y = (generator.nextDouble() * 1200.0 - 600.0) * generator.nextDouble(); [EOL]         double tst = FastMath.pow(x, y); [EOL]         double ref = DfpMath.pow(field.newDfp(x), field.newDfp(y)).toDouble(); [EOL]         double err = (tst - ref) / ref; [EOL]         if (err != 0) { [EOL]             double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); [EOL]             double errulp = field.newDfp(tst).subtract(DfpMath.pow(field.newDfp(x), field.newDfp(y))).divide(field.newDfp(ulp)).toDouble(); [EOL]             maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); [EOL]         } [EOL]     } [EOL]     Assert.assertTrue("pow() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); [EOL] } <line_num>: 467,498
@Test [EOL] public void testExpAccuracy() { [EOL]     double maxerrulp = 0.0; [EOL]     for (int i = 0; i < NUMBER_OF_TRIALS; i++) { [EOL]         double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble(); [EOL]         double tst = FastMath.exp(x); [EOL]         double ref = DfpMath.exp(field.newDfp(x)).toDouble(); [EOL]         double err = (tst - ref) / ref; [EOL]         if (err != 0) { [EOL]             double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); [EOL]             double errulp = field.newDfp(tst).subtract(DfpMath.exp(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); [EOL]             maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); [EOL]         } [EOL]     } [EOL]     Assert.assertTrue("exp() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); [EOL] } <line_num>: 500,525
@Test [EOL] public void testSinAccuracy() { [EOL]     double maxerrulp = 0.0; [EOL]     for (int i = 0; i < NUMBER_OF_TRIALS; i++) { [EOL]         double x = ((generator.nextDouble() * Math.PI) - Math.PI / 2.0) * Math.pow(2, 21) * generator.nextDouble(); [EOL]         double tst = FastMath.sin(x); [EOL]         double ref = DfpMath.sin(field.newDfp(x)).toDouble(); [EOL]         double err = (tst - ref) / ref; [EOL]         if (err != 0) { [EOL]             double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); [EOL]             double errulp = field.newDfp(tst).subtract(DfpMath.sin(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); [EOL]             maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); [EOL]         } [EOL]     } [EOL]     Assert.assertTrue("sin() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); [EOL] } <line_num>: 527,554
@Test [EOL] public void testCosAccuracy() { [EOL]     double maxerrulp = 0.0; [EOL]     for (int i = 0; i < NUMBER_OF_TRIALS; i++) { [EOL]         double x = ((generator.nextDouble() * Math.PI) - Math.PI / 2.0) * Math.pow(2, 21) * generator.nextDouble(); [EOL]         double tst = FastMath.cos(x); [EOL]         double ref = DfpMath.cos(field.newDfp(x)).toDouble(); [EOL]         double err = (tst - ref) / ref; [EOL]         if (err != 0) { [EOL]             double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); [EOL]             double errulp = field.newDfp(tst).subtract(DfpMath.cos(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); [EOL]             maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); [EOL]         } [EOL]     } [EOL]     Assert.assertTrue("cos() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); [EOL] } <line_num>: 556,583
@Test [EOL] public void testTanAccuracy() { [EOL]     double maxerrulp = 0.0; [EOL]     for (int i = 0; i < NUMBER_OF_TRIALS; i++) { [EOL]         double x = ((generator.nextDouble() * Math.PI) - Math.PI / 2.0) * Math.pow(2, 12) * generator.nextDouble(); [EOL]         double tst = FastMath.tan(x); [EOL]         double ref = DfpMath.tan(field.newDfp(x)).toDouble(); [EOL]         double err = (tst - ref) / ref; [EOL]         if (err != 0) { [EOL]             double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); [EOL]             double errulp = field.newDfp(tst).subtract(DfpMath.tan(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); [EOL]             maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); [EOL]         } [EOL]     } [EOL]     Assert.assertTrue("tan() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); [EOL] } <line_num>: 585,612
@Test [EOL] public void testAtanAccuracy() { [EOL]     double maxerrulp = 0.0; [EOL]     for (int i = 0; i < NUMBER_OF_TRIALS; i++) { [EOL]         double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble(); [EOL]         double tst = FastMath.atan(x); [EOL]         double ref = DfpMath.atan(field.newDfp(x)).toDouble(); [EOL]         double err = (tst - ref) / ref; [EOL]         if (err != 0) { [EOL]             double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); [EOL]             double errulp = field.newDfp(tst).subtract(DfpMath.atan(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); [EOL]             maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); [EOL]         } [EOL]     } [EOL]     Assert.assertTrue("atan() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); [EOL] } <line_num>: 614,643
@Test [EOL] public void testAtan2Accuracy() { [EOL]     double maxerrulp = 0.0; [EOL]     for (int i = 0; i < NUMBER_OF_TRIALS; i++) { [EOL]         double x = generator.nextDouble() - 0.5; [EOL]         double y = generator.nextDouble() - 0.5; [EOL]         double tst = FastMath.atan2(y, x); [EOL]         Dfp refdfp = DfpMath.atan(field.newDfp(y).divide(field.newDfp(x))); [EOL]         if (x < 0.0) { [EOL]             if (y > 0.0) [EOL]                 refdfp = field.getPi().add(refdfp); [EOL]             else [EOL]                 refdfp = refdfp.subtract(field.getPi()); [EOL]         } [EOL]         double ref = refdfp.toDouble(); [EOL]         double err = (tst - ref) / ref; [EOL]         if (err != 0) { [EOL]             double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); [EOL]             double errulp = field.newDfp(tst).subtract(refdfp).divide(field.newDfp(ulp)).toDouble(); [EOL]             maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); [EOL]         } [EOL]     } [EOL]     Assert.assertTrue("atan2() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); [EOL] } <line_num>: 645,683
@Test [EOL] public void testExpm1Accuracy() { [EOL]     double maxerrulp = 0.0; [EOL]     for (int i = 0; i < NUMBER_OF_TRIALS; i++) { [EOL]         double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble(); [EOL]         double tst = FastMath.expm1(x); [EOL]         double ref = DfpMath.exp(field.newDfp(x)).subtract(field.getOne()).toDouble(); [EOL]         double err = (tst - ref) / ref; [EOL]         if (err != 0) { [EOL]             double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); [EOL]             double errulp = field.newDfp(tst).subtract(DfpMath.exp(field.newDfp(x)).subtract(field.getOne())).divide(field.newDfp(ulp)).toDouble(); [EOL]             maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); [EOL]         } [EOL]     } [EOL]     Assert.assertTrue("expm1() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); [EOL] } <line_num>: 685,710
@Test [EOL] public void testAsinAccuracy() { [EOL]     double maxerrulp = 0.0; [EOL]     for (int i = 0; i < 10000; i++) { [EOL]         double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble(); [EOL]         double tst = FastMath.asin(x); [EOL]         double ref = DfpMath.asin(field.newDfp(x)).toDouble(); [EOL]         double err = (tst - ref) / ref; [EOL]         if (err != 0) { [EOL]             double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); [EOL]             double errulp = field.newDfp(tst).subtract(DfpMath.asin(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); [EOL]             maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); [EOL]         } [EOL]     } [EOL]     Assert.assertTrue("asin() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); [EOL] } <line_num>: 712,733
@Test [EOL] public void testAcosAccuracy() { [EOL]     double maxerrulp = 0.0; [EOL]     for (int i = 0; i < 10000; i++) { [EOL]         double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble(); [EOL]         double tst = FastMath.acos(x); [EOL]         double ref = DfpMath.acos(field.newDfp(x)).toDouble(); [EOL]         double err = (tst - ref) / ref; [EOL]         if (err != 0) { [EOL]             double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); [EOL]             double errulp = field.newDfp(tst).subtract(DfpMath.acos(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); [EOL]             maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); [EOL]         } [EOL]     } [EOL]     Assert.assertTrue("acos() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); [EOL] } <line_num>: 735,756
@Test [EOL] public void testAcosSpecialCases() { [EOL]     Assert.assertTrue("acos(NaN) should be NaN", Double.isNaN(FastMath.acos(Double.NaN))); [EOL]     Assert.assertTrue("acos(-1.1) should be NaN", Double.isNaN(FastMath.acos(-1.1))); [EOL]     Assert.assertTrue("acos(-1.1) should be NaN", Double.isNaN(FastMath.acos(1.1))); [EOL]     Assert.assertEquals("acos(-1.0) should be PI", FastMath.acos(-1.0), FastMath.PI, Precision.EPSILON); [EOL]     Assert.assertEquals("acos(1.0) should be 0.0", FastMath.acos(1.0), 0.0, Precision.EPSILON); [EOL]     Assert.assertEquals("acos(0.0) should be PI/2", FastMath.acos(0.0), FastMath.PI / 2.0, Precision.EPSILON); [EOL] } <line_num>: 761,775
@Test [EOL] public void testAsinSpecialCases() { [EOL]     Assert.assertTrue("asin(NaN) should be NaN", Double.isNaN(FastMath.asin(Double.NaN))); [EOL]     Assert.assertTrue("asin(1.1) should be NaN", Double.isNaN(FastMath.asin(1.1))); [EOL]     Assert.assertTrue("asin(-1.1) should be NaN", Double.isNaN(FastMath.asin(-1.1))); [EOL]     Assert.assertEquals("asin(1.0) should be PI/2", FastMath.asin(1.0), FastMath.PI / 2.0, Precision.EPSILON); [EOL]     Assert.assertEquals("asin(-1.0) should be -PI/2", FastMath.asin(-1.0), -FastMath.PI / 2.0, Precision.EPSILON); [EOL]     Assert.assertEquals("asin(0.0) should be 0.0", FastMath.asin(0.0), 0.0, Precision.EPSILON); [EOL] } <line_num>: 780,794
private Dfp cosh(Dfp x) { [EOL]     return DfpMath.exp(x).add(DfpMath.exp(x.negate())).divide(2); [EOL] } <line_num>: 796,798
private Dfp sinh(Dfp x) { [EOL]     return DfpMath.exp(x).subtract(DfpMath.exp(x.negate())).divide(2); [EOL] } <line_num>: 800,802
private Dfp tanh(Dfp x) { [EOL]     return sinh(x).divide(cosh(x)); [EOL] } <line_num>: 804,806
@Test [EOL] public void testSinhAccuracy() { [EOL]     double maxerrulp = 0.0; [EOL]     for (int i = 0; i < 10000; i++) { [EOL]         double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble(); [EOL]         double tst = FastMath.sinh(x); [EOL]         double ref = sinh(field.newDfp(x)).toDouble(); [EOL]         double err = (tst - ref) / ref; [EOL]         if (err != 0) { [EOL]             double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); [EOL]             double errulp = field.newDfp(tst).subtract(sinh(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); [EOL]             maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); [EOL]         } [EOL]     } [EOL]     Assert.assertTrue("sinh() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); [EOL] } <line_num>: 808,828
@Test [EOL] public void testCoshAccuracy() { [EOL]     double maxerrulp = 0.0; [EOL]     for (int i = 0; i < 10000; i++) { [EOL]         double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble(); [EOL]         double tst = FastMath.cosh(x); [EOL]         double ref = cosh(field.newDfp(x)).toDouble(); [EOL]         double err = (tst - ref) / ref; [EOL]         if (err != 0) { [EOL]             double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); [EOL]             double errulp = field.newDfp(tst).subtract(cosh(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); [EOL]             maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); [EOL]         } [EOL]     } [EOL]     Assert.assertTrue("cosh() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); [EOL] } <line_num>: 830,850
@Test [EOL] public void testTanhAccuracy() { [EOL]     double maxerrulp = 0.0; [EOL]     for (int i = 0; i < 10000; i++) { [EOL]         double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble(); [EOL]         double tst = FastMath.tanh(x); [EOL]         double ref = tanh(field.newDfp(x)).toDouble(); [EOL]         double err = (tst - ref) / ref; [EOL]         if (err != 0) { [EOL]             double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); [EOL]             double errulp = field.newDfp(tst).subtract(tanh(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); [EOL]             maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); [EOL]         } [EOL]     } [EOL]     Assert.assertTrue("tanh() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); [EOL] } <line_num>: 852,872
@Test [EOL] public void testCbrtAccuracy() { [EOL]     double maxerrulp = 0.0; [EOL]     for (int i = 0; i < 10000; i++) { [EOL]         double x = ((generator.nextDouble() * 200.0) - 100.0) * generator.nextDouble(); [EOL]         double tst = FastMath.cbrt(x); [EOL]         double ref = cbrt(field.newDfp(x)).toDouble(); [EOL]         double err = (tst - ref) / ref; [EOL]         if (err != 0) { [EOL]             double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); [EOL]             double errulp = field.newDfp(tst).subtract(cbrt(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); [EOL]             maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); [EOL]         } [EOL]     } [EOL]     Assert.assertTrue("cbrt() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); [EOL] } <line_num>: 874,894
private Dfp cbrt(Dfp x) { [EOL]     boolean negative = false; [EOL]     if (x.lessThan(field.getZero())) { [EOL]         negative = true; [EOL]         x = x.negate(); [EOL]     } [EOL]     Dfp y = DfpMath.pow(x, field.getOne().divide(3)); [EOL]     if (negative) { [EOL]         y = y.negate(); [EOL]     } [EOL]     return y; [EOL] } <line_num>: 896,911
@Test [EOL] public void testToDegrees() { [EOL]     double maxerrulp = 0.0; [EOL]     for (int i = 0; i < NUMBER_OF_TRIALS; i++) { [EOL]         double x = generator.nextDouble(); [EOL]         double tst = field.newDfp(x).multiply(180).divide(field.getPi()).toDouble(); [EOL]         double ref = FastMath.toDegrees(x); [EOL]         double err = (tst - ref) / ref; [EOL]         if (err != 0) { [EOL]             double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); [EOL]             double errulp = field.newDfp(tst).subtract(DfpMath.exp(field.newDfp(x)).subtract(field.getOne())).divide(field.newDfp(ulp)).toDouble(); [EOL]             maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); [EOL]         } [EOL]     } [EOL]     Assert.assertTrue("toDegrees() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); [EOL] } <line_num>: 913,933
@Test [EOL] public void testToRadians() { [EOL]     double maxerrulp = 0.0; [EOL]     for (int i = 0; i < NUMBER_OF_TRIALS; i++) { [EOL]         double x = generator.nextDouble(); [EOL]         double tst = field.newDfp(x).multiply(field.getPi()).divide(180).toDouble(); [EOL]         double ref = FastMath.toRadians(x); [EOL]         double err = (tst - ref) / ref; [EOL]         if (err != 0) { [EOL]             double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); [EOL]             double errulp = field.newDfp(tst).subtract(DfpMath.exp(field.newDfp(x)).subtract(field.getOne())).divide(field.newDfp(ulp)).toDouble(); [EOL]             maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); [EOL]         } [EOL]     } [EOL]     Assert.assertTrue("toRadians() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); [EOL] } <line_num>: 935,956
@Test [EOL] public void testNextAfter() { [EOL]     Assert.assertEquals(16.0, FastMath.nextAfter(15.999999999999998, 34.27555555555555), 0.0); [EOL]     Assert.assertEquals(-15.999999999999996, FastMath.nextAfter(-15.999999999999998, 34.27555555555555), 0.0); [EOL]     Assert.assertEquals(15.999999999999996, FastMath.nextAfter(15.999999999999998, 2.142222222222222), 0.0); [EOL]     Assert.assertEquals(-15.999999999999996, FastMath.nextAfter(-15.999999999999998, 2.142222222222222), 0.0); [EOL]     Assert.assertEquals(8.000000000000002, FastMath.nextAfter(8.0, 34.27555555555555), 0.0); [EOL]     Assert.assertEquals(-7.999999999999999, FastMath.nextAfter(-8.0, 34.27555555555555), 0.0); [EOL]     Assert.assertEquals(7.999999999999999, FastMath.nextAfter(8.0, 2.142222222222222), 0.0); [EOL]     Assert.assertEquals(-7.999999999999999, FastMath.nextAfter(-8.0, 2.142222222222222), 0.0); [EOL]     Assert.assertEquals(2.308922399667661E-4, FastMath.nextAfter(2.3089223996676606E-4, 2.308922399667661E-4), 0.0); [EOL]     Assert.assertEquals(2.3089223996676606E-4, FastMath.nextAfter(2.3089223996676606E-4, 2.3089223996676606E-4), 0.0); [EOL]     Assert.assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, 2.3089223996676603E-4), 0.0); [EOL]     Assert.assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, -2.308922399667661E-4), 0.0); [EOL]     Assert.assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, -2.3089223996676606E-4), 0.0); [EOL]     Assert.assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, -2.3089223996676603E-4), 0.0); [EOL]     Assert.assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, 2.308922399667661E-4), 0.0); [EOL]     Assert.assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, 2.3089223996676606E-4), 0.0); [EOL]     Assert.assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, 2.3089223996676603E-4), 0.0); [EOL]     Assert.assertEquals(-2.308922399667661E-4, FastMath.nextAfter(-2.3089223996676606E-4, -2.308922399667661E-4), 0.0); [EOL]     Assert.assertEquals(-2.3089223996676606E-4, FastMath.nextAfter(-2.3089223996676606E-4, -2.3089223996676606E-4), 0.0); [EOL]     Assert.assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, -2.3089223996676603E-4), 0.0); [EOL] } <line_num>: 958,1020
@Test [EOL] public void testDoubleNextAfterSpecialCases() { [EOL]     Assert.assertEquals(-Double.MAX_VALUE, FastMath.nextAfter(Double.NEGATIVE_INFINITY, 0D), 0D); [EOL]     Assert.assertEquals(Double.MAX_VALUE, FastMath.nextAfter(Double.POSITIVE_INFINITY, 0D), 0D); [EOL]     Assert.assertEquals(Double.NaN, FastMath.nextAfter(Double.NaN, 0D), 0D); [EOL]     Assert.assertEquals(Double.POSITIVE_INFINITY, FastMath.nextAfter(Double.MAX_VALUE, Double.POSITIVE_INFINITY), 0D); [EOL]     Assert.assertEquals(Double.NEGATIVE_INFINITY, FastMath.nextAfter(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY), 0D); [EOL]     Assert.assertEquals(Double.MIN_VALUE, FastMath.nextAfter(0D, 1D), 0D); [EOL]     Assert.assertEquals(-Double.MIN_VALUE, FastMath.nextAfter(0D, -1D), 0D); [EOL]     Assert.assertEquals(0D, FastMath.nextAfter(Double.MIN_VALUE, -1), 0D); [EOL]     Assert.assertEquals(0D, FastMath.nextAfter(-Double.MIN_VALUE, 1), 0D); [EOL] } <line_num>: 1022,1033
@Test [EOL] public void testFloatNextAfterSpecialCases() { [EOL]     Assert.assertEquals(-Float.MAX_VALUE, FastMath.nextAfter(Float.NEGATIVE_INFINITY, 0F), 0F); [EOL]     Assert.assertEquals(Float.MAX_VALUE, FastMath.nextAfter(Float.POSITIVE_INFINITY, 0F), 0F); [EOL]     Assert.assertEquals(Float.NaN, FastMath.nextAfter(Float.NaN, 0F), 0F); [EOL]     Assert.assertEquals(Float.POSITIVE_INFINITY, FastMath.nextAfter(Float.MAX_VALUE, Float.POSITIVE_INFINITY), 0F); [EOL]     Assert.assertEquals(Float.NEGATIVE_INFINITY, FastMath.nextAfter(-Float.MAX_VALUE, Float.NEGATIVE_INFINITY), 0F); [EOL]     Assert.assertEquals(Float.MIN_VALUE, FastMath.nextAfter(0F, 1F), 0F); [EOL]     Assert.assertEquals(-Float.MIN_VALUE, FastMath.nextAfter(0F, -1F), 0F); [EOL]     Assert.assertEquals(0F, FastMath.nextAfter(Float.MIN_VALUE, -1F), 0F); [EOL]     Assert.assertEquals(0F, FastMath.nextAfter(-Float.MIN_VALUE, 1F), 0F); [EOL] } <line_num>: 1035,1046
@Test [EOL] public void testDoubleScalbSpecialCases() { [EOL]     Assert.assertEquals(2.5269841324701218E-175, FastMath.scalb(2.2250738585072014E-308, 442), 0D); [EOL]     Assert.assertEquals(1.307993905256674E297, FastMath.scalb(1.1102230246251565E-16, 1040), 0D); [EOL]     Assert.assertEquals(7.2520887996488946E-217, FastMath.scalb(Double.MIN_VALUE, 356), 0D); [EOL]     Assert.assertEquals(8.98846567431158E307, FastMath.scalb(Double.MIN_VALUE, 2097), 0D); [EOL]     Assert.assertEquals(Double.POSITIVE_INFINITY, FastMath.scalb(Double.MIN_VALUE, 2098), 0D); [EOL]     Assert.assertEquals(1.1125369292536007E-308, FastMath.scalb(2.225073858507201E-308, -1), 0D); [EOL]     Assert.assertEquals(1.0E-323, FastMath.scalb(Double.MAX_VALUE, -2097), 0D); [EOL]     Assert.assertEquals(Double.MIN_VALUE, FastMath.scalb(Double.MAX_VALUE, -2098), 0D); [EOL]     Assert.assertEquals(0, FastMath.scalb(Double.MAX_VALUE, -2099), 0D); [EOL]     Assert.assertEquals(Double.POSITIVE_INFINITY, FastMath.scalb(Double.POSITIVE_INFINITY, -1000000), 0D); [EOL]     Assert.assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-1.1102230246251565E-16, 1078), 0D); [EOL]     Assert.assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-1.1102230246251565E-16, 1079), 0D); [EOL]     Assert.assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-2.2250738585072014E-308, 2047), 0D); [EOL]     Assert.assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-2.2250738585072014E-308, 2048), 0D); [EOL]     Assert.assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-1.7976931348623157E308, 2147483647), 0D); [EOL]     Assert.assertEquals(Double.POSITIVE_INFINITY, FastMath.scalb(1.7976931348623157E308, 2147483647), 0D); [EOL]     Assert.assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-1.1102230246251565E-16, 2147483647), 0D); [EOL]     Assert.assertEquals(Double.POSITIVE_INFINITY, FastMath.scalb(1.1102230246251565E-16, 2147483647), 0D); [EOL]     Assert.assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-2.2250738585072014E-308, 2147483647), 0D); [EOL]     Assert.assertEquals(Double.POSITIVE_INFINITY, FastMath.scalb(2.2250738585072014E-308, 2147483647), 0D); [EOL] } <line_num>: 1048,1070
@Test [EOL] public void testFloatScalbSpecialCases() { [EOL]     Assert.assertEquals(0f, FastMath.scalb(Float.MIN_VALUE, -30), 0F); [EOL]     Assert.assertEquals(2 * Float.MIN_VALUE, FastMath.scalb(Float.MIN_VALUE, 1), 0F); [EOL]     Assert.assertEquals(7.555786e22f, FastMath.scalb(Float.MAX_VALUE, -52), 0F); [EOL]     Assert.assertEquals(1.7014118e38f, FastMath.scalb(Float.MIN_VALUE, 276), 0F); [EOL]     Assert.assertEquals(Float.POSITIVE_INFINITY, FastMath.scalb(Float.MIN_VALUE, 277), 0F); [EOL]     Assert.assertEquals(5.8774718e-39f, FastMath.scalb(1.1754944e-38f, -1), 0F); [EOL]     Assert.assertEquals(2 * Float.MIN_VALUE, FastMath.scalb(Float.MAX_VALUE, -276), 0F); [EOL]     Assert.assertEquals(Float.MIN_VALUE, FastMath.scalb(Float.MAX_VALUE, -277), 0F); [EOL]     Assert.assertEquals(0, FastMath.scalb(Float.MAX_VALUE, -278), 0F); [EOL]     Assert.assertEquals(Float.POSITIVE_INFINITY, FastMath.scalb(Float.POSITIVE_INFINITY, -1000000), 0F); [EOL]     Assert.assertEquals(-3.13994498e38f, FastMath.scalb(-1.1e-7f, 151), 0F); [EOL]     Assert.assertEquals(Float.NEGATIVE_INFINITY, FastMath.scalb(-1.1e-7f, 152), 0F); [EOL]     Assert.assertEquals(Float.POSITIVE_INFINITY, FastMath.scalb(3.4028235E38f, 2147483647), 0F); [EOL]     Assert.assertEquals(Float.NEGATIVE_INFINITY, FastMath.scalb(-3.4028235E38f, 2147483647), 0F); [EOL] } <line_num>: 1072,1088
private boolean compareClassMethods(Class<?> class1, Class<?> class2) { [EOL]     boolean allfound = true; [EOL]     for (Method method1 : class1.getDeclaredMethods()) { [EOL]         if (Modifier.isPublic(method1.getModifiers())) { [EOL]             Type[] params = method1.getGenericParameterTypes(); [EOL]             try { [EOL]                 class2.getDeclaredMethod(method1.getName(), (Class[]) params); [EOL]             } catch (NoSuchMethodException e) { [EOL]                 allfound = false; [EOL]                 System.out.println(class2.getSimpleName() + " does not implement: " + method1); [EOL]             } [EOL]         } [EOL]     } [EOL]     return allfound; [EOL] } <line_num>: 1090,1104
@Test [EOL] public void checkMissingFastMathClasses() { [EOL] } <line_num>: 1106,1107
@Ignore [EOL] @Test [EOL] public void checkExtraFastMathClasses() { [EOL]     compareClassMethods(FastMath.class, StrictMath.class); [EOL] } <line_num>: 1115,1119
@Test [EOL] public void testSignumDouble() { [EOL]     final double delta = 0.0; [EOL]     Assert.assertEquals(1.0, FastMath.signum(2.0), delta); [EOL]     Assert.assertEquals(0.0, FastMath.signum(0.0), delta); [EOL]     Assert.assertEquals(-1.0, FastMath.signum(-2.0), delta); [EOL]     TestUtils.assertSame(-0. / 0., FastMath.signum(Double.NaN)); [EOL] } <line_num>: 1121,1128
@Test [EOL] public void testSignumFloat() { [EOL]     final float delta = 0.0F; [EOL]     Assert.assertEquals(1.0F, FastMath.signum(2.0F), delta); [EOL]     Assert.assertEquals(0.0F, FastMath.signum(0.0F), delta); [EOL]     Assert.assertEquals(-1.0F, FastMath.signum(-2.0F), delta); [EOL]     TestUtils.assertSame(Float.NaN, FastMath.signum(Float.NaN)); [EOL] } <line_num>: 1130,1137
@Test [EOL] public void testLogWithBase() { [EOL]     Assert.assertEquals(2.0, FastMath.log(2, 4), 0); [EOL]     Assert.assertEquals(3.0, FastMath.log(2, 8), 0); [EOL]     Assert.assertTrue(Double.isNaN(FastMath.log(-1, 1))); [EOL]     Assert.assertTrue(Double.isNaN(FastMath.log(1, -1))); [EOL]     Assert.assertTrue(Double.isNaN(FastMath.log(0, 0))); [EOL]     Assert.assertEquals(0, FastMath.log(0, 10), 0); [EOL]     Assert.assertEquals(Double.NEGATIVE_INFINITY, FastMath.log(10, 0), 0); [EOL] } <line_num>: 1139,1148
@Test [EOL] public void testIndicatorDouble() { [EOL]     double delta = 0.0; [EOL]     Assert.assertEquals(1.0, FastMath.copySign(1d, 2.0), delta); [EOL]     Assert.assertEquals(1.0, FastMath.copySign(1d, 0.0), delta); [EOL]     Assert.assertEquals(-1.0, FastMath.copySign(1d, -0.0), delta); [EOL]     Assert.assertEquals(1.0, FastMath.copySign(1d, Double.POSITIVE_INFINITY), delta); [EOL]     Assert.assertEquals(-1.0, FastMath.copySign(1d, Double.NEGATIVE_INFINITY), delta); [EOL]     Assert.assertEquals(1.0, FastMath.copySign(1d, Double.NaN), delta); [EOL]     Assert.assertEquals(-1.0, FastMath.copySign(1d, -2.0), delta); [EOL] } <line_num>: 1150,1160
@Test [EOL] public void testIndicatorFloat() { [EOL]     float delta = 0.0F; [EOL]     Assert.assertEquals(1.0F, FastMath.copySign(1d, 2.0F), delta); [EOL]     Assert.assertEquals(1.0F, FastMath.copySign(1d, 0.0F), delta); [EOL]     Assert.assertEquals(-1.0F, FastMath.copySign(1d, -0.0F), delta); [EOL]     Assert.assertEquals(1.0F, FastMath.copySign(1d, Float.POSITIVE_INFINITY), delta); [EOL]     Assert.assertEquals(-1.0F, FastMath.copySign(1d, Float.NEGATIVE_INFINITY), delta); [EOL]     Assert.assertEquals(1.0F, FastMath.copySign(1d, Float.NaN), delta); [EOL]     Assert.assertEquals(-1.0F, FastMath.copySign(1d, -2.0F), delta); [EOL] } <line_num>: 1162,1172
@Test [EOL] public void testIntPow() { [EOL]     final int maxExp = 300; [EOL]     DfpField field = new DfpField(40); [EOL]     final double base = 1.23456789; [EOL]     Dfp baseDfp = field.newDfp(base); [EOL]     Dfp dfpPower = field.getOne(); [EOL]     for (int i = 0; i < maxExp; i++) { [EOL]         Assert.assertEquals("exp=" + i, dfpPower.toDouble(), FastMath.pow(base, i), 0.6 * FastMath.ulp(dfpPower.toDouble())); [EOL]         dfpPower = dfpPower.multiply(baseDfp); [EOL]     } [EOL] } <line_num>: 1174,1186
