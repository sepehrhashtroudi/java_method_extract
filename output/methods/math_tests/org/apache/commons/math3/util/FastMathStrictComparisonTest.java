public FastMathStrictComparisonTest(Method m, Method f, Type[] types, Object[][] data) throws Exception { [EOL]     this.mathMethod = m; [EOL]     this.fastMethod = f; [EOL]     this.types = types; [EOL]     this.valueArrays = data; [EOL] } <line_num>: 80,85
@Test [EOL] public void test1() throws Exception { [EOL]     setupMethodCall(mathMethod, fastMethod, types, valueArrays); [EOL] } <line_num>: 87,90
private static boolean isNumber(Double d) { [EOL]     return !(d.isInfinite() || d.isNaN()); [EOL] } <line_num>: 91,93
private static boolean isNumber(Float f) { [EOL]     return !(f.isInfinite() || f.isNaN()); [EOL] } <line_num>: 95,97
private static void reportFailedResults(Method mathMethod, Object[] params, Object expected, Object actual, int[] entries) { [EOL]     final String methodName = mathMethod.getName(); [EOL]     String format = null; [EOL]     long actL = 0; [EOL]     long expL = 0; [EOL]     if (expected instanceof Double) { [EOL]         Double exp = (Double) expected; [EOL]         Double act = (Double) actual; [EOL]         if (isNumber(exp) && isNumber(act) && exp != 0) { [EOL]             actL = Double.doubleToLongBits(act); [EOL]             expL = Double.doubleToLongBits(exp); [EOL]             if (Math.abs(actL - expL) == 1) { [EOL]                 if (methodName.equals("toRadians") || methodName.equals("atan2")) { [EOL]                     return; [EOL]                 } [EOL]             } [EOL]             format = "%016x"; [EOL]         } [EOL]     } else if (expected instanceof Float) { [EOL]         Float exp = (Float) expected; [EOL]         Float act = (Float) actual; [EOL]         if (isNumber(exp) && isNumber(act) && exp != 0) { [EOL]             actL = Float.floatToIntBits(act); [EOL]             expL = Float.floatToIntBits(exp); [EOL]             format = "%08x"; [EOL]         } [EOL]     } [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append(mathMethod.getReturnType().getSimpleName()); [EOL]     sb.append(" "); [EOL]     sb.append(methodName); [EOL]     sb.append("("); [EOL]     String sep = ""; [EOL]     for (Object o : params) { [EOL]         sb.append(sep); [EOL]         sb.append(o); [EOL]         sep = ", "; [EOL]     } [EOL]     sb.append(") expected "); [EOL]     if (format != null) { [EOL]         sb.append(String.format(format, expL)); [EOL]     } else { [EOL]         sb.append(expected); [EOL]     } [EOL]     sb.append(" actual "); [EOL]     if (format != null) { [EOL]         sb.append(String.format(format, actL)); [EOL]     } else { [EOL]         sb.append(actual); [EOL]     } [EOL]     sb.append(" entries "); [EOL]     sb.append(Arrays.toString(entries)); [EOL]     String message = sb.toString(); [EOL]     final boolean fatal = true; [EOL]     if (fatal) { [EOL]         Assert.fail(message); [EOL]     } else { [EOL]         System.out.println(message); [EOL]     } [EOL] } <line_num>: 99,159
private static void callMethods(Method mathMethod, Method fastMethod, Object[] params, int[] entries) throws IllegalAccessException, InvocationTargetException { [EOL]     try { [EOL]         Object expected = mathMethod.invoke(mathMethod, params); [EOL]         Object actual = fastMethod.invoke(mathMethod, params); [EOL]         if (!expected.equals(actual)) { [EOL]             reportFailedResults(mathMethod, params, expected, actual, entries); [EOL]         } [EOL]     } catch (IllegalArgumentException e) { [EOL]         Assert.fail(mathMethod + " " + e); [EOL]     } [EOL] } <line_num>: 161,173
private static void setupMethodCall(Method mathMethod, Method fastMethod, Type[] types, Object[][] valueArrays) throws Exception { [EOL]     Object[] params = new Object[types.length]; [EOL]     int entry1 = 0; [EOL]     int[] entries = new int[types.length]; [EOL]     for (Object d : valueArrays[0]) { [EOL]         entry1++; [EOL]         params[0] = d; [EOL]         entries[0] = entry1; [EOL]         if (params.length > 1) { [EOL]             int entry2 = 0; [EOL]             for (Object d1 : valueArrays[1]) { [EOL]                 entry2++; [EOL]                 params[1] = d1; [EOL]                 entries[1] = entry2; [EOL]                 callMethods(mathMethod, fastMethod, params, entries); [EOL]             } [EOL]         } else { [EOL]             callMethods(mathMethod, fastMethod, params, entries); [EOL]         } [EOL]     } [EOL] } <line_num>: 175,196
@Parameters [EOL] public static List<Object[]> data() throws Exception { [EOL]     String singleMethod = System.getProperty("testMethod"); [EOL]     List<Object[]> list = new ArrayList<Object[]>(); [EOL]     for (Method mathMethod : StrictMath.class.getDeclaredMethods()) { [EOL]         method: if (Modifier.isPublic(mathMethod.getModifiers())) { [EOL]             Type[] types = mathMethod.getGenericParameterTypes(); [EOL]             if (types.length >= 1) { [EOL]                 try { [EOL]                     Method fastMethod = FastMath.class.getDeclaredMethod(mathMethod.getName(), (Class[]) types); [EOL]                     if (Modifier.isPublic(fastMethod.getModifiers())) { [EOL]                         if (singleMethod != null && !fastMethod.getName().equals(singleMethod)) { [EOL]                             break method; [EOL]                         } [EOL]                         Object[][] values = new Object[types.length][]; [EOL]                         int index = 0; [EOL]                         for (Type t : types) { [EOL]                             if (t.equals(double.class)) { [EOL]                                 values[index] = DOUBLE_SPECIAL_VALUES; [EOL]                             } else if (t.equals(float.class)) { [EOL]                                 values[index] = FLOAT_SPECIAL_VALUES; [EOL]                             } else if (t.equals(long.class)) { [EOL]                                 values[index] = LONG_SPECIAL_VALUES; [EOL]                             } else if (t.equals(int.class)) { [EOL]                                 values[index] = INT_SPECIAL_VALUES; [EOL]                             } else { [EOL]                                 System.out.println("Cannot handle class " + t + " for " + mathMethod); [EOL]                                 break method; [EOL]                             } [EOL]                             index++; [EOL]                         } [EOL]                         list.add(new Object[] { mathMethod, fastMethod, types, values }); [EOL]                     } else { [EOL]                         System.out.println("Cannot find public FastMath method corresponding to: " + mathMethod); [EOL]                     } [EOL]                 } catch (NoSuchMethodException e) { [EOL]                     System.out.println("Cannot find FastMath method corresponding to: " + mathMethod); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return list; [EOL] } <line_num>: 198,248
