@Test [EOL] public void testScale() { [EOL]     final double[] test = new double[] { -2.5, -1, 0, 1, 2.5 }; [EOL]     final double[] correctTest = MathArrays.copyOf(test); [EOL]     final double[] correctScaled = new double[] { 5.25, 2.1, 0, -2.1, -5.25 }; [EOL]     final double[] scaled = MathArrays.scale(-2.1, test); [EOL]     for (int i = 0; i < test.length; i++) { [EOL]         Assert.assertEquals(correctTest[i], test[i], 0); [EOL]     } [EOL]     for (int i = 0; i < scaled.length; i++) { [EOL]         Assert.assertEquals(correctScaled[i], scaled[i], 0); [EOL]     } [EOL] } <line_num>: 39,56
@Test [EOL] public void testScaleInPlace() { [EOL]     final double[] test = new double[] { -2.5, -1, 0, 1, 2.5 }; [EOL]     final double[] correctScaled = new double[] { 5.25, 2.1, 0, -2.1, -5.25 }; [EOL]     MathArrays.scaleInPlace(-2.1, test); [EOL]     for (int i = 0; i < test.length; i++) { [EOL]         Assert.assertEquals(correctScaled[i], test[i], 0); [EOL]     } [EOL] } <line_num>: 58,68
@Test(expected = DimensionMismatchException.class) [EOL] public void testEbeAddPrecondition() { [EOL]     MathArrays.ebeAdd(new double[3], new double[4]); [EOL] } <line_num>: 70,73
@Test(expected = DimensionMismatchException.class) [EOL] public void testEbeSubtractPrecondition() { [EOL]     MathArrays.ebeSubtract(new double[3], new double[4]); [EOL] } <line_num>: 74,77
@Test(expected = DimensionMismatchException.class) [EOL] public void testEbeMultiplyPrecondition() { [EOL]     MathArrays.ebeMultiply(new double[3], new double[4]); [EOL] } <line_num>: 78,81
@Test(expected = DimensionMismatchException.class) [EOL] public void testEbeDividePrecondition() { [EOL]     MathArrays.ebeDivide(new double[3], new double[4]); [EOL] } <line_num>: 82,85
@Test [EOL] public void testEbeAdd() { [EOL]     final double[] a = { 0, 1, 2 }; [EOL]     final double[] b = { 3, 5, 7 }; [EOL]     final double[] r = MathArrays.ebeAdd(a, b); [EOL]     for (int i = 0; i < a.length; i++) { [EOL]         Assert.assertEquals(a[i] + b[i], r[i], 0); [EOL]     } [EOL] } <line_num>: 87,96
@Test [EOL] public void testEbeSubtract() { [EOL]     final double[] a = { 0, 1, 2 }; [EOL]     final double[] b = { 3, 5, 7 }; [EOL]     final double[] r = MathArrays.ebeSubtract(a, b); [EOL]     for (int i = 0; i < a.length; i++) { [EOL]         Assert.assertEquals(a[i] - b[i], r[i], 0); [EOL]     } [EOL] } <line_num>: 97,106
@Test [EOL] public void testEbeMultiply() { [EOL]     final double[] a = { 0, 1, 2 }; [EOL]     final double[] b = { 3, 5, 7 }; [EOL]     final double[] r = MathArrays.ebeMultiply(a, b); [EOL]     for (int i = 0; i < a.length; i++) { [EOL]         Assert.assertEquals(a[i] * b[i], r[i], 0); [EOL]     } [EOL] } <line_num>: 107,116
@Test [EOL] public void testEbeDivide() { [EOL]     final double[] a = { 0, 1, 2 }; [EOL]     final double[] b = { 3, 5, 7 }; [EOL]     final double[] r = MathArrays.ebeDivide(a, b); [EOL]     for (int i = 0; i < a.length; i++) { [EOL]         Assert.assertEquals(a[i] / b[i], r[i], 0); [EOL]     } [EOL] } <line_num>: 117,126
@Test [EOL] public void testL1DistanceDouble() { [EOL]     double[] p1 = { 2.5, 0.0 }; [EOL]     double[] p2 = { -0.5, 4.0 }; [EOL]     Assert.assertTrue(Precision.equals(7.0, MathArrays.distance1(p1, p2), 1)); [EOL] } <line_num>: 128,133
@Test [EOL] public void testL1DistanceInt() { [EOL]     int[] p1 = { 3, 0 }; [EOL]     int[] p2 = { 0, 4 }; [EOL]     Assert.assertEquals(7, MathArrays.distance1(p1, p2)); [EOL] } <line_num>: 135,140
@Test [EOL] public void testL2DistanceDouble() { [EOL]     double[] p1 = { 2.5, 0.0 }; [EOL]     double[] p2 = { -0.5, 4.0 }; [EOL]     Assert.assertTrue(Precision.equals(5.0, MathArrays.distance(p1, p2), 1)); [EOL] } <line_num>: 142,147
@Test [EOL] public void testL2DistanceInt() { [EOL]     int[] p1 = { 3, 0 }; [EOL]     int[] p2 = { 0, 4 }; [EOL]     Assert.assertTrue(Precision.equals(5, MathArrays.distance(p1, p2), 1)); [EOL] } <line_num>: 149,154
@Test [EOL] public void testLInfDistanceDouble() { [EOL]     double[] p1 = { 2.5, 0.0 }; [EOL]     double[] p2 = { -0.5, 4.0 }; [EOL]     Assert.assertTrue(Precision.equals(4.0, MathArrays.distanceInf(p1, p2), 1)); [EOL] } <line_num>: 156,161
@Test [EOL] public void testLInfDistanceInt() { [EOL]     int[] p1 = { 3, 0 }; [EOL]     int[] p2 = { 0, 4 }; [EOL]     Assert.assertEquals(4, MathArrays.distanceInf(p1, p2)); [EOL] } <line_num>: 163,168
@Test [EOL] public void testCheckOrder() { [EOL]     MathArrays.checkOrder(new double[] { -15, -5.5, -1, 2, 15 }, MathArrays.OrderDirection.INCREASING, true); [EOL]     MathArrays.checkOrder(new double[] { -15, -5.5, -1, 2, 2 }, MathArrays.OrderDirection.INCREASING, false); [EOL]     MathArrays.checkOrder(new double[] { 3, -5.5, -11, -27.5 }, MathArrays.OrderDirection.DECREASING, true); [EOL]     MathArrays.checkOrder(new double[] { 3, 0, 0, -5.5, -11, -27.5 }, MathArrays.OrderDirection.DECREASING, false); [EOL]     try { [EOL]         MathArrays.checkOrder(new double[] { -15, -5.5, -1, -1, 2, 15 }, MathArrays.OrderDirection.INCREASING, true); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (NonMonotonicSequenceException e) { [EOL]     } [EOL]     try { [EOL]         MathArrays.checkOrder(new double[] { -15, -5.5, -1, -2, 2 }, MathArrays.OrderDirection.INCREASING, false); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (NonMonotonicSequenceException e) { [EOL]     } [EOL]     try { [EOL]         MathArrays.checkOrder(new double[] { 3, 3, -5.5, -11, -27.5 }, MathArrays.OrderDirection.DECREASING, true); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (NonMonotonicSequenceException e) { [EOL]     } [EOL]     try { [EOL]         MathArrays.checkOrder(new double[] { 3, -1, 0, -5.5, -11, -27.5 }, MathArrays.OrderDirection.DECREASING, false); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (NonMonotonicSequenceException e) { [EOL]     } [EOL]     try { [EOL]         MathArrays.checkOrder(new double[] { 3, 0, -5.5, -11, -10 }, MathArrays.OrderDirection.DECREASING, false); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (NonMonotonicSequenceException e) { [EOL]     } [EOL] } <line_num>: 170,216
@Test [EOL] public void testIsMonotonic() { [EOL]     Assert.assertFalse(MathArrays.isMonotonic(new double[] { -15, -5.5, -1, -1, 2, 15 }, MathArrays.OrderDirection.INCREASING, true)); [EOL]     Assert.assertTrue(MathArrays.isMonotonic(new double[] { -15, -5.5, -1, 0, 2, 15 }, MathArrays.OrderDirection.INCREASING, true)); [EOL]     Assert.assertFalse(MathArrays.isMonotonic(new double[] { -15, -5.5, -1, -2, 2 }, MathArrays.OrderDirection.INCREASING, false)); [EOL]     Assert.assertTrue(MathArrays.isMonotonic(new double[] { -15, -5.5, -1, -1, 2 }, MathArrays.OrderDirection.INCREASING, false)); [EOL]     Assert.assertFalse(MathArrays.isMonotonic(new double[] { 3, 3, -5.5, -11, -27.5 }, MathArrays.OrderDirection.DECREASING, true)); [EOL]     Assert.assertTrue(MathArrays.isMonotonic(new double[] { 3, 2, -5.5, -11, -27.5 }, MathArrays.OrderDirection.DECREASING, true)); [EOL]     Assert.assertFalse(MathArrays.isMonotonic(new double[] { 3, -1, 0, -5.5, -11, -27.5 }, MathArrays.OrderDirection.DECREASING, false)); [EOL]     Assert.assertTrue(MathArrays.isMonotonic(new double[] { 3, 0, 0, -5.5, -11, -27.5 }, MathArrays.OrderDirection.DECREASING, false)); [EOL] } <line_num>: 218,236
@Test [EOL] public void testIsMonotonicComparable() { [EOL]     Assert.assertFalse(MathArrays.isMonotonic(new Double[] { new Double(-15), new Double(-5.5), new Double(-1), new Double(-1), new Double(2), new Double(15) }, MathArrays.OrderDirection.INCREASING, true)); [EOL]     Assert.assertTrue(MathArrays.isMonotonic(new Double[] { new Double(-15), new Double(-5.5), new Double(-1), new Double(0), new Double(2), new Double(15) }, MathArrays.OrderDirection.INCREASING, true)); [EOL]     Assert.assertFalse(MathArrays.isMonotonic(new Double[] { new Double(-15), new Double(-5.5), new Double(-1), new Double(-2), new Double(2) }, MathArrays.OrderDirection.INCREASING, false)); [EOL]     Assert.assertTrue(MathArrays.isMonotonic(new Double[] { new Double(-15), new Double(-5.5), new Double(-1), new Double(-1), new Double(2) }, MathArrays.OrderDirection.INCREASING, false)); [EOL]     Assert.assertFalse(MathArrays.isMonotonic(new Double[] { new Double(3), new Double(3), new Double(-5.5), new Double(-11), new Double(-27.5) }, MathArrays.OrderDirection.DECREASING, true)); [EOL]     Assert.assertTrue(MathArrays.isMonotonic(new Double[] { new Double(3), new Double(2), new Double(-5.5), new Double(-11), new Double(-27.5) }, MathArrays.OrderDirection.DECREASING, true)); [EOL]     Assert.assertFalse(MathArrays.isMonotonic(new Double[] { new Double(3), new Double(-1), new Double(0), new Double(-5.5), new Double(-11), new Double(-27.5) }, MathArrays.OrderDirection.DECREASING, false)); [EOL]     Assert.assertTrue(MathArrays.isMonotonic(new Double[] { new Double(3), new Double(0), new Double(0), new Double(-5.5), new Double(-11), new Double(-27.5) }, MathArrays.OrderDirection.DECREASING, false)); [EOL] } <line_num>: 238,292
@Test [EOL] public void testCheckRectangular() { [EOL]     final long[][] rect = new long[][] { { 0, 1 }, { 2, 3 } }; [EOL]     final long[][] ragged = new long[][] { { 0, 1 }, { 2 } }; [EOL]     final long[][] nullArray = null; [EOL]     final long[][] empty = new long[][] {}; [EOL]     MathArrays.checkRectangular(rect); [EOL]     MathArrays.checkRectangular(empty); [EOL]     try { [EOL]         MathArrays.checkRectangular(ragged); [EOL]         Assert.fail("Expecting DimensionMismatchException"); [EOL]     } catch (DimensionMismatchException ex) { [EOL]     } [EOL]     try { [EOL]         MathArrays.checkRectangular(nullArray); [EOL]         Assert.fail("Expecting NullArgumentException"); [EOL]     } catch (NullArgumentException ex) { [EOL]     } [EOL] } <line_num>: 294,314
@Test [EOL] public void testCheckPositive() { [EOL]     final double[] positive = new double[] { 1, 2, 3 }; [EOL]     final double[] nonNegative = new double[] { 0, 1, 2 }; [EOL]     final double[] nullArray = null; [EOL]     final double[] empty = new double[] {}; [EOL]     MathArrays.checkPositive(positive); [EOL]     MathArrays.checkPositive(empty); [EOL]     try { [EOL]         MathArrays.checkPositive(nullArray); [EOL]         Assert.fail("Expecting NullPointerException"); [EOL]     } catch (NullPointerException ex) { [EOL]     } [EOL]     try { [EOL]         MathArrays.checkPositive(nonNegative); [EOL]         Assert.fail("Expecting NotStrictlyPositiveException"); [EOL]     } catch (NotStrictlyPositiveException ex) { [EOL]     } [EOL] } <line_num>: 316,336
@Test [EOL] public void testCheckNonNegative() { [EOL]     final long[] nonNegative = new long[] { 0, 1 }; [EOL]     final long[] hasNegative = new long[] { -1 }; [EOL]     final long[] nullArray = null; [EOL]     final long[] empty = new long[] {}; [EOL]     MathArrays.checkNonNegative(nonNegative); [EOL]     MathArrays.checkNonNegative(empty); [EOL]     try { [EOL]         MathArrays.checkNonNegative(nullArray); [EOL]         Assert.fail("Expecting NullPointerException"); [EOL]     } catch (NullPointerException ex) { [EOL]     } [EOL]     try { [EOL]         MathArrays.checkNonNegative(hasNegative); [EOL]         Assert.fail("Expecting NotPositiveException"); [EOL]     } catch (NotPositiveException ex) { [EOL]     } [EOL] } <line_num>: 338,358
@Test [EOL] public void testCheckNonNegative2D() { [EOL]     final long[][] nonNegative = new long[][] { { 0, 1 }, { 1, 0 } }; [EOL]     final long[][] hasNegative = new long[][] { { -1 }, { 0 } }; [EOL]     final long[][] nullArray = null; [EOL]     final long[][] empty = new long[][] {}; [EOL]     MathArrays.checkNonNegative(nonNegative); [EOL]     MathArrays.checkNonNegative(empty); [EOL]     try { [EOL]         MathArrays.checkNonNegative(nullArray); [EOL]         Assert.fail("Expecting NullPointerException"); [EOL]     } catch (NullPointerException ex) { [EOL]     } [EOL]     try { [EOL]         MathArrays.checkNonNegative(hasNegative); [EOL]         Assert.fail("Expecting NotPositiveException"); [EOL]     } catch (NotPositiveException ex) { [EOL]     } [EOL] } <line_num>: 360,380
@Test [EOL] public void testSortInPlace() { [EOL]     final double[] x1 = { 2, 5, -3, 1, 4 }; [EOL]     final double[] x2 = { 4, 25, 9, 1, 16 }; [EOL]     final double[] x3 = { 8, 125, -27, 1, 64 }; [EOL]     MathArrays.sortInPlace(x1, x2, x3); [EOL]     Assert.assertEquals(-3, x1[0], Math.ulp(1d)); [EOL]     Assert.assertEquals(9, x2[0], Math.ulp(1d)); [EOL]     Assert.assertEquals(-27, x3[0], Math.ulp(1d)); [EOL]     Assert.assertEquals(1, x1[1], Math.ulp(1d)); [EOL]     Assert.assertEquals(1, x2[1], Math.ulp(1d)); [EOL]     Assert.assertEquals(1, x3[1], Math.ulp(1d)); [EOL]     Assert.assertEquals(2, x1[2], Math.ulp(1d)); [EOL]     Assert.assertEquals(4, x2[2], Math.ulp(1d)); [EOL]     Assert.assertEquals(8, x3[2], Math.ulp(1d)); [EOL]     Assert.assertEquals(4, x1[3], Math.ulp(1d)); [EOL]     Assert.assertEquals(16, x2[3], Math.ulp(1d)); [EOL]     Assert.assertEquals(64, x3[3], Math.ulp(1d)); [EOL]     Assert.assertEquals(5, x1[4], Math.ulp(1d)); [EOL]     Assert.assertEquals(25, x2[4], Math.ulp(1d)); [EOL]     Assert.assertEquals(125, x3[4], Math.ulp(1d)); [EOL] } <line_num>: 382,409
@Test [EOL] public void testSortInPlaceDecresasingOrder() { [EOL]     final double[] x1 = { 2, 5, -3, 1, 4 }; [EOL]     final double[] x2 = { 4, 25, 9, 1, 16 }; [EOL]     final double[] x3 = { 8, 125, -27, 1, 64 }; [EOL]     MathArrays.sortInPlace(x1, MathArrays.OrderDirection.DECREASING, x2, x3); [EOL]     Assert.assertEquals(-3, x1[4], Math.ulp(1d)); [EOL]     Assert.assertEquals(9, x2[4], Math.ulp(1d)); [EOL]     Assert.assertEquals(-27, x3[4], Math.ulp(1d)); [EOL]     Assert.assertEquals(1, x1[3], Math.ulp(1d)); [EOL]     Assert.assertEquals(1, x2[3], Math.ulp(1d)); [EOL]     Assert.assertEquals(1, x3[3], Math.ulp(1d)); [EOL]     Assert.assertEquals(2, x1[2], Math.ulp(1d)); [EOL]     Assert.assertEquals(4, x2[2], Math.ulp(1d)); [EOL]     Assert.assertEquals(8, x3[2], Math.ulp(1d)); [EOL]     Assert.assertEquals(4, x1[1], Math.ulp(1d)); [EOL]     Assert.assertEquals(16, x2[1], Math.ulp(1d)); [EOL]     Assert.assertEquals(64, x3[1], Math.ulp(1d)); [EOL]     Assert.assertEquals(5, x1[0], Math.ulp(1d)); [EOL]     Assert.assertEquals(25, x2[0], Math.ulp(1d)); [EOL]     Assert.assertEquals(125, x3[0], Math.ulp(1d)); [EOL] } <line_num>: 411,440
@Test [EOL] public void testSortInPlaceExample() { [EOL]     final double[] x = { 3, 1, 2 }; [EOL]     final double[] y = { 1, 2, 3 }; [EOL]     final double[] z = { 0, 5, 7 }; [EOL]     MathArrays.sortInPlace(x, y, z); [EOL]     final double[] sx = { 1, 2, 3 }; [EOL]     final double[] sy = { 2, 3, 1 }; [EOL]     final double[] sz = { 5, 7, 0 }; [EOL]     Assert.assertTrue(Arrays.equals(sx, x)); [EOL]     Assert.assertTrue(Arrays.equals(sy, y)); [EOL]     Assert.assertTrue(Arrays.equals(sz, z)); [EOL] } <line_num>: 442,455
@Test [EOL] public void testSortInPlaceFailures() { [EOL]     final double[] nullArray = null; [EOL]     final double[] one = { 1 }; [EOL]     final double[] two = { 1, 2 }; [EOL]     final double[] onep = { 2 }; [EOL]     try { [EOL]         MathArrays.sortInPlace(one, two); [EOL]         Assert.fail("Expecting DimensionMismatchException"); [EOL]     } catch (DimensionMismatchException ex) { [EOL]     } [EOL]     try { [EOL]         MathArrays.sortInPlace(one, nullArray); [EOL]         Assert.fail("Expecting NullArgumentException"); [EOL]     } catch (NullArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         MathArrays.sortInPlace(one, onep, nullArray); [EOL]         Assert.fail("Expecting NullArgumentException"); [EOL]     } catch (NullArgumentException ex) { [EOL]     } [EOL] } <line_num>: 457,481
@Test [EOL] public void testCopyOfInt() { [EOL]     final int[] source = { Integer.MIN_VALUE, -1, 0, 1, 3, 113, 4769, Integer.MAX_VALUE }; [EOL]     final int[] dest = MathArrays.copyOf(source); [EOL]     Assert.assertEquals(dest.length, source.length); [EOL]     for (int i = 0; i < source.length; i++) { [EOL]         Assert.assertEquals(source[i], dest[i]); [EOL]     } [EOL] } <line_num>: 483,494
@Test [EOL] public void testCopyOfInt2() { [EOL]     final int[] source = { Integer.MIN_VALUE, -1, 0, 1, 3, 113, 4769, Integer.MAX_VALUE }; [EOL]     final int offset = 3; [EOL]     final int[] dest = MathArrays.copyOf(source, source.length - offset); [EOL]     Assert.assertEquals(dest.length, source.length - offset); [EOL]     for (int i = 0; i < source.length - offset; i++) { [EOL]         Assert.assertEquals(source[i], dest[i]); [EOL]     } [EOL] } <line_num>: 496,508
@Test [EOL] public void testCopyOfInt3() { [EOL]     final int[] source = { Integer.MIN_VALUE, -1, 0, 1, 3, 113, 4769, Integer.MAX_VALUE }; [EOL]     final int offset = 3; [EOL]     final int[] dest = MathArrays.copyOf(source, source.length + offset); [EOL]     Assert.assertEquals(dest.length, source.length + offset); [EOL]     for (int i = 0; i < source.length; i++) { [EOL]         Assert.assertEquals(source[i], dest[i]); [EOL]     } [EOL]     for (int i = source.length; i < source.length + offset; i++) { [EOL]         Assert.assertEquals(0, dest[i], 0); [EOL]     } [EOL] } <line_num>: 510,525
@Test [EOL] public void testCopyOfDouble() { [EOL]     final double[] source = { Double.NEGATIVE_INFINITY, -Double.MAX_VALUE, -1, 0, Double.MIN_VALUE, Math.ulp(1d), 1, 3, 113, 4769, Double.MAX_VALUE, Double.POSITIVE_INFINITY }; [EOL]     final double[] dest = MathArrays.copyOf(source); [EOL]     Assert.assertEquals(dest.length, source.length); [EOL]     for (int i = 0; i < source.length; i++) { [EOL]         Assert.assertEquals(source[i], dest[i], 0); [EOL]     } [EOL] } <line_num>: 527,543
@Test [EOL] public void testCopyOfDouble2() { [EOL]     final double[] source = { Double.NEGATIVE_INFINITY, -Double.MAX_VALUE, -1, 0, Double.MIN_VALUE, Math.ulp(1d), 1, 3, 113, 4769, Double.MAX_VALUE, Double.POSITIVE_INFINITY }; [EOL]     final int offset = 3; [EOL]     final double[] dest = MathArrays.copyOf(source, source.length - offset); [EOL]     Assert.assertEquals(dest.length, source.length - offset); [EOL]     for (int i = 0; i < source.length - offset; i++) { [EOL]         Assert.assertEquals(source[i], dest[i], 0); [EOL]     } [EOL] } <line_num>: 545,562
@Test [EOL] public void testCopyOfDouble3() { [EOL]     final double[] source = { Double.NEGATIVE_INFINITY, -Double.MAX_VALUE, -1, 0, Double.MIN_VALUE, Math.ulp(1d), 1, 3, 113, 4769, Double.MAX_VALUE, Double.POSITIVE_INFINITY }; [EOL]     final int offset = 3; [EOL]     final double[] dest = MathArrays.copyOf(source, source.length + offset); [EOL]     Assert.assertEquals(dest.length, source.length + offset); [EOL]     for (int i = 0; i < source.length; i++) { [EOL]         Assert.assertEquals(source[i], dest[i], 0); [EOL]     } [EOL]     for (int i = source.length; i < source.length + offset; i++) { [EOL]         Assert.assertEquals(0, dest[i], 0); [EOL]     } [EOL] } <line_num>: 564,584
@Test [EOL] public void testLinearCombinationWithSingleElementArray() { [EOL]     final double[] a = { 1.23456789 }; [EOL]     final double[] b = { 98765432.1 }; [EOL]     Assert.assertEquals(a[0] * b[0], MathArrays.linearCombination(a, b), 0d); [EOL] } <line_num>: 587,593
@Test [EOL] public void testLinearCombination1() { [EOL]     final double[] a = new double[] { -1321008684645961.0 / 268435456.0, -5774608829631843.0 / 268435456.0, -7645843051051357.0 / 8589934592.0 }; [EOL]     final double[] b = new double[] { -5712344449280879.0 / 2097152.0, -4550117129121957.0 / 2097152.0, 8846951984510141.0 / 131072.0 }; [EOL]     final double abSumInline = MathArrays.linearCombination(a[0], b[0], a[1], b[1], a[2], b[2]); [EOL]     final double abSumArray = MathArrays.linearCombination(a, b); [EOL]     Assert.assertEquals(abSumInline, abSumArray, 0); [EOL]     Assert.assertEquals(-1.8551294182586248737720779899, abSumInline, 1.0e-15); [EOL]     final double naive = a[0] * b[0] + a[1] * b[1] + a[2] * b[2]; [EOL]     Assert.assertTrue(FastMath.abs(naive - abSumInline) > 1.5); [EOL] } <line_num>: 595,619
@Test [EOL] public void testLinearCombination2() { [EOL]     Well1024a random = new Well1024a(553267312521321234l); [EOL]     for (int i = 0; i < 10000; ++i) { [EOL]         final double ux = 1e17 * random.nextDouble(); [EOL]         final double uy = 1e17 * random.nextDouble(); [EOL]         final double uz = 1e17 * random.nextDouble(); [EOL]         final double vx = 1e17 * random.nextDouble(); [EOL]         final double vy = 1e17 * random.nextDouble(); [EOL]         final double vz = 1e17 * random.nextDouble(); [EOL]         final double sInline = MathArrays.linearCombination(ux, vx, uy, vy, uz, vz); [EOL]         final double sArray = MathArrays.linearCombination(new double[] { ux, uy, uz }, new double[] { vx, vy, vz }); [EOL]         Assert.assertEquals(sInline, sArray, 0); [EOL]     } [EOL] } <line_num>: 621,641
@Test [EOL] public void testLinearCombinationInfinite() { [EOL]     final double[][] a = new double[][] { { 1, 2, 3, 4 }, { 1, Double.POSITIVE_INFINITY, 3, 4 }, { 1, 2, Double.POSITIVE_INFINITY, 4 }, { 1, Double.POSITIVE_INFINITY, 3, Double.NEGATIVE_INFINITY }, { 1, 2, 3, 4 }, { 1, 2, 3, 4 }, { 1, 2, 3, 4 }, { 1, 2, 3, 4 } }; [EOL]     final double[][] b = new double[][] { { 1, -2, 3, 4 }, { 1, -2, 3, 4 }, { 1, -2, 3, 4 }, { 1, -2, 3, 4 }, { 1, Double.POSITIVE_INFINITY, 3, 4 }, { 1, -2, Double.POSITIVE_INFINITY, 4 }, { 1, Double.POSITIVE_INFINITY, 3, Double.NEGATIVE_INFINITY }, { Double.NaN, -2, 3, 4 } }; [EOL]     Assert.assertEquals(-3, MathArrays.linearCombination(a[0][0], b[0][0], a[0][1], b[0][1]), 1.0e-10); [EOL]     Assert.assertEquals(6, MathArrays.linearCombination(a[0][0], b[0][0], a[0][1], b[0][1], a[0][2], b[0][2]), 1.0e-10); [EOL]     Assert.assertEquals(22, MathArrays.linearCombination(a[0][0], b[0][0], a[0][1], b[0][1], a[0][2], b[0][2], a[0][3], b[0][3]), 1.0e-10); [EOL]     Assert.assertEquals(22, MathArrays.linearCombination(a[0], b[0]), 1.0e-10); [EOL]     Assert.assertEquals(Double.NEGATIVE_INFINITY, MathArrays.linearCombination(a[1][0], b[1][0], a[1][1], b[1][1]), 1.0e-10); [EOL]     Assert.assertEquals(Double.NEGATIVE_INFINITY, MathArrays.linearCombination(a[1][0], b[1][0], a[1][1], b[1][1], a[1][2], b[1][2]), 1.0e-10); [EOL]     Assert.assertEquals(Double.NEGATIVE_INFINITY, MathArrays.linearCombination(a[1][0], b[1][0], a[1][1], b[1][1], a[1][2], b[1][2], a[1][3], b[1][3]), 1.0e-10); [EOL]     Assert.assertEquals(Double.NEGATIVE_INFINITY, MathArrays.linearCombination(a[1], b[1]), 1.0e-10); [EOL]     Assert.assertEquals(-3, MathArrays.linearCombination(a[2][0], b[2][0], a[2][1], b[2][1]), 1.0e-10); [EOL]     Assert.assertEquals(Double.POSITIVE_INFINITY, MathArrays.linearCombination(a[2][0], b[2][0], a[2][1], b[2][1], a[2][2], b[2][2]), 1.0e-10); [EOL]     Assert.assertEquals(Double.POSITIVE_INFINITY, MathArrays.linearCombination(a[2][0], b[2][0], a[2][1], b[2][1], a[2][2], b[2][2], a[2][3], b[2][3]), 1.0e-10); [EOL]     Assert.assertEquals(Double.POSITIVE_INFINITY, MathArrays.linearCombination(a[2], b[2]), 1.0e-10); [EOL]     Assert.assertEquals(Double.NEGATIVE_INFINITY, MathArrays.linearCombination(a[3][0], b[3][0], a[3][1], b[3][1]), 1.0e-10); [EOL]     Assert.assertEquals(Double.NEGATIVE_INFINITY, MathArrays.linearCombination(a[3][0], b[3][0], a[3][1], b[3][1], a[3][2], b[3][2]), 1.0e-10); [EOL]     Assert.assertEquals(Double.NEGATIVE_INFINITY, MathArrays.linearCombination(a[3][0], b[3][0], a[3][1], b[3][1], a[3][2], b[3][2], a[3][3], b[3][3]), 1.0e-10); [EOL]     Assert.assertEquals(Double.NEGATIVE_INFINITY, MathArrays.linearCombination(a[3], b[3]), 1.0e-10); [EOL]     Assert.assertEquals(Double.POSITIVE_INFINITY, MathArrays.linearCombination(a[4][0], b[4][0], a[4][1], b[4][1]), 1.0e-10); [EOL]     Assert.assertEquals(Double.POSITIVE_INFINITY, MathArrays.linearCombination(a[4][0], b[4][0], a[4][1], b[4][1], a[4][2], b[4][2]), 1.0e-10); [EOL]     Assert.assertEquals(Double.POSITIVE_INFINITY, MathArrays.linearCombination(a[4][0], b[4][0], a[4][1], b[4][1], a[4][2], b[4][2], a[4][3], b[4][3]), 1.0e-10); [EOL]     Assert.assertEquals(Double.POSITIVE_INFINITY, MathArrays.linearCombination(a[4], b[4]), 1.0e-10); [EOL]     Assert.assertEquals(-3, MathArrays.linearCombination(a[5][0], b[5][0], a[5][1], b[5][1]), 1.0e-10); [EOL]     Assert.assertEquals(Double.POSITIVE_INFINITY, MathArrays.linearCombination(a[5][0], b[5][0], a[5][1], b[5][1], a[5][2], b[5][2]), 1.0e-10); [EOL]     Assert.assertEquals(Double.POSITIVE_INFINITY, MathArrays.linearCombination(a[5][0], b[5][0], a[5][1], b[5][1], a[5][2], b[5][2], a[5][3], b[5][3]), 1.0e-10); [EOL]     Assert.assertEquals(Double.POSITIVE_INFINITY, MathArrays.linearCombination(a[5], b[5]), 1.0e-10); [EOL]     Assert.assertEquals(Double.POSITIVE_INFINITY, MathArrays.linearCombination(a[6][0], b[6][0], a[6][1], b[6][1]), 1.0e-10); [EOL]     Assert.assertEquals(Double.POSITIVE_INFINITY, MathArrays.linearCombination(a[6][0], b[6][0], a[6][1], b[6][1], a[6][2], b[6][2]), 1.0e-10); [EOL]     Assert.assertTrue(Double.isNaN(MathArrays.linearCombination(a[6][0], b[6][0], a[6][1], b[6][1], a[6][2], b[6][2], a[6][3], b[6][3]))); [EOL]     Assert.assertTrue(Double.isNaN(MathArrays.linearCombination(a[6], b[6]))); [EOL]     Assert.assertTrue(Double.isNaN(MathArrays.linearCombination(a[7][0], b[7][0], a[7][1], b[7][1]))); [EOL]     Assert.assertTrue(Double.isNaN(MathArrays.linearCombination(a[7][0], b[7][0], a[7][1], b[7][1], a[7][2], b[7][2]))); [EOL]     Assert.assertTrue(Double.isNaN(MathArrays.linearCombination(a[7][0], b[7][0], a[7][1], b[7][1], a[7][2], b[7][2], a[7][3], b[7][3]))); [EOL]     Assert.assertTrue(Double.isNaN(MathArrays.linearCombination(a[7], b[7]))); [EOL] } <line_num>: 643,793
@Test [EOL] public void testArrayEquals() { [EOL]     Assert.assertFalse(MathArrays.equals(new double[] { 1d }, null)); [EOL]     Assert.assertFalse(MathArrays.equals(null, new double[] { 1d })); [EOL]     Assert.assertTrue(MathArrays.equals((double[]) null, (double[]) null)); [EOL]     Assert.assertFalse(MathArrays.equals(new double[] { 1d }, new double[0])); [EOL]     Assert.assertTrue(MathArrays.equals(new double[] { 1d }, new double[] { 1d })); [EOL]     Assert.assertTrue(MathArrays.equals(new double[] { Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 1d, 0d }, new double[] { Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 1d, 0d })); [EOL]     Assert.assertFalse(MathArrays.equals(new double[] { Double.NaN }, new double[] { Double.NaN })); [EOL]     Assert.assertFalse(MathArrays.equals(new double[] { Double.POSITIVE_INFINITY }, new double[] { Double.NEGATIVE_INFINITY })); [EOL]     Assert.assertFalse(MathArrays.equals(new double[] { 1d }, new double[] { FastMath.nextAfter(FastMath.nextAfter(1d, 2d), 2d) })); [EOL] } <line_num>: 795,814
@Test [EOL] public void testArrayEqualsIncludingNaN() { [EOL]     Assert.assertFalse(MathArrays.equalsIncludingNaN(new double[] { 1d }, null)); [EOL]     Assert.assertFalse(MathArrays.equalsIncludingNaN(null, new double[] { 1d })); [EOL]     Assert.assertTrue(MathArrays.equalsIncludingNaN((double[]) null, (double[]) null)); [EOL]     Assert.assertFalse(MathArrays.equalsIncludingNaN(new double[] { 1d }, new double[0])); [EOL]     Assert.assertTrue(MathArrays.equalsIncludingNaN(new double[] { 1d }, new double[] { 1d })); [EOL]     Assert.assertTrue(MathArrays.equalsIncludingNaN(new double[] { Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 1d, 0d }, new double[] { Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 1d, 0d })); [EOL]     Assert.assertFalse(MathArrays.equalsIncludingNaN(new double[] { Double.POSITIVE_INFINITY }, new double[] { Double.NEGATIVE_INFINITY })); [EOL]     Assert.assertFalse(MathArrays.equalsIncludingNaN(new double[] { 1d }, new double[] { FastMath.nextAfter(FastMath.nextAfter(1d, 2d), 2d) })); [EOL] } <line_num>: 816,832
@Test [EOL] public void testNormalizeArray() { [EOL]     double[] testValues1 = new double[] { 1, 1, 2 }; [EOL]     TestUtils.assertEquals(new double[] { .25, .25, .5 }, MathArrays.normalizeArray(testValues1, 1), Double.MIN_VALUE); [EOL]     double[] testValues2 = new double[] { -1, -1, 1 }; [EOL]     TestUtils.assertEquals(new double[] { 1, 1, -1 }, MathArrays.normalizeArray(testValues2, 1), Double.MIN_VALUE); [EOL]     double[] testValues3 = new double[] { -1, -1, Double.NaN, 1, Double.NaN }; [EOL]     TestUtils.assertEquals(new double[] { 1, 1, Double.NaN, -1, Double.NaN }, MathArrays.normalizeArray(testValues3, 1), Double.MIN_VALUE); [EOL]     double[] zeroSum = new double[] { -1, 1 }; [EOL]     try { [EOL]         MathArrays.normalizeArray(zeroSum, 1); [EOL]         Assert.fail("expecting MathArithmeticException"); [EOL]     } catch (MathArithmeticException ex) { [EOL]     } [EOL]     double[] hasInf = new double[] { 1, 2, 1, Double.NEGATIVE_INFINITY }; [EOL]     try { [EOL]         MathArrays.normalizeArray(hasInf, 1); [EOL]         Assert.fail("expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         MathArrays.normalizeArray(testValues1, Double.POSITIVE_INFINITY); [EOL]         Assert.fail("expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         MathArrays.normalizeArray(testValues1, Double.NaN); [EOL]         Assert.fail("expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 834,877
@Test [EOL] public void testConvolve() { [EOL]     double[] x1 = { 1.2, -1.8, 1.4 }; [EOL]     double[] h1 = { 1, 0.8, 0.5, 0.3 }; [EOL]     double[] y1 = { 1.2, -0.84, 0.56, 0.58, 0.16, 0.42 }; [EOL]     double tolerance = 1e-13; [EOL]     double[] yActual = MathArrays.convolve(x1, h1); [EOL]     Assert.assertArrayEquals(y1, yActual, tolerance); [EOL]     double[] x2 = { 1, 2, 3 }; [EOL]     double[] h2 = { 0, 1, 0.5 }; [EOL]     double[] y2 = { 0, 1, 2.5, 4, 1.5 }; [EOL]     yActual = MathArrays.convolve(x2, h2); [EOL]     Assert.assertArrayEquals(y2, yActual, tolerance); [EOL]     try { [EOL]         MathArrays.convolve(new double[] { 1, 2 }, null); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (NullArgumentException e) { [EOL]     } [EOL]     try { [EOL]         MathArrays.convolve(null, new double[] { 1, 2 }); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (NullArgumentException e) { [EOL]     } [EOL]     try { [EOL]         MathArrays.convolve(new double[] { 1, 2 }, new double[] {}); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (NoDataException e) { [EOL]     } [EOL]     try { [EOL]         MathArrays.convolve(new double[] {}, new double[] { 1, 2 }); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (NoDataException e) { [EOL]     } [EOL]     try { [EOL]         MathArrays.convolve(new double[] {}, new double[] {}); [EOL]         Assert.fail("an exception should have been thrown"); [EOL]     } catch (NoDataException e) { [EOL]     } [EOL] } <line_num>: 879,935
@Test [EOL] public void testShuffleTail() { [EOL]     final int[] orig = new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; [EOL]     final int[] list = orig.clone(); [EOL]     final int start = 4; [EOL]     MathArrays.shuffle(list, start, MathArrays.Position.TAIL, new Well1024a(7654321L)); [EOL]     for (int i = 0; i < start; i++) { [EOL]         Assert.assertEquals(orig[i], list[i]); [EOL]     } [EOL]     boolean ok = false; [EOL]     for (int i = start; i < orig.length - 1; i++) { [EOL]         if (orig[i] != list[i]) { [EOL]             ok = true; [EOL]             break; [EOL]         } [EOL]     } [EOL]     Assert.assertTrue(ok); [EOL] } <line_num>: 937,958
@Test [EOL] public void testShuffleHead() { [EOL]     final int[] orig = new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; [EOL]     final int[] list = orig.clone(); [EOL]     final int start = 4; [EOL]     MathArrays.shuffle(list, start, MathArrays.Position.HEAD, new Well1024a(1234567L)); [EOL]     for (int i = start + 1; i < orig.length; i++) { [EOL]         Assert.assertEquals(orig[i], list[i]); [EOL]     } [EOL]     boolean ok = false; [EOL]     for (int i = 0; i <= start; i++) { [EOL]         if (orig[i] != list[i]) { [EOL]             ok = true; [EOL]             break; [EOL]         } [EOL]     } [EOL]     Assert.assertTrue(ok); [EOL] } <line_num>: 960,981
