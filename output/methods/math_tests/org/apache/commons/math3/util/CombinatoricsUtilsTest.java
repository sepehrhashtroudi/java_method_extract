@Test [EOL] public void test0Choose0() { [EOL]     Assert.assertEquals(CombinatoricsUtils.binomialCoefficientDouble(0, 0), 1d, 0); [EOL]     Assert.assertEquals(CombinatoricsUtils.binomialCoefficientLog(0, 0), 0d, 0); [EOL]     Assert.assertEquals(CombinatoricsUtils.binomialCoefficient(0, 0), 1); [EOL] } <line_num>: 43,48
@Test [EOL] public void testBinomialCoefficient() { [EOL]     long[] bcoef5 = { 1, 5, 10, 10, 5, 1 }; [EOL]     long[] bcoef6 = { 1, 6, 15, 20, 15, 6, 1 }; [EOL]     for (int i = 0; i < 6; i++) { [EOL]         Assert.assertEquals("5 choose " + i, bcoef5[i], CombinatoricsUtils.binomialCoefficient(5, i)); [EOL]     } [EOL]     for (int i = 0; i < 7; i++) { [EOL]         Assert.assertEquals("6 choose " + i, bcoef6[i], CombinatoricsUtils.binomialCoefficient(6, i)); [EOL]     } [EOL]     for (int n = 1; n < 10; n++) { [EOL]         for (int k = 0; k <= n; k++) { [EOL]             Assert.assertEquals(n + " choose " + k, binomialCoefficient(n, k), CombinatoricsUtils.binomialCoefficient(n, k)); [EOL]             Assert.assertEquals(n + " choose " + k, binomialCoefficient(n, k), CombinatoricsUtils.binomialCoefficientDouble(n, k), Double.MIN_VALUE); [EOL]             Assert.assertEquals(n + " choose " + k, FastMath.log(binomialCoefficient(n, k)), CombinatoricsUtils.binomialCoefficientLog(n, k), 10E-12); [EOL]         } [EOL]     } [EOL]     int[] n = { 34, 66, 100, 1500, 1500 }; [EOL]     int[] k = { 17, 33, 10, 1500 - 4, 4 }; [EOL]     for (int i = 0; i < n.length; i++) { [EOL]         long expected = binomialCoefficient(n[i], k[i]); [EOL]         Assert.assertEquals(n[i] + " choose " + k[i], expected, CombinatoricsUtils.binomialCoefficient(n[i], k[i])); [EOL]         Assert.assertEquals(n[i] + " choose " + k[i], expected, CombinatoricsUtils.binomialCoefficientDouble(n[i], k[i]), 0.0); [EOL]         Assert.assertEquals("log(" + n[i] + " choose " + k[i] + ")", FastMath.log(expected), CombinatoricsUtils.binomialCoefficientLog(n[i], k[i]), 0.0); [EOL]     } [EOL] } <line_num>: 50,93
@Test [EOL] public void testBinomialCoefficientFail() { [EOL]     try { [EOL]         CombinatoricsUtils.binomialCoefficient(4, 5); [EOL]         Assert.fail("expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         CombinatoricsUtils.binomialCoefficientDouble(4, 5); [EOL]         Assert.fail("expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         CombinatoricsUtils.binomialCoefficientLog(4, 5); [EOL]         Assert.fail("expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         CombinatoricsUtils.binomialCoefficient(-1, -2); [EOL]         Assert.fail("expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         CombinatoricsUtils.binomialCoefficientDouble(-1, -2); [EOL]         Assert.fail("expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         CombinatoricsUtils.binomialCoefficientLog(-1, -2); [EOL]         Assert.fail("expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         CombinatoricsUtils.binomialCoefficient(67, 30); [EOL]         Assert.fail("expecting MathArithmeticException"); [EOL]     } catch (MathArithmeticException ex) { [EOL]     } [EOL]     try { [EOL]         CombinatoricsUtils.binomialCoefficient(67, 34); [EOL]         Assert.fail("expecting MathArithmeticException"); [EOL]     } catch (MathArithmeticException ex) { [EOL]     } [EOL]     double x = CombinatoricsUtils.binomialCoefficientDouble(1030, 515); [EOL]     Assert.assertTrue("expecting infinite binomial coefficient", Double.isInfinite(x)); [EOL] } <line_num>: 95,152
@Test [EOL] public void testBinomialCoefficientLarge() throws Exception { [EOL]     for (int n = 0; n <= 200; n++) { [EOL]         for (int k = 0; k <= n; k++) { [EOL]             long ourResult = -1; [EOL]             long exactResult = -1; [EOL]             boolean shouldThrow = false; [EOL]             boolean didThrow = false; [EOL]             try { [EOL]                 ourResult = CombinatoricsUtils.binomialCoefficient(n, k); [EOL]             } catch (MathArithmeticException ex) { [EOL]                 didThrow = true; [EOL]             } [EOL]             try { [EOL]                 exactResult = binomialCoefficient(n, k); [EOL]             } catch (MathArithmeticException ex) { [EOL]                 shouldThrow = true; [EOL]             } [EOL]             Assert.assertEquals(n + " choose " + k, exactResult, ourResult); [EOL]             Assert.assertEquals(n + " choose " + k, shouldThrow, didThrow); [EOL]             Assert.assertTrue(n + " choose " + k, (n > 66 || !didThrow)); [EOL]             if (!shouldThrow && exactResult > 1) { [EOL]                 Assert.assertEquals(n + " choose " + k, 1., CombinatoricsUtils.binomialCoefficientDouble(n, k) / exactResult, 1e-10); [EOL]                 Assert.assertEquals(n + " choose " + k, 1, CombinatoricsUtils.binomialCoefficientLog(n, k) / FastMath.log(exactResult), 1e-10); [EOL]             } [EOL]         } [EOL]     } [EOL]     long ourResult = CombinatoricsUtils.binomialCoefficient(300, 3); [EOL]     long exactResult = binomialCoefficient(300, 3); [EOL]     Assert.assertEquals(exactResult, ourResult); [EOL]     ourResult = CombinatoricsUtils.binomialCoefficient(700, 697); [EOL]     exactResult = binomialCoefficient(700, 697); [EOL]     Assert.assertEquals(exactResult, ourResult); [EOL]     try { [EOL]         CombinatoricsUtils.binomialCoefficient(700, 300); [EOL]         Assert.fail("Expecting MathArithmeticException"); [EOL]     } catch (MathArithmeticException ex) { [EOL]     } [EOL]     int n = 10000; [EOL]     ourResult = CombinatoricsUtils.binomialCoefficient(n, 3); [EOL]     exactResult = binomialCoefficient(n, 3); [EOL]     Assert.assertEquals(exactResult, ourResult); [EOL]     Assert.assertEquals(1, CombinatoricsUtils.binomialCoefficientDouble(n, 3) / exactResult, 1e-10); [EOL]     Assert.assertEquals(1, CombinatoricsUtils.binomialCoefficientLog(n, 3) / FastMath.log(exactResult), 1e-10); [EOL] } <line_num>: 158,213
@Test [EOL] public void testFactorial() { [EOL]     for (int i = 1; i < 21; i++) { [EOL]         Assert.assertEquals(i + "! ", factorial(i), CombinatoricsUtils.factorial(i)); [EOL]         Assert.assertEquals(i + "! ", factorial(i), CombinatoricsUtils.factorialDouble(i), Double.MIN_VALUE); [EOL]         Assert.assertEquals(i + "! ", FastMath.log(factorial(i)), CombinatoricsUtils.factorialLog(i), 10E-12); [EOL]     } [EOL]     Assert.assertEquals("0", 1, CombinatoricsUtils.factorial(0)); [EOL]     Assert.assertEquals("0", 1.0d, CombinatoricsUtils.factorialDouble(0), 1E-14); [EOL]     Assert.assertEquals("0", 0.0d, CombinatoricsUtils.factorialLog(0), 1E-14); [EOL] } <line_num>: 215,226
@Test [EOL] public void testFactorialFail() { [EOL]     try { [EOL]         CombinatoricsUtils.factorial(-1); [EOL]         Assert.fail("expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         CombinatoricsUtils.factorialDouble(-1); [EOL]         Assert.fail("expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         CombinatoricsUtils.factorialLog(-1); [EOL]         Assert.fail("expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         CombinatoricsUtils.factorial(21); [EOL]         Assert.fail("expecting MathArithmeticException"); [EOL]     } catch (MathArithmeticException ex) { [EOL]     } [EOL]     Assert.assertTrue("expecting infinite factorial value", Double.isInfinite(CombinatoricsUtils.factorialDouble(171))); [EOL] } <line_num>: 228,255
@Test [EOL] public void testStirlingS2() { [EOL]     Assert.assertEquals(1, CombinatoricsUtils.stirlingS2(0, 0)); [EOL]     for (int n = 1; n < 30; ++n) { [EOL]         Assert.assertEquals(0, CombinatoricsUtils.stirlingS2(n, 0)); [EOL]         Assert.assertEquals(1, CombinatoricsUtils.stirlingS2(n, 1)); [EOL]         if (n > 2) { [EOL]             Assert.assertEquals((1l << (n - 1)) - 1l, CombinatoricsUtils.stirlingS2(n, 2)); [EOL]             Assert.assertEquals(CombinatoricsUtils.binomialCoefficient(n, 2), CombinatoricsUtils.stirlingS2(n, n - 1)); [EOL]         } [EOL]         Assert.assertEquals(1, CombinatoricsUtils.stirlingS2(n, n)); [EOL]     } [EOL]     Assert.assertEquals(536870911l, CombinatoricsUtils.stirlingS2(30, 2)); [EOL]     Assert.assertEquals(576460752303423487l, CombinatoricsUtils.stirlingS2(60, 2)); [EOL]     Assert.assertEquals(25, CombinatoricsUtils.stirlingS2(5, 3)); [EOL]     Assert.assertEquals(90, CombinatoricsUtils.stirlingS2(6, 3)); [EOL]     Assert.assertEquals(65, CombinatoricsUtils.stirlingS2(6, 4)); [EOL]     Assert.assertEquals(301, CombinatoricsUtils.stirlingS2(7, 3)); [EOL]     Assert.assertEquals(350, CombinatoricsUtils.stirlingS2(7, 4)); [EOL]     Assert.assertEquals(140, CombinatoricsUtils.stirlingS2(7, 5)); [EOL]     Assert.assertEquals(966, CombinatoricsUtils.stirlingS2(8, 3)); [EOL]     Assert.assertEquals(1701, CombinatoricsUtils.stirlingS2(8, 4)); [EOL]     Assert.assertEquals(1050, CombinatoricsUtils.stirlingS2(8, 5)); [EOL]     Assert.assertEquals(266, CombinatoricsUtils.stirlingS2(8, 6)); [EOL]     Assert.assertEquals(3025, CombinatoricsUtils.stirlingS2(9, 3)); [EOL]     Assert.assertEquals(7770, CombinatoricsUtils.stirlingS2(9, 4)); [EOL]     Assert.assertEquals(6951, CombinatoricsUtils.stirlingS2(9, 5)); [EOL]     Assert.assertEquals(2646, CombinatoricsUtils.stirlingS2(9, 6)); [EOL]     Assert.assertEquals(462, CombinatoricsUtils.stirlingS2(9, 7)); [EOL]     Assert.assertEquals(9330, CombinatoricsUtils.stirlingS2(10, 3)); [EOL]     Assert.assertEquals(34105, CombinatoricsUtils.stirlingS2(10, 4)); [EOL]     Assert.assertEquals(42525, CombinatoricsUtils.stirlingS2(10, 5)); [EOL]     Assert.assertEquals(22827, CombinatoricsUtils.stirlingS2(10, 6)); [EOL]     Assert.assertEquals(5880, CombinatoricsUtils.stirlingS2(10, 7)); [EOL]     Assert.assertEquals(750, CombinatoricsUtils.stirlingS2(10, 8)); [EOL] } <line_num>: 257,297
@Test(expected = NotPositiveException.class) [EOL] public void testStirlingS2NegativeN() { [EOL]     CombinatoricsUtils.stirlingS2(3, -1); [EOL] } <line_num>: 299,302
@Test(expected = NumberIsTooLargeException.class) [EOL] public void testStirlingS2LargeK() { [EOL]     CombinatoricsUtils.stirlingS2(3, 4); [EOL] } <line_num>: 304,307
@Test(expected = MathArithmeticException.class) [EOL] public void testStirlingS2Overflow() { [EOL]     CombinatoricsUtils.stirlingS2(26, 9); [EOL] } <line_num>: 309,312
private long binomialCoefficient(int n, int k) throws MathArithmeticException { [EOL]     if (binomialCache.size() > n) { [EOL]         Long cachedResult = binomialCache.get(n).get(Integer.valueOf(k)); [EOL]         if (cachedResult != null) { [EOL]             return cachedResult.longValue(); [EOL]         } [EOL]     } [EOL]     long result = -1; [EOL]     if ((n == k) || (k == 0)) { [EOL]         result = 1; [EOL]     } else if ((k == 1) || (k == n - 1)) { [EOL]         result = n; [EOL]     } else { [EOL]         if (k < n - 100) { [EOL]             binomialCoefficient(n - 100, k); [EOL]         } [EOL]         if (k > 100) { [EOL]             binomialCoefficient(n - 100, k - 100); [EOL]         } [EOL]         result = ArithmeticUtils.addAndCheck(binomialCoefficient(n - 1, k - 1), binomialCoefficient(n - 1, k)); [EOL]     } [EOL]     if (result == -1) { [EOL]         throw new MathArithmeticException(); [EOL]     } [EOL]     for (int i = binomialCache.size(); i < n + 1; i++) { [EOL]         binomialCache.add(new HashMap<Integer, Long>()); [EOL]     } [EOL]     binomialCache.get(n).put(Integer.valueOf(k), Long.valueOf(result)); [EOL]     return result; [EOL] } <line_num>: 317,348
private long factorial(int n) { [EOL]     long result = 1; [EOL]     for (int i = 2; i <= n; i++) { [EOL]         result *= i; [EOL]     } [EOL]     return result; [EOL] } <line_num>: 353,359
@Test [EOL] public void testCombinationsIterator() { [EOL]     Iterator<int[]> combinationsIterator = CombinatoricsUtils.combinationsIterator(5, 3); [EOL]     checkIterator(combinationsIterator, 5, 3); [EOL]     combinationsIterator = CombinatoricsUtils.combinationsIterator(6, 4); [EOL]     checkIterator(combinationsIterator, 6, 4); [EOL]     combinationsIterator = CombinatoricsUtils.combinationsIterator(8, 2); [EOL]     checkIterator(combinationsIterator, 8, 2); [EOL]     combinationsIterator = CombinatoricsUtils.combinationsIterator(6, 1); [EOL]     checkIterator(combinationsIterator, 6, 1); [EOL]     combinationsIterator = CombinatoricsUtils.combinationsIterator(3, 3); [EOL]     checkIterator(combinationsIterator, 3, 3); [EOL]     combinationsIterator = CombinatoricsUtils.combinationsIterator(1, 1); [EOL]     checkIterator(combinationsIterator, 1, 1); [EOL]     combinationsIterator = CombinatoricsUtils.combinationsIterator(1, 1); [EOL]     checkIterator(combinationsIterator, 1, 1); [EOL]     combinationsIterator = CombinatoricsUtils.combinationsIterator(1, 0); [EOL]     checkIterator(combinationsIterator, 1, 0); [EOL]     combinationsIterator = CombinatoricsUtils.combinationsIterator(0, 0); [EOL]     checkIterator(combinationsIterator, 0, 0); [EOL]     combinationsIterator = CombinatoricsUtils.combinationsIterator(4, 2); [EOL]     checkIterator(combinationsIterator, 4, 2); [EOL]     combinationsIterator = CombinatoricsUtils.combinationsIterator(123, 2); [EOL]     checkIterator(combinationsIterator, 123, 2); [EOL] } <line_num>: 361,385
private void checkIterator(Iterator<int[]> iterator, int n, int k) { [EOL]     long lastLex = -1; [EOL]     long length = 0; [EOL]     while (iterator.hasNext()) { [EOL]         final int[] iterate = iterator.next(); [EOL]         Assert.assertEquals(k, iterate.length); [EOL]         final long curLex = lexNorm(iterate, n); [EOL]         Assert.assertTrue(curLex > lastLex); [EOL]         lastLex = curLex; [EOL]         length++; [EOL]         for (int i = 1; i < iterate.length; i++) { [EOL]             Assert.assertTrue(iterate[i] > iterate[i - 1]); [EOL]         } [EOL]     } [EOL]     Assert.assertEquals(CombinatoricsUtils.binomialCoefficient(n, k), length); [EOL] } <line_num>: 396,411
@Test [EOL] public void testCombinationsIteratorFail() { [EOL]     try { [EOL]         CombinatoricsUtils.combinationsIterator(4, 5); [EOL]         Assert.fail("expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL]     try { [EOL]         CombinatoricsUtils.combinationsIterator(-1, -2); [EOL]         Assert.fail("expecting MathIllegalArgumentException"); [EOL]     } catch (MathIllegalArgumentException ex) { [EOL]     } [EOL] } <line_num>: 413,428
private long lexNorm(int[] iterate, int n) { [EOL]     long ret = 0; [EOL]     for (int i = iterate.length - 1; i >= 0; i--) { [EOL]         ret += iterate[i] * ArithmeticUtils.pow(n, (long) i); [EOL]     } [EOL]     return ret; [EOL] } <line_num>: 438,444
