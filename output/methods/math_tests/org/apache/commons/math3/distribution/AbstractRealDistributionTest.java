public double cumulativeProbability(final double x) { [EOL]     if ((x < x0) || (x > x3)) { [EOL]         throw new OutOfRangeException(x, x0, x3); [EOL]     } [EOL]     if (x <= x1) { [EOL]         return p12 * (x - x0) / (x1 - x0); [EOL]     } else if (x <= x2) { [EOL]         return p12; [EOL]     } else if (x <= x3) { [EOL]         return p12 + (1.0 - p12) * (x - x2) / (x3 - x2); [EOL]     } [EOL]     return 0.0; [EOL] } <line_num>: 40,52
public double density(final double x) { [EOL]     if ((x < x0) || (x > x3)) { [EOL]         throw new OutOfRangeException(x, x0, x3); [EOL]     } [EOL]     if (x <= x1) { [EOL]         return p12 / (x1 - x0); [EOL]     } else if (x <= x2) { [EOL]         return 0.0; [EOL]     } else if (x <= x3) { [EOL]         return (1.0 - p12) / (x3 - x2); [EOL]     } [EOL]     return 0.0; [EOL] } <line_num>: 54,66
public double getNumericalMean() { [EOL]     return ((x0 + x1) * p12 + (x2 + x3) * (1.0 - p12)) / 2.0; [EOL] } <line_num>: 68,70
public double getNumericalVariance() { [EOL]     final double meanX = getNumericalMean(); [EOL]     final double meanX2; [EOL]     meanX2 = ((x0 * x0 + x0 * x1 + x1 * x1) * p12 + (x2 * x2 + x2 * x3 + x3 * x3) * (1.0 - p12)) / 3.0; [EOL]     return meanX2 - meanX * meanX; [EOL] } <line_num>: 72,79
public double getSupportLowerBound() { [EOL]     return x0; [EOL] } <line_num>: 81,83
public double getSupportUpperBound() { [EOL]     return x3; [EOL] } <line_num>: 85,87
public boolean isSupportConnected() { [EOL]     return false; [EOL] } <line_num>: 89,91
public boolean isSupportLowerBoundInclusive() { [EOL]     return true; [EOL] } <line_num>: 93,95
public boolean isSupportUpperBoundInclusive() { [EOL]     return true; [EOL] } <line_num>: 97,99
@Override [EOL] public double probability(final double x) { [EOL]     throw new UnsupportedOperationException(); [EOL] } <line_num>: 101,104
@Test [EOL] public void testContinuous() { [EOL]     final double x0 = 0.0; [EOL]     final double x1 = 1.0; [EOL]     final double x2 = 2.0; [EOL]     final double x3 = 3.0; [EOL]     final double p12 = 0.5; [EOL]     final AbstractRealDistribution distribution; [EOL]     distribution = new AbstractRealDistribution(null) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         public double cumulativeProbability(final double x) { [EOL]             if ((x < x0) || (x > x3)) { [EOL]                 throw new OutOfRangeException(x, x0, x3); [EOL]             } [EOL]             if (x <= x1) { [EOL]                 return p12 * (x - x0) / (x1 - x0); [EOL]             } else if (x <= x2) { [EOL]                 return p12; [EOL]             } else if (x <= x3) { [EOL]                 return p12 + (1.0 - p12) * (x - x2) / (x3 - x2); [EOL]             } [EOL]             return 0.0; [EOL]         } [EOL]  [EOL]         public double density(final double x) { [EOL]             if ((x < x0) || (x > x3)) { [EOL]                 throw new OutOfRangeException(x, x0, x3); [EOL]             } [EOL]             if (x <= x1) { [EOL]                 return p12 / (x1 - x0); [EOL]             } else if (x <= x2) { [EOL]                 return 0.0; [EOL]             } else if (x <= x3) { [EOL]                 return (1.0 - p12) / (x3 - x2); [EOL]             } [EOL]             return 0.0; [EOL]         } [EOL]  [EOL]         public double getNumericalMean() { [EOL]             return ((x0 + x1) * p12 + (x2 + x3) * (1.0 - p12)) / 2.0; [EOL]         } [EOL]  [EOL]         public double getNumericalVariance() { [EOL]             final double meanX = getNumericalMean(); [EOL]             final double meanX2; [EOL]             meanX2 = ((x0 * x0 + x0 * x1 + x1 * x1) * p12 + (x2 * x2 + x2 * x3 + x3 * x3) * (1.0 - p12)) / 3.0; [EOL]             return meanX2 - meanX * meanX; [EOL]         } [EOL]  [EOL]         public double getSupportLowerBound() { [EOL]             return x0; [EOL]         } [EOL]  [EOL]         public double getSupportUpperBound() { [EOL]             return x3; [EOL]         } [EOL]  [EOL]         public boolean isSupportConnected() { [EOL]             return false; [EOL]         } [EOL]  [EOL]         public boolean isSupportLowerBoundInclusive() { [EOL]             return true; [EOL]         } [EOL]  [EOL]         public boolean isSupportUpperBoundInclusive() { [EOL]             return true; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public double probability(final double x) { [EOL]             throw new UnsupportedOperationException(); [EOL]         } [EOL]     }; [EOL]     final double expected = x1; [EOL]     final double actual = distribution.inverseCumulativeProbability(p12); [EOL]     Assert.assertEquals("", expected, actual, distribution.getSolverAbsoluteAccuracy()); [EOL] } <line_num>: 29,110
public double cumulativeProbability(final double x) { [EOL]     if ((x < x0) || (x > x4)) { [EOL]         throw new OutOfRangeException(x, x0, x4); [EOL]     } [EOL]     if (x <= x1) { [EOL]         return p12 * (x - x0) / (x1 - x0); [EOL]     } else if (x <= x2) { [EOL]         return p12; [EOL]     } else if (x <= x3) { [EOL]         return p23; [EOL]     } else { [EOL]         return (1.0 - p23) * (x - x3) / (x4 - x3) + p23; [EOL]     } [EOL] } <line_num>: 125,138
public double density(final double x) { [EOL]     if ((x < x0) || (x > x4)) { [EOL]         throw new OutOfRangeException(x, x0, x4); [EOL]     } [EOL]     if (x <= x1) { [EOL]         return p12 / (x1 - x0); [EOL]     } else if (x <= x2) { [EOL]         return 0.0; [EOL]     } else if (x <= x3) { [EOL]         return 0.0; [EOL]     } else { [EOL]         return (1.0 - p23) / (x4 - x3); [EOL]     } [EOL] } <line_num>: 140,153
public double value(final double x) { [EOL]     return x * density(x); [EOL] } <line_num>: 158,160
public double getNumericalMean() { [EOL]     final UnivariateFunction f = new UnivariateFunction() { [EOL]  [EOL]         public double value(final double x) { [EOL]             return x * density(x); [EOL]         } [EOL]     }; [EOL]     final UnivariateIntegrator integrator = new RombergIntegrator(); [EOL]     return integrator.integrate(Integer.MAX_VALUE, f, x0, x4); [EOL] } <line_num>: 155,164
public double value(final double x) { [EOL]     return x * x * density(x); [EOL] } <line_num>: 170,172
public double getNumericalVariance() { [EOL]     final double meanX = getNumericalMean(); [EOL]     final UnivariateFunction f = new UnivariateFunction() { [EOL]  [EOL]         public double value(final double x) { [EOL]             return x * x * density(x); [EOL]         } [EOL]     }; [EOL]     final UnivariateIntegrator integrator = new RombergIntegrator(); [EOL]     final double meanX2 = integrator.integrate(Integer.MAX_VALUE, f, x0, x4); [EOL]     return meanX2 - meanX * meanX; [EOL] } <line_num>: 166,178
public double getSupportLowerBound() { [EOL]     return x0; [EOL] } <line_num>: 180,182
public double getSupportUpperBound() { [EOL]     return x4; [EOL] } <line_num>: 184,186
public boolean isSupportConnected() { [EOL]     return false; [EOL] } <line_num>: 188,190
public boolean isSupportLowerBoundInclusive() { [EOL]     return true; [EOL] } <line_num>: 192,194
public boolean isSupportUpperBoundInclusive() { [EOL]     return true; [EOL] } <line_num>: 196,198
@Override [EOL] public double probability(final double x) { [EOL]     throw new UnsupportedOperationException(); [EOL] } <line_num>: 200,203
@Test [EOL] public void testDiscontinuous() { [EOL]     final double x0 = 0.0; [EOL]     final double x1 = 0.25; [EOL]     final double x2 = 0.5; [EOL]     final double x3 = 0.75; [EOL]     final double x4 = 1.0; [EOL]     final double p12 = 1.0 / 3.0; [EOL]     final double p23 = 2.0 / 3.0; [EOL]     final AbstractRealDistribution distribution; [EOL]     distribution = new AbstractRealDistribution(null) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         public double cumulativeProbability(final double x) { [EOL]             if ((x < x0) || (x > x4)) { [EOL]                 throw new OutOfRangeException(x, x0, x4); [EOL]             } [EOL]             if (x <= x1) { [EOL]                 return p12 * (x - x0) / (x1 - x0); [EOL]             } else if (x <= x2) { [EOL]                 return p12; [EOL]             } else if (x <= x3) { [EOL]                 return p23; [EOL]             } else { [EOL]                 return (1.0 - p23) * (x - x3) / (x4 - x3) + p23; [EOL]             } [EOL]         } [EOL]  [EOL]         public double density(final double x) { [EOL]             if ((x < x0) || (x > x4)) { [EOL]                 throw new OutOfRangeException(x, x0, x4); [EOL]             } [EOL]             if (x <= x1) { [EOL]                 return p12 / (x1 - x0); [EOL]             } else if (x <= x2) { [EOL]                 return 0.0; [EOL]             } else if (x <= x3) { [EOL]                 return 0.0; [EOL]             } else { [EOL]                 return (1.0 - p23) / (x4 - x3); [EOL]             } [EOL]         } [EOL]  [EOL]         public double getNumericalMean() { [EOL]             final UnivariateFunction f = new UnivariateFunction() { [EOL]  [EOL]                 public double value(final double x) { [EOL]                     return x * density(x); [EOL]                 } [EOL]             }; [EOL]             final UnivariateIntegrator integrator = new RombergIntegrator(); [EOL]             return integrator.integrate(Integer.MAX_VALUE, f, x0, x4); [EOL]         } [EOL]  [EOL]         public double getNumericalVariance() { [EOL]             final double meanX = getNumericalMean(); [EOL]             final UnivariateFunction f = new UnivariateFunction() { [EOL]  [EOL]                 public double value(final double x) { [EOL]                     return x * x * density(x); [EOL]                 } [EOL]             }; [EOL]             final UnivariateIntegrator integrator = new RombergIntegrator(); [EOL]             final double meanX2 = integrator.integrate(Integer.MAX_VALUE, f, x0, x4); [EOL]             return meanX2 - meanX * meanX; [EOL]         } [EOL]  [EOL]         public double getSupportLowerBound() { [EOL]             return x0; [EOL]         } [EOL]  [EOL]         public double getSupportUpperBound() { [EOL]             return x4; [EOL]         } [EOL]  [EOL]         public boolean isSupportConnected() { [EOL]             return false; [EOL]         } [EOL]  [EOL]         public boolean isSupportLowerBoundInclusive() { [EOL]             return true; [EOL]         } [EOL]  [EOL]         public boolean isSupportUpperBoundInclusive() { [EOL]             return true; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public double probability(final double x) { [EOL]             throw new UnsupportedOperationException(); [EOL]         } [EOL]     }; [EOL]     final double expected = x2; [EOL]     final double actual = distribution.inverseCumulativeProbability(p23); [EOL]     Assert.assertEquals("", expected, actual, distribution.getSolverAbsoluteAccuracy()); [EOL] } <line_num>: 112,210
