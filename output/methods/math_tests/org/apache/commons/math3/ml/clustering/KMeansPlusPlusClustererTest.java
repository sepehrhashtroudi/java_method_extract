@Before [EOL] public void setUp() { [EOL]     random = new JDKRandomGenerator(); [EOL]     random.setSeed(1746432956321l); [EOL] } <line_num>: 37,41
@Test [EOL] public void testPerformClusterAnalysisDegenerate() { [EOL]     KMeansPlusPlusClusterer<DoublePoint> transformer = new KMeansPlusPlusClusterer<DoublePoint>(1, 1); [EOL]     DoublePoint[] points = new DoublePoint[] { new DoublePoint(new int[] { 1959, 325100 }), new DoublePoint(new int[] { 1960, 373200 }) }; [EOL]     List<? extends Cluster<DoublePoint>> clusters = transformer.cluster(Arrays.asList(points)); [EOL]     Assert.assertEquals(1, clusters.size()); [EOL]     Assert.assertEquals(2, (clusters.get(0).getPoints().size())); [EOL]     DoublePoint pt1 = new DoublePoint(new int[] { 1959, 325100 }); [EOL]     DoublePoint pt2 = new DoublePoint(new int[] { 1960, 373200 }); [EOL]     Assert.assertTrue(clusters.get(0).getPoints().contains(pt1)); [EOL]     Assert.assertTrue(clusters.get(0).getPoints().contains(pt2)); [EOL] } <line_num>: 48,64
@Test [EOL] public void testCertainSpace() { [EOL]     KMeansPlusPlusClusterer.EmptyClusterStrategy[] strategies = { KMeansPlusPlusClusterer.EmptyClusterStrategy.LARGEST_VARIANCE, KMeansPlusPlusClusterer.EmptyClusterStrategy.LARGEST_POINTS_NUMBER, KMeansPlusPlusClusterer.EmptyClusterStrategy.FARTHEST_POINT }; [EOL]     for (KMeansPlusPlusClusterer.EmptyClusterStrategy strategy : strategies) { [EOL]         int numberOfVariables = 27; [EOL]         int position1 = 1; [EOL]         int position2 = position1 + numberOfVariables; [EOL]         int position3 = position2 + numberOfVariables; [EOL]         int position4 = position3 + numberOfVariables; [EOL]         int multiplier = 1000000; [EOL]         DoublePoint[] breakingPoints = new DoublePoint[numberOfVariables]; [EOL]         for (int i = 0; i < numberOfVariables; i++) { [EOL]             int[] points = { position1, position2, position3, position4 }; [EOL]             for (int j = 0; j < points.length; j++) { [EOL]                 points[j] = points[j] * multiplier; [EOL]             } [EOL]             DoublePoint DoublePoint = new DoublePoint(points); [EOL]             breakingPoints[i] = DoublePoint; [EOL]             position1 = position1 + numberOfVariables; [EOL]             position2 = position2 + numberOfVariables; [EOL]             position3 = position3 + numberOfVariables; [EOL]             position4 = position4 + numberOfVariables; [EOL]         } [EOL]         for (int n = 2; n < 27; ++n) { [EOL]             KMeansPlusPlusClusterer<DoublePoint> transformer = new KMeansPlusPlusClusterer<DoublePoint>(n, 100, new EuclideanDistance(), random, strategy); [EOL]             List<? extends Cluster<DoublePoint>> clusters = transformer.cluster(Arrays.asList(breakingPoints)); [EOL]             Assert.assertEquals(n, clusters.size()); [EOL]             int sum = 0; [EOL]             for (Cluster<DoublePoint> cluster : clusters) { [EOL]                 sum += cluster.getPoints().size(); [EOL]             } [EOL]             Assert.assertEquals(numberOfVariables, sum); [EOL]         } [EOL]     } [EOL] } <line_num>: 66,115
@Override [EOL] public double compute(double[] a, double[] b) { [EOL]     return super.compute(a, b) * 0.001; [EOL] } <line_num>: 124,127
@Test [EOL] public void testSmallDistances() { [EOL]     int[] repeatedArray = { 0 }; [EOL]     int[] uniqueArray = { 1 }; [EOL]     DoublePoint repeatedPoint = new DoublePoint(repeatedArray); [EOL]     DoublePoint uniquePoint = new DoublePoint(uniqueArray); [EOL]     Collection<DoublePoint> points = new ArrayList<DoublePoint>(); [EOL]     final int NUM_REPEATED_POINTS = 10 * 1000; [EOL]     for (int i = 0; i < NUM_REPEATED_POINTS; ++i) { [EOL]         points.add(repeatedPoint); [EOL]     } [EOL]     points.add(uniquePoint); [EOL]     final long RANDOM_SEED = 0; [EOL]     final int NUM_CLUSTERS = 2; [EOL]     final int NUM_ITERATIONS = 0; [EOL]     random.setSeed(RANDOM_SEED); [EOL]     KMeansPlusPlusClusterer<DoublePoint> clusterer = new KMeansPlusPlusClusterer<DoublePoint>(NUM_CLUSTERS, NUM_ITERATIONS, new CloseDistance(), random); [EOL]     List<CentroidCluster<DoublePoint>> clusters = clusterer.cluster(points); [EOL]     boolean uniquePointIsCenter = false; [EOL]     for (CentroidCluster<DoublePoint> cluster : clusters) { [EOL]         if (cluster.getCenter().equals(uniquePoint)) { [EOL]             uniquePointIsCenter = true; [EOL]         } [EOL]     } [EOL]     Assert.assertTrue(uniquePointIsCenter); [EOL] } <line_num>: 133,169
@Test(expected = NumberIsTooSmallException.class) [EOL] public void testPerformClusterAnalysisToManyClusters() { [EOL]     KMeansPlusPlusClusterer<DoublePoint> transformer = new KMeansPlusPlusClusterer<DoublePoint>(3, 1, new EuclideanDistance(), random); [EOL]     DoublePoint[] points = new DoublePoint[] { new DoublePoint(new int[] { 1959, 325100 }), new DoublePoint(new int[] { 1960, 373200 }) }; [EOL]     transformer.cluster(Arrays.asList(points)); [EOL] } <line_num>: 174,189
