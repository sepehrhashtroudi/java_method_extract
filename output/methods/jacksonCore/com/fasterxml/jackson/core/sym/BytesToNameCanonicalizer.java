private BytesToNameCanonicalizer(int hashSize, boolean intern, int seed) { [EOL]     _parent = null; [EOL]     _hashSeed = seed; [EOL]     _intern = intern; [EOL]     if (hashSize < MIN_HASH_SIZE) { [EOL]         hashSize = MIN_HASH_SIZE; [EOL]     } else { [EOL]         if ((hashSize & (hashSize - 1)) != 0) { [EOL]             int curr = MIN_HASH_SIZE; [EOL]             while (curr < hashSize) { [EOL]                 curr += curr; [EOL]             } [EOL]             hashSize = curr; [EOL]         } [EOL]     } [EOL]     _tableInfo = new AtomicReference<TableInfo>(initTableInfo(hashSize)); [EOL] } <line_num>: 239,260
private BytesToNameCanonicalizer(BytesToNameCanonicalizer parent, boolean intern, int seed, TableInfo state) { [EOL]     _parent = parent; [EOL]     _hashSeed = seed; [EOL]     _intern = intern; [EOL]     _tableInfo = null; [EOL]     _count = state.count; [EOL]     _mainHashMask = state.mainHashMask; [EOL]     _mainHash = state.mainHash; [EOL]     _mainNames = state.mainNames; [EOL]     _collList = state.collList; [EOL]     _collCount = state.collCount; [EOL]     _collEnd = state.collEnd; [EOL]     _longestCollisionList = state.longestCollisionList; [EOL]     _needRehash = false; [EOL]     _mainHashShared = true; [EOL]     _mainNamesShared = true; [EOL]     _collListShared = true; [EOL] } <line_num>: 265,288
public TableInfo(int count, int mainHashMask, int[] mainHash, Name[] mainNames, Bucket[] collList, int collCount, int collEnd, int longestCollisionList) { [EOL]     this.count = count; [EOL]     this.mainHashMask = mainHashMask; [EOL]     this.mainHash = mainHash; [EOL]     this.mainNames = mainNames; [EOL]     this.collList = collList; [EOL]     this.collCount = collCount; [EOL]     this.collEnd = collEnd; [EOL]     this.longestCollisionList = longestCollisionList; [EOL] } <line_num>: 1117,1128
public TableInfo(BytesToNameCanonicalizer src) { [EOL]     count = src._count; [EOL]     mainHashMask = src._mainHashMask; [EOL]     mainHash = src._mainHash; [EOL]     mainNames = src._mainNames; [EOL]     collList = src._collList; [EOL]     collCount = src._collCount; [EOL]     collEnd = src._collEnd; [EOL]     longestCollisionList = src._longestCollisionList; [EOL] } <line_num>: 1130,1140
Bucket(Name name, Bucket next) { [EOL]     _name = name; [EOL]     _next = next; [EOL]     _length = (next == null) ? 1 : next._length + 1; [EOL] } <line_num>: 1153,1158
private TableInfo initTableInfo(int hashSize) { [EOL]     return new TableInfo(0, hashSize - 1, new int[hashSize], new Name[hashSize], null, 0, 0, 0); [EOL] } <line_num>: 294,305
public static BytesToNameCanonicalizer createRoot() { [EOL]     long now = System.currentTimeMillis(); [EOL]     int seed = (((int) now) + ((int) (now >>> 32))) | 1; [EOL]     return createRoot(seed); [EOL] } <line_num>: 317,326
protected static BytesToNameCanonicalizer createRoot(int hashSeed) { [EOL]     return new BytesToNameCanonicalizer(DEFAULT_TABLE_SIZE, true, hashSeed); [EOL] } <line_num>: 332,334
public BytesToNameCanonicalizer makeChild(boolean canonicalize, boolean intern) { [EOL]     return new BytesToNameCanonicalizer(this, intern, _hashSeed, _tableInfo.get()); [EOL] } <line_num>: 343,347
public void release() { [EOL]     if (_parent != null && maybeDirty()) { [EOL]         _parent.mergeChild(new TableInfo(this)); [EOL]         _mainHashShared = true; [EOL]         _mainNamesShared = true; [EOL]         _collListShared = true; [EOL]     } [EOL] } <line_num>: 356,368
private void mergeChild(TableInfo childState) { [EOL]     final int childCount = childState.count; [EOL]     TableInfo currState = _tableInfo.get(); [EOL]     if (childCount <= currState.count) { [EOL]         return; [EOL]     } [EOL]     if (childCount > MAX_ENTRIES_FOR_REUSE || childState.longestCollisionList > MAX_COLL_CHAIN_FOR_REUSE) { [EOL]         childState = initTableInfo(DEFAULT_TABLE_SIZE); [EOL]     } [EOL]     _tableInfo.compareAndSet(currState, childState); [EOL] } <line_num>: 370,396
public int size() { [EOL]     if (_tableInfo != null) { [EOL]         return _tableInfo.get().count; [EOL]     } [EOL]     return _count; [EOL] } <line_num>: 404,411
public int bucketCount() { [EOL]     return _mainHash.length; [EOL] } <line_num>: 416,416
public boolean maybeDirty() { [EOL]     return !_mainHashShared; [EOL] } <line_num>: 423,425
public int hashSeed() { [EOL]     return _hashSeed; [EOL] } <line_num>: 430,430
public int collisionCount() { [EOL]     return _collCount; [EOL] } <line_num>: 439,441
public int maxCollisionLength() { [EOL]     return _longestCollisionList; [EOL] } <line_num>: 450,452
public static Name getEmptyName() { [EOL]     return Name1.getEmptyName(); [EOL] } <line_num>: 460,463
public Name findName(int firstQuad) { [EOL]     int hash = calcHash(firstQuad); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null) { [EOL]             return null; [EOL]         } [EOL]         if (name.equals(firstQuad)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, firstQuad, 0); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 480,512
public Name findName(int firstQuad, int secondQuad) { [EOL]     int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null) { [EOL]             return null; [EOL]         } [EOL]         if (name.equals(firstQuad, secondQuad)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, firstQuad, secondQuad); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 529,561
public Name findName(int[] quads, int qlen) { [EOL]     if (qlen < 3) { [EOL]         return findName(quads[0], (qlen < 2) ? 0 : quads[1]); [EOL]     } [EOL]     int hash = calcHash(quads, qlen); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null || name.equals(quads, qlen)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, quads, qlen); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 580,607
public Name addName(String symbolStr, int q1, int q2) { [EOL]     if (_intern) { [EOL]         symbolStr = InternCache.instance.intern(symbolStr); [EOL]     } [EOL]     int hash = (q2 == 0) ? calcHash(q1) : calcHash(q1, q2); [EOL]     Name symbol = constructName(hash, symbolStr, q1, q2); [EOL]     _addSymbol(hash, symbol); [EOL]     return symbol; [EOL] } <line_num>: 615,624
public Name addName(String symbolStr, int[] quads, int qlen) { [EOL]     if (_intern) { [EOL]         symbolStr = InternCache.instance.intern(symbolStr); [EOL]     } [EOL]     int hash; [EOL]     if (qlen < 3) { [EOL]         hash = (qlen == 1) ? calcHash(quads[0]) : calcHash(quads[0], quads[1]); [EOL]     } else { [EOL]         hash = calcHash(quads, qlen); [EOL]     } [EOL]     Name symbol = constructName(hash, symbolStr, quads, qlen); [EOL]     _addSymbol(hash, symbol); [EOL]     return symbol; [EOL] } <line_num>: 626,640
public int calcHash(int firstQuad) { [EOL]     int hash = firstQuad ^ _hashSeed; [EOL]     hash += (hash >>> 15); [EOL]     hash ^= (hash >>> 9); [EOL]     return hash; [EOL] } <line_num>: 662,668
public int calcHash(int firstQuad, int secondQuad) { [EOL]     int hash = firstQuad; [EOL]     hash ^= (hash >>> 15); [EOL]     hash += (secondQuad * MULT); [EOL]     hash ^= _hashSeed; [EOL]     hash += (hash >>> 7); [EOL]     return hash; [EOL] } <line_num>: 670,681
public int calcHash(int[] quads, int qlen) { [EOL]     if (qlen < 3) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     int hash = quads[0] ^ _hashSeed; [EOL]     hash += (hash >>> 9); [EOL]     hash *= MULT; [EOL]     hash += quads[1]; [EOL]     hash *= MULT2; [EOL]     hash += (hash >>> 15); [EOL]     hash ^= quads[2]; [EOL]     hash += (hash >>> 17); [EOL]     for (int i = 3; i < qlen; ++i) { [EOL]         hash = (hash * MULT3) ^ quads[i]; [EOL]         hash += (hash >>> 3); [EOL]         hash ^= (hash << 7); [EOL]     } [EOL]     hash += (hash >>> 15); [EOL]     hash ^= (hash << 9); [EOL]     return hash; [EOL] } <line_num>: 683,714
protected static int[] calcQuads(byte[] wordBytes) { [EOL]     int blen = wordBytes.length; [EOL]     int[] result = new int[(blen + 3) / 4]; [EOL]     for (int i = 0; i < blen; ++i) { [EOL]         int x = wordBytes[i] & 0xFF; [EOL]         if (++i < blen) { [EOL]             x = (x << 8) | (wordBytes[i] & 0xFF); [EOL]             if (++i < blen) { [EOL]                 x = (x << 8) | (wordBytes[i] & 0xFF); [EOL]                 if (++i < blen) { [EOL]                     x = (x << 8) | (wordBytes[i] & 0xFF); [EOL]                 } [EOL]             } [EOL]         } [EOL]         result[i >> 2] = x; [EOL]     } [EOL]     return result; [EOL] } <line_num>: 717,736
private void _addSymbol(int hash, Name symbol) { [EOL]     if (_mainHashShared) { [EOL]         unshareMain(); [EOL]     } [EOL]     if (_needRehash) { [EOL]         rehash(); [EOL]     } [EOL]     ++_count; [EOL]     int ix = (hash & _mainHashMask); [EOL]     if (_mainNames[ix] == null) { [EOL]         _mainHash[ix] = (hash << 8); [EOL]         if (_mainNamesShared) { [EOL]             unshareNames(); [EOL]         } [EOL]         _mainNames[ix] = symbol; [EOL]     } else { [EOL]         if (_collListShared) { [EOL]             unshareCollision(); [EOL]         } [EOL]         ++_collCount; [EOL]         int entryValue = _mainHash[ix]; [EOL]         int bucket = entryValue & 0xFF; [EOL]         if (bucket == 0) { [EOL]             if (_collEnd <= LAST_VALID_BUCKET) { [EOL]                 bucket = _collEnd; [EOL]                 ++_collEnd; [EOL]                 if (bucket >= _collList.length) { [EOL]                     expandCollision(); [EOL]                 } [EOL]             } else { [EOL]                 bucket = findBestBucket(); [EOL]             } [EOL]             _mainHash[ix] = (entryValue & ~0xFF) | (bucket + 1); [EOL]         } else { [EOL]             --bucket; [EOL]         } [EOL]         Bucket newB = new Bucket(symbol, _collList[bucket]); [EOL]         _collList[bucket] = newB; [EOL]         _longestCollisionList = Math.max(newB.length(), _longestCollisionList); [EOL]         if (_longestCollisionList > MAX_COLL_CHAIN_LENGTH) { [EOL]             reportTooManyCollisions(MAX_COLL_CHAIN_LENGTH); [EOL]         } [EOL]     } [EOL]     { [EOL]         int hashSize = _mainHash.length; [EOL]         if (_count > (hashSize >> 1)) { [EOL]             int hashQuarter = (hashSize >> 2); [EOL]             if (_count > (hashSize - hashQuarter)) { [EOL]                 _needRehash = true; [EOL]             } else if (_collCount >= hashQuarter) { [EOL]                 _needRehash = true; [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 789,865
private void rehash() { [EOL]     _needRehash = false; [EOL]     _mainNamesShared = false; [EOL]     int[] oldMainHash = _mainHash; [EOL]     int len = oldMainHash.length; [EOL]     int newLen = len + len; [EOL]     if (newLen > MAX_TABLE_SIZE) { [EOL]         nukeSymbols(); [EOL]         return; [EOL]     } [EOL]     _mainHash = new int[newLen]; [EOL]     _mainHashMask = (newLen - 1); [EOL]     Name[] oldNames = _mainNames; [EOL]     _mainNames = new Name[newLen]; [EOL]     int symbolsSeen = 0; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Name symbol = oldNames[i]; [EOL]         if (symbol != null) { [EOL]             ++symbolsSeen; [EOL]             int hash = symbol.hashCode(); [EOL]             int ix = (hash & _mainHashMask); [EOL]             _mainNames[ix] = symbol; [EOL]             _mainHash[ix] = hash << 8; [EOL]         } [EOL]     } [EOL]     int oldEnd = _collEnd; [EOL]     if (oldEnd == 0) { [EOL]         _longestCollisionList = 0; [EOL]         return; [EOL]     } [EOL]     _collCount = 0; [EOL]     _collEnd = 0; [EOL]     _collListShared = false; [EOL]     int maxColl = 0; [EOL]     Bucket[] oldBuckets = _collList; [EOL]     _collList = new Bucket[oldBuckets.length]; [EOL]     for (int i = 0; i < oldEnd; ++i) { [EOL]         for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) { [EOL]             ++symbolsSeen; [EOL]             Name symbol = curr._name; [EOL]             int hash = symbol.hashCode(); [EOL]             int ix = (hash & _mainHashMask); [EOL]             int val = _mainHash[ix]; [EOL]             if (_mainNames[ix] == null) { [EOL]                 _mainHash[ix] = (hash << 8); [EOL]                 _mainNames[ix] = symbol; [EOL]             } else { [EOL]                 ++_collCount; [EOL]                 int bucket = val & 0xFF; [EOL]                 if (bucket == 0) { [EOL]                     if (_collEnd <= LAST_VALID_BUCKET) { [EOL]                         bucket = _collEnd; [EOL]                         ++_collEnd; [EOL]                         if (bucket >= _collList.length) { [EOL]                             expandCollision(); [EOL]                         } [EOL]                     } else { [EOL]                         bucket = findBestBucket(); [EOL]                     } [EOL]                     _mainHash[ix] = (val & ~0xFF) | (bucket + 1); [EOL]                 } else { [EOL]                     --bucket; [EOL]                 } [EOL]                 Bucket newB = new Bucket(symbol, _collList[bucket]); [EOL]                 _collList[bucket] = newB; [EOL]                 maxColl = Math.max(maxColl, newB.length()); [EOL]             } [EOL]         } [EOL]     } [EOL]     _longestCollisionList = maxColl; [EOL]     if (symbolsSeen != _count) { [EOL]         throw new RuntimeException("Internal error: count after rehash " + symbolsSeen + "; should be " + _count); [EOL]     } [EOL] } <line_num>: 867,965
private void nukeSymbols() { [EOL]     _count = 0; [EOL]     _longestCollisionList = 0; [EOL]     Arrays.fill(_mainHash, 0); [EOL]     Arrays.fill(_mainNames, null); [EOL]     Arrays.fill(_collList, null); [EOL]     _collCount = 0; [EOL]     _collEnd = 0; [EOL] } <line_num>: 971,980
private int findBestBucket() { [EOL]     Bucket[] buckets = _collList; [EOL]     int bestCount = Integer.MAX_VALUE; [EOL]     int bestIx = -1; [EOL]     for (int i = 0, len = _collEnd; i < len; ++i) { [EOL]         int count = buckets[i].length(); [EOL]         if (count < bestCount) { [EOL]             if (count == 1) { [EOL]                 return i; [EOL]             } [EOL]             bestCount = count; [EOL]             bestIx = i; [EOL]         } [EOL]     } [EOL]     return bestIx; [EOL] } <line_num>: 987,1004
private void unshareMain() { [EOL]     final int[] old = _mainHash; [EOL]     _mainHash = Arrays.copyOf(old, old.length); [EOL]     _mainHashShared = false; [EOL] } <line_num>: 1012,1017
private void unshareCollision() { [EOL]     Bucket[] old = _collList; [EOL]     if (old == null) { [EOL]         _collList = new Bucket[INITIAL_COLLISION_LEN]; [EOL]     } else { [EOL]         _collList = Arrays.copyOf(old, old.length); [EOL]     } [EOL]     _collListShared = false; [EOL] } <line_num>: 1019,1028
private void unshareNames() { [EOL]     final Name[] old = _mainNames; [EOL]     _mainNames = Arrays.copyOf(old, old.length); [EOL]     _mainNamesShared = false; [EOL] } <line_num>: 1030,1035
private void expandCollision() { [EOL]     final Bucket[] old = _collList; [EOL]     _collList = Arrays.copyOf(old, old.length * 2); [EOL] } <line_num>: 1037,1041
private static Name constructName(int hash, String name, int q1, int q2) { [EOL]     if (q2 == 0) { [EOL]         return new Name1(name, hash, q1); [EOL]     } [EOL]     return new Name2(name, hash, q1, q2); [EOL] } <line_num>: 1049,1055
private static Name constructName(int hash, String name, int[] quads, int qlen) { [EOL]     if (qlen < 4) { [EOL]         switch(qlen) { [EOL]             case 1: [EOL]                 return new Name1(name, hash, quads[0]); [EOL]             case 2: [EOL]                 return new Name2(name, hash, quads[0], quads[1]); [EOL]             case 3: [EOL]                 return new Name3(name, hash, quads[0], quads[1], quads[2]); [EOL]             default: [EOL]         } [EOL]     } [EOL]     int[] buf = new int[qlen]; [EOL]     for (int i = 0; i < qlen; ++i) { [EOL]         buf[i] = quads[i]; [EOL]     } [EOL]     return new NameN(name, hash, buf, qlen); [EOL] } <line_num>: 1057,1076
protected void reportTooManyCollisions(int maxLen) { [EOL]     throw new IllegalStateException("Longest collision chain in symbol table (of size " + _count + ") now exceeds maximum, " + maxLen + " -- suspect a DoS attack based on hash collisions"); [EOL] } <line_num>: 1087,1091
public int length() { [EOL]     return _length; [EOL] } <line_num>: 1160,1160
public Name find(int hash, int firstQuad, int secondQuad) { [EOL]     if (_name.hashCode() == hash) { [EOL]         if (_name.equals(firstQuad, secondQuad)) { [EOL]             return _name; [EOL]         } [EOL]     } [EOL]     for (Bucket curr = _next; curr != null; curr = curr._next) { [EOL]         Name currName = curr._name; [EOL]         if (currName.hashCode() == hash) { [EOL]             if (currName.equals(firstQuad, secondQuad)) { [EOL]                 return currName; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 1162,1178
public Name find(int hash, int[] quads, int qlen) { [EOL]     if (_name.hashCode() == hash) { [EOL]         if (_name.equals(quads, qlen)) { [EOL]             return _name; [EOL]         } [EOL]     } [EOL]     for (Bucket curr = _next; curr != null; curr = curr._next) { [EOL]         Name currName = curr._name; [EOL]         if (currName.hashCode() == hash) { [EOL]             if (currName.equals(quads, qlen)) { [EOL]                 return currName; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 1180,1196
