public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st) { [EOL]     super(ctxt, features); [EOL]     _reader = r; [EOL]     _inputBuffer = ctxt.allocTokenBuffer(); [EOL]     _objectCodec = codec; [EOL]     _symbols = st; [EOL]     _hashSeed = st.hashSeed(); [EOL] } <line_num>: 70,79
@Override [EOL] public ObjectCodec getCodec() { [EOL]     return _objectCodec; [EOL] } <line_num>: 87,90
@Override [EOL] public void setCodec(ObjectCodec c) { [EOL]     _objectCodec = c; [EOL] } <line_num>: 92,95
@Override [EOL] public int releaseBuffered(Writer w) throws IOException { [EOL]     int count = _inputEnd - _inputPtr; [EOL]     if (count < 1) { [EOL]         return 0; [EOL]     } [EOL]     int origPtr = _inputPtr; [EOL]     w.write(_inputBuffer, origPtr, count); [EOL]     return count; [EOL] } <line_num>: 97,108
@Override [EOL] public Object getInputSource() { [EOL]     return _reader; [EOL] } <line_num>: 110,113
@Override [EOL] protected boolean loadMore() throws IOException { [EOL]     _currInputProcessed += _inputEnd; [EOL]     _currInputRowStart -= _inputEnd; [EOL]     if (_reader != null) { [EOL]         int count = _reader.read(_inputBuffer, 0, _inputBuffer.length); [EOL]         if (count > 0) { [EOL]             _inputPtr = 0; [EOL]             _inputEnd = count; [EOL]             return true; [EOL]         } [EOL]         _closeInput(); [EOL]         if (count == 0) { [EOL]             throw new IOException("Reader returned 0 characters when trying to read " + _inputEnd); [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 115,136
protected char getNextChar(String eofMsg) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(eofMsg); [EOL]         } [EOL]     } [EOL]     return _inputBuffer[_inputPtr++]; [EOL] } <line_num>: 138,147
@Override [EOL] protected void _closeInput() throws IOException { [EOL]     if (_reader != null) { [EOL]         if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) { [EOL]             _reader.close(); [EOL]         } [EOL]         _reader = null; [EOL]     } [EOL] } <line_num>: 149,165
@Override [EOL] protected void _releaseBuffers() throws IOException { [EOL]     super._releaseBuffers(); [EOL]     char[] buf = _inputBuffer; [EOL]     if (buf != null) { [EOL]         _inputBuffer = null; [EOL]         _ioContext.releaseTokenBuffer(buf); [EOL]     } [EOL] } <line_num>: 173,183
@Override [EOL] public String getText() throws IOException, JsonParseException { [EOL]     JsonToken t = _currToken; [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         if (_tokenIncomplete) { [EOL]             _tokenIncomplete = false; [EOL]             _finishString(); [EOL]         } [EOL]         return _textBuffer.contentsAsString(); [EOL]     } [EOL]     return _getText2(t); [EOL] } <line_num>: 197,210
@Override [EOL] public String getValueAsString() throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_STRING) { [EOL]         if (_tokenIncomplete) { [EOL]             _tokenIncomplete = false; [EOL]             _finishString(); [EOL]         } [EOL]         return _textBuffer.contentsAsString(); [EOL]     } [EOL]     return super.getValueAsString(null); [EOL] } <line_num>: 215,226
@Override [EOL] public String getValueAsString(String defValue) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_STRING) { [EOL]         if (_tokenIncomplete) { [EOL]             _tokenIncomplete = false; [EOL]             _finishString(); [EOL]         } [EOL]         return _textBuffer.contentsAsString(); [EOL]     } [EOL]     return super.getValueAsString(defValue); [EOL] } <line_num>: 229,240
protected String _getText2(JsonToken t) { [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case FIELD_NAME: [EOL]             return _parsingContext.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return _textBuffer.contentsAsString(); [EOL]         default: [EOL]             return t.asString(); [EOL]     } [EOL] } <line_num>: 243,260
@Override [EOL] public char[] getTextCharacters() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 if (!_nameCopied) { [EOL]                     String name = _parsingContext.getCurrentName(); [EOL]                     int nameLen = name.length(); [EOL]                     if (_nameCopyBuffer == null) { [EOL]                         _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); [EOL]                     } else if (_nameCopyBuffer.length < nameLen) { [EOL]                         _nameCopyBuffer = new char[nameLen]; [EOL]                     } [EOL]                     name.getChars(0, nameLen, _nameCopyBuffer, 0); [EOL]                     _nameCopied = true; [EOL]                 } [EOL]                 return _nameCopyBuffer; [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.getTextBuffer(); [EOL]             default: [EOL]                 return _currToken.asCharArray(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 262,298
@Override [EOL] public int getTextLength() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 return _parsingContext.getCurrentName().length(); [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.size(); [EOL]             default: [EOL]                 return _currToken.asCharArray().length; [EOL]         } [EOL]     } [EOL]     return 0; [EOL] } <line_num>: 300,324
@Override [EOL] public int getTextOffset() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 return 0; [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.getTextOffset(); [EOL]             default: [EOL]         } [EOL]     } [EOL]     return 0; [EOL] } <line_num>: 326,347
@Override [EOL] public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { [EOL]     if (_currToken != JsonToken.VALUE_STRING && (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) { [EOL]         _reportError("Current token (" + _currToken + ") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary"); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         try { [EOL]             _binaryValue = _decodeBase64(b64variant); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw _constructError("Failed to decode VALUE_STRING as base64 (" + b64variant + "): " + iae.getMessage()); [EOL]         } [EOL]         _tokenIncomplete = false; [EOL]     } else { [EOL]         if (_binaryValue == null) { [EOL]             @SuppressWarnings("resource") [EOL]             ByteArrayBuilder builder = _getByteArrayBuilder(); [EOL]             _decodeBase64(getText(), builder, b64variant); [EOL]             _binaryValue = builder.toByteArray(); [EOL]         } [EOL]     } [EOL]     return _binaryValue; [EOL] } <line_num>: 349,379
@Override [EOL] public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException { [EOL]     if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) { [EOL]         byte[] b = getBinaryValue(b64variant); [EOL]         out.write(b); [EOL]         return b.length; [EOL]     } [EOL]     byte[] buf = _ioContext.allocBase64Buffer(); [EOL]     try { [EOL]         return _readBinary(b64variant, out, buf); [EOL]     } finally { [EOL]         _ioContext.releaseBase64Buffer(buf); [EOL]     } [EOL] } <line_num>: 381,398
protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException { [EOL]     int outputPtr = 0; [EOL]     final int outputEnd = buffer.length - 3; [EOL]     int outputCount = 0; [EOL]     while (true) { [EOL]         char ch; [EOL]         do { [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             ch = _inputBuffer[_inputPtr++]; [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (ch == '"') { [EOL]                 break; [EOL]             } [EOL]             bits = _decodeBase64Escape(b64variant, ch, 0); [EOL]             if (bits < 0) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (outputPtr > outputEnd) { [EOL]             outputCount += outputPtr; [EOL]             out.write(buffer, 0, outputPtr); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             bits = _decodeBase64Escape(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 4; [EOL]                     buffer[outputPtr++] = (byte) decodedData; [EOL]                     break; [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 2); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (_inputPtr >= _inputEnd) { [EOL]                     loadMoreGuaranteed(); [EOL]                 } [EOL]                 ch = _inputBuffer[_inputPtr++]; [EOL]                 if (!b64variant.usesPaddingChar(ch)) { [EOL]                     throw reportInvalidBase64Char(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL]                 } [EOL]                 decodedData >>= 4; [EOL]                 buffer[outputPtr++] = (byte) decodedData; [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 2; [EOL]                     buffer[outputPtr++] = (byte) (decodedData >> 8); [EOL]                     buffer[outputPtr++] = (byte) decodedData; [EOL]                     break; [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 3); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 decodedData >>= 2; [EOL]                 buffer[outputPtr++] = (byte) (decodedData >> 8); [EOL]                 buffer[outputPtr++] = (byte) decodedData; [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         buffer[outputPtr++] = (byte) (decodedData >> 16); [EOL]         buffer[outputPtr++] = (byte) (decodedData >> 8); [EOL]         buffer[outputPtr++] = (byte) decodedData; [EOL]     } [EOL]     _tokenIncomplete = false; [EOL]     if (outputPtr > 0) { [EOL]         outputCount += outputPtr; [EOL]         out.write(buffer, 0, outputPtr); [EOL]     } [EOL]     return outputCount; [EOL] } <line_num>: 400,525
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] } <line_num>: 537,680
private JsonToken _nextAfterName() { [EOL]     _nameCopied = false; [EOL]     JsonToken t = _nextToken; [EOL]     _nextToken = null; [EOL]     if (t == JsonToken.START_ARRAY) { [EOL]         _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]     } else if (t == JsonToken.START_OBJECT) { [EOL]         _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]     } [EOL]     return (_currToken = t); [EOL] } <line_num>: 682,694
@Override [EOL] public String nextTextValue() throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         _nameCopied = false; [EOL]         JsonToken t = _nextToken; [EOL]         _nextToken = null; [EOL]         _currToken = t; [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             if (_tokenIncomplete) { [EOL]                 _tokenIncomplete = false; [EOL]                 _finishString(); [EOL]             } [EOL]             return _textBuffer.contentsAsString(); [EOL]         } [EOL]         if (t == JsonToken.START_ARRAY) { [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]         } else if (t == JsonToken.START_OBJECT) { [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]         } [EOL]         return null; [EOL]     } [EOL]     return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null; [EOL] } <line_num>: 703,728
@Override [EOL] public int nextIntValue(int defaultValue) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         _nameCopied = false; [EOL]         JsonToken t = _nextToken; [EOL]         _nextToken = null; [EOL]         _currToken = t; [EOL]         if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]             return getIntValue(); [EOL]         } [EOL]         if (t == JsonToken.START_ARRAY) { [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]         } else if (t == JsonToken.START_OBJECT) { [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]         } [EOL]         return defaultValue; [EOL]     } [EOL]     return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue; [EOL] } <line_num>: 731,752
@Override [EOL] public long nextLongValue(long defaultValue) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         _nameCopied = false; [EOL]         JsonToken t = _nextToken; [EOL]         _nextToken = null; [EOL]         _currToken = t; [EOL]         if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]             return getLongValue(); [EOL]         } [EOL]         if (t == JsonToken.START_ARRAY) { [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]         } else if (t == JsonToken.START_OBJECT) { [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]         } [EOL]         return defaultValue; [EOL]     } [EOL]     return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue; [EOL] } <line_num>: 755,776
@Override [EOL] public Boolean nextBooleanValue() throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         _nameCopied = false; [EOL]         JsonToken t = _nextToken; [EOL]         _nextToken = null; [EOL]         _currToken = t; [EOL]         if (t == JsonToken.VALUE_TRUE) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (t == JsonToken.VALUE_FALSE) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (t == JsonToken.START_ARRAY) { [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]         } else if (t == JsonToken.START_OBJECT) { [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]         } [EOL]         return null; [EOL]     } [EOL]     switch(nextToken()) { [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         default: [EOL]             return null; [EOL]     } [EOL] } <line_num>: 779,809
@Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     _symbols.release(); [EOL] } <line_num>: 811,816
protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException { [EOL]     boolean negative = (ch == INT_MINUS); [EOL]     int ptr = _inputPtr; [EOL]     int startPtr = ptr - 1; [EOL]     final int inputLen = _inputEnd; [EOL]     dummy_loop: do { [EOL]         if (negative) { [EOL]             if (ptr >= _inputEnd) { [EOL]                 break dummy_loop; [EOL]             } [EOL]             ch = _inputBuffer[ptr++]; [EOL]             if (ch > INT_9 || ch < INT_0) { [EOL]                 _inputPtr = ptr; [EOL]                 return _handleInvalidNumberStart(ch, true); [EOL]             } [EOL]         } [EOL]         if (ch == INT_0) { [EOL]             break dummy_loop; [EOL]         } [EOL]         int intLen = 1; [EOL]         int_loop: while (true) { [EOL]             if (ptr >= _inputEnd) { [EOL]                 break dummy_loop; [EOL]             } [EOL]             ch = (int) _inputBuffer[ptr++]; [EOL]             if (ch < INT_0 || ch > INT_9) { [EOL]                 break int_loop; [EOL]             } [EOL]             ++intLen; [EOL]         } [EOL]         int fractLen = 0; [EOL]         if (ch == INT_DECIMAL_POINT) { [EOL]             fract_loop: while (true) { [EOL]                 if (ptr >= inputLen) { [EOL]                     break dummy_loop; [EOL]                 } [EOL]                 ch = (int) _inputBuffer[ptr++]; [EOL]                 if (ch < INT_0 || ch > INT_9) { [EOL]                     break fract_loop; [EOL]                 } [EOL]                 ++fractLen; [EOL]             } [EOL]             if (fractLen == 0) { [EOL]                 reportUnexpectedNumberChar(ch, "Decimal point not followed by a digit"); [EOL]             } [EOL]         } [EOL]         int expLen = 0; [EOL]         if (ch == INT_e || ch == INT_E) { [EOL]             if (ptr >= inputLen) { [EOL]                 break dummy_loop; [EOL]             } [EOL]             ch = (int) _inputBuffer[ptr++]; [EOL]             if (ch == INT_MINUS || ch == INT_PLUS) { [EOL]                 if (ptr >= inputLen) { [EOL]                     break dummy_loop; [EOL]                 } [EOL]                 ch = (int) _inputBuffer[ptr++]; [EOL]             } [EOL]             while (ch <= INT_9 && ch >= INT_0) { [EOL]                 ++expLen; [EOL]                 if (ptr >= inputLen) { [EOL]                     break dummy_loop; [EOL]                 } [EOL]                 ch = (int) _inputBuffer[ptr++]; [EOL]             } [EOL]             if (expLen == 0) { [EOL]                 reportUnexpectedNumberChar(ch, "Exponent indicator not followed by a digit"); [EOL]             } [EOL]         } [EOL]         --ptr; [EOL]         _inputPtr = ptr; [EOL]         int len = ptr - startPtr; [EOL]         _textBuffer.resetWithShared(_inputBuffer, startPtr, len); [EOL]         return reset(negative, intLen, fractLen, expLen); [EOL]     } while (false); [EOL]     _inputPtr = negative ? (startPtr + 1) : startPtr; [EOL]     return parseNumberText2(negative); [EOL] } <line_num>: 840,954
private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = 0; [EOL]     if (negative) { [EOL]         outBuf[outPtr++] = '-'; [EOL]     } [EOL]     int intLen = 0; [EOL]     char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar("No digit following minus sign"); [EOL]     if (c == '0') { [EOL]         c = _verifyNoLeadingZeroes(); [EOL]     } [EOL]     boolean eof = false; [EOL]     int_loop: while (c >= '0' && c <= '9') { [EOL]         ++intLen; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]         if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]             c = CHAR_NULL; [EOL]             eof = true; [EOL]             break int_loop; [EOL]         } [EOL]         c = _inputBuffer[_inputPtr++]; [EOL]     } [EOL]     if (intLen == 0) { [EOL]         reportInvalidNumber("Missing integer part (next char " + _getCharDesc(c) + ")"); [EOL]     } [EOL]     int fractLen = 0; [EOL]     if (c == '.') { [EOL]         outBuf[outPtr++] = c; [EOL]         fract_loop: while (true) { [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break fract_loop; [EOL]             } [EOL]             c = _inputBuffer[_inputPtr++]; [EOL]             if (c < INT_0 || c > INT_9) { [EOL]                 break fract_loop; [EOL]             } [EOL]             ++fractLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = c; [EOL]         } [EOL]         if (fractLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Decimal point not followed by a digit"); [EOL]         } [EOL]     } [EOL]     int expLen = 0; [EOL]     if (c == 'e' || c == 'E') { [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]         c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar("expected a digit for number exponent"); [EOL]         if (c == '-' || c == '+') { [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = c; [EOL]             c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar("expected a digit for number exponent"); [EOL]         } [EOL]         exp_loop: while (c <= INT_9 && c >= INT_0) { [EOL]             ++expLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = c; [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break exp_loop; [EOL]             } [EOL]             c = _inputBuffer[_inputPtr++]; [EOL]         } [EOL]         if (expLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Exponent indicator not followed by a digit"); [EOL]         } [EOL]     } [EOL]     if (!eof) { [EOL]         --_inputPtr; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return reset(negative, intLen, fractLen, expLen); [EOL] } <line_num>: 963,1081
private char _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return '0'; [EOL]     } [EOL]     char ch = _inputBuffer[_inputPtr]; [EOL]     if (ch < '0' || ch > '9') { [EOL]         return '0'; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr]; [EOL]             if (ch < '0' || ch > '9') { [EOL]                 return '0'; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != '0') { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] } <line_num>: 1087,1117
protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException, JsonParseException { [EOL]     if (ch == 'I') { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOFInValue(); [EOL]             } [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         if (ch == 'N') { [EOL]             String match = negative ? "-INF" : "+INF"; [EOL]             _matchToken(match, 3); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token '" + match + "': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]         } else if (ch == 'n') { [EOL]             String match = negative ? "-Infinity" : "+Infinity"; [EOL]             _matchToken(match, 3); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token '" + match + "': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]         } [EOL]     } [EOL]     reportUnexpectedNumberChar(ch, "expected digit (0-9) to follow minus sign, for valid numeric value"); [EOL]     return null; [EOL] } <line_num>: 1123,1151
protected String _parseFieldName(int i) throws IOException, JsonParseException { [EOL]     if (i != INT_QUOTE) { [EOL]         return _handleUnusualFieldName(i); [EOL]     } [EOL]     int ptr = _inputPtr; [EOL]     int hash = _hashSeed; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         final int[] codes = CharTypes.getInputCodeLatin1(); [EOL]         final int maxCode = codes.length; [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch < maxCode && codes[ch] != 0) { [EOL]                 if (ch == '"') { [EOL]                     int start = _inputPtr; [EOL]                     _inputPtr = ptr + 1; [EOL]                     return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]             hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     int start = _inputPtr; [EOL]     _inputPtr = ptr; [EOL]     return _parseFieldName2(start, hash, INT_QUOTE); [EOL] } <line_num>: 1159,1195
private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException, JsonParseException { [EOL]     _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing '" + ((char) endChar) + "' for name"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= endChar) { [EOL]                 if (i == endChar) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "name"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; [EOL]         outBuf[outPtr++] = c; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     { [EOL]         TextBuffer tb = _textBuffer; [EOL]         char[] buf = tb.getTextBuffer(); [EOL]         int start = tb.getTextOffset(); [EOL]         int len = tb.size(); [EOL]         return _symbols.findSymbol(buf, start, len, hash); [EOL]     } [EOL] } <line_num>: 1197,1251
protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_APOSTROPHE && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]         return _parseApostropheFieldName(); [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { [EOL]         _reportUnexpectedChar(i, "was expecting double-quote to start field name"); [EOL]     } [EOL]     final int[] codes = CharTypes.getInputCodeLatin1JsNames(); [EOL]     final int maxCode = codes.length; [EOL]     boolean firstOk; [EOL]     if (i < maxCode) { [EOL]         firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9); [EOL]     } else { [EOL]         firstOk = Character.isJavaIdentifierPart((char) i); [EOL]     } [EOL]     if (!firstOk) { [EOL]         _reportUnexpectedChar(i, "was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"); [EOL]     } [EOL]     int ptr = _inputPtr; [EOL]     int hash = _hashSeed; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch < maxCode) { [EOL]                 if (codes[ch] != 0) { [EOL]                     int start = _inputPtr - 1; [EOL]                     _inputPtr = ptr; [EOL]                     return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]                 } [EOL]             } else if (!Character.isJavaIdentifierPart((char) ch)) { [EOL]                 int start = _inputPtr - 1; [EOL]                 _inputPtr = ptr; [EOL]                 return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]             } [EOL]             hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     int start = _inputPtr - 1; [EOL]     _inputPtr = ptr; [EOL]     return _parseUnusualFieldName2(start, hash, codes); [EOL] } <line_num>: 1259,1309
protected String _parseApostropheFieldName() throws IOException, JsonParseException { [EOL]     int ptr = _inputPtr; [EOL]     int hash = _hashSeed; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         final int[] codes = CharTypes.getInputCodeLatin1(); [EOL]         final int maxCode = codes.length; [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch == '\'') { [EOL]                 int start = _inputPtr; [EOL]                 _inputPtr = ptr + 1; [EOL]                 return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]             } [EOL]             if (ch < maxCode && codes[ch] != 0) { [EOL]                 break; [EOL]             } [EOL]             hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     int start = _inputPtr; [EOL]     _inputPtr = ptr; [EOL]     return _parseFieldName2(start, hash, INT_APOSTROPHE); [EOL] } <line_num>: 1311,1342
protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException { [EOL]     switch(i) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(i)) { [EOL]         _reportInvalidToken("" + ((char) i), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(i, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] } <line_num>: 1348,1394
protected JsonToken _handleApostropheValue() throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= INT_APOSTROPHE) { [EOL]                 if (i == INT_APOSTROPHE) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "string value"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return JsonToken.VALUE_STRING; [EOL] } <line_num>: 1396,1436
private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException { [EOL]     _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     final int maxCode = codes.length; [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr]; [EOL]         int i = (int) c; [EOL]         if (i <= maxCode) { [EOL]             if (codes[i] != 0) { [EOL]                 break; [EOL]             } [EOL]         } else if (!Character.isJavaIdentifierPart(c)) { [EOL]             break; [EOL]         } [EOL]         ++_inputPtr; [EOL]         hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; [EOL]         outBuf[outPtr++] = c; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     { [EOL]         TextBuffer tb = _textBuffer; [EOL]         char[] buf = tb.getTextBuffer(); [EOL]         int start = tb.getTextOffset(); [EOL]         int len = tb.size(); [EOL]         return _symbols.findSymbol(buf, start, len, hash); [EOL]     } [EOL] } <line_num>: 1438,1481
@Override [EOL] protected void _finishString() throws IOException, JsonParseException { [EOL]     int ptr = _inputPtr; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         final int[] codes = CharTypes.getInputCodeLatin1(); [EOL]         final int maxCode = codes.length; [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch < maxCode && codes[ch] != 0) { [EOL]                 if (ch == '"') { [EOL]                     _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr)); [EOL]                     _inputPtr = ptr + 1; [EOL]                     return; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr)); [EOL]     _inputPtr = ptr; [EOL]     _finishString2(); [EOL] } <line_num>: 1483,1519
protected void _finishString2() throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= INT_QUOTE) { [EOL]                 if (i == INT_QUOTE) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "string value"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] } <line_num>: 1521,1560
protected void _skipString() throws IOException, JsonParseException { [EOL]     _tokenIncomplete = false; [EOL]     int inputPtr = _inputPtr; [EOL]     int inputLen = _inputEnd; [EOL]     char[] inputBuffer = _inputBuffer; [EOL]     while (true) { [EOL]         if (inputPtr >= inputLen) { [EOL]             _inputPtr = inputPtr; [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL]             } [EOL]             inputPtr = _inputPtr; [EOL]             inputLen = _inputEnd; [EOL]         } [EOL]         char c = inputBuffer[inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 _inputPtr = inputPtr; [EOL]                 c = _decodeEscaped(); [EOL]                 inputPtr = _inputPtr; [EOL]                 inputLen = _inputEnd; [EOL]             } else if (i <= INT_QUOTE) { [EOL]                 if (i == INT_QUOTE) { [EOL]                     _inputPtr = inputPtr; [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _inputPtr = inputPtr; [EOL]                     _throwUnquotedSpace(i, "string value"); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 1567,1609
protected void _skipCR() throws IOException { [EOL]     if (_inputPtr < _inputEnd || loadMore()) { [EOL]         if (_inputBuffer[_inputPtr] == '\n') { [EOL]             ++_inputPtr; [EOL]         } [EOL]     } [EOL]     ++_currInputRow; [EOL]     _currInputRowStart = _inputPtr; [EOL] } <line_num>: 1621,1630
protected void _skipLF() throws IOException { [EOL]     ++_currInputRow; [EOL]     _currInputRowStart = _inputPtr; [EOL] } <line_num>: 1632,1636
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] } <line_num>: 1638,1659
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i == INT_SLASH) { [EOL]                 _skipComment(); [EOL]                 continue; [EOL]             } [EOL]             return i; [EOL]         } [EOL]         if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] } <line_num>: 1661,1686
private void _skipComment() throws IOException, JsonParseException { [EOL]     if (!isEnabled(Feature.ALLOW_COMMENTS)) { [EOL]         _reportUnexpectedChar('/', "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)"); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         _reportInvalidEOF(" in a comment"); [EOL]     } [EOL]     char c = _inputBuffer[_inputPtr++]; [EOL]     if (c == '/') { [EOL]         _skipCppComment(); [EOL]     } else if (c == '*') { [EOL]         _skipCComment(); [EOL]     } else { [EOL]         _reportUnexpectedChar(c, "was expecting either '*' or '/' for a comment"); [EOL]     } [EOL] } <line_num>: 1688,1706
private void _skipCComment() throws IOException, JsonParseException { [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i <= INT_ASTERISK) { [EOL]             if (i == INT_ASTERISK) { [EOL]                 if ((_inputPtr >= _inputEnd) && !loadMore()) { [EOL]                     break main_loop; [EOL]                 } [EOL]                 if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                     ++_inputPtr; [EOL]                     return; [EOL]                 } [EOL]                 continue; [EOL]             } [EOL]             if (i < INT_SPACE) { [EOL]                 if (i == INT_LF) { [EOL]                     _skipLF(); [EOL]                 } else if (i == INT_CR) { [EOL]                     _skipCR(); [EOL]                 } else if (i != INT_TAB) { [EOL]                     _throwInvalidSpace(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] } <line_num>: 1708,1738
private void _skipCppComment() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i < INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]                 break; [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]                 break; [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 1740,1758
@Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     char c = _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape(c); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } <line_num>: 1760,1813
protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException { [EOL]     final int len = matchStr.length(); [EOL]     do { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidToken(matchStr.substring(0, i)); [EOL]             } [EOL]         } [EOL]         if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) { [EOL]             _reportInvalidToken(matchStr.substring(0, i)); [EOL]         } [EOL]         ++_inputPtr; [EOL]     } while (++i < len); [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     char c = _inputBuffer[_inputPtr]; [EOL]     if (c < '0' || c == ']' || c == '}') { [EOL]         return; [EOL]     } [EOL]     if (Character.isJavaIdentifierPart(c)) { [EOL]         _reportInvalidToken(matchStr.substring(0, i)); [EOL]     } [EOL]     return; [EOL] } <line_num>: 1818,1850
@SuppressWarnings("resource") [EOL] protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException { [EOL]     ByteArrayBuilder builder = _getByteArrayBuilder(); [EOL]     while (true) { [EOL]         char ch; [EOL]         do { [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             ch = _inputBuffer[_inputPtr++]; [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (ch == '"') { [EOL]                 return builder.toByteArray(); [EOL]             } [EOL]             bits = _decodeBase64Escape(b64variant, ch, 0); [EOL]             if (bits < 0) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             bits = _decodeBase64Escape(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 4; [EOL]                     builder.append(decodedData); [EOL]                     return builder.toByteArray(); [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 2); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (_inputPtr >= _inputEnd) { [EOL]                     loadMoreGuaranteed(); [EOL]                 } [EOL]                 ch = _inputBuffer[_inputPtr++]; [EOL]                 if (!b64variant.usesPaddingChar(ch)) { [EOL]                     throw reportInvalidBase64Char(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL]                 } [EOL]                 decodedData >>= 4; [EOL]                 builder.append(decodedData); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 2; [EOL]                     builder.appendTwoBytes(decodedData); [EOL]                     return builder.toByteArray(); [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 3); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 decodedData >>= 2; [EOL]                 builder.appendTwoBytes(decodedData); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         builder.appendThreeBytes(decodedData); [EOL]     } [EOL] } <line_num>: 1862,1970
protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException { [EOL]     _reportInvalidToken(matchedPart, "'null', 'true', 'false' or NaN"); [EOL] } <line_num>: 1978,1981
protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException { [EOL]     StringBuilder sb = new StringBuilder(matchedPart); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr]; [EOL]         if (!Character.isJavaIdentifierPart(c)) { [EOL]             break; [EOL]         } [EOL]         ++_inputPtr; [EOL]         sb.append(c); [EOL]     } [EOL]     _reportError("Unrecognized token '" + sb.toString() + "': was expecting "); [EOL] } <line_num>: 1983,2005
