public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in, ObjectCodec codec, BytesToNameCanonicalizer sym, byte[] inputBuffer, int start, int end, boolean bufferRecyclable) { [EOL]     super(ctxt, features); [EOL]     _inputStream = in; [EOL]     _objectCodec = codec; [EOL]     _symbols = sym; [EOL]     _inputBuffer = inputBuffer; [EOL]     _inputPtr = start; [EOL]     _inputEnd = end; [EOL]     _bufferRecyclable = bufferRecyclable; [EOL] } <line_num>: 107,120
@Override [EOL] public ObjectCodec getCodec() { [EOL]     return _objectCodec; [EOL] } <line_num>: 122,125
@Override [EOL] public void setCodec(ObjectCodec c) { [EOL]     _objectCodec = c; [EOL] } <line_num>: 127,130
@Override [EOL] public int releaseBuffered(OutputStream out) throws IOException { [EOL]     int count = _inputEnd - _inputPtr; [EOL]     if (count < 1) { [EOL]         return 0; [EOL]     } [EOL]     int origPtr = _inputPtr; [EOL]     out.write(_inputBuffer, origPtr, count); [EOL]     return count; [EOL] } <line_num>: 138,149
@Override [EOL] public Object getInputSource() { [EOL]     return _inputStream; [EOL] } <line_num>: 151,154
@Override [EOL] protected boolean loadMore() throws IOException { [EOL]     _currInputProcessed += _inputEnd; [EOL]     _currInputRowStart -= _inputEnd; [EOL]     if (_inputStream != null) { [EOL]         int count = _inputStream.read(_inputBuffer, 0, _inputBuffer.length); [EOL]         if (count > 0) { [EOL]             _inputPtr = 0; [EOL]             _inputEnd = count; [EOL]             return true; [EOL]         } [EOL]         _closeInput(); [EOL]         if (count == 0) { [EOL]             throw new IOException("InputStream.read() returned 0 characters when trying to read " + _inputBuffer.length + " bytes"); [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 162,184
protected boolean _loadToHaveAtLeast(int minAvailable) throws IOException { [EOL]     if (_inputStream == null) { [EOL]         return false; [EOL]     } [EOL]     int amount = _inputEnd - _inputPtr; [EOL]     if (amount > 0 && _inputPtr > 0) { [EOL]         _currInputProcessed += _inputPtr; [EOL]         _currInputRowStart -= _inputPtr; [EOL]         System.arraycopy(_inputBuffer, _inputPtr, _inputBuffer, 0, amount); [EOL]         _inputEnd = amount; [EOL]     } else { [EOL]         _inputEnd = 0; [EOL]     } [EOL]     _inputPtr = 0; [EOL]     while (_inputEnd < minAvailable) { [EOL]         int count = _inputStream.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd); [EOL]         if (count < 1) { [EOL]             _closeInput(); [EOL]             if (count == 0) { [EOL]                 throw new IOException("InputStream.read() returned 0 characters when trying to read " + amount + " bytes"); [EOL]             } [EOL]             return false; [EOL]         } [EOL]         _inputEnd += count; [EOL]     } [EOL]     return true; [EOL] } <line_num>: 190,222
@Override [EOL] protected void _closeInput() throws IOException { [EOL]     if (_inputStream != null) { [EOL]         if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) { [EOL]             _inputStream.close(); [EOL]         } [EOL]         _inputStream = null; [EOL]     } [EOL] } <line_num>: 224,237
@Override [EOL] protected void _releaseBuffers() throws IOException { [EOL]     super._releaseBuffers(); [EOL]     if (_bufferRecyclable) { [EOL]         byte[] buf = _inputBuffer; [EOL]         if (buf != null) { [EOL]             _inputBuffer = null; [EOL]             _ioContext.releaseReadIOBuffer(buf); [EOL]         } [EOL]     } [EOL] } <line_num>: 245,256
@Override [EOL] public String getText() throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_STRING) { [EOL]         if (_tokenIncomplete) { [EOL]             _tokenIncomplete = false; [EOL]             _finishString(); [EOL]         } [EOL]         return _textBuffer.contentsAsString(); [EOL]     } [EOL]     return _getText2(_currToken); [EOL] } <line_num>: 264,276
@Override [EOL] public String getValueAsString() throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_STRING) { [EOL]         if (_tokenIncomplete) { [EOL]             _tokenIncomplete = false; [EOL]             _finishString(); [EOL]         } [EOL]         return _textBuffer.contentsAsString(); [EOL]     } [EOL]     return super.getValueAsString(null); [EOL] } <line_num>: 281,292
@Override [EOL] public String getValueAsString(String defValue) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_STRING) { [EOL]         if (_tokenIncomplete) { [EOL]             _tokenIncomplete = false; [EOL]             _finishString(); [EOL]         } [EOL]         return _textBuffer.contentsAsString(); [EOL]     } [EOL]     return super.getValueAsString(defValue); [EOL] } <line_num>: 295,306
protected String _getText2(JsonToken t) { [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case FIELD_NAME: [EOL]             return _parsingContext.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return _textBuffer.contentsAsString(); [EOL]         default: [EOL]             return t.asString(); [EOL]     } [EOL] } <line_num>: 308,325
@Override [EOL] public char[] getTextCharacters() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 if (!_nameCopied) { [EOL]                     String name = _parsingContext.getCurrentName(); [EOL]                     int nameLen = name.length(); [EOL]                     if (_nameCopyBuffer == null) { [EOL]                         _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen); [EOL]                     } else if (_nameCopyBuffer.length < nameLen) { [EOL]                         _nameCopyBuffer = new char[nameLen]; [EOL]                     } [EOL]                     name.getChars(0, nameLen, _nameCopyBuffer, 0); [EOL]                     _nameCopied = true; [EOL]                 } [EOL]                 return _nameCopyBuffer; [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.getTextBuffer(); [EOL]             default: [EOL]                 return _currToken.asCharArray(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 327,363
@Override [EOL] public int getTextLength() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 return _parsingContext.getCurrentName().length(); [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.size(); [EOL]             default: [EOL]                 return _currToken.asCharArray().length; [EOL]         } [EOL]     } [EOL]     return 0; [EOL] } <line_num>: 365,389
@Override [EOL] public int getTextOffset() throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case FIELD_NAME: [EOL]                 return 0; [EOL]             case VALUE_STRING: [EOL]                 if (_tokenIncomplete) { [EOL]                     _tokenIncomplete = false; [EOL]                     _finishString(); [EOL]                 } [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return _textBuffer.getTextOffset(); [EOL]             default: [EOL]         } [EOL]     } [EOL]     return 0; [EOL] } <line_num>: 391,412
@Override [EOL] public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { [EOL]     if (_currToken != JsonToken.VALUE_STRING && (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) { [EOL]         _reportError("Current token (" + _currToken + ") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary"); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         try { [EOL]             _binaryValue = _decodeBase64(b64variant); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw _constructError("Failed to decode VALUE_STRING as base64 (" + b64variant + "): " + iae.getMessage()); [EOL]         } [EOL]         _tokenIncomplete = false; [EOL]     } else { [EOL]         if (_binaryValue == null) { [EOL]             @SuppressWarnings("resource") [EOL]             ByteArrayBuilder builder = _getByteArrayBuilder(); [EOL]             _decodeBase64(getText(), builder, b64variant); [EOL]             _binaryValue = builder.toByteArray(); [EOL]         } [EOL]     } [EOL]     return _binaryValue; [EOL] } <line_num>: 414,444
@Override [EOL] public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException { [EOL]     if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) { [EOL]         byte[] b = getBinaryValue(b64variant); [EOL]         out.write(b); [EOL]         return b.length; [EOL]     } [EOL]     byte[] buf = _ioContext.allocBase64Buffer(); [EOL]     try { [EOL]         return _readBinary(b64variant, out, buf); [EOL]     } finally { [EOL]         _ioContext.releaseBase64Buffer(buf); [EOL]     } [EOL] } <line_num>: 446,463
protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException, JsonParseException { [EOL]     int outputPtr = 0; [EOL]     final int outputEnd = buffer.length - 3; [EOL]     int outputCount = 0; [EOL]     while (true) { [EOL]         int ch; [EOL]         do { [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             ch = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (ch == INT_QUOTE) { [EOL]                 break; [EOL]             } [EOL]             bits = _decodeBase64Escape(b64variant, ch, 0); [EOL]             if (bits < 0) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         if (outputPtr > outputEnd) { [EOL]             outputCount += outputPtr; [EOL]             out.write(buffer, 0, outputPtr); [EOL]             outputPtr = 0; [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             bits = _decodeBase64Escape(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 4; [EOL]                     buffer[outputPtr++] = (byte) decodedData; [EOL]                     break; [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 2); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (_inputPtr >= _inputEnd) { [EOL]                     loadMoreGuaranteed(); [EOL]                 } [EOL]                 ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]                 if (!b64variant.usesPaddingChar(ch)) { [EOL]                     throw reportInvalidBase64Char(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL]                 } [EOL]                 decodedData >>= 4; [EOL]                 buffer[outputPtr++] = (byte) decodedData; [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 2; [EOL]                     buffer[outputPtr++] = (byte) (decodedData >> 8); [EOL]                     buffer[outputPtr++] = (byte) decodedData; [EOL]                     break; [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 3); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 decodedData >>= 2; [EOL]                 buffer[outputPtr++] = (byte) (decodedData >> 8); [EOL]                 buffer[outputPtr++] = (byte) decodedData; [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         buffer[outputPtr++] = (byte) (decodedData >> 16); [EOL]         buffer[outputPtr++] = (byte) (decodedData >> 8); [EOL]         buffer[outputPtr++] = (byte) decodedData; [EOL]     } [EOL]     _tokenIncomplete = false; [EOL]     if (outputPtr > 0) { [EOL]         outputCount += outputPtr; [EOL]         out.write(buffer, 0, outputPtr); [EOL]     } [EOL]     return outputCount; [EOL] } <line_num>: 465,591
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] } <line_num>: 603,734
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] } <line_num>: 736,782
private JsonToken _nextAfterName() { [EOL]     _nameCopied = false; [EOL]     JsonToken t = _nextToken; [EOL]     _nextToken = null; [EOL]     if (t == JsonToken.START_ARRAY) { [EOL]         _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]     } else if (t == JsonToken.START_OBJECT) { [EOL]         _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]     } [EOL]     return (_currToken = t); [EOL] } <line_num>: 784,796
@Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     _symbols.release(); [EOL] } <line_num>: 798,804
@Override [EOL] public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         _nextAfterName(); [EOL]         return false; [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         _currToken = null; [EOL]         return false; [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         _currToken = JsonToken.END_ARRAY; [EOL]         return false; [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         _currToken = JsonToken.END_OBJECT; [EOL]         return false; [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         _nextTokenNotInObject(i); [EOL]         return false; [EOL]     } [EOL]     if (i == INT_QUOTE) { [EOL]         byte[] nameBytes = str.asQuotedUTF8(); [EOL]         final int len = nameBytes.length; [EOL]         if ((_inputPtr + len) < _inputEnd) { [EOL]             final int end = _inputPtr + len; [EOL]             if (_inputBuffer[end] == INT_QUOTE) { [EOL]                 int offset = 0; [EOL]                 final int ptr = _inputPtr; [EOL]                 while (true) { [EOL]                     if (offset == len) { [EOL]                         _inputPtr = end + 1; [EOL]                         _parsingContext.setCurrentName(str.getValue()); [EOL]                         _currToken = JsonToken.FIELD_NAME; [EOL]                         _isNextTokenNameYes(); [EOL]                         return true; [EOL]                     } [EOL]                     if (nameBytes[offset] != _inputBuffer[ptr + offset]) { [EOL]                         break; [EOL]                     } [EOL]                     ++offset; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _isNextTokenNameMaybe(i, str); [EOL] } <line_num>: 812,900
private void _isNextTokenNameYes() throws IOException, JsonParseException { [EOL]     int i; [EOL]     if (_inputPtr < (_inputEnd - 1) && _inputBuffer[_inputPtr] == INT_COLON) { [EOL]         i = _inputBuffer[++_inputPtr]; [EOL]         ++_inputPtr; [EOL]         if (i == INT_QUOTE) { [EOL]             _tokenIncomplete = true; [EOL]             _nextToken = JsonToken.VALUE_STRING; [EOL]             return; [EOL]         } [EOL]         if (i == INT_LCURLY) { [EOL]             _nextToken = JsonToken.START_OBJECT; [EOL]             return; [EOL]         } [EOL]         if (i == INT_LBRACKET) { [EOL]             _nextToken = JsonToken.START_ARRAY; [EOL]             return; [EOL]         } [EOL]         i &= 0xFF; [EOL]         if (i <= INT_SPACE || i == INT_SLASH) { [EOL]             --_inputPtr; [EOL]             i = _skipWS(); [EOL]         } [EOL]     } else { [EOL]         i = _skipColon(); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             _nextToken = JsonToken.VALUE_STRING; [EOL]             return; [EOL]         case INT_LBRACKET: [EOL]             _nextToken = JsonToken.START_ARRAY; [EOL]             return; [EOL]         case INT_LCURLY: [EOL]             _nextToken = JsonToken.START_OBJECT; [EOL]             return; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             _nextToken = JsonToken.VALUE_TRUE; [EOL]             return; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             _nextToken = JsonToken.VALUE_FALSE; [EOL]             return; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             _nextToken = JsonToken.VALUE_NULL; [EOL]             return; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             _nextToken = parseNumberText(i); [EOL]             return; [EOL]     } [EOL]     _nextToken = _handleUnexpectedValue(i); [EOL] } <line_num>: 902,972
private boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException, JsonParseException { [EOL]     Name n = _parseFieldName(i); [EOL]     final boolean match; [EOL]     { [EOL]         String nameStr = n.getName(); [EOL]         _parsingContext.setCurrentName(nameStr); [EOL]         match = nameStr.equals(str.getValue()); [EOL]     } [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return match; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return match; [EOL] } <line_num>: 974,1042
@Override [EOL] public String nextTextValue() throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         _nameCopied = false; [EOL]         JsonToken t = _nextToken; [EOL]         _nextToken = null; [EOL]         _currToken = t; [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             if (_tokenIncomplete) { [EOL]                 _tokenIncomplete = false; [EOL]                 _finishString(); [EOL]             } [EOL]             return _textBuffer.contentsAsString(); [EOL]         } [EOL]         if (t == JsonToken.START_ARRAY) { [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]         } else if (t == JsonToken.START_OBJECT) { [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]         } [EOL]         return null; [EOL]     } [EOL]     return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null; [EOL] } <line_num>: 1044,1070
@Override [EOL] public int nextIntValue(int defaultValue) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         _nameCopied = false; [EOL]         JsonToken t = _nextToken; [EOL]         _nextToken = null; [EOL]         _currToken = t; [EOL]         if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]             return getIntValue(); [EOL]         } [EOL]         if (t == JsonToken.START_ARRAY) { [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]         } else if (t == JsonToken.START_OBJECT) { [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]         } [EOL]         return defaultValue; [EOL]     } [EOL]     return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue; [EOL] } <line_num>: 1072,1094
@Override [EOL] public long nextLongValue(long defaultValue) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         _nameCopied = false; [EOL]         JsonToken t = _nextToken; [EOL]         _nextToken = null; [EOL]         _currToken = t; [EOL]         if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]             return getLongValue(); [EOL]         } [EOL]         if (t == JsonToken.START_ARRAY) { [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]         } else if (t == JsonToken.START_OBJECT) { [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]         } [EOL]         return defaultValue; [EOL]     } [EOL]     return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue; [EOL] } <line_num>: 1096,1118
@Override [EOL] public Boolean nextBooleanValue() throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         _nameCopied = false; [EOL]         JsonToken t = _nextToken; [EOL]         _nextToken = null; [EOL]         _currToken = t; [EOL]         if (t == JsonToken.VALUE_TRUE) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if (t == JsonToken.VALUE_FALSE) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (t == JsonToken.START_ARRAY) { [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]         } else if (t == JsonToken.START_OBJECT) { [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]         } [EOL]         return null; [EOL]     } [EOL]     switch(nextToken()) { [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         default: [EOL]             return null; [EOL]     } [EOL] } <line_num>: 1120,1151
protected JsonToken parseNumberText(int c) throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = 0; [EOL]     boolean negative = (c == INT_MINUS); [EOL]     if (negative) { [EOL]         outBuf[outPtr++] = '-'; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             return _handleInvalidNumberStart(c, true); [EOL]         } [EOL]     } [EOL]     if (c == INT_0) { [EOL]         c = _verifyNoLeadingZeroes(); [EOL]     } [EOL]     outBuf[outPtr++] = (char) c; [EOL]     int intLen = 1; [EOL]     int end = _inputPtr + outBuf.length; [EOL]     if (end > _inputEnd) { [EOL]         end = _inputEnd; [EOL]     } [EOL]     while (true) { [EOL]         if (_inputPtr >= end) { [EOL]             return _parserNumber2(outBuf, outPtr, negative, intLen); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             break; [EOL]         } [EOL]         ++intLen; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     if (c == '.' || c == 'e' || c == 'E') { [EOL]         return _parseFloatText(outBuf, outPtr, c, negative, intLen); [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intLen); [EOL] } <line_num>: 1175,1237
private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException { [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]             _textBuffer.setCurrentLength(outPtr); [EOL]             return resetInt(negative, intPartLength); [EOL]         } [EOL]         int c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c > INT_9 || c < INT_0) { [EOL]             if (c == '.' || c == 'e' || c == 'E') { [EOL]                 return _parseFloatText(outBuf, outPtr, c, negative, intPartLength); [EOL]             } [EOL]             break; [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]         ++intPartLength; [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intPartLength); [EOL] } <line_num>: 1243,1273
private int _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return INT_0; [EOL]     } [EOL]     int ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]     if (ch < INT_0 || ch > INT_9) { [EOL]         return INT_0; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]             if (ch < INT_0 || ch > INT_9) { [EOL]                 return INT_0; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != INT_0) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] } <line_num>: 1279,1310
private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException { [EOL]     int fractLen = 0; [EOL]     boolean eof = false; [EOL]     if (c == '.') { [EOL]         outBuf[outPtr++] = (char) c; [EOL]         fract_loop: while (true) { [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break fract_loop; [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]             if (c < INT_0 || c > INT_9) { [EOL]                 break fract_loop; [EOL]             } [EOL]             ++fractLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]         } [EOL]         if (fractLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Decimal point not followed by a digit"); [EOL]         } [EOL]     } [EOL]     int expLen = 0; [EOL]     if (c == 'e' || c == 'E') { [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c == '-' || c == '+') { [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } [EOL]         exp_loop: while (c <= INT_9 && c >= INT_0) { [EOL]             ++expLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = (char) c; [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break exp_loop; [EOL]             } [EOL]             c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } [EOL]         if (expLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Exponent indicator not followed by a digit"); [EOL]         } [EOL]     } [EOL]     if (!eof) { [EOL]         --_inputPtr; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetFloat(negative, integerPartLength, fractLen, expLen); [EOL] } <line_num>: 1312,1400
protected Name _parseFieldName(int i) throws IOException, JsonParseException { [EOL]     if (i != INT_QUOTE) { [EOL]         return _handleUnusualFieldName(i); [EOL]     } [EOL]     if ((_inputPtr + 9) > _inputEnd) { [EOL]         return slowParseFieldName(); [EOL]     } [EOL]     final byte[] input = _inputBuffer; [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     int q = input[_inputPtr++] & 0xFF; [EOL]     if (codes[q] == 0) { [EOL]         i = input[_inputPtr++] & 0xFF; [EOL]         if (codes[i] == 0) { [EOL]             q = (q << 8) | i; [EOL]             i = input[_inputPtr++] & 0xFF; [EOL]             if (codes[i] == 0) { [EOL]                 q = (q << 8) | i; [EOL]                 i = input[_inputPtr++] & 0xFF; [EOL]                 if (codes[i] == 0) { [EOL]                     q = (q << 8) | i; [EOL]                     i = input[_inputPtr++] & 0xFF; [EOL]                     if (codes[i] == 0) { [EOL]                         _quad1 = q; [EOL]                         return parseMediumFieldName(i, codes); [EOL]                     } [EOL]                     if (i == INT_QUOTE) { [EOL]                         return findName(q, 4); [EOL]                     } [EOL]                     return parseFieldName(q, i, 4); [EOL]                 } [EOL]                 if (i == INT_QUOTE) { [EOL]                     return findName(q, 3); [EOL]                 } [EOL]                 return parseFieldName(q, i, 3); [EOL]             } [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(q, 2); [EOL]             } [EOL]             return parseFieldName(q, i, 2); [EOL]         } [EOL]         if (i == INT_QUOTE) { [EOL]             return findName(q, 1); [EOL]         } [EOL]         return parseFieldName(q, i, 1); [EOL]     } [EOL]     if (q == INT_QUOTE) { [EOL]         return BytesToNameCanonicalizer.getEmptyName(); [EOL]     } [EOL]     return parseFieldName(0, q, 0); [EOL] } <line_num>: 1408,1469
protected Name parseMediumFieldName(int q2, final int[] codes) throws IOException, JsonParseException { [EOL]     int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (codes[i] != 0) { [EOL]         if (i == INT_QUOTE) { [EOL]             return findName(_quad1, q2, 1); [EOL]         } [EOL]         return parseFieldName(_quad1, q2, i, 1); [EOL]     } [EOL]     q2 = (q2 << 8) | i; [EOL]     i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (codes[i] != 0) { [EOL]         if (i == INT_QUOTE) { [EOL]             return findName(_quad1, q2, 2); [EOL]         } [EOL]         return parseFieldName(_quad1, q2, i, 2); [EOL]     } [EOL]     q2 = (q2 << 8) | i; [EOL]     i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (codes[i] != 0) { [EOL]         if (i == INT_QUOTE) { [EOL]             return findName(_quad1, q2, 3); [EOL]         } [EOL]         return parseFieldName(_quad1, q2, i, 3); [EOL]     } [EOL]     q2 = (q2 << 8) | i; [EOL]     i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (codes[i] != 0) { [EOL]         if (i == INT_QUOTE) { [EOL]             return findName(_quad1, q2, 4); [EOL]         } [EOL]         return parseFieldName(_quad1, q2, i, 4); [EOL]     } [EOL]     _quadBuffer[0] = _quad1; [EOL]     _quadBuffer[1] = q2; [EOL]     return parseLongFieldName(i); [EOL] } <line_num>: 1471,1509
protected Name parseLongFieldName(int q) throws IOException, JsonParseException { [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     int qlen = 2; [EOL]     while (true) { [EOL]         if ((_inputEnd - _inputPtr) < 4) { [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0); [EOL]         } [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 1); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 2); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 3); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3); [EOL]         } [EOL]         q = (q << 8) | i; [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (codes[i] != 0) { [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(_quadBuffer, qlen, q, 4); [EOL]             } [EOL]             return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4); [EOL]         } [EOL]         if (qlen >= _quadBuffer.length) { [EOL]             _quadBuffer = growArrayBy(_quadBuffer, qlen); [EOL]         } [EOL]         _quadBuffer[qlen++] = q; [EOL]         q = i; [EOL]     } [EOL] } <line_num>: 1511,1570
protected Name slowParseFieldName() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(": was expecting closing '\"' for name"); [EOL]         } [EOL]     } [EOL]     int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (i == INT_QUOTE) { [EOL]         return BytesToNameCanonicalizer.getEmptyName(); [EOL]     } [EOL]     return parseEscapedFieldName(_quadBuffer, 0, 0, i, 0); [EOL] } <line_num>: 1577,1590
private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException { [EOL]     return parseEscapedFieldName(_quadBuffer, 0, q1, ch, lastQuadBytes); [EOL] } <line_num>: 1592,1596
private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes) throws IOException, JsonParseException { [EOL]     _quadBuffer[0] = q1; [EOL]     return parseEscapedFieldName(_quadBuffer, 1, q2, ch, lastQuadBytes); [EOL] } <line_num>: 1598,1603
protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException { [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     while (true) { [EOL]         if (codes[ch] != 0) { [EOL]             if (ch == INT_QUOTE) { [EOL]                 break; [EOL]             } [EOL]             if (ch != INT_BACKSLASH) { [EOL]                 _throwUnquotedSpace(ch, "name"); [EOL]             } else { [EOL]                 ch = _decodeEscaped(); [EOL]             } [EOL]             if (ch > 127) { [EOL]                 if (currQuadBytes >= 4) { [EOL]                     if (qlen >= quads.length) { [EOL]                         _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]                     } [EOL]                     quads[qlen++] = currQuad; [EOL]                     currQuad = 0; [EOL]                     currQuadBytes = 0; [EOL]                 } [EOL]                 if (ch < 0x800) { [EOL]                     currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); [EOL]                     ++currQuadBytes; [EOL]                 } else { [EOL]                     currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); [EOL]                     ++currQuadBytes; [EOL]                     if (currQuadBytes >= 4) { [EOL]                         if (qlen >= quads.length) { [EOL]                             _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]                         } [EOL]                         quads[qlen++] = currQuad; [EOL]                         currQuad = 0; [EOL]                         currQuadBytes = 0; [EOL]                     } [EOL]                     currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); [EOL]                     ++currQuadBytes; [EOL]                 } [EOL]                 ch = 0x80 | (ch & 0x3f); [EOL]             } [EOL]         } [EOL]         if (currQuadBytes < 4) { [EOL]             ++currQuadBytes; [EOL]             currQuad = (currQuad << 8) | ch; [EOL]         } else { [EOL]             if (qlen >= quads.length) { [EOL]                 _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]             } [EOL]             quads[qlen++] = currQuad; [EOL]             currQuad = ch; [EOL]             currQuadBytes = 1; [EOL]         } [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     } [EOL]     if (currQuadBytes > 0) { [EOL]         if (qlen >= quads.length) { [EOL]             _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]         } [EOL]         quads[qlen++] = currQuad; [EOL]     } [EOL]     Name name = _symbols.findName(quads, qlen); [EOL]     if (name == null) { [EOL]         name = addName(quads, qlen, currQuadBytes); [EOL]     } [EOL]     return name; [EOL] } <line_num>: 1612,1705
protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException { [EOL]     if (ch == INT_APOSTROPHE && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]         return _parseApostropheFieldName(); [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { [EOL]         _reportUnexpectedChar(ch, "was expecting double-quote to start field name"); [EOL]     } [EOL]     final int[] codes = CharTypes.getInputCodeUtf8JsNames(); [EOL]     if (codes[ch] != 0) { [EOL]         _reportUnexpectedChar(ch, "was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"); [EOL]     } [EOL]     int[] quads = _quadBuffer; [EOL]     int qlen = 0; [EOL]     int currQuad = 0; [EOL]     int currQuadBytes = 0; [EOL]     while (true) { [EOL]         if (currQuadBytes < 4) { [EOL]             ++currQuadBytes; [EOL]             currQuad = (currQuad << 8) | ch; [EOL]         } else { [EOL]             if (qlen >= quads.length) { [EOL]                 _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]             } [EOL]             quads[qlen++] = currQuad; [EOL]             currQuad = ch; [EOL]             currQuadBytes = 1; [EOL]         } [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]         if (codes[ch] != 0) { [EOL]             break; [EOL]         } [EOL]         ++_inputPtr; [EOL]     } [EOL]     if (currQuadBytes > 0) { [EOL]         if (qlen >= quads.length) { [EOL]             _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]         } [EOL]         quads[qlen++] = currQuad; [EOL]     } [EOL]     Name name = _symbols.findName(quads, qlen); [EOL]     if (name == null) { [EOL]         name = addName(quads, qlen, currQuadBytes); [EOL]     } [EOL]     return name; [EOL] } <line_num>: 1713,1779
protected Name _parseApostropheFieldName() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(": was expecting closing '\'' for name"); [EOL]         } [EOL]     } [EOL]     int ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (ch == INT_APOSTROPHE) { [EOL]         return BytesToNameCanonicalizer.getEmptyName(); [EOL]     } [EOL]     int[] quads = _quadBuffer; [EOL]     int qlen = 0; [EOL]     int currQuad = 0; [EOL]     int currQuadBytes = 0; [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     while (true) { [EOL]         if (ch == INT_APOSTROPHE) { [EOL]             break; [EOL]         } [EOL]         if (ch != INT_QUOTE && codes[ch] != 0) { [EOL]             if (ch != INT_BACKSLASH) { [EOL]                 _throwUnquotedSpace(ch, "name"); [EOL]             } else { [EOL]                 ch = _decodeEscaped(); [EOL]             } [EOL]             if (ch > 127) { [EOL]                 if (currQuadBytes >= 4) { [EOL]                     if (qlen >= quads.length) { [EOL]                         _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]                     } [EOL]                     quads[qlen++] = currQuad; [EOL]                     currQuad = 0; [EOL]                     currQuadBytes = 0; [EOL]                 } [EOL]                 if (ch < 0x800) { [EOL]                     currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); [EOL]                     ++currQuadBytes; [EOL]                 } else { [EOL]                     currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); [EOL]                     ++currQuadBytes; [EOL]                     if (currQuadBytes >= 4) { [EOL]                         if (qlen >= quads.length) { [EOL]                             _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]                         } [EOL]                         quads[qlen++] = currQuad; [EOL]                         currQuad = 0; [EOL]                         currQuadBytes = 0; [EOL]                     } [EOL]                     currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); [EOL]                     ++currQuadBytes; [EOL]                 } [EOL]                 ch = 0x80 | (ch & 0x3f); [EOL]             } [EOL]         } [EOL]         if (currQuadBytes < 4) { [EOL]             ++currQuadBytes; [EOL]             currQuad = (currQuad << 8) | ch; [EOL]         } else { [EOL]             if (qlen >= quads.length) { [EOL]                 _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]             } [EOL]             quads[qlen++] = currQuad; [EOL]             currQuad = ch; [EOL]             currQuadBytes = 1; [EOL]         } [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     } [EOL]     if (currQuadBytes > 0) { [EOL]         if (qlen >= quads.length) { [EOL]             _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]         } [EOL]         quads[qlen++] = currQuad; [EOL]     } [EOL]     Name name = _symbols.findName(quads, qlen); [EOL]     if (name == null) { [EOL]         name = addName(quads, qlen, currQuadBytes); [EOL]     } [EOL]     return name; [EOL] } <line_num>: 1786,1890
private Name findName(int q1, int lastQuadBytes) throws JsonParseException { [EOL]     Name name = _symbols.findName(q1); [EOL]     if (name != null) { [EOL]         return name; [EOL]     } [EOL]     _quadBuffer[0] = q1; [EOL]     return addName(_quadBuffer, 1, lastQuadBytes); [EOL] } <line_num>: 1898,1909
private Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException { [EOL]     Name name = _symbols.findName(q1, q2); [EOL]     if (name != null) { [EOL]         return name; [EOL]     } [EOL]     _quadBuffer[0] = q1; [EOL]     _quadBuffer[1] = q2; [EOL]     return addName(_quadBuffer, 2, lastQuadBytes); [EOL] } <line_num>: 1911,1923
private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException { [EOL]     if (qlen >= quads.length) { [EOL]         _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]     } [EOL]     quads[qlen++] = lastQuad; [EOL]     Name name = _symbols.findName(quads, qlen); [EOL]     if (name == null) { [EOL]         return addName(quads, qlen, lastQuadBytes); [EOL]     } [EOL]     return name; [EOL] } <line_num>: 1925,1937
private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { [EOL]     int byteLen = (qlen << 2) - 4 + lastQuadBytes; [EOL]     int lastQuad; [EOL]     if (lastQuadBytes < 4) { [EOL]         lastQuad = quads[qlen - 1]; [EOL]         quads[qlen - 1] = (lastQuad << ((4 - lastQuadBytes) << 3)); [EOL]     } else { [EOL]         lastQuad = 0; [EOL]     } [EOL]     char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int cix = 0; [EOL]     for (int ix = 0; ix < byteLen; ) { [EOL]         int ch = quads[ix >> 2]; [EOL]         int byteIx = (ix & 3); [EOL]         ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; [EOL]         ++ix; [EOL]         if (ch > 127) { [EOL]             int needed; [EOL]             if ((ch & 0xE0) == 0xC0) { [EOL]                 ch &= 0x1F; [EOL]                 needed = 1; [EOL]             } else if ((ch & 0xF0) == 0xE0) { [EOL]                 ch &= 0x0F; [EOL]                 needed = 2; [EOL]             } else if ((ch & 0xF8) == 0xF0) { [EOL]                 ch &= 0x07; [EOL]                 needed = 3; [EOL]             } else { [EOL]                 _reportInvalidInitial(ch); [EOL]                 needed = ch = 1; [EOL]             } [EOL]             if ((ix + needed) > byteLen) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]             int ch2 = quads[ix >> 2]; [EOL]             byteIx = (ix & 3); [EOL]             ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]             ++ix; [EOL]             if ((ch2 & 0xC0) != 0x080) { [EOL]                 _reportInvalidOther(ch2); [EOL]             } [EOL]             ch = (ch << 6) | (ch2 & 0x3F); [EOL]             if (needed > 1) { [EOL]                 ch2 = quads[ix >> 2]; [EOL]                 byteIx = (ix & 3); [EOL]                 ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                 ++ix; [EOL]                 if ((ch2 & 0xC0) != 0x080) { [EOL]                     _reportInvalidOther(ch2); [EOL]                 } [EOL]                 ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 if (needed > 2) { [EOL]                     ch2 = quads[ix >> 2]; [EOL]                     byteIx = (ix & 3); [EOL]                     ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                     ++ix; [EOL]                     if ((ch2 & 0xC0) != 0x080) { [EOL]                         _reportInvalidOther(ch2 & 0xFF); [EOL]                     } [EOL]                     ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 } [EOL]             } [EOL]             if (needed > 2) { [EOL]                 ch -= 0x10000; [EOL]                 if (cix >= cbuf.length) { [EOL]                     cbuf = _textBuffer.expandCurrentSegment(); [EOL]                 } [EOL]                 cbuf[cix++] = (char) (0xD800 + (ch >> 10)); [EOL]                 ch = 0xDC00 | (ch & 0x03FF); [EOL]             } [EOL]         } [EOL]         if (cix >= cbuf.length) { [EOL]             cbuf = _textBuffer.expandCurrentSegment(); [EOL]         } [EOL]         cbuf[cix++] = (char) ch; [EOL]     } [EOL]     String baseName = new String(cbuf, 0, cix); [EOL]     if (lastQuadBytes < 4) { [EOL]         quads[qlen - 1] = lastQuad; [EOL]     } [EOL]     return _symbols.addName(baseName, quads, qlen); [EOL] } <line_num>: 1945,2052
@Override [EOL] protected void _finishString() throws IOException, JsonParseException { [EOL]     int ptr = _inputPtr; [EOL]     if (ptr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]         ptr = _inputPtr; [EOL]     } [EOL]     int outPtr = 0; [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final int max = Math.min(_inputEnd, (ptr + outBuf.length)); [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     while (ptr < max) { [EOL]         int c = (int) inputBuffer[ptr] & 0xFF; [EOL]         if (codes[c] != 0) { [EOL]             if (c == INT_QUOTE) { [EOL]                 _inputPtr = ptr + 1; [EOL]                 _textBuffer.setCurrentLength(outPtr); [EOL]                 return; [EOL]             } [EOL]             break; [EOL]         } [EOL]         ++ptr; [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _inputPtr = ptr; [EOL]     _finishString2(outBuf, outPtr); [EOL] } <line_num>: 2060,2091
private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException { [EOL]     int c; [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     main_loop: while (true) { [EOL]         ascii_loop: while (true) { [EOL]             int ptr = _inputPtr; [EOL]             if (ptr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]                 ptr = _inputPtr; [EOL]             } [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); [EOL]             while (ptr < max) { [EOL]                 c = (int) inputBuffer[ptr++] & 0xFF; [EOL]                 if (codes[c] != 0) { [EOL]                     _inputPtr = ptr; [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (char) c; [EOL]             } [EOL]             _inputPtr = ptr; [EOL]         } [EOL]         if (c == INT_QUOTE) { [EOL]             break main_loop; [EOL]         } [EOL]         switch(codes[c]) { [EOL]             case 1: [EOL]                 c = _decodeEscaped(); [EOL]                 break; [EOL]             case 2: [EOL]                 c = _decodeUtf8_2(c); [EOL]                 break; [EOL]             case 3: [EOL]                 if ((_inputEnd - _inputPtr) >= 2) { [EOL]                     c = _decodeUtf8_3fast(c); [EOL]                 } else { [EOL]                     c = _decodeUtf8_3(c); [EOL]                 } [EOL]                 break; [EOL]             case 4: [EOL]                 c = _decodeUtf8_4(c); [EOL]                 outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL]                 if (outPtr >= outBuf.length) { [EOL]                     outBuf = _textBuffer.finishCurrentSegment(); [EOL]                     outPtr = 0; [EOL]                 } [EOL]                 c = 0xDC00 | (c & 0x3FF); [EOL]                 break; [EOL]             default: [EOL]                 if (c < INT_SPACE) { [EOL]                     _throwUnquotedSpace(c, "string value"); [EOL]                 } else { [EOL]                     _reportInvalidChar(c); [EOL]                 } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL] } <line_num>: 2093,2175
protected void _skipString() throws IOException, JsonParseException { [EOL]     _tokenIncomplete = false; [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     main_loop: while (true) { [EOL]         int c; [EOL]         ascii_loop: while (true) { [EOL]             int ptr = _inputPtr; [EOL]             int max = _inputEnd; [EOL]             if (ptr >= max) { [EOL]                 loadMoreGuaranteed(); [EOL]                 ptr = _inputPtr; [EOL]                 max = _inputEnd; [EOL]             } [EOL]             while (ptr < max) { [EOL]                 c = (int) inputBuffer[ptr++] & 0xFF; [EOL]                 if (codes[c] != 0) { [EOL]                     _inputPtr = ptr; [EOL]                     break ascii_loop; [EOL]                 } [EOL]             } [EOL]             _inputPtr = ptr; [EOL]         } [EOL]         if (c == INT_QUOTE) { [EOL]             break main_loop; [EOL]         } [EOL]         switch(codes[c]) { [EOL]             case 1: [EOL]                 _decodeEscaped(); [EOL]                 break; [EOL]             case 2: [EOL]                 _skipUtf8_2(c); [EOL]                 break; [EOL]             case 3: [EOL]                 _skipUtf8_3(c); [EOL]                 break; [EOL]             case 4: [EOL]                 _skipUtf8_4(c); [EOL]                 break; [EOL]             default: [EOL]                 if (c < INT_SPACE) { [EOL]                     _throwUnquotedSpace(c, "string value"); [EOL]                 } else { [EOL]                     _reportInvalidChar(c); [EOL]                 } [EOL]         } [EOL]     } [EOL] } <line_num>: 2182,2241
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] } <line_num>: 2247,2286
protected JsonToken _handleApostropheValue() throws IOException, JsonParseException { [EOL]     int c = 0; [EOL]     int outPtr = 0; [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     main_loop: while (true) { [EOL]         ascii_loop: while (true) { [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             int max = _inputEnd; [EOL]             { [EOL]                 int max2 = _inputPtr + (outBuf.length - outPtr); [EOL]                 if (max2 < max) { [EOL]                     max = max2; [EOL]                 } [EOL]             } [EOL]             while (_inputPtr < max) { [EOL]                 c = (int) inputBuffer[_inputPtr++] & 0xFF; [EOL]                 if (c == INT_APOSTROPHE || codes[c] != 0) { [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (char) c; [EOL]             } [EOL]         } [EOL]         if (c == INT_APOSTROPHE) { [EOL]             break main_loop; [EOL]         } [EOL]         switch(codes[c]) { [EOL]             case 1: [EOL]                 if (c != INT_QUOTE) { [EOL]                     c = _decodeEscaped(); [EOL]                 } [EOL]                 break; [EOL]             case 2: [EOL]                 c = _decodeUtf8_2(c); [EOL]                 break; [EOL]             case 3: [EOL]                 if ((_inputEnd - _inputPtr) >= 2) { [EOL]                     c = _decodeUtf8_3fast(c); [EOL]                 } else { [EOL]                     c = _decodeUtf8_3(c); [EOL]                 } [EOL]                 break; [EOL]             case 4: [EOL]                 c = _decodeUtf8_4(c); [EOL]                 outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL]                 if (outPtr >= outBuf.length) { [EOL]                     outBuf = _textBuffer.finishCurrentSegment(); [EOL]                     outPtr = 0; [EOL]                 } [EOL]                 c = 0xDC00 | (c & 0x3FF); [EOL]                 break; [EOL]             default: [EOL]                 if (c < INT_SPACE) { [EOL]                     _throwUnquotedSpace(c, "string value"); [EOL]                 } [EOL]                 _reportInvalidChar(c); [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return JsonToken.VALUE_STRING; [EOL] } <line_num>: 2288,2378
protected JsonToken _handleInvalidNumberStart(int ch, boolean neg) throws IOException, JsonParseException { [EOL]     while (ch == 'I') { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOFInValue(); [EOL]             } [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         String match; [EOL]         if (ch == 'N') { [EOL]             match = neg ? "-INF" : "+INF"; [EOL]         } else if (ch == 'n') { [EOL]             match = neg ? "-Infinity" : "+Infinity"; [EOL]         } else { [EOL]             break; [EOL]         } [EOL]         _matchToken(match, 3); [EOL]         if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]             return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); [EOL]         } [EOL]         _reportError("Non-standard token '" + match + "': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]     } [EOL]     reportUnexpectedNumberChar(ch, "expected digit (0-9) to follow minus sign, for valid numeric value"); [EOL]     return null; [EOL] } <line_num>: 2384,2410
protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException { [EOL]     final int len = matchStr.length(); [EOL]     do { [EOL]         if (((_inputPtr >= _inputEnd) && !loadMore()) || (_inputBuffer[_inputPtr] != matchStr.charAt(i))) { [EOL]             _reportInvalidToken(matchStr.substring(0, i)); [EOL]         } [EOL]         ++_inputPtr; [EOL]     } while (++i < len); [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return; [EOL]     } [EOL]     int ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]     if (ch < '0' || ch == ']' || ch == '}') { [EOL]         return; [EOL]     } [EOL]     char c = (char) _decodeCharForError(ch); [EOL]     if (Character.isJavaIdentifierPart(c)) { [EOL]         _reportInvalidToken(matchStr.substring(0, i)); [EOL]     } [EOL] } <line_num>: 2412,2438
protected void _reportInvalidToken(String matchedPart) throws IOException, JsonParseException { [EOL]     _reportInvalidToken(matchedPart, "'null', 'true', 'false' or NaN"); [EOL] } <line_num>: 2440,2444
protected void _reportInvalidToken(String matchedPart, String msg) throws IOException, JsonParseException { [EOL]     StringBuilder sb = new StringBuilder(matchedPart); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]             break; [EOL]         } [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         char c = (char) _decodeCharForError(i); [EOL]         if (!Character.isJavaIdentifierPart(c)) { [EOL]             break; [EOL]         } [EOL]         sb.append(c); [EOL]     } [EOL]     _reportError("Unrecognized token '" + sb.toString() + "': was expecting " + msg); [EOL] } <line_num>: 2446,2467
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] } <line_num>: 2475,2496
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] } <line_num>: 2498,2521
private int _skipColon() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     int i = _inputBuffer[_inputPtr++]; [EOL]     if (i == INT_COLON) { [EOL]         if (_inputPtr < _inputEnd) { [EOL]             i = _inputBuffer[_inputPtr] & 0xFF; [EOL]             if (i > INT_SPACE && i != INT_SLASH) { [EOL]                 ++_inputPtr; [EOL]                 return i; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         i &= 0xFF; [EOL]         space_loop: while (true) { [EOL]             switch(i) { [EOL]                 case INT_SPACE: [EOL]                 case INT_TAB: [EOL]                     break; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     break; [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     break; [EOL]                 case INT_SLASH: [EOL]                     _skipComment(); [EOL]                     break; [EOL]                 default: [EOL]                     if (i < INT_SPACE) { [EOL]                         _throwInvalidSpace(i); [EOL]                     } [EOL]                     break space_loop; [EOL]             } [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]     } [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] } <line_num>: 2527,2597
private void _skipComment() throws IOException, JsonParseException { [EOL]     if (!isEnabled(Feature.ALLOW_COMMENTS)) { [EOL]         _reportUnexpectedChar('/', "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)"); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         _reportInvalidEOF(" in a comment"); [EOL]     } [EOL]     int c = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (c == INT_SLASH) { [EOL]         _skipCppComment(); [EOL]     } else if (c == INT_ASTERISK) { [EOL]         _skipCComment(); [EOL]     } else { [EOL]         _reportUnexpectedChar(c, "was expecting either '*' or '/' for a comment"); [EOL]     } [EOL] } <line_num>: 2599,2617
private void _skipCComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     main_loop: while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_ASTERISK: [EOL]                     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                         break main_loop; [EOL]                     } [EOL]                     if (_inputBuffer[_inputPtr] == INT_SLASH) { [EOL]                         ++_inputPtr; [EOL]                         return; [EOL]                     } [EOL]                     break; [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     break; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _reportInvalidEOF(" in a comment"); [EOL] } <line_num>: 2619,2663
private void _skipCppComment() throws IOException, JsonParseException { [EOL]     final int[] codes = CharTypes.getInputCodeComment(); [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         int code = codes[i]; [EOL]         if (code != 0) { [EOL]             switch(code) { [EOL]                 case INT_LF: [EOL]                     _skipLF(); [EOL]                     return; [EOL]                 case INT_CR: [EOL]                     _skipCR(); [EOL]                     return; [EOL]                 case INT_ASTERISK: [EOL]                     break; [EOL]                 case 2: [EOL]                     _skipUtf8_2(i); [EOL]                     break; [EOL]                 case 3: [EOL]                     _skipUtf8_3(i); [EOL]                     break; [EOL]                 case 4: [EOL]                     _skipUtf8_4(i); [EOL]                     break; [EOL]                 default: [EOL]                     _reportInvalidChar(i); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 2665,2698
@Override [EOL] protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(" in character escape sequence"); [EOL]         } [EOL]     } [EOL]     int c = (int) _inputBuffer[_inputPtr++]; [EOL]     switch((int) c) { [EOL]         case INT_b: [EOL]             return '\b'; [EOL]         case INT_t: [EOL]             return '\t'; [EOL]         case INT_n: [EOL]             return '\n'; [EOL]         case INT_f: [EOL]             return '\f'; [EOL]         case INT_r: [EOL]             return '\r'; [EOL]         case INT_QUOTE: [EOL]         case INT_SLASH: [EOL]         case INT_BACKSLASH: [EOL]             return (char) c; [EOL]         case INT_u: [EOL]             break; [EOL]         default: [EOL]             return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c)); [EOL]     } [EOL]     int value = 0; [EOL]     for (int i = 0; i < 4; ++i) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in character escape sequence"); [EOL]             } [EOL]         } [EOL]         int ch = (int) _inputBuffer[_inputPtr++]; [EOL]         int digit = CharTypes.charToHex(ch); [EOL]         if (digit < 0) { [EOL]             _reportUnexpectedChar(ch, "expected a hex-digit for character escape sequence"); [EOL]         } [EOL]         value = (value << 4) | digit; [EOL]     } [EOL]     return (char) value; [EOL] } <line_num>: 2700,2753
protected int _decodeCharForError(int firstByte) throws IOException, JsonParseException { [EOL]     int c = (int) firstByte; [EOL]     if (c < 0) { [EOL]         int needed; [EOL]         if ((c & 0xE0) == 0xC0) { [EOL]             c &= 0x1F; [EOL]             needed = 1; [EOL]         } else if ((c & 0xF0) == 0xE0) { [EOL]             c &= 0x0F; [EOL]             needed = 2; [EOL]         } else if ((c & 0xF8) == 0xF0) { [EOL]             c &= 0x07; [EOL]             needed = 3; [EOL]         } else { [EOL]             _reportInvalidInitial(c & 0xFF); [EOL]             needed = 1; [EOL]         } [EOL]         int d = nextByte(); [EOL]         if ((d & 0xC0) != 0x080) { [EOL]             _reportInvalidOther(d & 0xFF); [EOL]         } [EOL]         c = (c << 6) | (d & 0x3F); [EOL]         if (needed > 1) { [EOL]             d = nextByte(); [EOL]             if ((d & 0xC0) != 0x080) { [EOL]                 _reportInvalidOther(d & 0xFF); [EOL]             } [EOL]             c = (c << 6) | (d & 0x3F); [EOL]             if (needed > 2) { [EOL]                 d = nextByte(); [EOL]                 if ((d & 0xC0) != 0x080) { [EOL]                     _reportInvalidOther(d & 0xFF); [EOL]                 } [EOL]                 c = (c << 6) | (d & 0x3F); [EOL]             } [EOL]         } [EOL]     } [EOL]     return c; [EOL] } <line_num>: 2755,2800
private int _decodeUtf8_2(int c) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     return ((c & 0x1F) << 6) | (d & 0x3F); [EOL] } <line_num>: 2808,2819
private int _decodeUtf8_3(int c1) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     c1 &= 0x0F; [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     int c = (c1 << 6) | (d & 0x3F); [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = (c << 6) | (d & 0x3F); [EOL]     return c; [EOL] } <line_num>: 2821,2842
private int _decodeUtf8_3fast(int c1) throws IOException, JsonParseException { [EOL]     c1 &= 0x0F; [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     int c = (c1 << 6) | (d & 0x3F); [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = (c << 6) | (d & 0x3F); [EOL]     return c; [EOL] } <line_num>: 2844,2859
private int _decodeUtf8_4(int c) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = ((c & 0x07) << 6) | (d & 0x3F); [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     c = (c << 6) | (d & 0x3F); [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     return ((c << 6) | (d & 0x3F)) - 0x10000; [EOL] } <line_num>: 2865,2897
private void _skipUtf8_2(int c) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     c = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((c & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(c & 0xFF, _inputPtr); [EOL]     } [EOL] } <line_num>: 2899,2909
private void _skipUtf8_3(int c) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     c = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((c & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(c & 0xFF, _inputPtr); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     c = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((c & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(c & 0xFF, _inputPtr); [EOL]     } [EOL] } <line_num>: 2914,2932
private void _skipUtf8_4(int c) throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     int d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     d = (int) _inputBuffer[_inputPtr++]; [EOL]     if ((d & 0xC0) != 0x080) { [EOL]         _reportInvalidOther(d & 0xFF, _inputPtr); [EOL]     } [EOL] } <line_num>: 2934,2958
protected void _skipCR() throws IOException { [EOL]     if (_inputPtr < _inputEnd || loadMore()) { [EOL]         if (_inputBuffer[_inputPtr] == BYTE_LF) { [EOL]             ++_inputPtr; [EOL]         } [EOL]     } [EOL]     ++_currInputRow; [EOL]     _currInputRowStart = _inputPtr; [EOL] } <line_num>: 2970,2979
protected void _skipLF() throws IOException { [EOL]     ++_currInputRow; [EOL]     _currInputRowStart = _inputPtr; [EOL] } <line_num>: 2981,2985
private int nextByte() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         loadMoreGuaranteed(); [EOL]     } [EOL]     return _inputBuffer[_inputPtr++] & 0xFF; [EOL] } <line_num>: 2987,2994
protected void _reportInvalidChar(int c) throws JsonParseException { [EOL]     if (c < INT_SPACE) { [EOL]         _throwInvalidSpace(c); [EOL]     } [EOL]     _reportInvalidInitial(c); [EOL] } <line_num>: 3002,3010
protected void _reportInvalidInitial(int mask) throws JsonParseException { [EOL]     _reportError("Invalid UTF-8 start byte 0x" + Integer.toHexString(mask)); [EOL] } <line_num>: 3012,3016
protected void _reportInvalidOther(int mask) throws JsonParseException { [EOL]     _reportError("Invalid UTF-8 middle byte 0x" + Integer.toHexString(mask)); [EOL] } <line_num>: 3018,3022
protected void _reportInvalidOther(int mask, int ptr) throws JsonParseException { [EOL]     _inputPtr = ptr; [EOL]     _reportInvalidOther(mask); [EOL] } <line_num>: 3024,3029
public static int[] growArrayBy(int[] arr, int more) { [EOL]     if (arr == null) { [EOL]         return new int[more]; [EOL]     } [EOL]     return Arrays.copyOf(arr, arr.length + more); [EOL] } <line_num>: 3031,3037
@SuppressWarnings("resource") [EOL] protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException { [EOL]     ByteArrayBuilder builder = _getByteArrayBuilder(); [EOL]     while (true) { [EOL]         int ch; [EOL]         do { [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             ch = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (ch == INT_QUOTE) { [EOL]                 return builder.toByteArray(); [EOL]             } [EOL]             bits = _decodeBase64Escape(b64variant, ch, 0); [EOL]             if (bits < 0) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             bits = _decodeBase64Escape(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 4; [EOL]                     builder.append(decodedData); [EOL]                     return builder.toByteArray(); [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 2); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (_inputPtr >= _inputEnd) { [EOL]                     loadMoreGuaranteed(); [EOL]                 } [EOL]                 ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]                 if (!b64variant.usesPaddingChar(ch)) { [EOL]                     throw reportInvalidBase64Char(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL]                 } [EOL]                 decodedData >>= 4; [EOL]                 builder.append(decodedData); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 2; [EOL]                     builder.appendTwoBytes(decodedData); [EOL]                     return builder.toByteArray(); [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 3); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 decodedData >>= 2; [EOL]                 builder.appendTwoBytes(decodedData); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         builder.appendThreeBytes(decodedData); [EOL]     } [EOL] } <line_num>: 3049,3156
