public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec, Writer w) { [EOL]     super(ctxt, features, codec); [EOL]     _writer = w; [EOL]     _outputBuffer = ctxt.allocConcatBuffer(); [EOL]     _outputEnd = _outputBuffer.length; [EOL] } <line_num>: 71,78
@Override [EOL] public Object getOutputTarget() { [EOL]     return _writer; [EOL] } <line_num>: 86,89
@Override [EOL] public void writeFieldName(String name) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeFieldName(name); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { [EOL]         _reportError("Can not write a field name, expecting a value"); [EOL]     } [EOL]     _writeFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA)); [EOL] } <line_num>: 97,105
@Override [EOL] public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeFieldName(name.getValue()); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { [EOL]         _reportError("Can not write a field name, expecting a value"); [EOL]     } [EOL]     _writeFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA)); [EOL] } <line_num>: 107,117
@Override [EOL] public void writeStartArray() throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("start an array"); [EOL]     _writeContext = _writeContext.createChildArrayContext(); [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeStartArray(this); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '['; [EOL]     } [EOL] } <line_num>: 125,138
@Override [EOL] public void writeEndArray() throws IOException, JsonGenerationException { [EOL]     if (!_writeContext.inArray()) { [EOL]         _reportError("Current context not an ARRAY but " + _writeContext.getTypeDesc()); [EOL]     } [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount()); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = ']'; [EOL]     } [EOL]     _writeContext = _writeContext.getParent(); [EOL] } <line_num>: 140,155
@Override [EOL] public void writeStartObject() throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("start an object"); [EOL]     _writeContext = _writeContext.createChildObjectContext(); [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeStartObject(this); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '{'; [EOL]     } [EOL] } <line_num>: 157,170
@Override [EOL] public void writeEndObject() throws IOException, JsonGenerationException { [EOL]     if (!_writeContext.inObject()) { [EOL]         _reportError("Current context not an object but " + _writeContext.getTypeDesc()); [EOL]     } [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount()); [EOL]     } else { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '}'; [EOL]     } [EOL]     _writeContext = _writeContext.getParent(); [EOL] } <line_num>: 172,187
protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException { [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _writePPFieldName(name, commaBefore); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 1) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     if (commaBefore) { [EOL]         _outputBuffer[_outputTail++] = ','; [EOL]     } [EOL]     if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) { [EOL]         _writeString(name); [EOL]         return; [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     _writeString(name); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL] } <line_num>: 189,221
public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException { [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _writePPFieldName(name, commaBefore); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 1) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     if (commaBefore) { [EOL]         _outputBuffer[_outputTail++] = ','; [EOL]     } [EOL]     final char[] quoted = name.asQuotedChars(); [EOL]     if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) { [EOL]         writeRaw(quoted, 0, quoted.length); [EOL]         return; [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     final int qlen = quoted.length; [EOL]     if ((_outputTail + qlen + 1) >= _outputEnd) { [EOL]         writeRaw(quoted, 0, qlen); [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '"'; [EOL]     } else { [EOL]         System.arraycopy(quoted, 0, _outputBuffer, _outputTail, qlen); [EOL]         _outputTail += qlen; [EOL]         _outputBuffer[_outputTail++] = '"'; [EOL]     } [EOL] } <line_num>: 223,261
protected void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException { [EOL]     if (commaBefore) { [EOL]         _cfgPrettyPrinter.writeObjectEntrySeparator(this); [EOL]     } else { [EOL]         _cfgPrettyPrinter.beforeObjectEntries(this); [EOL]     } [EOL]     if (isEnabled(Feature.QUOTE_FIELD_NAMES)) { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '"'; [EOL]         _writeString(name); [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '"'; [EOL]     } else { [EOL]         _writeString(name); [EOL]     } [EOL] } <line_num>: 267,289
protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException { [EOL]     if (commaBefore) { [EOL]         _cfgPrettyPrinter.writeObjectEntrySeparator(this); [EOL]     } else { [EOL]         _cfgPrettyPrinter.beforeObjectEntries(this); [EOL]     } [EOL]     final char[] quoted = name.asQuotedChars(); [EOL]     if (isEnabled(Feature.QUOTE_FIELD_NAMES)) { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '"'; [EOL]         writeRaw(quoted, 0, quoted.length); [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '"'; [EOL]     } else { [EOL]         writeRaw(quoted, 0, quoted.length); [EOL]     } [EOL] } <line_num>: 291,314
@Override [EOL] public void writeString(String text) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (text == null) { [EOL]         _writeNull(); [EOL]         return; [EOL]     } [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     _writeString(text); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL] } <line_num>: 322,341
@Override [EOL] public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     _writeString(text, offset, len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL] } <line_num>: 343,358
@Override [EOL] public void writeString(SerializableString sstr) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     char[] text = sstr.asQuotedChars(); [EOL]     final int len = text.length; [EOL]     if (len < SHORT_WRITE) { [EOL]         int room = _outputEnd - _outputTail; [EOL]         if (len > room) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         System.arraycopy(text, 0, _outputBuffer, _outputTail, len); [EOL]         _outputTail += len; [EOL]     } else { [EOL]         _flushBuffer(); [EOL]         _writer.write(text, 0, len); [EOL]     } [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL] } <line_num>: 360,389
@Override [EOL] public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException { [EOL]     _reportUnsupportedOperation(); [EOL] } <line_num>: 391,397
@Override [EOL] public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException { [EOL]     _reportUnsupportedOperation(); [EOL] } <line_num>: 399,405
@Override [EOL] public void writeRaw(String text) throws IOException, JsonGenerationException { [EOL]     int len = text.length(); [EOL]     int room = _outputEnd - _outputTail; [EOL]     if (room == 0) { [EOL]         _flushBuffer(); [EOL]         room = _outputEnd - _outputTail; [EOL]     } [EOL]     if (room >= len) { [EOL]         text.getChars(0, len, _outputBuffer, _outputTail); [EOL]         _outputTail += len; [EOL]     } else { [EOL]         writeRawLong(text); [EOL]     } [EOL] } <line_num>: 413,432
@Override [EOL] public void writeRaw(String text, int start, int len) throws IOException, JsonGenerationException { [EOL]     int room = _outputEnd - _outputTail; [EOL]     if (room < len) { [EOL]         _flushBuffer(); [EOL]         room = _outputEnd - _outputTail; [EOL]     } [EOL]     if (room >= len) { [EOL]         text.getChars(start, start + len, _outputBuffer, _outputTail); [EOL]         _outputTail += len; [EOL]     } else { [EOL]         writeRawLong(text.substring(start, start + len)); [EOL]     } [EOL] } <line_num>: 434,452
@Override [EOL] public void writeRaw(SerializableString text) throws IOException, JsonGenerationException { [EOL]     writeRaw(text.getValue()); [EOL] } <line_num>: 455,458
@Override [EOL] public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     if (len < SHORT_WRITE) { [EOL]         int room = _outputEnd - _outputTail; [EOL]         if (len > room) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         System.arraycopy(text, offset, _outputBuffer, _outputTail, len); [EOL]         _outputTail += len; [EOL]         return; [EOL]     } [EOL]     _flushBuffer(); [EOL]     _writer.write(text, offset, len); [EOL] } <line_num>: 460,477
@Override [EOL] public void writeRaw(char c) throws IOException, JsonGenerationException { [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = c; [EOL] } <line_num>: 479,487
private void writeRawLong(String text) throws IOException, JsonGenerationException { [EOL]     int room = _outputEnd - _outputTail; [EOL]     text.getChars(0, room, _outputBuffer, _outputTail); [EOL]     _outputTail += room; [EOL]     _flushBuffer(); [EOL]     int offset = room; [EOL]     int len = text.length() - room; [EOL]     while (len > _outputEnd) { [EOL]         int amount = _outputEnd; [EOL]         text.getChars(offset, offset + amount, _outputBuffer, 0); [EOL]         _outputHead = 0; [EOL]         _outputTail = amount; [EOL]         _flushBuffer(); [EOL]         offset += amount; [EOL]         len -= amount; [EOL]     } [EOL]     text.getChars(offset, offset + len, _outputBuffer, 0); [EOL]     _outputHead = 0; [EOL]     _outputTail = len; [EOL] } <line_num>: 489,513
@Override [EOL] public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write binary value"); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     _writeBinary(b64variant, data, offset, offset + len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL] } <line_num>: 521,537
@Override [EOL] public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write binary value"); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     byte[] encodingBuffer = _ioContext.allocBase64Buffer(); [EOL]     int bytes; [EOL]     try { [EOL]         if (dataLength < 0) { [EOL]             bytes = _writeBinary(b64variant, data, encodingBuffer); [EOL]         } else { [EOL]             int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength); [EOL]             if (missing > 0) { [EOL]                 _reportError("Too few bytes available: missing " + missing + " bytes (out of " + dataLength + ")"); [EOL]             } [EOL]             bytes = dataLength; [EOL]         } [EOL]     } finally { [EOL]         _ioContext.releaseBase64Buffer(encodingBuffer); [EOL]     } [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     return bytes; [EOL] } <line_num>: 539,571
@Override [EOL] public void writeNumber(short s) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedShort(s); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 6) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail); [EOL] } <line_num>: 579,593
private void _writeQuotedShort(short s) throws IOException { [EOL]     if ((_outputTail + 8) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail); [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL] } <line_num>: 595,602
@Override [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedInt(i); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 11) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); [EOL] } <line_num>: 604,618
private void _writeQuotedInt(int i) throws IOException { [EOL]     if ((_outputTail + 13) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL] } <line_num>: 620,627
@Override [EOL] public void writeNumber(long l) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedLong(l); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 21) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail); [EOL] } <line_num>: 629,643
private void _writeQuotedLong(long l) throws IOException { [EOL]     if ((_outputTail + 23) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail); [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL] } <line_num>: 645,652
@Override [EOL] public void writeNumber(BigInteger value) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if (value == null) { [EOL]         _writeNull(); [EOL]     } else if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedRaw(value); [EOL]     } else { [EOL]         writeRaw(value.toString()); [EOL]     } [EOL] } <line_num>: 656,668
@Override [EOL] public void writeNumber(double d) throws IOException, JsonGenerationException { [EOL]     if (_cfgNumbersAsStrings || (((Double.isNaN(d) || Double.isInfinite(d)) && isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS)))) { [EOL]         writeString(String.valueOf(d)); [EOL]         return; [EOL]     } [EOL]     _verifyValueWrite("write number"); [EOL]     writeRaw(String.valueOf(d)); [EOL] } <line_num>: 671,685
@Override [EOL] public void writeNumber(float f) throws IOException, JsonGenerationException { [EOL]     if (_cfgNumbersAsStrings || (((Float.isNaN(f) || Float.isInfinite(f)) && isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS)))) { [EOL]         writeString(String.valueOf(f)); [EOL]         return; [EOL]     } [EOL]     _verifyValueWrite("write number"); [EOL]     writeRaw(String.valueOf(f)); [EOL] } <line_num>: 687,701
@Override [EOL] public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if (value == null) { [EOL]         _writeNull(); [EOL]     } else if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedRaw(value); [EOL]     } else if (isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN)) { [EOL]         writeRaw(value.toPlainString()); [EOL]     } else { [EOL]         writeRaw(value.toString()); [EOL]     } [EOL] } <line_num>: 703,718
@Override [EOL] public void writeNumber(String encodedValue) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedRaw(encodedValue); [EOL]     } else { [EOL]         writeRaw(encodedValue); [EOL]     } [EOL] } <line_num>: 720,730
private void _writeQuotedRaw(Object value) throws IOException { [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     writeRaw(value.toString()); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL] } <line_num>: 732,743
@Override [EOL] public void writeBoolean(boolean state) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write boolean value"); [EOL]     if ((_outputTail + 5) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     int ptr = _outputTail; [EOL]     char[] buf = _outputBuffer; [EOL]     if (state) { [EOL]         buf[ptr] = 't'; [EOL]         buf[++ptr] = 'r'; [EOL]         buf[++ptr] = 'u'; [EOL]         buf[++ptr] = 'e'; [EOL]     } else { [EOL]         buf[ptr] = 'f'; [EOL]         buf[++ptr] = 'a'; [EOL]         buf[++ptr] = 'l'; [EOL]         buf[++ptr] = 's'; [EOL]         buf[++ptr] = 'e'; [EOL]     } [EOL]     _outputTail = ptr + 1; [EOL] } <line_num>: 745,768
@Override [EOL] public void writeNull() throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write null value"); [EOL]     _writeNull(); [EOL] } <line_num>: 770,776
@Override [EOL] protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeValue(); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL]         _reportError("Can not " + typeMsg + ", expecting field name"); [EOL]     } [EOL]     if (_cfgPrettyPrinter == null) { [EOL]         char c; [EOL]         switch(status) { [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]                 c = ','; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]                 c = ':'; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]                 if (_rootValueSeparator != null) { [EOL]                     writeRaw(_rootValueSeparator.getValue()); [EOL]                 } [EOL]                 return; [EOL]             case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             default: [EOL]                 return; [EOL]         } [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail] = c; [EOL]         ++_outputTail; [EOL]         return; [EOL]     } [EOL]     _verifyPrettyValueWrite(typeMsg, status); [EOL] } <line_num>: 784,819
protected void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException { [EOL]     switch(status) { [EOL]         case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]             _cfgPrettyPrinter.writeArrayValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]             _cfgPrettyPrinter.writeObjectFieldValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]             _cfgPrettyPrinter.writeRootValueSeparator(this); [EOL]             break; [EOL]         case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             if (_writeContext.inArray()) { [EOL]                 _cfgPrettyPrinter.beforeArrayValues(this); [EOL]             } else if (_writeContext.inObject()) { [EOL]                 _cfgPrettyPrinter.beforeObjectEntries(this); [EOL]             } [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]             break; [EOL]     } [EOL] } <line_num>: 821,847
@Override [EOL] public void flush() throws IOException { [EOL]     _flushBuffer(); [EOL]     if (_writer != null) { [EOL]         if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL]             _writer.flush(); [EOL]         } [EOL]     } [EOL] } <line_num>: 855,865
@Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     if (_outputBuffer != null && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) { [EOL]         while (true) { [EOL]             JsonStreamContext ctxt = getOutputContext(); [EOL]             if (ctxt.inArray()) { [EOL]                 writeEndArray(); [EOL]             } else if (ctxt.inObject()) { [EOL]                 writeEndObject(); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     _flushBuffer(); [EOL]     if (_writer != null) { [EOL]         if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) { [EOL]             _writer.close(); [EOL]         } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) { [EOL]             _writer.flush(); [EOL]         } [EOL]     } [EOL]     _releaseBuffers(); [EOL] } <line_num>: 867,908
@Override [EOL] protected void _releaseBuffers() { [EOL]     char[] buf = _outputBuffer; [EOL]     if (buf != null) { [EOL]         _outputBuffer = null; [EOL]         _ioContext.releaseConcatBuffer(buf); [EOL]     } [EOL] } <line_num>: 910,918
private void _writeString(String text) throws IOException, JsonGenerationException { [EOL]     final int len = text.length(); [EOL]     if (len > _outputEnd) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     text.getChars(0, len, _outputBuffer, _outputTail); [EOL]     if (_characterEscapes != null) { [EOL]         _writeStringCustom(len); [EOL]     } else if (_maximumNonEscapedChar != 0) { [EOL]         _writeStringASCII(len, _maximumNonEscapedChar); [EOL]     } else { [EOL]         _writeString2(len); [EOL]     } [EOL] } <line_num>: 926,954
private void _writeString2(final int len) throws IOException, JsonGenerationException { [EOL]     int end = _outputTail + len; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int escLen = escCodes.length; [EOL]     output_loop: while (_outputTail < end) { [EOL]         escape_loop: while (true) { [EOL]             char c = _outputBuffer[_outputTail]; [EOL]             if (c < escLen && escCodes[c] != 0) { [EOL]                 break escape_loop; [EOL]             } [EOL]             if (++_outputTail >= end) { [EOL]                 break output_loop; [EOL]             } [EOL]         } [EOL]         int flushLen = (_outputTail - _outputHead); [EOL]         if (flushLen > 0) { [EOL]             _writer.write(_outputBuffer, _outputHead, flushLen); [EOL]         } [EOL]         char c = _outputBuffer[_outputTail++]; [EOL]         _prependOrWriteCharacterEscape(c, escCodes[c]); [EOL]     } [EOL] } <line_num>: 956,992
private void _writeLongString(String text) throws IOException, JsonGenerationException { [EOL]     _flushBuffer(); [EOL]     final int textLen = text.length(); [EOL]     int offset = 0; [EOL]     do { [EOL]         int max = _outputEnd; [EOL]         int segmentLen = ((offset + max) > textLen) ? (textLen - offset) : max; [EOL]         text.getChars(offset, offset + segmentLen, _outputBuffer, 0); [EOL]         if (_characterEscapes != null) { [EOL]             _writeSegmentCustom(segmentLen); [EOL]         } else if (_maximumNonEscapedChar != 0) { [EOL]             _writeSegmentASCII(segmentLen, _maximumNonEscapedChar); [EOL]         } else { [EOL]             _writeSegment(segmentLen); [EOL]         } [EOL]         offset += segmentLen; [EOL]     } while (offset < textLen); [EOL] } <line_num>: 998,1021
private void _writeSegment(int end) throws IOException, JsonGenerationException { [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int escLen = escCodes.length; [EOL]     int ptr = 0; [EOL]     int start = ptr; [EOL]     output_loop: while (ptr < end) { [EOL]         char c; [EOL]         while (true) { [EOL]             c = _outputBuffer[ptr]; [EOL]             if (c < escLen && escCodes[c] != 0) { [EOL]                 break; [EOL]             } [EOL]             if (++ptr >= end) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         int flushLen = (ptr - start); [EOL]         if (flushLen > 0) { [EOL]             _writer.write(_outputBuffer, start, flushLen); [EOL]             if (ptr >= end) { [EOL]                 break output_loop; [EOL]             } [EOL]         } [EOL]         ++ptr; [EOL]         start = _prependOrWriteCharacterEscape(_outputBuffer, ptr, end, c, escCodes[c]); [EOL]     } [EOL] } <line_num>: 1032,1070
private void _writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     if (_characterEscapes != null) { [EOL]         _writeStringCustom(text, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_maximumNonEscapedChar != 0) { [EOL]         _writeStringASCII(text, offset, len, _maximumNonEscapedChar); [EOL]         return; [EOL]     } [EOL]     len += offset; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int escLen = escCodes.length; [EOL]     while (offset < len) { [EOL]         int start = offset; [EOL]         while (true) { [EOL]             char c = text[offset]; [EOL]             if (c < escLen && escCodes[c] != 0) { [EOL]                 break; [EOL]             } [EOL]             if (++offset >= len) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         int newAmount = offset - start; [EOL]         if (newAmount < SHORT_WRITE) { [EOL]             if ((_outputTail + newAmount) > _outputEnd) { [EOL]                 _flushBuffer(); [EOL]             } [EOL]             if (newAmount > 0) { [EOL]                 System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount); [EOL]                 _outputTail += newAmount; [EOL]             } [EOL]         } else { [EOL]             _flushBuffer(); [EOL]             _writer.write(text, start, newAmount); [EOL]         } [EOL]         if (offset >= len) { [EOL]             break; [EOL]         } [EOL]         char c = text[offset++]; [EOL]         _appendCharacterEscape(c, escCodes[c]); [EOL]     } [EOL] } <line_num>: 1076,1131
private void _writeStringASCII(final int len, final int maxNonEscaped) throws IOException, JsonGenerationException { [EOL]     int end = _outputTail + len; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int escLimit = Math.min(escCodes.length, maxNonEscaped + 1); [EOL]     int escCode = 0; [EOL]     output_loop: while (_outputTail < end) { [EOL]         char c; [EOL]         escape_loop: while (true) { [EOL]             c = _outputBuffer[_outputTail]; [EOL]             if (c < escLimit) { [EOL]                 escCode = escCodes[c]; [EOL]                 if (escCode != 0) { [EOL]                     break escape_loop; [EOL]                 } [EOL]             } else if (c > maxNonEscaped) { [EOL]                 escCode = CharacterEscapes.ESCAPE_STANDARD; [EOL]                 break escape_loop; [EOL]             } [EOL]             if (++_outputTail >= end) { [EOL]                 break output_loop; [EOL]             } [EOL]         } [EOL]         int flushLen = (_outputTail - _outputHead); [EOL]         if (flushLen > 0) { [EOL]             _writer.write(_outputBuffer, _outputHead, flushLen); [EOL]         } [EOL]         ++_outputTail; [EOL]         _prependOrWriteCharacterEscape(c, escCode); [EOL]     } [EOL] } <line_num>: 1143,1179
private void _writeSegmentASCII(int end, final int maxNonEscaped) throws IOException, JsonGenerationException { [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int escLimit = Math.min(escCodes.length, maxNonEscaped + 1); [EOL]     int ptr = 0; [EOL]     int escCode = 0; [EOL]     int start = ptr; [EOL]     output_loop: while (ptr < end) { [EOL]         char c; [EOL]         while (true) { [EOL]             c = _outputBuffer[ptr]; [EOL]             if (c < escLimit) { [EOL]                 escCode = escCodes[c]; [EOL]                 if (escCode != 0) { [EOL]                     break; [EOL]                 } [EOL]             } else if (c > maxNonEscaped) { [EOL]                 escCode = CharacterEscapes.ESCAPE_STANDARD; [EOL]                 break; [EOL]             } [EOL]             if (++ptr >= end) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         int flushLen = (ptr - start); [EOL]         if (flushLen > 0) { [EOL]             _writer.write(_outputBuffer, start, flushLen); [EOL]             if (ptr >= end) { [EOL]                 break output_loop; [EOL]             } [EOL]         } [EOL]         ++ptr; [EOL]         start = _prependOrWriteCharacterEscape(_outputBuffer, ptr, end, c, escCode); [EOL]     } [EOL] } <line_num>: 1181,1220
private void _writeStringASCII(char[] text, int offset, int len, final int maxNonEscaped) throws IOException, JsonGenerationException { [EOL]     len += offset; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int escLimit = Math.min(escCodes.length, maxNonEscaped + 1); [EOL]     int escCode = 0; [EOL]     while (offset < len) { [EOL]         int start = offset; [EOL]         char c; [EOL]         while (true) { [EOL]             c = text[offset]; [EOL]             if (c < escLimit) { [EOL]                 escCode = escCodes[c]; [EOL]                 if (escCode != 0) { [EOL]                     break; [EOL]                 } [EOL]             } else if (c > maxNonEscaped) { [EOL]                 escCode = CharacterEscapes.ESCAPE_STANDARD; [EOL]                 break; [EOL]             } [EOL]             if (++offset >= len) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         int newAmount = offset - start; [EOL]         if (newAmount < SHORT_WRITE) { [EOL]             if ((_outputTail + newAmount) > _outputEnd) { [EOL]                 _flushBuffer(); [EOL]             } [EOL]             if (newAmount > 0) { [EOL]                 System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount); [EOL]                 _outputTail += newAmount; [EOL]             } [EOL]         } else { [EOL]             _flushBuffer(); [EOL]             _writer.write(text, start, newAmount); [EOL]         } [EOL]         if (offset >= len) { [EOL]             break; [EOL]         } [EOL]         ++offset; [EOL]         _appendCharacterEscape(c, escCode); [EOL]     } [EOL] } <line_num>: 1222,1275
private void _writeStringCustom(final int len) throws IOException, JsonGenerationException { [EOL]     int end = _outputTail + len; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int maxNonEscaped = (_maximumNonEscapedChar < 1) ? 0xFFFF : _maximumNonEscapedChar; [EOL]     final int escLimit = Math.min(escCodes.length, maxNonEscaped + 1); [EOL]     int escCode = 0; [EOL]     final CharacterEscapes customEscapes = _characterEscapes; [EOL]     output_loop: while (_outputTail < end) { [EOL]         char c; [EOL]         escape_loop: while (true) { [EOL]             c = _outputBuffer[_outputTail]; [EOL]             if (c < escLimit) { [EOL]                 escCode = escCodes[c]; [EOL]                 if (escCode != 0) { [EOL]                     break escape_loop; [EOL]                 } [EOL]             } else if (c > maxNonEscaped) { [EOL]                 escCode = CharacterEscapes.ESCAPE_STANDARD; [EOL]                 break escape_loop; [EOL]             } else { [EOL]                 if ((_currentEscape = customEscapes.getEscapeSequence(c)) != null) { [EOL]                     escCode = CharacterEscapes.ESCAPE_CUSTOM; [EOL]                     break escape_loop; [EOL]                 } [EOL]             } [EOL]             if (++_outputTail >= end) { [EOL]                 break output_loop; [EOL]             } [EOL]         } [EOL]         int flushLen = (_outputTail - _outputHead); [EOL]         if (flushLen > 0) { [EOL]             _writer.write(_outputBuffer, _outputHead, flushLen); [EOL]         } [EOL]         ++_outputTail; [EOL]         _prependOrWriteCharacterEscape(c, escCode); [EOL]     } [EOL] } <line_num>: 1287,1330
private void _writeSegmentCustom(int end) throws IOException, JsonGenerationException { [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int maxNonEscaped = (_maximumNonEscapedChar < 1) ? 0xFFFF : _maximumNonEscapedChar; [EOL]     final int escLimit = Math.min(escCodes.length, maxNonEscaped + 1); [EOL]     final CharacterEscapes customEscapes = _characterEscapes; [EOL]     int ptr = 0; [EOL]     int escCode = 0; [EOL]     int start = ptr; [EOL]     output_loop: while (ptr < end) { [EOL]         char c; [EOL]         while (true) { [EOL]             c = _outputBuffer[ptr]; [EOL]             if (c < escLimit) { [EOL]                 escCode = escCodes[c]; [EOL]                 if (escCode != 0) { [EOL]                     break; [EOL]                 } [EOL]             } else if (c > maxNonEscaped) { [EOL]                 escCode = CharacterEscapes.ESCAPE_STANDARD; [EOL]                 break; [EOL]             } else { [EOL]                 if ((_currentEscape = customEscapes.getEscapeSequence(c)) != null) { [EOL]                     escCode = CharacterEscapes.ESCAPE_CUSTOM; [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             if (++ptr >= end) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         int flushLen = (ptr - start); [EOL]         if (flushLen > 0) { [EOL]             _writer.write(_outputBuffer, start, flushLen); [EOL]             if (ptr >= end) { [EOL]                 break output_loop; [EOL]             } [EOL]         } [EOL]         ++ptr; [EOL]         start = _prependOrWriteCharacterEscape(_outputBuffer, ptr, end, c, escCode); [EOL]     } [EOL] } <line_num>: 1332,1378
private void _writeStringCustom(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     len += offset; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int maxNonEscaped = (_maximumNonEscapedChar < 1) ? 0xFFFF : _maximumNonEscapedChar; [EOL]     final int escLimit = Math.min(escCodes.length, maxNonEscaped + 1); [EOL]     final CharacterEscapes customEscapes = _characterEscapes; [EOL]     int escCode = 0; [EOL]     while (offset < len) { [EOL]         int start = offset; [EOL]         char c; [EOL]         while (true) { [EOL]             c = text[offset]; [EOL]             if (c < escLimit) { [EOL]                 escCode = escCodes[c]; [EOL]                 if (escCode != 0) { [EOL]                     break; [EOL]                 } [EOL]             } else if (c > maxNonEscaped) { [EOL]                 escCode = CharacterEscapes.ESCAPE_STANDARD; [EOL]                 break; [EOL]             } else { [EOL]                 if ((_currentEscape = customEscapes.getEscapeSequence(c)) != null) { [EOL]                     escCode = CharacterEscapes.ESCAPE_CUSTOM; [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             if (++offset >= len) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         int newAmount = offset - start; [EOL]         if (newAmount < SHORT_WRITE) { [EOL]             if ((_outputTail + newAmount) > _outputEnd) { [EOL]                 _flushBuffer(); [EOL]             } [EOL]             if (newAmount > 0) { [EOL]                 System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount); [EOL]                 _outputTail += newAmount; [EOL]             } [EOL]         } else { [EOL]             _flushBuffer(); [EOL]             _writer.write(text, start, newAmount); [EOL]         } [EOL]         if (offset >= len) { [EOL]             break; [EOL]         } [EOL]         ++offset; [EOL]         _appendCharacterEscape(c, escCode); [EOL]     } [EOL] } <line_num>: 1380,1439
protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException { [EOL]     int safeInputEnd = inputEnd - 3; [EOL]     int safeOutputEnd = _outputEnd - 6; [EOL]     int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL]     while (inputPtr <= safeInputEnd) { [EOL]         if (_outputTail > safeOutputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int b24 = ((int) input[inputPtr++]) << 8; [EOL]         b24 |= ((int) input[inputPtr++]) & 0xFF; [EOL]         b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF); [EOL]         _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); [EOL]         if (--chunksBeforeLF <= 0) { [EOL]             _outputBuffer[_outputTail++] = '\\'; [EOL]             _outputBuffer[_outputTail++] = 'n'; [EOL]             chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL]         } [EOL]     } [EOL]     int inputLeft = inputEnd - inputPtr; [EOL]     if (inputLeft > 0) { [EOL]         if (_outputTail > safeOutputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int b24 = ((int) input[inputPtr++]) << 16; [EOL]         if (inputLeft == 2) { [EOL]             b24 |= (((int) input[inputPtr++]) & 0xFF) << 8; [EOL]         } [EOL]         _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail); [EOL]     } [EOL] } <line_num>: 1447,1486
protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException { [EOL]     int inputPtr = 0; [EOL]     int inputEnd = 0; [EOL]     int lastFullOffset = -3; [EOL]     int safeOutputEnd = _outputEnd - 6; [EOL]     int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL]     while (bytesLeft > 2) { [EOL]         if (inputPtr > lastFullOffset) { [EOL]             inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft); [EOL]             inputPtr = 0; [EOL]             if (inputEnd < 3) { [EOL]                 break; [EOL]             } [EOL]             lastFullOffset = inputEnd - 3; [EOL]         } [EOL]         if (_outputTail > safeOutputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int b24 = ((int) readBuffer[inputPtr++]) << 8; [EOL]         b24 |= ((int) readBuffer[inputPtr++]) & 0xFF; [EOL]         b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF); [EOL]         bytesLeft -= 3; [EOL]         _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); [EOL]         if (--chunksBeforeLF <= 0) { [EOL]             _outputBuffer[_outputTail++] = '\\'; [EOL]             _outputBuffer[_outputTail++] = 'n'; [EOL]             chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL]         } [EOL]     } [EOL]     if (bytesLeft > 0) { [EOL]         inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft); [EOL]         inputPtr = 0; [EOL]         if (inputEnd > 0) { [EOL]             if (_outputTail > safeOutputEnd) { [EOL]                 _flushBuffer(); [EOL]             } [EOL]             int b24 = ((int) readBuffer[inputPtr++]) << 16; [EOL]             int amount; [EOL]             if (inputPtr < inputEnd) { [EOL]                 b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8; [EOL]                 amount = 2; [EOL]             } else { [EOL]                 amount = 1; [EOL]             } [EOL]             _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail); [EOL]             bytesLeft -= amount; [EOL]         } [EOL]     } [EOL]     return bytesLeft; [EOL] } <line_num>: 1489,1546
protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException { [EOL]     int inputPtr = 0; [EOL]     int inputEnd = 0; [EOL]     int lastFullOffset = -3; [EOL]     int bytesDone = 0; [EOL]     int safeOutputEnd = _outputEnd - 6; [EOL]     int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL]     while (true) { [EOL]         if (inputPtr > lastFullOffset) { [EOL]             inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length); [EOL]             inputPtr = 0; [EOL]             if (inputEnd < 3) { [EOL]                 break; [EOL]             } [EOL]             lastFullOffset = inputEnd - 3; [EOL]         } [EOL]         if (_outputTail > safeOutputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int b24 = ((int) readBuffer[inputPtr++]) << 8; [EOL]         b24 |= ((int) readBuffer[inputPtr++]) & 0xFF; [EOL]         b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF); [EOL]         bytesDone += 3; [EOL]         _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); [EOL]         if (--chunksBeforeLF <= 0) { [EOL]             _outputBuffer[_outputTail++] = '\\'; [EOL]             _outputBuffer[_outputTail++] = 'n'; [EOL]             chunksBeforeLF = b64variant.getMaxLineLength() >> 2; [EOL]         } [EOL]     } [EOL]     if (inputPtr < inputEnd) { [EOL]         if (_outputTail > safeOutputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int b24 = ((int) readBuffer[inputPtr++]) << 16; [EOL]         int amount = 1; [EOL]         if (inputPtr < inputEnd) { [EOL]             b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8; [EOL]             amount = 2; [EOL]         } [EOL]         bytesDone += amount; [EOL]         _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail); [EOL]     } [EOL]     return bytesDone; [EOL] } <line_num>: 1549,1603
private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException { [EOL]     int i = 0; [EOL]     while (inputPtr < inputEnd) { [EOL]         readBuffer[i++] = readBuffer[inputPtr++]; [EOL]     } [EOL]     inputPtr = 0; [EOL]     inputEnd = i; [EOL]     maxRead = Math.min(maxRead, readBuffer.length); [EOL]     do { [EOL]         int length = maxRead - inputEnd; [EOL]         if (length == 0) { [EOL]             break; [EOL]         } [EOL]         int count = in.read(readBuffer, inputEnd, length); [EOL]         if (count < 0) { [EOL]             return inputEnd; [EOL]         } [EOL]         inputEnd += count; [EOL]     } while (inputEnd < 3); [EOL]     return inputEnd; [EOL] } <line_num>: 1605,1630
private void _writeNull() throws IOException { [EOL]     if ((_outputTail + 4) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     int ptr = _outputTail; [EOL]     char[] buf = _outputBuffer; [EOL]     buf[ptr] = 'n'; [EOL]     buf[++ptr] = 'u'; [EOL]     buf[++ptr] = 'l'; [EOL]     buf[++ptr] = 'l'; [EOL]     _outputTail = ptr + 1; [EOL] } <line_num>: 1638,1650
private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException { [EOL]     if (escCode >= 0) { [EOL]         if (_outputTail >= 2) { [EOL]             int ptr = _outputTail - 2; [EOL]             _outputHead = ptr; [EOL]             _outputBuffer[ptr++] = '\\'; [EOL]             _outputBuffer[ptr] = (char) escCode; [EOL]             return; [EOL]         } [EOL]         char[] buf = _entityBuffer; [EOL]         if (buf == null) { [EOL]             buf = _allocateEntityBuffer(); [EOL]         } [EOL]         _outputHead = _outputTail; [EOL]         buf[1] = (char) escCode; [EOL]         _writer.write(buf, 0, 2); [EOL]         return; [EOL]     } [EOL]     if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { [EOL]         if (_outputTail >= 6) { [EOL]             char[] buf = _outputBuffer; [EOL]             int ptr = _outputTail - 6; [EOL]             _outputHead = ptr; [EOL]             buf[ptr] = '\\'; [EOL]             buf[++ptr] = 'u'; [EOL]             if (ch > 0xFF) { [EOL]                 int hi = (ch >> 8) & 0xFF; [EOL]                 buf[++ptr] = HEX_CHARS[hi >> 4]; [EOL]                 buf[++ptr] = HEX_CHARS[hi & 0xF]; [EOL]                 ch &= 0xFF; [EOL]             } else { [EOL]                 buf[++ptr] = '0'; [EOL]                 buf[++ptr] = '0'; [EOL]             } [EOL]             buf[++ptr] = HEX_CHARS[ch >> 4]; [EOL]             buf[++ptr] = HEX_CHARS[ch & 0xF]; [EOL]             return; [EOL]         } [EOL]         char[] buf = _entityBuffer; [EOL]         if (buf == null) { [EOL]             buf = _allocateEntityBuffer(); [EOL]         } [EOL]         _outputHead = _outputTail; [EOL]         if (ch > 0xFF) { [EOL]             int hi = (ch >> 8) & 0xFF; [EOL]             int lo = ch & 0xFF; [EOL]             buf[10] = HEX_CHARS[hi >> 4]; [EOL]             buf[11] = HEX_CHARS[hi & 0xF]; [EOL]             buf[12] = HEX_CHARS[lo >> 4]; [EOL]             buf[13] = HEX_CHARS[lo & 0xF]; [EOL]             _writer.write(buf, 8, 6); [EOL]         } else { [EOL]             buf[6] = HEX_CHARS[ch >> 4]; [EOL]             buf[7] = HEX_CHARS[ch & 0xF]; [EOL]             _writer.write(buf, 2, 6); [EOL]         } [EOL]         return; [EOL]     } [EOL]     String escape; [EOL]     if (_currentEscape == null) { [EOL]         escape = _characterEscapes.getEscapeSequence(ch).getValue(); [EOL]     } else { [EOL]         escape = _currentEscape.getValue(); [EOL]         _currentEscape = null; [EOL]     } [EOL]     int len = escape.length(); [EOL]     if (_outputTail >= len) { [EOL]         int ptr = _outputTail - len; [EOL]         _outputHead = ptr; [EOL]         escape.getChars(0, len, _outputBuffer, ptr); [EOL]         return; [EOL]     } [EOL]     _outputHead = _outputTail; [EOL]     _writer.write(escape); [EOL] } <line_num>: 1663,1744
private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end, char ch, int escCode) throws IOException, JsonGenerationException { [EOL]     if (escCode >= 0) { [EOL]         if (ptr > 1 && ptr < end) { [EOL]             ptr -= 2; [EOL]             buffer[ptr] = '\\'; [EOL]             buffer[ptr + 1] = (char) escCode; [EOL]         } else { [EOL]             char[] ent = _entityBuffer; [EOL]             if (ent == null) { [EOL]                 ent = _allocateEntityBuffer(); [EOL]             } [EOL]             ent[1] = (char) escCode; [EOL]             _writer.write(ent, 0, 2); [EOL]         } [EOL]         return ptr; [EOL]     } [EOL]     if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { [EOL]         if (ptr > 5 && ptr < end) { [EOL]             ptr -= 6; [EOL]             buffer[ptr++] = '\\'; [EOL]             buffer[ptr++] = 'u'; [EOL]             if (ch > 0xFF) { [EOL]                 int hi = (ch >> 8) & 0xFF; [EOL]                 buffer[ptr++] = HEX_CHARS[hi >> 4]; [EOL]                 buffer[ptr++] = HEX_CHARS[hi & 0xF]; [EOL]                 ch &= 0xFF; [EOL]             } else { [EOL]                 buffer[ptr++] = '0'; [EOL]                 buffer[ptr++] = '0'; [EOL]             } [EOL]             buffer[ptr++] = HEX_CHARS[ch >> 4]; [EOL]             buffer[ptr] = HEX_CHARS[ch & 0xF]; [EOL]             ptr -= 5; [EOL]         } else { [EOL]             char[] ent = _entityBuffer; [EOL]             if (ent == null) { [EOL]                 ent = _allocateEntityBuffer(); [EOL]             } [EOL]             _outputHead = _outputTail; [EOL]             if (ch > 0xFF) { [EOL]                 int hi = (ch >> 8) & 0xFF; [EOL]                 int lo = ch & 0xFF; [EOL]                 ent[10] = HEX_CHARS[hi >> 4]; [EOL]                 ent[11] = HEX_CHARS[hi & 0xF]; [EOL]                 ent[12] = HEX_CHARS[lo >> 4]; [EOL]                 ent[13] = HEX_CHARS[lo & 0xF]; [EOL]                 _writer.write(ent, 8, 6); [EOL]             } else { [EOL]                 ent[6] = HEX_CHARS[ch >> 4]; [EOL]                 ent[7] = HEX_CHARS[ch & 0xF]; [EOL]                 _writer.write(ent, 2, 6); [EOL]             } [EOL]         } [EOL]         return ptr; [EOL]     } [EOL]     String escape; [EOL]     if (_currentEscape == null) { [EOL]         escape = _characterEscapes.getEscapeSequence(ch).getValue(); [EOL]     } else { [EOL]         escape = _currentEscape.getValue(); [EOL]         _currentEscape = null; [EOL]     } [EOL]     int len = escape.length(); [EOL]     if (ptr >= len && ptr < end) { [EOL]         ptr -= len; [EOL]         escape.getChars(0, len, buffer, ptr); [EOL]     } else { [EOL]         _writer.write(escape); [EOL]     } [EOL]     return ptr; [EOL] } <line_num>: 1753,1828
private void _appendCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException { [EOL]     if (escCode >= 0) { [EOL]         if ((_outputTail + 2) > _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '\\'; [EOL]         _outputBuffer[_outputTail++] = (char) escCode; [EOL]         return; [EOL]     } [EOL]     if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { [EOL]         if ((_outputTail + 2) > _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         int ptr = _outputTail; [EOL]         char[] buf = _outputBuffer; [EOL]         buf[ptr++] = '\\'; [EOL]         buf[ptr++] = 'u'; [EOL]         if (ch > 0xFF) { [EOL]             int hi = (ch >> 8) & 0xFF; [EOL]             buf[ptr++] = HEX_CHARS[hi >> 4]; [EOL]             buf[ptr++] = HEX_CHARS[hi & 0xF]; [EOL]             ch &= 0xFF; [EOL]         } else { [EOL]             buf[ptr++] = '0'; [EOL]             buf[ptr++] = '0'; [EOL]         } [EOL]         buf[ptr++] = HEX_CHARS[ch >> 4]; [EOL]         buf[ptr] = HEX_CHARS[ch & 0xF]; [EOL]         _outputTail = ptr; [EOL]         return; [EOL]     } [EOL]     String escape; [EOL]     if (_currentEscape == null) { [EOL]         escape = _characterEscapes.getEscapeSequence(ch).getValue(); [EOL]     } else { [EOL]         escape = _currentEscape.getValue(); [EOL]         _currentEscape = null; [EOL]     } [EOL]     int len = escape.length(); [EOL]     if ((_outputTail + len) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]         if (len > _outputEnd) { [EOL]             _writer.write(escape); [EOL]             return; [EOL]         } [EOL]     } [EOL]     escape.getChars(0, len, _outputBuffer, _outputTail); [EOL]     _outputTail += len; [EOL] } <line_num>: 1834,1885
private char[] _allocateEntityBuffer() { [EOL]     char[] buf = new char[14]; [EOL]     buf[0] = '\\'; [EOL]     buf[2] = '\\'; [EOL]     buf[3] = 'u'; [EOL]     buf[4] = '0'; [EOL]     buf[5] = '0'; [EOL]     buf[8] = '\\'; [EOL]     buf[9] = 'u'; [EOL]     _entityBuffer = buf; [EOL]     return buf; [EOL] } <line_num>: 1887,1902
protected void _flushBuffer() throws IOException { [EOL]     int len = _outputTail - _outputHead; [EOL]     if (len > 0) { [EOL]         int offset = _outputHead; [EOL]         _outputTail = _outputHead = 0; [EOL]         _writer.write(_outputBuffer, offset, len); [EOL]     } [EOL] } <line_num>: 1904,1912
