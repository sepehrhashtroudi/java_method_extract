public ByteArrayBuilder() { [EOL]     this(null); [EOL] } <line_num>: 59,59
public ByteArrayBuilder(BufferRecycler br) { [EOL]     this(br, INITIAL_BLOCK_SIZE); [EOL] } <line_num>: 61,61
public ByteArrayBuilder(int firstBlockSize) { [EOL]     this(null, firstBlockSize); [EOL] } <line_num>: 63,63
public ByteArrayBuilder(BufferRecycler br, int firstBlockSize) { [EOL]     _bufferRecycler = br; [EOL]     if (br == null) { [EOL]         _currBlock = new byte[firstBlockSize]; [EOL]     } else { [EOL]         _currBlock = br.allocByteBuffer(BufferRecycler.ByteBufferType.WRITE_CONCAT_BUFFER); [EOL]     } [EOL] } <line_num>: 65,73
public void reset() { [EOL]     _pastLen = 0; [EOL]     _currBlockPtr = 0; [EOL]     if (!_pastBlocks.isEmpty()) { [EOL]         _pastBlocks.clear(); [EOL]     } [EOL] } <line_num>: 75,83
public void release() { [EOL]     reset(); [EOL]     if (_bufferRecycler != null && _currBlock != null) { [EOL]         _bufferRecycler.releaseByteBuffer(BufferRecycler.ByteBufferType.WRITE_CONCAT_BUFFER, _currBlock); [EOL]         _currBlock = null; [EOL]     } [EOL] } <line_num>: 90,96
public void append(int i) { [EOL]     if (_currBlockPtr >= _currBlock.length) { [EOL]         _allocMore(); [EOL]     } [EOL]     _currBlock[_currBlockPtr++] = (byte) i; [EOL] } <line_num>: 98,104
public void appendTwoBytes(int b16) { [EOL]     if ((_currBlockPtr + 1) < _currBlock.length) { [EOL]         _currBlock[_currBlockPtr++] = (byte) (b16 >> 8); [EOL]         _currBlock[_currBlockPtr++] = (byte) b16; [EOL]     } else { [EOL]         append(b16 >> 8); [EOL]         append(b16); [EOL]     } [EOL] } <line_num>: 106,115
public void appendThreeBytes(int b24) { [EOL]     if ((_currBlockPtr + 2) < _currBlock.length) { [EOL]         _currBlock[_currBlockPtr++] = (byte) (b24 >> 16); [EOL]         _currBlock[_currBlockPtr++] = (byte) (b24 >> 8); [EOL]         _currBlock[_currBlockPtr++] = (byte) b24; [EOL]     } else { [EOL]         append(b24 >> 16); [EOL]         append(b24 >> 8); [EOL]         append(b24); [EOL]     } [EOL] } <line_num>: 117,128
public byte[] toByteArray() { [EOL]     int totalLen = _pastLen + _currBlockPtr; [EOL]     if (totalLen == 0) { [EOL]         return NO_BYTES; [EOL]     } [EOL]     byte[] result = new byte[totalLen]; [EOL]     int offset = 0; [EOL]     for (byte[] block : _pastBlocks) { [EOL]         int len = block.length; [EOL]         System.arraycopy(block, 0, result, offset, len); [EOL]         offset += len; [EOL]     } [EOL]     System.arraycopy(_currBlock, 0, result, offset, _currBlockPtr); [EOL]     offset += _currBlockPtr; [EOL]     if (offset != totalLen) { [EOL]         throw new RuntimeException("Internal error: total len assumed to be " + totalLen + ", copied " + offset + " bytes"); [EOL]     } [EOL]     if (!_pastBlocks.isEmpty()) { [EOL]         reset(); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 134,160
public byte[] resetAndGetFirstSegment() { [EOL]     reset(); [EOL]     return _currBlock; [EOL] } <line_num>: 172,175
public byte[] finishCurrentSegment() { [EOL]     _allocMore(); [EOL]     return _currBlock; [EOL] } <line_num>: 182,185
public byte[] completeAndCoalesce(int lastBlockLength) { [EOL]     _currBlockPtr = lastBlockLength; [EOL]     return toByteArray(); [EOL] } <line_num>: 196,200
public byte[] getCurrentSegment() { [EOL]     return _currBlock; [EOL] } <line_num>: 202,204
public void setCurrentSegmentLength(int len) { [EOL]     _currBlockPtr = len; [EOL] } <line_num>: 206,208
public int getCurrentSegmentLength() { [EOL]     return _currBlockPtr; [EOL] } <line_num>: 210,212
@Override [EOL] public void write(byte[] b) { [EOL]     write(b, 0, b.length); [EOL] } <line_num>: 220,223
@Override [EOL] public void write(byte[] b, int off, int len) { [EOL]     while (true) { [EOL]         int max = _currBlock.length - _currBlockPtr; [EOL]         int toCopy = Math.min(max, len); [EOL]         if (toCopy > 0) { [EOL]             System.arraycopy(b, off, _currBlock, _currBlockPtr, toCopy); [EOL]             off += toCopy; [EOL]             _currBlockPtr += toCopy; [EOL]             len -= toCopy; [EOL]         } [EOL]         if (len <= 0) [EOL]             break; [EOL]         _allocMore(); [EOL]     } [EOL] } <line_num>: 225,240
@Override [EOL] public void write(int b) { [EOL]     append(b); [EOL] } <line_num>: 242,245
@Override [EOL] public void close() { [EOL] } <line_num>: 247,247
@Override [EOL] public void flush() { [EOL] } <line_num>: 249,249
private void _allocMore() { [EOL]     _pastLen += _currBlock.length; [EOL]     int newSize = Math.max((_pastLen >> 1), (INITIAL_BLOCK_SIZE + INITIAL_BLOCK_SIZE)); [EOL]     if (newSize > MAX_BLOCK_SIZE) { [EOL]         newSize = MAX_BLOCK_SIZE; [EOL]     } [EOL]     _pastBlocks.add(_currBlock); [EOL]     _currBlock = new byte[newSize]; [EOL]     _currBlockPtr = 0; [EOL] } <line_num>: 257,275
