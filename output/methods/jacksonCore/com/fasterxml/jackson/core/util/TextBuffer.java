public TextBuffer(BufferRecycler allocator) { [EOL]     _allocator = allocator; [EOL] } <line_num>: 121,124
public void releaseBuffers() { [EOL]     if (_allocator == null) { [EOL]         resetWithEmpty(); [EOL]     } else { [EOL]         if (_currentSegment != null) { [EOL]             resetWithEmpty(); [EOL]             char[] buf = _currentSegment; [EOL]             _currentSegment = null; [EOL]             _allocator.releaseCharBuffer(BufferRecycler.CharBufferType.TEXT_BUFFER, buf); [EOL]         } [EOL]     } [EOL] } <line_num>: 135,149
public void resetWithEmpty() { [EOL]     _inputStart = -1; [EOL]     _currentSize = 0; [EOL]     _inputLen = 0; [EOL]     _inputBuffer = null; [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } [EOL] } <line_num>: 155,169
public void resetWithShared(char[] buf, int start, int len) { [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     _inputBuffer = buf; [EOL]     _inputStart = start; [EOL]     _inputLen = len; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } [EOL] } <line_num>: 177,192
public void resetWithCopy(char[] buf, int start, int len) { [EOL]     _inputBuffer = null; [EOL]     _inputStart = -1; [EOL]     _inputLen = 0; [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } else if (_currentSegment == null) { [EOL]         _currentSegment = findBuffer(len); [EOL]     } [EOL]     _currentSize = _segmentSize = 0; [EOL]     append(buf, start, len); [EOL] } <line_num>: 194,211
public void resetWithString(String value) { [EOL]     _inputBuffer = null; [EOL]     _inputStart = -1; [EOL]     _inputLen = 0; [EOL]     _resultString = value; [EOL]     _resultArray = null; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } [EOL]     _currentSize = 0; [EOL] } <line_num>: 213,227
private char[] findBuffer(int needed) { [EOL]     if (_allocator != null) { [EOL]         return _allocator.allocCharBuffer(BufferRecycler.CharBufferType.TEXT_BUFFER, needed); [EOL]     } [EOL]     return new char[Math.max(needed, MIN_SEGMENT_LEN)]; [EOL] } <line_num>: 233,239
private void clearSegments() { [EOL]     _hasSegments = false; [EOL]     _segments.clear(); [EOL]     _currentSize = _segmentSize = 0; [EOL] } <line_num>: 241,253
public int size() { [EOL]     if (_inputStart >= 0) { [EOL]         return _inputLen; [EOL]     } [EOL]     if (_resultArray != null) { [EOL]         return _resultArray.length; [EOL]     } [EOL]     if (_resultString != null) { [EOL]         return _resultString.length(); [EOL]     } [EOL]     return _segmentSize + _currentSize; [EOL] } <line_num>: 264,276
public int getTextOffset() { [EOL]     return (_inputStart >= 0) ? _inputStart : 0; [EOL] } <line_num>: 278,285
public boolean hasTextAsCharacters() { [EOL]     if (_inputStart >= 0 || _resultArray != null) { [EOL]         return true; [EOL]     } [EOL]     if (_resultString != null) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } <line_num>: 291,302
public char[] getTextBuffer() { [EOL]     if (_inputStart >= 0) { [EOL]         return _inputBuffer; [EOL]     } [EOL]     if (_resultArray != null) { [EOL]         return _resultArray; [EOL]     } [EOL]     if (_resultString != null) { [EOL]         return (_resultArray = _resultString.toCharArray()); [EOL]     } [EOL]     if (!_hasSegments) { [EOL]         return _currentSegment; [EOL]     } [EOL]     return contentsAsArray(); [EOL] } <line_num>: 304,322
public String contentsAsString() { [EOL]     if (_resultString == null) { [EOL]         if (_resultArray != null) { [EOL]             _resultString = new String(_resultArray); [EOL]         } else { [EOL]             if (_inputStart >= 0) { [EOL]                 if (_inputLen < 1) { [EOL]                     return (_resultString = ""); [EOL]                 } [EOL]                 _resultString = new String(_inputBuffer, _inputStart, _inputLen); [EOL]             } else { [EOL]                 int segLen = _segmentSize; [EOL]                 int currLen = _currentSize; [EOL]                 if (segLen == 0) { [EOL]                     _resultString = (currLen == 0) ? "" : new String(_currentSegment, 0, currLen); [EOL]                 } else { [EOL]                     StringBuilder sb = new StringBuilder(segLen + currLen); [EOL]                     if (_segments != null) { [EOL]                         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]                             char[] curr = _segments.get(i); [EOL]                             sb.append(curr, 0, curr.length); [EOL]                         } [EOL]                     } [EOL]                     sb.append(_currentSegment, 0, _currentSize); [EOL]                     _resultString = sb.toString(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _resultString; [EOL] } <line_num>: 330,367
public char[] contentsAsArray() { [EOL]     char[] result = _resultArray; [EOL]     if (result == null) { [EOL]         _resultArray = result = buildResultArray(); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 369,376
public BigDecimal contentsAsDecimal() throws NumberFormatException { [EOL]     if (_resultArray != null) { [EOL]         return NumberInput.parseBigDecimal(_resultArray); [EOL]     } [EOL]     if ((_inputStart >= 0) && (_inputBuffer != null)) { [EOL]         return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen); [EOL]     } [EOL]     if ((_segmentSize == 0) && (_currentSegment != null)) { [EOL]         return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize); [EOL]     } [EOL]     return NumberInput.parseBigDecimal(contentsAsArray()); [EOL] } <line_num>: 382,399
public double contentsAsDouble() throws NumberFormatException { [EOL]     return NumberInput.parseDouble(contentsAsString()); [EOL] } <line_num>: 405,409
public void ensureNotShared() { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(16); [EOL]     } [EOL] } <line_num>: 421,425
public void append(char c) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(16); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     if (_currentSize >= curr.length) { [EOL]         expand(1); [EOL]         curr = _currentSegment; [EOL]     } [EOL]     curr[_currentSize++] = c; [EOL] } <line_num>: 427,441
public void append(char[] c, int start, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         System.arraycopy(c, start, curr, _currentSize, len); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         System.arraycopy(c, start, curr, _currentSize, max); [EOL]         start += max; [EOL]         len -= max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         System.arraycopy(c, start, _currentSegment, 0, amount); [EOL]         _currentSize += amount; [EOL]         start += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] } <line_num>: 443,479
public void append(String str, int offset, int len) { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(len); [EOL]     } [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     char[] curr = _currentSegment; [EOL]     int max = curr.length - _currentSize; [EOL]     if (max >= len) { [EOL]         str.getChars(offset, offset + len, curr, _currentSize); [EOL]         _currentSize += len; [EOL]         return; [EOL]     } [EOL]     if (max > 0) { [EOL]         str.getChars(offset, offset + max, curr, _currentSize); [EOL]         len -= max; [EOL]         offset += max; [EOL]     } [EOL]     do { [EOL]         expand(len); [EOL]         int amount = Math.min(_currentSegment.length, len); [EOL]         str.getChars(offset, offset + amount, _currentSegment, 0); [EOL]         _currentSize += amount; [EOL]         offset += amount; [EOL]         len -= amount; [EOL]     } while (len > 0); [EOL] } <line_num>: 481,516
public char[] getCurrentSegment() { [EOL]     if (_inputStart >= 0) { [EOL]         unshare(1); [EOL]     } else { [EOL]         char[] curr = _currentSegment; [EOL]         if (curr == null) { [EOL]             _currentSegment = findBuffer(0); [EOL]         } else if (_currentSize >= curr.length) { [EOL]             expand(1); [EOL]         } [EOL]     } [EOL]     return _currentSegment; [EOL] } <line_num>: 524,542
public char[] emptyAndGetCurrentSegment() { [EOL]     _inputStart = -1; [EOL]     _currentSize = 0; [EOL]     _inputLen = 0; [EOL]     _inputBuffer = null; [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } [EOL]     char[] curr = _currentSegment; [EOL]     if (curr == null) { [EOL]         _currentSegment = curr = findBuffer(0); [EOL]     } [EOL]     return curr; [EOL] } <line_num>: 544,564
public int getCurrentSegmentSize() { [EOL]     return _currentSize; [EOL] } <line_num>: 566,568
public void setCurrentLength(int len) { [EOL]     _currentSize = len; [EOL] } <line_num>: 570,572
public char[] finishCurrentSegment() { [EOL]     if (_segments == null) { [EOL]         _segments = new ArrayList<char[]>(); [EOL]     } [EOL]     _hasSegments = true; [EOL]     _segments.add(_currentSegment); [EOL]     int oldLen = _currentSegment.length; [EOL]     _segmentSize += oldLen; [EOL]     int newLen = Math.min(oldLen + (oldLen >> 1), MAX_SEGMENT_LEN); [EOL]     char[] curr = _charArray(newLen); [EOL]     _currentSize = 0; [EOL]     _currentSegment = curr; [EOL]     return curr; [EOL] } <line_num>: 574,589
public char[] expandCurrentSegment() { [EOL]     final char[] curr = _currentSegment; [EOL]     final int len = curr.length; [EOL]     int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1)); [EOL]     return (_currentSegment = Arrays.copyOf(curr, newLen)); [EOL] } <line_num>: 596,605
@Override [EOL] public String toString() { [EOL]     return contentsAsString(); [EOL] } <line_num>: 618,621
private void unshare(int needExtra) { [EOL]     int sharedLen = _inputLen; [EOL]     _inputLen = 0; [EOL]     char[] inputBuf = _inputBuffer; [EOL]     _inputBuffer = null; [EOL]     int start = _inputStart; [EOL]     _inputStart = -1; [EOL]     int needed = sharedLen + needExtra; [EOL]     if (_currentSegment == null || needed > _currentSegment.length) { [EOL]         _currentSegment = findBuffer(needed); [EOL]     } [EOL]     if (sharedLen > 0) { [EOL]         System.arraycopy(inputBuf, start, _currentSegment, 0, sharedLen); [EOL]     } [EOL]     _segmentSize = 0; [EOL]     _currentSize = sharedLen; [EOL] } <line_num>: 633,652
private void expand(int minNewSegmentSize) { [EOL]     if (_segments == null) { [EOL]         _segments = new ArrayList<char[]>(); [EOL]     } [EOL]     char[] curr = _currentSegment; [EOL]     _hasSegments = true; [EOL]     _segments.add(curr); [EOL]     _segmentSize += curr.length; [EOL]     int oldLen = curr.length; [EOL]     int sizeAddition = oldLen >> 1; [EOL]     if (sizeAddition < minNewSegmentSize) { [EOL]         sizeAddition = minNewSegmentSize; [EOL]     } [EOL]     _currentSize = 0; [EOL]     _currentSegment = _charArray(Math.min(MAX_SEGMENT_LEN, oldLen + sizeAddition)); [EOL] } <line_num>: 658,676
private char[] buildResultArray() { [EOL]     if (_resultString != null) { [EOL]         return _resultString.toCharArray(); [EOL]     } [EOL]     if (_inputStart >= 0) { [EOL]         final int len = _inputLen; [EOL]         if (len < 1) { [EOL]             return NO_CHARS; [EOL]         } [EOL]         final int start = _inputStart; [EOL]         if (start == 0) { [EOL]             return Arrays.copyOf(_inputBuffer, len); [EOL]         } [EOL]         return Arrays.copyOfRange(_inputBuffer, start, start + len); [EOL]     } [EOL]     int size = size(); [EOL]     if (size < 1) { [EOL]         return NO_CHARS; [EOL]     } [EOL]     int offset = 0; [EOL]     final char[] result = _charArray(size); [EOL]     if (_segments != null) { [EOL]         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]             char[] curr = (char[]) _segments.get(i); [EOL]             int currLen = curr.length; [EOL]             System.arraycopy(curr, 0, result, offset, currLen); [EOL]             offset += currLen; [EOL]         } [EOL]     } [EOL]     System.arraycopy(_currentSegment, 0, result, offset, _currentSize); [EOL]     return result; [EOL] } <line_num>: 678,712
private char[] _charArray(int len) { [EOL]     return new char[len]; [EOL] } <line_num>: 714,716
