public UTF8Writer(IOContext ctxt, OutputStream out) { [EOL]     _context = ctxt; [EOL]     _out = out; [EOL]     _outBuffer = ctxt.allocWriteEncodingBuffer(); [EOL]     _outBufferEnd = _outBuffer.length - 4; [EOL]     _outPtr = 0; [EOL] } <line_num>: 29,41
@Override [EOL] public Writer append(char c) throws IOException { [EOL]     write(c); [EOL]     return this; [EOL] } <line_num>: 43,49
@Override [EOL] public void close() throws IOException { [EOL]     if (_out != null) { [EOL]         if (_outPtr > 0) { [EOL]             _out.write(_outBuffer, 0, _outPtr); [EOL]             _outPtr = 0; [EOL]         } [EOL]         OutputStream out = _out; [EOL]         _out = null; [EOL]         byte[] buf = _outBuffer; [EOL]         if (buf != null) { [EOL]             _outBuffer = null; [EOL]             _context.releaseWriteEncodingBuffer(buf); [EOL]         } [EOL]         out.close(); [EOL]         int code = _surrogate; [EOL]         _surrogate = 0; [EOL]         if (code > 0) { [EOL]             illegalSurrogate(code); [EOL]         } [EOL]     } [EOL] } <line_num>: 51,80
@Override [EOL] public void flush() throws IOException { [EOL]     if (_out != null) { [EOL]         if (_outPtr > 0) { [EOL]             _out.write(_outBuffer, 0, _outPtr); [EOL]             _outPtr = 0; [EOL]         } [EOL]         _out.flush(); [EOL]     } [EOL] } <line_num>: 82,93
@Override [EOL] public void write(char[] cbuf) throws IOException { [EOL]     write(cbuf, 0, cbuf.length); [EOL] } <line_num>: 95,100
@Override [EOL] public void write(char[] cbuf, int off, int len) throws IOException { [EOL]     if (len < 2) { [EOL]         if (len == 1) { [EOL]             write(cbuf[off]); [EOL]         } [EOL]         return; [EOL]     } [EOL]     if (_surrogate > 0) { [EOL]         char second = cbuf[off++]; [EOL]         --len; [EOL]         write(convertSurrogate(second)); [EOL]     } [EOL]     int outPtr = _outPtr; [EOL]     byte[] outBuf = _outBuffer; [EOL]     int outBufLast = _outBufferEnd; [EOL]     len += off; [EOL]     output_loop: for (; off < len; ) { [EOL]         if (outPtr >= outBufLast) { [EOL]             _out.write(outBuf, 0, outPtr); [EOL]             outPtr = 0; [EOL]         } [EOL]         int c = cbuf[off++]; [EOL]         if (c < 0x80) { [EOL]             outBuf[outPtr++] = (byte) c; [EOL]             int maxInCount = (len - off); [EOL]             int maxOutCount = (outBufLast - outPtr); [EOL]             if (maxInCount > maxOutCount) { [EOL]                 maxInCount = maxOutCount; [EOL]             } [EOL]             maxInCount += off; [EOL]             ascii_loop: while (true) { [EOL]                 if (off >= maxInCount) { [EOL]                     continue output_loop; [EOL]                 } [EOL]                 c = cbuf[off++]; [EOL]                 if (c >= 0x80) { [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (byte) c; [EOL]             } [EOL]         } [EOL]         if (c < 0x800) { [EOL]             outBuf[outPtr++] = (byte) (0xc0 | (c >> 6)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else { [EOL]             if (c < SURR1_FIRST || c > SURR2_LAST) { [EOL]                 outBuf[outPtr++] = (byte) (0xe0 | (c >> 12)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]                 continue; [EOL]             } [EOL]             if (c > SURR1_LAST) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             _surrogate = c; [EOL]             if (off >= len) { [EOL]                 break; [EOL]             } [EOL]             c = convertSurrogate(cbuf[off++]); [EOL]             if (c > 0x10FFFF) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             outBuf[outPtr++] = (byte) (0xf0 | (c >> 18)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } [EOL]     } [EOL]     _outPtr = outPtr; [EOL] } <line_num>: 102,197
@Override [EOL] public void write(int c) throws IOException { [EOL]     if (_surrogate > 0) { [EOL]         c = convertSurrogate(c); [EOL]     } else if (c >= SURR1_FIRST && c <= SURR2_LAST) { [EOL]         if (c > SURR1_LAST) { [EOL]             illegalSurrogate(c); [EOL]         } [EOL]         _surrogate = c; [EOL]         return; [EOL]     } [EOL]     if (_outPtr >= _outBufferEnd) { [EOL]         _out.write(_outBuffer, 0, _outPtr); [EOL]         _outPtr = 0; [EOL]     } [EOL]     if (c < 0x80) { [EOL]         _outBuffer[_outPtr++] = (byte) c; [EOL]     } else { [EOL]         int ptr = _outPtr; [EOL]         if (c < 0x800) { [EOL]             _outBuffer[ptr++] = (byte) (0xc0 | (c >> 6)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else if (c <= 0xFFFF) { [EOL]             _outBuffer[ptr++] = (byte) (0xe0 | (c >> 12)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else { [EOL]             if (c > 0x10FFFF) { [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             _outBuffer[ptr++] = (byte) (0xf0 | (c >> 18)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } [EOL]         _outPtr = ptr; [EOL]     } [EOL] } <line_num>: 199,243
@Override [EOL] public void write(String str) throws IOException { [EOL]     write(str, 0, str.length()); [EOL] } <line_num>: 245,249
@Override [EOL] public void write(String str, int off, int len) throws IOException { [EOL]     if (len < 2) { [EOL]         if (len == 1) { [EOL]             write(str.charAt(off)); [EOL]         } [EOL]         return; [EOL]     } [EOL]     if (_surrogate > 0) { [EOL]         char second = str.charAt(off++); [EOL]         --len; [EOL]         write(convertSurrogate(second)); [EOL]     } [EOL]     int outPtr = _outPtr; [EOL]     byte[] outBuf = _outBuffer; [EOL]     int outBufLast = _outBufferEnd; [EOL]     len += off; [EOL]     output_loop: for (; off < len; ) { [EOL]         if (outPtr >= outBufLast) { [EOL]             _out.write(outBuf, 0, outPtr); [EOL]             outPtr = 0; [EOL]         } [EOL]         int c = str.charAt(off++); [EOL]         if (c < 0x80) { [EOL]             outBuf[outPtr++] = (byte) c; [EOL]             int maxInCount = (len - off); [EOL]             int maxOutCount = (outBufLast - outPtr); [EOL]             if (maxInCount > maxOutCount) { [EOL]                 maxInCount = maxOutCount; [EOL]             } [EOL]             maxInCount += off; [EOL]             ascii_loop: while (true) { [EOL]                 if (off >= maxInCount) { [EOL]                     continue output_loop; [EOL]                 } [EOL]                 c = str.charAt(off++); [EOL]                 if (c >= 0x80) { [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (byte) c; [EOL]             } [EOL]         } [EOL]         if (c < 0x800) { [EOL]             outBuf[outPtr++] = (byte) (0xc0 | (c >> 6)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else { [EOL]             if (c < SURR1_FIRST || c > SURR2_LAST) { [EOL]                 outBuf[outPtr++] = (byte) (0xe0 | (c >> 12)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]                 outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]                 continue; [EOL]             } [EOL]             if (c > SURR1_LAST) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             _surrogate = c; [EOL]             if (off >= len) { [EOL]                 break; [EOL]             } [EOL]             c = convertSurrogate(str.charAt(off++)); [EOL]             if (c > 0x10FFFF) { [EOL]                 _outPtr = outPtr; [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             outBuf[outPtr++] = (byte) (0xf0 | (c >> 18)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } [EOL]     } [EOL]     _outPtr = outPtr; [EOL] } <line_num>: 251,345
protected int convertSurrogate(int secondPart) throws IOException { [EOL]     int firstPart = _surrogate; [EOL]     _surrogate = 0; [EOL]     if (secondPart < SURR2_FIRST || secondPart > SURR2_LAST) { [EOL]         throw new IOException("Broken surrogate pair: first char 0x" + Integer.toHexString(firstPart) + ", second 0x" + Integer.toHexString(secondPart) + "; illegal combination"); [EOL]     } [EOL]     return 0x10000 + ((firstPart - SURR1_FIRST) << 10) + (secondPart - SURR2_FIRST); [EOL] } <line_num>: 356,367
protected static void illegalSurrogate(int code) throws IOException { [EOL]     throw new IOException(illegalSurrogateDesc(code)); [EOL] } <line_num>: 369,371
protected static String illegalSurrogateDesc(int code) { [EOL]     if (code > 0x10FFFF) { [EOL]         return "Illegal character point (0x" + Integer.toHexString(code) + ") to output; max is 0x10FFFF as per RFC 4627"; [EOL]     } [EOL]     if (code >= SURR1_FIRST) { [EOL]         if (code <= SURR1_LAST) { [EOL]             return "Unmatched first part of surrogate pair (0x" + Integer.toHexString(code) + ")"; [EOL]         } [EOL]         return "Unmatched second part of surrogate pair (0x" + Integer.toHexString(code) + ")"; [EOL]     } [EOL]     return "Illegal character point (0x" + Integer.toHexString(code) + ") to output"; [EOL] } <line_num>: 373,386
