public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength) { [EOL]     _name = name; [EOL]     _usesPadding = usesPadding; [EOL]     _paddingChar = paddingChar; [EOL]     _maxLineLength = maxLineLength; [EOL]     int alphaLen = base64Alphabet.length(); [EOL]     if (alphaLen != 64) { [EOL]         throw new IllegalArgumentException("Base64Alphabet length must be exactly 64 (was " + alphaLen + ")"); [EOL]     } [EOL]     base64Alphabet.getChars(0, alphaLen, _base64ToAsciiC, 0); [EOL]     Arrays.fill(_asciiToBase64, BASE64_VALUE_INVALID); [EOL]     for (int i = 0; i < alphaLen; ++i) { [EOL]         char alpha = _base64ToAsciiC[i]; [EOL]         _base64ToAsciiB[i] = (byte) alpha; [EOL]         _asciiToBase64[alpha] = i; [EOL]     } [EOL]     if (usesPadding) { [EOL]         _asciiToBase64[(int) paddingChar] = BASE64_VALUE_PADDING; [EOL]     } [EOL] } <line_num>: 109,137
public Base64Variant(Base64Variant base, String name, int maxLineLength) { [EOL]     this(base, name, base._usesPadding, base._paddingChar, maxLineLength); [EOL] } <line_num>: 144,147
public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength) { [EOL]     _name = name; [EOL]     byte[] srcB = base._base64ToAsciiB; [EOL]     System.arraycopy(srcB, 0, this._base64ToAsciiB, 0, srcB.length); [EOL]     char[] srcC = base._base64ToAsciiC; [EOL]     System.arraycopy(srcC, 0, this._base64ToAsciiC, 0, srcC.length); [EOL]     int[] srcV = base._asciiToBase64; [EOL]     System.arraycopy(srcV, 0, this._asciiToBase64, 0, srcV.length); [EOL]     _usesPadding = usesPadding; [EOL]     _paddingChar = paddingChar; [EOL]     _maxLineLength = maxLineLength; [EOL] } <line_num>: 154,167
protected Object readResolve() { [EOL]     return Base64Variants.valueOf(_name); [EOL] } <line_num>: 179,181
public String getName() { [EOL]     return _name; [EOL] } <line_num>: 189,189
public boolean usesPadding() { [EOL]     return _usesPadding; [EOL] } <line_num>: 191,191
public boolean usesPaddingChar(char c) { [EOL]     return c == _paddingChar; [EOL] } <line_num>: 192,192
public boolean usesPaddingChar(int ch) { [EOL]     return ch == (int) _paddingChar; [EOL] } <line_num>: 193,193
public char getPaddingChar() { [EOL]     return _paddingChar; [EOL] } <line_num>: 194,194
public byte getPaddingByte() { [EOL]     return (byte) _paddingChar; [EOL] } <line_num>: 195,195
public int getMaxLineLength() { [EOL]     return _maxLineLength; [EOL] } <line_num>: 197,197
public int decodeBase64Char(char c) { [EOL]     int ch = (int) c; [EOL]     return (ch <= 127) ? _asciiToBase64[ch] : BASE64_VALUE_INVALID; [EOL] } <line_num>: 208,212
public int decodeBase64Char(int ch) { [EOL]     return (ch <= 127) ? _asciiToBase64[ch] : BASE64_VALUE_INVALID; [EOL] } <line_num>: 214,217
public int decodeBase64Byte(byte b) { [EOL]     int ch = (int) b; [EOL]     return (ch <= 127) ? _asciiToBase64[ch] : BASE64_VALUE_INVALID; [EOL] } <line_num>: 219,223
public char encodeBase64BitsAsChar(int value) { [EOL]     return _base64ToAsciiC[value]; [EOL] } <line_num>: 231,237
public int encodeBase64Chunk(int b24, char[] buffer, int ptr) { [EOL]     buffer[ptr++] = _base64ToAsciiC[(b24 >> 18) & 0x3F]; [EOL]     buffer[ptr++] = _base64ToAsciiC[(b24 >> 12) & 0x3F]; [EOL]     buffer[ptr++] = _base64ToAsciiC[(b24 >> 6) & 0x3F]; [EOL]     buffer[ptr++] = _base64ToAsciiC[b24 & 0x3F]; [EOL]     return ptr; [EOL] } <line_num>: 243,250
public void encodeBase64Chunk(StringBuilder sb, int b24) { [EOL]     sb.append(_base64ToAsciiC[(b24 >> 18) & 0x3F]); [EOL]     sb.append(_base64ToAsciiC[(b24 >> 12) & 0x3F]); [EOL]     sb.append(_base64ToAsciiC[(b24 >> 6) & 0x3F]); [EOL]     sb.append(_base64ToAsciiC[b24 & 0x3F]); [EOL] } <line_num>: 252,258
public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr) { [EOL]     buffer[outPtr++] = _base64ToAsciiC[(bits >> 18) & 0x3F]; [EOL]     buffer[outPtr++] = _base64ToAsciiC[(bits >> 12) & 0x3F]; [EOL]     if (_usesPadding) { [EOL]         buffer[outPtr++] = (outputBytes == 2) ? _base64ToAsciiC[(bits >> 6) & 0x3F] : _paddingChar; [EOL]         buffer[outPtr++] = _paddingChar; [EOL]     } else { [EOL]         if (outputBytes == 2) { [EOL]             buffer[outPtr++] = _base64ToAsciiC[(bits >> 6) & 0x3F]; [EOL]         } [EOL]     } [EOL]     return outPtr; [EOL] } <line_num>: 268,282
public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes) { [EOL]     sb.append(_base64ToAsciiC[(bits >> 18) & 0x3F]); [EOL]     sb.append(_base64ToAsciiC[(bits >> 12) & 0x3F]); [EOL]     if (_usesPadding) { [EOL]         sb.append((outputBytes == 2) ? _base64ToAsciiC[(bits >> 6) & 0x3F] : _paddingChar); [EOL]         sb.append(_paddingChar); [EOL]     } else { [EOL]         if (outputBytes == 2) { [EOL]             sb.append(_base64ToAsciiC[(bits >> 6) & 0x3F]); [EOL]         } [EOL]     } [EOL] } <line_num>: 284,297
public byte encodeBase64BitsAsByte(int value) { [EOL]     return _base64ToAsciiB[value]; [EOL] } <line_num>: 299,303
public int encodeBase64Chunk(int b24, byte[] buffer, int ptr) { [EOL]     buffer[ptr++] = _base64ToAsciiB[(b24 >> 18) & 0x3F]; [EOL]     buffer[ptr++] = _base64ToAsciiB[(b24 >> 12) & 0x3F]; [EOL]     buffer[ptr++] = _base64ToAsciiB[(b24 >> 6) & 0x3F]; [EOL]     buffer[ptr++] = _base64ToAsciiB[b24 & 0x3F]; [EOL]     return ptr; [EOL] } <line_num>: 309,316
public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr) { [EOL]     buffer[outPtr++] = _base64ToAsciiB[(bits >> 18) & 0x3F]; [EOL]     buffer[outPtr++] = _base64ToAsciiB[(bits >> 12) & 0x3F]; [EOL]     if (_usesPadding) { [EOL]         byte pb = (byte) _paddingChar; [EOL]         buffer[outPtr++] = (outputBytes == 2) ? _base64ToAsciiB[(bits >> 6) & 0x3F] : pb; [EOL]         buffer[outPtr++] = pb; [EOL]     } else { [EOL]         if (outputBytes == 2) { [EOL]             buffer[outPtr++] = _base64ToAsciiB[(bits >> 6) & 0x3F]; [EOL]         } [EOL]     } [EOL]     return outPtr; [EOL] } <line_num>: 326,341
public String encode(byte[] input) { [EOL]     return encode(input, false); [EOL] } <line_num>: 357,360
public String encode(byte[] input, boolean addQuotes) { [EOL]     int inputEnd = input.length; [EOL]     StringBuilder sb; [EOL]     { [EOL]         int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3); [EOL]         sb = new StringBuilder(outputLen); [EOL]     } [EOL]     if (addQuotes) { [EOL]         sb.append('"'); [EOL]     } [EOL]     int chunksBeforeLF = getMaxLineLength() >> 2; [EOL]     int inputPtr = 0; [EOL]     int safeInputEnd = inputEnd - 3; [EOL]     while (inputPtr <= safeInputEnd) { [EOL]         int b24 = ((int) input[inputPtr++]) << 8; [EOL]         b24 |= ((int) input[inputPtr++]) & 0xFF; [EOL]         b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF); [EOL]         encodeBase64Chunk(sb, b24); [EOL]         if (--chunksBeforeLF <= 0) { [EOL]             sb.append('\\'); [EOL]             sb.append('n'); [EOL]             chunksBeforeLF = getMaxLineLength() >> 2; [EOL]         } [EOL]     } [EOL]     int inputLeft = inputEnd - inputPtr; [EOL]     if (inputLeft > 0) { [EOL]         int b24 = ((int) input[inputPtr++]) << 16; [EOL]         if (inputLeft == 2) { [EOL]             b24 |= (((int) input[inputPtr++]) & 0xFF) << 8; [EOL]         } [EOL]         encodeBase64Partial(sb, b24, inputLeft); [EOL]     } [EOL]     if (addQuotes) { [EOL]         sb.append('"'); [EOL]     } [EOL]     return sb.toString(); [EOL] } <line_num>: 370,417
@SuppressWarnings("resource") [EOL] public byte[] decode(String input) throws IllegalArgumentException { [EOL]     ByteArrayBuilder b = new ByteArrayBuilder(); [EOL]     decode(input, b); [EOL]     return b.toByteArray(); [EOL] } <line_num>: 429,435
public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException { [EOL]     int ptr = 0; [EOL]     int len = str.length(); [EOL]     main_loop: while (ptr < len) { [EOL]         char ch; [EOL]         do { [EOL]             ch = str.charAt(ptr++); [EOL]             if (ptr >= len) { [EOL]                 break main_loop; [EOL]             } [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             _reportInvalidBase64(ch, 0, null); [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (ptr >= len) { [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             _reportInvalidBase64(ch, 1, null); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (ptr >= len) { [EOL]             if (!usesPadding()) { [EOL]                 decodedData >>= 4; [EOL]                 builder.append(decodedData); [EOL]                 break; [EOL]             } [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 _reportInvalidBase64(ch, 2, null); [EOL]             } [EOL]             if (ptr >= len) { [EOL]                 _reportBase64EOF(); [EOL]             } [EOL]             ch = str.charAt(ptr++); [EOL]             if (!usesPaddingChar(ch)) { [EOL]                 _reportInvalidBase64(ch, 3, "expected padding character '" + getPaddingChar() + "'"); [EOL]             } [EOL]             decodedData >>= 4; [EOL]             builder.append(decodedData); [EOL]             continue; [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (ptr >= len) { [EOL]             if (!usesPadding()) { [EOL]                 decodedData >>= 2; [EOL]                 builder.appendTwoBytes(decodedData); [EOL]                 break; [EOL]             } [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 _reportInvalidBase64(ch, 3, null); [EOL]             } [EOL]             decodedData >>= 2; [EOL]             builder.appendTwoBytes(decodedData); [EOL]         } else { [EOL]             decodedData = (decodedData << 6) | bits; [EOL]             builder.appendThreeBytes(decodedData); [EOL]         } [EOL]     } [EOL] } <line_num>: 450,537
@Override [EOL] public String toString() { [EOL]     return _name; [EOL] } <line_num>: 545,546
@Override [EOL] public boolean equals(Object o) { [EOL]     return (o == this); [EOL] } <line_num>: 548,552
@Override [EOL] public int hashCode() { [EOL]     return _name.hashCode(); [EOL] } <line_num>: 554,557
protected void _reportInvalidBase64(char ch, int bindex, String msg) throws IllegalArgumentException { [EOL]     String base; [EOL]     if (ch <= INT_SPACE) { [EOL]         base = "Illegal white space character (code 0x" + Integer.toHexString(ch) + ") as character #" + (bindex + 1) + " of 4-char base64 unit: can only used between units"; [EOL]     } else if (usesPaddingChar(ch)) { [EOL]         base = "Unexpected padding character ('" + getPaddingChar() + "') as character #" + (bindex + 1) + " of 4-char base64 unit: padding only legal as 3rd or 4th character"; [EOL]     } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) { [EOL]         base = "Illegal character (code 0x" + Integer.toHexString(ch) + ") in base64 content"; [EOL]     } else { [EOL]         base = "Illegal character '" + ch + "' (code 0x" + Integer.toHexString(ch) + ") in base64 content"; [EOL]     } [EOL]     if (msg != null) { [EOL]         base = base + ": " + msg; [EOL]     } [EOL]     throw new IllegalArgumentException(base); [EOL] } <line_num>: 569,587
protected void _reportBase64EOF() throws IllegalArgumentException { [EOL]     throw new IllegalArgumentException("Unexpected end-of-String in base64 content"); [EOL] } <line_num>: 589,591
