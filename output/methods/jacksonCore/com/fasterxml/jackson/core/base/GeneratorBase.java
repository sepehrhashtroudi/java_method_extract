protected GeneratorBase(int features, ObjectCodec codec) { [EOL]     super(); [EOL]     _features = features; [EOL]     _writeContext = JsonWriteContext.createRootContext(); [EOL]     _objectCodec = codec; [EOL]     _cfgNumbersAsStrings = isEnabled(Feature.WRITE_NUMBERS_AS_STRINGS); [EOL] } <line_num>: 70,77
@Override [EOL] public Version version() { [EOL]     return VersionUtil.versionFor(getClass()); [EOL] } <line_num>: 83,86
@Override [EOL] public JsonGenerator enable(Feature f) { [EOL]     _features |= f.getMask(); [EOL]     if (f == Feature.WRITE_NUMBERS_AS_STRINGS) { [EOL]         _cfgNumbersAsStrings = true; [EOL]     } else if (f == Feature.ESCAPE_NON_ASCII) { [EOL]         setHighestNonEscapedChar(127); [EOL]     } [EOL]     return this; [EOL] } <line_num>: 94,103
@Override [EOL] public JsonGenerator disable(Feature f) { [EOL]     _features &= ~f.getMask(); [EOL]     if (f == Feature.WRITE_NUMBERS_AS_STRINGS) { [EOL]         _cfgNumbersAsStrings = false; [EOL]     } else if (f == Feature.ESCAPE_NON_ASCII) { [EOL]         setHighestNonEscapedChar(0); [EOL]     } [EOL]     return this; [EOL] } <line_num>: 105,114
@Override [EOL] public final boolean isEnabled(Feature f) { [EOL]     return (_features & f.getMask()) != 0; [EOL] } <line_num>: 118,121
@Override [EOL] public int getFeatureMask() { [EOL]     return _features; [EOL] } <line_num>: 123,126
@Override [EOL] public JsonGenerator setFeatureMask(int mask) { [EOL]     _features = mask; [EOL]     return this; [EOL] } <line_num>: 128,132
@Override [EOL] public JsonGenerator useDefaultPrettyPrinter() { [EOL]     if (getPrettyPrinter() != null) { [EOL]         return this; [EOL]     } [EOL]     return setPrettyPrinter(new DefaultPrettyPrinter()); [EOL] } <line_num>: 134,143
@Override [EOL] public JsonGenerator setCodec(ObjectCodec oc) { [EOL]     _objectCodec = oc; [EOL]     return this; [EOL] } <line_num>: 145,149
@Override [EOL] public final ObjectCodec getCodec() { [EOL]     return _objectCodec; [EOL] } <line_num>: 151,152
@Override [EOL] public final JsonWriteContext getOutputContext() { [EOL]     return _writeContext; [EOL] } <line_num>: 163,164
@Override [EOL] public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException { [EOL]     writeFieldName(name.getValue()); [EOL] } <line_num>: 183,186
@Override [EOL] public void writeString(SerializableString text) throws IOException, JsonGenerationException { [EOL]     writeString(text.getValue()); [EOL] } <line_num>: 196,199
@Override [EOL] public void writeRawValue(String text) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write raw value"); [EOL]     writeRaw(text); [EOL] } <line_num>: 201,206
@Override [EOL] public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write raw value"); [EOL]     writeRaw(text, offset, len); [EOL] } <line_num>: 208,214
@Override [EOL] public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write raw value"); [EOL]     writeRaw(text, offset, len); [EOL] } <line_num>: 216,222
@Override [EOL] public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException { [EOL]     _reportUnsupportedOperation(); [EOL]     return 0; [EOL] } <line_num>: 224,230
@Override [EOL] public void writeObject(Object value) throws IOException, JsonProcessingException { [EOL]     if (value == null) { [EOL]         writeNull(); [EOL]     } else { [EOL]         if (_objectCodec != null) { [EOL]             _objectCodec.writeValue(this, value); [EOL]             return; [EOL]         } [EOL]         _writeSimpleObject(value); [EOL]     } [EOL] } <line_num>: 256,275
@Override [EOL] public void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException { [EOL]     if (rootNode == null) { [EOL]         writeNull(); [EOL]     } else { [EOL]         if (_objectCodec == null) { [EOL]             throw new IllegalStateException("No ObjectCodec defined"); [EOL]         } [EOL]         _objectCodec.writeValue(this, rootNode); [EOL]     } [EOL] } <line_num>: 277,290
@Override [EOL] public abstract void flush() throws IOException; <line_num>: 298,299
@Override [EOL] public void close() throws IOException { [EOL]     _closed = true; [EOL] } <line_num>: 301,305
@Override [EOL] public boolean isClosed() { [EOL]     return _closed; [EOL] } <line_num>: 307,308
@Override [EOL] public final void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == null) { [EOL]         _reportError("No current event to copy"); [EOL]     } [EOL]     switch(t) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             _throwInternal(); [EOL]     } [EOL] } <line_num>: 316,387
@Override [EOL] public final void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.FIELD_NAME) { [EOL]         writeFieldName(jp.getCurrentName()); [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndArray(); [EOL]             break; [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndObject(); [EOL]             break; [EOL]         default: [EOL]             copyCurrentEvent(jp); [EOL]     } [EOL] } <line_num>: 389,420
protected abstract void _releaseBuffers(); <line_num>: 432,432
protected abstract void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; <line_num>: 442,443
protected void _reportError(String msg) throws JsonGenerationException { [EOL]     throw new JsonGenerationException(msg); [EOL] } <line_num>: 452,456
protected void _writeSimpleObject(Object value) throws IOException, JsonGenerationException { [EOL]     if (value == null) { [EOL]         writeNull(); [EOL]         return; [EOL]     } [EOL]     if (value instanceof String) { [EOL]         writeString((String) value); [EOL]         return; [EOL]     } [EOL]     if (value instanceof Number) { [EOL]         Number n = (Number) value; [EOL]         if (n instanceof Integer) { [EOL]             writeNumber(n.intValue()); [EOL]             return; [EOL]         } else if (n instanceof Long) { [EOL]             writeNumber(n.longValue()); [EOL]             return; [EOL]         } else if (n instanceof Double) { [EOL]             writeNumber(n.doubleValue()); [EOL]             return; [EOL]         } else if (n instanceof Float) { [EOL]             writeNumber(n.floatValue()); [EOL]             return; [EOL]         } else if (n instanceof Short) { [EOL]             writeNumber(n.shortValue()); [EOL]             return; [EOL]         } else if (n instanceof Byte) { [EOL]             writeNumber(n.byteValue()); [EOL]             return; [EOL]         } else if (n instanceof BigInteger) { [EOL]             writeNumber((BigInteger) n); [EOL]             return; [EOL]         } else if (n instanceof BigDecimal) { [EOL]             writeNumber((BigDecimal) n); [EOL]             return; [EOL]         } else if (n instanceof AtomicInteger) { [EOL]             writeNumber(((AtomicInteger) n).get()); [EOL]             return; [EOL]         } else if (n instanceof AtomicLong) { [EOL]             writeNumber(((AtomicLong) n).get()); [EOL]             return; [EOL]         } [EOL]     } else if (value instanceof byte[]) { [EOL]         writeBinary((byte[]) value); [EOL]         return; [EOL]     } else if (value instanceof Boolean) { [EOL]         writeBoolean((Boolean) value); [EOL]         return; [EOL]     } else if (value instanceof AtomicBoolean) { [EOL]         writeBoolean(((AtomicBoolean) value).get()); [EOL]         return; [EOL]     } [EOL]     throw new IllegalStateException("No ObjectCodec defined for the generator, can only serialize simple wrapper types (type passed " + value.getClass().getName() + ")"); [EOL] } <line_num>: 465,528
protected final void _throwInternal() { [EOL]     VersionUtil.throwInternal(); [EOL] } <line_num>: 530,532
protected void _reportUnsupportedOperation() { [EOL]     throw new UnsupportedOperationException("Operation not supported by generator of type " + getClass().getName()); [EOL] } <line_num>: 534,536
