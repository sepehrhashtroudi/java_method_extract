protected ParserBase(IOContext ctxt, int features) { [EOL]     super(); [EOL]     _features = features; [EOL]     _ioContext = ctxt; [EOL]     _textBuffer = ctxt.constructTextBuffer(); [EOL]     _parsingContext = JsonReadContext.createRootContext(); [EOL] } <line_num>: 298,305
@Override [EOL] public Version version() { [EOL]     return PackageVersion.VERSION; [EOL] } <line_num>: 307,310
@Override [EOL] public String getCurrentName() throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]         JsonReadContext parent = _parsingContext.getParent(); [EOL]         return parent.getCurrentName(); [EOL]     } [EOL]     return _parsingContext.getCurrentName(); [EOL] } <line_num>: 322,332
@Override [EOL] public void overrideCurrentName(String name) { [EOL]     JsonReadContext ctxt = _parsingContext; [EOL]     if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]         ctxt = ctxt.getParent(); [EOL]     } [EOL]     ctxt.setCurrentName(name); [EOL] } <line_num>: 334,343
@Override [EOL] public void close() throws IOException { [EOL]     if (!_closed) { [EOL]         _closed = true; [EOL]         try { [EOL]             _closeInput(); [EOL]         } finally { [EOL]             _releaseBuffers(); [EOL]         } [EOL]     } [EOL] } <line_num>: 345,358
@Override [EOL] public boolean isClosed() { [EOL]     return _closed; [EOL] } <line_num>: 360,361
@Override [EOL] public JsonReadContext getParsingContext() { [EOL]     return _parsingContext; [EOL] } <line_num>: 363,367
@Override [EOL] public JsonLocation getTokenLocation() { [EOL]     return new JsonLocation(_ioContext.getSourceReference(), getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr()); [EOL] } <line_num>: 374,381
@Override [EOL] public JsonLocation getCurrentLocation() { [EOL]     int col = _inputPtr - _currInputRowStart + 1; [EOL]     return new JsonLocation(_ioContext.getSourceReference(), _currInputProcessed + _inputPtr - 1, _currInputRow, col); [EOL] } <line_num>: 387,394
@Override [EOL] public boolean hasTextCharacters() { [EOL]     if (_currToken == JsonToken.VALUE_STRING) { [EOL]         return true; [EOL]     } [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nameCopied; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 402,412
@Override [EOL] public Object getEmbeddedObject() throws IOException, JsonParseException { [EOL]     return null; [EOL] } <line_num>: 415,418
public long getTokenCharacterOffset() { [EOL]     return _tokenInputTotal; [EOL] } <line_num>: 426,426
public int getTokenLineNr() { [EOL]     return _tokenInputRow; [EOL] } <line_num>: 427,427
public int getTokenColumnNr() { [EOL]     int col = _tokenInputCol; [EOL]     return (col < 0) ? col : (col + 1); [EOL] } <line_num>: 428,432
protected final void loadMoreGuaranteed() throws IOException { [EOL]     if (!loadMore()) { [EOL]         _reportInvalidEOF(); [EOL]     } [EOL] } <line_num>: 440,446
protected abstract boolean loadMore() throws IOException; <line_num>: 454,454
protected abstract void _finishString() throws IOException, JsonParseException; <line_num>: 456,456
protected abstract void _closeInput() throws IOException; <line_num>: 458,458
protected void _releaseBuffers() throws IOException { [EOL]     _textBuffer.releaseBuffers(); [EOL]     char[] buf = _nameCopyBuffer; [EOL]     if (buf != null) { [EOL]         _nameCopyBuffer = null; [EOL]         _ioContext.releaseNameCopyBuffer(buf); [EOL]     } [EOL] } <line_num>: 472,480
@Override [EOL] protected void _handleEOF() throws JsonParseException { [EOL]     if (!_parsingContext.inRoot()) { [EOL]         _reportInvalidEOF(": expected close marker for " + _parsingContext.getTypeDesc() + " (from " + _parsingContext.getStartLocation(_ioContext.getSourceReference()) + ")"); [EOL]     } [EOL] } <line_num>: 487,493
protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException { [EOL]     String startDesc = "" + _parsingContext.getStartLocation(_ioContext.getSourceReference()); [EOL]     _reportError("Unexpected close marker '" + ((char) actCh) + "': expected '" + expCh + "' (for " + _parsingContext.getTypeDesc() + " starting at " + startDesc + ")"); [EOL] } <line_num>: 501,506
public ByteArrayBuilder _getByteArrayBuilder() { [EOL]     if (_byteArrayBuilder == null) { [EOL]         _byteArrayBuilder = new ByteArrayBuilder(); [EOL]     } else { [EOL]         _byteArrayBuilder.reset(); [EOL]     } [EOL]     return _byteArrayBuilder; [EOL] } <line_num>: 514,522
protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen) { [EOL]     if (fractLen < 1 && expLen < 1) { [EOL]         return resetInt(negative, intLen); [EOL]     } [EOL]     return resetFloat(negative, intLen, fractLen, expLen); [EOL] } <line_num>: 532,538
protected final JsonToken resetInt(boolean negative, int intLen) { [EOL]     _numberNegative = negative; [EOL]     _intLength = intLen; [EOL]     _fractLength = 0; [EOL]     _expLength = 0; [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     return JsonToken.VALUE_NUMBER_INT; [EOL] } <line_num>: 540,548
protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen) { [EOL]     _numberNegative = negative; [EOL]     _intLength = intLen; [EOL]     _fractLength = fractLen; [EOL]     _expLength = expLen; [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     return JsonToken.VALUE_NUMBER_FLOAT; [EOL] } <line_num>: 550,558
protected final JsonToken resetAsNaN(String valueStr, double value) { [EOL]     _textBuffer.resetWithString(valueStr); [EOL]     _numberDouble = value; [EOL]     _numTypesValid = NR_DOUBLE; [EOL]     return JsonToken.VALUE_NUMBER_FLOAT; [EOL] } <line_num>: 560,566
@Override [EOL] public Number getNumberValue() throws IOException, JsonParseException { [EOL]     if (_numTypesValid == NR_UNKNOWN) { [EOL]         _parseNumericValue(NR_UNKNOWN); [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         if ((_numTypesValid & NR_INT) != 0) { [EOL]             return _numberInt; [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) != 0) { [EOL]             return _numberLong; [EOL]         } [EOL]         if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]             return _numberBigInt; [EOL]         } [EOL]         return _numberBigDecimal; [EOL]     } [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         return _numberBigDecimal; [EOL]     } [EOL]     if ((_numTypesValid & NR_DOUBLE) == 0) { [EOL]         _throwInternal(); [EOL]     } [EOL]     return _numberDouble; [EOL] } <line_num>: 574,605
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     if (_numTypesValid == NR_UNKNOWN) { [EOL]         _parseNumericValue(NR_UNKNOWN); [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         if ((_numTypesValid & NR_INT) != 0) { [EOL]             return NumberType.INT; [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) != 0) { [EOL]             return NumberType.LONG; [EOL]         } [EOL]         return NumberType.BIG_INTEGER; [EOL]     } [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         return NumberType.BIG_DECIMAL; [EOL]     } [EOL]     return NumberType.DOUBLE; [EOL] } <line_num>: 607,633
@Override [EOL] public int getIntValue() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_INT) == 0) { [EOL]         if (_numTypesValid == NR_UNKNOWN) { [EOL]             _parseNumericValue(NR_INT); [EOL]         } [EOL]         if ((_numTypesValid & NR_INT) == 0) { [EOL]             convertNumberToInt(); [EOL]         } [EOL]     } [EOL]     return _numberInt; [EOL] } <line_num>: 635,647
@Override [EOL] public long getLongValue() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_LONG) == 0) { [EOL]         if (_numTypesValid == NR_UNKNOWN) { [EOL]             _parseNumericValue(NR_LONG); [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) == 0) { [EOL]             convertNumberToLong(); [EOL]         } [EOL]     } [EOL]     return _numberLong; [EOL] } <line_num>: 649,661
@Override [EOL] public BigInteger getBigIntegerValue() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_BIGINT) == 0) { [EOL]         if (_numTypesValid == NR_UNKNOWN) { [EOL]             _parseNumericValue(NR_BIGINT); [EOL]         } [EOL]         if ((_numTypesValid & NR_BIGINT) == 0) { [EOL]             convertNumberToBigInteger(); [EOL]         } [EOL]     } [EOL]     return _numberBigInt; [EOL] } <line_num>: 663,675
@Override [EOL] public float getFloatValue() throws IOException, JsonParseException { [EOL]     double value = getDoubleValue(); [EOL]     return (float) value; [EOL] } <line_num>: 677,690
@Override [EOL] public double getDoubleValue() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_DOUBLE) == 0) { [EOL]         if (_numTypesValid == NR_UNKNOWN) { [EOL]             _parseNumericValue(NR_DOUBLE); [EOL]         } [EOL]         if ((_numTypesValid & NR_DOUBLE) == 0) { [EOL]             convertNumberToDouble(); [EOL]         } [EOL]     } [EOL]     return _numberDouble; [EOL] } <line_num>: 692,704
@Override [EOL] public BigDecimal getDecimalValue() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) == 0) { [EOL]         if (_numTypesValid == NR_UNKNOWN) { [EOL]             _parseNumericValue(NR_BIGDECIMAL); [EOL]         } [EOL]         if ((_numTypesValid & NR_BIGDECIMAL) == 0) { [EOL]             convertNumberToBigDecimal(); [EOL]         } [EOL]     } [EOL]     return _numberBigDecimal; [EOL] } <line_num>: 706,718
protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] } <line_num>: 735,785
private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException { [EOL]     try { [EOL]         if (expType == NR_BIGDECIMAL) { [EOL]             _numberBigDecimal = _textBuffer.contentsAsDecimal(); [EOL]             _numTypesValid = NR_BIGDECIMAL; [EOL]         } else { [EOL]             _numberDouble = _textBuffer.contentsAsDouble(); [EOL]             _numTypesValid = NR_DOUBLE; [EOL]         } [EOL]     } catch (NumberFormatException nex) { [EOL]         _wrapError("Malformed numeric value '" + _textBuffer.contentsAsString() + "'", nex); [EOL]     } [EOL] } <line_num>: 787,810
private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException { [EOL]     String numStr = _textBuffer.contentsAsString(); [EOL]     try { [EOL]         if (NumberInput.inLongRange(buf, offset, len, _numberNegative)) { [EOL]             _numberLong = Long.parseLong(numStr); [EOL]             _numTypesValid = NR_LONG; [EOL]         } else { [EOL]             _numberBigInt = new BigInteger(numStr); [EOL]             _numTypesValid = NR_BIGINT; [EOL]         } [EOL]     } catch (NumberFormatException nex) { [EOL]         _wrapError("Malformed numeric value '" + numStr + "'", nex); [EOL]     } [EOL] } <line_num>: 812,831
protected void convertNumberToInt() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_LONG) != 0) { [EOL]         int result = (int) _numberLong; [EOL]         if (((long) result) != _numberLong) { [EOL]             _reportError("Numeric value (" + getText() + ") out of range of int"); [EOL]         } [EOL]         _numberInt = result; [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = _numberBigInt.intValue(); [EOL]     } else if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL]         if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = (int) _numberDouble; [EOL]     } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) { [EOL]             reportOverflowInt(); [EOL]         } [EOL]         _numberInt = _numberBigDecimal.intValue(); [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_INT; [EOL] } <line_num>: 839,872
protected void convertNumberToLong() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_INT) != 0) { [EOL]         _numberLong = (long) _numberInt; [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         if (BI_MIN_LONG.compareTo(_numberBigInt) > 0 || BI_MAX_LONG.compareTo(_numberBigInt) < 0) { [EOL]             reportOverflowLong(); [EOL]         } [EOL]         _numberLong = _numberBigInt.longValue(); [EOL]     } else if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL]         if (_numberDouble < MIN_LONG_D || _numberDouble > MAX_LONG_D) { [EOL]             reportOverflowLong(); [EOL]         } [EOL]         _numberLong = (long) _numberDouble; [EOL]     } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         if (BD_MIN_LONG.compareTo(_numberBigDecimal) > 0 || BD_MAX_LONG.compareTo(_numberBigDecimal) < 0) { [EOL]             reportOverflowLong(); [EOL]         } [EOL]         _numberLong = _numberBigDecimal.longValue(); [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_LONG; [EOL] } <line_num>: 874,901
protected void convertNumberToBigInteger() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         _numberBigInt = _numberBigDecimal.toBigInteger(); [EOL]     } else if ((_numTypesValid & NR_LONG) != 0) { [EOL]         _numberBigInt = BigInteger.valueOf(_numberLong); [EOL]     } else if ((_numTypesValid & NR_INT) != 0) { [EOL]         _numberBigInt = BigInteger.valueOf(_numberInt); [EOL]     } else if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL]         _numberBigInt = BigDecimal.valueOf(_numberDouble).toBigInteger(); [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_BIGINT; [EOL] } <line_num>: 903,919
protected void convertNumberToDouble() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         _numberDouble = _numberBigDecimal.doubleValue(); [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         _numberDouble = _numberBigInt.doubleValue(); [EOL]     } else if ((_numTypesValid & NR_LONG) != 0) { [EOL]         _numberDouble = (double) _numberLong; [EOL]     } else if ((_numTypesValid & NR_INT) != 0) { [EOL]         _numberDouble = (double) _numberInt; [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_DOUBLE; [EOL] } <line_num>: 921,942
protected void convertNumberToBigDecimal() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL]         _numberBigDecimal = NumberInput.parseBigDecimal(getText()); [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         _numberBigDecimal = new BigDecimal(_numberBigInt); [EOL]     } else if ((_numTypesValid & NR_LONG) != 0) { [EOL]         _numberBigDecimal = BigDecimal.valueOf(_numberLong); [EOL]     } else if ((_numTypesValid & NR_INT) != 0) { [EOL]         _numberBigDecimal = BigDecimal.valueOf(_numberInt); [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_BIGDECIMAL; [EOL] } <line_num>: 944,969
protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException { [EOL]     String msg = "Unexpected character (" + _getCharDesc(ch) + ") in numeric value"; [EOL]     if (comment != null) { [EOL]         msg += ": " + comment; [EOL]     } [EOL]     _reportError(msg); [EOL] } <line_num>: 977,985
protected void reportInvalidNumber(String msg) throws JsonParseException { [EOL]     _reportError("Invalid numeric value: " + msg); [EOL] } <line_num>: 987,991
protected void reportOverflowInt() throws IOException, JsonParseException { [EOL]     _reportError("Numeric value (" + getText() + ") out of range of int (" + Integer.MIN_VALUE + " - " + Integer.MAX_VALUE + ")"); [EOL] } <line_num>: 993,997
protected void reportOverflowLong() throws IOException, JsonParseException { [EOL]     _reportError("Numeric value (" + getText() + ") out of range of long (" + Long.MIN_VALUE + " - " + Long.MAX_VALUE + ")"); [EOL] } <line_num>: 999,1003
protected char _decodeEscaped() throws IOException, JsonParseException { [EOL]     throw new UnsupportedOperationException(); [EOL] } <line_num>: 1016,1019
protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException { [EOL]     if (ch != '\\') { [EOL]         throw reportInvalidBase64Char(b64variant, ch, index); [EOL]     } [EOL]     int unescaped = _decodeEscaped(); [EOL]     if (unescaped <= INT_SPACE) { [EOL]         if (index == 0) { [EOL]             return -1; [EOL]         } [EOL]     } [EOL]     int bits = b64variant.decodeBase64Char(unescaped); [EOL]     if (bits < 0) { [EOL]         throw reportInvalidBase64Char(b64variant, unescaped, index); [EOL]     } [EOL]     return bits; [EOL] } <line_num>: 1021,1041
protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException { [EOL]     if (ch != '\\') { [EOL]         throw reportInvalidBase64Char(b64variant, ch, index); [EOL]     } [EOL]     char unescaped = _decodeEscaped(); [EOL]     if (unescaped <= INT_SPACE) { [EOL]         if (index == 0) { [EOL]             return -1; [EOL]         } [EOL]     } [EOL]     int bits = b64variant.decodeBase64Char(unescaped); [EOL]     if (bits < 0) { [EOL]         throw reportInvalidBase64Char(b64variant, unescaped, index); [EOL]     } [EOL]     return bits; [EOL] } <line_num>: 1043,1063
protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException { [EOL]     return reportInvalidBase64Char(b64variant, ch, bindex, null); [EOL] } <line_num>: 1065,1069
protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException { [EOL]     String base; [EOL]     if (ch <= INT_SPACE) { [EOL]         base = "Illegal white space character (code 0x" + Integer.toHexString(ch) + ") as character #" + (bindex + 1) + " of 4-char base64 unit: can only used between units"; [EOL]     } else if (b64variant.usesPaddingChar(ch)) { [EOL]         base = "Unexpected padding character ('" + b64variant.getPaddingChar() + "') as character #" + (bindex + 1) + " of 4-char base64 unit: padding only legal as 3rd or 4th character"; [EOL]     } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) { [EOL]         base = "Illegal character (code 0x" + Integer.toHexString(ch) + ") in base64 content"; [EOL]     } else { [EOL]         base = "Illegal character '" + ((char) ch) + "' (code 0x" + Integer.toHexString(ch) + ") in base64 content"; [EOL]     } [EOL]     if (msg != null) { [EOL]         base = base + ": " + msg; [EOL]     } [EOL]     return new IllegalArgumentException(base); [EOL] } <line_num>: 1075,1093
