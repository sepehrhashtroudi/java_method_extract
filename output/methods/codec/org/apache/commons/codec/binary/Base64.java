private static boolean isBase64(byte octect) { [EOL]     if (octect == PAD) { [EOL]         return true; [EOL]     } else if (octect < 0 || base64Alphabet[octect] == -1) { [EOL]         return false; [EOL]     } else { [EOL]         return true; [EOL]     } [EOL] } <line_num>: 169,177
public static boolean isArrayByteBase64(byte[] arrayOctect) { [EOL]     arrayOctect = discardWhitespace(arrayOctect); [EOL]     int length = arrayOctect.length; [EOL]     if (length == 0) { [EOL]         return true; [EOL]     } [EOL]     for (int i = 0; i < length; i++) { [EOL]         if (!isBase64(arrayOctect[i])) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 187,203
public static byte[] encodeBase64(byte[] binaryData) { [EOL]     return encodeBase64(binaryData, false); [EOL] } <line_num>: 212,214
public static byte[] encodeBase64Chunked(byte[] binaryData) { [EOL]     return encodeBase64(binaryData, true); [EOL] } <line_num>: 223,225
public Object decode(Object pObject) throws DecoderException { [EOL]     if (!(pObject instanceof byte[])) { [EOL]         throw new DecoderException("Parameter supplied to Base64 decode is not a byte[]"); [EOL]     } [EOL]     return decode((byte[]) pObject); [EOL] } <line_num>: 237,242
public byte[] decode(byte[] pArray) { [EOL]     return decodeBase64(pArray); [EOL] } <line_num>: 251,253
public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) { [EOL]     long binaryDataLength = binaryData.length; [EOL]     long lengthDataBits = binaryDataLength * EIGHTBIT; [EOL]     long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP; [EOL]     long tripletCount = lengthDataBits / TWENTYFOURBITGROUP; [EOL]     long encodedDataLengthLong = 0; [EOL]     int chunckCount = 0; [EOL]     if (fewerThan24bits != 0) { [EOL]         encodedDataLengthLong = (tripletCount + 1) * 4; [EOL]     } else { [EOL]         encodedDataLengthLong = tripletCount * 4; [EOL]     } [EOL]     if (isChunked) { [EOL]         chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math.ceil((float) encodedDataLengthLong / CHUNK_SIZE)); [EOL]         encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length; [EOL]     } [EOL]     if (encodedDataLengthLong > Integer.MAX_VALUE) { [EOL]         throw new IllegalArgumentException("Input array too big, output array would be bigger than Integer.MAX_VALUE=" + Integer.MAX_VALUE); [EOL]     } [EOL]     int encodedDataLength = (int) encodedDataLengthLong; [EOL]     byte[] encodedData = new byte[encodedDataLength]; [EOL]     byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0; [EOL]     int encodedIndex = 0; [EOL]     int dataIndex = 0; [EOL]     int i = 0; [EOL]     int nextSeparatorIndex = CHUNK_SIZE; [EOL]     int chunksSoFar = 0; [EOL]     for (i = 0; i < tripletCount; i++) { [EOL]         dataIndex = i * 3; [EOL]         b1 = binaryData[dataIndex]; [EOL]         b2 = binaryData[dataIndex + 1]; [EOL]         b3 = binaryData[dataIndex + 2]; [EOL]         l = (byte) (b2 & 0x0f); [EOL]         k = (byte) (b1 & 0x03); [EOL]         byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0); [EOL]         byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0); [EOL]         byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc); [EOL]         encodedData[encodedIndex] = lookUpBase64Alphabet[val1]; [EOL]         encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)]; [EOL]         encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3]; [EOL]         encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f]; [EOL]         encodedIndex += 4; [EOL]         if (isChunked) { [EOL]             if (encodedIndex == nextSeparatorIndex) { [EOL]                 System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length); [EOL]                 chunksSoFar++; [EOL]                 nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length); [EOL]                 encodedIndex += CHUNK_SEPARATOR.length; [EOL]             } [EOL]         } [EOL]     } [EOL]     dataIndex = i * 3; [EOL]     if (fewerThan24bits == EIGHTBIT) { [EOL]         b1 = binaryData[dataIndex]; [EOL]         k = (byte) (b1 & 0x03); [EOL]         byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0); [EOL]         encodedData[encodedIndex] = lookUpBase64Alphabet[val1]; [EOL]         encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4]; [EOL]         encodedData[encodedIndex + 2] = PAD; [EOL]         encodedData[encodedIndex + 3] = PAD; [EOL]     } else if (fewerThan24bits == SIXTEENBIT) { [EOL]         b1 = binaryData[dataIndex]; [EOL]         b2 = binaryData[dataIndex + 1]; [EOL]         l = (byte) (b2 & 0x0f); [EOL]         k = (byte) (b1 & 0x03); [EOL]         byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0); [EOL]         byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0); [EOL]         encodedData[encodedIndex] = lookUpBase64Alphabet[val1]; [EOL]         encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)]; [EOL]         encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2]; [EOL]         encodedData[encodedIndex + 3] = PAD; [EOL]     } [EOL]     if (isChunked) { [EOL]         if (chunksSoFar < chunckCount) { [EOL]             System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length, CHUNK_SEPARATOR.length); [EOL]         } [EOL]     } [EOL]     return encodedData; [EOL] } <line_num>: 266,383
public static byte[] decodeBase64(byte[] base64Data) { [EOL]     base64Data = discardNonBase64(base64Data); [EOL]     if (base64Data.length == 0) { [EOL]         return new byte[0]; [EOL]     } [EOL]     int numberQuadruple = base64Data.length / FOURBYTE; [EOL]     byte[] decodedData = null; [EOL]     byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0; [EOL]     int encodedIndex = 0; [EOL]     int dataIndex = 0; [EOL]     { [EOL]         int lastData = base64Data.length; [EOL]         while (base64Data[lastData - 1] == PAD) { [EOL]             if (--lastData == 0) { [EOL]                 return new byte[0]; [EOL]             } [EOL]         } [EOL]         decodedData = new byte[lastData - numberQuadruple]; [EOL]     } [EOL]     for (int i = 0; i < numberQuadruple; i++) { [EOL]         dataIndex = i * 4; [EOL]         marker0 = base64Data[dataIndex + 2]; [EOL]         marker1 = base64Data[dataIndex + 3]; [EOL]         b1 = base64Alphabet[base64Data[dataIndex]]; [EOL]         b2 = base64Alphabet[base64Data[dataIndex + 1]]; [EOL]         if (marker0 != PAD && marker1 != PAD) { [EOL]             b3 = base64Alphabet[marker0]; [EOL]             b4 = base64Alphabet[marker1]; [EOL]             decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4); [EOL]             decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf)); [EOL]             decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4); [EOL]         } else if (marker0 == PAD) { [EOL]             decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4); [EOL]         } else if (marker1 == PAD) { [EOL]             b3 = base64Alphabet[marker0]; [EOL]             decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4); [EOL]             decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf)); [EOL]         } [EOL]         encodedIndex += 3; [EOL]     } [EOL]     return decodedData; [EOL] } <line_num>: 392,450
static byte[] discardWhitespace(byte[] data) { [EOL]     byte[] groomedData = new byte[data.length]; [EOL]     int bytesCopied = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         switch(data[i]) { [EOL]             case (byte) ' ': [EOL]             case (byte) '\n': [EOL]             case (byte) '\r': [EOL]             case (byte) '\t': [EOL]                 break; [EOL]             default: [EOL]                 groomedData[bytesCopied++] = data[i]; [EOL]         } [EOL]     } [EOL]     byte[] packedData = new byte[bytesCopied]; [EOL]     System.arraycopy(groomedData, 0, packedData, 0, bytesCopied); [EOL]     return packedData; [EOL] } <line_num>: 459,480
static byte[] discardNonBase64(byte[] data) { [EOL]     byte[] groomedData = new byte[data.length]; [EOL]     int bytesCopied = 0; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         if (isBase64(data[i])) { [EOL]             groomedData[bytesCopied++] = data[i]; [EOL]         } [EOL]     } [EOL]     byte[] packedData = new byte[bytesCopied]; [EOL]     System.arraycopy(groomedData, 0, packedData, 0, bytesCopied); [EOL]     return packedData; [EOL] } <line_num>: 490,505
public Object encode(Object pObject) throws EncoderException { [EOL]     if (!(pObject instanceof byte[])) { [EOL]         throw new EncoderException("Parameter supplied to Base64 encode is not a byte[]"); [EOL]     } [EOL]     return encode((byte[]) pObject); [EOL] } <line_num>: 519,524
public byte[] encode(byte[] pArray) { [EOL]     return encodeBase64(pArray, false); [EOL] } <line_num>: 533,535
public static BigInteger decodeInteger(byte[] pArray) { [EOL]     return new BigInteger(1, decodeBase64(pArray)); [EOL] } <line_num>: 545,547
public static byte[] encodeInteger(BigInteger bigInt) { [EOL]     if (bigInt == null) { [EOL]         throw new NullPointerException("encodeInteger called with null parameter"); [EOL]     } [EOL]     return encodeBase64(toIntegerBytes(bigInt), false); [EOL] } <line_num>: 557,563
static byte[] toIntegerBytes(BigInteger bigInt) { [EOL]     int bitlen = bigInt.bitLength(); [EOL]     bitlen = ((bitlen + 7) >> 3) << 3; [EOL]     byte[] bigBytes = bigInt.toByteArray(); [EOL]     if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) { [EOL]         return bigBytes; [EOL]     } [EOL]     int startSrc = 0; [EOL]     int len = bigBytes.length; [EOL]     if ((bigInt.bitLength() % 8) == 0) { [EOL]         startSrc = 1; [EOL]         len--; [EOL]     } [EOL]     int startDst = bitlen / 8 - len; [EOL]     byte[] resizedBytes = new byte[bitlen / 8]; [EOL]     System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len); [EOL]     return resizedBytes; [EOL] } <line_num>: 572,599
