public GaussNewtonOptimizer(ConvergenceChecker<PointVectorValuePair> checker) { [EOL]     this(true, checker); [EOL] } <line_num>: 66,68
public GaussNewtonOptimizer(final boolean useLU, ConvergenceChecker<PointVectorValuePair> checker) { [EOL]     super(checker); [EOL]     this.useLU = useLU; [EOL] } <line_num>: 76,80
@Override [EOL] public PointVectorValuePair doOptimize() { [EOL]     checkParameters(); [EOL]     final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); [EOL]     if (checker == null) { [EOL]         throw new NullArgumentException(); [EOL]     } [EOL]     final double[] targetValues = getTarget(); [EOL]     final int nR = targetValues.length; [EOL]     final RealMatrix weightMatrix = getWeight(); [EOL]     final double[] residualsWeights = new double[nR]; [EOL]     for (int i = 0; i < nR; i++) { [EOL]         residualsWeights[i] = weightMatrix.getEntry(i, i); [EOL]     } [EOL]     final double[] currentPoint = getStartPoint(); [EOL]     final int nC = currentPoint.length; [EOL]     PointVectorValuePair current = null; [EOL]     for (boolean converged = false; !converged; ) { [EOL]         incrementIterationCount(); [EOL]         PointVectorValuePair previous = current; [EOL]         final double[] currentObjective = computeObjectiveValue(currentPoint); [EOL]         final double[] currentResiduals = computeResiduals(currentObjective); [EOL]         final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint); [EOL]         current = new PointVectorValuePair(currentPoint, currentObjective); [EOL]         final double[] b = new double[nC]; [EOL]         final double[][] a = new double[nC][nC]; [EOL]         for (int i = 0; i < nR; ++i) { [EOL]             final double[] grad = weightedJacobian.getRow(i); [EOL]             final double weight = residualsWeights[i]; [EOL]             final double residual = currentResiduals[i]; [EOL]             final double wr = weight * residual; [EOL]             for (int j = 0; j < nC; ++j) { [EOL]                 b[j] += wr * grad[j]; [EOL]             } [EOL]             for (int k = 0; k < nC; ++k) { [EOL]                 double[] ak = a[k]; [EOL]                 double wgk = weight * grad[k]; [EOL]                 for (int l = 0; l < nC; ++l) { [EOL]                     ak[l] += wgk * grad[l]; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (previous != null) { [EOL]             converged = checker.converged(getIterations(), previous, current); [EOL]             if (converged) { [EOL]                 setCost(computeCost(currentResiduals)); [EOL]                 return current; [EOL]             } [EOL]         } [EOL]         try { [EOL]             RealMatrix mA = new BlockRealMatrix(a); [EOL]             DecompositionSolver solver = useLU ? new LUDecomposition(mA).getSolver() : new QRDecomposition(mA).getSolver(); [EOL]             final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray(); [EOL]             for (int i = 0; i < nC; ++i) { [EOL]                 currentPoint[i] += dX[i]; [EOL]             } [EOL]         } catch (SingularMatrixException e) { [EOL]             throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM); [EOL]         } [EOL]     } [EOL]     throw new MathInternalError(); [EOL] } <line_num>: 83,172
private void checkParameters() { [EOL]     if (getLowerBound() != null || getUpperBound() != null) { [EOL]         throw new MathUnsupportedOperationException(LocalizedFormats.CONSTRAINT); [EOL]     } [EOL] } <line_num>: 178,183
