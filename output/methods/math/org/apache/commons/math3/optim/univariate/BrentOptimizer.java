public BrentOptimizer(double rel, double abs, ConvergenceChecker<UnivariatePointValuePair> checker) { [EOL]     super(checker); [EOL]     if (rel < MIN_RELATIVE_TOLERANCE) { [EOL]         throw new NumberIsTooSmallException(rel, MIN_RELATIVE_TOLERANCE, true); [EOL]     } [EOL]     if (abs <= 0) { [EOL]         throw new NotStrictlyPositiveException(abs); [EOL]     } [EOL]     relativeThreshold = rel; [EOL]     absoluteThreshold = abs; [EOL] } <line_num>: 78,92
public BrentOptimizer(double rel, double abs) { [EOL]     this(rel, abs, null); [EOL] } <line_num>: 108,111
@Override [EOL] protected UnivariatePointValuePair doOptimize() { [EOL]     final boolean isMinim = getGoalType() == GoalType.MINIMIZE; [EOL]     final double lo = getMin(); [EOL]     final double mid = getStartValue(); [EOL]     final double hi = getMax(); [EOL]     final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker(); [EOL]     double a; [EOL]     double b; [EOL]     if (lo < hi) { [EOL]         a = lo; [EOL]         b = hi; [EOL]     } else { [EOL]         a = hi; [EOL]         b = lo; [EOL]     } [EOL]     double x = mid; [EOL]     double v = x; [EOL]     double w = x; [EOL]     double d = 0; [EOL]     double e = 0; [EOL]     double fx = computeObjectiveValue(x); [EOL]     if (!isMinim) { [EOL]         fx = -fx; [EOL]     } [EOL]     double fv = fx; [EOL]     double fw = fx; [EOL]     UnivariatePointValuePair previous = null; [EOL]     UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx); [EOL]     UnivariatePointValuePair best = current; [EOL]     int iter = 0; [EOL]     while (true) { [EOL]         final double m = 0.5 * (a + b); [EOL]         final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold; [EOL]         final double tol2 = 2 * tol1; [EOL]         final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a); [EOL]         if (!stop) { [EOL]             double p = 0; [EOL]             double q = 0; [EOL]             double r = 0; [EOL]             double u = 0; [EOL]             if (FastMath.abs(e) > tol1) { [EOL]                 r = (x - w) * (fx - fv); [EOL]                 q = (x - v) * (fx - fw); [EOL]                 p = (x - v) * q - (x - w) * r; [EOL]                 q = 2 * (q - r); [EOL]                 if (q > 0) { [EOL]                     p = -p; [EOL]                 } else { [EOL]                     q = -q; [EOL]                 } [EOL]                 r = e; [EOL]                 e = d; [EOL]                 if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) { [EOL]                     d = p / q; [EOL]                     u = x + d; [EOL]                     if (u - a < tol2 || b - u < tol2) { [EOL]                         if (x <= m) { [EOL]                             d = tol1; [EOL]                         } else { [EOL]                             d = -tol1; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     if (x < m) { [EOL]                         e = b - x; [EOL]                     } else { [EOL]                         e = a - x; [EOL]                     } [EOL]                     d = GOLDEN_SECTION * e; [EOL]                 } [EOL]             } else { [EOL]                 if (x < m) { [EOL]                     e = b - x; [EOL]                 } else { [EOL]                     e = a - x; [EOL]                 } [EOL]                 d = GOLDEN_SECTION * e; [EOL]             } [EOL]             if (FastMath.abs(d) < tol1) { [EOL]                 if (d >= 0) { [EOL]                     u = x + tol1; [EOL]                 } else { [EOL]                     u = x - tol1; [EOL]                 } [EOL]             } else { [EOL]                 u = x + d; [EOL]             } [EOL]             double fu = computeObjectiveValue(u); [EOL]             if (!isMinim) { [EOL]                 fu = -fu; [EOL]             } [EOL]             previous = current; [EOL]             current = new UnivariatePointValuePair(u, isMinim ? fu : -fu); [EOL]             best = best(best, best(previous, current, isMinim), isMinim); [EOL]             if (checker != null && checker.converged(iter, previous, current)) { [EOL]                 return best; [EOL]             } [EOL]             if (fu <= fx) { [EOL]                 if (u < x) { [EOL]                     b = x; [EOL]                 } else { [EOL]                     a = x; [EOL]                 } [EOL]                 v = w; [EOL]                 fv = fw; [EOL]                 w = x; [EOL]                 fw = fx; [EOL]                 x = u; [EOL]                 fx = fu; [EOL]             } else { [EOL]                 if (u < x) { [EOL]                     a = u; [EOL]                 } else { [EOL]                     b = u; [EOL]                 } [EOL]                 if (fu <= fw || Precision.equals(w, x)) { [EOL]                     v = w; [EOL]                     fv = fw; [EOL]                     w = u; [EOL]                     fw = fu; [EOL]                 } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) { [EOL]                     v = u; [EOL]                     fv = fu; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             return best(best, best(previous, current, isMinim), isMinim); [EOL]         } [EOL]         ++iter; [EOL]     } [EOL] } <line_num>: 114,286
private UnivariatePointValuePair best(UnivariatePointValuePair a, UnivariatePointValuePair b, boolean isMinim) { [EOL]     if (a == null) { [EOL]         return b; [EOL]     } [EOL]     if (b == null) { [EOL]         return a; [EOL]     } [EOL]     if (isMinim) { [EOL]         return a.getValue() <= b.getValue() ? a : b; [EOL]     } else { [EOL]         return a.getValue() >= b.getValue() ? a : b; [EOL]     } [EOL] } <line_num>: 299,314
