public MultiStartUnivariateOptimizer(final UnivariateOptimizer optimizer, final int starts, final RandomGenerator generator) { [EOL]     super(optimizer.getConvergenceChecker()); [EOL]     if (starts < 1) { [EOL]         throw new NotStrictlyPositiveException(starts); [EOL]     } [EOL]     this.optimizer = optimizer; [EOL]     this.starts = starts; [EOL]     this.generator = generator; [EOL] } <line_num>: 76,88
@Override [EOL] public int getEvaluations() { [EOL]     return totalEvaluations; [EOL] } <line_num>: 91,94
public UnivariatePointValuePair[] getOptima() { [EOL]     if (optima == null) { [EOL]         throw new MathIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET); [EOL]     } [EOL]     return optima.clone(); [EOL] } <line_num>: 118,123
@Override [EOL] public UnivariatePointValuePair optimize(OptimizationData... optData) { [EOL]     optimData = optData; [EOL]     return super.optimize(optData); [EOL] } <line_num>: 131,137
@Override [EOL] protected UnivariatePointValuePair doOptimize() { [EOL]     for (int i = 0; i < optimData.length; i++) { [EOL]         if (optimData[i] instanceof MaxEval) { [EOL]             optimData[i] = null; [EOL]             maxEvalIndex = i; [EOL]             continue; [EOL]         } [EOL]         if (optimData[i] instanceof SearchInterval) { [EOL]             optimData[i] = null; [EOL]             searchIntervalIndex = i; [EOL]             continue; [EOL]         } [EOL]     } [EOL]     if (maxEvalIndex == -1) { [EOL]         throw new MathIllegalStateException(); [EOL]     } [EOL]     if (searchIntervalIndex == -1) { [EOL]         throw new MathIllegalStateException(); [EOL]     } [EOL]     RuntimeException lastException = null; [EOL]     optima = new UnivariatePointValuePair[starts]; [EOL]     totalEvaluations = 0; [EOL]     final int maxEval = getMaxEvaluations(); [EOL]     final double min = getMin(); [EOL]     final double max = getMax(); [EOL]     final double startValue = getStartValue(); [EOL]     for (int i = 0; i < starts; i++) { [EOL]         try { [EOL]             optimData[maxEvalIndex] = new MaxEval(maxEval - totalEvaluations); [EOL]             final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min); [EOL]             optimData[searchIntervalIndex] = new SearchInterval(min, max, s); [EOL]             optima[i] = optimizer.optimize(optimData); [EOL]         } catch (RuntimeException mue) { [EOL]             lastException = mue; [EOL]             optima[i] = null; [EOL]         } [EOL]         totalEvaluations += optimizer.getEvaluations(); [EOL]     } [EOL]     sortPairs(getGoalType()); [EOL]     if (optima[0] == null) { [EOL]         throw lastException; [EOL]     } [EOL]     return optima[0]; [EOL] } <line_num>: 140,205
public int compare(final UnivariatePointValuePair o1, final UnivariatePointValuePair o2) { [EOL]     if (o1 == null) { [EOL]         return (o2 == null) ? 0 : 1; [EOL]     } else if (o2 == null) { [EOL]         return -1; [EOL]     } [EOL]     final double v1 = o1.getValue(); [EOL]     final double v2 = o2.getValue(); [EOL]     return (goal == GoalType.MINIMIZE) ? Double.compare(v1, v2) : Double.compare(v2, v1); [EOL] } <line_num>: 214,225
private void sortPairs(final GoalType goal) { [EOL]     Arrays.sort(optima, new Comparator<UnivariatePointValuePair>() { [EOL]  [EOL]         public int compare(final UnivariatePointValuePair o1, final UnivariatePointValuePair o2) { [EOL]             if (o1 == null) { [EOL]                 return (o2 == null) ? 0 : 1; [EOL]             } else if (o2 == null) { [EOL]                 return -1; [EOL]             } [EOL]             final double v1 = o1.getValue(); [EOL]             final double v2 = o2.getValue(); [EOL]             return (goal == GoalType.MINIMIZE) ? Double.compare(v1, v2) : Double.compare(v2, v1); [EOL]         } [EOL]     }); [EOL] } <line_num>: 212,227
