public SimplexOptimizer(ConvergenceChecker<PointValuePair> checker) { [EOL]     super(checker); [EOL] } <line_num>: 96,98
public SimplexOptimizer(double rel, double abs) { [EOL]     this(new SimpleValueChecker(rel, abs)); [EOL] } <line_num>: 104,106
@Override [EOL] public PointValuePair optimize(OptimizationData... optData) { [EOL]     return super.optimize(optData); [EOL] } <line_num>: 119,123
public double value(double[] point) { [EOL]     return computeObjectiveValue(point); [EOL] } <line_num>: 134,136
public int compare(final PointValuePair o1, final PointValuePair o2) { [EOL]     final double v1 = o1.getValue(); [EOL]     final double v2 = o2.getValue(); [EOL]     return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1); [EOL] } <line_num>: 142,147
@Override [EOL] protected PointValuePair doOptimize() { [EOL]     checkParameters(); [EOL]     final MultivariateFunction evalFunc = new MultivariateFunction() { [EOL]  [EOL]         public double value(double[] point) { [EOL]             return computeObjectiveValue(point); [EOL]         } [EOL]     }; [EOL]     final boolean isMinim = getGoalType() == GoalType.MINIMIZE; [EOL]     final Comparator<PointValuePair> comparator = new Comparator<PointValuePair>() { [EOL]  [EOL]         public int compare(final PointValuePair o1, final PointValuePair o2) { [EOL]             final double v1 = o1.getValue(); [EOL]             final double v2 = o2.getValue(); [EOL]             return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1); [EOL]         } [EOL]     }; [EOL]     simplex.build(getStartPoint()); [EOL]     simplex.evaluate(evalFunc, comparator); [EOL]     PointValuePair[] previous = null; [EOL]     int iteration = 0; [EOL]     final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker(); [EOL]     while (true) { [EOL]         if (getIterations() > 0) { [EOL]             boolean converged = true; [EOL]             for (int i = 0; i < simplex.getSize(); i++) { [EOL]                 PointValuePair prev = previous[i]; [EOL]                 converged = converged && checker.converged(iteration, prev, simplex.getPoint(i)); [EOL]             } [EOL]             if (converged) { [EOL]                 return simplex.getPoint(0); [EOL]             } [EOL]         } [EOL]         previous = simplex.getPoints(); [EOL]         simplex.iterate(evalFunc, comparator); [EOL]         incrementIterationCount(); [EOL]     } [EOL] } <line_num>: 126,177
@Override [EOL] protected void parseOptimizationData(OptimizationData... optData) { [EOL]     super.parseOptimizationData(optData); [EOL]     for (OptimizationData data : optData) { [EOL]         if (data instanceof AbstractSimplex) { [EOL]             simplex = (AbstractSimplex) data; [EOL]             break; [EOL]         } [EOL]     } [EOL] } <line_num>: 189,204
private void checkParameters() { [EOL]     if (simplex == null) { [EOL]         throw new NullArgumentException(); [EOL]     } [EOL]     if (getLowerBound() != null || getUpperBound() != null) { [EOL]         throw new MathUnsupportedOperationException(LocalizedFormats.CONSTRAINT); [EOL]     } [EOL] } <line_num>: 212,220
