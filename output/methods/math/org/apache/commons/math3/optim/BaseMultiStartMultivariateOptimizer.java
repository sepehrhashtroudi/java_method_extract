public BaseMultiStartMultivariateOptimizer(final BaseMultivariateOptimizer<PAIR> optimizer, final int starts, final RandomVectorGenerator generator) { [EOL]     super(optimizer.getConvergenceChecker()); [EOL]     if (starts < 1) { [EOL]         throw new NotStrictlyPositiveException(starts); [EOL]     } [EOL]     this.optimizer = optimizer; [EOL]     this.starts = starts; [EOL]     this.generator = generator; [EOL] } <line_num>: 79,91
@Override [EOL] public int getEvaluations() { [EOL]     return totalEvaluations; [EOL] } <line_num>: 94,97
public abstract PAIR[] getOptima(); <line_num>: 122,122
@Override [EOL] public PAIR optimize(OptimizationData... optData) { [EOL]     optimData = optData; [EOL]     return super.optimize(optData); [EOL] } <line_num>: 130,136
@Override [EOL] protected PAIR doOptimize() { [EOL]     for (int i = 0; i < optimData.length; i++) { [EOL]         if (optimData[i] instanceof MaxEval) { [EOL]             optimData[i] = null; [EOL]             maxEvalIndex = i; [EOL]         } [EOL]         if (optimData[i] instanceof InitialGuess) { [EOL]             optimData[i] = null; [EOL]             initialGuessIndex = i; [EOL]             continue; [EOL]         } [EOL]     } [EOL]     if (maxEvalIndex == -1) { [EOL]         throw new MathIllegalStateException(); [EOL]     } [EOL]     if (initialGuessIndex == -1) { [EOL]         throw new MathIllegalStateException(); [EOL]     } [EOL]     RuntimeException lastException = null; [EOL]     totalEvaluations = 0; [EOL]     clear(); [EOL]     final int maxEval = getMaxEvaluations(); [EOL]     final double[] min = getLowerBound(); [EOL]     final double[] max = getUpperBound(); [EOL]     final double[] startPoint = getStartPoint(); [EOL]     for (int i = 0; i < starts; i++) { [EOL]         try { [EOL]             optimData[maxEvalIndex] = new MaxEval(maxEval - totalEvaluations); [EOL]             double[] s = null; [EOL]             if (i == 0) { [EOL]                 s = startPoint; [EOL]             } else { [EOL]                 int attempts = 0; [EOL]                 while (s == null) { [EOL]                     if (attempts++ >= getMaxEvaluations()) { [EOL]                         throw new TooManyEvaluationsException(getMaxEvaluations()); [EOL]                     } [EOL]                     s = generator.nextVector(); [EOL]                     for (int k = 0; s != null && k < s.length; ++k) { [EOL]                         if ((min != null && s[k] < min[k]) || (max != null && s[k] > max[k])) { [EOL]                             s = null; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]             optimData[initialGuessIndex] = new InitialGuess(s); [EOL]             final PAIR result = optimizer.optimize(optimData); [EOL]             store(result); [EOL]         } catch (RuntimeException mue) { [EOL]             lastException = mue; [EOL]         } [EOL]         totalEvaluations += optimizer.getEvaluations(); [EOL]     } [EOL]     final PAIR[] optima = getOptima(); [EOL]     if (optima.length == 0) { [EOL]         throw lastException; [EOL]     } [EOL]     return optima[0]; [EOL] } <line_num>: 139,218
protected abstract void store(PAIR optimum); <line_num>: 225,225
protected abstract void clear(); <line_num>: 229,229
