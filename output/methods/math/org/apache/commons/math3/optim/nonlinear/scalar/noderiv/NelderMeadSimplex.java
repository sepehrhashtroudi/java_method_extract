public NelderMeadSimplex(final int n) { [EOL]     this(n, 1d); [EOL] } <line_num>: 55,57
public NelderMeadSimplex(final int n, double sideLength) { [EOL]     this(n, sideLength, DEFAULT_RHO, DEFAULT_KHI, DEFAULT_GAMMA, DEFAULT_SIGMA); [EOL] } <line_num>: 68,71
public NelderMeadSimplex(final int n, double sideLength, final double rho, final double khi, final double gamma, final double sigma) { [EOL]     super(n, sideLength); [EOL]     this.rho = rho; [EOL]     this.khi = khi; [EOL]     this.gamma = gamma; [EOL]     this.sigma = sigma; [EOL] } <line_num>: 85,94
public NelderMeadSimplex(final int n, final double rho, final double khi, final double gamma, final double sigma) { [EOL]     this(n, 1d, rho, khi, gamma, sigma); [EOL] } <line_num>: 106,110
public NelderMeadSimplex(final double[] steps) { [EOL]     this(steps, DEFAULT_RHO, DEFAULT_KHI, DEFAULT_GAMMA, DEFAULT_SIGMA); [EOL] } <line_num>: 120,122
public NelderMeadSimplex(final double[] steps, final double rho, final double khi, final double gamma, final double sigma) { [EOL]     super(steps); [EOL]     this.rho = rho; [EOL]     this.khi = khi; [EOL]     this.gamma = gamma; [EOL]     this.sigma = sigma; [EOL] } <line_num>: 136,145
public NelderMeadSimplex(final double[][] referenceSimplex) { [EOL]     this(referenceSimplex, DEFAULT_RHO, DEFAULT_KHI, DEFAULT_GAMMA, DEFAULT_SIGMA); [EOL] } <line_num>: 155,157
public NelderMeadSimplex(final double[][] referenceSimplex, final double rho, final double khi, final double gamma, final double sigma) { [EOL]     super(referenceSimplex); [EOL]     this.rho = rho; [EOL]     this.khi = khi; [EOL]     this.gamma = gamma; [EOL]     this.sigma = sigma; [EOL] } <line_num>: 173,182
@Override [EOL] public void iterate(final MultivariateFunction evaluationFunction, final Comparator<PointValuePair> comparator) { [EOL]     final int n = getDimension(); [EOL]     final PointValuePair best = getPoint(0); [EOL]     final PointValuePair secondBest = getPoint(n - 1); [EOL]     final PointValuePair worst = getPoint(n); [EOL]     final double[] xWorst = worst.getPointRef(); [EOL]     final double[] centroid = new double[n]; [EOL]     for (int i = 0; i < n; i++) { [EOL]         final double[] x = getPoint(i).getPointRef(); [EOL]         for (int j = 0; j < n; j++) { [EOL]             centroid[j] += x[j]; [EOL]         } [EOL]     } [EOL]     final double scaling = 1.0 / n; [EOL]     for (int j = 0; j < n; j++) { [EOL]         centroid[j] *= scaling; [EOL]     } [EOL]     final double[] xR = new double[n]; [EOL]     for (int j = 0; j < n; j++) { [EOL]         xR[j] = centroid[j] + rho * (centroid[j] - xWorst[j]); [EOL]     } [EOL]     final PointValuePair reflected = new PointValuePair(xR, evaluationFunction.value(xR), false); [EOL]     if (comparator.compare(best, reflected) <= 0 && comparator.compare(reflected, secondBest) < 0) { [EOL]         replaceWorstPoint(reflected, comparator); [EOL]     } else if (comparator.compare(reflected, best) < 0) { [EOL]         final double[] xE = new double[n]; [EOL]         for (int j = 0; j < n; j++) { [EOL]             xE[j] = centroid[j] + khi * (xR[j] - centroid[j]); [EOL]         } [EOL]         final PointValuePair expanded = new PointValuePair(xE, evaluationFunction.value(xE), false); [EOL]         if (comparator.compare(expanded, reflected) < 0) { [EOL]             replaceWorstPoint(expanded, comparator); [EOL]         } else { [EOL]             replaceWorstPoint(reflected, comparator); [EOL]         } [EOL]     } else { [EOL]         if (comparator.compare(reflected, worst) < 0) { [EOL]             final double[] xC = new double[n]; [EOL]             for (int j = 0; j < n; j++) { [EOL]                 xC[j] = centroid[j] + gamma * (xR[j] - centroid[j]); [EOL]             } [EOL]             final PointValuePair outContracted = new PointValuePair(xC, evaluationFunction.value(xC), false); [EOL]             if (comparator.compare(outContracted, reflected) <= 0) { [EOL]                 replaceWorstPoint(outContracted, comparator); [EOL]                 return; [EOL]             } [EOL]         } else { [EOL]             final double[] xC = new double[n]; [EOL]             for (int j = 0; j < n; j++) { [EOL]                 xC[j] = centroid[j] - gamma * (centroid[j] - xWorst[j]); [EOL]             } [EOL]             final PointValuePair inContracted = new PointValuePair(xC, evaluationFunction.value(xC), false); [EOL]             if (comparator.compare(inContracted, worst) < 0) { [EOL]                 replaceWorstPoint(inContracted, comparator); [EOL]                 return; [EOL]             } [EOL]         } [EOL]         final double[] xSmallest = getPoint(0).getPointRef(); [EOL]         for (int i = 1; i <= n; i++) { [EOL]             final double[] x = getPoint(i).getPoint(); [EOL]             for (int j = 0; j < n; j++) { [EOL]                 x[j] = xSmallest[j] + sigma * (x[j] - xSmallest[j]); [EOL]             } [EOL]             setPoint(i, new PointValuePair(x, Double.NaN, false)); [EOL]         } [EOL]         evaluate(evaluationFunction, comparator); [EOL]     } [EOL] } <line_num>: 185,280
