public NonLinearConjugateGradientOptimizer(final Formula updateFormula, ConvergenceChecker<PointValuePair> checker) { [EOL]     this(updateFormula, checker, new BrentSolver(), new IdentityPreconditioner()); [EOL] } <line_num>: 69,75
public BracketingStep(double step) { [EOL]     initialStep = step; [EOL] } <line_num>: 118,120
public NonLinearConjugateGradientOptimizer(final Formula updateFormula, ConvergenceChecker<PointValuePair> checker, final UnivariateSolver lineSearchSolver) { [EOL]     this(updateFormula, checker, lineSearchSolver, new IdentityPreconditioner()); [EOL] } <line_num>: 141,148
public NonLinearConjugateGradientOptimizer(final Formula updateFormula, ConvergenceChecker<PointValuePair> checker, final UnivariateSolver lineSearchSolver, final Preconditioner preconditioner) { [EOL]     super(checker); [EOL]     this.updateFormula = updateFormula; [EOL]     solver = lineSearchSolver; [EOL]     this.preconditioner = preconditioner; [EOL]     initialStep = 1; [EOL] } <line_num>: 158,168
public LineSearchFunction(double[] point, double[] direction) { [EOL]     currentPoint = point.clone(); [EOL]     searchDirection = direction.clone(); [EOL] } <line_num>: 367,371
public double getBracketingStep() { [EOL]     return initialStep; [EOL] } <line_num>: 127,129
@Override [EOL] public PointValuePair optimize(OptimizationData... optData) throws TooManyEvaluationsException { [EOL]     return super.optimize(optData); [EOL] } <line_num>: 183,188
@Override [EOL] protected PointValuePair doOptimize() { [EOL]     final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker(); [EOL]     final double[] point = getStartPoint(); [EOL]     final GoalType goal = getGoalType(); [EOL]     final int n = point.length; [EOL]     double[] r = computeObjectiveGradient(point); [EOL]     if (goal == GoalType.MINIMIZE) { [EOL]         for (int i = 0; i < n; i++) { [EOL]             r[i] = -r[i]; [EOL]         } [EOL]     } [EOL]     double[] steepestDescent = preconditioner.precondition(point, r); [EOL]     double[] searchDirection = steepestDescent.clone(); [EOL]     double delta = 0; [EOL]     for (int i = 0; i < n; ++i) { [EOL]         delta += r[i] * searchDirection[i]; [EOL]     } [EOL]     PointValuePair current = null; [EOL]     int maxEval = getMaxEvaluations(); [EOL]     while (true) { [EOL]         incrementIterationCount(); [EOL]         final double objective = computeObjectiveValue(point); [EOL]         PointValuePair previous = current; [EOL]         current = new PointValuePair(point, objective); [EOL]         if (previous != null && checker.converged(getIterations(), previous, current)) { [EOL]             return current; [EOL]         } [EOL]         final UnivariateFunction lsf = new LineSearchFunction(point, searchDirection); [EOL]         final double uB = findUpperBound(lsf, 0, initialStep); [EOL]         final double step = solver.solve(maxEval, lsf, 0, uB, 1e-15); [EOL]         maxEval -= solver.getEvaluations(); [EOL]         for (int i = 0; i < point.length; ++i) { [EOL]             point[i] += step * searchDirection[i]; [EOL]         } [EOL]         r = computeObjectiveGradient(point); [EOL]         if (goal == GoalType.MINIMIZE) { [EOL]             for (int i = 0; i < n; ++i) { [EOL]                 r[i] = -r[i]; [EOL]             } [EOL]         } [EOL]         final double deltaOld = delta; [EOL]         final double[] newSteepestDescent = preconditioner.precondition(point, r); [EOL]         delta = 0; [EOL]         for (int i = 0; i < n; ++i) { [EOL]             delta += r[i] * newSteepestDescent[i]; [EOL]         } [EOL]         final double beta; [EOL]         switch(updateFormula) { [EOL]             case FLETCHER_REEVES: [EOL]                 beta = delta / deltaOld; [EOL]                 break; [EOL]             case POLAK_RIBIERE: [EOL]                 double deltaMid = 0; [EOL]                 for (int i = 0; i < r.length; ++i) { [EOL]                     deltaMid += r[i] * steepestDescent[i]; [EOL]                 } [EOL]                 beta = (delta - deltaMid) / deltaOld; [EOL]                 break; [EOL]             default: [EOL]                 throw new MathInternalError(); [EOL]         } [EOL]         steepestDescent = newSteepestDescent; [EOL]         if (getIterations() % n == 0 || beta < 0) { [EOL]             searchDirection = steepestDescent.clone(); [EOL]         } else { [EOL]             for (int i = 0; i < n; ++i) { [EOL]                 searchDirection[i] = steepestDescent[i] + beta * searchDirection[i]; [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 191,285
@Override [EOL] protected void parseOptimizationData(OptimizationData... optData) { [EOL]     super.parseOptimizationData(optData); [EOL]     for (OptimizationData data : optData) { [EOL]         if (data instanceof BracketingStep) { [EOL]             initialStep = ((BracketingStep) data).getBracketingStep(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     checkParameters(); [EOL] } <line_num>: 297,314
private double findUpperBound(final UnivariateFunction f, final double a, final double h) { [EOL]     final double yA = f.value(a); [EOL]     double yB = yA; [EOL]     for (double step = h; step < Double.MAX_VALUE; step *= FastMath.max(2, yA / yB)) { [EOL]         final double b = a + step; [EOL]         yB = f.value(b); [EOL]         if (yA * yB <= 0) { [EOL]             return b; [EOL]         } [EOL]     } [EOL]     throw new MathIllegalStateException(LocalizedFormats.UNABLE_TO_BRACKET_OPTIMUM_IN_LINE_SEARCH); [EOL] } <line_num>: 325,337
public double[] precondition(double[] variables, double[] r) { [EOL]     return r.clone(); [EOL] } <line_num>: 342,344
public double value(double x) { [EOL]     final double[] shiftedPoint = currentPoint.clone(); [EOL]     for (int i = 0; i < shiftedPoint.length; ++i) { [EOL]         shiftedPoint[i] += x * searchDirection[i]; [EOL]     } [EOL]     final double[] gradient = computeObjectiveGradient(shiftedPoint); [EOL]     double dotProduct = 0; [EOL]     for (int i = 0; i < gradient.length; ++i) { [EOL]         dotProduct += gradient[i] * searchDirection[i]; [EOL]     } [EOL]     return dotProduct; [EOL] } <line_num>: 374,391
private void checkParameters() { [EOL]     if (getLowerBound() != null || getUpperBound() != null) { [EOL]         throw new MathUnsupportedOperationException(LocalizedFormats.CONSTRAINT); [EOL]     } [EOL] } <line_num>: 398,403
