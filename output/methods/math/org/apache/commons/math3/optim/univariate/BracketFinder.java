public BracketFinder() { [EOL]     this(100, 50); [EOL] } <line_num>: 78,80
public BracketFinder(double growLimit, int maxEvaluations) { [EOL]     if (growLimit <= 0) { [EOL]         throw new NotStrictlyPositiveException(growLimit); [EOL]     } [EOL]     if (maxEvaluations <= 0) { [EOL]         throw new NotStrictlyPositiveException(maxEvaluations); [EOL]     } [EOL]     this.growLimit = growLimit; [EOL]     evaluations.setMaximalCount(maxEvaluations); [EOL] } <line_num>: 89,100
public void search(UnivariateFunction func, GoalType goal, double xA, double xB) { [EOL]     evaluations.resetCount(); [EOL]     final boolean isMinim = goal == GoalType.MINIMIZE; [EOL]     double fA = eval(func, xA); [EOL]     double fB = eval(func, xB); [EOL]     if (isMinim ? fA < fB : fA > fB) { [EOL]         double tmp = xA; [EOL]         xA = xB; [EOL]         xB = tmp; [EOL]         tmp = fA; [EOL]         fA = fB; [EOL]         fB = tmp; [EOL]     } [EOL]     double xC = xB + GOLD * (xB - xA); [EOL]     double fC = eval(func, xC); [EOL]     while (isMinim ? fC < fB : fC > fB) { [EOL]         double tmp1 = (xB - xA) * (fB - fC); [EOL]         double tmp2 = (xB - xC) * (fB - fA); [EOL]         double val = tmp2 - tmp1; [EOL]         double denom = Math.abs(val) < EPS_MIN ? 2 * EPS_MIN : 2 * val; [EOL]         double w = xB - ((xB - xC) * tmp2 - (xB - xA) * tmp1) / denom; [EOL]         double wLim = xB + growLimit * (xC - xB); [EOL]         double fW; [EOL]         if ((w - xC) * (xB - w) > 0) { [EOL]             fW = eval(func, w); [EOL]             if (isMinim ? fW < fC : fW > fC) { [EOL]                 xA = xB; [EOL]                 xB = w; [EOL]                 fA = fB; [EOL]                 fB = fW; [EOL]                 break; [EOL]             } else if (isMinim ? fW > fB : fW < fB) { [EOL]                 xC = w; [EOL]                 fC = fW; [EOL]                 break; [EOL]             } [EOL]             w = xC + GOLD * (xC - xB); [EOL]             fW = eval(func, w); [EOL]         } else if ((w - wLim) * (wLim - xC) >= 0) { [EOL]             w = wLim; [EOL]             fW = eval(func, w); [EOL]         } else if ((w - wLim) * (xC - w) > 0) { [EOL]             fW = eval(func, w); [EOL]             if (isMinim ? fW < fC : fW > fC) { [EOL]                 xB = xC; [EOL]                 xC = w; [EOL]                 w = xC + GOLD * (xC - xB); [EOL]                 fB = fC; [EOL]                 fC = fW; [EOL]                 fW = eval(func, w); [EOL]             } [EOL]         } else { [EOL]             w = xC + GOLD * (xC - xB); [EOL]             fW = eval(func, w); [EOL]         } [EOL]         xA = xB; [EOL]         fA = fB; [EOL]         xB = xC; [EOL]         fB = fC; [EOL]         xC = w; [EOL]         fC = fW; [EOL]     } [EOL]     lo = xA; [EOL]     fLo = fA; [EOL]     mid = xB; [EOL]     fMid = fB; [EOL]     hi = xC; [EOL]     fHi = fC; [EOL]     if (lo > hi) { [EOL]         double tmp = lo; [EOL]         lo = hi; [EOL]         hi = tmp; [EOL]         tmp = fLo; [EOL]         fLo = fHi; [EOL]         fHi = tmp; [EOL]     } [EOL] } <line_num>: 112,208
public int getMaxEvaluations() { [EOL]     return evaluations.getMaximalCount(); [EOL] } <line_num>: 213,215
public int getEvaluations() { [EOL]     return evaluations.getCount(); [EOL] } <line_num>: 220,222
public double getLo() { [EOL]     return lo; [EOL] } <line_num>: 228,230
public double getFLo() { [EOL]     return fLo; [EOL] } <line_num>: 236,238
public double getHi() { [EOL]     return hi; [EOL] } <line_num>: 244,246
public double getFHi() { [EOL]     return fHi; [EOL] } <line_num>: 252,254
public double getMid() { [EOL]     return mid; [EOL] } <line_num>: 260,262
public double getFMid() { [EOL]     return fMid; [EOL] } <line_num>: 268,270
private double eval(UnivariateFunction f, double x) { [EOL]     try { [EOL]         evaluations.incrementCount(); [EOL]     } catch (MaxCountExceededException e) { [EOL]         throw new TooManyEvaluationsException(e.getMax()); [EOL]     } [EOL]     return f.value(x); [EOL] } <line_num>: 279,286
