public SubLine(final Hyperplane<Euclidean2D> hyperplane, final Region<Euclidean1D> remainingRegion) { [EOL]     super(hyperplane, remainingRegion); [EOL] } <line_num>: 46,49
public SubLine(final Vector2D start, final Vector2D end) { [EOL]     super(new Line(start, end), buildIntervalSet(start, end)); [EOL] } <line_num>: 55,57
public SubLine(final Segment segment) { [EOL]     super(segment.getLine(), buildIntervalSet(segment.getStart(), segment.getEnd())); [EOL] } <line_num>: 62,64
public List<Segment> getSegments() { [EOL]     final Line line = (Line) getHyperplane(); [EOL]     final List<Interval> list = ((IntervalsSet) getRemainingRegion()).asList(); [EOL]     final List<Segment> segments = new ArrayList<Segment>(list.size()); [EOL]     for (final Interval interval : list) { [EOL]         final Vector2D start = line.toSpace(new Vector1D(interval.getInf())); [EOL]         final Vector2D end = line.toSpace(new Vector1D(interval.getSup())); [EOL]         segments.add(new Segment(start, end, line)); [EOL]     } [EOL]     return segments; [EOL] } <line_num>: 80,94
public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) { [EOL]     Line line1 = (Line) getHyperplane(); [EOL]     Line line2 = (Line) subLine.getHyperplane(); [EOL]     Vector2D v2D = line1.intersection(line2); [EOL]     if (v2D == null) { [EOL]         return null; [EOL]     } [EOL]     Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D)); [EOL]     Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D)); [EOL]     if (includeEndPoints) { [EOL]         return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null; [EOL]     } else { [EOL]         return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null; [EOL]     } [EOL] } <line_num>: 110,134
private static IntervalsSet buildIntervalSet(final Vector2D start, final Vector2D end) { [EOL]     final Line line = new Line(start, end); [EOL]     return new IntervalsSet(line.toSubSpace(start).getX(), line.toSubSpace(end).getX()); [EOL] } <line_num>: 141,145
@Override [EOL] protected AbstractSubHyperplane<Euclidean2D, Euclidean1D> buildNew(final Hyperplane<Euclidean2D> hyperplane, final Region<Euclidean1D> remainingRegion) { [EOL]     return new SubLine(hyperplane, remainingRegion); [EOL] } <line_num>: 148,152
@Override [EOL] public Side side(final Hyperplane<Euclidean2D> hyperplane) { [EOL]     final Line thisLine = (Line) getHyperplane(); [EOL]     final Line otherLine = (Line) hyperplane; [EOL]     final Vector2D crossing = thisLine.intersection(otherLine); [EOL]     if (crossing == null) { [EOL]         final double global = otherLine.getOffset(thisLine); [EOL]         return (global < -1.0e-10) ? Side.MINUS : ((global > 1.0e-10) ? Side.PLUS : Side.HYPER); [EOL]     } [EOL]     final boolean direct = FastMath.sin(thisLine.getAngle() - otherLine.getAngle()) < 0; [EOL]     final Vector1D x = thisLine.toSubSpace(crossing); [EOL]     return getRemainingRegion().side(new OrientedPoint(x, direct)); [EOL] } <line_num>: 155,173
@Override [EOL] public SplitSubHyperplane<Euclidean2D> split(final Hyperplane<Euclidean2D> hyperplane) { [EOL]     final Line thisLine = (Line) getHyperplane(); [EOL]     final Line otherLine = (Line) hyperplane; [EOL]     final Vector2D crossing = thisLine.intersection(otherLine); [EOL]     if (crossing == null) { [EOL]         final double global = otherLine.getOffset(thisLine); [EOL]         return (global < -1.0e-10) ? new SplitSubHyperplane<Euclidean2D>(null, this) : new SplitSubHyperplane<Euclidean2D>(this, null); [EOL]     } [EOL]     final boolean direct = FastMath.sin(thisLine.getAngle() - otherLine.getAngle()) < 0; [EOL]     final Vector1D x = thisLine.toSubSpace(crossing); [EOL]     final SubHyperplane<Euclidean1D> subPlus = new OrientedPoint(x, !direct).wholeHyperplane(); [EOL]     final SubHyperplane<Euclidean1D> subMinus = new OrientedPoint(x, direct).wholeHyperplane(); [EOL]     final BSPTree<Euclidean1D> splitTree = getRemainingRegion().getTree(false).split(subMinus); [EOL]     final BSPTree<Euclidean1D> plusTree = getRemainingRegion().isEmpty(splitTree.getPlus()) ? new BSPTree<Euclidean1D>(Boolean.FALSE) : new BSPTree<Euclidean1D>(subPlus, new BSPTree<Euclidean1D>(Boolean.FALSE), splitTree.getPlus(), null); [EOL]     final BSPTree<Euclidean1D> minusTree = getRemainingRegion().isEmpty(splitTree.getMinus()) ? new BSPTree<Euclidean1D>(Boolean.FALSE) : new BSPTree<Euclidean1D>(subMinus, new BSPTree<Euclidean1D>(Boolean.FALSE), splitTree.getMinus(), null); [EOL]     return new SplitSubHyperplane<Euclidean2D>(new SubLine(thisLine.copySelf(), new IntervalsSet(plusTree)), new SubLine(thisLine.copySelf(), new IntervalsSet(minusTree))); [EOL] } <line_num>: 176,210
