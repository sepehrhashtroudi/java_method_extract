public BSPTree() { [EOL]     cut = null; [EOL]     plus = null; [EOL]     minus = null; [EOL]     parent = null; [EOL]     attribute = null; [EOL] } <line_num>: 82,88
public BSPTree(final Object attribute) { [EOL]     cut = null; [EOL]     plus = null; [EOL]     minus = null; [EOL]     parent = null; [EOL]     this.attribute = attribute; [EOL] } <line_num>: 93,99
public BSPTree(final SubHyperplane<S> cut, final BSPTree<S> plus, final BSPTree<S> minus, final Object attribute) { [EOL]     this.cut = cut; [EOL]     this.plus = plus; [EOL]     this.minus = minus; [EOL]     this.parent = null; [EOL]     this.attribute = attribute; [EOL]     plus.parent = this; [EOL]     minus.parent = this; [EOL] } <line_num>: 114,123
public boolean insertCut(final Hyperplane<S> hyperplane) { [EOL]     if (cut != null) { [EOL]         plus.parent = null; [EOL]         minus.parent = null; [EOL]     } [EOL]     final SubHyperplane<S> chopped = fitToCell(hyperplane.wholeHyperplane()); [EOL]     if (chopped == null || chopped.isEmpty()) { [EOL]         cut = null; [EOL]         plus = null; [EOL]         minus = null; [EOL]         return false; [EOL]     } [EOL]     cut = chopped; [EOL]     plus = new BSPTree<S>(); [EOL]     plus.parent = this; [EOL]     minus = new BSPTree<S>(); [EOL]     minus.parent = this; [EOL]     return true; [EOL] } <line_num>: 148,170
public BSPTree<S> copySelf() { [EOL]     if (cut == null) { [EOL]         return new BSPTree<S>(attribute); [EOL]     } [EOL]     return new BSPTree<S>(cut.copySelf(), plus.copySelf(), minus.copySelf(), attribute); [EOL] } <line_num>: 179,188
public SubHyperplane<S> getCut() { [EOL]     return cut; [EOL] } <line_num>: 193,195
public BSPTree<S> getPlus() { [EOL]     return plus; [EOL] } <line_num>: 201,203
public BSPTree<S> getMinus() { [EOL]     return minus; [EOL] } <line_num>: 209,211
public BSPTree<S> getParent() { [EOL]     return parent; [EOL] } <line_num>: 216,218
public void setAttribute(final Object attribute) { [EOL]     this.attribute = attribute; [EOL] } <line_num>: 224,226
public Object getAttribute() { [EOL]     return attribute; [EOL] } <line_num>: 234,236
public void visit(final BSPTreeVisitor<S> visitor) { [EOL]     if (cut == null) { [EOL]         visitor.visitLeafNode(this); [EOL]     } else { [EOL]         switch(visitor.visitOrder(this)) { [EOL]             case PLUS_MINUS_SUB: [EOL]                 plus.visit(visitor); [EOL]                 minus.visit(visitor); [EOL]                 visitor.visitInternalNode(this); [EOL]                 break; [EOL]             case PLUS_SUB_MINUS: [EOL]                 plus.visit(visitor); [EOL]                 visitor.visitInternalNode(this); [EOL]                 minus.visit(visitor); [EOL]                 break; [EOL]             case MINUS_PLUS_SUB: [EOL]                 minus.visit(visitor); [EOL]                 plus.visit(visitor); [EOL]                 visitor.visitInternalNode(this); [EOL]                 break; [EOL]             case MINUS_SUB_PLUS: [EOL]                 minus.visit(visitor); [EOL]                 visitor.visitInternalNode(this); [EOL]                 plus.visit(visitor); [EOL]                 break; [EOL]             case SUB_PLUS_MINUS: [EOL]                 visitor.visitInternalNode(this); [EOL]                 plus.visit(visitor); [EOL]                 minus.visit(visitor); [EOL]                 break; [EOL]             case SUB_MINUS_PLUS: [EOL]                 visitor.visitInternalNode(this); [EOL]                 minus.visit(visitor); [EOL]                 plus.visit(visitor); [EOL]                 break; [EOL]             default: [EOL]                 throw new MathInternalError(); [EOL]         } [EOL]     } [EOL] } <line_num>: 241,281
private SubHyperplane<S> fitToCell(final SubHyperplane<S> sub) { [EOL]     SubHyperplane<S> s = sub; [EOL]     for (BSPTree<S> tree = this; tree.parent != null; tree = tree.parent) { [EOL]         if (tree == tree.parent.plus) { [EOL]             s = s.split(tree.parent.cut.getHyperplane()).getPlus(); [EOL]         } else { [EOL]             s = s.split(tree.parent.cut.getHyperplane()).getMinus(); [EOL]         } [EOL]     } [EOL]     return s; [EOL] } <line_num>: 291,301
public BSPTree<S> getCell(final Vector<S> point) { [EOL]     if (cut == null) { [EOL]         return this; [EOL]     } [EOL]     final double offset = cut.getHyperplane().getOffset(point); [EOL]     if (FastMath.abs(offset) < 1.0e-10) { [EOL]         return this; [EOL]     } else if (offset <= 0) { [EOL]         return minus.getCell(point); [EOL]     } else { [EOL]         return plus.getCell(point); [EOL]     } [EOL] } <line_num>: 310,329
private void condense() { [EOL]     if ((cut != null) && (plus.cut == null) && (minus.cut == null) && (((plus.attribute == null) && (minus.attribute == null)) || ((plus.attribute != null) && plus.attribute.equals(minus.attribute)))) { [EOL]         attribute = (plus.attribute == null) ? minus.attribute : plus.attribute; [EOL]         cut = null; [EOL]         plus = null; [EOL]         minus = null; [EOL]     } [EOL] } <line_num>: 335,344
public BSPTree<S> merge(final BSPTree<S> tree, final LeafMerger<S> leafMerger) { [EOL]     return merge(tree, leafMerger, null, false); [EOL] } <line_num>: 364,366
private BSPTree<S> merge(final BSPTree<S> tree, final LeafMerger<S> leafMerger, final BSPTree<S> parentTree, final boolean isPlusChild) { [EOL]     if (cut == null) { [EOL]         return leafMerger.merge(this, tree, parentTree, isPlusChild, true); [EOL]     } else if (tree.cut == null) { [EOL]         return leafMerger.merge(tree, this, parentTree, isPlusChild, false); [EOL]     } else { [EOL]         final BSPTree<S> merged = tree.split(cut); [EOL]         if (parentTree != null) { [EOL]             merged.parent = parentTree; [EOL]             if (isPlusChild) { [EOL]                 parentTree.plus = merged; [EOL]             } else { [EOL]                 parentTree.minus = merged; [EOL]             } [EOL]         } [EOL]         plus.merge(merged.plus, leafMerger, merged, true); [EOL]         minus.merge(merged.minus, leafMerger, merged, false); [EOL]         merged.condense(); [EOL]         if (merged.cut != null) { [EOL]             merged.cut = merged.fitToCell(merged.cut.getHyperplane().wholeHyperplane()); [EOL]         } [EOL]         return merged; [EOL]     } [EOL] } <line_num>: 383,415
BSPTree<S> merge(BSPTree<S> leaf, BSPTree<S> tree, BSPTree<S> parentTree, boolean isPlusChild, boolean leafFromInstance); <line_num>: 464,465
public BSPTree<S> split(final SubHyperplane<S> sub) { [EOL]     if (cut == null) { [EOL]         return new BSPTree<S>(sub, copySelf(), new BSPTree<S>(attribute), null); [EOL]     } [EOL]     final Hyperplane<S> cHyperplane = cut.getHyperplane(); [EOL]     final Hyperplane<S> sHyperplane = sub.getHyperplane(); [EOL]     switch(sub.side(cHyperplane)) { [EOL]         case PLUS: [EOL]             { [EOL]                 final BSPTree<S> split = plus.split(sub); [EOL]                 if (cut.side(sHyperplane) == Side.PLUS) { [EOL]                     split.plus = new BSPTree<S>(cut.copySelf(), split.plus, minus.copySelf(), attribute); [EOL]                     split.plus.condense(); [EOL]                     split.plus.parent = split; [EOL]                 } else { [EOL]                     split.minus = new BSPTree<S>(cut.copySelf(), split.minus, minus.copySelf(), attribute); [EOL]                     split.minus.condense(); [EOL]                     split.minus.parent = split; [EOL]                 } [EOL]                 return split; [EOL]             } [EOL]         case MINUS: [EOL]             { [EOL]                 final BSPTree<S> split = minus.split(sub); [EOL]                 if (cut.side(sHyperplane) == Side.PLUS) { [EOL]                     split.plus = new BSPTree<S>(cut.copySelf(), plus.copySelf(), split.plus, attribute); [EOL]                     split.plus.condense(); [EOL]                     split.plus.parent = split; [EOL]                 } else { [EOL]                     split.minus = new BSPTree<S>(cut.copySelf(), plus.copySelf(), split.minus, attribute); [EOL]                     split.minus.condense(); [EOL]                     split.minus.parent = split; [EOL]                 } [EOL]                 return split; [EOL]             } [EOL]         case BOTH: [EOL]             { [EOL]                 final SubHyperplane.SplitSubHyperplane<S> cutParts = cut.split(sHyperplane); [EOL]                 final SubHyperplane.SplitSubHyperplane<S> subParts = sub.split(cHyperplane); [EOL]                 final BSPTree<S> split = new BSPTree<S>(sub, plus.split(subParts.getPlus()), minus.split(subParts.getMinus()), null); [EOL]                 split.plus.cut = cutParts.getPlus(); [EOL]                 split.minus.cut = cutParts.getMinus(); [EOL]                 final BSPTree<S> tmp = split.plus.minus; [EOL]                 split.plus.minus = split.minus.plus; [EOL]                 split.plus.minus.parent = split.plus; [EOL]                 split.minus.plus = tmp; [EOL]                 split.minus.plus.parent = split.minus; [EOL]                 split.plus.condense(); [EOL]                 split.minus.condense(); [EOL]                 return split; [EOL]             } [EOL]         default: [EOL]             return cHyperplane.sameOrientationAs(sHyperplane) ? new BSPTree<S>(sub, plus.copySelf(), minus.copySelf(), attribute) : new BSPTree<S>(sub, minus.copySelf(), plus.copySelf(), attribute); [EOL]     } [EOL] } <line_num>: 487,553
public void insertInTree(final BSPTree<S> parentTree, final boolean isPlusChild) { [EOL]     parent = parentTree; [EOL]     if (parentTree != null) { [EOL]         if (isPlusChild) { [EOL]             parentTree.plus = this; [EOL]         } else { [EOL]             parentTree.minus = this; [EOL]         } [EOL]     } [EOL]     if (cut != null) { [EOL]         for (BSPTree<S> tree = this; tree.parent != null; tree = tree.parent) { [EOL]             final Hyperplane<S> hyperplane = tree.parent.cut.getHyperplane(); [EOL]             if (tree == tree.parent.plus) { [EOL]                 cut = cut.split(hyperplane).getPlus(); [EOL]                 plus.chopOffMinus(hyperplane); [EOL]                 minus.chopOffMinus(hyperplane); [EOL]             } else { [EOL]                 cut = cut.split(hyperplane).getMinus(); [EOL]                 plus.chopOffPlus(hyperplane); [EOL]                 minus.chopOffPlus(hyperplane); [EOL]             } [EOL]         } [EOL]         condense(); [EOL]     } [EOL] } <line_num>: 564,605
private void chopOffMinus(final Hyperplane<S> hyperplane) { [EOL]     if (cut != null) { [EOL]         cut = cut.split(hyperplane).getPlus(); [EOL]         plus.chopOffMinus(hyperplane); [EOL]         minus.chopOffMinus(hyperplane); [EOL]     } [EOL] } <line_num>: 613,619
private void chopOffPlus(final Hyperplane<S> hyperplane) { [EOL]     if (cut != null) { [EOL]         cut = cut.split(hyperplane).getMinus(); [EOL]         plus.chopOffPlus(hyperplane); [EOL]         minus.chopOffPlus(hyperplane); [EOL]     } [EOL] } <line_num>: 627,633
