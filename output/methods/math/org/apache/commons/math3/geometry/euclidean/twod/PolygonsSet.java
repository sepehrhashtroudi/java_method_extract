public PolygonsSet() { [EOL]     super(); [EOL] } <line_num>: 50,52
public PolygonsSet(final BSPTree<Euclidean2D> tree) { [EOL]     super(tree); [EOL] } <line_num>: 63,65
public PolygonsSet(final Collection<SubHyperplane<Euclidean2D>> boundary) { [EOL]     super(boundary); [EOL] } <line_num>: 87,89
public PolygonsSet(final double xMin, final double xMax, final double yMin, final double yMax) { [EOL]     super(boxBoundary(xMin, xMax, yMin, yMax)); [EOL] } <line_num>: 97,100
public PolygonsSet(final double hyperplaneThickness, final Vector2D... vertices) { [EOL]     super(verticesToTree(hyperplaneThickness, vertices)); [EOL] } <line_num>: 133,135
public Vertex(final Vector2D location) { [EOL]     this.location = location; [EOL]     this.incoming = null; [EOL]     this.outgoing = null; [EOL]     this.lines = new ArrayList<Line>(); [EOL] } <line_num>: 341,346
public Edge(final Vertex start, final Vertex end, final Line line) { [EOL]     this.start = start; [EOL]     this.end = end; [EOL]     this.line = line; [EOL]     this.node = null; [EOL]     start.setOutgoing(this); [EOL]     end.setIncoming(this); [EOL] } <line_num>: 443,454
public ComparableSegment(final Vector2D start, final Vector2D end, final Line line) { [EOL]     super(start, end, line); [EOL]     sortingKey = (start == null) ? new OrderedTuple(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY) : new OrderedTuple(start.getX(), start.getY()); [EOL] } <line_num>: 754,759
public ComparableSegment(final Vector2D start, final double dx, final double dy) { [EOL]     super(null, null, null); [EOL]     sortingKey = new OrderedTuple(start.getX() + dx, start.getY() + dy); [EOL] } <line_num>: 770,773
public SegmentsBuilder() { [EOL]     sorted = new AVLTree<ComparableSegment>(); [EOL] } <line_num>: 808,810
private static Line[] boxBoundary(final double xMin, final double xMax, final double yMin, final double yMax) { [EOL]     final Vector2D minMin = new Vector2D(xMin, yMin); [EOL]     final Vector2D minMax = new Vector2D(xMin, yMax); [EOL]     final Vector2D maxMin = new Vector2D(xMax, yMin); [EOL]     final Vector2D maxMax = new Vector2D(xMax, yMax); [EOL]     return new Line[] { new Line(minMin, maxMin), new Line(maxMin, maxMax), new Line(maxMax, minMax), new Line(minMax, minMin) }; [EOL] } <line_num>: 144,156
private static BSPTree<Euclidean2D> verticesToTree(final double hyperplaneThickness, final Vector2D... vertices) { [EOL]     final int n = vertices.length; [EOL]     if (n == 0) { [EOL]         return new BSPTree<Euclidean2D>(Boolean.TRUE); [EOL]     } [EOL]     final Vertex[] vArray = new Vertex[n]; [EOL]     for (int i = 0; i < n; ++i) { [EOL]         vArray[i] = new Vertex(vertices[i]); [EOL]     } [EOL]     List<Edge> edges = new ArrayList<Edge>(n); [EOL]     for (int i = 0; i < n; ++i) { [EOL]         final Vertex start = vArray[i]; [EOL]         final Vertex end = vArray[(i + 1) % n]; [EOL]         Line line = start.sharedLineWith(end); [EOL]         if (line == null) { [EOL]             line = new Line(start.getLocation(), end.getLocation()); [EOL]         } [EOL]         edges.add(new Edge(start, end, line)); [EOL]         for (final Vertex vertex : vArray) { [EOL]             if (vertex != start && vertex != end && FastMath.abs(line.getOffset(vertex.getLocation())) <= hyperplaneThickness) { [EOL]                 vertex.bindWith(line); [EOL]             } [EOL]         } [EOL]     } [EOL]     final BSPTree<Euclidean2D> tree = new BSPTree<Euclidean2D>(); [EOL]     insertEdges(hyperplaneThickness, tree, edges); [EOL]     return tree; [EOL] } <line_num>: 173,223
private static void insertEdges(final double hyperplaneThickness, final BSPTree<Euclidean2D> node, final List<Edge> edges) { [EOL]     int index = 0; [EOL]     Edge inserted = null; [EOL]     while (inserted == null && index < edges.size()) { [EOL]         inserted = edges.get(index++); [EOL]         if (inserted.getNode() == null) { [EOL]             if (node.insertCut(inserted.getLine())) { [EOL]                 inserted.setNode(node); [EOL]             } else { [EOL]                 inserted = null; [EOL]             } [EOL]         } else { [EOL]             inserted = null; [EOL]         } [EOL]     } [EOL]     if (inserted == null) { [EOL]         final BSPTree<Euclidean2D> parent = node.getParent(); [EOL]         if (parent == null || node == parent.getMinus()) { [EOL]             node.setAttribute(Boolean.TRUE); [EOL]         } else { [EOL]             node.setAttribute(Boolean.FALSE); [EOL]         } [EOL]         return; [EOL]     } [EOL]     final List<Edge> plusList = new ArrayList<Edge>(); [EOL]     final List<Edge> minusList = new ArrayList<Edge>(); [EOL]     for (final Edge edge : edges) { [EOL]         if (edge != inserted) { [EOL]             final double startOffset = inserted.getLine().getOffset(edge.getStart().getLocation()); [EOL]             final double endOffset = inserted.getLine().getOffset(edge.getEnd().getLocation()); [EOL]             Side startSide = (FastMath.abs(startOffset) <= hyperplaneThickness) ? Side.HYPER : ((startOffset < 0) ? Side.MINUS : Side.PLUS); [EOL]             Side endSide = (FastMath.abs(endOffset) <= hyperplaneThickness) ? Side.HYPER : ((endOffset < 0) ? Side.MINUS : Side.PLUS); [EOL]             switch(startSide) { [EOL]                 case PLUS: [EOL]                     if (endSide == Side.MINUS) { [EOL]                         final Vertex splitPoint = edge.split(inserted.getLine()); [EOL]                         minusList.add(splitPoint.getOutgoing()); [EOL]                         plusList.add(splitPoint.getIncoming()); [EOL]                     } else { [EOL]                         plusList.add(edge); [EOL]                     } [EOL]                     break; [EOL]                 case MINUS: [EOL]                     if (endSide == Side.PLUS) { [EOL]                         final Vertex splitPoint = edge.split(inserted.getLine()); [EOL]                         minusList.add(splitPoint.getIncoming()); [EOL]                         plusList.add(splitPoint.getOutgoing()); [EOL]                     } else { [EOL]                         minusList.add(edge); [EOL]                     } [EOL]                     break; [EOL]                 default: [EOL]                     if (endSide == Side.PLUS) { [EOL]                         plusList.add(edge); [EOL]                     } else if (endSide == Side.MINUS) { [EOL]                         minusList.add(edge); [EOL]                     } [EOL]                     break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (!plusList.isEmpty()) { [EOL]         insertEdges(hyperplaneThickness, node.getPlus(), plusList); [EOL]     } else { [EOL]         node.getPlus().setAttribute(Boolean.FALSE); [EOL]     } [EOL]     if (!minusList.isEmpty()) { [EOL]         insertEdges(hyperplaneThickness, node.getMinus(), minusList); [EOL]     } else { [EOL]         node.getMinus().setAttribute(Boolean.TRUE); [EOL]     } [EOL] } <line_num>: 233,321
public Vector2D getLocation() { [EOL]     return location; [EOL] } <line_num>: 351,353
public void bindWith(final Line line) { [EOL]     lines.add(line); [EOL] } <line_num>: 358,360
public Line sharedLineWith(final Vertex vertex) { [EOL]     for (final Line line1 : lines) { [EOL]         for (final Line line2 : vertex.lines) { [EOL]             if (line1 == line2) { [EOL]                 return line1; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 372,381
public void setIncoming(final Edge incoming) { [EOL]     this.incoming = incoming; [EOL]     bindWith(incoming.getLine()); [EOL] } <line_num>: 390,393
public Edge getIncoming() { [EOL]     return incoming; [EOL] } <line_num>: 398,400
public void setOutgoing(final Edge outgoing) { [EOL]     this.outgoing = outgoing; [EOL]     bindWith(outgoing.getLine()); [EOL] } <line_num>: 409,412
public Edge getOutgoing() { [EOL]     return outgoing; [EOL] } <line_num>: 417,419
public Vertex getStart() { [EOL]     return start; [EOL] } <line_num>: 459,461
public Vertex getEnd() { [EOL]     return end; [EOL] } <line_num>: 466,468
public Line getLine() { [EOL]     return line; [EOL] } <line_num>: 473,475
public void setNode(final BSPTree<Euclidean2D> node) { [EOL]     this.node = node; [EOL] } <line_num>: 480,482
public BSPTree<Euclidean2D> getNode() { [EOL]     return node; [EOL] } <line_num>: 488,490
public Vertex split(final Line splitLine) { [EOL]     final Vertex splitVertex = new Vertex(line.intersection(splitLine)); [EOL]     splitVertex.bindWith(splitLine); [EOL]     final Edge startHalf = new Edge(start, splitVertex, line); [EOL]     final Edge endHalf = new Edge(splitVertex, end, line); [EOL]     startHalf.node = node; [EOL]     endHalf.node = node; [EOL]     return splitVertex; [EOL] } <line_num>: 501,509
@Override [EOL] public PolygonsSet buildNew(final BSPTree<Euclidean2D> tree) { [EOL]     return new PolygonsSet(tree); [EOL] } <line_num>: 514,517
@Override [EOL] protected void computeGeometricalProperties() { [EOL]     final Vector2D[][] v = getVertices(); [EOL]     if (v.length == 0) { [EOL]         final BSPTree<Euclidean2D> tree = getTree(false); [EOL]         if (tree.getCut() == null && (Boolean) tree.getAttribute()) { [EOL]             setSize(Double.POSITIVE_INFINITY); [EOL]             setBarycenter(Vector2D.NaN); [EOL]         } else { [EOL]             setSize(0); [EOL]             setBarycenter(new Vector2D(0, 0)); [EOL]         } [EOL]     } else if (v[0][0] == null) { [EOL]         setSize(Double.POSITIVE_INFINITY); [EOL]         setBarycenter(Vector2D.NaN); [EOL]     } else { [EOL]         double sum = 0; [EOL]         double sumX = 0; [EOL]         double sumY = 0; [EOL]         for (Vector2D[] loop : v) { [EOL]             double x1 = loop[loop.length - 1].getX(); [EOL]             double y1 = loop[loop.length - 1].getY(); [EOL]             for (final Vector2D point : loop) { [EOL]                 final double x0 = x1; [EOL]                 final double y0 = y1; [EOL]                 x1 = point.getX(); [EOL]                 y1 = point.getY(); [EOL]                 final double factor = x0 * y1 - y0 * x1; [EOL]                 sum += factor; [EOL]                 sumX += factor * (x0 + x1); [EOL]                 sumY += factor * (y0 + y1); [EOL]             } [EOL]         } [EOL]         if (sum < 0) { [EOL]             setSize(Double.POSITIVE_INFINITY); [EOL]             setBarycenter(Vector2D.NaN); [EOL]         } else { [EOL]             setSize(sum / 2); [EOL]             setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum))); [EOL]         } [EOL]     } [EOL] } <line_num>: 520,572
public Vector2D[][] getVertices() { [EOL]     if (vertices == null) { [EOL]         if (getTree(false).getCut() == null) { [EOL]             vertices = new Vector2D[0][]; [EOL]         } else { [EOL]             final SegmentsBuilder visitor = new SegmentsBuilder(); [EOL]             getTree(true).visit(visitor); [EOL]             final AVLTree<ComparableSegment> sorted = visitor.getSorted(); [EOL]             final ArrayList<List<ComparableSegment>> loops = new ArrayList<List<ComparableSegment>>(); [EOL]             while (!sorted.isEmpty()) { [EOL]                 final AVLTree<ComparableSegment>.Node node = sorted.getSmallest(); [EOL]                 final List<ComparableSegment> loop = followLoop(node, sorted); [EOL]                 if (loop != null) { [EOL]                     loops.add(loop); [EOL]                 } [EOL]             } [EOL]             vertices = new Vector2D[loops.size()][]; [EOL]             int i = 0; [EOL]             for (final List<ComparableSegment> loop : loops) { [EOL]                 if (loop.size() < 2) { [EOL]                     final Line line = loop.get(0).getLine(); [EOL]                     vertices[i++] = new Vector2D[] { null, line.toSpace(new Vector1D(-Float.MAX_VALUE)), line.toSpace(new Vector1D(+Float.MAX_VALUE)) }; [EOL]                 } else if (loop.get(0).getStart() == null) { [EOL]                     final Vector2D[] array = new Vector2D[loop.size() + 2]; [EOL]                     int j = 0; [EOL]                     for (Segment segment : loop) { [EOL]                         if (j == 0) { [EOL]                             double x = segment.getLine().toSubSpace(segment.getEnd()).getX(); [EOL]                             x -= FastMath.max(1.0, FastMath.abs(x / 2)); [EOL]                             array[j++] = null; [EOL]                             array[j++] = segment.getLine().toSpace(new Vector1D(x)); [EOL]                         } [EOL]                         if (j < (array.length - 1)) { [EOL]                             array[j++] = segment.getEnd(); [EOL]                         } [EOL]                         if (j == (array.length - 1)) { [EOL]                             double x = segment.getLine().toSubSpace(segment.getStart()).getX(); [EOL]                             x += FastMath.max(1.0, FastMath.abs(x / 2)); [EOL]                             array[j++] = segment.getLine().toSpace(new Vector1D(x)); [EOL]                         } [EOL]                     } [EOL]                     vertices[i++] = array; [EOL]                 } else { [EOL]                     final Vector2D[] array = new Vector2D[loop.size()]; [EOL]                     int j = 0; [EOL]                     for (Segment segment : loop) { [EOL]                         array[j++] = segment.getStart(); [EOL]                     } [EOL]                     vertices[i++] = array; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return vertices.clone(); [EOL] } <line_num>: 597,675
private List<ComparableSegment> followLoop(final AVLTree<ComparableSegment>.Node node, final AVLTree<ComparableSegment> sorted) { [EOL]     final ArrayList<ComparableSegment> loop = new ArrayList<ComparableSegment>(); [EOL]     ComparableSegment segment = node.getElement(); [EOL]     loop.add(segment); [EOL]     final Vector2D globalStart = segment.getStart(); [EOL]     Vector2D end = segment.getEnd(); [EOL]     node.delete(); [EOL]     final boolean open = segment.getStart() == null; [EOL]     while ((end != null) && (open || (globalStart.distance(end) > 1.0e-10))) { [EOL]         AVLTree<ComparableSegment>.Node selectedNode = null; [EOL]         ComparableSegment selectedSegment = null; [EOL]         double selectedDistance = Double.POSITIVE_INFINITY; [EOL]         final ComparableSegment lowerLeft = new ComparableSegment(end, -1.0e-10, -1.0e-10); [EOL]         final ComparableSegment upperRight = new ComparableSegment(end, +1.0e-10, +1.0e-10); [EOL]         for (AVLTree<ComparableSegment>.Node n = sorted.getNotSmaller(lowerLeft); (n != null) && (n.getElement().compareTo(upperRight) <= 0); n = n.getNext()) { [EOL]             segment = n.getElement(); [EOL]             final double distance = end.distance(segment.getStart()); [EOL]             if (distance < selectedDistance) { [EOL]                 selectedNode = n; [EOL]                 selectedSegment = segment; [EOL]                 selectedDistance = distance; [EOL]             } [EOL]         } [EOL]         if (selectedDistance > 1.0e-10) { [EOL]             return null; [EOL]         } [EOL]         end = selectedSegment.getEnd(); [EOL]         loop.add(selectedSegment); [EOL]         selectedNode.delete(); [EOL]     } [EOL]     if ((loop.size() == 2) && !open) { [EOL]         return null; [EOL]     } [EOL]     if ((end == null) && !open) { [EOL]         throw new MathInternalError(); [EOL]     } [EOL]     return loop; [EOL] } <line_num>: 684,741
public int compareTo(final ComparableSegment o) { [EOL]     return sortingKey.compareTo(o.sortingKey); [EOL] } <line_num>: 776,778
@Override [EOL] public boolean equals(final Object other) { [EOL]     if (this == other) { [EOL]         return true; [EOL]     } else if (other instanceof ComparableSegment) { [EOL]         return compareTo((ComparableSegment) other) == 0; [EOL]     } else { [EOL]         return false; [EOL]     } [EOL] } <line_num>: 781,790
@Override [EOL] public int hashCode() { [EOL]     return getStart().hashCode() ^ getEnd().hashCode() ^ getLine().hashCode() ^ sortingKey.hashCode(); [EOL] } <line_num>: 793,797
public Order visitOrder(final BSPTree<Euclidean2D> node) { [EOL]     return Order.MINUS_SUB_PLUS; [EOL] } <line_num>: 813,815
public void visitInternalNode(final BSPTree<Euclidean2D> node) { [EOL]     @SuppressWarnings("unchecked") [EOL]     final BoundaryAttribute<Euclidean2D> attribute = (BoundaryAttribute<Euclidean2D>) node.getAttribute(); [EOL]     if (attribute.getPlusOutside() != null) { [EOL]         addContribution(attribute.getPlusOutside(), false); [EOL]     } [EOL]     if (attribute.getPlusInside() != null) { [EOL]         addContribution(attribute.getPlusInside(), true); [EOL]     } [EOL] } <line_num>: 818,827
public void visitLeafNode(final BSPTree<Euclidean2D> node) { [EOL] } <line_num>: 830,831
private void addContribution(final SubHyperplane<Euclidean2D> sub, final boolean reversed) { [EOL]     @SuppressWarnings("unchecked") [EOL]     final AbstractSubHyperplane<Euclidean2D, Euclidean1D> absSub = (AbstractSubHyperplane<Euclidean2D, Euclidean1D>) sub; [EOL]     final Line line = (Line) sub.getHyperplane(); [EOL]     final List<Interval> intervals = ((IntervalsSet) absSub.getRemainingRegion()).asList(); [EOL]     for (final Interval i : intervals) { [EOL]         final Vector2D start = Double.isInfinite(i.getInf()) ? null : (Vector2D) line.toSpace(new Vector1D(i.getInf())); [EOL]         final Vector2D end = Double.isInfinite(i.getSup()) ? null : (Vector2D) line.toSpace(new Vector1D(i.getSup())); [EOL]         if (reversed) { [EOL]             sorted.insert(new ComparableSegment(end, start, line.getReverse())); [EOL]         } else { [EOL]             sorted.insert(new ComparableSegment(start, end, line)); [EOL]         } [EOL]     } [EOL] } <line_num>: 837,854
public AVLTree<ComparableSegment> getSorted() { [EOL]     return sorted; [EOL] } <line_num>: 859,861
