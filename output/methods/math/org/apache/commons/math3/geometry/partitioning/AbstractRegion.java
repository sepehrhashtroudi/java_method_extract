protected AbstractRegion() { [EOL]     tree = new BSPTree<S>(Boolean.TRUE); [EOL] } <line_num>: 51,53
protected AbstractRegion(final BSPTree<S> tree) { [EOL]     this.tree = tree; [EOL] } <line_num>: 67,69
protected AbstractRegion(final Collection<SubHyperplane<S>> boundary) { [EOL]     if (boundary.size() == 0) { [EOL]         tree = new BSPTree<S>(Boolean.TRUE); [EOL]     } else { [EOL]         final TreeSet<SubHyperplane<S>> ordered = new TreeSet<SubHyperplane<S>>(new Comparator<SubHyperplane<S>>() { [EOL]  [EOL]             public int compare(final SubHyperplane<S> o1, final SubHyperplane<S> o2) { [EOL]                 final double size1 = o1.getSize(); [EOL]                 final double size2 = o2.getSize(); [EOL]                 return (size2 < size1) ? -1 : ((o1 == o2) ? 0 : +1); [EOL]             } [EOL]         }); [EOL]         ordered.addAll(boundary); [EOL]         tree = new BSPTree<S>(); [EOL]         insertCuts(tree, ordered); [EOL]         tree.visit(new BSPTreeVisitor<S>() { [EOL]  [EOL]             public Order visitOrder(final BSPTree<S> node) { [EOL]                 return Order.PLUS_SUB_MINUS; [EOL]             } [EOL]  [EOL]             public void visitInternalNode(final BSPTree<S> node) { [EOL]             } [EOL]  [EOL]             public void visitLeafNode(final BSPTree<S> node) { [EOL]                 node.setAttribute((node == node.getParent().getPlus()) ? Boolean.FALSE : Boolean.TRUE); [EOL]             } [EOL]         }); [EOL]     } [EOL] } <line_num>: 90,136
public AbstractRegion(final Hyperplane<S>[] hyperplanes) { [EOL]     if ((hyperplanes == null) || (hyperplanes.length == 0)) { [EOL]         tree = new BSPTree<S>(Boolean.FALSE); [EOL]     } else { [EOL]         tree = hyperplanes[0].wholeSpace().getTree(false); [EOL]         BSPTree<S> node = tree; [EOL]         node.setAttribute(Boolean.TRUE); [EOL]         for (final Hyperplane<S> hyperplane : hyperplanes) { [EOL]             if (node.insertCut(hyperplane)) { [EOL]                 node.setAttribute(null); [EOL]                 node.getPlus().setAttribute(Boolean.FALSE); [EOL]                 node = node.getMinus(); [EOL]                 node.setAttribute(Boolean.TRUE); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 142,164
public Sides() { [EOL]     plusFound = false; [EOL]     minusFound = false; [EOL] } <line_num>: 556,559
public int compare(final SubHyperplane<S> o1, final SubHyperplane<S> o2) { [EOL]     final double size1 = o1.getSize(); [EOL]     final double size2 = o2.getSize(); [EOL]     return (size2 < size1) ? -1 : ((o1 == o2) ? 0 : +1); [EOL] } <line_num>: 103,107
public Order visitOrder(final BSPTree<S> node) { [EOL]     return Order.PLUS_SUB_MINUS; [EOL] } <line_num>: 119,121
public void visitInternalNode(final BSPTree<S> node) { [EOL] } <line_num>: 124,125
public void visitLeafNode(final BSPTree<S> node) { [EOL]     node.setAttribute((node == node.getParent().getPlus()) ? Boolean.FALSE : Boolean.TRUE); [EOL] } <line_num>: 128,131
public abstract AbstractRegion<S, T> buildNew(BSPTree<S> newTree); <line_num>: 167,167
private void insertCuts(final BSPTree<S> node, final Collection<SubHyperplane<S>> boundary) { [EOL]     final Iterator<SubHyperplane<S>> iterator = boundary.iterator(); [EOL]     Hyperplane<S> inserted = null; [EOL]     while ((inserted == null) && iterator.hasNext()) { [EOL]         inserted = iterator.next().getHyperplane(); [EOL]         if (!node.insertCut(inserted.copySelf())) { [EOL]             inserted = null; [EOL]         } [EOL]     } [EOL]     if (!iterator.hasNext()) { [EOL]         return; [EOL]     } [EOL]     final ArrayList<SubHyperplane<S>> plusList = new ArrayList<SubHyperplane<S>>(); [EOL]     final ArrayList<SubHyperplane<S>> minusList = new ArrayList<SubHyperplane<S>>(); [EOL]     while (iterator.hasNext()) { [EOL]         final SubHyperplane<S> other = iterator.next(); [EOL]         switch(other.side(inserted)) { [EOL]             case PLUS: [EOL]                 plusList.add(other); [EOL]                 break; [EOL]             case MINUS: [EOL]                 minusList.add(other); [EOL]                 break; [EOL]             case BOTH: [EOL]                 final SubHyperplane.SplitSubHyperplane<S> split = other.split(inserted); [EOL]                 plusList.add(split.getPlus()); [EOL]                 minusList.add(split.getMinus()); [EOL]                 break; [EOL]             default: [EOL]         } [EOL]     } [EOL]     insertCuts(node.getPlus(), plusList); [EOL]     insertCuts(node.getMinus(), minusList); [EOL] } <line_num>: 175,218
public AbstractRegion<S, T> copySelf() { [EOL]     return buildNew(tree.copySelf()); [EOL] } <line_num>: 221,223
public boolean isEmpty() { [EOL]     return isEmpty(tree); [EOL] } <line_num>: 226,228
public boolean isEmpty(final BSPTree<S> node) { [EOL]     if (node.getCut() == null) { [EOL]         return !((Boolean) node.getAttribute()); [EOL]     } [EOL]     return isEmpty(node.getMinus()) && isEmpty(node.getPlus()); [EOL] } <line_num>: 231,245
public boolean contains(final Region<S> region) { [EOL]     return new RegionFactory<S>().difference(region, this).isEmpty(); [EOL] } <line_num>: 248,250
public Location checkPoint(final Vector<S> point) { [EOL]     return checkPoint(tree, point); [EOL] } <line_num>: 253,255
protected Location checkPoint(final BSPTree<S> node, final Vector<S> point) { [EOL]     final BSPTree<S> cell = node.getCell(point); [EOL]     if (cell.getCut() == null) { [EOL]         return ((Boolean) cell.getAttribute()) ? Location.INSIDE : Location.OUTSIDE; [EOL]     } [EOL]     final Location minusCode = checkPoint(cell.getMinus(), point); [EOL]     final Location plusCode = checkPoint(cell.getPlus(), point); [EOL]     return (minusCode == plusCode) ? minusCode : Location.BOUNDARY; [EOL] } <line_num>: 264,276
public BSPTree<S> getTree(final boolean includeBoundaryAttributes) { [EOL]     if (includeBoundaryAttributes && (tree.getCut() != null) && (tree.getAttribute() == null)) { [EOL]         tree.visit(new BoundaryBuilder<S>()); [EOL]     } [EOL]     return tree; [EOL] } <line_num>: 279,285
public Order visitOrder(BSPTree<S> node) { [EOL]     return Order.PLUS_MINUS_SUB; [EOL] } <line_num>: 296,298
public void visitInternalNode(BSPTree<S> node) { [EOL]     SubHyperplane<S> plusOutside = null; [EOL]     SubHyperplane<S> plusInside = null; [EOL]     @SuppressWarnings("unchecked") [EOL]     final SubHyperplane<S>[] plusChar = (SubHyperplane<S>[]) Array.newInstance(SubHyperplane.class, 2); [EOL]     characterize(node.getPlus(), node.getCut().copySelf(), plusChar); [EOL]     if (plusChar[0] != null && !plusChar[0].isEmpty()) { [EOL]         @SuppressWarnings("unchecked") [EOL]         final SubHyperplane<S>[] minusChar = (SubHyperplane<S>[]) Array.newInstance(SubHyperplane.class, 2); [EOL]         characterize(node.getMinus(), plusChar[0], minusChar); [EOL]         if (minusChar[1] != null && !minusChar[1].isEmpty()) { [EOL]             plusOutside = minusChar[1]; [EOL]         } [EOL]     } [EOL]     if (plusChar[1] != null && !plusChar[1].isEmpty()) { [EOL]         @SuppressWarnings("unchecked") [EOL]         final SubHyperplane<S>[] minusChar = (SubHyperplane<S>[]) Array.newInstance(SubHyperplane.class, 2); [EOL]         characterize(node.getMinus(), plusChar[1], minusChar); [EOL]         if (minusChar[0] != null && !minusChar[0].isEmpty()) { [EOL]             plusInside = minusChar[0]; [EOL]         } [EOL]     } [EOL]     node.setAttribute(new BoundaryAttribute<S>(plusOutside, plusInside)); [EOL] } <line_num>: 301,343
public void visitLeafNode(BSPTree<S> node) { [EOL] } <line_num>: 346,347
private void characterize(final BSPTree<S> node, final SubHyperplane<S> sub, final SubHyperplane<S>[] characterization) { [EOL]     if (node.getCut() == null) { [EOL]         final boolean inside = (Boolean) node.getAttribute(); [EOL]         if (inside) { [EOL]             if (characterization[1] == null) { [EOL]                 characterization[1] = sub; [EOL]             } else { [EOL]                 characterization[1] = characterization[1].reunite(sub); [EOL]             } [EOL]         } else { [EOL]             if (characterization[0] == null) { [EOL]                 characterization[0] = sub; [EOL]             } else { [EOL]                 characterization[0] = characterization[0].reunite(sub); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         final Hyperplane<S> hyperplane = node.getCut().getHyperplane(); [EOL]         switch(sub.side(hyperplane)) { [EOL]             case PLUS: [EOL]                 characterize(node.getPlus(), sub, characterization); [EOL]                 break; [EOL]             case MINUS: [EOL]                 characterize(node.getMinus(), sub, characterization); [EOL]                 break; [EOL]             case BOTH: [EOL]                 final SubHyperplane.SplitSubHyperplane<S> split = sub.split(hyperplane); [EOL]                 characterize(node.getPlus(), split.getPlus(), characterization); [EOL]                 characterize(node.getMinus(), split.getMinus(), characterization); [EOL]                 break; [EOL]             default: [EOL]                 throw new MathInternalError(); [EOL]         } [EOL]     } [EOL] } <line_num>: 362,399
public double getBoundarySize() { [EOL]     final BoundarySizeVisitor<S> visitor = new BoundarySizeVisitor<S>(); [EOL]     getTree(true).visit(visitor); [EOL]     return visitor.getSize(); [EOL] } <line_num>: 404,408
public double getSize() { [EOL]     if (barycenter == null) { [EOL]         computeGeometricalProperties(); [EOL]     } [EOL]     return size; [EOL] } <line_num>: 411,416
protected void setSize(final double size) { [EOL]     this.size = size; [EOL] } <line_num>: 421,423
public Vector<S> getBarycenter() { [EOL]     if (barycenter == null) { [EOL]         computeGeometricalProperties(); [EOL]     } [EOL]     return barycenter; [EOL] } <line_num>: 426,431
protected void setBarycenter(final Vector<S> barycenter) { [EOL]     this.barycenter = barycenter; [EOL] } <line_num>: 436,438
protected abstract void computeGeometricalProperties(); <line_num>: 443,443
public Side side(final Hyperplane<S> hyperplane) { [EOL]     final Sides sides = new Sides(); [EOL]     recurseSides(tree, hyperplane.wholeHyperplane(), sides); [EOL]     return sides.plusFound() ? (sides.minusFound() ? Side.BOTH : Side.PLUS) : (sides.minusFound() ? Side.MINUS : Side.HYPER); [EOL] } <line_num>: 446,452
private void recurseSides(final BSPTree<S> node, final SubHyperplane<S> sub, final Sides sides) { [EOL]     if (node.getCut() == null) { [EOL]         if ((Boolean) node.getAttribute()) { [EOL]             sides.rememberPlusFound(); [EOL]             sides.rememberMinusFound(); [EOL]         } [EOL]         return; [EOL]     } [EOL]     final Hyperplane<S> hyperplane = node.getCut().getHyperplane(); [EOL]     switch(sub.side(hyperplane)) { [EOL]         case PLUS: [EOL]             if (node.getCut().side(sub.getHyperplane()) == Side.PLUS) { [EOL]                 if (!isEmpty(node.getMinus())) { [EOL]                     sides.rememberPlusFound(); [EOL]                 } [EOL]             } else { [EOL]                 if (!isEmpty(node.getMinus())) { [EOL]                     sides.rememberMinusFound(); [EOL]                 } [EOL]             } [EOL]             if (!(sides.plusFound() && sides.minusFound())) { [EOL]                 recurseSides(node.getPlus(), sub, sides); [EOL]             } [EOL]             break; [EOL]         case MINUS: [EOL]             if (node.getCut().side(sub.getHyperplane()) == Side.PLUS) { [EOL]                 if (!isEmpty(node.getPlus())) { [EOL]                     sides.rememberPlusFound(); [EOL]                 } [EOL]             } else { [EOL]                 if (!isEmpty(node.getPlus())) { [EOL]                     sides.rememberMinusFound(); [EOL]                 } [EOL]             } [EOL]             if (!(sides.plusFound() && sides.minusFound())) { [EOL]                 recurseSides(node.getMinus(), sub, sides); [EOL]             } [EOL]             break; [EOL]         case BOTH: [EOL]             final SubHyperplane.SplitSubHyperplane<S> split = sub.split(hyperplane); [EOL]             recurseSides(node.getPlus(), split.getPlus(), sides); [EOL]             if (!(sides.plusFound() && sides.minusFound())) { [EOL]                 recurseSides(node.getMinus(), split.getMinus(), sides); [EOL]             } [EOL]             break; [EOL]         default: [EOL]             if (node.getCut().getHyperplane().sameOrientationAs(sub.getHyperplane())) { [EOL]                 if ((node.getPlus().getCut() != null) || ((Boolean) node.getPlus().getAttribute())) { [EOL]                     sides.rememberPlusFound(); [EOL]                 } [EOL]                 if ((node.getMinus().getCut() != null) || ((Boolean) node.getMinus().getAttribute())) { [EOL]                     sides.rememberMinusFound(); [EOL]                 } [EOL]             } else { [EOL]                 if ((node.getPlus().getCut() != null) || ((Boolean) node.getPlus().getAttribute())) { [EOL]                     sides.rememberMinusFound(); [EOL]                 } [EOL]                 if ((node.getMinus().getCut() != null) || ((Boolean) node.getMinus().getAttribute())) { [EOL]                     sides.rememberPlusFound(); [EOL]                 } [EOL]             } [EOL]     } [EOL] } <line_num>: 469,543
public void rememberPlusFound() { [EOL]     plusFound = true; [EOL] } <line_num>: 563,565
public boolean plusFound() { [EOL]     return plusFound; [EOL] } <line_num>: 570,572
public void rememberMinusFound() { [EOL]     minusFound = true; [EOL] } <line_num>: 576,578
public boolean minusFound() { [EOL]     return minusFound; [EOL] } <line_num>: 583,585
public SubHyperplane<S> intersection(final SubHyperplane<S> sub) { [EOL]     return recurseIntersection(tree, sub); [EOL] } <line_num>: 590,592
private SubHyperplane<S> recurseIntersection(final BSPTree<S> node, final SubHyperplane<S> sub) { [EOL]     if (node.getCut() == null) { [EOL]         return (Boolean) node.getAttribute() ? sub.copySelf() : null; [EOL]     } [EOL]     final Hyperplane<S> hyperplane = node.getCut().getHyperplane(); [EOL]     switch(sub.side(hyperplane)) { [EOL]         case PLUS: [EOL]             return recurseIntersection(node.getPlus(), sub); [EOL]         case MINUS: [EOL]             return recurseIntersection(node.getMinus(), sub); [EOL]         case BOTH: [EOL]             final SubHyperplane.SplitSubHyperplane<S> split = sub.split(hyperplane); [EOL]             final SubHyperplane<S> plus = recurseIntersection(node.getPlus(), split.getPlus()); [EOL]             final SubHyperplane<S> minus = recurseIntersection(node.getMinus(), split.getMinus()); [EOL]             if (plus == null) { [EOL]                 return minus; [EOL]             } else if (minus == null) { [EOL]                 return plus; [EOL]             } else { [EOL]                 return plus.reunite(minus); [EOL]             } [EOL]         default: [EOL]             return recurseIntersection(node.getPlus(), recurseIntersection(node.getMinus(), sub)); [EOL]     } [EOL] } <line_num>: 600,628
public AbstractRegion<S, T> applyTransform(final Transform<S, T> transform) { [EOL]     return buildNew(recurseTransform(getTree(false), transform)); [EOL] } <line_num>: 640,642
@SuppressWarnings("unchecked") [EOL] private BSPTree<S> recurseTransform(final BSPTree<S> node, final Transform<S, T> transform) { [EOL]     if (node.getCut() == null) { [EOL]         return new BSPTree<S>(node.getAttribute()); [EOL]     } [EOL]     final SubHyperplane<S> sub = node.getCut(); [EOL]     final SubHyperplane<S> tSub = ((AbstractSubHyperplane<S, T>) sub).applyTransform(transform); [EOL]     BoundaryAttribute<S> attribute = (BoundaryAttribute<S>) node.getAttribute(); [EOL]     if (attribute != null) { [EOL]         final SubHyperplane<S> tPO = (attribute.getPlusOutside() == null) ? null : ((AbstractSubHyperplane<S, T>) attribute.getPlusOutside()).applyTransform(transform); [EOL]         final SubHyperplane<S> tPI = (attribute.getPlusInside() == null) ? null : ((AbstractSubHyperplane<S, T>) attribute.getPlusInside()).applyTransform(transform); [EOL]         attribute = new BoundaryAttribute<S>(tPO, tPI); [EOL]     } [EOL]     return new BSPTree<S>(tSub, recurseTransform(node.getPlus(), transform), recurseTransform(node.getMinus(), transform), attribute); [EOL] } <line_num>: 649,672
