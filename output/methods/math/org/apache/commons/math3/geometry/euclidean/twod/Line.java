public Line(final Vector2D p1, final Vector2D p2) { [EOL]     reset(p1, p2); [EOL] } <line_num>: 81,83
public Line(final Vector2D p, final double angle) { [EOL]     reset(p, angle); [EOL] } <line_num>: 89,91
private Line(final double angle, final double cos, final double sin, final double originOffset) { [EOL]     this.angle = angle; [EOL]     this.cos = cos; [EOL]     this.sin = sin; [EOL]     this.originOffset = originOffset; [EOL] } <line_num>: 99,104
public Line(final Line line) { [EOL]     angle = MathUtils.normalizeAngle(line.angle, FastMath.PI); [EOL]     cos = FastMath.cos(angle); [EOL]     sin = FastMath.sin(angle); [EOL]     originOffset = line.originOffset; [EOL] } <line_num>: 111,116
public LineTransform(final AffineTransform transform) throws MathIllegalArgumentException { [EOL]     final double[] m = new double[6]; [EOL]     transform.getMatrix(m); [EOL]     cXX = m[0]; [EOL]     cXY = m[2]; [EOL]     cX1 = m[4]; [EOL]     cYX = m[1]; [EOL]     cYY = m[3]; [EOL]     cY1 = m[5]; [EOL]     c1Y = cXY * cY1 - cYY * cX1; [EOL]     c1X = cXX * cY1 - cYX * cX1; [EOL]     c11 = cXX * cYY - cYX * cXY; [EOL]     if (FastMath.abs(c11) < 1.0e-20) { [EOL]         throw new MathIllegalArgumentException(LocalizedFormats.NON_INVERTIBLE_TRANSFORM); [EOL]     } [EOL] } <line_num>: 371,390
public Line copySelf() { [EOL]     return new Line(this); [EOL] } <line_num>: 119,121
public void reset(final Vector2D p1, final Vector2D p2) { [EOL]     final double dx = p2.getX() - p1.getX(); [EOL]     final double dy = p2.getY() - p1.getY(); [EOL]     final double d = FastMath.hypot(dx, dy); [EOL]     if (d == 0.0) { [EOL]         angle = 0.0; [EOL]         cos = 1.0; [EOL]         sin = 0.0; [EOL]         originOffset = p1.getY(); [EOL]     } else { [EOL]         angle = FastMath.PI + FastMath.atan2(-dy, -dx); [EOL]         cos = FastMath.cos(angle); [EOL]         sin = FastMath.sin(angle); [EOL]         originOffset = (p2.getX() * p1.getY() - p1.getX() * p2.getY()) / d; [EOL]     } [EOL] } <line_num>: 128,143
public void reset(final Vector2D p, final double alpha) { [EOL]     this.angle = MathUtils.normalizeAngle(alpha, FastMath.PI); [EOL]     cos = FastMath.cos(this.angle); [EOL]     sin = FastMath.sin(this.angle); [EOL]     originOffset = cos * p.getY() - sin * p.getX(); [EOL] } <line_num>: 149,154
public void revertSelf() { [EOL]     if (angle < FastMath.PI) { [EOL]         angle += FastMath.PI; [EOL]     } else { [EOL]         angle -= FastMath.PI; [EOL]     } [EOL]     cos = -cos; [EOL]     sin = -sin; [EOL]     originOffset = -originOffset; [EOL] } <line_num>: 158,167
public Line getReverse() { [EOL]     return new Line((angle < FastMath.PI) ? (angle + FastMath.PI) : (angle - FastMath.PI), -cos, -sin, -originOffset); [EOL] } <line_num>: 174,177
public Vector1D toSubSpace(final Vector<Euclidean2D> point) { [EOL]     Vector2D p2 = (Vector2D) point; [EOL]     return new Vector1D(cos * p2.getX() + sin * p2.getY()); [EOL] } <line_num>: 180,183
public Vector2D toSpace(final Vector<Euclidean1D> point) { [EOL]     final double abscissa = ((Vector1D) point).getX(); [EOL]     return new Vector2D(abscissa * cos - originOffset * sin, abscissa * sin + originOffset * cos); [EOL] } <line_num>: 186,190
public Vector2D intersection(final Line other) { [EOL]     final double d = sin * other.cos - other.sin * cos; [EOL]     if (FastMath.abs(d) < 1.0e-10) { [EOL]         return null; [EOL]     } [EOL]     return new Vector2D((cos * other.originOffset - other.cos * originOffset) / d, (sin * other.originOffset - other.sin * originOffset) / d); [EOL] } <line_num>: 197,204
public SubLine wholeHyperplane() { [EOL]     return new SubLine(this, new IntervalsSet()); [EOL] } <line_num>: 207,209
public PolygonsSet wholeSpace() { [EOL]     return new PolygonsSet(); [EOL] } <line_num>: 215,217
public double getOffset(final Line line) { [EOL]     return originOffset + ((cos * line.cos + sin * line.sin > 0) ? -line.originOffset : line.originOffset); [EOL] } <line_num>: 229,232
public double getOffset(final Vector<Euclidean2D> point) { [EOL]     Vector2D p2 = (Vector2D) point; [EOL]     return sin * p2.getX() - cos * p2.getY() + originOffset; [EOL] } <line_num>: 235,238
public boolean sameOrientationAs(final Hyperplane<Euclidean2D> other) { [EOL]     final Line otherL = (Line) other; [EOL]     return (sin * otherL.sin + cos * otherL.cos) >= 0.0; [EOL] } <line_num>: 241,244
public Vector2D getPointAt(final Vector1D abscissa, final double offset) { [EOL]     final double x = abscissa.getX(); [EOL]     final double dOffset = offset - originOffset; [EOL]     return new Vector2D(x * cos + dOffset * sin, x * sin - dOffset * cos); [EOL] } <line_num>: 252,256
public boolean contains(final Vector2D p) { [EOL]     return FastMath.abs(getOffset(p)) < 1.0e-10; [EOL] } <line_num>: 262,264
public double distance(final Vector2D p) { [EOL]     return FastMath.abs(getOffset(p)); [EOL] } <line_num>: 275,277
public boolean isParallelTo(final Line line) { [EOL]     return FastMath.abs(sin * line.cos - cos * line.sin) < 1.0e-10; [EOL] } <line_num>: 284,286
public void translateToPoint(final Vector2D p) { [EOL]     originOffset = cos * p.getY() - sin * p.getX(); [EOL] } <line_num>: 291,293
public double getAngle() { [EOL]     return MathUtils.normalizeAngle(angle, FastMath.PI); [EOL] } <line_num>: 298,300
public void setAngle(final double angle) { [EOL]     this.angle = MathUtils.normalizeAngle(angle, FastMath.PI); [EOL]     cos = FastMath.cos(this.angle); [EOL]     sin = FastMath.sin(this.angle); [EOL] } <line_num>: 305,309
public double getOriginOffset() { [EOL]     return originOffset; [EOL] } <line_num>: 314,316
public void setOriginOffset(final double offset) { [EOL]     originOffset = offset; [EOL] } <line_num>: 321,323
public static Transform<Euclidean2D, Euclidean1D> getTransform(final AffineTransform transform) throws MathIllegalArgumentException { [EOL]     return new LineTransform(transform); [EOL] } <line_num>: 338,341
public Vector2D apply(final Vector<Euclidean2D> point) { [EOL]     final Vector2D p2D = (Vector2D) point; [EOL]     final double x = p2D.getX(); [EOL]     final double y = p2D.getY(); [EOL]     return new Vector2D(cXX * x + cXY * y + cX1, cYX * x + cYY * y + cY1); [EOL] } <line_num>: 393,399
public Line apply(final Hyperplane<Euclidean2D> hyperplane) { [EOL]     final Line line = (Line) hyperplane; [EOL]     final double rOffset = c1X * line.cos + c1Y * line.sin + c11 * line.originOffset; [EOL]     final double rCos = cXX * line.cos + cXY * line.sin; [EOL]     final double rSin = cYX * line.cos + cYY * line.sin; [EOL]     final double inv = 1.0 / FastMath.sqrt(rSin * rSin + rCos * rCos); [EOL]     return new Line(FastMath.PI + FastMath.atan2(-rSin, -rCos), inv * rCos, inv * rSin, inv * rOffset); [EOL] } <line_num>: 402,411
public SubHyperplane<Euclidean1D> apply(final SubHyperplane<Euclidean1D> sub, final Hyperplane<Euclidean2D> original, final Hyperplane<Euclidean2D> transformed) { [EOL]     final OrientedPoint op = (OrientedPoint) sub.getHyperplane(); [EOL]     final Line originalLine = (Line) original; [EOL]     final Line transformedLine = (Line) transformed; [EOL]     final Vector1D newLoc = transformedLine.toSubSpace(apply(originalLine.toSpace(op.getLocation()))); [EOL]     return new OrientedPoint(newLoc, op.isDirect()).wholeHyperplane(); [EOL] } <line_num>: 414,423
