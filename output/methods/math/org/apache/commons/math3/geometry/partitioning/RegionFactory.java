public RegionFactory() { [EOL]     nodeCleaner = new NodesCleaner(); [EOL] } <line_num>: 35,37
public Region<S> buildConvex(final Hyperplane<S>... hyperplanes) { [EOL]     if ((hyperplanes == null) || (hyperplanes.length == 0)) { [EOL]         return null; [EOL]     } [EOL]     final Region<S> region = hyperplanes[0].wholeSpace(); [EOL]     BSPTree<S> node = region.getTree(false); [EOL]     node.setAttribute(Boolean.TRUE); [EOL]     for (final Hyperplane<S> hyperplane : hyperplanes) { [EOL]         if (node.insertCut(hyperplane)) { [EOL]             node.setAttribute(null); [EOL]             node.getPlus().setAttribute(Boolean.FALSE); [EOL]             node = node.getMinus(); [EOL]             node.setAttribute(Boolean.TRUE); [EOL]         } [EOL]     } [EOL]     return region; [EOL] } <line_num>: 43,65
public Region<S> union(final Region<S> region1, final Region<S> region2) { [EOL]     final BSPTree<S> tree = region1.getTree(false).merge(region2.getTree(false), new UnionMerger()); [EOL]     tree.visit(nodeCleaner); [EOL]     return region1.buildNew(tree); [EOL] } <line_num>: 74,79
public Region<S> intersection(final Region<S> region1, final Region<S> region2) { [EOL]     final BSPTree<S> tree = region1.getTree(false).merge(region2.getTree(false), new IntersectionMerger()); [EOL]     tree.visit(nodeCleaner); [EOL]     return region1.buildNew(tree); [EOL] } <line_num>: 88,93
public Region<S> xor(final Region<S> region1, final Region<S> region2) { [EOL]     final BSPTree<S> tree = region1.getTree(false).merge(region2.getTree(false), new XorMerger()); [EOL]     tree.visit(nodeCleaner); [EOL]     return region1.buildNew(tree); [EOL] } <line_num>: 102,107
public Region<S> difference(final Region<S> region1, final Region<S> region2) { [EOL]     final BSPTree<S> tree = region1.getTree(false).merge(region2.getTree(false), new DifferenceMerger()); [EOL]     tree.visit(nodeCleaner); [EOL]     return region1.buildNew(tree); [EOL] } <line_num>: 116,121
public Region<S> getComplement(final Region<S> region) { [EOL]     return region.buildNew(recurseComplement(region.getTree(false))); [EOL] } <line_num>: 128,130
private BSPTree<S> recurseComplement(final BSPTree<S> node) { [EOL]     if (node.getCut() == null) { [EOL]         return new BSPTree<S>(((Boolean) node.getAttribute()) ? Boolean.FALSE : Boolean.TRUE); [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     BoundaryAttribute<S> attribute = (BoundaryAttribute<S>) node.getAttribute(); [EOL]     if (attribute != null) { [EOL]         final SubHyperplane<S> plusOutside = (attribute.getPlusInside() == null) ? null : attribute.getPlusInside().copySelf(); [EOL]         final SubHyperplane<S> plusInside = (attribute.getPlusOutside() == null) ? null : attribute.getPlusOutside().copySelf(); [EOL]         attribute = new BoundaryAttribute<S>(plusOutside, plusInside); [EOL]     } [EOL]     return new BSPTree<S>(node.getCut().copySelf(), recurseComplement(node.getPlus()), recurseComplement(node.getMinus()), attribute); [EOL] } <line_num>: 136,156
public BSPTree<S> merge(final BSPTree<S> leaf, final BSPTree<S> tree, final BSPTree<S> parentTree, final boolean isPlusChild, final boolean leafFromInstance) { [EOL]     if ((Boolean) leaf.getAttribute()) { [EOL]         leaf.insertInTree(parentTree, isPlusChild); [EOL]         return leaf; [EOL]     } [EOL]     tree.insertInTree(parentTree, isPlusChild); [EOL]     return tree; [EOL] } <line_num>: 161,172
public BSPTree<S> merge(final BSPTree<S> leaf, final BSPTree<S> tree, final BSPTree<S> parentTree, final boolean isPlusChild, final boolean leafFromInstance) { [EOL]     if ((Boolean) leaf.getAttribute()) { [EOL]         tree.insertInTree(parentTree, isPlusChild); [EOL]         return tree; [EOL]     } [EOL]     leaf.insertInTree(parentTree, isPlusChild); [EOL]     return leaf; [EOL] } <line_num>: 178,189
public BSPTree<S> merge(final BSPTree<S> leaf, final BSPTree<S> tree, final BSPTree<S> parentTree, final boolean isPlusChild, final boolean leafFromInstance) { [EOL]     BSPTree<S> t = tree; [EOL]     if ((Boolean) leaf.getAttribute()) { [EOL]         t = recurseComplement(t); [EOL]     } [EOL]     t.insertInTree(parentTree, isPlusChild); [EOL]     return t; [EOL] } <line_num>: 195,205
public BSPTree<S> merge(final BSPTree<S> leaf, final BSPTree<S> tree, final BSPTree<S> parentTree, final boolean isPlusChild, final boolean leafFromInstance) { [EOL]     if ((Boolean) leaf.getAttribute()) { [EOL]         final BSPTree<S> argTree = recurseComplement(leafFromInstance ? tree : leaf); [EOL]         argTree.insertInTree(parentTree, isPlusChild); [EOL]         return argTree; [EOL]     } [EOL]     final BSPTree<S> instanceTree = leafFromInstance ? leaf : tree; [EOL]     instanceTree.insertInTree(parentTree, isPlusChild); [EOL]     return instanceTree; [EOL] } <line_num>: 211,226
public Order visitOrder(final BSPTree<S> node) { [EOL]     return Order.PLUS_SUB_MINUS; [EOL] } <line_num>: 233,235
public void visitInternalNode(final BSPTree<S> node) { [EOL]     node.setAttribute(null); [EOL] } <line_num>: 238,240
public void visitLeafNode(final BSPTree<S> node) { [EOL] } <line_num>: 243,244
