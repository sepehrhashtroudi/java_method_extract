public AVLTree() { [EOL]     top = null; [EOL] } <line_num>: 54,56
Node(final T element, final Node parent) { [EOL]     this.element = element; [EOL]     left = null; [EOL]     right = null; [EOL]     this.parent = parent; [EOL]     skew = Skew.BALANCED; [EOL] } <line_num>: 245,251
public void insert(final T element) { [EOL]     if (element != null) { [EOL]         if (top == null) { [EOL]             top = new Node(element, null); [EOL]         } else { [EOL]             top.insert(element); [EOL]         } [EOL]     } [EOL] } <line_num>: 61,69
public boolean delete(final T element) { [EOL]     if (element != null) { [EOL]         for (Node node = getNotSmaller(element); node != null; node = node.getNext()) { [EOL]             if (node.element == element) { [EOL]                 node.delete(); [EOL]                 return true; [EOL]             } else if (node.element.compareTo(element) > 0) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 81,97
public boolean isEmpty() { [EOL]     return top == null; [EOL] } <line_num>: 102,104
public int size() { [EOL]     return (top == null) ? 0 : top.size(); [EOL] } <line_num>: 110,112
public Node getSmallest() { [EOL]     return (top == null) ? null : top.getSmallest(); [EOL] } <line_num>: 123,125
public Node getLargest() { [EOL]     return (top == null) ? null : top.getLargest(); [EOL] } <line_num>: 136,138
public Node getNotSmaller(final T reference) { [EOL]     Node candidate = null; [EOL]     for (Node node = top; node != null; ) { [EOL]         if (node.element.compareTo(reference) < 0) { [EOL]             if (node.right == null) { [EOL]                 return candidate; [EOL]             } [EOL]             node = node.right; [EOL]         } else { [EOL]             candidate = node; [EOL]             if (node.left == null) { [EOL]                 return candidate; [EOL]             } [EOL]             node = node.left; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 151,168
public Node getNotLarger(final T reference) { [EOL]     Node candidate = null; [EOL]     for (Node node = top; node != null; ) { [EOL]         if (node.element.compareTo(reference) > 0) { [EOL]             if (node.left == null) { [EOL]                 return candidate; [EOL]             } [EOL]             node = node.left; [EOL]         } else { [EOL]             candidate = node; [EOL]             if (node.right == null) { [EOL]                 return candidate; [EOL]             } [EOL]             node = node.right; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 182,199
public T getElement() { [EOL]     return element; [EOL] } <line_num>: 256,258
int size() { [EOL]     return 1 + ((left == null) ? 0 : left.size()) + ((right == null) ? 0 : right.size()); [EOL] } <line_num>: 263,265
Node getSmallest() { [EOL]     Node node = this; [EOL]     while (node.left != null) { [EOL]         node = node.left; [EOL]     } [EOL]     return node; [EOL] } <line_num>: 273,279
Node getLargest() { [EOL]     Node node = this; [EOL]     while (node.right != null) { [EOL]         node = node.right; [EOL]     } [EOL]     return node; [EOL] } <line_num>: 287,293
public Node getPrevious() { [EOL]     if (left != null) { [EOL]         final Node node = left.getLargest(); [EOL]         if (node != null) { [EOL]             return node; [EOL]         } [EOL]     } [EOL]     for (Node node = this; node.parent != null; node = node.parent) { [EOL]         if (node != node.parent.left) { [EOL]             return node.parent; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 300,317
public Node getNext() { [EOL]     if (right != null) { [EOL]         final Node node = right.getSmallest(); [EOL]         if (node != null) { [EOL]             return node; [EOL]         } [EOL]     } [EOL]     for (Node node = this; node.parent != null; node = node.parent) { [EOL]         if (node != node.parent.right) { [EOL]             return node.parent; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 325,342
boolean insert(final T newElement) { [EOL]     if (newElement.compareTo(this.element) < 0) { [EOL]         if (left == null) { [EOL]             left = new Node(newElement, this); [EOL]             return rebalanceLeftGrown(); [EOL]         } [EOL]         return left.insert(newElement) ? rebalanceLeftGrown() : false; [EOL]     } [EOL]     if (right == null) { [EOL]         right = new Node(newElement, this); [EOL]         return rebalanceRightGrown(); [EOL]     } [EOL]     return right.insert(newElement) ? rebalanceRightGrown() : false; [EOL] } <line_num>: 348,365
public void delete() { [EOL]     if ((parent == null) && (left == null) && (right == null)) { [EOL]         element = null; [EOL]         top = null; [EOL]     } else { [EOL]         Node node; [EOL]         Node child; [EOL]         boolean leftShrunk; [EOL]         if ((left == null) && (right == null)) { [EOL]             node = this; [EOL]             element = null; [EOL]             leftShrunk = node == node.parent.left; [EOL]             child = null; [EOL]         } else { [EOL]             node = (left != null) ? left.getLargest() : right.getSmallest(); [EOL]             element = node.element; [EOL]             leftShrunk = node == node.parent.left; [EOL]             child = (node.left != null) ? node.left : node.right; [EOL]         } [EOL]         node = node.parent; [EOL]         if (leftShrunk) { [EOL]             node.left = child; [EOL]         } else { [EOL]             node.right = child; [EOL]         } [EOL]         if (child != null) { [EOL]             child.parent = node; [EOL]         } [EOL]         while (leftShrunk ? node.rebalanceLeftShrunk() : node.rebalanceRightShrunk()) { [EOL]             if (node.parent == null) { [EOL]                 return; [EOL]             } [EOL]             leftShrunk = node == node.parent.left; [EOL]             node = node.parent; [EOL]         } [EOL]     } [EOL] } <line_num>: 369,410
private boolean rebalanceLeftGrown() { [EOL]     switch(skew) { [EOL]         case LEFT_HIGH: [EOL]             if (left.skew == Skew.LEFT_HIGH) { [EOL]                 rotateCW(); [EOL]                 skew = Skew.BALANCED; [EOL]                 right.skew = Skew.BALANCED; [EOL]             } else { [EOL]                 final Skew s = left.right.skew; [EOL]                 left.rotateCCW(); [EOL]                 rotateCW(); [EOL]                 switch(s) { [EOL]                     case LEFT_HIGH: [EOL]                         left.skew = Skew.BALANCED; [EOL]                         right.skew = Skew.RIGHT_HIGH; [EOL]                         break; [EOL]                     case RIGHT_HIGH: [EOL]                         left.skew = Skew.LEFT_HIGH; [EOL]                         right.skew = Skew.BALANCED; [EOL]                         break; [EOL]                     default: [EOL]                         left.skew = Skew.BALANCED; [EOL]                         right.skew = Skew.BALANCED; [EOL]                 } [EOL]                 skew = Skew.BALANCED; [EOL]             } [EOL]             return false; [EOL]         case RIGHT_HIGH: [EOL]             skew = Skew.BALANCED; [EOL]             return false; [EOL]         default: [EOL]             skew = Skew.LEFT_HIGH; [EOL]             return true; [EOL]     } [EOL] } <line_num>: 415,449
private boolean rebalanceRightGrown() { [EOL]     switch(skew) { [EOL]         case LEFT_HIGH: [EOL]             skew = Skew.BALANCED; [EOL]             return false; [EOL]         case RIGHT_HIGH: [EOL]             if (right.skew == Skew.RIGHT_HIGH) { [EOL]                 rotateCCW(); [EOL]                 skew = Skew.BALANCED; [EOL]                 left.skew = Skew.BALANCED; [EOL]             } else { [EOL]                 final Skew s = right.left.skew; [EOL]                 right.rotateCW(); [EOL]                 rotateCCW(); [EOL]                 switch(s) { [EOL]                     case LEFT_HIGH: [EOL]                         left.skew = Skew.BALANCED; [EOL]                         right.skew = Skew.RIGHT_HIGH; [EOL]                         break; [EOL]                     case RIGHT_HIGH: [EOL]                         left.skew = Skew.LEFT_HIGH; [EOL]                         right.skew = Skew.BALANCED; [EOL]                         break; [EOL]                     default: [EOL]                         left.skew = Skew.BALANCED; [EOL]                         right.skew = Skew.BALANCED; [EOL]                 } [EOL]                 skew = Skew.BALANCED; [EOL]             } [EOL]             return false; [EOL]         default: [EOL]             skew = Skew.RIGHT_HIGH; [EOL]             return true; [EOL]     } [EOL] } <line_num>: 454,488
private boolean rebalanceLeftShrunk() { [EOL]     switch(skew) { [EOL]         case LEFT_HIGH: [EOL]             skew = Skew.BALANCED; [EOL]             return true; [EOL]         case RIGHT_HIGH: [EOL]             if (right.skew == Skew.RIGHT_HIGH) { [EOL]                 rotateCCW(); [EOL]                 skew = Skew.BALANCED; [EOL]                 left.skew = Skew.BALANCED; [EOL]                 return true; [EOL]             } else if (right.skew == Skew.BALANCED) { [EOL]                 rotateCCW(); [EOL]                 skew = Skew.LEFT_HIGH; [EOL]                 left.skew = Skew.RIGHT_HIGH; [EOL]                 return false; [EOL]             } else { [EOL]                 final Skew s = right.left.skew; [EOL]                 right.rotateCW(); [EOL]                 rotateCCW(); [EOL]                 switch(s) { [EOL]                     case LEFT_HIGH: [EOL]                         left.skew = Skew.BALANCED; [EOL]                         right.skew = Skew.RIGHT_HIGH; [EOL]                         break; [EOL]                     case RIGHT_HIGH: [EOL]                         left.skew = Skew.LEFT_HIGH; [EOL]                         right.skew = Skew.BALANCED; [EOL]                         break; [EOL]                     default: [EOL]                         left.skew = Skew.BALANCED; [EOL]                         right.skew = Skew.BALANCED; [EOL]                 } [EOL]                 skew = Skew.BALANCED; [EOL]                 return true; [EOL]             } [EOL]         default: [EOL]             skew = Skew.RIGHT_HIGH; [EOL]             return false; [EOL]     } [EOL] } <line_num>: 493,533
private boolean rebalanceRightShrunk() { [EOL]     switch(skew) { [EOL]         case RIGHT_HIGH: [EOL]             skew = Skew.BALANCED; [EOL]             return true; [EOL]         case LEFT_HIGH: [EOL]             if (left.skew == Skew.LEFT_HIGH) { [EOL]                 rotateCW(); [EOL]                 skew = Skew.BALANCED; [EOL]                 right.skew = Skew.BALANCED; [EOL]                 return true; [EOL]             } else if (left.skew == Skew.BALANCED) { [EOL]                 rotateCW(); [EOL]                 skew = Skew.RIGHT_HIGH; [EOL]                 right.skew = Skew.LEFT_HIGH; [EOL]                 return false; [EOL]             } else { [EOL]                 final Skew s = left.right.skew; [EOL]                 left.rotateCCW(); [EOL]                 rotateCW(); [EOL]                 switch(s) { [EOL]                     case LEFT_HIGH: [EOL]                         left.skew = Skew.BALANCED; [EOL]                         right.skew = Skew.RIGHT_HIGH; [EOL]                         break; [EOL]                     case RIGHT_HIGH: [EOL]                         left.skew = Skew.LEFT_HIGH; [EOL]                         right.skew = Skew.BALANCED; [EOL]                         break; [EOL]                     default: [EOL]                         left.skew = Skew.BALANCED; [EOL]                         right.skew = Skew.BALANCED; [EOL]                 } [EOL]                 skew = Skew.BALANCED; [EOL]                 return true; [EOL]             } [EOL]         default: [EOL]             skew = Skew.LEFT_HIGH; [EOL]             return false; [EOL]     } [EOL] } <line_num>: 538,578
private void rotateCW() { [EOL]     final T tmpElt = element; [EOL]     element = left.element; [EOL]     left.element = tmpElt; [EOL]     final Node tmpNode = left; [EOL]     left = tmpNode.left; [EOL]     tmpNode.left = tmpNode.right; [EOL]     tmpNode.right = right; [EOL]     right = tmpNode; [EOL]     if (left != null) { [EOL]         left.parent = this; [EOL]     } [EOL]     if (right.right != null) { [EOL]         right.right.parent = right; [EOL]     } [EOL] } <line_num>: 584,603
private void rotateCCW() { [EOL]     final T tmpElt = element; [EOL]     element = right.element; [EOL]     right.element = tmpElt; [EOL]     final Node tmpNode = right; [EOL]     right = tmpNode.right; [EOL]     tmpNode.right = tmpNode.left; [EOL]     tmpNode.left = left; [EOL]     left = tmpNode; [EOL]     if (right != null) { [EOL]         right.parent = this; [EOL]     } [EOL]     if (left.left != null) { [EOL]         left.left.parent = left; [EOL]     } [EOL] } <line_num>: 609,628
