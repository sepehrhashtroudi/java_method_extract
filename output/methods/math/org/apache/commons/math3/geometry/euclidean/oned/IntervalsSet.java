public IntervalsSet() { [EOL]     super(); [EOL] } <line_num>: 36,38
public IntervalsSet(final double lower, final double upper) { [EOL]     super(buildTree(lower, upper)); [EOL] } <line_num>: 46,48
public IntervalsSet(final BSPTree<Euclidean1D> tree) { [EOL]     super(tree); [EOL] } <line_num>: 59,61
public IntervalsSet(final Collection<SubHyperplane<Euclidean1D>> boundary) { [EOL]     super(boundary); [EOL] } <line_num>: 82,84
private static BSPTree<Euclidean1D> buildTree(final double lower, final double upper) { [EOL]     if (Double.isInfinite(lower) && (lower < 0)) { [EOL]         if (Double.isInfinite(upper) && (upper > 0)) { [EOL]             return new BSPTree<Euclidean1D>(Boolean.TRUE); [EOL]         } [EOL]         final SubHyperplane<Euclidean1D> upperCut = new OrientedPoint(new Vector1D(upper), true).wholeHyperplane(); [EOL]         return new BSPTree<Euclidean1D>(upperCut, new BSPTree<Euclidean1D>(Boolean.FALSE), new BSPTree<Euclidean1D>(Boolean.TRUE), null); [EOL]     } [EOL]     final SubHyperplane<Euclidean1D> lowerCut = new OrientedPoint(new Vector1D(lower), false).wholeHyperplane(); [EOL]     if (Double.isInfinite(upper) && (upper > 0)) { [EOL]         return new BSPTree<Euclidean1D>(lowerCut, new BSPTree<Euclidean1D>(Boolean.FALSE), new BSPTree<Euclidean1D>(Boolean.TRUE), null); [EOL]     } [EOL]     final SubHyperplane<Euclidean1D> upperCut = new OrientedPoint(new Vector1D(upper), true).wholeHyperplane(); [EOL]     return new BSPTree<Euclidean1D>(lowerCut, new BSPTree<Euclidean1D>(Boolean.FALSE), new BSPTree<Euclidean1D>(upperCut, new BSPTree<Euclidean1D>(Boolean.FALSE), new BSPTree<Euclidean1D>(Boolean.TRUE), null), null); [EOL] } <line_num>: 93,128
@Override [EOL] public IntervalsSet buildNew(final BSPTree<Euclidean1D> tree) { [EOL]     return new IntervalsSet(tree); [EOL] } <line_num>: 131,134
@Override [EOL] protected void computeGeometricalProperties() { [EOL]     if (getTree(false).getCut() == null) { [EOL]         setBarycenter(Vector1D.NaN); [EOL]         setSize(((Boolean) getTree(false).getAttribute()) ? Double.POSITIVE_INFINITY : 0); [EOL]     } else { [EOL]         double size = 0.0; [EOL]         double sum = 0.0; [EOL]         for (final Interval interval : asList()) { [EOL]             size += interval.getSize(); [EOL]             sum += interval.getSize() * interval.getBarycenter(); [EOL]         } [EOL]         setSize(size); [EOL]         if (Double.isInfinite(size)) { [EOL]             setBarycenter(Vector1D.NaN); [EOL]         } else if (size >= Precision.SAFE_MIN) { [EOL]             setBarycenter(new Vector1D(sum / size)); [EOL]         } else { [EOL]             setBarycenter(((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation()); [EOL]         } [EOL]     } [EOL] } <line_num>: 137,158
public double getInf() { [EOL]     BSPTree<Euclidean1D> node = getTree(false); [EOL]     double inf = Double.POSITIVE_INFINITY; [EOL]     while (node.getCut() != null) { [EOL]         final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane(); [EOL]         inf = op.getLocation().getX(); [EOL]         node = op.isDirect() ? node.getMinus() : node.getPlus(); [EOL]     } [EOL]     return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf; [EOL] } <line_num>: 166,175
public double getSup() { [EOL]     BSPTree<Euclidean1D> node = getTree(false); [EOL]     double sup = Double.NEGATIVE_INFINITY; [EOL]     while (node.getCut() != null) { [EOL]         final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane(); [EOL]         sup = op.getLocation().getX(); [EOL]         node = op.isDirect() ? node.getPlus() : node.getMinus(); [EOL]     } [EOL]     return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup; [EOL] } <line_num>: 183,192
public List<Interval> asList() { [EOL]     final List<Interval> list = new ArrayList<Interval>(); [EOL]     recurseList(getTree(false), list, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY); [EOL]     return list; [EOL] } <line_num>: 207,212
private void recurseList(final BSPTree<Euclidean1D> node, final List<Interval> list, final double lower, final double upper) { [EOL]     if (node.getCut() == null) { [EOL]         if ((Boolean) node.getAttribute()) { [EOL]             list.add(new Interval(lower, upper)); [EOL]         } [EOL]     } else { [EOL]         final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane(); [EOL]         final Vector1D loc = op.getLocation(); [EOL]         double x = loc.getX(); [EOL]         final BSPTree<Euclidean1D> low = op.isDirect() ? node.getMinus() : node.getPlus(); [EOL]         final BSPTree<Euclidean1D> high = op.isDirect() ? node.getPlus() : node.getMinus(); [EOL]         recurseList(low, list, lower, x); [EOL]         if ((checkPoint(low, loc) == Location.INSIDE) && (checkPoint(high, loc) == Location.INSIDE)) { [EOL]             x = list.remove(list.size() - 1).getInf(); [EOL]         } [EOL]         recurseList(high, list, x, upper); [EOL]     } [EOL] } <line_num>: 220,250
