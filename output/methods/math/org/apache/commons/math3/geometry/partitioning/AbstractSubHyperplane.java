protected AbstractSubHyperplane(final Hyperplane<S> hyperplane, final Region<T> remainingRegion) { [EOL]     this.hyperplane = hyperplane; [EOL]     this.remainingRegion = remainingRegion; [EOL] } <line_num>: 49,53
protected abstract AbstractSubHyperplane<S, T> buildNew(final Hyperplane<S> hyper, final Region<T> remaining); <line_num>: 60,61
public AbstractSubHyperplane<S, T> copySelf() { [EOL]     return buildNew(hyperplane, remainingRegion); [EOL] } <line_num>: 64,66
public Hyperplane<S> getHyperplane() { [EOL]     return hyperplane; [EOL] } <line_num>: 71,73
public Region<T> getRemainingRegion() { [EOL]     return remainingRegion; [EOL] } <line_num>: 82,84
public double getSize() { [EOL]     return remainingRegion.getSize(); [EOL] } <line_num>: 87,89
public AbstractSubHyperplane<S, T> reunite(final SubHyperplane<S> other) { [EOL]     @SuppressWarnings("unchecked") [EOL]     AbstractSubHyperplane<S, T> o = (AbstractSubHyperplane<S, T>) other; [EOL]     return buildNew(hyperplane, new RegionFactory<T>().union(remainingRegion, o.remainingRegion)); [EOL] } <line_num>: 92,97
public AbstractSubHyperplane<S, T> applyTransform(final Transform<S, T> transform) { [EOL]     final Hyperplane<S> tHyperplane = transform.apply(hyperplane); [EOL]     final BSPTree<T> tTree = recurseTransform(remainingRegion.getTree(false), tHyperplane, transform); [EOL]     return buildNew(tHyperplane, remainingRegion.buildNew(tTree)); [EOL] } <line_num>: 109,114
private BSPTree<T> recurseTransform(final BSPTree<T> node, final Hyperplane<S> transformed, final Transform<S, T> transform) { [EOL]     if (node.getCut() == null) { [EOL]         return new BSPTree<T>(node.getAttribute()); [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     BoundaryAttribute<T> attribute = (BoundaryAttribute<T>) node.getAttribute(); [EOL]     if (attribute != null) { [EOL]         final SubHyperplane<T> tPO = (attribute.getPlusOutside() == null) ? null : transform.apply(attribute.getPlusOutside(), hyperplane, transformed); [EOL]         final SubHyperplane<T> tPI = (attribute.getPlusInside() == null) ? null : transform.apply(attribute.getPlusInside(), hyperplane, transformed); [EOL]         attribute = new BoundaryAttribute<T>(tPO, tPI); [EOL]     } [EOL]     return new BSPTree<T>(transform.apply(node.getCut(), hyperplane, transformed), recurseTransform(node.getPlus(), transformed, transform), recurseTransform(node.getMinus(), transformed, transform), attribute); [EOL] } <line_num>: 122,145
public abstract Side side(Hyperplane<S> hyper); <line_num>: 148,148
public abstract SplitSubHyperplane<S> split(Hyperplane<S> hyper); <line_num>: 151,151
public boolean isEmpty() { [EOL]     return remainingRegion.isEmpty(); [EOL] } <line_num>: 154,156
