public OrderedTuple(final double... components) { [EOL]     this.components = components.clone(); [EOL]     int msb = Integer.MIN_VALUE; [EOL]     lsb = Integer.MAX_VALUE; [EOL]     posInf = false; [EOL]     negInf = false; [EOL]     nan = false; [EOL]     for (int i = 0; i < components.length; ++i) { [EOL]         if (Double.isInfinite(components[i])) { [EOL]             if (components[i] < 0) { [EOL]                 negInf = true; [EOL]             } else { [EOL]                 posInf = true; [EOL]             } [EOL]         } else if (Double.isNaN(components[i])) { [EOL]             nan = true; [EOL]         } else { [EOL]             final long b = Double.doubleToLongBits(components[i]); [EOL]             final long m = mantissa(b); [EOL]             if (m != 0) { [EOL]                 final int e = exponent(b); [EOL]                 msb = FastMath.max(msb, e + computeMSB(m)); [EOL]                 lsb = FastMath.min(lsb, e + computeLSB(m)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (posInf && negInf) { [EOL]         posInf = false; [EOL]         negInf = false; [EOL]         nan = true; [EOL]     } [EOL]     if (lsb <= msb) { [EOL]         encode(msb + 16); [EOL]     } else { [EOL]         encoding = new long[] { 0x0L }; [EOL]     } [EOL] } <line_num>: 132,175
private void encode(final int minOffset) { [EOL]     offset = minOffset + 31; [EOL]     offset -= offset % 32; [EOL]     if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) { [EOL]         return; [EOL]     } [EOL]     final int neededBits = offset + 1 - lsb; [EOL]     final int neededLongs = (neededBits + 62) / 63; [EOL]     encoding = new long[components.length * neededLongs]; [EOL]     int eIndex = 0; [EOL]     int shift = 62; [EOL]     long word = 0x0L; [EOL]     for (int k = offset; eIndex < encoding.length; --k) { [EOL]         for (int vIndex = 0; vIndex < components.length; ++vIndex) { [EOL]             if (getBit(vIndex, k) != 0) { [EOL]                 word |= 0x1L << shift; [EOL]             } [EOL]             if (shift-- == 0) { [EOL]                 encoding[eIndex++] = word; [EOL]                 word = 0x0L; [EOL]                 shift = 62; [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 181,215
public int compareTo(final OrderedTuple ot) { [EOL]     if (components.length == ot.components.length) { [EOL]         if (nan) { [EOL]             return +1; [EOL]         } else if (ot.nan) { [EOL]             return -1; [EOL]         } else if (negInf || ot.posInf) { [EOL]             return -1; [EOL]         } else if (posInf || ot.negInf) { [EOL]             return +1; [EOL]         } else { [EOL]             if (offset < ot.offset) { [EOL]                 encode(ot.offset); [EOL]             } else if (offset > ot.offset) { [EOL]                 ot.encode(offset); [EOL]             } [EOL]             final int limit = FastMath.min(encoding.length, ot.encoding.length); [EOL]             for (int i = 0; i < limit; ++i) { [EOL]                 if (encoding[i] < ot.encoding[i]) { [EOL]                     return -1; [EOL]                 } else if (encoding[i] > ot.encoding[i]) { [EOL]                     return +1; [EOL]                 } [EOL]             } [EOL]             if (encoding.length < ot.encoding.length) { [EOL]                 return -1; [EOL]             } else if (encoding.length > ot.encoding.length) { [EOL]                 return +1; [EOL]             } else { [EOL]                 return 0; [EOL]             } [EOL]         } [EOL]     } [EOL]     return components.length - ot.components.length; [EOL] } <line_num>: 247,287
@Override [EOL] public boolean equals(final Object other) { [EOL]     if (this == other) { [EOL]         return true; [EOL]     } else if (other instanceof OrderedTuple) { [EOL]         return compareTo((OrderedTuple) other) == 0; [EOL]     } else { [EOL]         return false; [EOL]     } [EOL] } <line_num>: 290,299
@Override [EOL] public int hashCode() { [EOL]     final int multiplier = 37; [EOL]     final int trueHash = 97; [EOL]     final int falseHash = 71; [EOL]     int hash = Arrays.hashCode(components); [EOL]     hash = hash * multiplier + offset; [EOL]     hash = hash * multiplier + lsb; [EOL]     hash = hash * multiplier + (posInf ? trueHash : falseHash); [EOL]     hash = hash * multiplier + (negInf ? trueHash : falseHash); [EOL]     hash = hash * multiplier + (nan ? trueHash : falseHash); [EOL]     return hash; [EOL] } <line_num>: 302,321
public double[] getComponents() { [EOL]     return components.clone(); [EOL] } <line_num>: 326,328
private static long sign(final long bits) { [EOL]     return bits & SIGN_MASK; [EOL] } <line_num>: 334,336
private static int exponent(final long bits) { [EOL]     return ((int) ((bits & EXPONENT_MASK) >> 52)) - 1075; [EOL] } <line_num>: 342,344
private static long mantissa(final long bits) { [EOL]     return ((bits & EXPONENT_MASK) == 0) ? ((bits & MANTISSA_MASK) << 1) : (IMPLICIT_ONE | (bits & MANTISSA_MASK)); [EOL] } <line_num>: 350,354
private static int computeMSB(final long l) { [EOL]     long ll = l; [EOL]     long mask = 0xffffffffL; [EOL]     int scale = 32; [EOL]     int msb = 0; [EOL]     while (scale != 0) { [EOL]         if ((ll & mask) != ll) { [EOL]             msb |= scale; [EOL]             ll = ll >> scale; [EOL]         } [EOL]         scale = scale >> 1; [EOL]         mask = mask >> scale; [EOL]     } [EOL]     return msb; [EOL] } <line_num>: 362,380
private static int computeLSB(final long l) { [EOL]     long ll = l; [EOL]     long mask = 0xffffffff00000000L; [EOL]     int scale = 32; [EOL]     int lsb = 0; [EOL]     while (scale != 0) { [EOL]         if ((ll & mask) == ll) { [EOL]             lsb |= scale; [EOL]             ll = ll >> scale; [EOL]         } [EOL]         scale = scale >> 1; [EOL]         mask = mask >> scale; [EOL]     } [EOL]     return lsb; [EOL] } <line_num>: 388,406
private int getBit(final int i, final int k) { [EOL]     final long bits = Double.doubleToLongBits(components[i]); [EOL]     final int e = exponent(bits); [EOL]     if ((k < e) || (k > offset)) { [EOL]         return 0; [EOL]     } else if (k == offset) { [EOL]         return (sign(bits) == 0L) ? 1 : 0; [EOL]     } else if (k > (e + 52)) { [EOL]         return (sign(bits) == 0L) ? 0 : 1; [EOL]     } else { [EOL]         final long m = (sign(bits) == 0L) ? mantissa(bits) : -mantissa(bits); [EOL]         return (int) ((m >> (k - e)) & 0x1L); [EOL]     } [EOL] } <line_num>: 414,427
