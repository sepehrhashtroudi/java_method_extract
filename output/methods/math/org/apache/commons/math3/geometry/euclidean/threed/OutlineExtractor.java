public OutlineExtractor(final Vector3D u, final Vector3D v) { [EOL]     this.u = u; [EOL]     this.v = v; [EOL]     w = Vector3D.crossProduct(u, v); [EOL] } <line_num>: 53,57
public BoundaryProjector() { [EOL]     projected = new PolygonsSet(new BSPTree<Euclidean2D>(Boolean.FALSE)); [EOL] } <line_num>: 129,131
public Vector2D[][] getOutline(final PolyhedronsSet polyhedronsSet) { [EOL]     final BoundaryProjector projector = new BoundaryProjector(); [EOL]     polyhedronsSet.getTree(true).visit(projector); [EOL]     final PolygonsSet projected = projector.getProjected(); [EOL]     final Vector2D[][] outline = projected.getVertices(); [EOL]     for (int i = 0; i < outline.length; ++i) { [EOL]         final Vector2D[] rawLoop = outline[i]; [EOL]         int end = rawLoop.length; [EOL]         int j = 0; [EOL]         while (j < end) { [EOL]             if (pointIsBetween(rawLoop, end, j)) { [EOL]                 for (int k = j; k < (end - 1); ++k) { [EOL]                     rawLoop[k] = rawLoop[k + 1]; [EOL]                 } [EOL]                 --end; [EOL]             } else { [EOL]                 ++j; [EOL]             } [EOL]         } [EOL]         if (end != rawLoop.length) { [EOL]             outline[i] = new Vector2D[end]; [EOL]             System.arraycopy(rawLoop, 0, outline[i], 0, end); [EOL]         } [EOL]     } [EOL]     return outline; [EOL] } <line_num>: 63,97
private boolean pointIsBetween(final Vector2D[] loop, final int n, final int i) { [EOL]     final Vector2D previous = loop[(i + n - 1) % n]; [EOL]     final Vector2D current = loop[i]; [EOL]     final Vector2D next = loop[(i + 1) % n]; [EOL]     final double dx1 = current.getX() - previous.getX(); [EOL]     final double dy1 = current.getY() - previous.getY(); [EOL]     final double dx2 = next.getX() - current.getX(); [EOL]     final double dy2 = next.getY() - current.getY(); [EOL]     final double cross = dx1 * dy2 - dx2 * dy1; [EOL]     final double dot = dx1 * dx2 + dy1 * dy2; [EOL]     final double d1d2 = FastMath.sqrt((dx1 * dx1 + dy1 * dy1) * (dx2 * dx2 + dy2 * dy2)); [EOL]     return (FastMath.abs(cross) <= (1.0e-6 * d1d2)) && (dot >= 0.0); [EOL] } <line_num>: 107,119
public Order visitOrder(final BSPTree<Euclidean3D> node) { [EOL]     return Order.MINUS_SUB_PLUS; [EOL] } <line_num>: 134,136
public void visitInternalNode(final BSPTree<Euclidean3D> node) { [EOL]     @SuppressWarnings("unchecked") [EOL]     final BoundaryAttribute<Euclidean3D> attribute = (BoundaryAttribute<Euclidean3D>) node.getAttribute(); [EOL]     if (attribute.getPlusOutside() != null) { [EOL]         addContribution(attribute.getPlusOutside(), false); [EOL]     } [EOL]     if (attribute.getPlusInside() != null) { [EOL]         addContribution(attribute.getPlusInside(), true); [EOL]     } [EOL] } <line_num>: 139,149
public void visitLeafNode(final BSPTree<Euclidean3D> node) { [EOL] } <line_num>: 152,153
private void addContribution(final SubHyperplane<Euclidean3D> facet, final boolean reversed) { [EOL]     @SuppressWarnings("unchecked") [EOL]     final AbstractSubHyperplane<Euclidean3D, Euclidean2D> absFacet = (AbstractSubHyperplane<Euclidean3D, Euclidean2D>) facet; [EOL]     final Plane plane = (Plane) facet.getHyperplane(); [EOL]     final double scal = plane.getNormal().dotProduct(w); [EOL]     if (FastMath.abs(scal) > 1.0e-3) { [EOL]         Vector2D[][] vertices = ((PolygonsSet) absFacet.getRemainingRegion()).getVertices(); [EOL]         if ((scal < 0) ^ reversed) { [EOL]             final Vector2D[][] newVertices = new Vector2D[vertices.length][]; [EOL]             for (int i = 0; i < vertices.length; ++i) { [EOL]                 final Vector2D[] loop = vertices[i]; [EOL]                 final Vector2D[] newLoop = new Vector2D[loop.length]; [EOL]                 if (loop[0] == null) { [EOL]                     newLoop[0] = null; [EOL]                     for (int j = 1; j < loop.length; ++j) { [EOL]                         newLoop[j] = loop[loop.length - j]; [EOL]                     } [EOL]                 } else { [EOL]                     for (int j = 0; j < loop.length; ++j) { [EOL]                         newLoop[j] = loop[loop.length - (j + 1)]; [EOL]                     } [EOL]                 } [EOL]                 newVertices[i] = newLoop; [EOL]             } [EOL]             vertices = newVertices; [EOL]         } [EOL]         final ArrayList<SubHyperplane<Euclidean2D>> edges = new ArrayList<SubHyperplane<Euclidean2D>>(); [EOL]         for (Vector2D[] loop : vertices) { [EOL]             final boolean closed = loop[0] != null; [EOL]             int previous = closed ? (loop.length - 1) : 1; [EOL]             Vector3D previous3D = plane.toSpace(loop[previous]); [EOL]             int current = (previous + 1) % loop.length; [EOL]             Vector2D pPoint = new Vector2D(previous3D.dotProduct(u), previous3D.dotProduct(v)); [EOL]             while (current < loop.length) { [EOL]                 final Vector3D current3D = plane.toSpace(loop[current]); [EOL]                 final Vector2D cPoint = new Vector2D(current3D.dotProduct(u), current3D.dotProduct(v)); [EOL]                 final org.apache.commons.math3.geometry.euclidean.twod.Line line = new org.apache.commons.math3.geometry.euclidean.twod.Line(pPoint, cPoint); [EOL]                 SubHyperplane<Euclidean2D> edge = line.wholeHyperplane(); [EOL]                 if (closed || (previous != 1)) { [EOL]                     final double angle = line.getAngle() + 0.5 * FastMath.PI; [EOL]                     final org.apache.commons.math3.geometry.euclidean.twod.Line l = new org.apache.commons.math3.geometry.euclidean.twod.Line(pPoint, angle); [EOL]                     edge = edge.split(l).getPlus(); [EOL]                 } [EOL]                 if (closed || (current != (loop.length - 1))) { [EOL]                     final double angle = line.getAngle() + 0.5 * FastMath.PI; [EOL]                     final org.apache.commons.math3.geometry.euclidean.twod.Line l = new org.apache.commons.math3.geometry.euclidean.twod.Line(cPoint, angle); [EOL]                     edge = edge.split(l).getMinus(); [EOL]                 } [EOL]                 edges.add(edge); [EOL]                 previous = current++; [EOL]                 previous3D = current3D; [EOL]                 pPoint = cPoint; [EOL]             } [EOL]         } [EOL]         final PolygonsSet projectedFacet = new PolygonsSet(edges); [EOL]         projected = (PolygonsSet) new RegionFactory<Euclidean2D>().union(projected, projectedFacet); [EOL]     } [EOL] } <line_num>: 159,247
public PolygonsSet getProjected() { [EOL]     return projected; [EOL] } <line_num>: 252,254
