public PolyhedronsSet() { [EOL]     super(); [EOL] } <line_num>: 46,48
public PolyhedronsSet(final BSPTree<Euclidean3D> tree) { [EOL]     super(tree); [EOL] } <line_num>: 59,61
public PolyhedronsSet(final Collection<SubHyperplane<Euclidean3D>> boundary) { [EOL]     super(boundary); [EOL] } <line_num>: 82,84
public PolyhedronsSet(final double xMin, final double xMax, final double yMin, final double yMax, final double zMin, final double zMax) { [EOL]     super(buildBoundary(xMin, xMax, yMin, yMax, zMin, zMax)); [EOL] } <line_num>: 94,98
public FacetsContributionVisitor() { [EOL]     setSize(0); [EOL]     setBarycenter(new Vector3D(0, 0, 0)); [EOL] } <line_num>: 154,157
public RotationTransform(final Vector3D center, final Rotation rotation) { [EOL]     this.center = center; [EOL]     this.rotation = rotation; [EOL] } <line_num>: 337,340
public TranslationTransform(final Vector3D translation) { [EOL]     this.translation = translation; [EOL] } <line_num>: 406,408
private static BSPTree<Euclidean3D> buildBoundary(final double xMin, final double xMax, final double yMin, final double yMax, final double zMin, final double zMax) { [EOL]     final Plane pxMin = new Plane(new Vector3D(xMin, 0, 0), Vector3D.MINUS_I); [EOL]     final Plane pxMax = new Plane(new Vector3D(xMax, 0, 0), Vector3D.PLUS_I); [EOL]     final Plane pyMin = new Plane(new Vector3D(0, yMin, 0), Vector3D.MINUS_J); [EOL]     final Plane pyMax = new Plane(new Vector3D(0, yMax, 0), Vector3D.PLUS_J); [EOL]     final Plane pzMin = new Plane(new Vector3D(0, 0, zMin), Vector3D.MINUS_K); [EOL]     final Plane pzMax = new Plane(new Vector3D(0, 0, zMax), Vector3D.PLUS_K); [EOL]     @SuppressWarnings("unchecked") [EOL]     final Region<Euclidean3D> boundary = new RegionFactory<Euclidean3D>().buildConvex(pxMin, pxMax, pyMin, pyMax, pzMin, pzMax); [EOL]     return boundary.getTree(false); [EOL] } <line_num>: 109,122
@Override [EOL] public PolyhedronsSet buildNew(final BSPTree<Euclidean3D> tree) { [EOL]     return new PolyhedronsSet(tree); [EOL] } <line_num>: 125,128
@Override [EOL] protected void computeGeometricalProperties() { [EOL]     getTree(true).visit(new FacetsContributionVisitor()); [EOL]     if (getSize() < 0) { [EOL]         setSize(Double.POSITIVE_INFINITY); [EOL]         setBarycenter(Vector3D.NaN); [EOL]     } else { [EOL]         setSize(getSize() / 3.0); [EOL]         setBarycenter(new Vector3D(1.0 / (4 * getSize()), (Vector3D) getBarycenter())); [EOL]     } [EOL] } <line_num>: 131,148
public Order visitOrder(final BSPTree<Euclidean3D> node) { [EOL]     return Order.MINUS_SUB_PLUS; [EOL] } <line_num>: 160,162
public void visitInternalNode(final BSPTree<Euclidean3D> node) { [EOL]     @SuppressWarnings("unchecked") [EOL]     final BoundaryAttribute<Euclidean3D> attribute = (BoundaryAttribute<Euclidean3D>) node.getAttribute(); [EOL]     if (attribute.getPlusOutside() != null) { [EOL]         addContribution(attribute.getPlusOutside(), false); [EOL]     } [EOL]     if (attribute.getPlusInside() != null) { [EOL]         addContribution(attribute.getPlusInside(), true); [EOL]     } [EOL] } <line_num>: 165,175
public void visitLeafNode(final BSPTree<Euclidean3D> node) { [EOL] } <line_num>: 178,179
private void addContribution(final SubHyperplane<Euclidean3D> facet, final boolean reversed) { [EOL]     final Region<Euclidean2D> polygon = ((SubPlane) facet).getRemainingRegion(); [EOL]     final double area = polygon.getSize(); [EOL]     if (Double.isInfinite(area)) { [EOL]         setSize(Double.POSITIVE_INFINITY); [EOL]         setBarycenter(Vector3D.NaN); [EOL]     } else { [EOL]         final Plane plane = (Plane) facet.getHyperplane(); [EOL]         final Vector3D facetB = plane.toSpace(polygon.getBarycenter()); [EOL]         double scaled = area * facetB.dotProduct(plane.getNormal()); [EOL]         if (reversed) { [EOL]             scaled = -scaled; [EOL]         } [EOL]         setSize(getSize() + scaled); [EOL]         setBarycenter(new Vector3D(1.0, (Vector3D) getBarycenter(), scaled, facetB)); [EOL]     } [EOL] } <line_num>: 185,207
public SubHyperplane<Euclidean3D> firstIntersection(final Vector3D point, final Line line) { [EOL]     return recurseFirstIntersection(getTree(true), point, line); [EOL] } <line_num>: 218,220
private SubHyperplane<Euclidean3D> recurseFirstIntersection(final BSPTree<Euclidean3D> node, final Vector3D point, final Line line) { [EOL]     final SubHyperplane<Euclidean3D> cut = node.getCut(); [EOL]     if (cut == null) { [EOL]         return null; [EOL]     } [EOL]     final BSPTree<Euclidean3D> minus = node.getMinus(); [EOL]     final BSPTree<Euclidean3D> plus = node.getPlus(); [EOL]     final Plane plane = (Plane) cut.getHyperplane(); [EOL]     final double offset = plane.getOffset(point); [EOL]     final boolean in = FastMath.abs(offset) < 1.0e-10; [EOL]     final BSPTree<Euclidean3D> near; [EOL]     final BSPTree<Euclidean3D> far; [EOL]     if (offset < 0) { [EOL]         near = minus; [EOL]         far = plus; [EOL]     } else { [EOL]         near = plus; [EOL]         far = minus; [EOL]     } [EOL]     if (in) { [EOL]         final SubHyperplane<Euclidean3D> facet = boundaryFacet(point, node); [EOL]         if (facet != null) { [EOL]             return facet; [EOL]         } [EOL]     } [EOL]     final SubHyperplane<Euclidean3D> crossed = recurseFirstIntersection(near, point, line); [EOL]     if (crossed != null) { [EOL]         return crossed; [EOL]     } [EOL]     if (!in) { [EOL]         final Vector3D hit3D = plane.intersection(line); [EOL]         if (hit3D != null) { [EOL]             final SubHyperplane<Euclidean3D> facet = boundaryFacet(hit3D, node); [EOL]             if (facet != null) { [EOL]                 return facet; [EOL]             } [EOL]         } [EOL]     } [EOL]     return recurseFirstIntersection(far, point, line); [EOL] } <line_num>: 230,283
private SubHyperplane<Euclidean3D> boundaryFacet(final Vector3D point, final BSPTree<Euclidean3D> node) { [EOL]     final Vector2D point2D = ((Plane) node.getCut().getHyperplane()).toSubSpace(point); [EOL]     @SuppressWarnings("unchecked") [EOL]     final BoundaryAttribute<Euclidean3D> attribute = (BoundaryAttribute<Euclidean3D>) node.getAttribute(); [EOL]     if ((attribute.getPlusOutside() != null) && (((SubPlane) attribute.getPlusOutside()).getRemainingRegion().checkPoint(point2D) == Location.INSIDE)) { [EOL]         return attribute.getPlusOutside(); [EOL]     } [EOL]     if ((attribute.getPlusInside() != null) && (((SubPlane) attribute.getPlusInside()).getRemainingRegion().checkPoint(point2D) == Location.INSIDE)) { [EOL]         return attribute.getPlusInside(); [EOL]     } [EOL]     return null; [EOL] } <line_num>: 291,306
public PolyhedronsSet rotate(final Vector3D center, final Rotation rotation) { [EOL]     return (PolyhedronsSet) applyTransform(new RotationTransform(center, rotation)); [EOL] } <line_num>: 314,316
public Vector3D apply(final Vector<Euclidean3D> point) { [EOL]     final Vector3D delta = ((Vector3D) point).subtract(center); [EOL]     return new Vector3D(1.0, center, 1.0, rotation.applyTo(delta)); [EOL] } <line_num>: 343,346
public Plane apply(final Hyperplane<Euclidean3D> hyperplane) { [EOL]     return ((Plane) hyperplane).rotate(center, rotation); [EOL] } <line_num>: 349,351
public SubHyperplane<Euclidean2D> apply(final SubHyperplane<Euclidean2D> sub, final Hyperplane<Euclidean3D> original, final Hyperplane<Euclidean3D> transformed) { [EOL]     if (original != cachedOriginal) { [EOL]         final Plane oPlane = (Plane) original; [EOL]         final Plane tPlane = (Plane) transformed; [EOL]         final Vector3D p00 = oPlane.getOrigin(); [EOL]         final Vector3D p10 = oPlane.toSpace(new Vector2D(1.0, 0.0)); [EOL]         final Vector3D p01 = oPlane.toSpace(new Vector2D(0.0, 1.0)); [EOL]         final Vector2D tP00 = tPlane.toSubSpace(apply(p00)); [EOL]         final Vector2D tP10 = tPlane.toSubSpace(apply(p10)); [EOL]         final Vector2D tP01 = tPlane.toSubSpace(apply(p01)); [EOL]         final AffineTransform at = new AffineTransform(tP10.getX() - tP00.getX(), tP10.getY() - tP00.getY(), tP01.getX() - tP00.getX(), tP01.getY() - tP00.getY(), tP00.getX(), tP00.getY()); [EOL]         cachedOriginal = (Plane) original; [EOL]         cachedTransform = org.apache.commons.math3.geometry.euclidean.twod.Line.getTransform(at); [EOL]     } [EOL]     return ((SubLine) sub).applyTransform(cachedTransform); [EOL] } <line_num>: 354,378
public PolyhedronsSet translate(final Vector3D translation) { [EOL]     return (PolyhedronsSet) applyTransform(new TranslationTransform(translation)); [EOL] } <line_num>: 387,389
public Vector3D apply(final Vector<Euclidean3D> point) { [EOL]     return new Vector3D(1.0, (Vector3D) point, 1.0, translation); [EOL] } <line_num>: 411,413
public Plane apply(final Hyperplane<Euclidean3D> hyperplane) { [EOL]     return ((Plane) hyperplane).translate(translation); [EOL] } <line_num>: 416,418
public SubHyperplane<Euclidean2D> apply(final SubHyperplane<Euclidean2D> sub, final Hyperplane<Euclidean3D> original, final Hyperplane<Euclidean3D> transformed) { [EOL]     if (original != cachedOriginal) { [EOL]         final Plane oPlane = (Plane) original; [EOL]         final Plane tPlane = (Plane) transformed; [EOL]         final Vector2D shift = tPlane.toSubSpace(apply(oPlane.getOrigin())); [EOL]         final AffineTransform at = AffineTransform.getTranslateInstance(shift.getX(), shift.getY()); [EOL]         cachedOriginal = (Plane) original; [EOL]         cachedTransform = org.apache.commons.math3.geometry.euclidean.twod.Line.getTransform(at); [EOL]     } [EOL]     return ((SubLine) sub).applyTransform(cachedTransform); [EOL] } <line_num>: 421,441
