public SphericalCoordinates(final Vector3D v) { [EOL]     this.v = v; [EOL]     this.r = v.getNorm(); [EOL]     this.theta = v.getAlpha(); [EOL]     this.phi = FastMath.acos(v.getZ() / r); [EOL] } <line_num>: 85,95
public SphericalCoordinates(final double r, final double theta, final double phi) { [EOL]     final double cosTheta = FastMath.cos(theta); [EOL]     final double sinTheta = FastMath.sin(theta); [EOL]     final double cosPhi = FastMath.cos(phi); [EOL]     final double sinPhi = FastMath.sin(phi); [EOL]     this.r = r; [EOL]     this.theta = theta; [EOL]     this.phi = phi; [EOL]     this.v = new Vector3D(r * cosTheta * sinPhi, r * sinTheta * sinPhi, r * cosPhi); [EOL] } <line_num>: 102,119
public DataTransferObject(final double x, final double y, final double z) { [EOL]     this.x = x; [EOL]     this.y = y; [EOL]     this.z = z; [EOL] } <line_num>: 381,385
public Vector3D getCartesian() { [EOL]     return v; [EOL] } <line_num>: 124,126
public double getR() { [EOL]     return r; [EOL] } <line_num>: 133,135
public double getTheta() { [EOL]     return theta; [EOL] } <line_num>: 142,144
public double getPhi() { [EOL]     return phi; [EOL] } <line_num>: 151,153
public double[] toCartesianGradient(final double[] sGradient) { [EOL]     computeJacobian(); [EOL]     return new double[] { sGradient[0] * jacobian[0][0] + sGradient[1] * jacobian[1][0] + sGradient[2] * jacobian[2][0], sGradient[0] * jacobian[0][1] + sGradient[1] * jacobian[1][1] + sGradient[2] * jacobian[2][1], sGradient[0] * jacobian[0][2] + sGradient[2] * jacobian[2][2] }; [EOL] } <line_num>: 162,175
public double[][] toCartesianHessian(final double[][] sHessian, final double[] sGradient) { [EOL]     computeJacobian(); [EOL]     computeHessians(); [EOL]     final double[][] hj = new double[3][3]; [EOL]     final double[][] cHessian = new double[3][3]; [EOL]     hj[0][0] = sHessian[0][0] * jacobian[0][0] + sHessian[1][0] * jacobian[1][0] + sHessian[2][0] * jacobian[2][0]; [EOL]     hj[0][1] = sHessian[0][0] * jacobian[0][1] + sHessian[1][0] * jacobian[1][1] + sHessian[2][0] * jacobian[2][1]; [EOL]     hj[0][2] = sHessian[0][0] * jacobian[0][2] + sHessian[2][0] * jacobian[2][2]; [EOL]     hj[1][0] = sHessian[1][0] * jacobian[0][0] + sHessian[1][1] * jacobian[1][0] + sHessian[2][1] * jacobian[2][0]; [EOL]     hj[1][1] = sHessian[1][0] * jacobian[0][1] + sHessian[1][1] * jacobian[1][1] + sHessian[2][1] * jacobian[2][1]; [EOL]     hj[2][0] = sHessian[2][0] * jacobian[0][0] + sHessian[2][1] * jacobian[1][0] + sHessian[2][2] * jacobian[2][0]; [EOL]     hj[2][1] = sHessian[2][0] * jacobian[0][1] + sHessian[2][1] * jacobian[1][1] + sHessian[2][2] * jacobian[2][1]; [EOL]     hj[2][2] = sHessian[2][0] * jacobian[0][2] + sHessian[2][2] * jacobian[2][2]; [EOL]     cHessian[0][0] = jacobian[0][0] * hj[0][0] + jacobian[1][0] * hj[1][0] + jacobian[2][0] * hj[2][0]; [EOL]     cHessian[1][0] = jacobian[0][1] * hj[0][0] + jacobian[1][1] * hj[1][0] + jacobian[2][1] * hj[2][0]; [EOL]     cHessian[2][0] = jacobian[0][2] * hj[0][0] + jacobian[2][2] * hj[2][0]; [EOL]     cHessian[1][1] = jacobian[0][1] * hj[0][1] + jacobian[1][1] * hj[1][1] + jacobian[2][1] * hj[2][1]; [EOL]     cHessian[2][1] = jacobian[0][2] * hj[0][1] + jacobian[2][2] * hj[2][1]; [EOL]     cHessian[2][2] = jacobian[0][2] * hj[0][2] + jacobian[2][2] * hj[2][2]; [EOL]     cHessian[0][0] += sGradient[0] * rHessian[0][0] + sGradient[1] * thetaHessian[0][0] + sGradient[2] * phiHessian[0][0]; [EOL]     cHessian[1][0] += sGradient[0] * rHessian[1][0] + sGradient[1] * thetaHessian[1][0] + sGradient[2] * phiHessian[1][0]; [EOL]     cHessian[2][0] += sGradient[0] * rHessian[2][0] + sGradient[2] * phiHessian[2][0]; [EOL]     cHessian[1][1] += sGradient[0] * rHessian[1][1] + sGradient[1] * thetaHessian[1][1] + sGradient[2] * phiHessian[1][1]; [EOL]     cHessian[2][1] += sGradient[0] * rHessian[2][1] + sGradient[2] * phiHessian[2][1]; [EOL]     cHessian[2][2] += sGradient[0] * rHessian[2][2] + sGradient[2] * phiHessian[2][2]; [EOL]     cHessian[0][1] = cHessian[1][0]; [EOL]     cHessian[0][2] = cHessian[2][0]; [EOL]     cHessian[1][2] = cHessian[2][1]; [EOL]     return cHessian; [EOL] } <line_num>: 195,241
private void computeJacobian() { [EOL]     if (jacobian == null) { [EOL]         final double x = v.getX(); [EOL]         final double y = v.getY(); [EOL]         final double z = v.getZ(); [EOL]         final double rho2 = x * x + y * y; [EOL]         final double rho = FastMath.sqrt(rho2); [EOL]         final double r2 = rho2 + z * z; [EOL]         jacobian = new double[3][3]; [EOL]         jacobian[0][0] = x / r; [EOL]         jacobian[0][1] = y / r; [EOL]         jacobian[0][2] = z / r; [EOL]         jacobian[1][0] = -y / rho2; [EOL]         jacobian[1][1] = x / rho2; [EOL]         jacobian[2][0] = x * z / (rho * r2); [EOL]         jacobian[2][1] = y * z / (rho * r2); [EOL]         jacobian[2][2] = -rho / r2; [EOL]     } [EOL] } <line_num>: 245,274
private void computeHessians() { [EOL]     if (rHessian == null) { [EOL]         final double x = v.getX(); [EOL]         final double y = v.getY(); [EOL]         final double z = v.getZ(); [EOL]         final double x2 = x * x; [EOL]         final double y2 = y * y; [EOL]         final double z2 = z * z; [EOL]         final double rho2 = x2 + y2; [EOL]         final double rho = FastMath.sqrt(rho2); [EOL]         final double r2 = rho2 + z2; [EOL]         final double xOr = x / r; [EOL]         final double yOr = y / r; [EOL]         final double zOr = z / r; [EOL]         final double xOrho2 = x / rho2; [EOL]         final double yOrho2 = y / rho2; [EOL]         final double xOr3 = xOr / r2; [EOL]         final double yOr3 = yOr / r2; [EOL]         final double zOr3 = zOr / r2; [EOL]         rHessian = new double[3][3]; [EOL]         rHessian[0][0] = y * yOr3 + z * zOr3; [EOL]         rHessian[1][0] = -x * yOr3; [EOL]         rHessian[2][0] = -z * xOr3; [EOL]         rHessian[1][1] = x * xOr3 + z * zOr3; [EOL]         rHessian[2][1] = -y * zOr3; [EOL]         rHessian[2][2] = x * xOr3 + y * yOr3; [EOL]         rHessian[0][1] = rHessian[1][0]; [EOL]         rHessian[0][2] = rHessian[2][0]; [EOL]         rHessian[1][2] = rHessian[2][1]; [EOL]         thetaHessian = new double[2][2]; [EOL]         thetaHessian[0][0] = 2 * xOrho2 * yOrho2; [EOL]         thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2; [EOL]         thetaHessian[1][1] = -2 * xOrho2 * yOrho2; [EOL]         thetaHessian[0][1] = thetaHessian[1][0]; [EOL]         final double rhor2 = rho * r2; [EOL]         final double rho2r2 = rho * rhor2; [EOL]         final double rhor4 = rhor2 * r2; [EOL]         final double rho3r4 = rhor4 * rho2; [EOL]         final double r2P2rho2 = 3 * rho2 + z2; [EOL]         phiHessian = new double[3][3]; [EOL]         phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4; [EOL]         phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4; [EOL]         phiHessian[2][0] = x * (rho2 - z2) / rhor4; [EOL]         phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4; [EOL]         phiHessian[2][1] = y * (rho2 - z2) / rhor4; [EOL]         phiHessian[2][2] = 2 * rho * zOr3 / r; [EOL]         phiHessian[0][1] = phiHessian[1][0]; [EOL]         phiHessian[0][2] = phiHessian[2][0]; [EOL]         phiHessian[1][2] = phiHessian[2][1]; [EOL]     } [EOL] } <line_num>: 278,345
private Object writeReplace() { [EOL]     return new DataTransferObject(v.getX(), v.getY(), v.getZ()); [EOL] } <line_num>: 351,353
private Object readResolve() { [EOL]     return new SphericalCoordinates(new Vector3D(x, y, z)); [EOL] } <line_num>: 390,392
