private SmallPrimes() { [EOL] } <line_num>: 74,75
public static int smallTrialDivision(int n, final List<Integer> factors) { [EOL]     for (int p : PRIMES) { [EOL]         while (0 == n % p) { [EOL]             n = n / p; [EOL]             factors.add(p); [EOL]         } [EOL]     } [EOL]     return n; [EOL] } <line_num>: 83,91
public static int boundedTrialDivision(int n, int maxFactor, List<Integer> factors) { [EOL]     int f = PRIMES_LAST + 2; [EOL]     while (f <= maxFactor) { [EOL]         if (0 == n % f) { [EOL]             n = n / f; [EOL]             factors.add(f); [EOL]             break; [EOL]         } [EOL]         f += 4; [EOL]         if (0 == n % f) { [EOL]             n = n / f; [EOL]             factors.add(f); [EOL]             break; [EOL]         } [EOL]         f += 2; [EOL]     } [EOL]     if (n != 1) { [EOL]         factors.add(n); [EOL]     } [EOL]     return n; [EOL] } <line_num>: 100,121
public static List<Integer> trialDivision(int n) { [EOL]     final List<Integer> factors = new ArrayList<Integer>(32); [EOL]     n = smallTrialDivision(n, factors); [EOL]     if (1 == n) { [EOL]         return factors; [EOL]     } [EOL]     final int bound = (int) FastMath.sqrt(n); [EOL]     boundedTrialDivision(n, bound, factors); [EOL]     return factors; [EOL] } <line_num>: 128,138
public static boolean millerRabinPrimeTest(final int n) { [EOL]     final int nMinus1 = n - 1; [EOL]     final int s = Integer.numberOfTrailingZeros(nMinus1); [EOL]     final int r = nMinus1 >> s; [EOL]     int t = 1; [EOL]     if (n >= 2047) { [EOL]         t = 2; [EOL]     } [EOL]     if (n >= 1373653) { [EOL]         t = 3; [EOL]     } [EOL]     if (n >= 25326001) { [EOL]         t = 4; [EOL]     } [EOL]     BigInteger br = BigInteger.valueOf(r); [EOL]     BigInteger bn = BigInteger.valueOf(n); [EOL]     for (int i = 0; i < t; i++) { [EOL]         BigInteger a = BigInteger.valueOf(SmallPrimes.PRIMES[i]); [EOL]         BigInteger bPow = a.modPow(br, bn); [EOL]         int y = bPow.intValue(); [EOL]         if ((1 != y) && (y != nMinus1)) { [EOL]             int j = 1; [EOL]             while ((j <= s - 1) && (nMinus1 != y)) { [EOL]                 long square = ((long) y) * y; [EOL]                 y = (int) (square % n); [EOL]                 if (1 == y) { [EOL]                     return false; [EOL]                 } [EOL]                 j++; [EOL]             } [EOL]             if (nMinus1 != y) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 149,187
