private PollardRho() { [EOL] } <line_num>: 34,35
public static List<Integer> primeFactors(int n) { [EOL]     final List<Integer> factors = new ArrayList<Integer>(); [EOL]     n = SmallPrimes.smallTrialDivision(n, factors); [EOL]     if (1 == n) { [EOL]         return factors; [EOL]     } [EOL]     if (SmallPrimes.millerRabinPrimeTest(n)) { [EOL]         factors.add(n); [EOL]         return factors; [EOL]     } [EOL]     int divisor = rhoBrent(n); [EOL]     factors.add(divisor); [EOL]     factors.add(n / divisor); [EOL]     return factors; [EOL] } <line_num>: 42,59
static int rhoBrent(final int n) { [EOL]     final int x0 = 2; [EOL]     final int m = 25; [EOL]     int cst = SmallPrimes.PRIMES_LAST; [EOL]     int y = x0; [EOL]     int r = 1; [EOL]     do { [EOL]         int x = y; [EOL]         for (int i = 0; i < r; i++) { [EOL]             final long y2 = ((long) y) * y; [EOL]             y = (int) ((y2 + cst) % n); [EOL]         } [EOL]         int k = 0; [EOL]         do { [EOL]             final int bound = FastMath.min(m, r - k); [EOL]             int q = 1; [EOL]             for (int i = -3; i < bound; i++) { [EOL]                 final long y2 = ((long) y) * y; [EOL]                 y = (int) ((y2 + cst) % n); [EOL]                 final long divisor = FastMath.abs(x - y); [EOL]                 if (0 == divisor) { [EOL]                     cst += SmallPrimes.PRIMES_LAST; [EOL]                     k = -m; [EOL]                     y = x0; [EOL]                     r = 1; [EOL]                     break; [EOL]                 } [EOL]                 final long prod = divisor * q; [EOL]                 q = (int) (prod % n); [EOL]                 if (0 == q) { [EOL]                     return gcdPositive(FastMath.abs((int) divisor), n); [EOL]                 } [EOL]             } [EOL]             final int out = gcdPositive(FastMath.abs(q), n); [EOL]             if (1 != out) { [EOL]                 return out; [EOL]             } [EOL]             k = k + m; [EOL]         } while (k < r); [EOL]         r = 2 * r; [EOL]     } while (true); [EOL] } <line_num>: 73,114
static int gcdPositive(int a, int b) { [EOL]     if (a == 0) { [EOL]         return b; [EOL]     } else if (b == 0) { [EOL]         return a; [EOL]     } [EOL]     final int aTwos = Integer.numberOfTrailingZeros(a); [EOL]     a >>= aTwos; [EOL]     final int bTwos = Integer.numberOfTrailingZeros(b); [EOL]     b >>= bTwos; [EOL]     final int shift = FastMath.min(aTwos, bTwos); [EOL]     while (a != b) { [EOL]         final int delta = a - b; [EOL]         b = FastMath.min(a, b); [EOL]         a = FastMath.abs(delta); [EOL]         a >>= Integer.numberOfTrailingZeros(a); [EOL]     } [EOL]     return a << shift; [EOL] } <line_num>: 133,164
