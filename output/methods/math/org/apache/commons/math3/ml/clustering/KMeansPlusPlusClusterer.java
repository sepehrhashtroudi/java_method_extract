public KMeansPlusPlusClusterer(final int k) { [EOL]     this(k, -1); [EOL] } <line_num>: 83,85
public KMeansPlusPlusClusterer(final int k, final int maxIterations) { [EOL]     this(k, maxIterations, new EuclideanDistance()); [EOL] } <line_num>: 98,100
public KMeansPlusPlusClusterer(final int k, final int maxIterations, final DistanceMeasure measure) { [EOL]     this(k, maxIterations, measure, new JDKRandomGenerator()); [EOL] } <line_num>: 112,114
public KMeansPlusPlusClusterer(final int k, final int maxIterations, final DistanceMeasure measure, final RandomGenerator random) { [EOL]     this(k, maxIterations, measure, random, EmptyClusterStrategy.LARGEST_VARIANCE); [EOL] } <line_num>: 127,131
public KMeansPlusPlusClusterer(final int k, final int maxIterations, final DistanceMeasure measure, final RandomGenerator random, final EmptyClusterStrategy emptyStrategy) { [EOL]     super(measure); [EOL]     this.k = k; [EOL]     this.maxIterations = maxIterations; [EOL]     this.random = random; [EOL]     this.emptyStrategy = emptyStrategy; [EOL] } <line_num>: 143,152
public int getK() { [EOL]     return k; [EOL] } <line_num>: 158,160
public int getMaxIterations() { [EOL]     return maxIterations; [EOL] } <line_num>: 166,168
public RandomGenerator getRandomGenerator() { [EOL]     return random; [EOL] } <line_num>: 174,176
public EmptyClusterStrategy getEmptyClusterStrategy() { [EOL]     return emptyStrategy; [EOL] } <line_num>: 182,184
@Override [EOL] public List<CentroidCluster<T>> cluster(final Collection<T> points) throws MathIllegalArgumentException, ConvergenceException { [EOL]     MathUtils.checkNotNull(points); [EOL]     if (points.size() < k) { [EOL]         throw new NumberIsTooSmallException(points.size(), k, false); [EOL]     } [EOL]     List<CentroidCluster<T>> clusters = chooseInitialCenters(points); [EOL]     int[] assignments = new int[points.size()]; [EOL]     assignPointsToClusters(clusters, points, assignments); [EOL]     final int max = (maxIterations < 0) ? Integer.MAX_VALUE : maxIterations; [EOL]     for (int count = 0; count < max; count++) { [EOL]         boolean emptyCluster = false; [EOL]         List<CentroidCluster<T>> newClusters = new ArrayList<CentroidCluster<T>>(); [EOL]         for (final CentroidCluster<T> cluster : clusters) { [EOL]             final Clusterable newCenter; [EOL]             if (cluster.getPoints().isEmpty()) { [EOL]                 switch(emptyStrategy) { [EOL]                     case LARGEST_VARIANCE: [EOL]                         newCenter = getPointFromLargestVarianceCluster(clusters); [EOL]                         break; [EOL]                     case LARGEST_POINTS_NUMBER: [EOL]                         newCenter = getPointFromLargestNumberCluster(clusters); [EOL]                         break; [EOL]                     case FARTHEST_POINT: [EOL]                         newCenter = getFarthestPoint(clusters); [EOL]                         break; [EOL]                     default: [EOL]                         throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS); [EOL]                 } [EOL]                 emptyCluster = true; [EOL]             } else { [EOL]                 newCenter = centroidOf(cluster.getPoints(), cluster.getCenter().getPoint().length); [EOL]             } [EOL]             newClusters.add(new CentroidCluster<T>(newCenter)); [EOL]         } [EOL]         int changes = assignPointsToClusters(newClusters, points, assignments); [EOL]         clusters = newClusters; [EOL]         if (changes == 0 && !emptyCluster) { [EOL]             return clusters; [EOL]         } [EOL]     } [EOL]     return clusters; [EOL] } <line_num>: 196,253
private int assignPointsToClusters(final List<CentroidCluster<T>> clusters, final Collection<T> points, final int[] assignments) { [EOL]     int assignedDifferently = 0; [EOL]     int pointIndex = 0; [EOL]     for (final T p : points) { [EOL]         int clusterIndex = getNearestCluster(clusters, p); [EOL]         if (clusterIndex != assignments[pointIndex]) { [EOL]             assignedDifferently++; [EOL]         } [EOL]         CentroidCluster<T> cluster = clusters.get(clusterIndex); [EOL]         cluster.addPoint(p); [EOL]         assignments[pointIndex++] = clusterIndex; [EOL]     } [EOL]     return assignedDifferently; [EOL] } <line_num>: 263,280
private List<CentroidCluster<T>> chooseInitialCenters(final Collection<T> points) { [EOL]     final List<T> pointList = Collections.unmodifiableList(new ArrayList<T>(points)); [EOL]     final int numPoints = pointList.size(); [EOL]     final boolean[] taken = new boolean[numPoints]; [EOL]     final List<CentroidCluster<T>> resultSet = new ArrayList<CentroidCluster<T>>(); [EOL]     final int firstPointIndex = random.nextInt(numPoints); [EOL]     final T firstPoint = pointList.get(firstPointIndex); [EOL]     resultSet.add(new CentroidCluster<T>(firstPoint)); [EOL]     taken[firstPointIndex] = true; [EOL]     final double[] minDistSquared = new double[numPoints]; [EOL]     for (int i = 0; i < numPoints; i++) { [EOL]         if (i != firstPointIndex) { [EOL]             double d = distance(firstPoint, pointList.get(i)); [EOL]             minDistSquared[i] = d * d; [EOL]         } [EOL]     } [EOL]     while (resultSet.size() < k) { [EOL]         double distSqSum = 0.0; [EOL]         for (int i = 0; i < numPoints; i++) { [EOL]             if (!taken[i]) { [EOL]                 distSqSum += minDistSquared[i]; [EOL]             } [EOL]         } [EOL]         final double r = random.nextDouble() * distSqSum; [EOL]         int nextPointIndex = -1; [EOL]         double sum = 0.0; [EOL]         for (int i = 0; i < numPoints; i++) { [EOL]             if (!taken[i]) { [EOL]                 sum += minDistSquared[i]; [EOL]                 if (sum >= r) { [EOL]                     nextPointIndex = i; [EOL]                     break; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (nextPointIndex == -1) { [EOL]             for (int i = numPoints - 1; i >= 0; i--) { [EOL]                 if (!taken[i]) { [EOL]                     nextPointIndex = i; [EOL]                     break; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (nextPointIndex >= 0) { [EOL]             final T p = pointList.get(nextPointIndex); [EOL]             resultSet.add(new CentroidCluster<T>(p)); [EOL]             taken[nextPointIndex] = true; [EOL]             if (resultSet.size() < k) { [EOL]                 for (int j = 0; j < numPoints; j++) { [EOL]                     if (!taken[j]) { [EOL]                         double d = distance(p, pointList.get(j)); [EOL]                         double d2 = d * d; [EOL]                         if (d2 < minDistSquared[j]) { [EOL]                             minDistSquared[j] = d2; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return resultSet; [EOL] } <line_num>: 288,405
private T getPointFromLargestVarianceCluster(final Collection<CentroidCluster<T>> clusters) throws ConvergenceException { [EOL]     double maxVariance = Double.NEGATIVE_INFINITY; [EOL]     Cluster<T> selected = null; [EOL]     for (final CentroidCluster<T> cluster : clusters) { [EOL]         if (!cluster.getPoints().isEmpty()) { [EOL]             final Clusterable center = cluster.getCenter(); [EOL]             final Variance stat = new Variance(); [EOL]             for (final T point : cluster.getPoints()) { [EOL]                 stat.increment(distance(point, center)); [EOL]             } [EOL]             final double variance = stat.getResult(); [EOL]             if (variance > maxVariance) { [EOL]                 maxVariance = variance; [EOL]                 selected = cluster; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (selected == null) { [EOL]         throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS); [EOL]     } [EOL]     final List<T> selectedPoints = selected.getPoints(); [EOL]     return selectedPoints.remove(random.nextInt(selectedPoints.size())); [EOL] } <line_num>: 414,448
private T getPointFromLargestNumberCluster(final Collection<? extends Cluster<T>> clusters) throws ConvergenceException { [EOL]     int maxNumber = 0; [EOL]     Cluster<T> selected = null; [EOL]     for (final Cluster<T> cluster : clusters) { [EOL]         final int number = cluster.getPoints().size(); [EOL]         if (number > maxNumber) { [EOL]             maxNumber = number; [EOL]             selected = cluster; [EOL]         } [EOL]     } [EOL]     if (selected == null) { [EOL]         throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS); [EOL]     } [EOL]     final List<T> selectedPoints = selected.getPoints(); [EOL]     return selectedPoints.remove(random.nextInt(selectedPoints.size())); [EOL] } <line_num>: 457,484
private T getFarthestPoint(final Collection<CentroidCluster<T>> clusters) throws ConvergenceException { [EOL]     double maxDistance = Double.NEGATIVE_INFINITY; [EOL]     Cluster<T> selectedCluster = null; [EOL]     int selectedPoint = -1; [EOL]     for (final CentroidCluster<T> cluster : clusters) { [EOL]         final Clusterable center = cluster.getCenter(); [EOL]         final List<T> points = cluster.getPoints(); [EOL]         for (int i = 0; i < points.size(); ++i) { [EOL]             final double distance = distance(points.get(i), center); [EOL]             if (distance > maxDistance) { [EOL]                 maxDistance = distance; [EOL]                 selectedCluster = cluster; [EOL]                 selectedPoint = i; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (selectedCluster == null) { [EOL]         throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS); [EOL]     } [EOL]     return selectedCluster.getPoints().remove(selectedPoint); [EOL] } <line_num>: 493,521
private int getNearestCluster(final Collection<CentroidCluster<T>> clusters, final T point) { [EOL]     double minDistance = Double.MAX_VALUE; [EOL]     int clusterIndex = 0; [EOL]     int minCluster = 0; [EOL]     for (final CentroidCluster<T> c : clusters) { [EOL]         final double distance = distance(point, c.getCenter()); [EOL]         if (distance < minDistance) { [EOL]             minDistance = distance; [EOL]             minCluster = clusterIndex; [EOL]         } [EOL]         clusterIndex++; [EOL]     } [EOL]     return minCluster; [EOL] } <line_num>: 530,543
private Clusterable centroidOf(final Collection<T> points, final int dimension) { [EOL]     final double[] centroid = new double[dimension]; [EOL]     for (final T p : points) { [EOL]         final double[] point = p.getPoint(); [EOL]         for (int i = 0; i < centroid.length; i++) { [EOL]             centroid[i] += point[i]; [EOL]         } [EOL]     } [EOL]     for (int i = 0; i < centroid.length; i++) { [EOL]         centroid[i] /= points.size(); [EOL]     } [EOL]     return new DoublePoint(centroid); [EOL] } <line_num>: 552,564
