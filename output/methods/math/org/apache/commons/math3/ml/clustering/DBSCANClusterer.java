public DBSCANClusterer(final double eps, final int minPts) throws NotPositiveException { [EOL]     this(eps, minPts, new EuclideanDistance()); [EOL] } <line_num>: 84,87
public DBSCANClusterer(final double eps, final int minPts, final DistanceMeasure measure) throws NotPositiveException { [EOL]     super(measure); [EOL]     if (eps < 0.0d) { [EOL]         throw new NotPositiveException(eps); [EOL]     } [EOL]     if (minPts < 0) { [EOL]         throw new NotPositiveException(minPts); [EOL]     } [EOL]     this.eps = eps; [EOL]     this.minPts = minPts; [EOL] } <line_num>: 97,109
public double getEps() { [EOL]     return eps; [EOL] } <line_num>: 115,117
public int getMinPts() { [EOL]     return minPts; [EOL] } <line_num>: 123,125
@Override [EOL] public List<Cluster<T>> cluster(final Collection<T> points) throws NullArgumentException { [EOL]     MathUtils.checkNotNull(points); [EOL]     final List<Cluster<T>> clusters = new ArrayList<Cluster<T>>(); [EOL]     final Map<Clusterable, PointStatus> visited = new HashMap<Clusterable, PointStatus>(); [EOL]     for (final T point : points) { [EOL]         if (visited.get(point) != null) { [EOL]             continue; [EOL]         } [EOL]         final List<T> neighbors = getNeighbors(point, points); [EOL]         if (neighbors.size() >= minPts) { [EOL]             final Cluster<T> cluster = new Cluster<T>(); [EOL]             clusters.add(expandCluster(cluster, point, neighbors, points, visited)); [EOL]         } else { [EOL]             visited.put(point, PointStatus.NOISE); [EOL]         } [EOL]     } [EOL]     return clusters; [EOL] } <line_num>: 134,158
private Cluster<T> expandCluster(final Cluster<T> cluster, final T point, final List<T> neighbors, final Collection<T> points, final Map<Clusterable, PointStatus> visited) { [EOL]     cluster.addPoint(point); [EOL]     visited.put(point, PointStatus.PART_OF_CLUSTER); [EOL]     List<T> seeds = new ArrayList<T>(neighbors); [EOL]     int index = 0; [EOL]     while (index < seeds.size()) { [EOL]         final T current = seeds.get(index); [EOL]         PointStatus pStatus = visited.get(current); [EOL]         if (pStatus == null) { [EOL]             final List<T> currentNeighbors = getNeighbors(current, points); [EOL]             if (currentNeighbors.size() >= minPts) { [EOL]                 seeds = merge(seeds, currentNeighbors); [EOL]             } [EOL]         } [EOL]         if (pStatus != PointStatus.PART_OF_CLUSTER) { [EOL]             visited.put(current, PointStatus.PART_OF_CLUSTER); [EOL]             cluster.addPoint(current); [EOL]         } [EOL]         index++; [EOL]     } [EOL]     return cluster; [EOL] } <line_num>: 170,199
private List<T> getNeighbors(final T point, final Collection<T> points) { [EOL]     final List<T> neighbors = new ArrayList<T>(); [EOL]     for (final T neighbor : points) { [EOL]         if (point != neighbor && distance(neighbor, point) <= eps) { [EOL]             neighbors.add(neighbor); [EOL]         } [EOL]     } [EOL]     return neighbors; [EOL] } <line_num>: 208,216
private List<T> merge(final List<T> one, final List<T> two) { [EOL]     final Set<T> oneSet = new HashSet<T>(one); [EOL]     for (T item : two) { [EOL]         if (!oneSet.contains(item)) { [EOL]             one.add(item); [EOL]         } [EOL]     } [EOL]     return one; [EOL] } <line_num>: 225,233
