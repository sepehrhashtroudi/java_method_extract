public HypergeometricDistribution(int populationSize, int numberOfSuccesses, int sampleSize) throws NotPositiveException, NotStrictlyPositiveException, NumberIsTooLargeException { [EOL]     this(new Well19937c(), populationSize, numberOfSuccesses, sampleSize); [EOL] } <line_num>: 61,64
public HypergeometricDistribution(RandomGenerator rng, int populationSize, int numberOfSuccesses, int sampleSize) throws NotPositiveException, NotStrictlyPositiveException, NumberIsTooLargeException { [EOL]     super(rng); [EOL]     if (populationSize <= 0) { [EOL]         throw new NotStrictlyPositiveException(LocalizedFormats.POPULATION_SIZE, populationSize); [EOL]     } [EOL]     if (numberOfSuccesses < 0) { [EOL]         throw new NotPositiveException(LocalizedFormats.NUMBER_OF_SUCCESSES, numberOfSuccesses); [EOL]     } [EOL]     if (sampleSize < 0) { [EOL]         throw new NotPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize); [EOL]     } [EOL]     if (numberOfSuccesses > populationSize) { [EOL]         throw new NumberIsTooLargeException(LocalizedFormats.NUMBER_OF_SUCCESS_LARGER_THAN_POPULATION_SIZE, numberOfSuccesses, populationSize, true); [EOL]     } [EOL]     if (sampleSize > populationSize) { [EOL]         throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_LARGER_THAN_POPULATION_SIZE, sampleSize, populationSize, true); [EOL]     } [EOL]     this.numberOfSuccesses = numberOfSuccesses; [EOL]     this.populationSize = populationSize; [EOL]     this.sampleSize = sampleSize; [EOL] } <line_num>: 79,111
public double cumulativeProbability(int x) { [EOL]     double ret; [EOL]     int[] domain = getDomain(populationSize, numberOfSuccesses, sampleSize); [EOL]     if (x < domain[0]) { [EOL]         ret = 0.0; [EOL]     } else if (x >= domain[1]) { [EOL]         ret = 1.0; [EOL]     } else { [EOL]         ret = innerCumulativeProbability(domain[0], x, 1); [EOL]     } [EOL]     return ret; [EOL] } <line_num>: 114,127
private int[] getDomain(int n, int m, int k) { [EOL]     return new int[] { getLowerDomain(n, m, k), getUpperDomain(m, k) }; [EOL] } <line_num>: 138,140
private int getLowerDomain(int n, int m, int k) { [EOL]     return FastMath.max(0, m - (n - k)); [EOL] } <line_num>: 151,153
public int getNumberOfSuccesses() { [EOL]     return numberOfSuccesses; [EOL] } <line_num>: 160,162
public int getPopulationSize() { [EOL]     return populationSize; [EOL] } <line_num>: 169,171
public int getSampleSize() { [EOL]     return sampleSize; [EOL] } <line_num>: 178,180
private int getUpperDomain(int m, int k) { [EOL]     return FastMath.min(k, m); [EOL] } <line_num>: 190,192
public double probability(int x) { [EOL]     double ret; [EOL]     int[] domain = getDomain(populationSize, numberOfSuccesses, sampleSize); [EOL]     if (x < domain[0] || x > domain[1]) { [EOL]         ret = 0.0; [EOL]     } else { [EOL]         double p = (double) sampleSize / (double) populationSize; [EOL]         double q = (double) (populationSize - sampleSize) / (double) populationSize; [EOL]         double p1 = SaddlePointExpansion.logBinomialProbability(x, numberOfSuccesses, p, q); [EOL]         double p2 = SaddlePointExpansion.logBinomialProbability(sampleSize - x, populationSize - numberOfSuccesses, p, q); [EOL]         double p3 = SaddlePointExpansion.logBinomialProbability(sampleSize, populationSize, p, q); [EOL]         ret = FastMath.exp(p1 + p2 - p3); [EOL]     } [EOL]     return ret; [EOL] } <line_num>: 195,215
public double upperCumulativeProbability(int x) { [EOL]     double ret; [EOL]     final int[] domain = getDomain(populationSize, numberOfSuccesses, sampleSize); [EOL]     if (x <= domain[0]) { [EOL]         ret = 1.0; [EOL]     } else if (x > domain[1]) { [EOL]         ret = 0.0; [EOL]     } else { [EOL]         ret = innerCumulativeProbability(domain[1], x, -1); [EOL]     } [EOL]     return ret; [EOL] } <line_num>: 224,237
private double innerCumulativeProbability(int x0, int x1, int dx) { [EOL]     double ret = probability(x0); [EOL]     while (x0 != x1) { [EOL]         x0 += dx; [EOL]         ret += probability(x0); [EOL]     } [EOL]     return ret; [EOL] } <line_num>: 252,259
public double getNumericalMean() { [EOL]     return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize()); [EOL] } <line_num>: 267,269
public double getNumericalVariance() { [EOL]     if (!numericalVarianceIsCalculated) { [EOL]         numericalVariance = calculateNumericalVariance(); [EOL]         numericalVarianceIsCalculated = true; [EOL]     } [EOL]     return numericalVariance; [EOL] } <line_num>: 278,284
protected double calculateNumericalVariance() { [EOL]     final double N = getPopulationSize(); [EOL]     final double m = getNumberOfSuccesses(); [EOL]     final double n = getSampleSize(); [EOL]     return (n * m * (N - n) * (N - m)) / (N * N * (N - 1)); [EOL] } <line_num>: 291,296
public int getSupportLowerBound() { [EOL]     return FastMath.max(0, getSampleSize() + getNumberOfSuccesses() - getPopulationSize()); [EOL] } <line_num>: 307,310
public int getSupportUpperBound() { [EOL]     return FastMath.min(getNumberOfSuccesses(), getSampleSize()); [EOL] } <line_num>: 320,322
public boolean isSupportConnected() { [EOL]     return true; [EOL] } <line_num>: 331,333
