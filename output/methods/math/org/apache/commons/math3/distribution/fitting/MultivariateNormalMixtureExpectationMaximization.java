public MultivariateNormalMixtureExpectationMaximization(double[][] data) throws NotStrictlyPositiveException, DimensionMismatchException, NumberIsTooSmallException { [EOL]     if (data.length < 1) { [EOL]         throw new NotStrictlyPositiveException(data.length); [EOL]     } [EOL]     this.data = new double[data.length][data[0].length]; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         if (data[i].length != data[0].length) { [EOL]             throw new DimensionMismatchException(data[i].length, data[0].length); [EOL]         } [EOL]         if (data[i].length < 2) { [EOL]             throw new NumberIsTooSmallException(LocalizedFormats.NUMBER_TOO_SMALL, data[i].length, 2, true); [EOL]         } [EOL]         this.data[i] = MathArrays.copyOf(data[i], data[i].length); [EOL]     } [EOL] } <line_num>: 85,107
DataRow(final double[] data) { [EOL]     row = data; [EOL]     mean = 0d; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         mean += data[i]; [EOL]     } [EOL]     mean /= data.length; [EOL] } <line_num>: 403,412
public void fit(final MixtureMultivariateNormalDistribution initialMixture, final int maxIterations, final double threshold) throws SingularMatrixException, NotStrictlyPositiveException, DimensionMismatchException { [EOL]     if (maxIterations < 1) { [EOL]         throw new NotStrictlyPositiveException(maxIterations); [EOL]     } [EOL]     if (threshold < Double.MIN_VALUE) { [EOL]         throw new NotStrictlyPositiveException(threshold); [EOL]     } [EOL]     final int n = data.length; [EOL]     final int numCols = data[0].length; [EOL]     final int k = initialMixture.getComponents().size(); [EOL]     final int numMeanColumns = initialMixture.getComponents().get(0).getSecond().getMeans().length; [EOL]     if (numMeanColumns != numCols) { [EOL]         throw new DimensionMismatchException(numMeanColumns, numCols); [EOL]     } [EOL]     int numIterations = 0; [EOL]     double previousLogLikelihood = 0d; [EOL]     logLikelihood = Double.NEGATIVE_INFINITY; [EOL]     fittedModel = new MixtureMultivariateNormalDistribution(initialMixture.getComponents()); [EOL]     while (numIterations++ <= maxIterations && Math.abs(previousLogLikelihood - logLikelihood) > threshold) { [EOL]         previousLogLikelihood = logLikelihood; [EOL]         double sumLogLikelihood = 0d; [EOL]         final List<Pair<Double, MultivariateNormalDistribution>> components = fittedModel.getComponents(); [EOL]         final double[] weights = new double[k]; [EOL]         final MultivariateNormalDistribution[] mvns = new MultivariateNormalDistribution[k]; [EOL]         for (int j = 0; j < k; j++) { [EOL]             weights[j] = components.get(j).getFirst(); [EOL]             mvns[j] = components.get(j).getSecond(); [EOL]         } [EOL]         final double[][] gamma = new double[n][k]; [EOL]         final double[] gammaSums = new double[k]; [EOL]         final double[][] gammaDataProdSums = new double[k][numCols]; [EOL]         for (int i = 0; i < n; i++) { [EOL]             final double rowDensity = fittedModel.density(data[i]); [EOL]             sumLogLikelihood += Math.log(rowDensity); [EOL]             for (int j = 0; j < k; j++) { [EOL]                 gamma[i][j] = weights[j] * mvns[j].density(data[i]) / rowDensity; [EOL]                 gammaSums[j] += gamma[i][j]; [EOL]                 for (int col = 0; col < numCols; col++) { [EOL]                     gammaDataProdSums[j][col] += gamma[i][j] * data[i][col]; [EOL]                 } [EOL]             } [EOL]         } [EOL]         logLikelihood = sumLogLikelihood / n; [EOL]         final double[] newWeights = new double[k]; [EOL]         final double[][] newMeans = new double[k][numCols]; [EOL]         for (int j = 0; j < k; j++) { [EOL]             newWeights[j] = gammaSums[j] / n; [EOL]             for (int col = 0; col < numCols; col++) { [EOL]                 newMeans[j][col] = gammaDataProdSums[j][col] / gammaSums[j]; [EOL]             } [EOL]         } [EOL]         final RealMatrix[] newCovMats = new RealMatrix[k]; [EOL]         for (int j = 0; j < k; j++) { [EOL]             newCovMats[j] = new Array2DRowRealMatrix(numCols, numCols); [EOL]         } [EOL]         for (int i = 0; i < n; i++) { [EOL]             for (int j = 0; j < k; j++) { [EOL]                 final RealMatrix vec = new Array2DRowRealMatrix(MathArrays.ebeSubtract(data[i], newMeans[j])); [EOL]                 final RealMatrix dataCov = vec.multiply(vec.transpose()).scalarMultiply(gamma[i][j]); [EOL]                 newCovMats[j] = newCovMats[j].add(dataCov); [EOL]             } [EOL]         } [EOL]         final double[][][] newCovMatArrays = new double[k][numCols][numCols]; [EOL]         for (int j = 0; j < k; j++) { [EOL]             newCovMats[j] = newCovMats[j].scalarMultiply(1d / gammaSums[j]); [EOL]             newCovMatArrays[j] = newCovMats[j].getData(); [EOL]         } [EOL]         fittedModel = new MixtureMultivariateNormalDistribution(newWeights, newMeans, newCovMatArrays); [EOL]     } [EOL]     if (Math.abs(previousLogLikelihood - logLikelihood) > threshold) { [EOL]         throw new ConvergenceException(); [EOL]     } [EOL] } <line_num>: 131,258
public void fit(MixtureMultivariateNormalDistribution initialMixture) throws SingularMatrixException, NotStrictlyPositiveException { [EOL]     fit(initialMixture, DEFAULT_MAX_ITERATIONS, DEFAULT_THRESHOLD); [EOL] } <line_num>: 277,281
public static MixtureMultivariateNormalDistribution estimate(final double[][] data, final int numComponents) throws NotStrictlyPositiveException, DimensionMismatchException { [EOL]     if (data.length < 2) { [EOL]         throw new NotStrictlyPositiveException(data.length); [EOL]     } [EOL]     if (numComponents < 2) { [EOL]         throw new NumberIsTooSmallException(numComponents, 2, true); [EOL]     } [EOL]     if (numComponents > data.length) { [EOL]         throw new NumberIsTooLargeException(numComponents, data.length, true); [EOL]     } [EOL]     final int numRows = data.length; [EOL]     final int numCols = data[0].length; [EOL]     final DataRow[] sortedData = new DataRow[numRows]; [EOL]     for (int i = 0; i < numRows; i++) { [EOL]         sortedData[i] = new DataRow(data[i]); [EOL]     } [EOL]     Arrays.sort(sortedData); [EOL]     final double weight = 1d / numComponents; [EOL]     final List<Pair<Double, MultivariateNormalDistribution>> components = new ArrayList<Pair<Double, MultivariateNormalDistribution>>(numComponents); [EOL]     for (int binIndex = 0; binIndex < numComponents; binIndex++) { [EOL]         final int minIndex = (binIndex * numRows) / numComponents; [EOL]         final int maxIndex = ((binIndex + 1) * numRows) / numComponents; [EOL]         final int numBinRows = maxIndex - minIndex; [EOL]         final double[][] binData = new double[numBinRows][numCols]; [EOL]         final double[] columnMeans = new double[numCols]; [EOL]         for (int i = minIndex, iBin = 0; i < maxIndex; i++, iBin++) { [EOL]             for (int j = 0; j < numCols; j++) { [EOL]                 final double val = sortedData[i].getRow()[j]; [EOL]                 columnMeans[j] += val; [EOL]                 binData[iBin][j] = val; [EOL]             } [EOL]         } [EOL]         MathArrays.scaleInPlace(1d / numBinRows, columnMeans); [EOL]         final double[][] covMat = new Covariance(binData).getCovarianceMatrix().getData(); [EOL]         final MultivariateNormalDistribution mvn = new MultivariateNormalDistribution(columnMeans, covMat); [EOL]         components.add(new Pair<Double, MultivariateNormalDistribution>(weight, mvn)); [EOL]     } [EOL]     return new MixtureMultivariateNormalDistribution(components); [EOL] } <line_num>: 301,370
public double getLogLikelihood() { [EOL]     return logLikelihood; [EOL] } <line_num>: 377,379
public MixtureMultivariateNormalDistribution getFittedModel() { [EOL]     return new MixtureMultivariateNormalDistribution(fittedModel.getComponents()); [EOL] } <line_num>: 386,388
public int compareTo(final DataRow other) { [EOL]     return mean.compareTo(other.mean); [EOL] } <line_num>: 419,421
@Override [EOL] public boolean equals(Object other) { [EOL]     if (this == other) { [EOL]         return true; [EOL]     } [EOL]     if (other instanceof DataRow) { [EOL]         return MathArrays.equals(row, ((DataRow) other).row); [EOL]     } [EOL]     return false; [EOL] } <line_num>: 424,437
@Override [EOL] public int hashCode() { [EOL]     return Arrays.hashCode(row); [EOL] } <line_num>: 440,443
public double[] getRow() { [EOL]     return row; [EOL] } <line_num>: 448,450
