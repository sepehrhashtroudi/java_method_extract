@Deprecated [EOL] protected AbstractIntegerDistribution() { [EOL]     random = null; [EOL] } <line_num>: 60,65
protected AbstractIntegerDistribution(RandomGenerator rng) { [EOL]     random = rng; [EOL] } <line_num>: 71,73
public double cumulativeProbability(int x0, int x1) throws NumberIsTooLargeException { [EOL]     if (x1 < x0) { [EOL]         throw new NumberIsTooLargeException(LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT, x0, x1, true); [EOL]     } [EOL]     return cumulativeProbability(x1) - cumulativeProbability(x0); [EOL] } <line_num>: 81,87
public int inverseCumulativeProbability(final double p) throws OutOfRangeException { [EOL]     if (p < 0.0 || p > 1.0) { [EOL]         throw new OutOfRangeException(p, 0, 1); [EOL]     } [EOL]     int lower = getSupportLowerBound(); [EOL]     if (p == 0.0) { [EOL]         return lower; [EOL]     } [EOL]     if (lower == Integer.MIN_VALUE) { [EOL]         if (checkedCumulativeProbability(lower) >= p) { [EOL]             return lower; [EOL]         } [EOL]     } else { [EOL]         lower -= 1; [EOL]     } [EOL]     int upper = getSupportUpperBound(); [EOL]     if (p == 1.0) { [EOL]         return upper; [EOL]     } [EOL]     final double mu = getNumericalMean(); [EOL]     final double sigma = FastMath.sqrt(getNumericalVariance()); [EOL]     final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) || Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0); [EOL]     if (chebyshevApplies) { [EOL]         double k = FastMath.sqrt((1.0 - p) / p); [EOL]         double tmp = mu - k * sigma; [EOL]         if (tmp > lower) { [EOL]             lower = ((int) Math.ceil(tmp)) - 1; [EOL]         } [EOL]         k = 1.0 / k; [EOL]         tmp = mu + k * sigma; [EOL]         if (tmp < upper) { [EOL]             upper = ((int) Math.ceil(tmp)) - 1; [EOL]         } [EOL]     } [EOL]     return solveInverseCumulativeProbability(p, lower, upper); [EOL] } <line_num>: 100,143
protected int solveInverseCumulativeProbability(final double p, int lower, int upper) { [EOL]     while (lower + 1 < upper) { [EOL]         int xm = (lower + upper) / 2; [EOL]         if (xm < lower || xm > upper) { [EOL]             xm = lower + (upper - lower) / 2; [EOL]         } [EOL]         double pm = checkedCumulativeProbability(xm); [EOL]         if (pm >= p) { [EOL]             upper = xm; [EOL]         } else { [EOL]             lower = xm; [EOL]         } [EOL]     } [EOL]     return upper; [EOL] } <line_num>: 157,177
public void reseedRandomGenerator(long seed) { [EOL]     random.setSeed(seed); [EOL]     randomData.reSeed(seed); [EOL] } <line_num>: 180,183
public int sample() { [EOL]     return inverseCumulativeProbability(random.nextDouble()); [EOL] } <line_num>: 192,194
public int[] sample(int sampleSize) { [EOL]     if (sampleSize <= 0) { [EOL]         throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize); [EOL]     } [EOL]     int[] out = new int[sampleSize]; [EOL]     for (int i = 0; i < sampleSize; i++) { [EOL]         out[i] = sample(); [EOL]     } [EOL]     return out; [EOL] } <line_num>: 202,212
private double checkedCumulativeProbability(int argument) throws MathInternalError { [EOL]     double result = Double.NaN; [EOL]     result = cumulativeProbability(argument); [EOL]     if (Double.isNaN(result)) { [EOL]         throw new MathInternalError(LocalizedFormats.DISCRETE_CUMULATIVE_PROBABILITY_RETURNED_NAN, argument); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 225,234
