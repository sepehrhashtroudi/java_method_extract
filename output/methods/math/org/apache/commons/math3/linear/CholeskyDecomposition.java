public CholeskyDecomposition(final RealMatrix matrix) { [EOL]     this(matrix, DEFAULT_RELATIVE_SYMMETRY_THRESHOLD, DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD); [EOL] } <line_num>: 84,87
public CholeskyDecomposition(final RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) { [EOL]     if (!matrix.isSquare()) { [EOL]         throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension()); [EOL]     } [EOL]     final int order = matrix.getRowDimension(); [EOL]     lTData = matrix.getData(); [EOL]     cachedL = null; [EOL]     cachedLT = null; [EOL]     for (int i = 0; i < order; ++i) { [EOL]         final double[] lI = lTData[i]; [EOL]         for (int j = i + 1; j < order; ++j) { [EOL]             final double[] lJ = lTData[j]; [EOL]             final double lIJ = lI[j]; [EOL]             final double lJI = lJ[i]; [EOL]             final double maxDelta = relativeSymmetryThreshold * FastMath.max(FastMath.abs(lIJ), FastMath.abs(lJI)); [EOL]             if (FastMath.abs(lIJ - lJI) > maxDelta) { [EOL]                 throw new NonSymmetricMatrixException(i, j, relativeSymmetryThreshold); [EOL]             } [EOL]             lJ[i] = 0; [EOL]         } [EOL]     } [EOL]     for (int i = 0; i < order; ++i) { [EOL]         final double[] ltI = lTData[i]; [EOL]         if (ltI[i] <= absolutePositivityThreshold) { [EOL]             throw new NonPositiveDefiniteMatrixException(ltI[i], i, absolutePositivityThreshold); [EOL]         } [EOL]         ltI[i] = FastMath.sqrt(ltI[i]); [EOL]         final double inverse = 1.0 / ltI[i]; [EOL]         for (int q = order - 1; q > i; --q) { [EOL]             ltI[q] *= inverse; [EOL]             final double[] ltQ = lTData[q]; [EOL]             for (int p = q; p < order; ++p) { [EOL]                 ltQ[p] -= ltI[q] * ltI[p]; [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 104,156
private Solver(final double[][] lTData) { [EOL]     this.lTData = lTData; [EOL] } <line_num>: 215,217
public RealMatrix getL() { [EOL]     if (cachedL == null) { [EOL]         cachedL = getLT().transpose(); [EOL]     } [EOL]     return cachedL; [EOL] } <line_num>: 163,168
public RealMatrix getLT() { [EOL]     if (cachedLT == null) { [EOL]         cachedLT = MatrixUtils.createRealMatrix(lTData); [EOL]     } [EOL]     return cachedLT; [EOL] } <line_num>: 175,183
public double getDeterminant() { [EOL]     double determinant = 1.0; [EOL]     for (int i = 0; i < lTData.length; ++i) { [EOL]         double lTii = lTData[i][i]; [EOL]         determinant *= lTii * lTii; [EOL]     } [EOL]     return determinant; [EOL] } <line_num>: 189,196
public DecompositionSolver getSolver() { [EOL]     return new Solver(lTData); [EOL] } <line_num>: 202,204
public boolean isNonSingular() { [EOL]     return true; [EOL] } <line_num>: 220,223
public RealVector solve(final RealVector b) { [EOL]     final int m = lTData.length; [EOL]     if (b.getDimension() != m) { [EOL]         throw new DimensionMismatchException(b.getDimension(), m); [EOL]     } [EOL]     final double[] x = b.toArray(); [EOL]     for (int j = 0; j < m; j++) { [EOL]         final double[] lJ = lTData[j]; [EOL]         x[j] /= lJ[j]; [EOL]         final double xJ = x[j]; [EOL]         for (int i = j + 1; i < m; i++) { [EOL]             x[i] -= xJ * lJ[i]; [EOL]         } [EOL]     } [EOL]     for (int j = m - 1; j >= 0; j--) { [EOL]         x[j] /= lTData[j][j]; [EOL]         final double xJ = x[j]; [EOL]         for (int i = 0; i < j; i++) { [EOL]             x[i] -= xJ * lTData[i][j]; [EOL]         } [EOL]     } [EOL]     return new ArrayRealVector(x, false); [EOL] } <line_num>: 226,254
public RealMatrix solve(RealMatrix b) { [EOL]     final int m = lTData.length; [EOL]     if (b.getRowDimension() != m) { [EOL]         throw new DimensionMismatchException(b.getRowDimension(), m); [EOL]     } [EOL]     final int nColB = b.getColumnDimension(); [EOL]     final double[][] x = b.getData(); [EOL]     for (int j = 0; j < m; j++) { [EOL]         final double[] lJ = lTData[j]; [EOL]         final double lJJ = lJ[j]; [EOL]         final double[] xJ = x[j]; [EOL]         for (int k = 0; k < nColB; ++k) { [EOL]             xJ[k] /= lJJ; [EOL]         } [EOL]         for (int i = j + 1; i < m; i++) { [EOL]             final double[] xI = x[i]; [EOL]             final double lJI = lJ[i]; [EOL]             for (int k = 0; k < nColB; ++k) { [EOL]                 xI[k] -= xJ[k] * lJI; [EOL]             } [EOL]         } [EOL]     } [EOL]     for (int j = m - 1; j >= 0; j--) { [EOL]         final double lJJ = lTData[j][j]; [EOL]         final double[] xJ = x[j]; [EOL]         for (int k = 0; k < nColB; ++k) { [EOL]             xJ[k] /= lJJ; [EOL]         } [EOL]         for (int i = 0; i < j; i++) { [EOL]             final double[] xI = x[i]; [EOL]             final double lIJ = lTData[i][j]; [EOL]             for (int k = 0; k < nColB; ++k) { [EOL]                 xI[k] -= xJ[k] * lIJ; [EOL]             } [EOL]         } [EOL]     } [EOL]     return new Array2DRowRealMatrix(x); [EOL] } <line_num>: 257,300
public RealMatrix getInverse() { [EOL]     return solve(MatrixUtils.createRealIdentityMatrix(lTData.length)); [EOL] } <line_num>: 303,305
