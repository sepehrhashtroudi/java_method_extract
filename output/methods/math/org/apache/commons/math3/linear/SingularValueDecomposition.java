public SingularValueDecomposition(final RealMatrix matrix) { [EOL]     final double[][] A; [EOL]     if (matrix.getRowDimension() < matrix.getColumnDimension()) { [EOL]         transposed = true; [EOL]         A = matrix.transpose().getData(); [EOL]         m = matrix.getColumnDimension(); [EOL]         n = matrix.getRowDimension(); [EOL]     } else { [EOL]         transposed = false; [EOL]         A = matrix.getData(); [EOL]         m = matrix.getRowDimension(); [EOL]         n = matrix.getColumnDimension(); [EOL]     } [EOL]     singularValues = new double[n]; [EOL]     final double[][] U = new double[m][n]; [EOL]     final double[][] V = new double[n][n]; [EOL]     final double[] e = new double[n]; [EOL]     final double[] work = new double[m]; [EOL]     final int nct = FastMath.min(m - 1, n); [EOL]     final int nrt = FastMath.max(0, n - 2); [EOL]     for (int k = 0; k < FastMath.max(nct, nrt); k++) { [EOL]         if (k < nct) { [EOL]             singularValues[k] = 0; [EOL]             for (int i = k; i < m; i++) { [EOL]                 singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]); [EOL]             } [EOL]             if (singularValues[k] != 0) { [EOL]                 if (A[k][k] < 0) { [EOL]                     singularValues[k] = -singularValues[k]; [EOL]                 } [EOL]                 for (int i = k; i < m; i++) { [EOL]                     A[i][k] /= singularValues[k]; [EOL]                 } [EOL]                 A[k][k] += 1; [EOL]             } [EOL]             singularValues[k] = -singularValues[k]; [EOL]         } [EOL]         for (int j = k + 1; j < n; j++) { [EOL]             if (k < nct && singularValues[k] != 0) { [EOL]                 double t = 0; [EOL]                 for (int i = k; i < m; i++) { [EOL]                     t += A[i][k] * A[i][j]; [EOL]                 } [EOL]                 t = -t / A[k][k]; [EOL]                 for (int i = k; i < m; i++) { [EOL]                     A[i][j] += t * A[i][k]; [EOL]                 } [EOL]             } [EOL]             e[j] = A[k][j]; [EOL]         } [EOL]         if (k < nct) { [EOL]             for (int i = k; i < m; i++) { [EOL]                 U[i][k] = A[i][k]; [EOL]             } [EOL]         } [EOL]         if (k < nrt) { [EOL]             e[k] = 0; [EOL]             for (int i = k + 1; i < n; i++) { [EOL]                 e[k] = FastMath.hypot(e[k], e[i]); [EOL]             } [EOL]             if (e[k] != 0) { [EOL]                 if (e[k + 1] < 0) { [EOL]                     e[k] = -e[k]; [EOL]                 } [EOL]                 for (int i = k + 1; i < n; i++) { [EOL]                     e[i] /= e[k]; [EOL]                 } [EOL]                 e[k + 1] += 1; [EOL]             } [EOL]             e[k] = -e[k]; [EOL]             if (k + 1 < m && e[k] != 0) { [EOL]                 for (int i = k + 1; i < m; i++) { [EOL]                     work[i] = 0; [EOL]                 } [EOL]                 for (int j = k + 1; j < n; j++) { [EOL]                     for (int i = k + 1; i < m; i++) { [EOL]                         work[i] += e[j] * A[i][j]; [EOL]                     } [EOL]                 } [EOL]                 for (int j = k + 1; j < n; j++) { [EOL]                     final double t = -e[j] / e[k + 1]; [EOL]                     for (int i = k + 1; i < m; i++) { [EOL]                         A[i][j] += t * work[i]; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             for (int i = k + 1; i < n; i++) { [EOL]                 V[i][k] = e[i]; [EOL]             } [EOL]         } [EOL]     } [EOL]     int p = n; [EOL]     if (nct < n) { [EOL]         singularValues[nct] = A[nct][nct]; [EOL]     } [EOL]     if (m < p) { [EOL]         singularValues[p - 1] = 0; [EOL]     } [EOL]     if (nrt + 1 < p) { [EOL]         e[nrt] = A[nrt][p - 1]; [EOL]     } [EOL]     e[p - 1] = 0; [EOL]     for (int j = nct; j < n; j++) { [EOL]         for (int i = 0; i < m; i++) { [EOL]             U[i][j] = 0; [EOL]         } [EOL]         U[j][j] = 1; [EOL]     } [EOL]     for (int k = nct - 1; k >= 0; k--) { [EOL]         if (singularValues[k] != 0) { [EOL]             for (int j = k + 1; j < n; j++) { [EOL]                 double t = 0; [EOL]                 for (int i = k; i < m; i++) { [EOL]                     t += U[i][k] * U[i][j]; [EOL]                 } [EOL]                 t = -t / U[k][k]; [EOL]                 for (int i = k; i < m; i++) { [EOL]                     U[i][j] += t * U[i][k]; [EOL]                 } [EOL]             } [EOL]             for (int i = k; i < m; i++) { [EOL]                 U[i][k] = -U[i][k]; [EOL]             } [EOL]             U[k][k] = 1 + U[k][k]; [EOL]             for (int i = 0; i < k - 1; i++) { [EOL]                 U[i][k] = 0; [EOL]             } [EOL]         } else { [EOL]             for (int i = 0; i < m; i++) { [EOL]                 U[i][k] = 0; [EOL]             } [EOL]             U[k][k] = 1; [EOL]         } [EOL]     } [EOL]     for (int k = n - 1; k >= 0; k--) { [EOL]         if (k < nrt && e[k] != 0) { [EOL]             for (int j = k + 1; j < n; j++) { [EOL]                 double t = 0; [EOL]                 for (int i = k + 1; i < n; i++) { [EOL]                     t += V[i][k] * V[i][j]; [EOL]                 } [EOL]                 t = -t / V[k + 1][k]; [EOL]                 for (int i = k + 1; i < n; i++) { [EOL]                     V[i][j] += t * V[i][k]; [EOL]                 } [EOL]             } [EOL]         } [EOL]         for (int i = 0; i < n; i++) { [EOL]             V[i][k] = 0; [EOL]         } [EOL]         V[k][k] = 1; [EOL]     } [EOL]     final int pp = p - 1; [EOL]     int iter = 0; [EOL]     while (p > 0) { [EOL]         int k; [EOL]         int kase; [EOL]         for (k = p - 2; k >= 0; k--) { [EOL]             final double threshold = TINY + EPS * (FastMath.abs(singularValues[k]) + FastMath.abs(singularValues[k + 1])); [EOL]             if (!(FastMath.abs(e[k]) > threshold)) { [EOL]                 e[k] = 0; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (k == p - 2) { [EOL]             kase = 4; [EOL]         } else { [EOL]             int ks; [EOL]             for (ks = p - 1; ks >= k; ks--) { [EOL]                 if (ks == k) { [EOL]                     break; [EOL]                 } [EOL]                 final double t = (ks != p ? FastMath.abs(e[ks]) : 0) + (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0); [EOL]                 if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) { [EOL]                     singularValues[ks] = 0; [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             if (ks == k) { [EOL]                 kase = 3; [EOL]             } else if (ks == p - 1) { [EOL]                 kase = 1; [EOL]             } else { [EOL]                 kase = 2; [EOL]                 k = ks; [EOL]             } [EOL]         } [EOL]         k++; [EOL]         switch(kase) { [EOL]             case 1: [EOL]                 { [EOL]                     double f = e[p - 2]; [EOL]                     e[p - 2] = 0; [EOL]                     for (int j = p - 2; j >= k; j--) { [EOL]                         double t = FastMath.hypot(singularValues[j], f); [EOL]                         final double cs = singularValues[j] / t; [EOL]                         final double sn = f / t; [EOL]                         singularValues[j] = t; [EOL]                         if (j != k) { [EOL]                             f = -sn * e[j - 1]; [EOL]                             e[j - 1] = cs * e[j - 1]; [EOL]                         } [EOL]                         for (int i = 0; i < n; i++) { [EOL]                             t = cs * V[i][j] + sn * V[i][p - 1]; [EOL]                             V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1]; [EOL]                             V[i][j] = t; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case 2: [EOL]                 { [EOL]                     double f = e[k - 1]; [EOL]                     e[k - 1] = 0; [EOL]                     for (int j = k; j < p; j++) { [EOL]                         double t = FastMath.hypot(singularValues[j], f); [EOL]                         final double cs = singularValues[j] / t; [EOL]                         final double sn = f / t; [EOL]                         singularValues[j] = t; [EOL]                         f = -sn * e[j]; [EOL]                         e[j] = cs * e[j]; [EOL]                         for (int i = 0; i < m; i++) { [EOL]                             t = cs * U[i][j] + sn * U[i][k - 1]; [EOL]                             U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1]; [EOL]                             U[i][j] = t; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case 3: [EOL]                 { [EOL]                     final double maxPm1Pm2 = FastMath.max(FastMath.abs(singularValues[p - 1]), FastMath.abs(singularValues[p - 2])); [EOL]                     final double scale = FastMath.max(FastMath.max(FastMath.max(maxPm1Pm2, FastMath.abs(e[p - 2])), FastMath.abs(singularValues[k])), FastMath.abs(e[k])); [EOL]                     final double sp = singularValues[p - 1] / scale; [EOL]                     final double spm1 = singularValues[p - 2] / scale; [EOL]                     final double epm1 = e[p - 2] / scale; [EOL]                     final double sk = singularValues[k] / scale; [EOL]                     final double ek = e[k] / scale; [EOL]                     final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0; [EOL]                     final double c = (sp * epm1) * (sp * epm1); [EOL]                     double shift = 0; [EOL]                     if (b != 0 || c != 0) { [EOL]                         shift = FastMath.sqrt(b * b + c); [EOL]                         if (b < 0) { [EOL]                             shift = -shift; [EOL]                         } [EOL]                         shift = c / (b + shift); [EOL]                     } [EOL]                     double f = (sk + sp) * (sk - sp) + shift; [EOL]                     double g = sk * ek; [EOL]                     for (int j = k; j < p - 1; j++) { [EOL]                         double t = FastMath.hypot(f, g); [EOL]                         double cs = f / t; [EOL]                         double sn = g / t; [EOL]                         if (j != k) { [EOL]                             e[j - 1] = t; [EOL]                         } [EOL]                         f = cs * singularValues[j] + sn * e[j]; [EOL]                         e[j] = cs * e[j] - sn * singularValues[j]; [EOL]                         g = sn * singularValues[j + 1]; [EOL]                         singularValues[j + 1] = cs * singularValues[j + 1]; [EOL]                         for (int i = 0; i < n; i++) { [EOL]                             t = cs * V[i][j] + sn * V[i][j + 1]; [EOL]                             V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1]; [EOL]                             V[i][j] = t; [EOL]                         } [EOL]                         t = FastMath.hypot(f, g); [EOL]                         cs = f / t; [EOL]                         sn = g / t; [EOL]                         singularValues[j] = t; [EOL]                         f = cs * e[j] + sn * singularValues[j + 1]; [EOL]                         singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1]; [EOL]                         g = sn * e[j + 1]; [EOL]                         e[j + 1] = cs * e[j + 1]; [EOL]                         if (j < m - 1) { [EOL]                             for (int i = 0; i < m; i++) { [EOL]                                 t = cs * U[i][j] + sn * U[i][j + 1]; [EOL]                                 U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1]; [EOL]                                 U[i][j] = t; [EOL]                             } [EOL]                         } [EOL]                     } [EOL]                     e[p - 2] = f; [EOL]                     iter = iter + 1; [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 { [EOL]                     if (singularValues[k] <= 0) { [EOL]                         singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0; [EOL]                         for (int i = 0; i <= pp; i++) { [EOL]                             V[i][k] = -V[i][k]; [EOL]                         } [EOL]                     } [EOL]                     while (k < pp) { [EOL]                         if (singularValues[k] >= singularValues[k + 1]) { [EOL]                             break; [EOL]                         } [EOL]                         double t = singularValues[k]; [EOL]                         singularValues[k] = singularValues[k + 1]; [EOL]                         singularValues[k + 1] = t; [EOL]                         if (k < n - 1) { [EOL]                             for (int i = 0; i < n; i++) { [EOL]                                 t = V[i][k + 1]; [EOL]                                 V[i][k + 1] = V[i][k]; [EOL]                                 V[i][k] = t; [EOL]                             } [EOL]                         } [EOL]                         if (k < m - 1) { [EOL]                             for (int i = 0; i < m; i++) { [EOL]                                 t = U[i][k + 1]; [EOL]                                 U[i][k + 1] = U[i][k]; [EOL]                                 U[i][k] = t; [EOL]                             } [EOL]                         } [EOL]                         k++; [EOL]                     } [EOL]                     iter = 0; [EOL]                     p--; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     tol = FastMath.max(m * singularValues[0] * EPS, FastMath.sqrt(Precision.SAFE_MIN)); [EOL]     if (!transposed) { [EOL]         cachedU = MatrixUtils.createRealMatrix(U); [EOL]         cachedV = MatrixUtils.createRealMatrix(V); [EOL]     } else { [EOL]         cachedU = MatrixUtils.createRealMatrix(V); [EOL]         cachedV = MatrixUtils.createRealMatrix(U); [EOL]     } [EOL] } <line_num>: 88,488
private Solver(final double[] singularValues, final RealMatrix uT, final RealMatrix v, final boolean nonSingular, final double tol) { [EOL]     final double[][] suT = uT.getData(); [EOL]     for (int i = 0; i < singularValues.length; ++i) { [EOL]         final double a; [EOL]         if (singularValues[i] > tol) { [EOL]             a = 1 / singularValues[i]; [EOL]         } else { [EOL]             a = 0; [EOL]         } [EOL]         final double[] suTi = suT[i]; [EOL]         for (int j = 0; j < suTi.length; ++j) { [EOL]             suTi[j] *= a; [EOL]         } [EOL]     } [EOL]     pseudoInverse = v.multiply(new Array2DRowRealMatrix(suT, false)); [EOL]     this.nonSingular = nonSingular; [EOL] } <line_num>: 676,693
public RealMatrix getU() { [EOL]     return cachedU; [EOL] } <line_num>: 496,500
public RealMatrix getUT() { [EOL]     if (cachedUt == null) { [EOL]         cachedUt = getU().transpose(); [EOL]     } [EOL]     return cachedUt; [EOL] } <line_num>: 508,514
public RealMatrix getS() { [EOL]     if (cachedS == null) { [EOL]         cachedS = MatrixUtils.createRealDiagonalMatrix(singularValues); [EOL]     } [EOL]     return cachedS; [EOL] } <line_num>: 522,528
public double[] getSingularValues() { [EOL]     return singularValues.clone(); [EOL] } <line_num>: 536,538
public RealMatrix getV() { [EOL]     return cachedV; [EOL] } <line_num>: 546,549
public RealMatrix getVT() { [EOL]     if (cachedVt == null) { [EOL]         cachedVt = getV().transpose(); [EOL]     } [EOL]     return cachedVt; [EOL] } <line_num>: 557,563
@Override [EOL] public void visit(final int row, final int column, final double value) { [EOL]     data[row][column] = value / singularValues[row]; [EOL] } <line_num>: 593,597
public RealMatrix getCovariance(final double minSingularValue) { [EOL]     final int p = singularValues.length; [EOL]     int dimension = 0; [EOL]     while (dimension < p && singularValues[dimension] >= minSingularValue) { [EOL]         ++dimension; [EOL]     } [EOL]     if (dimension == 0) { [EOL]         throw new NumberIsTooLargeException(LocalizedFormats.TOO_LARGE_CUTOFF_SINGULAR_VALUE, minSingularValue, singularValues[0], true); [EOL]     } [EOL]     final double[][] data = new double[dimension][p]; [EOL]     getVT().walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() { [EOL]  [EOL]         @Override [EOL]         public void visit(final int row, final int column, final double value) { [EOL]             data[row][column] = value / singularValues[row]; [EOL]         } [EOL]     }, 0, dimension - 1, 0, p - 1); [EOL]     RealMatrix jv = new Array2DRowRealMatrix(data, false); [EOL]     return jv.transpose().multiply(jv); [EOL] } <line_num>: 576,602
public double getNorm() { [EOL]     return singularValues[0]; [EOL] } <line_num>: 611,613
public double getConditionNumber() { [EOL]     return singularValues[0] / singularValues[n - 1]; [EOL] } <line_num>: 619,621
public double getInverseConditionNumber() { [EOL]     return singularValues[n - 1] / singularValues[0]; [EOL] } <line_num>: 630,632
public int getRank() { [EOL]     int r = 0; [EOL]     for (int i = 0; i < singularValues.length; i++) { [EOL]         if (singularValues[i] > tol) { [EOL]             r++; [EOL]         } [EOL]     } [EOL]     return r; [EOL] } <line_num>: 642,650
public DecompositionSolver getSolver() { [EOL]     return new Solver(singularValues, getUT(), getV(), getRank() == m, tol); [EOL] } <line_num>: 656,658
public RealVector solve(final RealVector b) { [EOL]     return pseudoInverse.operate(b); [EOL] } <line_num>: 706,708
public RealMatrix solve(final RealMatrix b) { [EOL]     return pseudoInverse.multiply(b); [EOL] } <line_num>: 722,724
public boolean isNonSingular() { [EOL]     return nonSingular; [EOL] } <line_num>: 731,733
public RealMatrix getInverse() { [EOL]     return pseudoInverse; [EOL] } <line_num>: 740,742
