public TriDiagonalTransformer(RealMatrix matrix) { [EOL]     if (!matrix.isSquare()) { [EOL]         throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension()); [EOL]     } [EOL]     final int m = matrix.getRowDimension(); [EOL]     householderVectors = matrix.getData(); [EOL]     main = new double[m]; [EOL]     secondary = new double[m - 1]; [EOL]     cachedQ = null; [EOL]     cachedQt = null; [EOL]     cachedT = null; [EOL]     transform(); [EOL] } <line_num>: 62,78
public RealMatrix getQ() { [EOL]     if (cachedQ == null) { [EOL]         cachedQ = getQT().transpose(); [EOL]     } [EOL]     return cachedQ; [EOL] } <line_num>: 85,90
public RealMatrix getQT() { [EOL]     if (cachedQt == null) { [EOL]         final int m = householderVectors.length; [EOL]         double[][] qta = new double[m][m]; [EOL]         for (int k = m - 1; k >= 1; --k) { [EOL]             final double[] hK = householderVectors[k - 1]; [EOL]             qta[k][k] = 1; [EOL]             if (hK[k] != 0.0) { [EOL]                 final double inv = 1.0 / (secondary[k - 1] * hK[k]); [EOL]                 double beta = 1.0 / secondary[k - 1]; [EOL]                 qta[k][k] = 1 + beta * hK[k]; [EOL]                 for (int i = k + 1; i < m; ++i) { [EOL]                     qta[k][i] = beta * hK[i]; [EOL]                 } [EOL]                 for (int j = k + 1; j < m; ++j) { [EOL]                     beta = 0; [EOL]                     for (int i = k + 1; i < m; ++i) { [EOL]                         beta += qta[j][i] * hK[i]; [EOL]                     } [EOL]                     beta *= inv; [EOL]                     qta[j][k] = beta * hK[k]; [EOL]                     for (int i = k + 1; i < m; ++i) { [EOL]                         qta[j][i] += beta * hK[i]; [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         qta[0][0] = 1; [EOL]         cachedQt = MatrixUtils.createRealMatrix(qta); [EOL]     } [EOL]     return cachedQt; [EOL] } <line_num>: 97,132
public RealMatrix getT() { [EOL]     if (cachedT == null) { [EOL]         final int m = main.length; [EOL]         double[][] ta = new double[m][m]; [EOL]         for (int i = 0; i < m; ++i) { [EOL]             ta[i][i] = main[i]; [EOL]             if (i > 0) { [EOL]                 ta[i][i - 1] = secondary[i - 1]; [EOL]             } [EOL]             if (i < main.length - 1) { [EOL]                 ta[i][i + 1] = secondary[i]; [EOL]             } [EOL]         } [EOL]         cachedT = MatrixUtils.createRealMatrix(ta); [EOL]     } [EOL]     return cachedT; [EOL] } <line_num>: 138,156
double[][] getHouseholderVectorsRef() { [EOL]     return householderVectors; [EOL] } <line_num>: 164,166
double[] getMainDiagonalRef() { [EOL]     return main; [EOL] } <line_num>: 174,176
double[] getSecondaryDiagonalRef() { [EOL]     return secondary; [EOL] } <line_num>: 184,186
private void transform() { [EOL]     final int m = householderVectors.length; [EOL]     final double[] z = new double[m]; [EOL]     for (int k = 0; k < m - 1; k++) { [EOL]         final double[] hK = householderVectors[k]; [EOL]         main[k] = hK[k]; [EOL]         double xNormSqr = 0; [EOL]         for (int j = k + 1; j < m; ++j) { [EOL]             final double c = hK[j]; [EOL]             xNormSqr += c * c; [EOL]         } [EOL]         final double a = (hK[k + 1] > 0) ? -FastMath.sqrt(xNormSqr) : FastMath.sqrt(xNormSqr); [EOL]         secondary[k] = a; [EOL]         if (a != 0.0) { [EOL]             hK[k + 1] -= a; [EOL]             final double beta = -1 / (a * hK[k + 1]); [EOL]             Arrays.fill(z, k + 1, m, 0); [EOL]             for (int i = k + 1; i < m; ++i) { [EOL]                 final double[] hI = householderVectors[i]; [EOL]                 final double hKI = hK[i]; [EOL]                 double zI = hI[i] * hKI; [EOL]                 for (int j = i + 1; j < m; ++j) { [EOL]                     final double hIJ = hI[j]; [EOL]                     zI += hIJ * hK[j]; [EOL]                     z[j] += hIJ * hKI; [EOL]                 } [EOL]                 z[i] = beta * (z[i] + zI); [EOL]             } [EOL]             double gamma = 0; [EOL]             for (int i = k + 1; i < m; ++i) { [EOL]                 gamma += z[i] * hK[i]; [EOL]             } [EOL]             gamma *= beta / 2; [EOL]             for (int i = k + 1; i < m; ++i) { [EOL]                 z[i] -= gamma * hK[i]; [EOL]             } [EOL]             for (int i = k + 1; i < m; ++i) { [EOL]                 final double[] hI = householderVectors[i]; [EOL]                 for (int j = i; j < m; ++j) { [EOL]                     hI[j] -= hK[i] * z[j] + z[i] * hK[j]; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     main[m - 1] = householderVectors[m - 1][m - 1]; [EOL] } <line_num>: 192,253
