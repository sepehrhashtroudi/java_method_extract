public BlockFieldMatrix(final Field<T> field, final int rows, final int columns) throws NotStrictlyPositiveException { [EOL]     super(field, rows, columns); [EOL]     this.rows = rows; [EOL]     this.columns = columns; [EOL]     blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE; [EOL]     blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE; [EOL]     blocks = createBlocksLayout(field, rows, columns); [EOL] } <line_num>: 100,113
public BlockFieldMatrix(final T[][] rawData) throws DimensionMismatchException { [EOL]     this(rawData.length, rawData[0].length, toBlocksLayout(rawData), false); [EOL] } <line_num>: 128,131
public BlockFieldMatrix(final int rows, final int columns, final T[][] blockData, final boolean copyArray) throws DimensionMismatchException, NotStrictlyPositiveException { [EOL]     super(extractField(blockData), rows, columns); [EOL]     this.rows = rows; [EOL]     this.columns = columns; [EOL]     blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE; [EOL]     blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE; [EOL]     if (copyArray) { [EOL]         blocks = MathArrays.buildArray(getField(), blockRows * blockColumns, -1); [EOL]     } else { [EOL]         blocks = blockData; [EOL]     } [EOL]     int index = 0; [EOL]     for (int iBlock = 0; iBlock < blockRows; ++iBlock) { [EOL]         final int iHeight = blockHeight(iBlock); [EOL]         for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) { [EOL]             if (blockData[index].length != iHeight * blockWidth(jBlock)) { [EOL]                 throw new DimensionMismatchException(blockData[index].length, iHeight * blockWidth(jBlock)); [EOL]             } [EOL]             if (copyArray) { [EOL]                 blocks[index] = blockData[index].clone(); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 150,182
public static <T extends FieldElement<T>> T[][] toBlocksLayout(final T[][] rawData) throws DimensionMismatchException { [EOL]     final int rows = rawData.length; [EOL]     final int columns = rawData[0].length; [EOL]     final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE; [EOL]     final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE; [EOL]     for (int i = 0; i < rawData.length; ++i) { [EOL]         final int length = rawData[i].length; [EOL]         if (length != columns) { [EOL]             throw new DimensionMismatchException(columns, length); [EOL]         } [EOL]     } [EOL]     final Field<T> field = extractField(rawData); [EOL]     final T[][] blocks = MathArrays.buildArray(field, blockRows * blockColumns, -1); [EOL]     int blockIndex = 0; [EOL]     for (int iBlock = 0; iBlock < blockRows; ++iBlock) { [EOL]         final int pStart = iBlock * BLOCK_SIZE; [EOL]         final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows); [EOL]         final int iHeight = pEnd - pStart; [EOL]         for (int jBlock = 0; jBlock < blockColumns; ++jBlock) { [EOL]             final int qStart = jBlock * BLOCK_SIZE; [EOL]             final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns); [EOL]             final int jWidth = qEnd - qStart; [EOL]             final T[] block = MathArrays.buildArray(field, iHeight * jWidth); [EOL]             blocks[blockIndex] = block; [EOL]             int index = 0; [EOL]             for (int p = pStart; p < pEnd; ++p) { [EOL]                 System.arraycopy(rawData[p], qStart, block, index, jWidth); [EOL]                 index += jWidth; [EOL]             } [EOL]             ++blockIndex; [EOL]         } [EOL]     } [EOL]     return blocks; [EOL] } <line_num>: 208,253
public static <T extends FieldElement<T>> T[][] createBlocksLayout(final Field<T> field, final int rows, final int columns) { [EOL]     final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE; [EOL]     final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE; [EOL]     final T[][] blocks = MathArrays.buildArray(field, blockRows * blockColumns, -1); [EOL]     int blockIndex = 0; [EOL]     for (int iBlock = 0; iBlock < blockRows; ++iBlock) { [EOL]         final int pStart = iBlock * BLOCK_SIZE; [EOL]         final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows); [EOL]         final int iHeight = pEnd - pStart; [EOL]         for (int jBlock = 0; jBlock < blockColumns; ++jBlock) { [EOL]             final int qStart = jBlock * BLOCK_SIZE; [EOL]             final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns); [EOL]             final int jWidth = qEnd - qStart; [EOL]             blocks[blockIndex] = MathArrays.buildArray(field, iHeight * jWidth); [EOL]             ++blockIndex; [EOL]         } [EOL]     } [EOL]     return blocks; [EOL] } <line_num>: 270,291
@Override [EOL] public FieldMatrix<T> createMatrix(final int rowDimension, final int columnDimension) throws NotStrictlyPositiveException { [EOL]     return new BlockFieldMatrix<T>(getField(), rowDimension, columnDimension); [EOL] } <line_num>: 294,300
@Override [EOL] public FieldMatrix<T> copy() { [EOL]     BlockFieldMatrix<T> copied = new BlockFieldMatrix<T>(getField(), rows, columns); [EOL]     for (int i = 0; i < blocks.length; ++i) { [EOL]         System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length); [EOL]     } [EOL]     return copied; [EOL] } <line_num>: 303,315
@Override [EOL] public FieldMatrix<T> add(final FieldMatrix<T> m) throws MatrixDimensionMismatchException { [EOL]     try { [EOL]         return add((BlockFieldMatrix<T>) m); [EOL]     } catch (ClassCastException cce) { [EOL]         checkAdditionCompatible(m); [EOL]         final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), rows, columns); [EOL]         int blockIndex = 0; [EOL]         for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) { [EOL]             for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) { [EOL]                 final T[] outBlock = out.blocks[blockIndex]; [EOL]                 final T[] tBlock = blocks[blockIndex]; [EOL]                 final int pStart = iBlock * BLOCK_SIZE; [EOL]                 final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows); [EOL]                 final int qStart = jBlock * BLOCK_SIZE; [EOL]                 final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns); [EOL]                 int k = 0; [EOL]                 for (int p = pStart; p < pEnd; ++p) { [EOL]                     for (int q = qStart; q < qEnd; ++q) { [EOL]                         outBlock[k] = tBlock[k].add(m.getEntry(p, q)); [EOL]                         ++k; [EOL]                     } [EOL]                 } [EOL]                 ++blockIndex; [EOL]             } [EOL]         } [EOL]         return out; [EOL]     } [EOL] } <line_num>: 318,358
public BlockFieldMatrix<T> add(final BlockFieldMatrix<T> m) throws MatrixDimensionMismatchException { [EOL]     checkAdditionCompatible(m); [EOL]     final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), rows, columns); [EOL]     for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) { [EOL]         final T[] outBlock = out.blocks[blockIndex]; [EOL]         final T[] tBlock = blocks[blockIndex]; [EOL]         final T[] mBlock = m.blocks[blockIndex]; [EOL]         for (int k = 0; k < outBlock.length; ++k) { [EOL]             outBlock[k] = tBlock[k].add(mBlock[k]); [EOL]         } [EOL]     } [EOL]     return out; [EOL] } <line_num>: 368,387
@Override [EOL] public FieldMatrix<T> subtract(final FieldMatrix<T> m) throws MatrixDimensionMismatchException { [EOL]     try { [EOL]         return subtract((BlockFieldMatrix<T>) m); [EOL]     } catch (ClassCastException cce) { [EOL]         checkSubtractionCompatible(m); [EOL]         final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), rows, columns); [EOL]         int blockIndex = 0; [EOL]         for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) { [EOL]             for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) { [EOL]                 final T[] outBlock = out.blocks[blockIndex]; [EOL]                 final T[] tBlock = blocks[blockIndex]; [EOL]                 final int pStart = iBlock * BLOCK_SIZE; [EOL]                 final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows); [EOL]                 final int qStart = jBlock * BLOCK_SIZE; [EOL]                 final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns); [EOL]                 int k = 0; [EOL]                 for (int p = pStart; p < pEnd; ++p) { [EOL]                     for (int q = qStart; q < qEnd; ++q) { [EOL]                         outBlock[k] = tBlock[k].subtract(m.getEntry(p, q)); [EOL]                         ++k; [EOL]                     } [EOL]                 } [EOL]                 ++blockIndex; [EOL]             } [EOL]         } [EOL]         return out; [EOL]     } [EOL] } <line_num>: 390,430
public BlockFieldMatrix<T> subtract(final BlockFieldMatrix<T> m) throws MatrixDimensionMismatchException { [EOL]     checkSubtractionCompatible(m); [EOL]     final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), rows, columns); [EOL]     for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) { [EOL]         final T[] outBlock = out.blocks[blockIndex]; [EOL]         final T[] tBlock = blocks[blockIndex]; [EOL]         final T[] mBlock = m.blocks[blockIndex]; [EOL]         for (int k = 0; k < outBlock.length; ++k) { [EOL]             outBlock[k] = tBlock[k].subtract(mBlock[k]); [EOL]         } [EOL]     } [EOL]     return out; [EOL] } <line_num>: 440,457
@Override [EOL] public FieldMatrix<T> scalarAdd(final T d) { [EOL]     final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), rows, columns); [EOL]     for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) { [EOL]         final T[] outBlock = out.blocks[blockIndex]; [EOL]         final T[] tBlock = blocks[blockIndex]; [EOL]         for (int k = 0; k < outBlock.length; ++k) { [EOL]             outBlock[k] = tBlock[k].add(d); [EOL]         } [EOL]     } [EOL]     return out; [EOL] } <line_num>: 460,474
@Override [EOL] public FieldMatrix<T> scalarMultiply(final T d) { [EOL]     final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), rows, columns); [EOL]     for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) { [EOL]         final T[] outBlock = out.blocks[blockIndex]; [EOL]         final T[] tBlock = blocks[blockIndex]; [EOL]         for (int k = 0; k < outBlock.length; ++k) { [EOL]             outBlock[k] = tBlock[k].multiply(d); [EOL]         } [EOL]     } [EOL]     return out; [EOL] } <line_num>: 477,492
@Override [EOL] public FieldMatrix<T> multiply(final FieldMatrix<T> m) throws DimensionMismatchException { [EOL]     try { [EOL]         return multiply((BlockFieldMatrix<T>) m); [EOL]     } catch (ClassCastException cce) { [EOL]         checkMultiplicationCompatible(m); [EOL]         final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), rows, m.getColumnDimension()); [EOL]         final T zero = getField().getZero(); [EOL]         int blockIndex = 0; [EOL]         for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) { [EOL]             final int pStart = iBlock * BLOCK_SIZE; [EOL]             final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows); [EOL]             for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) { [EOL]                 final int qStart = jBlock * BLOCK_SIZE; [EOL]                 final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension()); [EOL]                 final T[] outBlock = out.blocks[blockIndex]; [EOL]                 for (int kBlock = 0; kBlock < blockColumns; ++kBlock) { [EOL]                     final int kWidth = blockWidth(kBlock); [EOL]                     final T[] tBlock = blocks[iBlock * blockColumns + kBlock]; [EOL]                     final int rStart = kBlock * BLOCK_SIZE; [EOL]                     int k = 0; [EOL]                     for (int p = pStart; p < pEnd; ++p) { [EOL]                         final int lStart = (p - pStart) * kWidth; [EOL]                         final int lEnd = lStart + kWidth; [EOL]                         for (int q = qStart; q < qEnd; ++q) { [EOL]                             T sum = zero; [EOL]                             int r = rStart; [EOL]                             for (int l = lStart; l < lEnd; ++l) { [EOL]                                 sum = sum.add(tBlock[l].multiply(m.getEntry(r, q))); [EOL]                                 ++r; [EOL]                             } [EOL]                             outBlock[k] = outBlock[k].add(sum); [EOL]                             ++k; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]                 ++blockIndex; [EOL]             } [EOL]         } [EOL]         return out; [EOL]     } [EOL] } <line_num>: 495,553
public BlockFieldMatrix<T> multiply(BlockFieldMatrix<T> m) throws DimensionMismatchException { [EOL]     checkMultiplicationCompatible(m); [EOL]     final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), rows, m.columns); [EOL]     final T zero = getField().getZero(); [EOL]     int blockIndex = 0; [EOL]     for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) { [EOL]         final int pStart = iBlock * BLOCK_SIZE; [EOL]         final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows); [EOL]         for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) { [EOL]             final int jWidth = out.blockWidth(jBlock); [EOL]             final int jWidth2 = jWidth + jWidth; [EOL]             final int jWidth3 = jWidth2 + jWidth; [EOL]             final int jWidth4 = jWidth3 + jWidth; [EOL]             final T[] outBlock = out.blocks[blockIndex]; [EOL]             for (int kBlock = 0; kBlock < blockColumns; ++kBlock) { [EOL]                 final int kWidth = blockWidth(kBlock); [EOL]                 final T[] tBlock = blocks[iBlock * blockColumns + kBlock]; [EOL]                 final T[] mBlock = m.blocks[kBlock * m.blockColumns + jBlock]; [EOL]                 int k = 0; [EOL]                 for (int p = pStart; p < pEnd; ++p) { [EOL]                     final int lStart = (p - pStart) * kWidth; [EOL]                     final int lEnd = lStart + kWidth; [EOL]                     for (int nStart = 0; nStart < jWidth; ++nStart) { [EOL]                         T sum = zero; [EOL]                         int l = lStart; [EOL]                         int n = nStart; [EOL]                         while (l < lEnd - 3) { [EOL]                             sum = sum.add(tBlock[l].multiply(mBlock[n])).add(tBlock[l + 1].multiply(mBlock[n + jWidth])).add(tBlock[l + 2].multiply(mBlock[n + jWidth2])).add(tBlock[l + 3].multiply(mBlock[n + jWidth3])); [EOL]                             l += 4; [EOL]                             n += jWidth4; [EOL]                         } [EOL]                         while (l < lEnd) { [EOL]                             sum = sum.add(tBlock[l++].multiply(mBlock[n])); [EOL]                             n += jWidth; [EOL]                         } [EOL]                         outBlock[k] = outBlock[k].add(sum); [EOL]                         ++k; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             ++blockIndex; [EOL]         } [EOL]     } [EOL]     return out; [EOL] } <line_num>: 562,625
@Override [EOL] public T[][] getData() { [EOL]     final T[][] data = MathArrays.buildArray(getField(), getRowDimension(), getColumnDimension()); [EOL]     final int lastColumns = columns - (blockColumns - 1) * BLOCK_SIZE; [EOL]     for (int iBlock = 0; iBlock < blockRows; ++iBlock) { [EOL]         final int pStart = iBlock * BLOCK_SIZE; [EOL]         final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows); [EOL]         int regularPos = 0; [EOL]         int lastPos = 0; [EOL]         for (int p = pStart; p < pEnd; ++p) { [EOL]             final T[] dataP = data[p]; [EOL]             int blockIndex = iBlock * blockColumns; [EOL]             int dataPos = 0; [EOL]             for (int jBlock = 0; jBlock < blockColumns - 1; ++jBlock) { [EOL]                 System.arraycopy(blocks[blockIndex++], regularPos, dataP, dataPos, BLOCK_SIZE); [EOL]                 dataPos += BLOCK_SIZE; [EOL]             } [EOL]             System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns); [EOL]             regularPos += BLOCK_SIZE; [EOL]             lastPos += lastColumns; [EOL]         } [EOL]     } [EOL]     return data; [EOL] } <line_num>: 628,654
@Override [EOL] public FieldMatrix<T> getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws OutOfRangeException, NumberIsTooSmallException { [EOL]     checkSubMatrixIndex(startRow, endRow, startColumn, endColumn); [EOL]     final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), endRow - startRow + 1, endColumn - startColumn + 1); [EOL]     final int blockStartRow = startRow / BLOCK_SIZE; [EOL]     final int rowsShift = startRow % BLOCK_SIZE; [EOL]     final int blockStartColumn = startColumn / BLOCK_SIZE; [EOL]     final int columnsShift = startColumn % BLOCK_SIZE; [EOL]     int pBlock = blockStartRow; [EOL]     for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) { [EOL]         final int iHeight = out.blockHeight(iBlock); [EOL]         int qBlock = blockStartColumn; [EOL]         for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) { [EOL]             final int jWidth = out.blockWidth(jBlock); [EOL]             final int outIndex = iBlock * out.blockColumns + jBlock; [EOL]             final T[] outBlock = out.blocks[outIndex]; [EOL]             final int index = pBlock * blockColumns + qBlock; [EOL]             final int width = blockWidth(qBlock); [EOL]             final int heightExcess = iHeight + rowsShift - BLOCK_SIZE; [EOL]             final int widthExcess = jWidth + columnsShift - BLOCK_SIZE; [EOL]             if (heightExcess > 0) { [EOL]                 if (widthExcess > 0) { [EOL]                     final int width2 = blockWidth(qBlock + 1); [EOL]                     copyBlockPart(blocks[index], width, rowsShift, BLOCK_SIZE, columnsShift, BLOCK_SIZE, outBlock, jWidth, 0, 0); [EOL]                     copyBlockPart(blocks[index + 1], width2, rowsShift, BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, jWidth - widthExcess); [EOL]                     copyBlockPart(blocks[index + blockColumns], width, 0, heightExcess, columnsShift, BLOCK_SIZE, outBlock, jWidth, iHeight - heightExcess, 0); [EOL]                     copyBlockPart(blocks[index + blockColumns + 1], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess); [EOL]                 } else { [EOL]                     copyBlockPart(blocks[index], width, rowsShift, BLOCK_SIZE, columnsShift, jWidth + columnsShift, outBlock, jWidth, 0, 0); [EOL]                     copyBlockPart(blocks[index + blockColumns], width, 0, heightExcess, columnsShift, jWidth + columnsShift, outBlock, jWidth, iHeight - heightExcess, 0); [EOL]                 } [EOL]             } else { [EOL]                 if (widthExcess > 0) { [EOL]                     final int width2 = blockWidth(qBlock + 1); [EOL]                     copyBlockPart(blocks[index], width, rowsShift, iHeight + rowsShift, columnsShift, BLOCK_SIZE, outBlock, jWidth, 0, 0); [EOL]                     copyBlockPart(blocks[index + 1], width2, rowsShift, iHeight + rowsShift, 0, widthExcess, outBlock, jWidth, 0, jWidth - widthExcess); [EOL]                 } else { [EOL]                     copyBlockPart(blocks[index], width, rowsShift, iHeight + rowsShift, columnsShift, jWidth + columnsShift, outBlock, jWidth, 0, 0); [EOL]                 } [EOL]             } [EOL]             ++qBlock; [EOL]         } [EOL]         ++pBlock; [EOL]     } [EOL]     return out; [EOL] } <line_num>: 657,750
private void copyBlockPart(final T[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final T[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) { [EOL]     final int length = srcEndColumn - srcStartColumn; [EOL]     int srcPos = srcStartRow * srcWidth + srcStartColumn; [EOL]     int dstPos = dstStartRow * dstWidth + dstStartColumn; [EOL]     for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) { [EOL]         System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length); [EOL]         srcPos += srcWidth; [EOL]         dstPos += dstWidth; [EOL]     } [EOL] } <line_num>: 767,780
@Override [EOL] public void setSubMatrix(final T[][] subMatrix, final int row, final int column) throws DimensionMismatchException, OutOfRangeException, NoDataException, NullArgumentException { [EOL]     MathUtils.checkNotNull(subMatrix); [EOL]     final int refLength = subMatrix[0].length; [EOL]     if (refLength == 0) { [EOL]         throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN); [EOL]     } [EOL]     final int endRow = row + subMatrix.length - 1; [EOL]     final int endColumn = column + refLength - 1; [EOL]     checkSubMatrixIndex(row, endRow, column, endColumn); [EOL]     for (final T[] subRow : subMatrix) { [EOL]         if (subRow.length != refLength) { [EOL]             throw new DimensionMismatchException(refLength, subRow.length); [EOL]         } [EOL]     } [EOL]     final int blockStartRow = row / BLOCK_SIZE; [EOL]     final int blockEndRow = (endRow + BLOCK_SIZE) / BLOCK_SIZE; [EOL]     final int blockStartColumn = column / BLOCK_SIZE; [EOL]     final int blockEndColumn = (endColumn + BLOCK_SIZE) / BLOCK_SIZE; [EOL]     for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) { [EOL]         final int iHeight = blockHeight(iBlock); [EOL]         final int firstRow = iBlock * BLOCK_SIZE; [EOL]         final int iStart = FastMath.max(row, firstRow); [EOL]         final int iEnd = FastMath.min(endRow + 1, firstRow + iHeight); [EOL]         for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) { [EOL]             final int jWidth = blockWidth(jBlock); [EOL]             final int firstColumn = jBlock * BLOCK_SIZE; [EOL]             final int jStart = FastMath.max(column, firstColumn); [EOL]             final int jEnd = FastMath.min(endColumn + 1, firstColumn + jWidth); [EOL]             final int jLength = jEnd - jStart; [EOL]             final T[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]             for (int i = iStart; i < iEnd; ++i) { [EOL]                 System.arraycopy(subMatrix[i - row], jStart - column, block, (i - firstRow) * jWidth + (jStart - firstColumn), jLength); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 783,833
@Override [EOL] public FieldMatrix<T> getRowMatrix(final int row) throws OutOfRangeException { [EOL]     checkRowIndex(row); [EOL]     final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), 1, columns); [EOL]     final int iBlock = row / BLOCK_SIZE; [EOL]     final int iRow = row - iBlock * BLOCK_SIZE; [EOL]     int outBlockIndex = 0; [EOL]     int outIndex = 0; [EOL]     T[] outBlock = out.blocks[outBlockIndex]; [EOL]     for (int jBlock = 0; jBlock < blockColumns; ++jBlock) { [EOL]         final int jWidth = blockWidth(jBlock); [EOL]         final T[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]         final int available = outBlock.length - outIndex; [EOL]         if (jWidth > available) { [EOL]             System.arraycopy(block, iRow * jWidth, outBlock, outIndex, available); [EOL]             outBlock = out.blocks[++outBlockIndex]; [EOL]             System.arraycopy(block, iRow * jWidth, outBlock, 0, jWidth - available); [EOL]             outIndex = jWidth - available; [EOL]         } else { [EOL]             System.arraycopy(block, iRow * jWidth, outBlock, outIndex, jWidth); [EOL]             outIndex += jWidth; [EOL]         } [EOL]     } [EOL]     return out; [EOL] } <line_num>: 836,864
@Override [EOL] public void setRowMatrix(final int row, final FieldMatrix<T> matrix) throws MatrixDimensionMismatchException, OutOfRangeException { [EOL]     try { [EOL]         setRowMatrix(row, (BlockFieldMatrix<T>) matrix); [EOL]     } catch (ClassCastException cce) { [EOL]         super.setRowMatrix(row, matrix); [EOL]     } [EOL] } <line_num>: 867,875
public void setRowMatrix(final int row, final BlockFieldMatrix<T> matrix) throws MatrixDimensionMismatchException, OutOfRangeException { [EOL]     checkRowIndex(row); [EOL]     final int nCols = getColumnDimension(); [EOL]     if ((matrix.getRowDimension() != 1) || (matrix.getColumnDimension() != nCols)) { [EOL]         throw new MatrixDimensionMismatchException(matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols); [EOL]     } [EOL]     final int iBlock = row / BLOCK_SIZE; [EOL]     final int iRow = row - iBlock * BLOCK_SIZE; [EOL]     int mBlockIndex = 0; [EOL]     int mIndex = 0; [EOL]     T[] mBlock = matrix.blocks[mBlockIndex]; [EOL]     for (int jBlock = 0; jBlock < blockColumns; ++jBlock) { [EOL]         final int jWidth = blockWidth(jBlock); [EOL]         final T[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]         final int available = mBlock.length - mIndex; [EOL]         if (jWidth > available) { [EOL]             System.arraycopy(mBlock, mIndex, block, iRow * jWidth, available); [EOL]             mBlock = matrix.blocks[++mBlockIndex]; [EOL]             System.arraycopy(mBlock, 0, block, iRow * jWidth, jWidth - available); [EOL]             mIndex = jWidth - available; [EOL]         } else { [EOL]             System.arraycopy(mBlock, mIndex, block, iRow * jWidth, jWidth); [EOL]             mIndex += jWidth; [EOL]         } [EOL]     } [EOL] } <line_num>: 888,919
@Override [EOL] public FieldMatrix<T> getColumnMatrix(final int column) throws OutOfRangeException { [EOL]     checkColumnIndex(column); [EOL]     final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), rows, 1); [EOL]     final int jBlock = column / BLOCK_SIZE; [EOL]     final int jColumn = column - jBlock * BLOCK_SIZE; [EOL]     final int jWidth = blockWidth(jBlock); [EOL]     int outBlockIndex = 0; [EOL]     int outIndex = 0; [EOL]     T[] outBlock = out.blocks[outBlockIndex]; [EOL]     for (int iBlock = 0; iBlock < blockRows; ++iBlock) { [EOL]         final int iHeight = blockHeight(iBlock); [EOL]         final T[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]         for (int i = 0; i < iHeight; ++i) { [EOL]             if (outIndex >= outBlock.length) { [EOL]                 outBlock = out.blocks[++outBlockIndex]; [EOL]                 outIndex = 0; [EOL]             } [EOL]             outBlock[outIndex++] = block[i * jWidth + jColumn]; [EOL]         } [EOL]     } [EOL]     return out; [EOL] } <line_num>: 922,948
@Override [EOL] public void setColumnMatrix(final int column, final FieldMatrix<T> matrix) throws MatrixDimensionMismatchException, OutOfRangeException { [EOL]     try { [EOL]         setColumnMatrix(column, (BlockFieldMatrix<T>) matrix); [EOL]     } catch (ClassCastException cce) { [EOL]         super.setColumnMatrix(column, matrix); [EOL]     } [EOL] } <line_num>: 951,959
void setColumnMatrix(final int column, final BlockFieldMatrix<T> matrix) throws MatrixDimensionMismatchException, OutOfRangeException { [EOL]     checkColumnIndex(column); [EOL]     final int nRows = getRowDimension(); [EOL]     if ((matrix.getRowDimension() != nRows) || (matrix.getColumnDimension() != 1)) { [EOL]         throw new MatrixDimensionMismatchException(matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1); [EOL]     } [EOL]     final int jBlock = column / BLOCK_SIZE; [EOL]     final int jColumn = column - jBlock * BLOCK_SIZE; [EOL]     final int jWidth = blockWidth(jBlock); [EOL]     int mBlockIndex = 0; [EOL]     int mIndex = 0; [EOL]     T[] mBlock = matrix.blocks[mBlockIndex]; [EOL]     for (int iBlock = 0; iBlock < blockRows; ++iBlock) { [EOL]         final int iHeight = blockHeight(iBlock); [EOL]         final T[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]         for (int i = 0; i < iHeight; ++i) { [EOL]             if (mIndex >= mBlock.length) { [EOL]                 mBlock = matrix.blocks[++mBlockIndex]; [EOL]                 mIndex = 0; [EOL]             } [EOL]             block[i * jWidth + jColumn] = mBlock[mIndex++]; [EOL]         } [EOL]     } [EOL] } <line_num>: 972,1001
@Override [EOL] public FieldVector<T> getRowVector(final int row) throws OutOfRangeException { [EOL]     checkRowIndex(row); [EOL]     final T[] outData = MathArrays.buildArray(getField(), columns); [EOL]     final int iBlock = row / BLOCK_SIZE; [EOL]     final int iRow = row - iBlock * BLOCK_SIZE; [EOL]     int outIndex = 0; [EOL]     for (int jBlock = 0; jBlock < blockColumns; ++jBlock) { [EOL]         final int jWidth = blockWidth(jBlock); [EOL]         final T[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]         System.arraycopy(block, iRow * jWidth, outData, outIndex, jWidth); [EOL]         outIndex += jWidth; [EOL]     } [EOL]     return new ArrayFieldVector<T>(getField(), outData, false); [EOL] } <line_num>: 1004,1022
@Override [EOL] public void setRowVector(final int row, final FieldVector<T> vector) throws MatrixDimensionMismatchException, OutOfRangeException { [EOL]     try { [EOL]         setRow(row, ((ArrayFieldVector<T>) vector).getDataRef()); [EOL]     } catch (ClassCastException cce) { [EOL]         super.setRowVector(row, vector); [EOL]     } [EOL] } <line_num>: 1025,1033
@Override [EOL] public FieldVector<T> getColumnVector(final int column) throws OutOfRangeException { [EOL]     checkColumnIndex(column); [EOL]     final T[] outData = MathArrays.buildArray(getField(), rows); [EOL]     final int jBlock = column / BLOCK_SIZE; [EOL]     final int jColumn = column - jBlock * BLOCK_SIZE; [EOL]     final int jWidth = blockWidth(jBlock); [EOL]     int outIndex = 0; [EOL]     for (int iBlock = 0; iBlock < blockRows; ++iBlock) { [EOL]         final int iHeight = blockHeight(iBlock); [EOL]         final T[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]         for (int i = 0; i < iHeight; ++i) { [EOL]             outData[outIndex++] = block[i * jWidth + jColumn]; [EOL]         } [EOL]     } [EOL]     return new ArrayFieldVector<T>(getField(), outData, false); [EOL] } <line_num>: 1036,1056
@Override [EOL] public void setColumnVector(final int column, final FieldVector<T> vector) throws OutOfRangeException, MatrixDimensionMismatchException { [EOL]     try { [EOL]         setColumn(column, ((ArrayFieldVector<T>) vector).getDataRef()); [EOL]     } catch (ClassCastException cce) { [EOL]         super.setColumnVector(column, vector); [EOL]     } [EOL] } <line_num>: 1059,1067
@Override [EOL] public T[] getRow(final int row) throws OutOfRangeException { [EOL]     checkRowIndex(row); [EOL]     final T[] out = MathArrays.buildArray(getField(), columns); [EOL]     final int iBlock = row / BLOCK_SIZE; [EOL]     final int iRow = row - iBlock * BLOCK_SIZE; [EOL]     int outIndex = 0; [EOL]     for (int jBlock = 0; jBlock < blockColumns; ++jBlock) { [EOL]         final int jWidth = blockWidth(jBlock); [EOL]         final T[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]         System.arraycopy(block, iRow * jWidth, out, outIndex, jWidth); [EOL]         outIndex += jWidth; [EOL]     } [EOL]     return out; [EOL] } <line_num>: 1070,1087
@Override [EOL] public void setRow(final int row, final T[] array) throws OutOfRangeException, MatrixDimensionMismatchException { [EOL]     checkRowIndex(row); [EOL]     final int nCols = getColumnDimension(); [EOL]     if (array.length != nCols) { [EOL]         throw new MatrixDimensionMismatchException(1, array.length, 1, nCols); [EOL]     } [EOL]     final int iBlock = row / BLOCK_SIZE; [EOL]     final int iRow = row - iBlock * BLOCK_SIZE; [EOL]     int outIndex = 0; [EOL]     for (int jBlock = 0; jBlock < blockColumns; ++jBlock) { [EOL]         final int jWidth = blockWidth(jBlock); [EOL]         final T[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]         System.arraycopy(array, outIndex, block, iRow * jWidth, jWidth); [EOL]         outIndex += jWidth; [EOL]     } [EOL] } <line_num>: 1090,1109
@Override [EOL] public T[] getColumn(final int column) throws OutOfRangeException { [EOL]     checkColumnIndex(column); [EOL]     final T[] out = MathArrays.buildArray(getField(), rows); [EOL]     final int jBlock = column / BLOCK_SIZE; [EOL]     final int jColumn = column - jBlock * BLOCK_SIZE; [EOL]     final int jWidth = blockWidth(jBlock); [EOL]     int outIndex = 0; [EOL]     for (int iBlock = 0; iBlock < blockRows; ++iBlock) { [EOL]         final int iHeight = blockHeight(iBlock); [EOL]         final T[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]         for (int i = 0; i < iHeight; ++i) { [EOL]             out[outIndex++] = block[i * jWidth + jColumn]; [EOL]         } [EOL]     } [EOL]     return out; [EOL] } <line_num>: 1112,1131
@Override [EOL] public void setColumn(final int column, final T[] array) throws MatrixDimensionMismatchException, OutOfRangeException { [EOL]     checkColumnIndex(column); [EOL]     final int nRows = getRowDimension(); [EOL]     if (array.length != nRows) { [EOL]         throw new MatrixDimensionMismatchException(array.length, 1, nRows, 1); [EOL]     } [EOL]     final int jBlock = column / BLOCK_SIZE; [EOL]     final int jColumn = column - jBlock * BLOCK_SIZE; [EOL]     final int jWidth = blockWidth(jBlock); [EOL]     int outIndex = 0; [EOL]     for (int iBlock = 0; iBlock < blockRows; ++iBlock) { [EOL]         final int iHeight = blockHeight(iBlock); [EOL]         final T[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]         for (int i = 0; i < iHeight; ++i) { [EOL]             block[i * jWidth + jColumn] = array[outIndex++]; [EOL]         } [EOL]     } [EOL] } <line_num>: 1134,1155
@Override [EOL] public T getEntry(final int row, final int column) throws OutOfRangeException { [EOL]     checkRowIndex(row); [EOL]     checkColumnIndex(column); [EOL]     final int iBlock = row / BLOCK_SIZE; [EOL]     final int jBlock = column / BLOCK_SIZE; [EOL]     final int k = (row - iBlock * BLOCK_SIZE) * blockWidth(jBlock) + (column - jBlock * BLOCK_SIZE); [EOL]     return blocks[iBlock * blockColumns + jBlock][k]; [EOL] } <line_num>: 1158,1170
@Override [EOL] public void setEntry(final int row, final int column, final T value) throws OutOfRangeException { [EOL]     checkRowIndex(row); [EOL]     checkColumnIndex(column); [EOL]     final int iBlock = row / BLOCK_SIZE; [EOL]     final int jBlock = column / BLOCK_SIZE; [EOL]     final int k = (row - iBlock * BLOCK_SIZE) * blockWidth(jBlock) + (column - jBlock * BLOCK_SIZE); [EOL]     blocks[iBlock * blockColumns + jBlock][k] = value; [EOL] } <line_num>: 1173,1185
@Override [EOL] public void addToEntry(final int row, final int column, final T increment) throws OutOfRangeException { [EOL]     checkRowIndex(row); [EOL]     checkColumnIndex(column); [EOL]     final int iBlock = row / BLOCK_SIZE; [EOL]     final int jBlock = column / BLOCK_SIZE; [EOL]     final int k = (row - iBlock * BLOCK_SIZE) * blockWidth(jBlock) + (column - jBlock * BLOCK_SIZE); [EOL]     final T[] blockIJ = blocks[iBlock * blockColumns + jBlock]; [EOL]     blockIJ[k] = blockIJ[k].add(increment); [EOL] } <line_num>: 1188,1201
@Override [EOL] public void multiplyEntry(final int row, final int column, final T factor) throws OutOfRangeException { [EOL]     checkRowIndex(row); [EOL]     checkColumnIndex(column); [EOL]     final int iBlock = row / BLOCK_SIZE; [EOL]     final int jBlock = column / BLOCK_SIZE; [EOL]     final int k = (row - iBlock * BLOCK_SIZE) * blockWidth(jBlock) + (column - jBlock * BLOCK_SIZE); [EOL]     final T[] blockIJ = blocks[iBlock * blockColumns + jBlock]; [EOL]     blockIJ[k] = blockIJ[k].multiply(factor); [EOL] } <line_num>: 1204,1217
@Override [EOL] public FieldMatrix<T> transpose() { [EOL]     final int nRows = getRowDimension(); [EOL]     final int nCols = getColumnDimension(); [EOL]     final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows); [EOL]     int blockIndex = 0; [EOL]     for (int iBlock = 0; iBlock < blockColumns; ++iBlock) { [EOL]         for (int jBlock = 0; jBlock < blockRows; ++jBlock) { [EOL]             final T[] outBlock = out.blocks[blockIndex]; [EOL]             final T[] tBlock = blocks[jBlock * blockColumns + iBlock]; [EOL]             final int pStart = iBlock * BLOCK_SIZE; [EOL]             final int pEnd = FastMath.min(pStart + BLOCK_SIZE, columns); [EOL]             final int qStart = jBlock * BLOCK_SIZE; [EOL]             final int qEnd = FastMath.min(qStart + BLOCK_SIZE, rows); [EOL]             int k = 0; [EOL]             for (int p = pStart; p < pEnd; ++p) { [EOL]                 final int lInc = pEnd - pStart; [EOL]                 int l = p - pStart; [EOL]                 for (int q = qStart; q < qEnd; ++q) { [EOL]                     outBlock[k] = tBlock[l]; [EOL]                     ++k; [EOL]                     l += lInc; [EOL]                 } [EOL]             } [EOL]             ++blockIndex; [EOL]         } [EOL]     } [EOL]     return out; [EOL] } <line_num>: 1220,1256
@Override [EOL] public int getRowDimension() { [EOL]     return rows; [EOL] } <line_num>: 1259,1262
@Override [EOL] public int getColumnDimension() { [EOL]     return columns; [EOL] } <line_num>: 1265,1268
@Override [EOL] public T[] operate(final T[] v) throws DimensionMismatchException { [EOL]     if (v.length != columns) { [EOL]         throw new DimensionMismatchException(v.length, columns); [EOL]     } [EOL]     final T[] out = MathArrays.buildArray(getField(), rows); [EOL]     final T zero = getField().getZero(); [EOL]     for (int iBlock = 0; iBlock < blockRows; ++iBlock) { [EOL]         final int pStart = iBlock * BLOCK_SIZE; [EOL]         final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows); [EOL]         for (int jBlock = 0; jBlock < blockColumns; ++jBlock) { [EOL]             final T[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]             final int qStart = jBlock * BLOCK_SIZE; [EOL]             final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns); [EOL]             int k = 0; [EOL]             for (int p = pStart; p < pEnd; ++p) { [EOL]                 T sum = zero; [EOL]                 int q = qStart; [EOL]                 while (q < qEnd - 3) { [EOL]                     sum = sum.add(block[k].multiply(v[q])).add(block[k + 1].multiply(v[q + 1])).add(block[k + 2].multiply(v[q + 2])).add(block[k + 3].multiply(v[q + 3])); [EOL]                     k += 4; [EOL]                     q += 4; [EOL]                 } [EOL]                 while (q < qEnd) { [EOL]                     sum = sum.add(block[k++].multiply(v[q++])); [EOL]                 } [EOL]                 out[p] = out[p].add(sum); [EOL]             } [EOL]         } [EOL]     } [EOL]     return out; [EOL] } <line_num>: 1271,1309
@Override [EOL] public T[] preMultiply(final T[] v) throws DimensionMismatchException { [EOL]     if (v.length != rows) { [EOL]         throw new DimensionMismatchException(v.length, rows); [EOL]     } [EOL]     final T[] out = MathArrays.buildArray(getField(), columns); [EOL]     final T zero = getField().getZero(); [EOL]     for (int jBlock = 0; jBlock < blockColumns; ++jBlock) { [EOL]         final int jWidth = blockWidth(jBlock); [EOL]         final int jWidth2 = jWidth + jWidth; [EOL]         final int jWidth3 = jWidth2 + jWidth; [EOL]         final int jWidth4 = jWidth3 + jWidth; [EOL]         final int qStart = jBlock * BLOCK_SIZE; [EOL]         final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns); [EOL]         for (int iBlock = 0; iBlock < blockRows; ++iBlock) { [EOL]             final T[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]             final int pStart = iBlock * BLOCK_SIZE; [EOL]             final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows); [EOL]             for (int q = qStart; q < qEnd; ++q) { [EOL]                 int k = q - qStart; [EOL]                 T sum = zero; [EOL]                 int p = pStart; [EOL]                 while (p < pEnd - 3) { [EOL]                     sum = sum.add(block[k].multiply(v[p])).add(block[k + jWidth].multiply(v[p + 1])).add(block[k + jWidth2].multiply(v[p + 2])).add(block[k + jWidth3].multiply(v[p + 3])); [EOL]                     k += jWidth4; [EOL]                     p += 4; [EOL]                 } [EOL]                 while (p < pEnd) { [EOL]                     sum = sum.add(block[k].multiply(v[p++])); [EOL]                     k += jWidth; [EOL]                 } [EOL]                 out[q] = out[q].add(sum); [EOL]             } [EOL]         } [EOL]     } [EOL]     return out; [EOL] } <line_num>: 1312,1356
@Override [EOL] public T walkInRowOrder(final FieldMatrixChangingVisitor<T> visitor) { [EOL]     visitor.start(rows, columns, 0, rows - 1, 0, columns - 1); [EOL]     for (int iBlock = 0; iBlock < blockRows; ++iBlock) { [EOL]         final int pStart = iBlock * BLOCK_SIZE; [EOL]         final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows); [EOL]         for (int p = pStart; p < pEnd; ++p) { [EOL]             for (int jBlock = 0; jBlock < blockColumns; ++jBlock) { [EOL]                 final int jWidth = blockWidth(jBlock); [EOL]                 final int qStart = jBlock * BLOCK_SIZE; [EOL]                 final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns); [EOL]                 final T[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]                 int k = (p - pStart) * jWidth; [EOL]                 for (int q = qStart; q < qEnd; ++q) { [EOL]                     block[k] = visitor.visit(p, q, block[k]); [EOL]                     ++k; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 1359,1380
@Override [EOL] public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor) { [EOL]     visitor.start(rows, columns, 0, rows - 1, 0, columns - 1); [EOL]     for (int iBlock = 0; iBlock < blockRows; ++iBlock) { [EOL]         final int pStart = iBlock * BLOCK_SIZE; [EOL]         final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows); [EOL]         for (int p = pStart; p < pEnd; ++p) { [EOL]             for (int jBlock = 0; jBlock < blockColumns; ++jBlock) { [EOL]                 final int jWidth = blockWidth(jBlock); [EOL]                 final int qStart = jBlock * BLOCK_SIZE; [EOL]                 final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns); [EOL]                 final T[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]                 int k = (p - pStart) * jWidth; [EOL]                 for (int q = qStart; q < qEnd; ++q) { [EOL]                     visitor.visit(p, q, block[k]); [EOL]                     ++k; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 1383,1404
@Override [EOL] public T walkInRowOrder(final FieldMatrixChangingVisitor<T> visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws OutOfRangeException, NumberIsTooSmallException { [EOL]     checkSubMatrixIndex(startRow, endRow, startColumn, endColumn); [EOL]     visitor.start(rows, columns, startRow, endRow, startColumn, endColumn); [EOL]     for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) { [EOL]         final int p0 = iBlock * BLOCK_SIZE; [EOL]         final int pStart = FastMath.max(startRow, p0); [EOL]         final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow); [EOL]         for (int p = pStart; p < pEnd; ++p) { [EOL]             for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) { [EOL]                 final int jWidth = blockWidth(jBlock); [EOL]                 final int q0 = jBlock * BLOCK_SIZE; [EOL]                 final int qStart = FastMath.max(startColumn, q0); [EOL]                 final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn); [EOL]                 final T[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]                 int k = (p - p0) * jWidth + qStart - q0; [EOL]                 for (int q = qStart; q < qEnd; ++q) { [EOL]                     block[k] = visitor.visit(p, q, block[k]); [EOL]                     ++k; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 1407,1434
@Override [EOL] public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws OutOfRangeException, NumberIsTooSmallException { [EOL]     checkSubMatrixIndex(startRow, endRow, startColumn, endColumn); [EOL]     visitor.start(rows, columns, startRow, endRow, startColumn, endColumn); [EOL]     for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) { [EOL]         final int p0 = iBlock * BLOCK_SIZE; [EOL]         final int pStart = FastMath.max(startRow, p0); [EOL]         final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow); [EOL]         for (int p = pStart; p < pEnd; ++p) { [EOL]             for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) { [EOL]                 final int jWidth = blockWidth(jBlock); [EOL]                 final int q0 = jBlock * BLOCK_SIZE; [EOL]                 final int qStart = FastMath.max(startColumn, q0); [EOL]                 final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn); [EOL]                 final T[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]                 int k = (p - p0) * jWidth + qStart - q0; [EOL]                 for (int q = qStart; q < qEnd; ++q) { [EOL]                     visitor.visit(p, q, block[k]); [EOL]                     ++k; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 1437,1464
@Override [EOL] public T walkInOptimizedOrder(final FieldMatrixChangingVisitor<T> visitor) { [EOL]     visitor.start(rows, columns, 0, rows - 1, 0, columns - 1); [EOL]     int blockIndex = 0; [EOL]     for (int iBlock = 0; iBlock < blockRows; ++iBlock) { [EOL]         final int pStart = iBlock * BLOCK_SIZE; [EOL]         final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows); [EOL]         for (int jBlock = 0; jBlock < blockColumns; ++jBlock) { [EOL]             final int qStart = jBlock * BLOCK_SIZE; [EOL]             final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns); [EOL]             final T[] block = blocks[blockIndex]; [EOL]             int k = 0; [EOL]             for (int p = pStart; p < pEnd; ++p) { [EOL]                 for (int q = qStart; q < qEnd; ++q) { [EOL]                     block[k] = visitor.visit(p, q, block[k]); [EOL]                     ++k; [EOL]                 } [EOL]             } [EOL]             ++blockIndex; [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 1467,1489
@Override [EOL] public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor) { [EOL]     visitor.start(rows, columns, 0, rows - 1, 0, columns - 1); [EOL]     int blockIndex = 0; [EOL]     for (int iBlock = 0; iBlock < blockRows; ++iBlock) { [EOL]         final int pStart = iBlock * BLOCK_SIZE; [EOL]         final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows); [EOL]         for (int jBlock = 0; jBlock < blockColumns; ++jBlock) { [EOL]             final int qStart = jBlock * BLOCK_SIZE; [EOL]             final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns); [EOL]             final T[] block = blocks[blockIndex]; [EOL]             int k = 0; [EOL]             for (int p = pStart; p < pEnd; ++p) { [EOL]                 for (int q = qStart; q < qEnd; ++q) { [EOL]                     visitor.visit(p, q, block[k]); [EOL]                     ++k; [EOL]                 } [EOL]             } [EOL]             ++blockIndex; [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 1492,1514
@Override [EOL] public T walkInOptimizedOrder(final FieldMatrixChangingVisitor<T> visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws OutOfRangeException, NumberIsTooSmallException { [EOL]     checkSubMatrixIndex(startRow, endRow, startColumn, endColumn); [EOL]     visitor.start(rows, columns, startRow, endRow, startColumn, endColumn); [EOL]     for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) { [EOL]         final int p0 = iBlock * BLOCK_SIZE; [EOL]         final int pStart = FastMath.max(startRow, p0); [EOL]         final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow); [EOL]         for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) { [EOL]             final int jWidth = blockWidth(jBlock); [EOL]             final int q0 = jBlock * BLOCK_SIZE; [EOL]             final int qStart = FastMath.max(startColumn, q0); [EOL]             final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn); [EOL]             final T[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]             for (int p = pStart; p < pEnd; ++p) { [EOL]                 int k = (p - p0) * jWidth + qStart - q0; [EOL]                 for (int q = qStart; q < qEnd; ++q) { [EOL]                     block[k] = visitor.visit(p, q, block[k]); [EOL]                     ++k; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 1517,1544
@Override [EOL] public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws OutOfRangeException, NumberIsTooSmallException { [EOL]     checkSubMatrixIndex(startRow, endRow, startColumn, endColumn); [EOL]     visitor.start(rows, columns, startRow, endRow, startColumn, endColumn); [EOL]     for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) { [EOL]         final int p0 = iBlock * BLOCK_SIZE; [EOL]         final int pStart = FastMath.max(startRow, p0); [EOL]         final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow); [EOL]         for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) { [EOL]             final int jWidth = blockWidth(jBlock); [EOL]             final int q0 = jBlock * BLOCK_SIZE; [EOL]             final int qStart = FastMath.max(startColumn, q0); [EOL]             final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn); [EOL]             final T[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]             for (int p = pStart; p < pEnd; ++p) { [EOL]                 int k = (p - p0) * jWidth + qStart - q0; [EOL]                 for (int q = qStart; q < qEnd; ++q) { [EOL]                     visitor.visit(p, q, block[k]); [EOL]                     ++k; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 1547,1574
private int blockHeight(final int blockRow) { [EOL]     return (blockRow == blockRows - 1) ? rows - blockRow * BLOCK_SIZE : BLOCK_SIZE; [EOL] } <line_num>: 1581,1583
private int blockWidth(final int blockColumn) { [EOL]     return (blockColumn == blockColumns - 1) ? columns - blockColumn * BLOCK_SIZE : BLOCK_SIZE; [EOL] } <line_num>: 1590,1592
