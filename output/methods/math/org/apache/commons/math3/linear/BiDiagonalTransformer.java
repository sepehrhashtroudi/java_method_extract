public BiDiagonalTransformer(RealMatrix matrix) { [EOL]     final int m = matrix.getRowDimension(); [EOL]     final int n = matrix.getColumnDimension(); [EOL]     final int p = FastMath.min(m, n); [EOL]     householderVectors = matrix.getData(); [EOL]     main = new double[p]; [EOL]     secondary = new double[p - 1]; [EOL]     cachedU = null; [EOL]     cachedB = null; [EOL]     cachedV = null; [EOL]     if (m >= n) { [EOL]         transformToUpperBiDiagonal(); [EOL]     } else { [EOL]         transformToLowerBiDiagonal(); [EOL]     } [EOL] } <line_num>: 62,81
public RealMatrix getU() { [EOL]     if (cachedU == null) { [EOL]         final int m = householderVectors.length; [EOL]         final int n = householderVectors[0].length; [EOL]         final int p = main.length; [EOL]         final int diagOffset = (m >= n) ? 0 : 1; [EOL]         final double[] diagonal = (m >= n) ? main : secondary; [EOL]         double[][] ua = new double[m][m]; [EOL]         for (int k = m - 1; k >= p; --k) { [EOL]             ua[k][k] = 1; [EOL]         } [EOL]         for (int k = p - 1; k >= diagOffset; --k) { [EOL]             final double[] hK = householderVectors[k]; [EOL]             ua[k][k] = 1; [EOL]             if (hK[k - diagOffset] != 0.0) { [EOL]                 for (int j = k; j < m; ++j) { [EOL]                     double alpha = 0; [EOL]                     for (int i = k; i < m; ++i) { [EOL]                         alpha -= ua[i][j] * householderVectors[i][k - diagOffset]; [EOL]                     } [EOL]                     alpha /= diagonal[k - diagOffset] * hK[k - diagOffset]; [EOL]                     for (int i = k; i < m; ++i) { [EOL]                         ua[i][j] += -alpha * householderVectors[i][k - diagOffset]; [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (diagOffset > 0) { [EOL]             ua[0][0] = 1; [EOL]         } [EOL]         cachedU = MatrixUtils.createRealMatrix(ua); [EOL]     } [EOL]     return cachedU; [EOL] } <line_num>: 88,131
public RealMatrix getB() { [EOL]     if (cachedB == null) { [EOL]         final int m = householderVectors.length; [EOL]         final int n = householderVectors[0].length; [EOL]         double[][] ba = new double[m][n]; [EOL]         for (int i = 0; i < main.length; ++i) { [EOL]             ba[i][i] = main[i]; [EOL]             if (m < n) { [EOL]                 if (i > 0) { [EOL]                     ba[i][i - 1] = secondary[i - 1]; [EOL]                 } [EOL]             } else { [EOL]                 if (i < main.length - 1) { [EOL]                     ba[i][i + 1] = secondary[i]; [EOL]                 } [EOL]             } [EOL]         } [EOL]         cachedB = MatrixUtils.createRealMatrix(ba); [EOL]     } [EOL]     return cachedB; [EOL] } <line_num>: 137,162
public RealMatrix getV() { [EOL]     if (cachedV == null) { [EOL]         final int m = householderVectors.length; [EOL]         final int n = householderVectors[0].length; [EOL]         final int p = main.length; [EOL]         final int diagOffset = (m >= n) ? 1 : 0; [EOL]         final double[] diagonal = (m >= n) ? secondary : main; [EOL]         double[][] va = new double[n][n]; [EOL]         for (int k = n - 1; k >= p; --k) { [EOL]             va[k][k] = 1; [EOL]         } [EOL]         for (int k = p - 1; k >= diagOffset; --k) { [EOL]             final double[] hK = householderVectors[k - diagOffset]; [EOL]             va[k][k] = 1; [EOL]             if (hK[k] != 0.0) { [EOL]                 for (int j = k; j < n; ++j) { [EOL]                     double beta = 0; [EOL]                     for (int i = k; i < n; ++i) { [EOL]                         beta -= va[i][j] * hK[i]; [EOL]                     } [EOL]                     beta /= diagonal[k - diagOffset] * hK[k]; [EOL]                     for (int i = k; i < n; ++i) { [EOL]                         va[i][j] += -beta * hK[i]; [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (diagOffset > 0) { [EOL]             va[0][0] = 1; [EOL]         } [EOL]         cachedV = MatrixUtils.createRealMatrix(va); [EOL]     } [EOL]     return cachedV; [EOL] } <line_num>: 169,212
double[][] getHouseholderVectorsRef() { [EOL]     return householderVectors; [EOL] } <line_num>: 220,222
double[] getMainDiagonalRef() { [EOL]     return main; [EOL] } <line_num>: 230,232
double[] getSecondaryDiagonalRef() { [EOL]     return secondary; [EOL] } <line_num>: 240,242
boolean isUpperBiDiagonal() { [EOL]     return householderVectors.length >= householderVectors[0].length; [EOL] } <line_num>: 248,250
private void transformToUpperBiDiagonal() { [EOL]     final int m = householderVectors.length; [EOL]     final int n = householderVectors[0].length; [EOL]     for (int k = 0; k < n; k++) { [EOL]         double xNormSqr = 0; [EOL]         for (int i = k; i < m; ++i) { [EOL]             final double c = householderVectors[i][k]; [EOL]             xNormSqr += c * c; [EOL]         } [EOL]         final double[] hK = householderVectors[k]; [EOL]         final double a = (hK[k] > 0) ? -FastMath.sqrt(xNormSqr) : FastMath.sqrt(xNormSqr); [EOL]         main[k] = a; [EOL]         if (a != 0.0) { [EOL]             hK[k] -= a; [EOL]             for (int j = k + 1; j < n; ++j) { [EOL]                 double alpha = 0; [EOL]                 for (int i = k; i < m; ++i) { [EOL]                     final double[] hI = householderVectors[i]; [EOL]                     alpha -= hI[j] * hI[k]; [EOL]                 } [EOL]                 alpha /= a * householderVectors[k][k]; [EOL]                 for (int i = k; i < m; ++i) { [EOL]                     final double[] hI = householderVectors[i]; [EOL]                     hI[j] -= alpha * hI[k]; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (k < n - 1) { [EOL]             xNormSqr = 0; [EOL]             for (int j = k + 1; j < n; ++j) { [EOL]                 final double c = hK[j]; [EOL]                 xNormSqr += c * c; [EOL]             } [EOL]             final double b = (hK[k + 1] > 0) ? -FastMath.sqrt(xNormSqr) : FastMath.sqrt(xNormSqr); [EOL]             secondary[k] = b; [EOL]             if (b != 0.0) { [EOL]                 hK[k + 1] -= b; [EOL]                 for (int i = k + 1; i < m; ++i) { [EOL]                     final double[] hI = householderVectors[i]; [EOL]                     double beta = 0; [EOL]                     for (int j = k + 1; j < n; ++j) { [EOL]                         beta -= hI[j] * hK[j]; [EOL]                     } [EOL]                     beta /= b * hK[k + 1]; [EOL]                     for (int j = k + 1; j < n; ++j) { [EOL]                         hI[j] -= beta * hK[j]; [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 257,314
private void transformToLowerBiDiagonal() { [EOL]     final int m = householderVectors.length; [EOL]     final int n = householderVectors[0].length; [EOL]     for (int k = 0; k < m; k++) { [EOL]         final double[] hK = householderVectors[k]; [EOL]         double xNormSqr = 0; [EOL]         for (int j = k; j < n; ++j) { [EOL]             final double c = hK[j]; [EOL]             xNormSqr += c * c; [EOL]         } [EOL]         final double a = (hK[k] > 0) ? -FastMath.sqrt(xNormSqr) : FastMath.sqrt(xNormSqr); [EOL]         main[k] = a; [EOL]         if (a != 0.0) { [EOL]             hK[k] -= a; [EOL]             for (int i = k + 1; i < m; ++i) { [EOL]                 final double[] hI = householderVectors[i]; [EOL]                 double alpha = 0; [EOL]                 for (int j = k; j < n; ++j) { [EOL]                     alpha -= hI[j] * hK[j]; [EOL]                 } [EOL]                 alpha /= a * householderVectors[k][k]; [EOL]                 for (int j = k; j < n; ++j) { [EOL]                     hI[j] -= alpha * hK[j]; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (k < m - 1) { [EOL]             final double[] hKp1 = householderVectors[k + 1]; [EOL]             xNormSqr = 0; [EOL]             for (int i = k + 1; i < m; ++i) { [EOL]                 final double c = householderVectors[i][k]; [EOL]                 xNormSqr += c * c; [EOL]             } [EOL]             final double b = (hKp1[k] > 0) ? -FastMath.sqrt(xNormSqr) : FastMath.sqrt(xNormSqr); [EOL]             secondary[k] = b; [EOL]             if (b != 0.0) { [EOL]                 hKp1[k] -= b; [EOL]                 for (int j = k + 1; j < n; ++j) { [EOL]                     double beta = 0; [EOL]                     for (int i = k + 1; i < m; ++i) { [EOL]                         final double[] hI = householderVectors[i]; [EOL]                         beta -= hI[j] * hI[k]; [EOL]                     } [EOL]                     beta /= b * hKp1[k]; [EOL]                     for (int i = k + 1; i < m; ++i) { [EOL]                         final double[] hI = householderVectors[i]; [EOL]                         hI[j] -= beta * hI[k]; [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 321,379
