public RectangularCholeskyDecomposition(RealMatrix matrix) throws NonPositiveDefiniteMatrixException { [EOL]     this(matrix, 0); [EOL] } <line_num>: 68,71
public RectangularCholeskyDecomposition(RealMatrix matrix, double small) throws NonPositiveDefiniteMatrixException { [EOL]     final int order = matrix.getRowDimension(); [EOL]     final double[][] c = matrix.getData(); [EOL]     final double[][] b = new double[order][order]; [EOL]     int[] index = new int[order]; [EOL]     for (int i = 0; i < order; ++i) { [EOL]         index[i] = i; [EOL]     } [EOL]     int r = 0; [EOL]     for (boolean loop = true; loop; ) { [EOL]         int swapR = r; [EOL]         for (int i = r + 1; i < order; ++i) { [EOL]             int ii = index[i]; [EOL]             int isr = index[swapR]; [EOL]             if (c[ii][ii] > c[isr][isr]) { [EOL]                 swapR = i; [EOL]             } [EOL]         } [EOL]         if (swapR != r) { [EOL]             final int tmpIndex = index[r]; [EOL]             index[r] = index[swapR]; [EOL]             index[swapR] = tmpIndex; [EOL]             final double[] tmpRow = b[r]; [EOL]             b[r] = b[swapR]; [EOL]             b[swapR] = tmpRow; [EOL]         } [EOL]         int ir = index[r]; [EOL]         if (c[ir][ir] <= small) { [EOL]             if (r == 0) { [EOL]                 throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small); [EOL]             } [EOL]             for (int i = r; i < order; ++i) { [EOL]                 if (c[index[i]][index[i]] < -small) { [EOL]                     throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small); [EOL]                 } [EOL]             } [EOL]             loop = false; [EOL]         } else { [EOL]             final double sqrt = FastMath.sqrt(c[ir][ir]); [EOL]             b[r][r] = sqrt; [EOL]             final double inverse = 1 / sqrt; [EOL]             final double inverse2 = 1 / c[ir][ir]; [EOL]             for (int i = r + 1; i < order; ++i) { [EOL]                 final int ii = index[i]; [EOL]                 final double e = inverse * c[ii][ir]; [EOL]                 b[i][r] = e; [EOL]                 c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2; [EOL]                 for (int j = r + 1; j < i; ++j) { [EOL]                     final int ij = index[j]; [EOL]                     final double f = c[ii][ij] - e * b[j][r]; [EOL]                     c[ii][ij] = f; [EOL]                     c[ij][ii] = f; [EOL]                 } [EOL]             } [EOL]             loop = ++r < order; [EOL]         } [EOL]     } [EOL]     rank = r; [EOL]     root = MatrixUtils.createRealMatrix(order, r); [EOL]     for (int i = 0; i < order; ++i) { [EOL]         for (int j = 0; j < r; ++j) { [EOL]             root.setEntry(index[i], j, b[i][j]); [EOL]         } [EOL]     } [EOL] } <line_num>: 82,173
public RealMatrix getRootMatrix() { [EOL]     return root; [EOL] } <line_num>: 181,183
public int getRank() { [EOL]     return rank; [EOL] } <line_num>: 192,194
