public Entry() { [EOL]     setIndex(0); [EOL] } <line_num>: 1059,1061
protected SparseEntryIterator() { [EOL]     dim = getDimension(); [EOL]     current = new Entry(); [EOL]     next = new Entry(); [EOL]     if (next.getValue() == 0) { [EOL]         advance(next); [EOL]     } [EOL] } <line_num>: 1169,1176
public abstract int getDimension(); <line_num>: 66,66
public abstract double getEntry(int index) throws OutOfRangeException; <line_num>: 76,76
public abstract void setEntry(int index, double value) throws OutOfRangeException; <line_num>: 86,87
public void addToEntry(int index, double increment) throws OutOfRangeException { [EOL]     setEntry(index, getEntry(index) + increment); [EOL] } <line_num>: 97,100
public abstract RealVector append(RealVector v); <line_num>: 108,108
public abstract RealVector append(double d); <line_num>: 116,116
public abstract RealVector getSubVector(int index, int n) throws NotPositiveException, OutOfRangeException; <line_num>: 127,128
public abstract void setSubVector(int index, RealVector v) throws OutOfRangeException; <line_num>: 137,138
public abstract boolean isNaN(); <line_num>: 146,146
public abstract boolean isInfinite(); <line_num>: 154,154
protected void checkVectorDimensions(RealVector v) throws DimensionMismatchException { [EOL]     checkVectorDimensions(v.getDimension()); [EOL] } <line_num>: 163,166
protected void checkVectorDimensions(int n) throws DimensionMismatchException { [EOL]     int d = getDimension(); [EOL]     if (d != n) { [EOL]         throw new DimensionMismatchException(d, n); [EOL]     } [EOL] } <line_num>: 175,181
protected void checkIndex(final int index) throws OutOfRangeException { [EOL]     if (index < 0 || index >= getDimension()) { [EOL]         throw new OutOfRangeException(LocalizedFormats.INDEX, index, 0, getDimension() - 1); [EOL]     } [EOL] } <line_num>: 189,195
protected void checkIndices(final int start, final int end) throws NumberIsTooSmallException, OutOfRangeException { [EOL]     final int dim = getDimension(); [EOL]     if ((start < 0) || (start >= dim)) { [EOL]         throw new OutOfRangeException(LocalizedFormats.INDEX, start, 0, dim - 1); [EOL]     } [EOL]     if ((end < 0) || (end >= dim)) { [EOL]         throw new OutOfRangeException(LocalizedFormats.INDEX, end, 0, dim - 1); [EOL]     } [EOL]     if (end < start) { [EOL]         throw new NumberIsTooSmallException(LocalizedFormats.INITIAL_ROW_AFTER_FINAL_ROW, end, start, false); [EOL]     } [EOL] } <line_num>: 206,222
public RealVector add(RealVector v) throws DimensionMismatchException { [EOL]     checkVectorDimensions(v); [EOL]     RealVector result = v.copy(); [EOL]     Iterator<Entry> it = iterator(); [EOL]     while (it.hasNext()) { [EOL]         final Entry e = it.next(); [EOL]         final int index = e.getIndex(); [EOL]         result.setEntry(index, e.getValue() + result.getEntry(index)); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 233,243
public RealVector subtract(RealVector v) throws DimensionMismatchException { [EOL]     checkVectorDimensions(v); [EOL]     RealVector result = v.mapMultiply(-1d); [EOL]     Iterator<Entry> it = iterator(); [EOL]     while (it.hasNext()) { [EOL]         final Entry e = it.next(); [EOL]         final int index = e.getIndex(); [EOL]         result.setEntry(index, e.getValue() + result.getEntry(index)); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 254,264
public RealVector mapAdd(double d) { [EOL]     return copy().mapAddToSelf(d); [EOL] } <line_num>: 273,275
public RealVector mapAddToSelf(double d) { [EOL]     if (d != 0) { [EOL]         return mapToSelf(FunctionUtils.fix2ndArgument(new Add(), d)); [EOL]     } [EOL]     return this; [EOL] } <line_num>: 284,289
public abstract RealVector copy(); <line_num>: 296,296
public double dotProduct(RealVector v) throws DimensionMismatchException { [EOL]     checkVectorDimensions(v); [EOL]     double d = 0; [EOL]     final int n = getDimension(); [EOL]     for (int i = 0; i < n; i++) { [EOL]         d += getEntry(i) * v.getEntry(i); [EOL]     } [EOL]     return d; [EOL] } <line_num>: 306,314
public double cosine(RealVector v) throws DimensionMismatchException, MathArithmeticException { [EOL]     final double norm = getNorm(); [EOL]     final double vNorm = v.getNorm(); [EOL]     if (norm == 0 || vNorm == 0) { [EOL]         throw new MathArithmeticException(LocalizedFormats.ZERO_NORM); [EOL]     } [EOL]     return dotProduct(v) / (norm * vNorm); [EOL] } <line_num>: 327,337
@Deprecated [EOL] public abstract RealVector ebeDivide(RealVector v) throws DimensionMismatchException; <line_num>: 356,358
@Deprecated [EOL] public abstract RealVector ebeMultiply(RealVector v) throws DimensionMismatchException; <line_num>: 377,379
public double getDistance(RealVector v) throws DimensionMismatchException { [EOL]     checkVectorDimensions(v); [EOL]     double d = 0; [EOL]     Iterator<Entry> it = iterator(); [EOL]     while (it.hasNext()) { [EOL]         final Entry e = it.next(); [EOL]         final double diff = e.getValue() - v.getEntry(e.getIndex()); [EOL]         d += diff * diff; [EOL]     } [EOL]     return FastMath.sqrt(d); [EOL] } <line_num>: 395,405
public double getNorm() { [EOL]     double sum = 0; [EOL]     Iterator<Entry> it = iterator(); [EOL]     while (it.hasNext()) { [EOL]         final Entry e = it.next(); [EOL]         final double value = e.getValue(); [EOL]         sum += value * value; [EOL]     } [EOL]     return FastMath.sqrt(sum); [EOL] } <line_num>: 417,426
public double getL1Norm() { [EOL]     double norm = 0; [EOL]     Iterator<Entry> it = iterator(); [EOL]     while (it.hasNext()) { [EOL]         final Entry e = it.next(); [EOL]         norm += FastMath.abs(e.getValue()); [EOL]     } [EOL]     return norm; [EOL] } <line_num>: 438,446
public double getLInfNorm() { [EOL]     double norm = 0; [EOL]     Iterator<Entry> it = iterator(); [EOL]     while (it.hasNext()) { [EOL]         final Entry e = it.next(); [EOL]         norm = FastMath.max(norm, FastMath.abs(e.getValue())); [EOL]     } [EOL]     return norm; [EOL] } <line_num>: 458,466
public double getL1Distance(RealVector v) throws DimensionMismatchException { [EOL]     checkVectorDimensions(v); [EOL]     double d = 0; [EOL]     Iterator<Entry> it = iterator(); [EOL]     while (it.hasNext()) { [EOL]         final Entry e = it.next(); [EOL]         d += FastMath.abs(e.getValue() - v.getEntry(e.getIndex())); [EOL]     } [EOL]     return d; [EOL] } <line_num>: 479,489
public double getLInfDistance(RealVector v) throws DimensionMismatchException { [EOL]     checkVectorDimensions(v); [EOL]     double d = 0; [EOL]     Iterator<Entry> it = iterator(); [EOL]     while (it.hasNext()) { [EOL]         final Entry e = it.next(); [EOL]         d = FastMath.max(FastMath.abs(e.getValue() - v.getEntry(e.getIndex())), d); [EOL]     } [EOL]     return d; [EOL] } <line_num>: 505,515
public int getMinIndex() { [EOL]     int minIndex = -1; [EOL]     double minValue = Double.POSITIVE_INFINITY; [EOL]     Iterator<Entry> iterator = iterator(); [EOL]     while (iterator.hasNext()) { [EOL]         final Entry entry = iterator.next(); [EOL]         if (entry.getValue() <= minValue) { [EOL]             minIndex = entry.getIndex(); [EOL]             minValue = entry.getValue(); [EOL]         } [EOL]     } [EOL]     return minIndex; [EOL] } <line_num>: 523,535
public double getMinValue() { [EOL]     final int minIndex = getMinIndex(); [EOL]     return minIndex < 0 ? Double.NaN : getEntry(minIndex); [EOL] } <line_num>: 543,546
public int getMaxIndex() { [EOL]     int maxIndex = -1; [EOL]     double maxValue = Double.NEGATIVE_INFINITY; [EOL]     Iterator<Entry> iterator = iterator(); [EOL]     while (iterator.hasNext()) { [EOL]         final Entry entry = iterator.next(); [EOL]         if (entry.getValue() >= maxValue) { [EOL]             maxIndex = entry.getIndex(); [EOL]             maxValue = entry.getValue(); [EOL]         } [EOL]     } [EOL]     return maxIndex; [EOL] } <line_num>: 554,566
public double getMaxValue() { [EOL]     final int maxIndex = getMaxIndex(); [EOL]     return maxIndex < 0 ? Double.NaN : getEntry(maxIndex); [EOL] } <line_num>: 574,577
public RealVector mapMultiply(double d) { [EOL]     return copy().mapMultiplyToSelf(d); [EOL] } <line_num>: 587,589
public RealVector mapMultiplyToSelf(double d) { [EOL]     return mapToSelf(FunctionUtils.fix2ndArgument(new Multiply(), d)); [EOL] } <line_num>: 598,600
public RealVector mapSubtract(double d) { [EOL]     return copy().mapSubtractToSelf(d); [EOL] } <line_num>: 609,611
public RealVector mapSubtractToSelf(double d) { [EOL]     return mapAddToSelf(-d); [EOL] } <line_num>: 620,622
public RealVector mapDivide(double d) { [EOL]     return copy().mapDivideToSelf(d); [EOL] } <line_num>: 631,633
public RealVector mapDivideToSelf(double d) { [EOL]     return mapToSelf(FunctionUtils.fix2ndArgument(new Divide(), d)); [EOL] } <line_num>: 642,644
public RealMatrix outerProduct(RealVector v) { [EOL]     final int m = this.getDimension(); [EOL]     final int n = v.getDimension(); [EOL]     final RealMatrix product; [EOL]     if (v instanceof SparseRealVector || this instanceof SparseRealVector) { [EOL]         product = new OpenMapRealMatrix(m, n); [EOL]     } else { [EOL]         product = new Array2DRowRealMatrix(m, n); [EOL]     } [EOL]     for (int i = 0; i < m; i++) { [EOL]         for (int j = 0; j < n; j++) { [EOL]             product.setEntry(i, j, this.getEntry(i) * v.getEntry(j)); [EOL]         } [EOL]     } [EOL]     return product; [EOL] } <line_num>: 652,667
public RealVector projection(final RealVector v) throws DimensionMismatchException, MathArithmeticException { [EOL]     final double norm2 = v.dotProduct(v); [EOL]     if (norm2 == 0.0) { [EOL]         throw new MathArithmeticException(LocalizedFormats.ZERO_NORM); [EOL]     } [EOL]     return v.mapMultiply(dotProduct(v) / v.dotProduct(v)); [EOL] } <line_num>: 679,686
public void set(double value) { [EOL]     Iterator<Entry> it = iterator(); [EOL]     while (it.hasNext()) { [EOL]         final Entry e = it.next(); [EOL]         e.setValue(value); [EOL]     } [EOL] } <line_num>: 693,699
public double[] toArray() { [EOL]     int dim = getDimension(); [EOL]     double[] values = new double[dim]; [EOL]     for (int i = 0; i < dim; i++) { [EOL]         values[i] = getEntry(i); [EOL]     } [EOL]     return values; [EOL] } <line_num>: 708,715
public RealVector unitVector() throws MathArithmeticException { [EOL]     final double norm = getNorm(); [EOL]     if (norm == 0) { [EOL]         throw new MathArithmeticException(LocalizedFormats.ZERO_NORM); [EOL]     } [EOL]     return mapDivide(norm); [EOL] } <line_num>: 724,730
public void unitize() throws MathArithmeticException { [EOL]     final double norm = getNorm(); [EOL]     if (norm == 0) { [EOL]         throw new MathArithmeticException(LocalizedFormats.ZERO_NORM); [EOL]     } [EOL]     mapDivideToSelf(getNorm()); [EOL] } <line_num>: 738,744
@Deprecated [EOL] public Iterator<Entry> sparseIterator() { [EOL]     return new SparseEntryIterator(); [EOL] } <line_num>: 765,768
public boolean hasNext() { [EOL]     return i < dim; [EOL] } <line_num>: 791,793
public Entry next() { [EOL]     if (i < dim) { [EOL]         e.setIndex(i++); [EOL]         return e; [EOL]     } else { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL] } <line_num>: 796,803
public void remove() throws MathUnsupportedOperationException { [EOL]     throw new MathUnsupportedOperationException(); [EOL] } <line_num>: 810,812
public Iterator<Entry> iterator() { [EOL]     final int dim = getDimension(); [EOL]     return new Iterator<Entry>() { [EOL]  [EOL]         private int i = 0; [EOL]  [EOL]         private Entry e = new Entry(); [EOL]  [EOL]         public boolean hasNext() { [EOL]             return i < dim; [EOL]         } [EOL]  [EOL]         public Entry next() { [EOL]             if (i < dim) { [EOL]                 e.setIndex(i++); [EOL]                 return e; [EOL]             } else { [EOL]                 throw new NoSuchElementException(); [EOL]             } [EOL]         } [EOL]  [EOL]         public void remove() throws MathUnsupportedOperationException { [EOL]             throw new MathUnsupportedOperationException(); [EOL]         } [EOL]     }; [EOL] } <line_num>: 780,814
public RealVector map(UnivariateFunction function) { [EOL]     return copy().mapToSelf(function); [EOL] } <line_num>: 826,828
public RealVector mapToSelf(UnivariateFunction function) { [EOL]     Iterator<Entry> it = iterator(); [EOL]     while (it.hasNext()) { [EOL]         final Entry e = it.next(); [EOL]         e.setValue(function.value(e.getValue())); [EOL]     } [EOL]     return this; [EOL] } <line_num>: 843,850
public RealVector combine(double a, double b, RealVector y) throws DimensionMismatchException { [EOL]     return copy().combineToSelf(a, b, y); [EOL] } <line_num>: 865,868
public RealVector combineToSelf(double a, double b, RealVector y) throws DimensionMismatchException { [EOL]     checkVectorDimensions(y); [EOL]     for (int i = 0; i < getDimension(); i++) { [EOL]         final double xi = getEntry(i); [EOL]         final double yi = y.getEntry(i); [EOL]         setEntry(i, a * xi + b * yi); [EOL]     } [EOL]     return this; [EOL] } <line_num>: 882,891
public double walkInDefaultOrder(final RealVectorPreservingVisitor visitor) { [EOL]     final int dim = getDimension(); [EOL]     visitor.start(dim, 0, dim - 1); [EOL]     for (int i = 0; i < dim; i++) { [EOL]         visitor.visit(i, getEntry(i)); [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 903,910
public double walkInDefaultOrder(final RealVectorPreservingVisitor visitor, final int start, final int end) throws NumberIsTooSmallException, OutOfRangeException { [EOL]     checkIndices(start, end); [EOL]     visitor.start(getDimension(), start, end); [EOL]     for (int i = start; i <= end; i++) { [EOL]         visitor.visit(i, getEntry(i)); [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 925,934
public double walkInOptimizedOrder(final RealVectorPreservingVisitor visitor) { [EOL]     return walkInDefaultOrder(visitor); [EOL] } <line_num>: 948,950
public double walkInOptimizedOrder(final RealVectorPreservingVisitor visitor, final int start, final int end) throws NumberIsTooSmallException, OutOfRangeException { [EOL]     return walkInDefaultOrder(visitor, start, end); [EOL] } <line_num>: 967,971
public double walkInDefaultOrder(final RealVectorChangingVisitor visitor) { [EOL]     final int dim = getDimension(); [EOL]     visitor.start(dim, 0, dim - 1); [EOL]     for (int i = 0; i < dim; i++) { [EOL]         setEntry(i, visitor.visit(i, getEntry(i))); [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 983,990
public double walkInDefaultOrder(final RealVectorChangingVisitor visitor, final int start, final int end) throws NumberIsTooSmallException, OutOfRangeException { [EOL]     checkIndices(start, end); [EOL]     visitor.start(getDimension(), start, end); [EOL]     for (int i = start; i <= end; i++) { [EOL]         setEntry(i, visitor.visit(i, getEntry(i))); [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 1005,1014
public double walkInOptimizedOrder(final RealVectorChangingVisitor visitor) { [EOL]     return walkInDefaultOrder(visitor); [EOL] } <line_num>: 1028,1030
public double walkInOptimizedOrder(final RealVectorChangingVisitor visitor, final int start, final int end) throws NumberIsTooSmallException, OutOfRangeException { [EOL]     return walkInDefaultOrder(visitor, start, end); [EOL] } <line_num>: 1047,1051
public double getValue() { [EOL]     return getEntry(getIndex()); [EOL] } <line_num>: 1068,1070
public void setValue(double value) { [EOL]     setEntry(getIndex(), value); [EOL] } <line_num>: 1077,1079
public int getIndex() { [EOL]     return index; [EOL] } <line_num>: 1086,1088
public void setIndex(int index) { [EOL]     this.index = index; [EOL] } <line_num>: 1095,1097
@Override [EOL] public boolean equals(Object other) throws MathUnsupportedOperationException { [EOL]     throw new MathUnsupportedOperationException(); [EOL] } <line_num>: 1122,1126
@Override [EOL] public int hashCode() throws MathUnsupportedOperationException { [EOL]     throw new MathUnsupportedOperationException(); [EOL] } <line_num>: 1136,1139
protected void advance(Entry e) { [EOL]     if (e == null) { [EOL]         return; [EOL]     } [EOL]     do { [EOL]         e.setIndex(e.getIndex() + 1); [EOL]     } while (e.getIndex() < dim && e.getValue() == 0); [EOL]     if (e.getIndex() >= dim) { [EOL]         e.setIndex(-1); [EOL]     } [EOL] } <line_num>: 1183,1193
public boolean hasNext() { [EOL]     return next.getIndex() >= 0; [EOL] } <line_num>: 1196,1198
public Entry next() { [EOL]     int index = next.getIndex(); [EOL]     if (index < 0) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     current.setIndex(index); [EOL]     advance(next); [EOL]     return current; [EOL] } <line_num>: 1201,1209
public void remove() throws MathUnsupportedOperationException { [EOL]     throw new MathUnsupportedOperationException(); [EOL] } <line_num>: 1216,1218
@Override [EOL] public RealVector mapToSelf(UnivariateFunction function) throws MathUnsupportedOperationException { [EOL]     throw new MathUnsupportedOperationException(); [EOL] } <line_num>: 1255,1259
@Override [EOL] public RealVector map(UnivariateFunction function) { [EOL]     return v.map(function); [EOL] } <line_num>: 1262,1265
public boolean hasNext() { [EOL]     return i.hasNext(); [EOL] } <line_num>: 1276,1278
public Entry next() { [EOL]     e.setIndex(i.next().getIndex()); [EOL]     return e; [EOL] } <line_num>: 1281,1284
public void remove() throws MathUnsupportedOperationException { [EOL]     throw new MathUnsupportedOperationException(); [EOL] } <line_num>: 1292,1294
@Override [EOL] public Iterator<Entry> iterator() { [EOL]     final Iterator<Entry> i = v.iterator(); [EOL]     return new Iterator<Entry>() { [EOL]  [EOL]         private final UnmodifiableEntry e = new UnmodifiableEntry(); [EOL]  [EOL]         public boolean hasNext() { [EOL]             return i.hasNext(); [EOL]         } [EOL]  [EOL]         public Entry next() { [EOL]             e.setIndex(i.next().getIndex()); [EOL]             return e; [EOL]         } [EOL]  [EOL]         public void remove() throws MathUnsupportedOperationException { [EOL]             throw new MathUnsupportedOperationException(); [EOL]         } [EOL]     }; [EOL] } <line_num>: 1268,1296
public boolean hasNext() { [EOL]     return i.hasNext(); [EOL] } <line_num>: 1308,1310
public Entry next() { [EOL]     e.setIndex(i.next().getIndex()); [EOL]     return e; [EOL] } <line_num>: 1313,1316
public void remove() throws MathUnsupportedOperationException { [EOL]     throw new MathUnsupportedOperationException(); [EOL] } <line_num>: 1324,1327
@Override [EOL] public Iterator<Entry> sparseIterator() { [EOL]     final Iterator<Entry> i = v.sparseIterator(); [EOL]     return new Iterator<Entry>() { [EOL]  [EOL]         private final UnmodifiableEntry e = new UnmodifiableEntry(); [EOL]  [EOL]         public boolean hasNext() { [EOL]             return i.hasNext(); [EOL]         } [EOL]  [EOL]         public Entry next() { [EOL]             e.setIndex(i.next().getIndex()); [EOL]             return e; [EOL]         } [EOL]  [EOL]         public void remove() throws MathUnsupportedOperationException { [EOL]             throw new MathUnsupportedOperationException(); [EOL]         } [EOL]     }; [EOL] } <line_num>: 1299,1329
@Override [EOL] public RealVector copy() { [EOL]     return v.copy(); [EOL] } <line_num>: 1332,1335
@Override [EOL] public RealVector add(RealVector w) throws DimensionMismatchException { [EOL]     return v.add(w); [EOL] } <line_num>: 1338,1342
@Override [EOL] public RealVector subtract(RealVector w) throws DimensionMismatchException { [EOL]     return v.subtract(w); [EOL] } <line_num>: 1345,1349
@Override [EOL] public RealVector mapAdd(double d) { [EOL]     return v.mapAdd(d); [EOL] } <line_num>: 1352,1355
@Override [EOL] public RealVector mapAddToSelf(double d) throws MathUnsupportedOperationException { [EOL]     throw new MathUnsupportedOperationException(); [EOL] } <line_num>: 1363,1367
@Override [EOL] public RealVector mapSubtract(double d) { [EOL]     return v.mapSubtract(d); [EOL] } <line_num>: 1370,1373
@Override [EOL] public RealVector mapSubtractToSelf(double d) throws MathUnsupportedOperationException { [EOL]     throw new MathUnsupportedOperationException(); [EOL] } <line_num>: 1381,1385
@Override [EOL] public RealVector mapMultiply(double d) { [EOL]     return v.mapMultiply(d); [EOL] } <line_num>: 1388,1391
@Override [EOL] public RealVector mapMultiplyToSelf(double d) throws MathUnsupportedOperationException { [EOL]     throw new MathUnsupportedOperationException(); [EOL] } <line_num>: 1399,1403
@Override [EOL] public RealVector mapDivide(double d) { [EOL]     return v.mapDivide(d); [EOL] } <line_num>: 1406,1409
@Override [EOL] public RealVector mapDivideToSelf(double d) throws MathUnsupportedOperationException { [EOL]     throw new MathUnsupportedOperationException(); [EOL] } <line_num>: 1417,1421
@Override [EOL] public RealVector ebeMultiply(RealVector w) throws DimensionMismatchException { [EOL]     return v.ebeMultiply(w); [EOL] } <line_num>: 1424,1428
@Override [EOL] public RealVector ebeDivide(RealVector w) throws DimensionMismatchException { [EOL]     return v.ebeDivide(w); [EOL] } <line_num>: 1431,1435
@Override [EOL] public double dotProduct(RealVector w) throws DimensionMismatchException { [EOL]     return v.dotProduct(w); [EOL] } <line_num>: 1438,1442
@Override [EOL] public double cosine(RealVector w) throws DimensionMismatchException, MathArithmeticException { [EOL]     return v.cosine(w); [EOL] } <line_num>: 1445,1449
@Override [EOL] public double getNorm() { [EOL]     return v.getNorm(); [EOL] } <line_num>: 1452,1455
@Override [EOL] public double getL1Norm() { [EOL]     return v.getL1Norm(); [EOL] } <line_num>: 1458,1461
@Override [EOL] public double getLInfNorm() { [EOL]     return v.getLInfNorm(); [EOL] } <line_num>: 1464,1467
@Override [EOL] public double getDistance(RealVector w) throws DimensionMismatchException { [EOL]     return v.getDistance(w); [EOL] } <line_num>: 1470,1474
@Override [EOL] public double getL1Distance(RealVector w) throws DimensionMismatchException { [EOL]     return v.getL1Distance(w); [EOL] } <line_num>: 1477,1481
@Override [EOL] public double getLInfDistance(RealVector w) throws DimensionMismatchException { [EOL]     return v.getLInfDistance(w); [EOL] } <line_num>: 1484,1488
@Override [EOL] public RealVector unitVector() throws MathArithmeticException { [EOL]     return v.unitVector(); [EOL] } <line_num>: 1491,1494
@Override [EOL] public void unitize() throws MathUnsupportedOperationException { [EOL]     throw new MathUnsupportedOperationException(); [EOL] } <line_num>: 1502,1505
@Override [EOL] public RealMatrix outerProduct(RealVector w) { [EOL]     return v.outerProduct(w); [EOL] } <line_num>: 1508,1511
@Override [EOL] public double getEntry(int index) throws OutOfRangeException { [EOL]     return v.getEntry(index); [EOL] } <line_num>: 1514,1517
@Override [EOL] public void setEntry(int index, double value) throws MathUnsupportedOperationException { [EOL]     throw new MathUnsupportedOperationException(); [EOL] } <line_num>: 1525,1529
@Override [EOL] public void addToEntry(int index, double value) throws MathUnsupportedOperationException { [EOL]     throw new MathUnsupportedOperationException(); [EOL] } <line_num>: 1537,1541
@Override [EOL] public int getDimension() { [EOL]     return v.getDimension(); [EOL] } <line_num>: 1544,1547
@Override [EOL] public RealVector append(RealVector w) { [EOL]     return v.append(w); [EOL] } <line_num>: 1550,1553
@Override [EOL] public RealVector append(double d) { [EOL]     return v.append(d); [EOL] } <line_num>: 1556,1559
@Override [EOL] public RealVector getSubVector(int index, int n) throws OutOfRangeException, NotPositiveException { [EOL]     return v.getSubVector(index, n); [EOL] } <line_num>: 1562,1566
@Override [EOL] public void setSubVector(int index, RealVector w) throws MathUnsupportedOperationException { [EOL]     throw new MathUnsupportedOperationException(); [EOL] } <line_num>: 1574,1578
@Override [EOL] public void set(double value) throws MathUnsupportedOperationException { [EOL]     throw new MathUnsupportedOperationException(); [EOL] } <line_num>: 1586,1590
@Override [EOL] public double[] toArray() { [EOL]     return v.toArray(); [EOL] } <line_num>: 1593,1596
@Override [EOL] public boolean isNaN() { [EOL]     return v.isNaN(); [EOL] } <line_num>: 1599,1602
@Override [EOL] public boolean isInfinite() { [EOL]     return v.isInfinite(); [EOL] } <line_num>: 1605,1608
@Override [EOL] public RealVector combine(double a, double b, RealVector y) throws DimensionMismatchException { [EOL]     return v.combine(a, b, y); [EOL] } <line_num>: 1611,1615
@Override [EOL] public RealVector combineToSelf(double a, double b, RealVector y) throws MathUnsupportedOperationException { [EOL]     throw new MathUnsupportedOperationException(); [EOL] } <line_num>: 1623,1627
@Override [EOL] public double getValue() { [EOL]     return v.getEntry(getIndex()); [EOL] } <line_num>: 1632,1635
@Override [EOL] public void setValue(double value) throws MathUnsupportedOperationException { [EOL]     throw new MathUnsupportedOperationException(); [EOL] } <line_num>: 1643,1647
public static RealVector unmodifiableRealVector(final RealVector v) { [EOL]     return new RealVector() { [EOL]  [EOL]         @Override [EOL]         public RealVector mapToSelf(UnivariateFunction function) throws MathUnsupportedOperationException { [EOL]             throw new MathUnsupportedOperationException(); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public RealVector map(UnivariateFunction function) { [EOL]             return v.map(function); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public Iterator<Entry> iterator() { [EOL]             final Iterator<Entry> i = v.iterator(); [EOL]             return new Iterator<Entry>() { [EOL]  [EOL]                 private final UnmodifiableEntry e = new UnmodifiableEntry(); [EOL]  [EOL]                 public boolean hasNext() { [EOL]                     return i.hasNext(); [EOL]                 } [EOL]  [EOL]                 public Entry next() { [EOL]                     e.setIndex(i.next().getIndex()); [EOL]                     return e; [EOL]                 } [EOL]  [EOL]                 public void remove() throws MathUnsupportedOperationException { [EOL]                     throw new MathUnsupportedOperationException(); [EOL]                 } [EOL]             }; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public Iterator<Entry> sparseIterator() { [EOL]             final Iterator<Entry> i = v.sparseIterator(); [EOL]             return new Iterator<Entry>() { [EOL]  [EOL]                 private final UnmodifiableEntry e = new UnmodifiableEntry(); [EOL]  [EOL]                 public boolean hasNext() { [EOL]                     return i.hasNext(); [EOL]                 } [EOL]  [EOL]                 public Entry next() { [EOL]                     e.setIndex(i.next().getIndex()); [EOL]                     return e; [EOL]                 } [EOL]  [EOL]                 public void remove() throws MathUnsupportedOperationException { [EOL]                     throw new MathUnsupportedOperationException(); [EOL]                 } [EOL]             }; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public RealVector copy() { [EOL]             return v.copy(); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public RealVector add(RealVector w) throws DimensionMismatchException { [EOL]             return v.add(w); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public RealVector subtract(RealVector w) throws DimensionMismatchException { [EOL]             return v.subtract(w); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public RealVector mapAdd(double d) { [EOL]             return v.mapAdd(d); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public RealVector mapAddToSelf(double d) throws MathUnsupportedOperationException { [EOL]             throw new MathUnsupportedOperationException(); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public RealVector mapSubtract(double d) { [EOL]             return v.mapSubtract(d); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public RealVector mapSubtractToSelf(double d) throws MathUnsupportedOperationException { [EOL]             throw new MathUnsupportedOperationException(); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public RealVector mapMultiply(double d) { [EOL]             return v.mapMultiply(d); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public RealVector mapMultiplyToSelf(double d) throws MathUnsupportedOperationException { [EOL]             throw new MathUnsupportedOperationException(); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public RealVector mapDivide(double d) { [EOL]             return v.mapDivide(d); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public RealVector mapDivideToSelf(double d) throws MathUnsupportedOperationException { [EOL]             throw new MathUnsupportedOperationException(); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public RealVector ebeMultiply(RealVector w) throws DimensionMismatchException { [EOL]             return v.ebeMultiply(w); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public RealVector ebeDivide(RealVector w) throws DimensionMismatchException { [EOL]             return v.ebeDivide(w); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public double dotProduct(RealVector w) throws DimensionMismatchException { [EOL]             return v.dotProduct(w); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public double cosine(RealVector w) throws DimensionMismatchException, MathArithmeticException { [EOL]             return v.cosine(w); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public double getNorm() { [EOL]             return v.getNorm(); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public double getL1Norm() { [EOL]             return v.getL1Norm(); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public double getLInfNorm() { [EOL]             return v.getLInfNorm(); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public double getDistance(RealVector w) throws DimensionMismatchException { [EOL]             return v.getDistance(w); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public double getL1Distance(RealVector w) throws DimensionMismatchException { [EOL]             return v.getL1Distance(w); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public double getLInfDistance(RealVector w) throws DimensionMismatchException { [EOL]             return v.getLInfDistance(w); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public RealVector unitVector() throws MathArithmeticException { [EOL]             return v.unitVector(); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void unitize() throws MathUnsupportedOperationException { [EOL]             throw new MathUnsupportedOperationException(); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public RealMatrix outerProduct(RealVector w) { [EOL]             return v.outerProduct(w); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public double getEntry(int index) throws OutOfRangeException { [EOL]             return v.getEntry(index); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void setEntry(int index, double value) throws MathUnsupportedOperationException { [EOL]             throw new MathUnsupportedOperationException(); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addToEntry(int index, double value) throws MathUnsupportedOperationException { [EOL]             throw new MathUnsupportedOperationException(); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public int getDimension() { [EOL]             return v.getDimension(); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public RealVector append(RealVector w) { [EOL]             return v.append(w); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public RealVector append(double d) { [EOL]             return v.append(d); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public RealVector getSubVector(int index, int n) throws OutOfRangeException, NotPositiveException { [EOL]             return v.getSubVector(index, n); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void setSubVector(int index, RealVector w) throws MathUnsupportedOperationException { [EOL]             throw new MathUnsupportedOperationException(); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void set(double value) throws MathUnsupportedOperationException { [EOL]             throw new MathUnsupportedOperationException(); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public double[] toArray() { [EOL]             return v.toArray(); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isNaN() { [EOL]             return v.isNaN(); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isInfinite() { [EOL]             return v.isInfinite(); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public RealVector combine(double a, double b, RealVector y) throws DimensionMismatchException { [EOL]             return v.combine(a, b, y); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public RealVector combineToSelf(double a, double b, RealVector y) throws MathUnsupportedOperationException { [EOL]             throw new MathUnsupportedOperationException(); [EOL]         } [EOL]  [EOL]         class UnmodifiableEntry extends Entry { [EOL]  [EOL]             @Override [EOL]             public double getValue() { [EOL]                 return v.getEntry(getIndex()); [EOL]             } [EOL]  [EOL]             @Override [EOL]             public void setValue(double value) throws MathUnsupportedOperationException { [EOL]                 throw new MathUnsupportedOperationException(); [EOL]             } [EOL]         } [EOL]     }; [EOL] } <line_num>: 1239,1650
