public BlockRealMatrix(final int rows, final int columns) throws NotStrictlyPositiveException { [EOL]     super(rows, columns); [EOL]     this.rows = rows; [EOL]     this.columns = columns; [EOL]     blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE; [EOL]     blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE; [EOL]     blocks = createBlocksLayout(rows, columns); [EOL] } <line_num>: 96,108
public BlockRealMatrix(final double[][] rawData) throws DimensionMismatchException, NotStrictlyPositiveException { [EOL]     this(rawData.length, rawData[0].length, toBlocksLayout(rawData), false); [EOL] } <line_num>: 125,128
public BlockRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws DimensionMismatchException, NotStrictlyPositiveException { [EOL]     super(rows, columns); [EOL]     this.rows = rows; [EOL]     this.columns = columns; [EOL]     blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE; [EOL]     blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE; [EOL]     if (copyArray) { [EOL]         blocks = new double[blockRows * blockColumns][]; [EOL]     } else { [EOL]         blocks = blockData; [EOL]     } [EOL]     int index = 0; [EOL]     for (int iBlock = 0; iBlock < blockRows; ++iBlock) { [EOL]         final int iHeight = blockHeight(iBlock); [EOL]         for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) { [EOL]             if (blockData[index].length != iHeight * blockWidth(jBlock)) { [EOL]                 throw new DimensionMismatchException(blockData[index].length, iHeight * blockWidth(jBlock)); [EOL]             } [EOL]             if (copyArray) { [EOL]                 blocks[index] = blockData[index].clone(); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 146,178
public static double[][] toBlocksLayout(final double[][] rawData) throws DimensionMismatchException { [EOL]     final int rows = rawData.length; [EOL]     final int columns = rawData[0].length; [EOL]     final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE; [EOL]     final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE; [EOL]     for (int i = 0; i < rawData.length; ++i) { [EOL]         final int length = rawData[i].length; [EOL]         if (length != columns) { [EOL]             throw new DimensionMismatchException(columns, length); [EOL]         } [EOL]     } [EOL]     final double[][] blocks = new double[blockRows * blockColumns][]; [EOL]     int blockIndex = 0; [EOL]     for (int iBlock = 0; iBlock < blockRows; ++iBlock) { [EOL]         final int pStart = iBlock * BLOCK_SIZE; [EOL]         final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows); [EOL]         final int iHeight = pEnd - pStart; [EOL]         for (int jBlock = 0; jBlock < blockColumns; ++jBlock) { [EOL]             final int qStart = jBlock * BLOCK_SIZE; [EOL]             final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns); [EOL]             final int jWidth = qEnd - qStart; [EOL]             final double[] block = new double[iHeight * jWidth]; [EOL]             blocks[blockIndex] = block; [EOL]             int index = 0; [EOL]             for (int p = pStart; p < pEnd; ++p) { [EOL]                 System.arraycopy(rawData[p], qStart, block, index, jWidth); [EOL]                 index += jWidth; [EOL]             } [EOL]             ++blockIndex; [EOL]         } [EOL]     } [EOL]     return blocks; [EOL] } <line_num>: 201,243
public static double[][] createBlocksLayout(final int rows, final int columns) { [EOL]     final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE; [EOL]     final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE; [EOL]     final double[][] blocks = new double[blockRows * blockColumns][]; [EOL]     int blockIndex = 0; [EOL]     for (int iBlock = 0; iBlock < blockRows; ++iBlock) { [EOL]         final int pStart = iBlock * BLOCK_SIZE; [EOL]         final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows); [EOL]         final int iHeight = pEnd - pStart; [EOL]         for (int jBlock = 0; jBlock < blockColumns; ++jBlock) { [EOL]             final int qStart = jBlock * BLOCK_SIZE; [EOL]             final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns); [EOL]             final int jWidth = qEnd - qStart; [EOL]             blocks[blockIndex] = new double[iHeight * jWidth]; [EOL]             ++blockIndex; [EOL]         } [EOL]     } [EOL]     return blocks; [EOL] } <line_num>: 257,277
@Override [EOL] public BlockRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws NotStrictlyPositiveException { [EOL]     return new BlockRealMatrix(rowDimension, columnDimension); [EOL] } <line_num>: 280,285
@Override [EOL] public BlockRealMatrix copy() { [EOL]     BlockRealMatrix copied = new BlockRealMatrix(rows, columns); [EOL]     for (int i = 0; i < blocks.length; ++i) { [EOL]         System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length); [EOL]     } [EOL]     return copied; [EOL] } <line_num>: 288,299
@Override [EOL] public BlockRealMatrix add(final RealMatrix m) throws MatrixDimensionMismatchException { [EOL]     try { [EOL]         return add((BlockRealMatrix) m); [EOL]     } catch (ClassCastException cce) { [EOL]         MatrixUtils.checkAdditionCompatible(this, m); [EOL]         final BlockRealMatrix out = new BlockRealMatrix(rows, columns); [EOL]         int blockIndex = 0; [EOL]         for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) { [EOL]             for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) { [EOL]                 final double[] outBlock = out.blocks[blockIndex]; [EOL]                 final double[] tBlock = blocks[blockIndex]; [EOL]                 final int pStart = iBlock * BLOCK_SIZE; [EOL]                 final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows); [EOL]                 final int qStart = jBlock * BLOCK_SIZE; [EOL]                 final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns); [EOL]                 int k = 0; [EOL]                 for (int p = pStart; p < pEnd; ++p) { [EOL]                     for (int q = qStart; q < qEnd; ++q) { [EOL]                         outBlock[k] = tBlock[k] + m.getEntry(p, q); [EOL]                         ++k; [EOL]                     } [EOL]                 } [EOL]                 ++blockIndex; [EOL]             } [EOL]         } [EOL]         return out; [EOL]     } [EOL] } <line_num>: 302,339
public BlockRealMatrix add(final BlockRealMatrix m) throws MatrixDimensionMismatchException { [EOL]     MatrixUtils.checkAdditionCompatible(this, m); [EOL]     final BlockRealMatrix out = new BlockRealMatrix(rows, columns); [EOL]     for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) { [EOL]         final double[] outBlock = out.blocks[blockIndex]; [EOL]         final double[] tBlock = blocks[blockIndex]; [EOL]         final double[] mBlock = m.blocks[blockIndex]; [EOL]         for (int k = 0; k < outBlock.length; ++k) { [EOL]             outBlock[k] = tBlock[k] + mBlock[k]; [EOL]         } [EOL]     } [EOL]     return out; [EOL] } <line_num>: 349,367
@Override [EOL] public BlockRealMatrix subtract(final RealMatrix m) throws MatrixDimensionMismatchException { [EOL]     try { [EOL]         return subtract((BlockRealMatrix) m); [EOL]     } catch (ClassCastException cce) { [EOL]         MatrixUtils.checkSubtractionCompatible(this, m); [EOL]         final BlockRealMatrix out = new BlockRealMatrix(rows, columns); [EOL]         int blockIndex = 0; [EOL]         for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) { [EOL]             for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) { [EOL]                 final double[] outBlock = out.blocks[blockIndex]; [EOL]                 final double[] tBlock = blocks[blockIndex]; [EOL]                 final int pStart = iBlock * BLOCK_SIZE; [EOL]                 final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows); [EOL]                 final int qStart = jBlock * BLOCK_SIZE; [EOL]                 final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns); [EOL]                 int k = 0; [EOL]                 for (int p = pStart; p < pEnd; ++p) { [EOL]                     for (int q = qStart; q < qEnd; ++q) { [EOL]                         outBlock[k] = tBlock[k] - m.getEntry(p, q); [EOL]                         ++k; [EOL]                     } [EOL]                 } [EOL]                 ++blockIndex; [EOL]             } [EOL]         } [EOL]         return out; [EOL]     } [EOL] } <line_num>: 370,407
public BlockRealMatrix subtract(final BlockRealMatrix m) throws MatrixDimensionMismatchException { [EOL]     MatrixUtils.checkSubtractionCompatible(this, m); [EOL]     final BlockRealMatrix out = new BlockRealMatrix(rows, columns); [EOL]     for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) { [EOL]         final double[] outBlock = out.blocks[blockIndex]; [EOL]         final double[] tBlock = blocks[blockIndex]; [EOL]         final double[] mBlock = m.blocks[blockIndex]; [EOL]         for (int k = 0; k < outBlock.length; ++k) { [EOL]             outBlock[k] = tBlock[k] - mBlock[k]; [EOL]         } [EOL]     } [EOL]     return out; [EOL] } <line_num>: 417,435
@Override [EOL] public BlockRealMatrix scalarAdd(final double d) { [EOL]     final BlockRealMatrix out = new BlockRealMatrix(rows, columns); [EOL]     for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) { [EOL]         final double[] outBlock = out.blocks[blockIndex]; [EOL]         final double[] tBlock = blocks[blockIndex]; [EOL]         for (int k = 0; k < outBlock.length; ++k) { [EOL]             outBlock[k] = tBlock[k] + d; [EOL]         } [EOL]     } [EOL]     return out; [EOL] } <line_num>: 438,453
@Override [EOL] public RealMatrix scalarMultiply(final double d) { [EOL]     final BlockRealMatrix out = new BlockRealMatrix(rows, columns); [EOL]     for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) { [EOL]         final double[] outBlock = out.blocks[blockIndex]; [EOL]         final double[] tBlock = blocks[blockIndex]; [EOL]         for (int k = 0; k < outBlock.length; ++k) { [EOL]             outBlock[k] = tBlock[k] * d; [EOL]         } [EOL]     } [EOL]     return out; [EOL] } <line_num>: 456,470
@Override [EOL] public BlockRealMatrix multiply(final RealMatrix m) throws DimensionMismatchException { [EOL]     try { [EOL]         return multiply((BlockRealMatrix) m); [EOL]     } catch (ClassCastException cce) { [EOL]         MatrixUtils.checkMultiplicationCompatible(this, m); [EOL]         final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension()); [EOL]         int blockIndex = 0; [EOL]         for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) { [EOL]             final int pStart = iBlock * BLOCK_SIZE; [EOL]             final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows); [EOL]             for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) { [EOL]                 final int qStart = jBlock * BLOCK_SIZE; [EOL]                 final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension()); [EOL]                 final double[] outBlock = out.blocks[blockIndex]; [EOL]                 for (int kBlock = 0; kBlock < blockColumns; ++kBlock) { [EOL]                     final int kWidth = blockWidth(kBlock); [EOL]                     final double[] tBlock = blocks[iBlock * blockColumns + kBlock]; [EOL]                     final int rStart = kBlock * BLOCK_SIZE; [EOL]                     int k = 0; [EOL]                     for (int p = pStart; p < pEnd; ++p) { [EOL]                         final int lStart = (p - pStart) * kWidth; [EOL]                         final int lEnd = lStart + kWidth; [EOL]                         for (int q = qStart; q < qEnd; ++q) { [EOL]                             double sum = 0; [EOL]                             int r = rStart; [EOL]                             for (int l = lStart; l < lEnd; ++l) { [EOL]                                 sum += tBlock[l] * m.getEntry(r, q); [EOL]                                 ++r; [EOL]                             } [EOL]                             outBlock[k] += sum; [EOL]                             ++k; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]                 ++blockIndex; [EOL]             } [EOL]         } [EOL]         return out; [EOL]     } [EOL] } <line_num>: 473,525
public BlockRealMatrix multiply(BlockRealMatrix m) throws DimensionMismatchException { [EOL]     MatrixUtils.checkMultiplicationCompatible(this, m); [EOL]     final BlockRealMatrix out = new BlockRealMatrix(rows, m.columns); [EOL]     int blockIndex = 0; [EOL]     for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) { [EOL]         final int pStart = iBlock * BLOCK_SIZE; [EOL]         final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows); [EOL]         for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) { [EOL]             final int jWidth = out.blockWidth(jBlock); [EOL]             final int jWidth2 = jWidth + jWidth; [EOL]             final int jWidth3 = jWidth2 + jWidth; [EOL]             final int jWidth4 = jWidth3 + jWidth; [EOL]             final double[] outBlock = out.blocks[blockIndex]; [EOL]             for (int kBlock = 0; kBlock < blockColumns; ++kBlock) { [EOL]                 final int kWidth = blockWidth(kBlock); [EOL]                 final double[] tBlock = blocks[iBlock * blockColumns + kBlock]; [EOL]                 final double[] mBlock = m.blocks[kBlock * m.blockColumns + jBlock]; [EOL]                 int k = 0; [EOL]                 for (int p = pStart; p < pEnd; ++p) { [EOL]                     final int lStart = (p - pStart) * kWidth; [EOL]                     final int lEnd = lStart + kWidth; [EOL]                     for (int nStart = 0; nStart < jWidth; ++nStart) { [EOL]                         double sum = 0; [EOL]                         int l = lStart; [EOL]                         int n = nStart; [EOL]                         while (l < lEnd - 3) { [EOL]                             sum += tBlock[l] * mBlock[n] + tBlock[l + 1] * mBlock[n + jWidth] + tBlock[l + 2] * mBlock[n + jWidth2] + tBlock[l + 3] * mBlock[n + jWidth3]; [EOL]                             l += 4; [EOL]                             n += jWidth4; [EOL]                         } [EOL]                         while (l < lEnd) { [EOL]                             sum += tBlock[l++] * mBlock[n]; [EOL]                             n += jWidth; [EOL]                         } [EOL]                         outBlock[k] += sum; [EOL]                         ++k; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             ++blockIndex; [EOL]         } [EOL]     } [EOL]     return out; [EOL] } <line_num>: 534,593
@Override [EOL] public double[][] getData() { [EOL]     final double[][] data = new double[getRowDimension()][getColumnDimension()]; [EOL]     final int lastColumns = columns - (blockColumns - 1) * BLOCK_SIZE; [EOL]     for (int iBlock = 0; iBlock < blockRows; ++iBlock) { [EOL]         final int pStart = iBlock * BLOCK_SIZE; [EOL]         final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows); [EOL]         int regularPos = 0; [EOL]         int lastPos = 0; [EOL]         for (int p = pStart; p < pEnd; ++p) { [EOL]             final double[] dataP = data[p]; [EOL]             int blockIndex = iBlock * blockColumns; [EOL]             int dataPos = 0; [EOL]             for (int jBlock = 0; jBlock < blockColumns - 1; ++jBlock) { [EOL]                 System.arraycopy(blocks[blockIndex++], regularPos, dataP, dataPos, BLOCK_SIZE); [EOL]                 dataPos += BLOCK_SIZE; [EOL]             } [EOL]             System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns); [EOL]             regularPos += BLOCK_SIZE; [EOL]             lastPos += lastColumns; [EOL]         } [EOL]     } [EOL]     return data; [EOL] } <line_num>: 596,621
@Override [EOL] public double getNorm() { [EOL]     final double[] colSums = new double[BLOCK_SIZE]; [EOL]     double maxColSum = 0; [EOL]     for (int jBlock = 0; jBlock < blockColumns; jBlock++) { [EOL]         final int jWidth = blockWidth(jBlock); [EOL]         Arrays.fill(colSums, 0, jWidth, 0.0); [EOL]         for (int iBlock = 0; iBlock < blockRows; ++iBlock) { [EOL]             final int iHeight = blockHeight(iBlock); [EOL]             final double[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]             for (int j = 0; j < jWidth; ++j) { [EOL]                 double sum = 0; [EOL]                 for (int i = 0; i < iHeight; ++i) { [EOL]                     sum += FastMath.abs(block[i * jWidth + j]); [EOL]                 } [EOL]                 colSums[j] += sum; [EOL]             } [EOL]         } [EOL]         for (int j = 0; j < jWidth; ++j) { [EOL]             maxColSum = FastMath.max(maxColSum, colSums[j]); [EOL]         } [EOL]     } [EOL]     return maxColSum; [EOL] } <line_num>: 624,647
@Override [EOL] public double getFrobeniusNorm() { [EOL]     double sum2 = 0; [EOL]     for (int blockIndex = 0; blockIndex < blocks.length; ++blockIndex) { [EOL]         for (final double entry : blocks[blockIndex]) { [EOL]             sum2 += entry * entry; [EOL]         } [EOL]     } [EOL]     return FastMath.sqrt(sum2); [EOL] } <line_num>: 650,659
@Override [EOL] public BlockRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws OutOfRangeException, NumberIsTooSmallException { [EOL]     MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn); [EOL]     final BlockRealMatrix out = new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1); [EOL]     final int blockStartRow = startRow / BLOCK_SIZE; [EOL]     final int rowsShift = startRow % BLOCK_SIZE; [EOL]     final int blockStartColumn = startColumn / BLOCK_SIZE; [EOL]     final int columnsShift = startColumn % BLOCK_SIZE; [EOL]     int pBlock = blockStartRow; [EOL]     for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) { [EOL]         final int iHeight = out.blockHeight(iBlock); [EOL]         int qBlock = blockStartColumn; [EOL]         for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) { [EOL]             final int jWidth = out.blockWidth(jBlock); [EOL]             final int outIndex = iBlock * out.blockColumns + jBlock; [EOL]             final double[] outBlock = out.blocks[outIndex]; [EOL]             final int index = pBlock * blockColumns + qBlock; [EOL]             final int width = blockWidth(qBlock); [EOL]             final int heightExcess = iHeight + rowsShift - BLOCK_SIZE; [EOL]             final int widthExcess = jWidth + columnsShift - BLOCK_SIZE; [EOL]             if (heightExcess > 0) { [EOL]                 if (widthExcess > 0) { [EOL]                     final int width2 = blockWidth(qBlock + 1); [EOL]                     copyBlockPart(blocks[index], width, rowsShift, BLOCK_SIZE, columnsShift, BLOCK_SIZE, outBlock, jWidth, 0, 0); [EOL]                     copyBlockPart(blocks[index + 1], width2, rowsShift, BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, jWidth - widthExcess); [EOL]                     copyBlockPart(blocks[index + blockColumns], width, 0, heightExcess, columnsShift, BLOCK_SIZE, outBlock, jWidth, iHeight - heightExcess, 0); [EOL]                     copyBlockPart(blocks[index + blockColumns + 1], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess); [EOL]                 } else { [EOL]                     copyBlockPart(blocks[index], width, rowsShift, BLOCK_SIZE, columnsShift, jWidth + columnsShift, outBlock, jWidth, 0, 0); [EOL]                     copyBlockPart(blocks[index + blockColumns], width, 0, heightExcess, columnsShift, jWidth + columnsShift, outBlock, jWidth, iHeight - heightExcess, 0); [EOL]                 } [EOL]             } else { [EOL]                 if (widthExcess > 0) { [EOL]                     final int width2 = blockWidth(qBlock + 1); [EOL]                     copyBlockPart(blocks[index], width, rowsShift, iHeight + rowsShift, columnsShift, BLOCK_SIZE, outBlock, jWidth, 0, 0); [EOL]                     copyBlockPart(blocks[index + 1], width2, rowsShift, iHeight + rowsShift, 0, widthExcess, outBlock, jWidth, 0, jWidth - widthExcess); [EOL]                 } else { [EOL]                     copyBlockPart(blocks[index], width, rowsShift, iHeight + rowsShift, columnsShift, jWidth + columnsShift, outBlock, jWidth, 0, 0); [EOL]                 } [EOL]             } [EOL]             ++qBlock; [EOL]         } [EOL]         ++pBlock; [EOL]     } [EOL]     return out; [EOL] } <line_num>: 662,755
private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) { [EOL]     final int length = srcEndColumn - srcStartColumn; [EOL]     int srcPos = srcStartRow * srcWidth + srcStartColumn; [EOL]     int dstPos = dstStartRow * dstWidth + dstStartColumn; [EOL]     for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) { [EOL]         System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length); [EOL]         srcPos += srcWidth; [EOL]         dstPos += dstWidth; [EOL]     } [EOL] } <line_num>: 772,785
@Override [EOL] public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws OutOfRangeException, NoDataException, NullArgumentException, DimensionMismatchException { [EOL]     MathUtils.checkNotNull(subMatrix); [EOL]     final int refLength = subMatrix[0].length; [EOL]     if (refLength == 0) { [EOL]         throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN); [EOL]     } [EOL]     final int endRow = row + subMatrix.length - 1; [EOL]     final int endColumn = column + refLength - 1; [EOL]     MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn); [EOL]     for (final double[] subRow : subMatrix) { [EOL]         if (subRow.length != refLength) { [EOL]             throw new DimensionMismatchException(refLength, subRow.length); [EOL]         } [EOL]     } [EOL]     final int blockStartRow = row / BLOCK_SIZE; [EOL]     final int blockEndRow = (endRow + BLOCK_SIZE) / BLOCK_SIZE; [EOL]     final int blockStartColumn = column / BLOCK_SIZE; [EOL]     final int blockEndColumn = (endColumn + BLOCK_SIZE) / BLOCK_SIZE; [EOL]     for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) { [EOL]         final int iHeight = blockHeight(iBlock); [EOL]         final int firstRow = iBlock * BLOCK_SIZE; [EOL]         final int iStart = FastMath.max(row, firstRow); [EOL]         final int iEnd = FastMath.min(endRow + 1, firstRow + iHeight); [EOL]         for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) { [EOL]             final int jWidth = blockWidth(jBlock); [EOL]             final int firstColumn = jBlock * BLOCK_SIZE; [EOL]             final int jStart = FastMath.max(column, firstColumn); [EOL]             final int jEnd = FastMath.min(endColumn + 1, firstColumn + jWidth); [EOL]             final int jLength = jEnd - jStart; [EOL]             final double[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]             for (int i = iStart; i < iEnd; ++i) { [EOL]                 System.arraycopy(subMatrix[i - row], jStart - column, block, (i - firstRow) * jWidth + (jStart - firstColumn), jLength); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 788,838
@Override [EOL] public BlockRealMatrix getRowMatrix(final int row) throws OutOfRangeException { [EOL]     MatrixUtils.checkRowIndex(this, row); [EOL]     final BlockRealMatrix out = new BlockRealMatrix(1, columns); [EOL]     final int iBlock = row / BLOCK_SIZE; [EOL]     final int iRow = row - iBlock * BLOCK_SIZE; [EOL]     int outBlockIndex = 0; [EOL]     int outIndex = 0; [EOL]     double[] outBlock = out.blocks[outBlockIndex]; [EOL]     for (int jBlock = 0; jBlock < blockColumns; ++jBlock) { [EOL]         final int jWidth = blockWidth(jBlock); [EOL]         final double[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]         final int available = outBlock.length - outIndex; [EOL]         if (jWidth > available) { [EOL]             System.arraycopy(block, iRow * jWidth, outBlock, outIndex, available); [EOL]             outBlock = out.blocks[++outBlockIndex]; [EOL]             System.arraycopy(block, iRow * jWidth, outBlock, 0, jWidth - available); [EOL]             outIndex = jWidth - available; [EOL]         } else { [EOL]             System.arraycopy(block, iRow * jWidth, outBlock, outIndex, jWidth); [EOL]             outIndex += jWidth; [EOL]         } [EOL]     } [EOL]     return out; [EOL] } <line_num>: 841,869
@Override [EOL] public void setRowMatrix(final int row, final RealMatrix matrix) throws OutOfRangeException, MatrixDimensionMismatchException { [EOL]     try { [EOL]         setRowMatrix(row, (BlockRealMatrix) matrix); [EOL]     } catch (ClassCastException cce) { [EOL]         super.setRowMatrix(row, matrix); [EOL]     } [EOL] } <line_num>: 872,880
public void setRowMatrix(final int row, final BlockRealMatrix matrix) throws OutOfRangeException, MatrixDimensionMismatchException { [EOL]     MatrixUtils.checkRowIndex(this, row); [EOL]     final int nCols = getColumnDimension(); [EOL]     if ((matrix.getRowDimension() != 1) || (matrix.getColumnDimension() != nCols)) { [EOL]         throw new MatrixDimensionMismatchException(matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols); [EOL]     } [EOL]     final int iBlock = row / BLOCK_SIZE; [EOL]     final int iRow = row - iBlock * BLOCK_SIZE; [EOL]     int mBlockIndex = 0; [EOL]     int mIndex = 0; [EOL]     double[] mBlock = matrix.blocks[mBlockIndex]; [EOL]     for (int jBlock = 0; jBlock < blockColumns; ++jBlock) { [EOL]         final int jWidth = blockWidth(jBlock); [EOL]         final double[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]         final int available = mBlock.length - mIndex; [EOL]         if (jWidth > available) { [EOL]             System.arraycopy(mBlock, mIndex, block, iRow * jWidth, available); [EOL]             mBlock = matrix.blocks[++mBlockIndex]; [EOL]             System.arraycopy(mBlock, 0, block, iRow * jWidth, jWidth - available); [EOL]             mIndex = jWidth - available; [EOL]         } else { [EOL]             System.arraycopy(mBlock, mIndex, block, iRow * jWidth, jWidth); [EOL]             mIndex += jWidth; [EOL]         } [EOL]     } [EOL] } <line_num>: 893,924
@Override [EOL] public BlockRealMatrix getColumnMatrix(final int column) throws OutOfRangeException { [EOL]     MatrixUtils.checkColumnIndex(this, column); [EOL]     final BlockRealMatrix out = new BlockRealMatrix(rows, 1); [EOL]     final int jBlock = column / BLOCK_SIZE; [EOL]     final int jColumn = column - jBlock * BLOCK_SIZE; [EOL]     final int jWidth = blockWidth(jBlock); [EOL]     int outBlockIndex = 0; [EOL]     int outIndex = 0; [EOL]     double[] outBlock = out.blocks[outBlockIndex]; [EOL]     for (int iBlock = 0; iBlock < blockRows; ++iBlock) { [EOL]         final int iHeight = blockHeight(iBlock); [EOL]         final double[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]         for (int i = 0; i < iHeight; ++i) { [EOL]             if (outIndex >= outBlock.length) { [EOL]                 outBlock = out.blocks[++outBlockIndex]; [EOL]                 outIndex = 0; [EOL]             } [EOL]             outBlock[outIndex++] = block[i * jWidth + jColumn]; [EOL]         } [EOL]     } [EOL]     return out; [EOL] } <line_num>: 927,953
@Override [EOL] public void setColumnMatrix(final int column, final RealMatrix matrix) throws OutOfRangeException, MatrixDimensionMismatchException { [EOL]     try { [EOL]         setColumnMatrix(column, (BlockRealMatrix) matrix); [EOL]     } catch (ClassCastException cce) { [EOL]         super.setColumnMatrix(column, matrix); [EOL]     } [EOL] } <line_num>: 956,964
void setColumnMatrix(final int column, final BlockRealMatrix matrix) throws OutOfRangeException, MatrixDimensionMismatchException { [EOL]     MatrixUtils.checkColumnIndex(this, column); [EOL]     final int nRows = getRowDimension(); [EOL]     if ((matrix.getRowDimension() != nRows) || (matrix.getColumnDimension() != 1)) { [EOL]         throw new MatrixDimensionMismatchException(matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1); [EOL]     } [EOL]     final int jBlock = column / BLOCK_SIZE; [EOL]     final int jColumn = column - jBlock * BLOCK_SIZE; [EOL]     final int jWidth = blockWidth(jBlock); [EOL]     int mBlockIndex = 0; [EOL]     int mIndex = 0; [EOL]     double[] mBlock = matrix.blocks[mBlockIndex]; [EOL]     for (int iBlock = 0; iBlock < blockRows; ++iBlock) { [EOL]         final int iHeight = blockHeight(iBlock); [EOL]         final double[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]         for (int i = 0; i < iHeight; ++i) { [EOL]             if (mIndex >= mBlock.length) { [EOL]                 mBlock = matrix.blocks[++mBlockIndex]; [EOL]                 mIndex = 0; [EOL]             } [EOL]             block[i * jWidth + jColumn] = mBlock[mIndex++]; [EOL]         } [EOL]     } [EOL] } <line_num>: 977,1006
@Override [EOL] public RealVector getRowVector(final int row) throws OutOfRangeException { [EOL]     MatrixUtils.checkRowIndex(this, row); [EOL]     final double[] outData = new double[columns]; [EOL]     final int iBlock = row / BLOCK_SIZE; [EOL]     final int iRow = row - iBlock * BLOCK_SIZE; [EOL]     int outIndex = 0; [EOL]     for (int jBlock = 0; jBlock < blockColumns; ++jBlock) { [EOL]         final int jWidth = blockWidth(jBlock); [EOL]         final double[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]         System.arraycopy(block, iRow * jWidth, outData, outIndex, jWidth); [EOL]         outIndex += jWidth; [EOL]     } [EOL]     return new ArrayRealVector(outData, false); [EOL] } <line_num>: 1009,1027
@Override [EOL] public void setRowVector(final int row, final RealVector vector) throws OutOfRangeException, MatrixDimensionMismatchException { [EOL]     try { [EOL]         setRow(row, ((ArrayRealVector) vector).getDataRef()); [EOL]     } catch (ClassCastException cce) { [EOL]         super.setRowVector(row, vector); [EOL]     } [EOL] } <line_num>: 1030,1038
@Override [EOL] public RealVector getColumnVector(final int column) throws OutOfRangeException { [EOL]     MatrixUtils.checkColumnIndex(this, column); [EOL]     final double[] outData = new double[rows]; [EOL]     final int jBlock = column / BLOCK_SIZE; [EOL]     final int jColumn = column - jBlock * BLOCK_SIZE; [EOL]     final int jWidth = blockWidth(jBlock); [EOL]     int outIndex = 0; [EOL]     for (int iBlock = 0; iBlock < blockRows; ++iBlock) { [EOL]         final int iHeight = blockHeight(iBlock); [EOL]         final double[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]         for (int i = 0; i < iHeight; ++i) { [EOL]             outData[outIndex++] = block[i * jWidth + jColumn]; [EOL]         } [EOL]     } [EOL]     return new ArrayRealVector(outData, false); [EOL] } <line_num>: 1041,1061
@Override [EOL] public void setColumnVector(final int column, final RealVector vector) throws OutOfRangeException, MatrixDimensionMismatchException { [EOL]     try { [EOL]         setColumn(column, ((ArrayRealVector) vector).getDataRef()); [EOL]     } catch (ClassCastException cce) { [EOL]         super.setColumnVector(column, vector); [EOL]     } [EOL] } <line_num>: 1064,1072
@Override [EOL] public double[] getRow(final int row) throws OutOfRangeException { [EOL]     MatrixUtils.checkRowIndex(this, row); [EOL]     final double[] out = new double[columns]; [EOL]     final int iBlock = row / BLOCK_SIZE; [EOL]     final int iRow = row - iBlock * BLOCK_SIZE; [EOL]     int outIndex = 0; [EOL]     for (int jBlock = 0; jBlock < blockColumns; ++jBlock) { [EOL]         final int jWidth = blockWidth(jBlock); [EOL]         final double[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]         System.arraycopy(block, iRow * jWidth, out, outIndex, jWidth); [EOL]         outIndex += jWidth; [EOL]     } [EOL]     return out; [EOL] } <line_num>: 1075,1092
@Override [EOL] public void setRow(final int row, final double[] array) throws OutOfRangeException, MatrixDimensionMismatchException { [EOL]     MatrixUtils.checkRowIndex(this, row); [EOL]     final int nCols = getColumnDimension(); [EOL]     if (array.length != nCols) { [EOL]         throw new MatrixDimensionMismatchException(1, array.length, 1, nCols); [EOL]     } [EOL]     final int iBlock = row / BLOCK_SIZE; [EOL]     final int iRow = row - iBlock * BLOCK_SIZE; [EOL]     int outIndex = 0; [EOL]     for (int jBlock = 0; jBlock < blockColumns; ++jBlock) { [EOL]         final int jWidth = blockWidth(jBlock); [EOL]         final double[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]         System.arraycopy(array, outIndex, block, iRow * jWidth, jWidth); [EOL]         outIndex += jWidth; [EOL]     } [EOL] } <line_num>: 1095,1114
@Override [EOL] public double[] getColumn(final int column) throws OutOfRangeException { [EOL]     MatrixUtils.checkColumnIndex(this, column); [EOL]     final double[] out = new double[rows]; [EOL]     final int jBlock = column / BLOCK_SIZE; [EOL]     final int jColumn = column - jBlock * BLOCK_SIZE; [EOL]     final int jWidth = blockWidth(jBlock); [EOL]     int outIndex = 0; [EOL]     for (int iBlock = 0; iBlock < blockRows; ++iBlock) { [EOL]         final int iHeight = blockHeight(iBlock); [EOL]         final double[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]         for (int i = 0; i < iHeight; ++i) { [EOL]             out[outIndex++] = block[i * jWidth + jColumn]; [EOL]         } [EOL]     } [EOL]     return out; [EOL] } <line_num>: 1117,1136
@Override [EOL] public void setColumn(final int column, final double[] array) throws OutOfRangeException, MatrixDimensionMismatchException { [EOL]     MatrixUtils.checkColumnIndex(this, column); [EOL]     final int nRows = getRowDimension(); [EOL]     if (array.length != nRows) { [EOL]         throw new MatrixDimensionMismatchException(array.length, 1, nRows, 1); [EOL]     } [EOL]     final int jBlock = column / BLOCK_SIZE; [EOL]     final int jColumn = column - jBlock * BLOCK_SIZE; [EOL]     final int jWidth = blockWidth(jBlock); [EOL]     int outIndex = 0; [EOL]     for (int iBlock = 0; iBlock < blockRows; ++iBlock) { [EOL]         final int iHeight = blockHeight(iBlock); [EOL]         final double[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]         for (int i = 0; i < iHeight; ++i) { [EOL]             block[i * jWidth + jColumn] = array[outIndex++]; [EOL]         } [EOL]     } [EOL] } <line_num>: 1139,1160
@Override [EOL] public double getEntry(final int row, final int column) throws OutOfRangeException { [EOL]     MatrixUtils.checkMatrixIndex(this, row, column); [EOL]     final int iBlock = row / BLOCK_SIZE; [EOL]     final int jBlock = column / BLOCK_SIZE; [EOL]     final int k = (row - iBlock * BLOCK_SIZE) * blockWidth(jBlock) + (column - jBlock * BLOCK_SIZE); [EOL]     return blocks[iBlock * blockColumns + jBlock][k]; [EOL] } <line_num>: 1163,1172
@Override [EOL] public void setEntry(final int row, final int column, final double value) throws OutOfRangeException { [EOL]     MatrixUtils.checkMatrixIndex(this, row, column); [EOL]     final int iBlock = row / BLOCK_SIZE; [EOL]     final int jBlock = column / BLOCK_SIZE; [EOL]     final int k = (row - iBlock * BLOCK_SIZE) * blockWidth(jBlock) + (column - jBlock * BLOCK_SIZE); [EOL]     blocks[iBlock * blockColumns + jBlock][k] = value; [EOL] } <line_num>: 1175,1184
@Override [EOL] public void addToEntry(final int row, final int column, final double increment) throws OutOfRangeException { [EOL]     MatrixUtils.checkMatrixIndex(this, row, column); [EOL]     final int iBlock = row / BLOCK_SIZE; [EOL]     final int jBlock = column / BLOCK_SIZE; [EOL]     final int k = (row - iBlock * BLOCK_SIZE) * blockWidth(jBlock) + (column - jBlock * BLOCK_SIZE); [EOL]     blocks[iBlock * blockColumns + jBlock][k] += increment; [EOL] } <line_num>: 1187,1197
@Override [EOL] public void multiplyEntry(final int row, final int column, final double factor) throws OutOfRangeException { [EOL]     MatrixUtils.checkMatrixIndex(this, row, column); [EOL]     final int iBlock = row / BLOCK_SIZE; [EOL]     final int jBlock = column / BLOCK_SIZE; [EOL]     final int k = (row - iBlock * BLOCK_SIZE) * blockWidth(jBlock) + (column - jBlock * BLOCK_SIZE); [EOL]     blocks[iBlock * blockColumns + jBlock][k] *= factor; [EOL] } <line_num>: 1200,1210
@Override [EOL] public BlockRealMatrix transpose() { [EOL]     final int nRows = getRowDimension(); [EOL]     final int nCols = getColumnDimension(); [EOL]     final BlockRealMatrix out = new BlockRealMatrix(nCols, nRows); [EOL]     int blockIndex = 0; [EOL]     for (int iBlock = 0; iBlock < blockColumns; ++iBlock) { [EOL]         for (int jBlock = 0; jBlock < blockRows; ++jBlock) { [EOL]             final double[] outBlock = out.blocks[blockIndex]; [EOL]             final double[] tBlock = blocks[jBlock * blockColumns + iBlock]; [EOL]             final int pStart = iBlock * BLOCK_SIZE; [EOL]             final int pEnd = FastMath.min(pStart + BLOCK_SIZE, columns); [EOL]             final int qStart = jBlock * BLOCK_SIZE; [EOL]             final int qEnd = FastMath.min(qStart + BLOCK_SIZE, rows); [EOL]             int k = 0; [EOL]             for (int p = pStart; p < pEnd; ++p) { [EOL]                 final int lInc = pEnd - pStart; [EOL]                 int l = p - pStart; [EOL]                 for (int q = qStart; q < qEnd; ++q) { [EOL]                     outBlock[k] = tBlock[l]; [EOL]                     ++k; [EOL]                     l += lInc; [EOL]                 } [EOL]             } [EOL]             ++blockIndex; [EOL]         } [EOL]     } [EOL]     return out; [EOL] } <line_num>: 1213,1246
@Override [EOL] public int getRowDimension() { [EOL]     return rows; [EOL] } <line_num>: 1249,1252
@Override [EOL] public int getColumnDimension() { [EOL]     return columns; [EOL] } <line_num>: 1255,1258
@Override [EOL] public double[] operate(final double[] v) throws DimensionMismatchException { [EOL]     if (v.length != columns) { [EOL]         throw new DimensionMismatchException(v.length, columns); [EOL]     } [EOL]     final double[] out = new double[rows]; [EOL]     for (int iBlock = 0; iBlock < blockRows; ++iBlock) { [EOL]         final int pStart = iBlock * BLOCK_SIZE; [EOL]         final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows); [EOL]         for (int jBlock = 0; jBlock < blockColumns; ++jBlock) { [EOL]             final double[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]             final int qStart = jBlock * BLOCK_SIZE; [EOL]             final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns); [EOL]             int k = 0; [EOL]             for (int p = pStart; p < pEnd; ++p) { [EOL]                 double sum = 0; [EOL]                 int q = qStart; [EOL]                 while (q < qEnd - 3) { [EOL]                     sum += block[k] * v[q] + block[k + 1] * v[q + 1] + block[k + 2] * v[q + 2] + block[k + 3] * v[q + 3]; [EOL]                     k += 4; [EOL]                     q += 4; [EOL]                 } [EOL]                 while (q < qEnd) { [EOL]                     sum += block[k++] * v[q++]; [EOL]                 } [EOL]                 out[p] += sum; [EOL]             } [EOL]         } [EOL]     } [EOL]     return out; [EOL] } <line_num>: 1261,1298
@Override [EOL] public double[] preMultiply(final double[] v) throws DimensionMismatchException { [EOL]     if (v.length != rows) { [EOL]         throw new DimensionMismatchException(v.length, rows); [EOL]     } [EOL]     final double[] out = new double[columns]; [EOL]     for (int jBlock = 0; jBlock < blockColumns; ++jBlock) { [EOL]         final int jWidth = blockWidth(jBlock); [EOL]         final int jWidth2 = jWidth + jWidth; [EOL]         final int jWidth3 = jWidth2 + jWidth; [EOL]         final int jWidth4 = jWidth3 + jWidth; [EOL]         final int qStart = jBlock * BLOCK_SIZE; [EOL]         final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns); [EOL]         for (int iBlock = 0; iBlock < blockRows; ++iBlock) { [EOL]             final double[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]             final int pStart = iBlock * BLOCK_SIZE; [EOL]             final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows); [EOL]             for (int q = qStart; q < qEnd; ++q) { [EOL]                 int k = q - qStart; [EOL]                 double sum = 0; [EOL]                 int p = pStart; [EOL]                 while (p < pEnd - 3) { [EOL]                     sum += block[k] * v[p] + block[k + jWidth] * v[p + 1] + block[k + jWidth2] * v[p + 2] + block[k + jWidth3] * v[p + 3]; [EOL]                     k += jWidth4; [EOL]                     p += 4; [EOL]                 } [EOL]                 while (p < pEnd) { [EOL]                     sum += block[k] * v[p++]; [EOL]                     k += jWidth; [EOL]                 } [EOL]                 out[q] += sum; [EOL]             } [EOL]         } [EOL]     } [EOL]     return out; [EOL] } <line_num>: 1301,1343
@Override [EOL] public double walkInRowOrder(final RealMatrixChangingVisitor visitor) { [EOL]     visitor.start(rows, columns, 0, rows - 1, 0, columns - 1); [EOL]     for (int iBlock = 0; iBlock < blockRows; ++iBlock) { [EOL]         final int pStart = iBlock * BLOCK_SIZE; [EOL]         final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows); [EOL]         for (int p = pStart; p < pEnd; ++p) { [EOL]             for (int jBlock = 0; jBlock < blockColumns; ++jBlock) { [EOL]                 final int jWidth = blockWidth(jBlock); [EOL]                 final int qStart = jBlock * BLOCK_SIZE; [EOL]                 final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns); [EOL]                 final double[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]                 int k = (p - pStart) * jWidth; [EOL]                 for (int q = qStart; q < qEnd; ++q) { [EOL]                     block[k] = visitor.visit(p, q, block[k]); [EOL]                     ++k; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 1346,1367
@Override [EOL] public double walkInRowOrder(final RealMatrixPreservingVisitor visitor) { [EOL]     visitor.start(rows, columns, 0, rows - 1, 0, columns - 1); [EOL]     for (int iBlock = 0; iBlock < blockRows; ++iBlock) { [EOL]         final int pStart = iBlock * BLOCK_SIZE; [EOL]         final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows); [EOL]         for (int p = pStart; p < pEnd; ++p) { [EOL]             for (int jBlock = 0; jBlock < blockColumns; ++jBlock) { [EOL]                 final int jWidth = blockWidth(jBlock); [EOL]                 final int qStart = jBlock * BLOCK_SIZE; [EOL]                 final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns); [EOL]                 final double[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]                 int k = (p - pStart) * jWidth; [EOL]                 for (int q = qStart; q < qEnd; ++q) { [EOL]                     visitor.visit(p, q, block[k]); [EOL]                     ++k; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 1370,1391
@Override [EOL] public double walkInRowOrder(final RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws OutOfRangeException, NumberIsTooSmallException { [EOL]     MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn); [EOL]     visitor.start(rows, columns, startRow, endRow, startColumn, endColumn); [EOL]     for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) { [EOL]         final int p0 = iBlock * BLOCK_SIZE; [EOL]         final int pStart = FastMath.max(startRow, p0); [EOL]         final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow); [EOL]         for (int p = pStart; p < pEnd; ++p) { [EOL]             for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) { [EOL]                 final int jWidth = blockWidth(jBlock); [EOL]                 final int q0 = jBlock * BLOCK_SIZE; [EOL]                 final int qStart = FastMath.max(startColumn, q0); [EOL]                 final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn); [EOL]                 final double[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]                 int k = (p - p0) * jWidth + qStart - q0; [EOL]                 for (int q = qStart; q < qEnd; ++q) { [EOL]                     block[k] = visitor.visit(p, q, block[k]); [EOL]                     ++k; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 1394,1421
@Override [EOL] public double walkInRowOrder(final RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws OutOfRangeException, NumberIsTooSmallException { [EOL]     MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn); [EOL]     visitor.start(rows, columns, startRow, endRow, startColumn, endColumn); [EOL]     for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) { [EOL]         final int p0 = iBlock * BLOCK_SIZE; [EOL]         final int pStart = FastMath.max(startRow, p0); [EOL]         final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow); [EOL]         for (int p = pStart; p < pEnd; ++p) { [EOL]             for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) { [EOL]                 final int jWidth = blockWidth(jBlock); [EOL]                 final int q0 = jBlock * BLOCK_SIZE; [EOL]                 final int qStart = FastMath.max(startColumn, q0); [EOL]                 final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn); [EOL]                 final double[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]                 int k = (p - p0) * jWidth + qStart - q0; [EOL]                 for (int q = qStart; q < qEnd; ++q) { [EOL]                     visitor.visit(p, q, block[k]); [EOL]                     ++k; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 1424,1451
@Override [EOL] public double walkInOptimizedOrder(final RealMatrixChangingVisitor visitor) { [EOL]     visitor.start(rows, columns, 0, rows - 1, 0, columns - 1); [EOL]     int blockIndex = 0; [EOL]     for (int iBlock = 0; iBlock < blockRows; ++iBlock) { [EOL]         final int pStart = iBlock * BLOCK_SIZE; [EOL]         final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows); [EOL]         for (int jBlock = 0; jBlock < blockColumns; ++jBlock) { [EOL]             final int qStart = jBlock * BLOCK_SIZE; [EOL]             final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns); [EOL]             final double[] block = blocks[blockIndex]; [EOL]             int k = 0; [EOL]             for (int p = pStart; p < pEnd; ++p) { [EOL]                 for (int q = qStart; q < qEnd; ++q) { [EOL]                     block[k] = visitor.visit(p, q, block[k]); [EOL]                     ++k; [EOL]                 } [EOL]             } [EOL]             ++blockIndex; [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 1454,1476
@Override [EOL] public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor) { [EOL]     visitor.start(rows, columns, 0, rows - 1, 0, columns - 1); [EOL]     int blockIndex = 0; [EOL]     for (int iBlock = 0; iBlock < blockRows; ++iBlock) { [EOL]         final int pStart = iBlock * BLOCK_SIZE; [EOL]         final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows); [EOL]         for (int jBlock = 0; jBlock < blockColumns; ++jBlock) { [EOL]             final int qStart = jBlock * BLOCK_SIZE; [EOL]             final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns); [EOL]             final double[] block = blocks[blockIndex]; [EOL]             int k = 0; [EOL]             for (int p = pStart; p < pEnd; ++p) { [EOL]                 for (int q = qStart; q < qEnd; ++q) { [EOL]                     visitor.visit(p, q, block[k]); [EOL]                     ++k; [EOL]                 } [EOL]             } [EOL]             ++blockIndex; [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 1479,1501
@Override [EOL] public double walkInOptimizedOrder(final RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws OutOfRangeException, NumberIsTooSmallException { [EOL]     MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn); [EOL]     visitor.start(rows, columns, startRow, endRow, startColumn, endColumn); [EOL]     for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) { [EOL]         final int p0 = iBlock * BLOCK_SIZE; [EOL]         final int pStart = FastMath.max(startRow, p0); [EOL]         final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow); [EOL]         for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) { [EOL]             final int jWidth = blockWidth(jBlock); [EOL]             final int q0 = jBlock * BLOCK_SIZE; [EOL]             final int qStart = FastMath.max(startColumn, q0); [EOL]             final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn); [EOL]             final double[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]             for (int p = pStart; p < pEnd; ++p) { [EOL]                 int k = (p - p0) * jWidth + qStart - q0; [EOL]                 for (int q = qStart; q < qEnd; ++q) { [EOL]                     block[k] = visitor.visit(p, q, block[k]); [EOL]                     ++k; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 1504,1532
@Override [EOL] public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws OutOfRangeException, NumberIsTooSmallException { [EOL]     MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn); [EOL]     visitor.start(rows, columns, startRow, endRow, startColumn, endColumn); [EOL]     for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) { [EOL]         final int p0 = iBlock * BLOCK_SIZE; [EOL]         final int pStart = FastMath.max(startRow, p0); [EOL]         final int pEnd = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow); [EOL]         for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) { [EOL]             final int jWidth = blockWidth(jBlock); [EOL]             final int q0 = jBlock * BLOCK_SIZE; [EOL]             final int qStart = FastMath.max(startColumn, q0); [EOL]             final int qEnd = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn); [EOL]             final double[] block = blocks[iBlock * blockColumns + jBlock]; [EOL]             for (int p = pStart; p < pEnd; ++p) { [EOL]                 int k = (p - p0) * jWidth + qStart - q0; [EOL]                 for (int q = qStart; q < qEnd; ++q) { [EOL]                     visitor.visit(p, q, block[k]); [EOL]                     ++k; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 1535,1563
private int blockHeight(final int blockRow) { [EOL]     return (blockRow == blockRows - 1) ? rows - blockRow * BLOCK_SIZE : BLOCK_SIZE; [EOL] } <line_num>: 1570,1572
private int blockWidth(final int blockColumn) { [EOL]     return (blockColumn == blockColumns - 1) ? columns - blockColumn * BLOCK_SIZE : BLOCK_SIZE; [EOL] } <line_num>: 1579,1581
