public SparseFieldVector(Field<T> field) { [EOL]     this(field, 0); [EOL] } <line_num>: 64,66
public SparseFieldVector(Field<T> field, int dimension) { [EOL]     this.field = field; [EOL]     virtualSize = dimension; [EOL]     entries = new OpenIntToFieldHashMap<T>(field); [EOL] } <line_num>: 75,79
protected SparseFieldVector(SparseFieldVector<T> v, int resize) { [EOL]     field = v.field; [EOL]     virtualSize = v.getDimension() + resize; [EOL]     entries = new OpenIntToFieldHashMap<T>(v.entries); [EOL] } <line_num>: 87,91
public SparseFieldVector(Field<T> field, int dimension, int expectedSize) { [EOL]     this.field = field; [EOL]     virtualSize = dimension; [EOL]     entries = new OpenIntToFieldHashMap<T>(field, expectedSize); [EOL] } <line_num>: 101,105
public SparseFieldVector(Field<T> field, T[] values) throws NullArgumentException { [EOL]     MathUtils.checkNotNull(values); [EOL]     this.field = field; [EOL]     virtualSize = values.length; [EOL]     entries = new OpenIntToFieldHashMap<T>(field); [EOL]     for (int key = 0; key < values.length; key++) { [EOL]         T value = values[key]; [EOL]         entries.put(key, value); [EOL]     } [EOL] } <line_num>: 115,124
public SparseFieldVector(SparseFieldVector<T> v) { [EOL]     field = v.field; [EOL]     virtualSize = v.getDimension(); [EOL]     entries = new OpenIntToFieldHashMap<T>(v.getEntries()); [EOL] } <line_num>: 131,135
private OpenIntToFieldHashMap<T> getEntries() { [EOL]     return entries; [EOL] } <line_num>: 142,144
public FieldVector<T> add(SparseFieldVector<T> v) throws DimensionMismatchException { [EOL]     checkVectorDimensions(v.getDimension()); [EOL]     SparseFieldVector<T> res = (SparseFieldVector<T>) copy(); [EOL]     OpenIntToFieldHashMap<T>.Iterator iter = v.getEntries().iterator(); [EOL]     while (iter.hasNext()) { [EOL]         iter.advance(); [EOL]         int key = iter.key(); [EOL]         T value = iter.value(); [EOL]         if (entries.containsKey(key)) { [EOL]             res.setEntry(key, entries.get(key).add(value)); [EOL]         } else { [EOL]             res.setEntry(key, value); [EOL]         } [EOL]     } [EOL]     return res; [EOL] } <line_num>: 154,171
public FieldVector<T> append(SparseFieldVector<T> v) { [EOL]     SparseFieldVector<T> res = new SparseFieldVector<T>(this, v.getDimension()); [EOL]     OpenIntToFieldHashMap<T>.Iterator iter = v.entries.iterator(); [EOL]     while (iter.hasNext()) { [EOL]         iter.advance(); [EOL]         res.setEntry(iter.key() + virtualSize, iter.value()); [EOL]     } [EOL]     return res; [EOL] } <line_num>: 179,187
public FieldVector<T> append(FieldVector<T> v) { [EOL]     if (v instanceof SparseFieldVector<?>) { [EOL]         return append((SparseFieldVector<T>) v); [EOL]     } else { [EOL]         final int n = v.getDimension(); [EOL]         FieldVector<T> res = new SparseFieldVector<T>(this, n); [EOL]         for (int i = 0; i < n; i++) { [EOL]             res.setEntry(i + virtualSize, v.getEntry(i)); [EOL]         } [EOL]         return res; [EOL]     } [EOL] } <line_num>: 190,201
public FieldVector<T> append(T d) throws NullArgumentException { [EOL]     MathUtils.checkNotNull(d); [EOL]     FieldVector<T> res = new SparseFieldVector<T>(this, 1); [EOL]     res.setEntry(virtualSize, d); [EOL]     return res; [EOL] } <line_num>: 206,211
public FieldVector<T> copy() { [EOL]     return new SparseFieldVector<T>(this); [EOL] } <line_num>: 214,216
public T dotProduct(FieldVector<T> v) throws DimensionMismatchException { [EOL]     checkVectorDimensions(v.getDimension()); [EOL]     T res = field.getZero(); [EOL]     OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator(); [EOL]     while (iter.hasNext()) { [EOL]         iter.advance(); [EOL]         res = res.add(v.getEntry(iter.key()).multiply(iter.value())); [EOL]     } [EOL]     return res; [EOL] } <line_num>: 219,228
public FieldVector<T> ebeDivide(FieldVector<T> v) throws DimensionMismatchException, MathArithmeticException { [EOL]     checkVectorDimensions(v.getDimension()); [EOL]     SparseFieldVector<T> res = new SparseFieldVector<T>(this); [EOL]     OpenIntToFieldHashMap<T>.Iterator iter = res.entries.iterator(); [EOL]     while (iter.hasNext()) { [EOL]         iter.advance(); [EOL]         res.setEntry(iter.key(), iter.value().divide(v.getEntry(iter.key()))); [EOL]     } [EOL]     return res; [EOL] } <line_num>: 231,241
public FieldVector<T> ebeMultiply(FieldVector<T> v) throws DimensionMismatchException { [EOL]     checkVectorDimensions(v.getDimension()); [EOL]     SparseFieldVector<T> res = new SparseFieldVector<T>(this); [EOL]     OpenIntToFieldHashMap<T>.Iterator iter = res.entries.iterator(); [EOL]     while (iter.hasNext()) { [EOL]         iter.advance(); [EOL]         res.setEntry(iter.key(), iter.value().multiply(v.getEntry(iter.key()))); [EOL]     } [EOL]     return res; [EOL] } <line_num>: 244,254
@Deprecated [EOL] public T[] getData() { [EOL]     return toArray(); [EOL] } <line_num>: 261,264
public int getDimension() { [EOL]     return virtualSize; [EOL] } <line_num>: 267,269
public T getEntry(int index) throws OutOfRangeException { [EOL]     checkIndex(index); [EOL]     return entries.get(index); [EOL] } <line_num>: 272,275
public Field<T> getField() { [EOL]     return field; [EOL] } <line_num>: 278,280
public FieldVector<T> getSubVector(int index, int n) throws OutOfRangeException, NotPositiveException { [EOL]     if (n < 0) { [EOL]         throw new NotPositiveException(LocalizedFormats.NUMBER_OF_ELEMENTS_SHOULD_BE_POSITIVE, n); [EOL]     } [EOL]     checkIndex(index); [EOL]     checkIndex(index + n - 1); [EOL]     SparseFieldVector<T> res = new SparseFieldVector<T>(field, n); [EOL]     int end = index + n; [EOL]     OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator(); [EOL]     while (iter.hasNext()) { [EOL]         iter.advance(); [EOL]         int key = iter.key(); [EOL]         if (key >= index && key < end) { [EOL]             res.setEntry(key - index, iter.value()); [EOL]         } [EOL]     } [EOL]     return res; [EOL] } <line_num>: 283,301
public FieldVector<T> mapAdd(T d) throws NullArgumentException { [EOL]     return copy().mapAddToSelf(d); [EOL] } <line_num>: 304,306
public FieldVector<T> mapAddToSelf(T d) throws NullArgumentException { [EOL]     for (int i = 0; i < virtualSize; i++) { [EOL]         setEntry(i, getEntry(i).add(d)); [EOL]     } [EOL]     return this; [EOL] } <line_num>: 309,314
public FieldVector<T> mapDivide(T d) throws NullArgumentException, MathArithmeticException { [EOL]     return copy().mapDivideToSelf(d); [EOL] } <line_num>: 317,320
public FieldVector<T> mapDivideToSelf(T d) throws NullArgumentException, MathArithmeticException { [EOL]     OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator(); [EOL]     while (iter.hasNext()) { [EOL]         iter.advance(); [EOL]         entries.put(iter.key(), iter.value().divide(d)); [EOL]     } [EOL]     return this; [EOL] } <line_num>: 323,331
public FieldVector<T> mapInv() throws MathArithmeticException { [EOL]     return copy().mapInvToSelf(); [EOL] } <line_num>: 334,336
public FieldVector<T> mapInvToSelf() throws MathArithmeticException { [EOL]     for (int i = 0; i < virtualSize; i++) { [EOL]         setEntry(i, field.getOne().divide(getEntry(i))); [EOL]     } [EOL]     return this; [EOL] } <line_num>: 339,344
public FieldVector<T> mapMultiply(T d) throws NullArgumentException { [EOL]     return copy().mapMultiplyToSelf(d); [EOL] } <line_num>: 347,349
public FieldVector<T> mapMultiplyToSelf(T d) throws NullArgumentException { [EOL]     OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator(); [EOL]     while (iter.hasNext()) { [EOL]         iter.advance(); [EOL]         entries.put(iter.key(), iter.value().multiply(d)); [EOL]     } [EOL]     return this; [EOL] } <line_num>: 352,359
public FieldVector<T> mapSubtract(T d) throws NullArgumentException { [EOL]     return copy().mapSubtractToSelf(d); [EOL] } <line_num>: 362,364
public FieldVector<T> mapSubtractToSelf(T d) throws NullArgumentException { [EOL]     return mapAddToSelf(field.getZero().subtract(d)); [EOL] } <line_num>: 367,369
public FieldMatrix<T> outerProduct(SparseFieldVector<T> v) { [EOL]     final int n = v.getDimension(); [EOL]     SparseFieldMatrix<T> res = new SparseFieldMatrix<T>(field, virtualSize, n); [EOL]     OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator(); [EOL]     while (iter.hasNext()) { [EOL]         iter.advance(); [EOL]         OpenIntToFieldHashMap<T>.Iterator iter2 = v.entries.iterator(); [EOL]         while (iter2.hasNext()) { [EOL]             iter2.advance(); [EOL]             res.setEntry(iter.key(), iter2.key(), iter.value().multiply(iter2.value())); [EOL]         } [EOL]     } [EOL]     return res; [EOL] } <line_num>: 376,389
public FieldMatrix<T> outerProduct(FieldVector<T> v) { [EOL]     if (v instanceof SparseFieldVector<?>) { [EOL]         return outerProduct((SparseFieldVector<T>) v); [EOL]     } else { [EOL]         final int n = v.getDimension(); [EOL]         FieldMatrix<T> res = new SparseFieldMatrix<T>(field, virtualSize, n); [EOL]         OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator(); [EOL]         while (iter.hasNext()) { [EOL]             iter.advance(); [EOL]             int row = iter.key(); [EOL]             FieldElement<T> value = iter.value(); [EOL]             for (int col = 0; col < n; col++) { [EOL]                 res.setEntry(row, col, value.multiply(v.getEntry(col))); [EOL]             } [EOL]         } [EOL]         return res; [EOL]     } [EOL] } <line_num>: 392,409
public FieldVector<T> projection(FieldVector<T> v) throws DimensionMismatchException, MathArithmeticException { [EOL]     checkVectorDimensions(v.getDimension()); [EOL]     return v.mapMultiply(dotProduct(v).divide(v.dotProduct(v))); [EOL] } <line_num>: 412,416
public void set(T value) { [EOL]     MathUtils.checkNotNull(value); [EOL]     for (int i = 0; i < virtualSize; i++) { [EOL]         setEntry(i, value); [EOL]     } [EOL] } <line_num>: 421,426
public void setEntry(int index, T value) throws NullArgumentException, OutOfRangeException { [EOL]     MathUtils.checkNotNull(value); [EOL]     checkIndex(index); [EOL]     entries.put(index, value); [EOL] } <line_num>: 431,435
public void setSubVector(int index, FieldVector<T> v) throws OutOfRangeException { [EOL]     checkIndex(index); [EOL]     checkIndex(index + v.getDimension() - 1); [EOL]     final int n = v.getDimension(); [EOL]     for (int i = 0; i < n; i++) { [EOL]         setEntry(i + index, v.getEntry(i)); [EOL]     } [EOL] } <line_num>: 438,446
public SparseFieldVector<T> subtract(SparseFieldVector<T> v) throws DimensionMismatchException { [EOL]     checkVectorDimensions(v.getDimension()); [EOL]     SparseFieldVector<T> res = (SparseFieldVector<T>) copy(); [EOL]     OpenIntToFieldHashMap<T>.Iterator iter = v.getEntries().iterator(); [EOL]     while (iter.hasNext()) { [EOL]         iter.advance(); [EOL]         int key = iter.key(); [EOL]         if (entries.containsKey(key)) { [EOL]             res.setEntry(key, entries.get(key).subtract(iter.value())); [EOL]         } else { [EOL]             res.setEntry(key, field.getZero().subtract(iter.value())); [EOL]         } [EOL]     } [EOL]     return res; [EOL] } <line_num>: 455,470
public FieldVector<T> subtract(FieldVector<T> v) throws DimensionMismatchException { [EOL]     if (v instanceof SparseFieldVector<?>) { [EOL]         return subtract((SparseFieldVector<T>) v); [EOL]     } else { [EOL]         final int n = v.getDimension(); [EOL]         checkVectorDimensions(n); [EOL]         SparseFieldVector<T> res = new SparseFieldVector<T>(this); [EOL]         for (int i = 0; i < n; i++) { [EOL]             if (entries.containsKey(i)) { [EOL]                 res.setEntry(i, entries.get(i).subtract(v.getEntry(i))); [EOL]             } else { [EOL]                 res.setEntry(i, field.getZero().subtract(v.getEntry(i))); [EOL]             } [EOL]         } [EOL]         return res; [EOL]     } [EOL] } <line_num>: 473,490
public T[] toArray() { [EOL]     T[] res = MathArrays.buildArray(field, virtualSize); [EOL]     OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator(); [EOL]     while (iter.hasNext()) { [EOL]         iter.advance(); [EOL]         res[iter.key()] = iter.value(); [EOL]     } [EOL]     return res; [EOL] } <line_num>: 493,501
private void checkIndex(final int index) throws OutOfRangeException { [EOL]     if (index < 0 || index >= getDimension()) { [EOL]         throw new OutOfRangeException(index, 0, getDimension() - 1); [EOL]     } [EOL] } <line_num>: 509,513
protected void checkVectorDimensions(int n) throws DimensionMismatchException { [EOL]     if (getDimension() != n) { [EOL]         throw new DimensionMismatchException(getDimension(), n); [EOL]     } [EOL] } <line_num>: 521,526
public FieldVector<T> add(FieldVector<T> v) throws DimensionMismatchException { [EOL]     if (v instanceof SparseFieldVector<?>) { [EOL]         return add((SparseFieldVector<T>) v); [EOL]     } else { [EOL]         final int n = v.getDimension(); [EOL]         checkVectorDimensions(n); [EOL]         SparseFieldVector<T> res = new SparseFieldVector<T>(field, getDimension()); [EOL]         for (int i = 0; i < n; i++) { [EOL]             res.setEntry(i, v.getEntry(i).add(getEntry(i))); [EOL]         } [EOL]         return res; [EOL]     } [EOL] } <line_num>: 529,542
@Override [EOL] public int hashCode() { [EOL]     final int prime = 31; [EOL]     int result = 1; [EOL]     result = prime * result + ((field == null) ? 0 : field.hashCode()); [EOL]     result = prime * result + virtualSize; [EOL]     OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator(); [EOL]     while (iter.hasNext()) { [EOL]         iter.advance(); [EOL]         int temp = iter.value().hashCode(); [EOL]         result = prime * result + temp; [EOL]     } [EOL]     return result; [EOL] } <line_num>: 545,558
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (!(obj instanceof SparseFieldVector<?>)) { [EOL]         return false; [EOL]     } [EOL]     @SuppressWarnings("unchecked") [EOL]     SparseFieldVector<T> other = (SparseFieldVector<T>) obj; [EOL]     if (field == null) { [EOL]         if (other.field != null) { [EOL]             return false; [EOL]         } [EOL]     } else if (!field.equals(other.field)) { [EOL]         return false; [EOL]     } [EOL]     if (virtualSize != other.virtualSize) { [EOL]         return false; [EOL]     } [EOL]     OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator(); [EOL]     while (iter.hasNext()) { [EOL]         iter.advance(); [EOL]         T test = other.getEntry(iter.key()); [EOL]         if (!test.equals(iter.value())) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     iter = other.getEntries().iterator(); [EOL]     while (iter.hasNext()) { [EOL]         iter.advance(); [EOL]         T test = iter.value(); [EOL]         if (!test.equals(getEntry(iter.key()))) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 562,604
