public Array2DRowFieldMatrix(final Field<T> field) { [EOL]     super(field); [EOL] } <line_num>: 58,60
public Array2DRowFieldMatrix(final Field<T> field, final int rowDimension, final int columnDimension) throws NotStrictlyPositiveException { [EOL]     super(field, rowDimension, columnDimension); [EOL]     data = MathArrays.buildArray(field, rowDimension, columnDimension); [EOL] } <line_num>: 70,75
public Array2DRowFieldMatrix(final T[][] d) throws DimensionMismatchException, NullArgumentException, NoDataException { [EOL]     this(extractField(d), d); [EOL] } <line_num>: 90,94
public Array2DRowFieldMatrix(final Field<T> field, final T[][] d) throws DimensionMismatchException, NullArgumentException, NoDataException { [EOL]     super(field); [EOL]     copyIn(d); [EOL] } <line_num>: 110,115
public Array2DRowFieldMatrix(final T[][] d, final boolean copyArray) throws DimensionMismatchException, NoDataException, NullArgumentException { [EOL]     this(extractField(d), d, copyArray); [EOL] } <line_num>: 132,136
public Array2DRowFieldMatrix(final Field<T> field, final T[][] d, final boolean copyArray) throws DimensionMismatchException, NoDataException, NullArgumentException { [EOL]     super(field); [EOL]     if (copyArray) { [EOL]         copyIn(d); [EOL]     } else { [EOL]         MathUtils.checkNotNull(d); [EOL]         final int nRows = d.length; [EOL]         if (nRows == 0) { [EOL]             throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW); [EOL]         } [EOL]         final int nCols = d[0].length; [EOL]         if (nCols == 0) { [EOL]             throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN); [EOL]         } [EOL]         for (int r = 1; r < nRows; r++) { [EOL]             if (d[r].length != nCols) { [EOL]                 throw new DimensionMismatchException(nCols, d[r].length); [EOL]             } [EOL]         } [EOL]         data = d; [EOL]     } [EOL] } <line_num>: 154,176
public Array2DRowFieldMatrix(final T[] v) throws NoDataException { [EOL]     this(extractField(v), v); [EOL] } <line_num>: 186,188
public Array2DRowFieldMatrix(final Field<T> field, final T[] v) { [EOL]     super(field); [EOL]     final int nRows = v.length; [EOL]     data = MathArrays.buildArray(getField(), nRows, 1); [EOL]     for (int row = 0; row < nRows; row++) { [EOL]         data[row][0] = v[row]; [EOL]     } [EOL] } <line_num>: 198,205
@Override [EOL] public FieldMatrix<T> createMatrix(final int rowDimension, final int columnDimension) throws NotStrictlyPositiveException { [EOL]     return new Array2DRowFieldMatrix<T>(getField(), rowDimension, columnDimension); [EOL] } <line_num>: 208,213
@Override [EOL] public FieldMatrix<T> copy() { [EOL]     return new Array2DRowFieldMatrix<T>(getField(), copyOut(), false); [EOL] } <line_num>: 216,219
public Array2DRowFieldMatrix<T> add(final Array2DRowFieldMatrix<T> m) throws MatrixDimensionMismatchException { [EOL]     checkAdditionCompatible(m); [EOL]     final int rowCount = getRowDimension(); [EOL]     final int columnCount = getColumnDimension(); [EOL]     final T[][] outData = MathArrays.buildArray(getField(), rowCount, columnCount); [EOL]     for (int row = 0; row < rowCount; row++) { [EOL]         final T[] dataRow = data[row]; [EOL]         final T[] mRow = m.data[row]; [EOL]         final T[] outDataRow = outData[row]; [EOL]         for (int col = 0; col < columnCount; col++) { [EOL]             outDataRow[col] = dataRow[col].add(mRow[col]); [EOL]         } [EOL]     } [EOL]     return new Array2DRowFieldMatrix<T>(getField(), outData, false); [EOL] } <line_num>: 229,247
public Array2DRowFieldMatrix<T> subtract(final Array2DRowFieldMatrix<T> m) throws MatrixDimensionMismatchException { [EOL]     checkSubtractionCompatible(m); [EOL]     final int rowCount = getRowDimension(); [EOL]     final int columnCount = getColumnDimension(); [EOL]     final T[][] outData = MathArrays.buildArray(getField(), rowCount, columnCount); [EOL]     for (int row = 0; row < rowCount; row++) { [EOL]         final T[] dataRow = data[row]; [EOL]         final T[] mRow = m.data[row]; [EOL]         final T[] outDataRow = outData[row]; [EOL]         for (int col = 0; col < columnCount; col++) { [EOL]             outDataRow[col] = dataRow[col].subtract(mRow[col]); [EOL]         } [EOL]     } [EOL]     return new Array2DRowFieldMatrix<T>(getField(), outData, false); [EOL] } <line_num>: 257,276
public Array2DRowFieldMatrix<T> multiply(final Array2DRowFieldMatrix<T> m) throws DimensionMismatchException { [EOL]     checkMultiplicationCompatible(m); [EOL]     final int nRows = this.getRowDimension(); [EOL]     final int nCols = m.getColumnDimension(); [EOL]     final int nSum = this.getColumnDimension(); [EOL]     final T[][] outData = MathArrays.buildArray(getField(), nRows, nCols); [EOL]     for (int row = 0; row < nRows; row++) { [EOL]         final T[] dataRow = data[row]; [EOL]         final T[] outDataRow = outData[row]; [EOL]         for (int col = 0; col < nCols; col++) { [EOL]             T sum = getField().getZero(); [EOL]             for (int i = 0; i < nSum; i++) { [EOL]                 sum = sum.add(dataRow[i].multiply(m.data[i][col])); [EOL]             } [EOL]             outDataRow[col] = sum; [EOL]         } [EOL]     } [EOL]     return new Array2DRowFieldMatrix<T>(getField(), outData, false); [EOL] } <line_num>: 286,309
@Override [EOL] public T[][] getData() { [EOL]     return copyOut(); [EOL] } <line_num>: 312,315
public T[][] getDataRef() { [EOL]     return data; [EOL] } <line_num>: 323,325
@Override [EOL] public void setSubMatrix(final T[][] subMatrix, final int row, final int column) throws OutOfRangeException, NullArgumentException, NoDataException, DimensionMismatchException { [EOL]     if (data == null) { [EOL]         if (row > 0) { [EOL]             throw new MathIllegalStateException(LocalizedFormats.FIRST_ROWS_NOT_INITIALIZED_YET, row); [EOL]         } [EOL]         if (column > 0) { [EOL]             throw new MathIllegalStateException(LocalizedFormats.FIRST_COLUMNS_NOT_INITIALIZED_YET, column); [EOL]         } [EOL]         final int nRows = subMatrix.length; [EOL]         if (nRows == 0) { [EOL]             throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW); [EOL]         } [EOL]         final int nCols = subMatrix[0].length; [EOL]         if (nCols == 0) { [EOL]             throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN); [EOL]         } [EOL]         data = MathArrays.buildArray(getField(), subMatrix.length, nCols); [EOL]         for (int i = 0; i < data.length; ++i) { [EOL]             if (subMatrix[i].length != nCols) { [EOL]                 throw new DimensionMismatchException(nCols, subMatrix[i].length); [EOL]             } [EOL]             System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols); [EOL]         } [EOL]     } else { [EOL]         super.setSubMatrix(subMatrix, row, column); [EOL]     } [EOL] } <line_num>: 328,360
@Override [EOL] public T getEntry(final int row, final int column) throws OutOfRangeException { [EOL]     checkRowIndex(row); [EOL]     checkColumnIndex(column); [EOL]     return data[row][column]; [EOL] } <line_num>: 363,370
@Override [EOL] public void setEntry(final int row, final int column, final T value) throws OutOfRangeException { [EOL]     checkRowIndex(row); [EOL]     checkColumnIndex(column); [EOL]     data[row][column] = value; [EOL] } <line_num>: 373,380
@Override [EOL] public void addToEntry(final int row, final int column, final T increment) throws OutOfRangeException { [EOL]     checkRowIndex(row); [EOL]     checkColumnIndex(column); [EOL]     data[row][column] = data[row][column].add(increment); [EOL] } <line_num>: 383,390
@Override [EOL] public void multiplyEntry(final int row, final int column, final T factor) throws OutOfRangeException { [EOL]     checkRowIndex(row); [EOL]     checkColumnIndex(column); [EOL]     data[row][column] = data[row][column].multiply(factor); [EOL] } <line_num>: 393,400
@Override [EOL] public int getRowDimension() { [EOL]     return (data == null) ? 0 : data.length; [EOL] } <line_num>: 403,406
@Override [EOL] public int getColumnDimension() { [EOL]     return ((data == null) || (data[0] == null)) ? 0 : data[0].length; [EOL] } <line_num>: 409,412
@Override [EOL] public T[] operate(final T[] v) throws DimensionMismatchException { [EOL]     final int nRows = this.getRowDimension(); [EOL]     final int nCols = this.getColumnDimension(); [EOL]     if (v.length != nCols) { [EOL]         throw new DimensionMismatchException(v.length, nCols); [EOL]     } [EOL]     final T[] out = MathArrays.buildArray(getField(), nRows); [EOL]     for (int row = 0; row < nRows; row++) { [EOL]         final T[] dataRow = data[row]; [EOL]         T sum = getField().getZero(); [EOL]         for (int i = 0; i < nCols; i++) { [EOL]             sum = sum.add(dataRow[i].multiply(v[i])); [EOL]         } [EOL]         out[row] = sum; [EOL]     } [EOL]     return out; [EOL] } <line_num>: 415,432
@Override [EOL] public T[] preMultiply(final T[] v) throws DimensionMismatchException { [EOL]     final int nRows = getRowDimension(); [EOL]     final int nCols = getColumnDimension(); [EOL]     if (v.length != nRows) { [EOL]         throw new DimensionMismatchException(v.length, nRows); [EOL]     } [EOL]     final T[] out = MathArrays.buildArray(getField(), nCols); [EOL]     for (int col = 0; col < nCols; ++col) { [EOL]         T sum = getField().getZero(); [EOL]         for (int i = 0; i < nRows; ++i) { [EOL]             sum = sum.add(data[i][col].multiply(v[i])); [EOL]         } [EOL]         out[col] = sum; [EOL]     } [EOL]     return out; [EOL] } <line_num>: 435,453
@Override [EOL] public T walkInRowOrder(final FieldMatrixChangingVisitor<T> visitor) { [EOL]     final int rows = getRowDimension(); [EOL]     final int columns = getColumnDimension(); [EOL]     visitor.start(rows, columns, 0, rows - 1, 0, columns - 1); [EOL]     for (int i = 0; i < rows; ++i) { [EOL]         final T[] rowI = data[i]; [EOL]         for (int j = 0; j < columns; ++j) { [EOL]             rowI[j] = visitor.visit(i, j, rowI[j]); [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 456,468
@Override [EOL] public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor) { [EOL]     final int rows = getRowDimension(); [EOL]     final int columns = getColumnDimension(); [EOL]     visitor.start(rows, columns, 0, rows - 1, 0, columns - 1); [EOL]     for (int i = 0; i < rows; ++i) { [EOL]         final T[] rowI = data[i]; [EOL]         for (int j = 0; j < columns; ++j) { [EOL]             visitor.visit(i, j, rowI[j]); [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 471,483
@Override [EOL] public T walkInRowOrder(final FieldMatrixChangingVisitor<T> visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws OutOfRangeException, NumberIsTooSmallException { [EOL]     checkSubMatrixIndex(startRow, endRow, startColumn, endColumn); [EOL]     visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn); [EOL]     for (int i = startRow; i <= endRow; ++i) { [EOL]         final T[] rowI = data[i]; [EOL]         for (int j = startColumn; j <= endColumn; ++j) { [EOL]             rowI[j] = visitor.visit(i, j, rowI[j]); [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 486,501
@Override [EOL] public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws OutOfRangeException, NumberIsTooSmallException { [EOL]     checkSubMatrixIndex(startRow, endRow, startColumn, endColumn); [EOL]     visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn); [EOL]     for (int i = startRow; i <= endRow; ++i) { [EOL]         final T[] rowI = data[i]; [EOL]         for (int j = startColumn; j <= endColumn; ++j) { [EOL]             visitor.visit(i, j, rowI[j]); [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 504,519
@Override [EOL] public T walkInColumnOrder(final FieldMatrixChangingVisitor<T> visitor) { [EOL]     final int rows = getRowDimension(); [EOL]     final int columns = getColumnDimension(); [EOL]     visitor.start(rows, columns, 0, rows - 1, 0, columns - 1); [EOL]     for (int j = 0; j < columns; ++j) { [EOL]         for (int i = 0; i < rows; ++i) { [EOL]             final T[] rowI = data[i]; [EOL]             rowI[j] = visitor.visit(i, j, rowI[j]); [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 522,534
@Override [EOL] public T walkInColumnOrder(final FieldMatrixPreservingVisitor<T> visitor) { [EOL]     final int rows = getRowDimension(); [EOL]     final int columns = getColumnDimension(); [EOL]     visitor.start(rows, columns, 0, rows - 1, 0, columns - 1); [EOL]     for (int j = 0; j < columns; ++j) { [EOL]         for (int i = 0; i < rows; ++i) { [EOL]             visitor.visit(i, j, data[i][j]); [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 537,548
@Override [EOL] public T walkInColumnOrder(final FieldMatrixChangingVisitor<T> visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws OutOfRangeException, NumberIsTooSmallException { [EOL]     checkSubMatrixIndex(startRow, endRow, startColumn, endColumn); [EOL]     visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn); [EOL]     for (int j = startColumn; j <= endColumn; ++j) { [EOL]         for (int i = startRow; i <= endRow; ++i) { [EOL]             final T[] rowI = data[i]; [EOL]             rowI[j] = visitor.visit(i, j, rowI[j]); [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 551,566
@Override [EOL] public T walkInColumnOrder(final FieldMatrixPreservingVisitor<T> visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws OutOfRangeException, NumberIsTooSmallException { [EOL]     checkSubMatrixIndex(startRow, endRow, startColumn, endColumn); [EOL]     visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn); [EOL]     for (int j = startColumn; j <= endColumn; ++j) { [EOL]         for (int i = startRow; i <= endRow; ++i) { [EOL]             visitor.visit(i, j, data[i][j]); [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 569,583
private T[][] copyOut() { [EOL]     final int nRows = this.getRowDimension(); [EOL]     final T[][] out = MathArrays.buildArray(getField(), nRows, getColumnDimension()); [EOL]     for (int i = 0; i < nRows; i++) { [EOL]         System.arraycopy(data[i], 0, out[i], 0, data[i].length); [EOL]     } [EOL]     return out; [EOL] } <line_num>: 590,598
private void copyIn(final T[][] in) throws NullArgumentException, NoDataException, DimensionMismatchException { [EOL]     setSubMatrix(in, 0, 0); [EOL] } <line_num>: 608,612
