public EigenDecomposition(final RealMatrix matrix) throws MathArithmeticException { [EOL]     final double symTol = 10 * matrix.getRowDimension() * matrix.getColumnDimension() * Precision.EPSILON; [EOL]     isSymmetric = MatrixUtils.isSymmetric(matrix, symTol); [EOL]     if (isSymmetric) { [EOL]         transformToTridiagonal(matrix); [EOL]         findEigenVectors(transformer.getQ().getData()); [EOL]     } else { [EOL]         final SchurTransformer t = transformToSchur(matrix); [EOL]         findEigenVectorsFromSchur(t); [EOL]     } [EOL] } <line_num>: 117,128
@Deprecated [EOL] public EigenDecomposition(final RealMatrix matrix, final double splitTolerance) throws MathArithmeticException { [EOL]     this(matrix); [EOL] } <line_num>: 141,146
public EigenDecomposition(final double[] main, final double[] secondary) { [EOL]     isSymmetric = true; [EOL]     this.main = main.clone(); [EOL]     this.secondary = secondary.clone(); [EOL]     transformer = null; [EOL]     final int size = main.length; [EOL]     final double[][] z = new double[size][size]; [EOL]     for (int i = 0; i < size; i++) { [EOL]         z[i][i] = 1.0; [EOL]     } [EOL]     findEigenVectors(z); [EOL] } <line_num>: 157,168
@Deprecated [EOL] public EigenDecomposition(final double[] main, final double[] secondary, final double splitTolerance) { [EOL]     this(main, secondary); [EOL] } <line_num>: 181,185
private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final ArrayRealVector[] eigenvectors) { [EOL]     this.realEigenvalues = realEigenvalues; [EOL]     this.imagEigenvalues = imagEigenvalues; [EOL]     this.eigenvectors = eigenvectors; [EOL] } <line_num>: 428,434
public RealMatrix getV() { [EOL]     if (cachedV == null) { [EOL]         final int m = eigenvectors.length; [EOL]         cachedV = MatrixUtils.createRealMatrix(m, m); [EOL]         for (int k = 0; k < m; ++k) { [EOL]             cachedV.setColumnVector(k, eigenvectors[k]); [EOL]         } [EOL]     } [EOL]     return cachedV; [EOL] } <line_num>: 197,208
public RealMatrix getD() { [EOL]     if (cachedD == null) { [EOL]         cachedD = MatrixUtils.createRealDiagonalMatrix(realEigenvalues); [EOL]         for (int i = 0; i < imagEigenvalues.length; i++) { [EOL]             if (Precision.compareTo(imagEigenvalues[i], 0.0, EPSILON) > 0) { [EOL]                 cachedD.setEntry(i, i + 1, imagEigenvalues[i]); [EOL]             } else if (Precision.compareTo(imagEigenvalues[i], 0.0, EPSILON) < 0) { [EOL]                 cachedD.setEntry(i, i - 1, imagEigenvalues[i]); [EOL]             } [EOL]         } [EOL]     } [EOL]     return cachedD; [EOL] } <line_num>: 221,236
public RealMatrix getVT() { [EOL]     if (cachedVt == null) { [EOL]         final int m = eigenvectors.length; [EOL]         cachedVt = MatrixUtils.createRealMatrix(m, m); [EOL]         for (int k = 0; k < m; ++k) { [EOL]             cachedVt.setRowVector(k, eigenvectors[k]); [EOL]         } [EOL]     } [EOL]     return cachedVt; [EOL] } <line_num>: 248,260
public boolean hasComplexEigenvalues() { [EOL]     for (int i = 0; i < imagEigenvalues.length; i++) { [EOL]         if (!Precision.equals(imagEigenvalues[i], 0.0, EPSILON)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 271,278
public double[] getRealEigenvalues() { [EOL]     return realEigenvalues.clone(); [EOL] } <line_num>: 289,291
public double getRealEigenvalue(final int i) { [EOL]     return realEigenvalues[i]; [EOL] } <line_num>: 305,307
public double[] getImagEigenvalues() { [EOL]     return imagEigenvalues.clone(); [EOL] } <line_num>: 320,322
public double getImagEigenvalue(final int i) { [EOL]     return imagEigenvalues[i]; [EOL] } <line_num>: 336,338
public RealVector getEigenvector(final int i) { [EOL]     return eigenvectors[i].copy(); [EOL] } <line_num>: 347,349
public double getDeterminant() { [EOL]     double determinant = 1; [EOL]     for (double lambda : realEigenvalues) { [EOL]         determinant *= lambda; [EOL]     } [EOL]     return determinant; [EOL] } <line_num>: 356,362
public RealMatrix getSquareRoot() { [EOL]     if (!isSymmetric) { [EOL]         throw new MathUnsupportedOperationException(); [EOL]     } [EOL]     final double[] sqrtEigenValues = new double[realEigenvalues.length]; [EOL]     for (int i = 0; i < realEigenvalues.length; i++) { [EOL]         final double eigen = realEigenvalues[i]; [EOL]         if (eigen <= 0) { [EOL]             throw new MathUnsupportedOperationException(); [EOL]         } [EOL]         sqrtEigenValues[i] = FastMath.sqrt(eigen); [EOL]     } [EOL]     final RealMatrix sqrtEigen = MatrixUtils.createRealDiagonalMatrix(sqrtEigenValues); [EOL]     final RealMatrix v = getV(); [EOL]     final RealMatrix vT = getVT(); [EOL]     return v.multiply(sqrtEigen).multiply(vT); [EOL] } <line_num>: 374,392
public DecompositionSolver getSolver() { [EOL]     if (hasComplexEigenvalues()) { [EOL]         throw new MathUnsupportedOperationException(); [EOL]     } [EOL]     return new Solver(realEigenvalues, imagEigenvalues, eigenvectors); [EOL] } <line_num>: 405,410
public RealVector solve(final RealVector b) { [EOL]     if (!isNonSingular()) { [EOL]         throw new SingularMatrixException(); [EOL]     } [EOL]     final int m = realEigenvalues.length; [EOL]     if (b.getDimension() != m) { [EOL]         throw new DimensionMismatchException(b.getDimension(), m); [EOL]     } [EOL]     final double[] bp = new double[m]; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         final ArrayRealVector v = eigenvectors[i]; [EOL]         final double[] vData = v.getDataRef(); [EOL]         final double s = v.dotProduct(b) / realEigenvalues[i]; [EOL]         for (int j = 0; j < m; ++j) { [EOL]             bp[j] += s * vData[j]; [EOL]         } [EOL]     } [EOL]     return new ArrayRealVector(bp, false); [EOL] } <line_num>: 449,470
public RealMatrix solve(RealMatrix b) { [EOL]     if (!isNonSingular()) { [EOL]         throw new SingularMatrixException(); [EOL]     } [EOL]     final int m = realEigenvalues.length; [EOL]     if (b.getRowDimension() != m) { [EOL]         throw new DimensionMismatchException(b.getRowDimension(), m); [EOL]     } [EOL]     final int nColB = b.getColumnDimension(); [EOL]     final double[][] bp = new double[m][nColB]; [EOL]     final double[] tmpCol = new double[m]; [EOL]     for (int k = 0; k < nColB; ++k) { [EOL]         for (int i = 0; i < m; ++i) { [EOL]             tmpCol[i] = b.getEntry(i, k); [EOL]             bp[i][k] = 0; [EOL]         } [EOL]         for (int i = 0; i < m; ++i) { [EOL]             final ArrayRealVector v = eigenvectors[i]; [EOL]             final double[] vData = v.getDataRef(); [EOL]             double s = 0; [EOL]             for (int j = 0; j < m; ++j) { [EOL]                 s += v.getEntry(j) * tmpCol[j]; [EOL]             } [EOL]             s /= realEigenvalues[i]; [EOL]             for (int j = 0; j < m; ++j) { [EOL]                 bp[j][k] += s * vData[j]; [EOL]             } [EOL]         } [EOL]     } [EOL]     return new Array2DRowRealMatrix(bp, false); [EOL] } <line_num>: 473,508
public boolean isNonSingular() { [EOL]     for (int i = 0; i < realEigenvalues.length; ++i) { [EOL]         if (realEigenvalues[i] == 0 && imagEigenvalues[i] == 0) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 515,523
public RealMatrix getInverse() { [EOL]     if (!isNonSingular()) { [EOL]         throw new SingularMatrixException(); [EOL]     } [EOL]     final int m = realEigenvalues.length; [EOL]     final double[][] invData = new double[m][m]; [EOL]     for (int i = 0; i < m; ++i) { [EOL]         final double[] invI = invData[i]; [EOL]         for (int j = 0; j < m; ++j) { [EOL]             double invIJ = 0; [EOL]             for (int k = 0; k < m; ++k) { [EOL]                 final double[] vK = eigenvectors[k].getDataRef(); [EOL]                 invIJ += vK[i] * vK[j] / realEigenvalues[k]; [EOL]             } [EOL]             invI[j] = invIJ; [EOL]         } [EOL]     } [EOL]     return MatrixUtils.createRealMatrix(invData); [EOL] } <line_num>: 531,551
private void transformToTridiagonal(final RealMatrix matrix) { [EOL]     transformer = new TriDiagonalTransformer(matrix); [EOL]     main = transformer.getMainDiagonalRef(); [EOL]     secondary = transformer.getSecondaryDiagonalRef(); [EOL] } <line_num>: 559,564
private void findEigenVectors(final double[][] householderMatrix) { [EOL]     final double[][] z = householderMatrix.clone(); [EOL]     final int n = main.length; [EOL]     realEigenvalues = new double[n]; [EOL]     imagEigenvalues = new double[n]; [EOL]     final double[] e = new double[n]; [EOL]     for (int i = 0; i < n - 1; i++) { [EOL]         realEigenvalues[i] = main[i]; [EOL]         e[i] = secondary[i]; [EOL]     } [EOL]     realEigenvalues[n - 1] = main[n - 1]; [EOL]     e[n - 1] = 0; [EOL]     double maxAbsoluteValue = 0; [EOL]     for (int i = 0; i < n; i++) { [EOL]         if (FastMath.abs(realEigenvalues[i]) > maxAbsoluteValue) { [EOL]             maxAbsoluteValue = FastMath.abs(realEigenvalues[i]); [EOL]         } [EOL]         if (FastMath.abs(e[i]) > maxAbsoluteValue) { [EOL]             maxAbsoluteValue = FastMath.abs(e[i]); [EOL]         } [EOL]     } [EOL]     if (maxAbsoluteValue != 0) { [EOL]         for (int i = 0; i < n; i++) { [EOL]             if (FastMath.abs(realEigenvalues[i]) <= Precision.EPSILON * maxAbsoluteValue) { [EOL]                 realEigenvalues[i] = 0; [EOL]             } [EOL]             if (FastMath.abs(e[i]) <= Precision.EPSILON * maxAbsoluteValue) { [EOL]                 e[i] = 0; [EOL]             } [EOL]         } [EOL]     } [EOL]     for (int j = 0; j < n; j++) { [EOL]         int its = 0; [EOL]         int m; [EOL]         do { [EOL]             for (m = j; m < n - 1; m++) { [EOL]                 double delta = FastMath.abs(realEigenvalues[m]) + FastMath.abs(realEigenvalues[m + 1]); [EOL]                 if (FastMath.abs(e[m]) + delta == delta) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             if (m != j) { [EOL]                 if (its == maxIter) { [EOL]                     throw new MaxCountExceededException(LocalizedFormats.CONVERGENCE_FAILED, maxIter); [EOL]                 } [EOL]                 its++; [EOL]                 double q = (realEigenvalues[j + 1] - realEigenvalues[j]) / (2 * e[j]); [EOL]                 double t = FastMath.sqrt(1 + q * q); [EOL]                 if (q < 0.0) { [EOL]                     q = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q - t); [EOL]                 } else { [EOL]                     q = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q + t); [EOL]                 } [EOL]                 double u = 0.0; [EOL]                 double s = 1.0; [EOL]                 double c = 1.0; [EOL]                 int i; [EOL]                 for (i = m - 1; i >= j; i--) { [EOL]                     double p = s * e[i]; [EOL]                     double h = c * e[i]; [EOL]                     if (FastMath.abs(p) >= FastMath.abs(q)) { [EOL]                         c = q / p; [EOL]                         t = FastMath.sqrt(c * c + 1.0); [EOL]                         e[i + 1] = p * t; [EOL]                         s = 1.0 / t; [EOL]                         c = c * s; [EOL]                     } else { [EOL]                         s = p / q; [EOL]                         t = FastMath.sqrt(s * s + 1.0); [EOL]                         e[i + 1] = q * t; [EOL]                         c = 1.0 / t; [EOL]                         s = s * c; [EOL]                     } [EOL]                     if (e[i + 1] == 0.0) { [EOL]                         realEigenvalues[i + 1] -= u; [EOL]                         e[m] = 0.0; [EOL]                         break; [EOL]                     } [EOL]                     q = realEigenvalues[i + 1] - u; [EOL]                     t = (realEigenvalues[i] - q) * s + 2.0 * c * h; [EOL]                     u = s * t; [EOL]                     realEigenvalues[i + 1] = q + u; [EOL]                     q = c * t - h; [EOL]                     for (int ia = 0; ia < n; ia++) { [EOL]                         p = z[ia][i + 1]; [EOL]                         z[ia][i + 1] = s * z[ia][i] + c * p; [EOL]                         z[ia][i] = c * z[ia][i] - s * p; [EOL]                     } [EOL]                 } [EOL]                 if (t == 0.0 && i >= j) { [EOL]                     continue; [EOL]                 } [EOL]                 realEigenvalues[j] -= u; [EOL]                 e[j] = q; [EOL]                 e[m] = 0.0; [EOL]             } [EOL]         } while (m != j); [EOL]     } [EOL]     for (int i = 0; i < n; i++) { [EOL]         int k = i; [EOL]         double p = realEigenvalues[i]; [EOL]         for (int j = i + 1; j < n; j++) { [EOL]             if (realEigenvalues[j] > p) { [EOL]                 k = j; [EOL]                 p = realEigenvalues[j]; [EOL]             } [EOL]         } [EOL]         if (k != i) { [EOL]             realEigenvalues[k] = realEigenvalues[i]; [EOL]             realEigenvalues[i] = p; [EOL]             for (int j = 0; j < n; j++) { [EOL]                 p = z[j][i]; [EOL]                 z[j][i] = z[j][k]; [EOL]                 z[j][k] = p; [EOL]             } [EOL]         } [EOL]     } [EOL]     maxAbsoluteValue = 0; [EOL]     for (int i = 0; i < n; i++) { [EOL]         if (FastMath.abs(realEigenvalues[i]) > maxAbsoluteValue) { [EOL]             maxAbsoluteValue = FastMath.abs(realEigenvalues[i]); [EOL]         } [EOL]     } [EOL]     if (maxAbsoluteValue != 0.0) { [EOL]         for (int i = 0; i < n; i++) { [EOL]             if (FastMath.abs(realEigenvalues[i]) < Precision.EPSILON * maxAbsoluteValue) { [EOL]                 realEigenvalues[i] = 0; [EOL]             } [EOL]         } [EOL]     } [EOL]     eigenvectors = new ArrayRealVector[n]; [EOL]     final double[] tmp = new double[n]; [EOL]     for (int i = 0; i < n; i++) { [EOL]         for (int j = 0; j < n; j++) { [EOL]             tmp[j] = z[j][i]; [EOL]         } [EOL]         eigenvectors[i] = new ArrayRealVector(tmp); [EOL]     } [EOL] } <line_num>: 572,721
private SchurTransformer transformToSchur(final RealMatrix matrix) { [EOL]     final SchurTransformer schurTransform = new SchurTransformer(matrix); [EOL]     final double[][] matT = schurTransform.getT().getData(); [EOL]     realEigenvalues = new double[matT.length]; [EOL]     imagEigenvalues = new double[matT.length]; [EOL]     for (int i = 0; i < realEigenvalues.length; i++) { [EOL]         if (i == (realEigenvalues.length - 1) || Precision.equals(matT[i + 1][i], 0.0, EPSILON)) { [EOL]             realEigenvalues[i] = matT[i][i]; [EOL]         } else { [EOL]             final double x = matT[i + 1][i + 1]; [EOL]             final double p = 0.5 * (matT[i][i] - x); [EOL]             final double z = FastMath.sqrt(FastMath.abs(p * p + matT[i + 1][i] * matT[i][i + 1])); [EOL]             realEigenvalues[i] = x + p; [EOL]             imagEigenvalues[i] = z; [EOL]             realEigenvalues[i + 1] = x + p; [EOL]             imagEigenvalues[i + 1] = -z; [EOL]             i++; [EOL]         } [EOL]     } [EOL]     return schurTransform; [EOL] } <line_num>: 729,752
private Complex cdiv(final double xr, final double xi, final double yr, final double yi) { [EOL]     return new Complex(xr, xi).divide(new Complex(yr, yi)); [EOL] } <line_num>: 763,766
private void findEigenVectorsFromSchur(final SchurTransformer schur) throws MathArithmeticException { [EOL]     final double[][] matrixT = schur.getT().getData(); [EOL]     final double[][] matrixP = schur.getP().getData(); [EOL]     final int n = matrixT.length; [EOL]     double norm = 0.0; [EOL]     for (int i = 0; i < n; i++) { [EOL]         for (int j = FastMath.max(i - 1, 0); j < n; j++) { [EOL]             norm = norm + FastMath.abs(matrixT[i][j]); [EOL]         } [EOL]     } [EOL]     if (Precision.equals(norm, 0.0, EPSILON)) { [EOL]         throw new MathArithmeticException(LocalizedFormats.ZERO_NORM); [EOL]     } [EOL]     double r = 0.0; [EOL]     double s = 0.0; [EOL]     double z = 0.0; [EOL]     for (int idx = n - 1; idx >= 0; idx--) { [EOL]         double p = realEigenvalues[idx]; [EOL]         double q = imagEigenvalues[idx]; [EOL]         if (Precision.equals(q, 0.0)) { [EOL]             int l = idx; [EOL]             matrixT[idx][idx] = 1.0; [EOL]             for (int i = idx - 1; i >= 0; i--) { [EOL]                 double w = matrixT[i][i] - p; [EOL]                 r = 0.0; [EOL]                 for (int j = l; j <= idx; j++) { [EOL]                     r = r + matrixT[i][j] * matrixT[j][idx]; [EOL]                 } [EOL]                 if (Precision.compareTo(imagEigenvalues[i], 0.0, EPSILON) < 0.0) { [EOL]                     z = w; [EOL]                     s = r; [EOL]                 } else { [EOL]                     l = i; [EOL]                     if (Precision.equals(imagEigenvalues[i], 0.0)) { [EOL]                         if (w != 0.0) { [EOL]                             matrixT[i][idx] = -r / w; [EOL]                         } else { [EOL]                             matrixT[i][idx] = -r / (Precision.EPSILON * norm); [EOL]                         } [EOL]                     } else { [EOL]                         double x = matrixT[i][i + 1]; [EOL]                         double y = matrixT[i + 1][i]; [EOL]                         q = (realEigenvalues[i] - p) * (realEigenvalues[i] - p) + imagEigenvalues[i] * imagEigenvalues[i]; [EOL]                         double t = (x * s - z * r) / q; [EOL]                         matrixT[i][idx] = t; [EOL]                         if (FastMath.abs(x) > FastMath.abs(z)) { [EOL]                             matrixT[i + 1][idx] = (-r - w * t) / x; [EOL]                         } else { [EOL]                             matrixT[i + 1][idx] = (-s - y * t) / z; [EOL]                         } [EOL]                     } [EOL]                     double t = FastMath.abs(matrixT[i][idx]); [EOL]                     if ((Precision.EPSILON * t) * t > 1) { [EOL]                         for (int j = i; j <= idx; j++) { [EOL]                             matrixT[j][idx] = matrixT[j][idx] / t; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } else if (q < 0.0) { [EOL]             int l = idx - 1; [EOL]             if (FastMath.abs(matrixT[idx][idx - 1]) > FastMath.abs(matrixT[idx - 1][idx])) { [EOL]                 matrixT[idx - 1][idx - 1] = q / matrixT[idx][idx - 1]; [EOL]                 matrixT[idx - 1][idx] = -(matrixT[idx][idx] - p) / matrixT[idx][idx - 1]; [EOL]             } else { [EOL]                 final Complex result = cdiv(0.0, -matrixT[idx - 1][idx], matrixT[idx - 1][idx - 1] - p, q); [EOL]                 matrixT[idx - 1][idx - 1] = result.getReal(); [EOL]                 matrixT[idx - 1][idx] = result.getImaginary(); [EOL]             } [EOL]             matrixT[idx][idx - 1] = 0.0; [EOL]             matrixT[idx][idx] = 1.0; [EOL]             for (int i = idx - 2; i >= 0; i--) { [EOL]                 double ra = 0.0; [EOL]                 double sa = 0.0; [EOL]                 for (int j = l; j <= idx; j++) { [EOL]                     ra = ra + matrixT[i][j] * matrixT[j][idx - 1]; [EOL]                     sa = sa + matrixT[i][j] * matrixT[j][idx]; [EOL]                 } [EOL]                 double w = matrixT[i][i] - p; [EOL]                 if (Precision.compareTo(imagEigenvalues[i], 0.0, EPSILON) < 0.0) { [EOL]                     z = w; [EOL]                     r = ra; [EOL]                     s = sa; [EOL]                 } else { [EOL]                     l = i; [EOL]                     if (Precision.equals(imagEigenvalues[i], 0.0)) { [EOL]                         final Complex c = cdiv(-ra, -sa, w, q); [EOL]                         matrixT[i][idx - 1] = c.getReal(); [EOL]                         matrixT[i][idx] = c.getImaginary(); [EOL]                     } else { [EOL]                         double x = matrixT[i][i + 1]; [EOL]                         double y = matrixT[i + 1][i]; [EOL]                         double vr = (realEigenvalues[i] - p) * (realEigenvalues[i] - p) + imagEigenvalues[i] * imagEigenvalues[i] - q * q; [EOL]                         final double vi = (realEigenvalues[i] - p) * 2.0 * q; [EOL]                         if (Precision.equals(vr, 0.0) && Precision.equals(vi, 0.0)) { [EOL]                             vr = Precision.EPSILON * norm * (FastMath.abs(w) + FastMath.abs(q) + FastMath.abs(x) + FastMath.abs(y) + FastMath.abs(z)); [EOL]                         } [EOL]                         final Complex c = cdiv(x * r - z * ra + q * sa, x * s - z * sa - q * ra, vr, vi); [EOL]                         matrixT[i][idx - 1] = c.getReal(); [EOL]                         matrixT[i][idx] = c.getImaginary(); [EOL]                         if (FastMath.abs(x) > (FastMath.abs(z) + FastMath.abs(q))) { [EOL]                             matrixT[i + 1][idx - 1] = (-ra - w * matrixT[i][idx - 1] + q * matrixT[i][idx]) / x; [EOL]                             matrixT[i + 1][idx] = (-sa - w * matrixT[i][idx] - q * matrixT[i][idx - 1]) / x; [EOL]                         } else { [EOL]                             final Complex c2 = cdiv(-r - y * matrixT[i][idx - 1], -s - y * matrixT[i][idx], z, q); [EOL]                             matrixT[i + 1][idx - 1] = c2.getReal(); [EOL]                             matrixT[i + 1][idx] = c2.getImaginary(); [EOL]                         } [EOL]                     } [EOL]                     double t = FastMath.max(FastMath.abs(matrixT[i][idx - 1]), FastMath.abs(matrixT[i][idx])); [EOL]                     if ((Precision.EPSILON * t) * t > 1) { [EOL]                         for (int j = i; j <= idx; j++) { [EOL]                             matrixT[j][idx - 1] = matrixT[j][idx - 1] / t; [EOL]                             matrixT[j][idx] = matrixT[j][idx] / t; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     for (int i = 0; i < n; i++) { [EOL]         if (i < 0 | i > n - 1) { [EOL]             for (int j = i; j < n; j++) { [EOL]                 matrixP[i][j] = matrixT[i][j]; [EOL]             } [EOL]         } [EOL]     } [EOL]     for (int j = n - 1; j >= 0; j--) { [EOL]         for (int i = 0; i <= n - 1; i++) { [EOL]             z = 0.0; [EOL]             for (int k = 0; k <= FastMath.min(j, n - 1); k++) { [EOL]                 z = z + matrixP[i][k] * matrixT[k][j]; [EOL]             } [EOL]             matrixP[i][j] = z; [EOL]         } [EOL]     } [EOL]     eigenvectors = new ArrayRealVector[n]; [EOL]     final double[] tmp = new double[n]; [EOL]     for (int i = 0; i < n; i++) { [EOL]         for (int j = 0; j < n; j++) { [EOL]             tmp[j] = matrixP[j][i]; [EOL]         } [EOL]         eigenvectors[i] = new ArrayRealVector(tmp); [EOL]     } [EOL] } <line_num>: 774,958
