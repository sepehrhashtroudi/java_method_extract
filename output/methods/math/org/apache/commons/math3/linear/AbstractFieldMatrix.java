protected AbstractFieldMatrix() { [EOL]     field = null; [EOL] } <line_num>: 52,54
protected AbstractFieldMatrix(final Field<T> field) { [EOL]     this.field = field; [EOL] } <line_num>: 60,62
protected AbstractFieldMatrix(final Field<T> field, final int rowDimension, final int columnDimension) throws NotStrictlyPositiveException { [EOL]     if (rowDimension <= 0) { [EOL]         throw new NotStrictlyPositiveException(LocalizedFormats.DIMENSION, rowDimension); [EOL]     } [EOL]     if (columnDimension <= 0) { [EOL]         throw new NotStrictlyPositiveException(LocalizedFormats.DIMENSION, columnDimension); [EOL]     } [EOL]     this.field = field; [EOL] } <line_num>: 73,86
protected static <T extends FieldElement<T>> Field<T> extractField(final T[][] d) throws NoDataException, NullArgumentException { [EOL]     if (d == null) { [EOL]         throw new NullArgumentException(); [EOL]     } [EOL]     if (d.length == 0) { [EOL]         throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW); [EOL]     } [EOL]     if (d[0].length == 0) { [EOL]         throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN); [EOL]     } [EOL]     return d[0][0].getField(); [EOL] } <line_num>: 97,109
protected static <T extends FieldElement<T>> Field<T> extractField(final T[] d) throws NoDataException { [EOL]     if (d.length == 0) { [EOL]         throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW); [EOL]     } [EOL]     return d[0].getField(); [EOL] } <line_num>: 119,125
@Deprecated [EOL] protected static <T extends FieldElement<T>> T[][] buildArray(final Field<T> field, final int rows, final int columns) { [EOL]     return MathArrays.buildArray(field, rows, columns); [EOL] } <line_num>: 139,144
@Deprecated [EOL] protected static <T extends FieldElement<T>> T[] buildArray(final Field<T> field, final int length) { [EOL]     return MathArrays.buildArray(field, length); [EOL] } <line_num>: 156,160
public Field<T> getField() { [EOL]     return field; [EOL] } <line_num>: 163,165
public abstract FieldMatrix<T> createMatrix(final int rowDimension, final int columnDimension) throws NotStrictlyPositiveException; <line_num>: 168,170
public abstract FieldMatrix<T> copy(); <line_num>: 173,173
public FieldMatrix<T> add(FieldMatrix<T> m) throws MatrixDimensionMismatchException { [EOL]     checkAdditionCompatible(m); [EOL]     final int rowCount = getRowDimension(); [EOL]     final int columnCount = getColumnDimension(); [EOL]     final FieldMatrix<T> out = createMatrix(rowCount, columnCount); [EOL]     for (int row = 0; row < rowCount; ++row) { [EOL]         for (int col = 0; col < columnCount; ++col) { [EOL]             out.setEntry(row, col, getEntry(row, col).add(m.getEntry(row, col))); [EOL]         } [EOL]     } [EOL]     return out; [EOL] } <line_num>: 176,191
public FieldMatrix<T> subtract(final FieldMatrix<T> m) throws MatrixDimensionMismatchException { [EOL]     checkSubtractionCompatible(m); [EOL]     final int rowCount = getRowDimension(); [EOL]     final int columnCount = getColumnDimension(); [EOL]     final FieldMatrix<T> out = createMatrix(rowCount, columnCount); [EOL]     for (int row = 0; row < rowCount; ++row) { [EOL]         for (int col = 0; col < columnCount; ++col) { [EOL]             out.setEntry(row, col, getEntry(row, col).subtract(m.getEntry(row, col))); [EOL]         } [EOL]     } [EOL]     return out; [EOL] } <line_num>: 194,209
public FieldMatrix<T> scalarAdd(final T d) { [EOL]     final int rowCount = getRowDimension(); [EOL]     final int columnCount = getColumnDimension(); [EOL]     final FieldMatrix<T> out = createMatrix(rowCount, columnCount); [EOL]     for (int row = 0; row < rowCount; ++row) { [EOL]         for (int col = 0; col < columnCount; ++col) { [EOL]             out.setEntry(row, col, getEntry(row, col).add(d)); [EOL]         } [EOL]     } [EOL]     return out; [EOL] } <line_num>: 212,224
public FieldMatrix<T> scalarMultiply(final T d) { [EOL]     final int rowCount = getRowDimension(); [EOL]     final int columnCount = getColumnDimension(); [EOL]     final FieldMatrix<T> out = createMatrix(rowCount, columnCount); [EOL]     for (int row = 0; row < rowCount; ++row) { [EOL]         for (int col = 0; col < columnCount; ++col) { [EOL]             out.setEntry(row, col, getEntry(row, col).multiply(d)); [EOL]         } [EOL]     } [EOL]     return out; [EOL] } <line_num>: 227,238
public FieldMatrix<T> multiply(final FieldMatrix<T> m) throws DimensionMismatchException { [EOL]     checkMultiplicationCompatible(m); [EOL]     final int nRows = getRowDimension(); [EOL]     final int nCols = m.getColumnDimension(); [EOL]     final int nSum = getColumnDimension(); [EOL]     final FieldMatrix<T> out = createMatrix(nRows, nCols); [EOL]     for (int row = 0; row < nRows; ++row) { [EOL]         for (int col = 0; col < nCols; ++col) { [EOL]             T sum = field.getZero(); [EOL]             for (int i = 0; i < nSum; ++i) { [EOL]                 sum = sum.add(getEntry(row, i).multiply(m.getEntry(i, col))); [EOL]             } [EOL]             out.setEntry(row, col, sum); [EOL]         } [EOL]     } [EOL]     return out; [EOL] } <line_num>: 241,261
public FieldMatrix<T> preMultiply(final FieldMatrix<T> m) throws DimensionMismatchException { [EOL]     return m.multiply(this); [EOL] } <line_num>: 264,267
public FieldMatrix<T> power(final int p) throws NonSquareMatrixException, NotPositiveException { [EOL]     if (p < 0) { [EOL]         throw new NotPositiveException(p); [EOL]     } [EOL]     if (!isSquare()) { [EOL]         throw new NonSquareMatrixException(getRowDimension(), getColumnDimension()); [EOL]     } [EOL]     if (p == 0) { [EOL]         return MatrixUtils.createFieldIdentityMatrix(this.getField(), this.getRowDimension()); [EOL]     } [EOL]     if (p == 1) { [EOL]         return this.copy(); [EOL]     } [EOL]     final int power = p - 1; [EOL]     final char[] binaryRepresentation = Integer.toBinaryString(power).toCharArray(); [EOL]     final ArrayList<Integer> nonZeroPositions = new ArrayList<Integer>(); [EOL]     for (int i = 0; i < binaryRepresentation.length; ++i) { [EOL]         if (binaryRepresentation[i] == '1') { [EOL]             final int pos = binaryRepresentation.length - i - 1; [EOL]             nonZeroPositions.add(pos); [EOL]         } [EOL]     } [EOL]     ArrayList<FieldMatrix<T>> results = new ArrayList<FieldMatrix<T>>(binaryRepresentation.length); [EOL]     results.add(0, this.copy()); [EOL]     for (int i = 1; i < binaryRepresentation.length; ++i) { [EOL]         final FieldMatrix<T> s = results.get(i - 1); [EOL]         final FieldMatrix<T> r = s.multiply(s); [EOL]         results.add(i, r); [EOL]     } [EOL]     FieldMatrix<T> result = this.copy(); [EOL]     for (Integer i : nonZeroPositions) { [EOL]         result = result.multiply(results.get(i)); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 270,326
public T[][] getData() { [EOL]     final T[][] data = MathArrays.buildArray(field, getRowDimension(), getColumnDimension()); [EOL]     for (int i = 0; i < data.length; ++i) { [EOL]         final T[] dataI = data[i]; [EOL]         for (int j = 0; j < dataI.length; ++j) { [EOL]             dataI[j] = getEntry(i, j); [EOL]         } [EOL]     } [EOL]     return data; [EOL] } <line_num>: 329,340
public FieldMatrix<T> getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws NumberIsTooSmallException, OutOfRangeException { [EOL]     checkSubMatrixIndex(startRow, endRow, startColumn, endColumn); [EOL]     final FieldMatrix<T> subMatrix = createMatrix(endRow - startRow + 1, endColumn - startColumn + 1); [EOL]     for (int i = startRow; i <= endRow; ++i) { [EOL]         for (int j = startColumn; j <= endColumn; ++j) { [EOL]             subMatrix.setEntry(i - startRow, j - startColumn, getEntry(i, j)); [EOL]         } [EOL]     } [EOL]     return subMatrix; [EOL] } <line_num>: 343,358
@Override [EOL] public T visit(final int row, final int column, final T value) { [EOL]     return getEntry(selectedRows[row], selectedColumns[column]); [EOL] } <line_num>: 374,377
public FieldMatrix<T> getSubMatrix(final int[] selectedRows, final int[] selectedColumns) throws NoDataException, NullArgumentException, OutOfRangeException { [EOL]     checkSubMatrixIndex(selectedRows, selectedColumns); [EOL]     final FieldMatrix<T> subMatrix = createMatrix(selectedRows.length, selectedColumns.length); [EOL]     subMatrix.walkInOptimizedOrder(new DefaultFieldMatrixChangingVisitor<T>(field.getZero()) { [EOL]  [EOL]         @Override [EOL]         public T visit(final int row, final int column, final T value) { [EOL]             return getEntry(selectedRows[row], selectedColumns[column]); [EOL]         } [EOL]     }); [EOL]     return subMatrix; [EOL] } <line_num>: 361,383
@Override [EOL] public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) { [EOL]     this.startRow = startRow; [EOL]     this.startColumn = startColumn; [EOL] } <line_num>: 412,418
@Override [EOL] public void visit(final int row, final int column, final T value) { [EOL]     destination[row - startRow][column - startColumn] = value; [EOL] } <line_num>: 421,424
public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final T[][] destination) throws MatrixDimensionMismatchException, NumberIsTooSmallException, OutOfRangeException { [EOL]     checkSubMatrixIndex(startRow, endRow, startColumn, endColumn); [EOL]     final int rowsCount = endRow + 1 - startRow; [EOL]     final int columnsCount = endColumn + 1 - startColumn; [EOL]     if ((destination.length < rowsCount) || (destination[0].length < columnsCount)) { [EOL]         throw new MatrixDimensionMismatchException(destination.length, destination[0].length, rowsCount, columnsCount); [EOL]     } [EOL]     walkInOptimizedOrder(new DefaultFieldMatrixPreservingVisitor<T>(field.getZero()) { [EOL]  [EOL]         private int startRow; [EOL]  [EOL]         private int startColumn; [EOL]  [EOL]         @Override [EOL]         public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) { [EOL]             this.startRow = startRow; [EOL]             this.startColumn = startColumn; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void visit(final int row, final int column, final T value) { [EOL]             destination[row - startRow][column - startColumn] = value; [EOL]         } [EOL]     }, startRow, endRow, startColumn, endColumn); [EOL] } <line_num>: 386,428
public void copySubMatrix(int[] selectedRows, int[] selectedColumns, T[][] destination) throws MatrixDimensionMismatchException, NoDataException, NullArgumentException, OutOfRangeException { [EOL]     checkSubMatrixIndex(selectedRows, selectedColumns); [EOL]     if ((destination.length < selectedRows.length) || (destination[0].length < selectedColumns.length)) { [EOL]         throw new MatrixDimensionMismatchException(destination.length, destination[0].length, selectedRows.length, selectedColumns.length); [EOL]     } [EOL]     for (int i = 0; i < selectedRows.length; i++) { [EOL]         final T[] destinationI = destination[i]; [EOL]         for (int j = 0; j < selectedColumns.length; j++) { [EOL]             destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]); [EOL]         } [EOL]     } [EOL] } <line_num>: 431,452
public void setSubMatrix(final T[][] subMatrix, final int row, final int column) throws DimensionMismatchException, OutOfRangeException, NoDataException, NullArgumentException { [EOL]     if (subMatrix == null) { [EOL]         throw new NullArgumentException(); [EOL]     } [EOL]     final int nRows = subMatrix.length; [EOL]     if (nRows == 0) { [EOL]         throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW); [EOL]     } [EOL]     final int nCols = subMatrix[0].length; [EOL]     if (nCols == 0) { [EOL]         throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN); [EOL]     } [EOL]     for (int r = 1; r < nRows; ++r) { [EOL]         if (subMatrix[r].length != nCols) { [EOL]             throw new DimensionMismatchException(nCols, subMatrix[r].length); [EOL]         } [EOL]     } [EOL]     checkRowIndex(row); [EOL]     checkColumnIndex(column); [EOL]     checkRowIndex(nRows + row - 1); [EOL]     checkColumnIndex(nCols + column - 1); [EOL]     for (int i = 0; i < nRows; ++i) { [EOL]         for (int j = 0; j < nCols; ++j) { [EOL]             setEntry(row + i, column + j, subMatrix[i][j]); [EOL]         } [EOL]     } [EOL] } <line_num>: 455,488
public FieldMatrix<T> getRowMatrix(final int row) throws OutOfRangeException { [EOL]     checkRowIndex(row); [EOL]     final int nCols = getColumnDimension(); [EOL]     final FieldMatrix<T> out = createMatrix(1, nCols); [EOL]     for (int i = 0; i < nCols; ++i) { [EOL]         out.setEntry(0, i, getEntry(row, i)); [EOL]     } [EOL]     return out; [EOL] } <line_num>: 491,501
public void setRowMatrix(final int row, final FieldMatrix<T> matrix) throws OutOfRangeException, MatrixDimensionMismatchException { [EOL]     checkRowIndex(row); [EOL]     final int nCols = getColumnDimension(); [EOL]     if ((matrix.getRowDimension() != 1) || (matrix.getColumnDimension() != nCols)) { [EOL]         throw new MatrixDimensionMismatchException(matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols); [EOL]     } [EOL]     for (int i = 0; i < nCols; ++i) { [EOL]         setEntry(row, i, matrix.getEntry(0, i)); [EOL]     } [EOL] } <line_num>: 504,518
public FieldMatrix<T> getColumnMatrix(final int column) throws OutOfRangeException { [EOL]     checkColumnIndex(column); [EOL]     final int nRows = getRowDimension(); [EOL]     final FieldMatrix<T> out = createMatrix(nRows, 1); [EOL]     for (int i = 0; i < nRows; ++i) { [EOL]         out.setEntry(i, 0, getEntry(i, column)); [EOL]     } [EOL]     return out; [EOL] } <line_num>: 521,533
public void setColumnMatrix(final int column, final FieldMatrix<T> matrix) throws OutOfRangeException, MatrixDimensionMismatchException { [EOL]     checkColumnIndex(column); [EOL]     final int nRows = getRowDimension(); [EOL]     if ((matrix.getRowDimension() != nRows) || (matrix.getColumnDimension() != 1)) { [EOL]         throw new MatrixDimensionMismatchException(matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1); [EOL]     } [EOL]     for (int i = 0; i < nRows; ++i) { [EOL]         setEntry(i, column, matrix.getEntry(i, 0)); [EOL]     } [EOL] } <line_num>: 536,550
public FieldVector<T> getRowVector(final int row) throws OutOfRangeException { [EOL]     return new ArrayFieldVector<T>(field, getRow(row), false); [EOL] } <line_num>: 553,556
public void setRowVector(final int row, final FieldVector<T> vector) throws OutOfRangeException, MatrixDimensionMismatchException { [EOL]     checkRowIndex(row); [EOL]     final int nCols = getColumnDimension(); [EOL]     if (vector.getDimension() != nCols) { [EOL]         throw new MatrixDimensionMismatchException(1, vector.getDimension(), 1, nCols); [EOL]     } [EOL]     for (int i = 0; i < nCols; ++i) { [EOL]         setEntry(row, i, vector.getEntry(i)); [EOL]     } [EOL] } <line_num>: 559,571
public FieldVector<T> getColumnVector(final int column) throws OutOfRangeException { [EOL]     return new ArrayFieldVector<T>(field, getColumn(column), false); [EOL] } <line_num>: 574,577
public void setColumnVector(final int column, final FieldVector<T> vector) throws OutOfRangeException, MatrixDimensionMismatchException { [EOL]     checkColumnIndex(column); [EOL]     final int nRows = getRowDimension(); [EOL]     if (vector.getDimension() != nRows) { [EOL]         throw new MatrixDimensionMismatchException(vector.getDimension(), 1, nRows, 1); [EOL]     } [EOL]     for (int i = 0; i < nRows; ++i) { [EOL]         setEntry(i, column, vector.getEntry(i)); [EOL]     } [EOL] } <line_num>: 580,593
public T[] getRow(final int row) throws OutOfRangeException { [EOL]     checkRowIndex(row); [EOL]     final int nCols = getColumnDimension(); [EOL]     final T[] out = MathArrays.buildArray(field, nCols); [EOL]     for (int i = 0; i < nCols; ++i) { [EOL]         out[i] = getEntry(row, i); [EOL]     } [EOL]     return out; [EOL] } <line_num>: 596,606
public void setRow(final int row, final T[] array) throws OutOfRangeException, MatrixDimensionMismatchException { [EOL]     checkRowIndex(row); [EOL]     final int nCols = getColumnDimension(); [EOL]     if (array.length != nCols) { [EOL]         throw new MatrixDimensionMismatchException(1, array.length, 1, nCols); [EOL]     } [EOL]     for (int i = 0; i < nCols; ++i) { [EOL]         setEntry(row, i, array[i]); [EOL]     } [EOL] } <line_num>: 609,620
public T[] getColumn(final int column) throws OutOfRangeException { [EOL]     checkColumnIndex(column); [EOL]     final int nRows = getRowDimension(); [EOL]     final T[] out = MathArrays.buildArray(field, nRows); [EOL]     for (int i = 0; i < nRows; ++i) { [EOL]         out[i] = getEntry(i, column); [EOL]     } [EOL]     return out; [EOL] } <line_num>: 623,633
public void setColumn(final int column, final T[] array) throws OutOfRangeException, MatrixDimensionMismatchException { [EOL]     checkColumnIndex(column); [EOL]     final int nRows = getRowDimension(); [EOL]     if (array.length != nRows) { [EOL]         throw new MatrixDimensionMismatchException(array.length, 1, nRows, 1); [EOL]     } [EOL]     for (int i = 0; i < nRows; ++i) { [EOL]         setEntry(i, column, array[i]); [EOL]     } [EOL] } <line_num>: 636,646
public abstract T getEntry(int row, int column) throws OutOfRangeException; <line_num>: 649,649
public abstract void setEntry(int row, int column, T value) throws OutOfRangeException; <line_num>: 652,652
public abstract void addToEntry(int row, int column, T increment) throws OutOfRangeException; <line_num>: 655,655
public abstract void multiplyEntry(int row, int column, T factor) throws OutOfRangeException; <line_num>: 658,658
@Override [EOL] public void visit(final int row, final int column, final T value) { [EOL]     out.setEntry(column, row, value); [EOL] } <line_num>: 667,670
public FieldMatrix<T> transpose() { [EOL]     final int nRows = getRowDimension(); [EOL]     final int nCols = getColumnDimension(); [EOL]     final FieldMatrix<T> out = createMatrix(nCols, nRows); [EOL]     walkInOptimizedOrder(new DefaultFieldMatrixPreservingVisitor<T>(field.getZero()) { [EOL]  [EOL]         @Override [EOL]         public void visit(final int row, final int column, final T value) { [EOL]             out.setEntry(column, row, value); [EOL]         } [EOL]     }); [EOL]     return out; [EOL] } <line_num>: 661,674
public boolean isSquare() { [EOL]     return getColumnDimension() == getRowDimension(); [EOL] } <line_num>: 677,679
public abstract int getRowDimension(); <line_num>: 682,682
public abstract int getColumnDimension(); <line_num>: 685,685
public T getTrace() throws NonSquareMatrixException { [EOL]     final int nRows = getRowDimension(); [EOL]     final int nCols = getColumnDimension(); [EOL]     if (nRows != nCols) { [EOL]         throw new NonSquareMatrixException(nRows, nCols); [EOL]     } [EOL]     T trace = field.getZero(); [EOL]     for (int i = 0; i < nRows; ++i) { [EOL]         trace = trace.add(getEntry(i, i)); [EOL]     } [EOL]     return trace; [EOL] } <line_num>: 688,699
public T[] operate(final T[] v) throws DimensionMismatchException { [EOL]     final int nRows = getRowDimension(); [EOL]     final int nCols = getColumnDimension(); [EOL]     if (v.length != nCols) { [EOL]         throw new DimensionMismatchException(v.length, nCols); [EOL]     } [EOL]     final T[] out = MathArrays.buildArray(field, nRows); [EOL]     for (int row = 0; row < nRows; ++row) { [EOL]         T sum = field.getZero(); [EOL]         for (int i = 0; i < nCols; ++i) { [EOL]             sum = sum.add(getEntry(row, i).multiply(v[i])); [EOL]         } [EOL]         out[row] = sum; [EOL]     } [EOL]     return out; [EOL] } <line_num>: 702,720
public FieldVector<T> operate(final FieldVector<T> v) throws DimensionMismatchException { [EOL]     try { [EOL]         return new ArrayFieldVector<T>(field, operate(((ArrayFieldVector<T>) v).getDataRef()), false); [EOL]     } catch (ClassCastException cce) { [EOL]         final int nRows = getRowDimension(); [EOL]         final int nCols = getColumnDimension(); [EOL]         if (v.getDimension() != nCols) { [EOL]             throw new DimensionMismatchException(v.getDimension(), nCols); [EOL]         } [EOL]         final T[] out = MathArrays.buildArray(field, nRows); [EOL]         for (int row = 0; row < nRows; ++row) { [EOL]             T sum = field.getZero(); [EOL]             for (int i = 0; i < nCols; ++i) { [EOL]                 sum = sum.add(getEntry(row, i).multiply(v.getEntry(i))); [EOL]             } [EOL]             out[row] = sum; [EOL]         } [EOL]         return new ArrayFieldVector<T>(field, out, false); [EOL]     } [EOL] } <line_num>: 723,745
public T[] preMultiply(final T[] v) throws DimensionMismatchException { [EOL]     final int nRows = getRowDimension(); [EOL]     final int nCols = getColumnDimension(); [EOL]     if (v.length != nRows) { [EOL]         throw new DimensionMismatchException(v.length, nRows); [EOL]     } [EOL]     final T[] out = MathArrays.buildArray(field, nCols); [EOL]     for (int col = 0; col < nCols; ++col) { [EOL]         T sum = field.getZero(); [EOL]         for (int i = 0; i < nRows; ++i) { [EOL]             sum = sum.add(getEntry(i, col).multiply(v[i])); [EOL]         } [EOL]         out[col] = sum; [EOL]     } [EOL]     return out; [EOL] } <line_num>: 748,766
public FieldVector<T> preMultiply(final FieldVector<T> v) throws DimensionMismatchException { [EOL]     try { [EOL]         return new ArrayFieldVector<T>(field, preMultiply(((ArrayFieldVector<T>) v).getDataRef()), false); [EOL]     } catch (ClassCastException cce) { [EOL]         final int nRows = getRowDimension(); [EOL]         final int nCols = getColumnDimension(); [EOL]         if (v.getDimension() != nRows) { [EOL]             throw new DimensionMismatchException(v.getDimension(), nRows); [EOL]         } [EOL]         final T[] out = MathArrays.buildArray(field, nCols); [EOL]         for (int col = 0; col < nCols; ++col) { [EOL]             T sum = field.getZero(); [EOL]             for (int i = 0; i < nRows; ++i) { [EOL]                 sum = sum.add(getEntry(i, col).multiply(v.getEntry(i))); [EOL]             } [EOL]             out[col] = sum; [EOL]         } [EOL]         return new ArrayFieldVector<T>(field, out, false); [EOL]     } [EOL] } <line_num>: 769,791
public T walkInRowOrder(final FieldMatrixChangingVisitor<T> visitor) { [EOL]     final int rows = getRowDimension(); [EOL]     final int columns = getColumnDimension(); [EOL]     visitor.start(rows, columns, 0, rows - 1, 0, columns - 1); [EOL]     for (int row = 0; row < rows; ++row) { [EOL]         for (int column = 0; column < columns; ++column) { [EOL]             final T oldValue = getEntry(row, column); [EOL]             final T newValue = visitor.visit(row, column, oldValue); [EOL]             setEntry(row, column, newValue); [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 794,806
public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor) { [EOL]     final int rows = getRowDimension(); [EOL]     final int columns = getColumnDimension(); [EOL]     visitor.start(rows, columns, 0, rows - 1, 0, columns - 1); [EOL]     for (int row = 0; row < rows; ++row) { [EOL]         for (int column = 0; column < columns; ++column) { [EOL]             visitor.visit(row, column, getEntry(row, column)); [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 809,819
public T walkInRowOrder(final FieldMatrixChangingVisitor<T> visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws NumberIsTooSmallException, OutOfRangeException { [EOL]     checkSubMatrixIndex(startRow, endRow, startColumn, endColumn); [EOL]     visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn); [EOL]     for (int row = startRow; row <= endRow; ++row) { [EOL]         for (int column = startColumn; column <= endColumn; ++column) { [EOL]             final T oldValue = getEntry(row, column); [EOL]             final T newValue = visitor.visit(row, column, oldValue); [EOL]             setEntry(row, column, newValue); [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 822,837
public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws NumberIsTooSmallException, OutOfRangeException { [EOL]     checkSubMatrixIndex(startRow, endRow, startColumn, endColumn); [EOL]     visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn); [EOL]     for (int row = startRow; row <= endRow; ++row) { [EOL]         for (int column = startColumn; column <= endColumn; ++column) { [EOL]             visitor.visit(row, column, getEntry(row, column)); [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 840,853
public T walkInColumnOrder(final FieldMatrixChangingVisitor<T> visitor) { [EOL]     final int rows = getRowDimension(); [EOL]     final int columns = getColumnDimension(); [EOL]     visitor.start(rows, columns, 0, rows - 1, 0, columns - 1); [EOL]     for (int column = 0; column < columns; ++column) { [EOL]         for (int row = 0; row < rows; ++row) { [EOL]             final T oldValue = getEntry(row, column); [EOL]             final T newValue = visitor.visit(row, column, oldValue); [EOL]             setEntry(row, column, newValue); [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 856,868
public T walkInColumnOrder(final FieldMatrixPreservingVisitor<T> visitor) { [EOL]     final int rows = getRowDimension(); [EOL]     final int columns = getColumnDimension(); [EOL]     visitor.start(rows, columns, 0, rows - 1, 0, columns - 1); [EOL]     for (int column = 0; column < columns; ++column) { [EOL]         for (int row = 0; row < rows; ++row) { [EOL]             visitor.visit(row, column, getEntry(row, column)); [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 871,881
public T walkInColumnOrder(final FieldMatrixChangingVisitor<T> visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws NumberIsTooSmallException, OutOfRangeException { [EOL]     checkSubMatrixIndex(startRow, endRow, startColumn, endColumn); [EOL]     visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn); [EOL]     for (int column = startColumn; column <= endColumn; ++column) { [EOL]         for (int row = startRow; row <= endRow; ++row) { [EOL]             final T oldValue = getEntry(row, column); [EOL]             final T newValue = visitor.visit(row, column, oldValue); [EOL]             setEntry(row, column, newValue); [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 884,899
public T walkInColumnOrder(final FieldMatrixPreservingVisitor<T> visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws NumberIsTooSmallException, OutOfRangeException { [EOL]     checkSubMatrixIndex(startRow, endRow, startColumn, endColumn); [EOL]     visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn); [EOL]     for (int column = startColumn; column <= endColumn; ++column) { [EOL]         for (int row = startRow; row <= endRow; ++row) { [EOL]             visitor.visit(row, column, getEntry(row, column)); [EOL]         } [EOL]     } [EOL]     return visitor.end(); [EOL] } <line_num>: 902,915
public T walkInOptimizedOrder(final FieldMatrixChangingVisitor<T> visitor) { [EOL]     return walkInRowOrder(visitor); [EOL] } <line_num>: 918,920
public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor) { [EOL]     return walkInRowOrder(visitor); [EOL] } <line_num>: 923,925
public T walkInOptimizedOrder(final FieldMatrixChangingVisitor<T> visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws NumberIsTooSmallException, OutOfRangeException { [EOL]     return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn); [EOL] } <line_num>: 928,933
public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws NumberIsTooSmallException, OutOfRangeException { [EOL]     return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn); [EOL] } <line_num>: 936,941
@Override [EOL] public String toString() { [EOL]     final int nRows = getRowDimension(); [EOL]     final int nCols = getColumnDimension(); [EOL]     final StringBuffer res = new StringBuffer(); [EOL]     String fullClassName = getClass().getName(); [EOL]     String shortClassName = fullClassName.substring(fullClassName.lastIndexOf('.') + 1); [EOL]     res.append(shortClassName).append("{"); [EOL]     for (int i = 0; i < nRows; ++i) { [EOL]         if (i > 0) { [EOL]             res.append(","); [EOL]         } [EOL]         res.append("{"); [EOL]         for (int j = 0; j < nCols; ++j) { [EOL]             if (j > 0) { [EOL]                 res.append(","); [EOL]             } [EOL]             res.append(getEntry(i, j)); [EOL]         } [EOL]         res.append("}"); [EOL]     } [EOL]     res.append("}"); [EOL]     return res.toString(); [EOL] } <line_num>: 947,972
@Override [EOL] public boolean equals(final Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof FieldMatrix<?> == false) { [EOL]         return false; [EOL]     } [EOL]     FieldMatrix<?> m = (FieldMatrix<?>) object; [EOL]     final int nRows = getRowDimension(); [EOL]     final int nCols = getColumnDimension(); [EOL]     if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) { [EOL]         return false; [EOL]     } [EOL]     for (int row = 0; row < nRows; ++row) { [EOL]         for (int col = 0; col < nCols; ++col) { [EOL]             if (!getEntry(row, col).equals(m.getEntry(row, col))) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 982,1004
@Override [EOL] public int hashCode() { [EOL]     int ret = 322562; [EOL]     final int nRows = getRowDimension(); [EOL]     final int nCols = getColumnDimension(); [EOL]     ret = ret * 31 + nRows; [EOL]     ret = ret * 31 + nCols; [EOL]     for (int row = 0; row < nRows; ++row) { [EOL]         for (int col = 0; col < nCols; ++col) { [EOL]             ret = ret * 31 + (11 * (row + 1) + 17 * (col + 1)) * getEntry(row, col).hashCode(); [EOL]         } [EOL]     } [EOL]     return ret; [EOL] } <line_num>: 1011,1024
protected void checkRowIndex(final int row) throws OutOfRangeException { [EOL]     if (row < 0 || row >= getRowDimension()) { [EOL]         throw new OutOfRangeException(LocalizedFormats.ROW_INDEX, row, 0, getRowDimension() - 1); [EOL]     } [EOL] } <line_num>: 1032,1037
protected void checkColumnIndex(final int column) throws OutOfRangeException { [EOL]     if (column < 0 || column >= getColumnDimension()) { [EOL]         throw new OutOfRangeException(LocalizedFormats.COLUMN_INDEX, column, 0, getColumnDimension() - 1); [EOL]     } [EOL] } <line_num>: 1045,1051
protected void checkSubMatrixIndex(final int startRow, final int endRow, final int startColumn, final int endColumn) throws NumberIsTooSmallException, OutOfRangeException { [EOL]     checkRowIndex(startRow); [EOL]     checkRowIndex(endRow); [EOL]     if (endRow < startRow) { [EOL]         throw new NumberIsTooSmallException(LocalizedFormats.INITIAL_ROW_AFTER_FINAL_ROW, endRow, startRow, true); [EOL]     } [EOL]     checkColumnIndex(startColumn); [EOL]     checkColumnIndex(endColumn); [EOL]     if (endColumn < startColumn) { [EOL]         throw new NumberIsTooSmallException(LocalizedFormats.INITIAL_COLUMN_AFTER_FINAL_COLUMN, endColumn, startColumn, true); [EOL]     } [EOL] } <line_num>: 1065,1081
protected void checkSubMatrixIndex(final int[] selectedRows, final int[] selectedColumns) throws NoDataException, NullArgumentException, OutOfRangeException { [EOL]     if (selectedRows == null || selectedColumns == null) { [EOL]         throw new NullArgumentException(); [EOL]     } [EOL]     if (selectedRows.length == 0 || selectedColumns.length == 0) { [EOL]         throw new NoDataException(); [EOL]     } [EOL]     for (final int row : selectedRows) { [EOL]         checkRowIndex(row); [EOL]     } [EOL]     for (final int column : selectedColumns) { [EOL]         checkColumnIndex(column); [EOL]     } [EOL] } <line_num>: 1093,1110
protected void checkAdditionCompatible(final FieldMatrix<T> m) throws MatrixDimensionMismatchException { [EOL]     if ((getRowDimension() != m.getRowDimension()) || (getColumnDimension() != m.getColumnDimension())) { [EOL]         throw new MatrixDimensionMismatchException(m.getRowDimension(), m.getColumnDimension(), getRowDimension(), getColumnDimension()); [EOL]     } [EOL] } <line_num>: 1119,1126
protected void checkSubtractionCompatible(final FieldMatrix<T> m) throws MatrixDimensionMismatchException { [EOL]     if ((getRowDimension() != m.getRowDimension()) || (getColumnDimension() != m.getColumnDimension())) { [EOL]         throw new MatrixDimensionMismatchException(m.getRowDimension(), m.getColumnDimension(), getRowDimension(), getColumnDimension()); [EOL]     } [EOL] } <line_num>: 1135,1142
protected void checkMultiplicationCompatible(final FieldMatrix<T> m) throws DimensionMismatchException { [EOL]     if (getColumnDimension() != m.getRowDimension()) { [EOL]         throw new DimensionMismatchException(m.getRowDimension(), getColumnDimension()); [EOL]     } [EOL] } <line_num>: 1151,1156
