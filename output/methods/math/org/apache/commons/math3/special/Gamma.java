private Gamma() { [EOL] } <line_num>: 219,219
public static double logGamma(double x) { [EOL]     double ret; [EOL]     if (Double.isNaN(x) || (x <= 0.0)) { [EOL]         ret = Double.NaN; [EOL]     } else if (x < 0.5) { [EOL]         return logGamma1p(x) - FastMath.log(x); [EOL]     } else if (x <= 2.5) { [EOL]         return logGamma1p((x - 0.5) - 0.5); [EOL]     } else if (x <= 8.0) { [EOL]         final int n = (int) FastMath.floor(x - 1.5); [EOL]         double prod = 1.0; [EOL]         for (int i = 1; i <= n; i++) { [EOL]             prod *= x - i; [EOL]         } [EOL]         return logGamma1p(x - (n + 1)) + FastMath.log(prod); [EOL]     } else { [EOL]         double sum = lanczos(x); [EOL]         double tmp = x + LANCZOS_G + .5; [EOL]         ret = ((x + .5) * FastMath.log(tmp)) - tmp + HALF_LOG_2_PI + FastMath.log(sum / x); [EOL]     } [EOL]     return ret; [EOL] } <line_num>: 244,268
public static double regularizedGammaP(double a, double x) { [EOL]     return regularizedGammaP(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE); [EOL] } <line_num>: 278,280
public static double regularizedGammaP(double a, double x, double epsilon, int maxIterations) { [EOL]     double ret; [EOL]     if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) { [EOL]         ret = Double.NaN; [EOL]     } else if (x == 0.0) { [EOL]         ret = 0.0; [EOL]     } else if (x >= a + 1) { [EOL]         ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations); [EOL]     } else { [EOL]         double n = 0.0; [EOL]         double an = 1.0 / a; [EOL]         double sum = an; [EOL]         while (FastMath.abs(an / sum) > epsilon && n < maxIterations && sum < Double.POSITIVE_INFINITY) { [EOL]             n = n + 1.0; [EOL]             an = an * (x / (a + n)); [EOL]             sum = sum + an; [EOL]         } [EOL]         if (n >= maxIterations) { [EOL]             throw new MaxCountExceededException(maxIterations); [EOL]         } else if (Double.isInfinite(sum)) { [EOL]             ret = 1.0; [EOL]         } else { [EOL]             ret = FastMath.exp(-x + (a * FastMath.log(x)) - logGamma(a)) * sum; [EOL]         } [EOL]     } [EOL]     return ret; [EOL] } <line_num>: 310,349
public static double regularizedGammaQ(double a, double x) { [EOL]     return regularizedGammaQ(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE); [EOL] } <line_num>: 359,361
@Override [EOL] protected double getA(int n, double x) { [EOL]     return ((2.0 * n) + 1.0) - a + x; [EOL] } <line_num>: 406,409
@Override [EOL] protected double getB(int n, double x) { [EOL]     return n * (a - n); [EOL] } <line_num>: 411,414
public static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) { [EOL]     double ret; [EOL]     if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) { [EOL]         ret = Double.NaN; [EOL]     } else if (x == 0.0) { [EOL]         ret = 1.0; [EOL]     } else if (x < a + 1.0) { [EOL]         ret = 1.0 - regularizedGammaP(a, x, epsilon, maxIterations); [EOL]     } else { [EOL]         ContinuedFraction cf = new ContinuedFraction() { [EOL]  [EOL]             @Override [EOL]             protected double getA(int n, double x) { [EOL]                 return ((2.0 * n) + 1.0) - a + x; [EOL]             } [EOL]  [EOL]             @Override [EOL]             protected double getB(int n, double x) { [EOL]                 return n * (a - n); [EOL]             } [EOL]         }; [EOL]         ret = 1.0 / cf.evaluate(x, epsilon, maxIterations); [EOL]         ret = FastMath.exp(-x + (a * FastMath.log(x)) - logGamma(a)) * ret; [EOL]     } [EOL]     return ret; [EOL] } <line_num>: 388,422
public static double digamma(double x) { [EOL]     if (x > 0 && x <= S_LIMIT) { [EOL]         return -GAMMA - 1 / x; [EOL]     } [EOL]     if (x >= C_LIMIT) { [EOL]         double inv = 1 / (x * x); [EOL]         return FastMath.log(x) - 0.5 / x - inv * ((1.0 / 12) + inv * (1.0 / 120 - inv / 252)); [EOL]     } [EOL]     return digamma(x + 1) - 1 / x; [EOL] } <line_num>: 445,462
public static double trigamma(double x) { [EOL]     if (x > 0 && x <= S_LIMIT) { [EOL]         return 1 / (x * x); [EOL]     } [EOL]     if (x >= C_LIMIT) { [EOL]         double inv = 1 / (x * x); [EOL]         return 1 / x + inv / 2 + inv / x * (1.0 / 6 - inv * (1.0 / 30 + inv / 42)); [EOL]     } [EOL]     return trigamma(x + 1) + 1 / (x * x); [EOL] } <line_num>: 475,490
public static double lanczos(final double x) { [EOL]     double sum = 0.0; [EOL]     for (int i = LANCZOS.length - 1; i > 0; --i) { [EOL]         sum = sum + (LANCZOS[i] / (x + i)); [EOL]     } [EOL]     return sum + LANCZOS[0]; [EOL] } <line_num>: 512,518
public static double invGamma1pm1(final double x) { [EOL]     if (x < -0.5) { [EOL]         throw new NumberIsTooSmallException(x, -0.5, true); [EOL]     } [EOL]     if (x > 1.5) { [EOL]         throw new NumberIsTooLargeException(x, 1.5, true); [EOL]     } [EOL]     final double ret; [EOL]     final double t = x <= 0.5 ? x : (x - 0.5) - 0.5; [EOL]     if (t < 0.0) { [EOL]         final double a = INV_GAMMA1P_M1_A0 + t * INV_GAMMA1P_M1_A1; [EOL]         double b = INV_GAMMA1P_M1_B8; [EOL]         b = INV_GAMMA1P_M1_B7 + t * b; [EOL]         b = INV_GAMMA1P_M1_B6 + t * b; [EOL]         b = INV_GAMMA1P_M1_B5 + t * b; [EOL]         b = INV_GAMMA1P_M1_B4 + t * b; [EOL]         b = INV_GAMMA1P_M1_B3 + t * b; [EOL]         b = INV_GAMMA1P_M1_B2 + t * b; [EOL]         b = INV_GAMMA1P_M1_B1 + t * b; [EOL]         b = 1.0 + t * b; [EOL]         double c = INV_GAMMA1P_M1_C13 + t * (a / b); [EOL]         c = INV_GAMMA1P_M1_C12 + t * c; [EOL]         c = INV_GAMMA1P_M1_C11 + t * c; [EOL]         c = INV_GAMMA1P_M1_C10 + t * c; [EOL]         c = INV_GAMMA1P_M1_C9 + t * c; [EOL]         c = INV_GAMMA1P_M1_C8 + t * c; [EOL]         c = INV_GAMMA1P_M1_C7 + t * c; [EOL]         c = INV_GAMMA1P_M1_C6 + t * c; [EOL]         c = INV_GAMMA1P_M1_C5 + t * c; [EOL]         c = INV_GAMMA1P_M1_C4 + t * c; [EOL]         c = INV_GAMMA1P_M1_C3 + t * c; [EOL]         c = INV_GAMMA1P_M1_C2 + t * c; [EOL]         c = INV_GAMMA1P_M1_C1 + t * c; [EOL]         c = INV_GAMMA1P_M1_C + t * c; [EOL]         if (x > 0.5) { [EOL]             ret = t * c / x; [EOL]         } else { [EOL]             ret = x * ((c + 0.5) + 0.5); [EOL]         } [EOL]     } else { [EOL]         double p = INV_GAMMA1P_M1_P6; [EOL]         p = INV_GAMMA1P_M1_P5 + t * p; [EOL]         p = INV_GAMMA1P_M1_P4 + t * p; [EOL]         p = INV_GAMMA1P_M1_P3 + t * p; [EOL]         p = INV_GAMMA1P_M1_P2 + t * p; [EOL]         p = INV_GAMMA1P_M1_P1 + t * p; [EOL]         p = INV_GAMMA1P_M1_P0 + t * p; [EOL]         double q = INV_GAMMA1P_M1_Q4; [EOL]         q = INV_GAMMA1P_M1_Q3 + t * q; [EOL]         q = INV_GAMMA1P_M1_Q2 + t * q; [EOL]         q = INV_GAMMA1P_M1_Q1 + t * q; [EOL]         q = 1.0 + t * q; [EOL]         double c = INV_GAMMA1P_M1_C13 + (p / q) * t; [EOL]         c = INV_GAMMA1P_M1_C12 + t * c; [EOL]         c = INV_GAMMA1P_M1_C11 + t * c; [EOL]         c = INV_GAMMA1P_M1_C10 + t * c; [EOL]         c = INV_GAMMA1P_M1_C9 + t * c; [EOL]         c = INV_GAMMA1P_M1_C8 + t * c; [EOL]         c = INV_GAMMA1P_M1_C7 + t * c; [EOL]         c = INV_GAMMA1P_M1_C6 + t * c; [EOL]         c = INV_GAMMA1P_M1_C5 + t * c; [EOL]         c = INV_GAMMA1P_M1_C4 + t * c; [EOL]         c = INV_GAMMA1P_M1_C3 + t * c; [EOL]         c = INV_GAMMA1P_M1_C2 + t * c; [EOL]         c = INV_GAMMA1P_M1_C1 + t * c; [EOL]         c = INV_GAMMA1P_M1_C0 + t * c; [EOL]         if (x > 0.5) { [EOL]             ret = (t / x) * ((c - 0.5) - 0.5); [EOL]         } else { [EOL]             ret = x * c; [EOL]         } [EOL]     } [EOL]     return ret; [EOL] } <line_num>: 532,612
public static double logGamma1p(final double x) throws NumberIsTooSmallException, NumberIsTooLargeException { [EOL]     if (x < -0.5) { [EOL]         throw new NumberIsTooSmallException(x, -0.5, true); [EOL]     } [EOL]     if (x > 1.5) { [EOL]         throw new NumberIsTooLargeException(x, 1.5, true); [EOL]     } [EOL]     return -FastMath.log1p(invGamma1pm1(x)); [EOL] } <line_num>: 625,636
public static double gamma(final double x) { [EOL]     if ((x == FastMath.rint(x)) && (x <= 0.0)) { [EOL]         return Double.NaN; [EOL]     } [EOL]     final double ret; [EOL]     final double absX = FastMath.abs(x); [EOL]     if (absX <= 20.0) { [EOL]         if (x >= 1.0) { [EOL]             double prod = 1.0; [EOL]             double t = x; [EOL]             while (t > 2.5) { [EOL]                 t = t - 1.0; [EOL]                 prod *= t; [EOL]             } [EOL]             ret = prod / (1.0 + invGamma1pm1(t - 1.0)); [EOL]         } else { [EOL]             double prod = x; [EOL]             double t = x; [EOL]             while (t < -0.5) { [EOL]                 t = t + 1.0; [EOL]                 prod *= t; [EOL]             } [EOL]             ret = 1.0 / (prod * (1.0 + invGamma1pm1(t))); [EOL]         } [EOL]     } else { [EOL]         final double y = absX + LANCZOS_G + 0.5; [EOL]         final double gammaAbs = SQRT_TWO_PI / x * FastMath.pow(y, absX + 0.5) * FastMath.exp(-y) * lanczos(absX); [EOL]         if (x > 0.0) { [EOL]             ret = gammaAbs; [EOL]         } else { [EOL]             ret = -FastMath.PI / (x * FastMath.sin(FastMath.PI * x) * gammaAbs); [EOL]         } [EOL]     } [EOL]     return ret; [EOL] } <line_num>: 648,710
