private Beta() { [EOL] } <line_num>: 102,102
public static double regularizedBeta(double x, double a, double b) { [EOL]     return regularizedBeta(x, a, b, DEFAULT_EPSILON, Integer.MAX_VALUE); [EOL] } <line_num>: 116,118
public static double regularizedBeta(double x, double a, double b, double epsilon) { [EOL]     return regularizedBeta(x, a, b, epsilon, Integer.MAX_VALUE); [EOL] } <line_num>: 135,139
public static double regularizedBeta(double x, double a, double b, int maxIterations) { [EOL]     return regularizedBeta(x, a, b, DEFAULT_EPSILON, maxIterations); [EOL] } <line_num>: 152,156
@Override [EOL] protected double getB(int n, double x) { [EOL]     double ret; [EOL]     double m; [EOL]     if (n % 2 == 0) { [EOL]         m = n / 2.0; [EOL]         ret = (m * (b - m) * x) / ((a + (2 * m) - 1) * (a + (2 * m))); [EOL]     } else { [EOL]         m = (n - 1.0) / 2.0; [EOL]         ret = -((a + m) * (a + b + m) * x) / ((a + (2 * m)) * (a + (2 * m) + 1.0)); [EOL]     } [EOL]     return ret; [EOL] } <line_num>: 200,214
@Override [EOL] protected double getA(int n, double x) { [EOL]     return 1.0; [EOL] } <line_num>: 216,219
public static double regularizedBeta(double x, final double a, final double b, double epsilon, int maxIterations) { [EOL]     double ret; [EOL]     if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b) || x < 0 || x > 1 || a <= 0.0 || b <= 0.0) { [EOL]         ret = Double.NaN; [EOL]     } else if (x > (a + 1.0) / (a + b + 2.0)) { [EOL]         ret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations); [EOL]     } else { [EOL]         ContinuedFraction fraction = new ContinuedFraction() { [EOL]  [EOL]             @Override [EOL]             protected double getB(int n, double x) { [EOL]                 double ret; [EOL]                 double m; [EOL]                 if (n % 2 == 0) { [EOL]                     m = n / 2.0; [EOL]                     ret = (m * (b - m) * x) / ((a + (2 * m) - 1) * (a + (2 * m))); [EOL]                 } else { [EOL]                     m = (n - 1.0) / 2.0; [EOL]                     ret = -((a + m) * (a + b + m) * x) / ((a + (2 * m)) * (a + (2 * m) + 1.0)); [EOL]                 } [EOL]                 return ret; [EOL]             } [EOL]  [EOL]             @Override [EOL]             protected double getA(int n, double x) { [EOL]                 return 1.0; [EOL]             } [EOL]         }; [EOL]         ret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log(1.0 - x)) - FastMath.log(a) - logBeta(a, b)) * 1.0 / fraction.evaluate(x, epsilon, maxIterations); [EOL]     } [EOL]     return ret; [EOL] } <line_num>: 182,227
@Deprecated [EOL] public static double logBeta(double a, double b, double epsilon, int maxIterations) { [EOL]     return logBeta(a, b); [EOL] } <line_num>: 248,254
private static double logGammaSum(final double a, final double b) throws OutOfRangeException { [EOL]     if ((a < 1.0) || (a > 2.0)) { [EOL]         throw new OutOfRangeException(a, 1.0, 2.0); [EOL]     } [EOL]     if ((b < 1.0) || (b > 2.0)) { [EOL]         throw new OutOfRangeException(b, 1.0, 2.0); [EOL]     } [EOL]     final double x = (a - 1.0) + (b - 1.0); [EOL]     if (x <= 0.5) { [EOL]         return Gamma.logGamma1p(1.0 + x); [EOL]     } else if (x <= 1.5) { [EOL]         return Gamma.logGamma1p(x) + FastMath.log1p(x); [EOL]     } else { [EOL]         return Gamma.logGamma1p(x - 1.0) + FastMath.log(x * (1.0 + x)); [EOL]     } [EOL] } <line_num>: 269,287
private static double logGammaMinusLogGammaSum(final double a, final double b) throws NumberIsTooSmallException { [EOL]     if (a < 0.0) { [EOL]         throw new NumberIsTooSmallException(a, 0.0, true); [EOL]     } [EOL]     if (b < 10.0) { [EOL]         throw new NumberIsTooSmallException(b, 10.0, true); [EOL]     } [EOL]     final double d; [EOL]     final double w; [EOL]     if (a <= b) { [EOL]         d = b + (a - 0.5); [EOL]         w = deltaMinusDeltaSum(a, b); [EOL]     } else { [EOL]         d = a + (b - 0.5); [EOL]         w = deltaMinusDeltaSum(b, a); [EOL]     } [EOL]     final double u = d * FastMath.log1p(a / b); [EOL]     final double v = a * (FastMath.log(b) - 1.0); [EOL]     return u <= v ? (w - u) - v : (w - v) - u; [EOL] } <line_num>: 301,329
private static double deltaMinusDeltaSum(final double a, final double b) throws OutOfRangeException, NumberIsTooSmallException { [EOL]     if ((a < 0) || (a > b)) { [EOL]         throw new OutOfRangeException(a, 0, b); [EOL]     } [EOL]     if (b < 10) { [EOL]         throw new NumberIsTooSmallException(b, 10, true); [EOL]     } [EOL]     final double h = a / b; [EOL]     final double p = h / (1.0 + h); [EOL]     final double q = 1.0 / (1.0 + h); [EOL]     final double q2 = q * q; [EOL]     final double[] s = new double[DELTA.length]; [EOL]     s[0] = 1.0; [EOL]     for (int i = 1; i < s.length; i++) { [EOL]         s[i] = 1.0 + (q + q2 * s[i - 1]); [EOL]     } [EOL]     final double sqrtT = 10.0 / b; [EOL]     final double t = sqrtT * sqrtT; [EOL]     double w = DELTA[DELTA.length - 1] * s[s.length - 1]; [EOL]     for (int i = DELTA.length - 2; i >= 0; i--) { [EOL]         w = t * w + DELTA[i] * s[i]; [EOL]     } [EOL]     return w * p / b; [EOL] } <line_num>: 341,374
private static double sumDeltaMinusDeltaSum(final double p, final double q) { [EOL]     if (p < 10.0) { [EOL]         throw new NumberIsTooSmallException(p, 10.0, true); [EOL]     } [EOL]     if (q < 10.0) { [EOL]         throw new NumberIsTooSmallException(q, 10.0, true); [EOL]     } [EOL]     final double a = FastMath.min(p, q); [EOL]     final double b = FastMath.max(p, q); [EOL]     final double sqrtT = 10.0 / a; [EOL]     final double t = sqrtT * sqrtT; [EOL]     double z = DELTA[DELTA.length - 1]; [EOL]     for (int i = DELTA.length - 2; i >= 0; i--) { [EOL]         z = t * z + DELTA[i]; [EOL]     } [EOL]     return z / a + deltaMinusDeltaSum(a, b); [EOL] } <line_num>: 388,407
public static double logBeta(final double p, final double q) { [EOL]     if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) { [EOL]         return Double.NaN; [EOL]     } [EOL]     final double a = FastMath.min(p, q); [EOL]     final double b = FastMath.max(p, q); [EOL]     if (a >= 10.0) { [EOL]         final double w = sumDeltaMinusDeltaSum(a, b); [EOL]         final double h = a / b; [EOL]         final double c = h / (1.0 + h); [EOL]         final double u = -(a - 0.5) * FastMath.log(c); [EOL]         final double v = b * FastMath.log1p(h); [EOL]         if (u <= v) { [EOL]             return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - u) - v; [EOL]         } else { [EOL]             return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u; [EOL]         } [EOL]     } else if (a > 2.0) { [EOL]         if (b > 1000.0) { [EOL]             final int n = (int) FastMath.floor(a - 1.0); [EOL]             double prod = 1.0; [EOL]             double ared = a; [EOL]             for (int i = 0; i < n; i++) { [EOL]                 ared -= 1.0; [EOL]                 prod *= ared / (1.0 + ared / b); [EOL]             } [EOL]             return (FastMath.log(prod) - n * FastMath.log(b)) + (Gamma.logGamma(ared) + logGammaMinusLogGammaSum(ared, b)); [EOL]         } else { [EOL]             double prod1 = 1.0; [EOL]             double ared = a; [EOL]             while (ared > 2.0) { [EOL]                 ared -= 1.0; [EOL]                 final double h = ared / b; [EOL]                 prod1 *= h / (1.0 + h); [EOL]             } [EOL]             if (b < 10.0) { [EOL]                 double prod2 = 1.0; [EOL]                 double bred = b; [EOL]                 while (bred > 2.0) { [EOL]                     bred -= 1.0; [EOL]                     prod2 *= bred / (ared + bred); [EOL]                 } [EOL]                 return FastMath.log(prod1) + FastMath.log(prod2) + (Gamma.logGamma(ared) + (Gamma.logGamma(bred) - logGammaSum(ared, bred))); [EOL]             } else { [EOL]                 return FastMath.log(prod1) + Gamma.logGamma(ared) + logGammaMinusLogGammaSum(ared, b); [EOL]             } [EOL]         } [EOL]     } else if (a >= 1.0) { [EOL]         if (b > 2.0) { [EOL]             if (b < 10.0) { [EOL]                 double prod = 1.0; [EOL]                 double bred = b; [EOL]                 while (bred > 2.0) { [EOL]                     bred -= 1.0; [EOL]                     prod *= bred / (a + bred); [EOL]                 } [EOL]                 return FastMath.log(prod) + (Gamma.logGamma(a) + (Gamma.logGamma(bred) - logGammaSum(a, bred))); [EOL]             } else { [EOL]                 return Gamma.logGamma(a) + logGammaMinusLogGammaSum(a, b); [EOL]             } [EOL]         } else { [EOL]             return Gamma.logGamma(a) + Gamma.logGamma(b) - logGammaSum(a, b); [EOL]         } [EOL]     } else { [EOL]         if (b >= 10.0) { [EOL]             return Gamma.logGamma(a) + logGammaMinusLogGammaSum(a, b); [EOL]         } else { [EOL]             return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) / Gamma.gamma(a + b)); [EOL]         } [EOL]     } [EOL] } <line_num>: 419,510
