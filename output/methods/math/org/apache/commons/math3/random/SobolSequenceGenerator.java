public SobolSequenceGenerator(final int dimension) throws OutOfRangeException { [EOL]     if (dimension < 1 || dimension > MAX_DIMENSION) { [EOL]         throw new OutOfRangeException(dimension, 1, MAX_DIMENSION); [EOL]     } [EOL]     final InputStream is = getClass().getResourceAsStream(RESOURCE_NAME); [EOL]     if (is == null) { [EOL]         throw new MathInternalError(); [EOL]     } [EOL]     this.dimension = dimension; [EOL]     direction = new long[dimension][BITS + 1]; [EOL]     x = new long[dimension]; [EOL]     try { [EOL]         initFromStream(is); [EOL]     } catch (IOException e) { [EOL]         throw new MathInternalError(); [EOL]     } catch (MathParseException e) { [EOL]         throw new MathInternalError(); [EOL]     } finally { [EOL]         try { [EOL]             is.close(); [EOL]         } catch (IOException e) { [EOL]         } [EOL]     } [EOL] } <line_num>: 92,124
public SobolSequenceGenerator(final int dimension, final InputStream is) throws NotStrictlyPositiveException, MathParseException, IOException { [EOL]     if (dimension < 1) { [EOL]         throw new NotStrictlyPositiveException(dimension); [EOL]     } [EOL]     this.dimension = dimension; [EOL]     direction = new long[dimension][BITS + 1]; [EOL]     x = new long[dimension]; [EOL]     int lastDimension = initFromStream(is); [EOL]     if (lastDimension < dimension) { [EOL]         throw new OutOfRangeException(dimension, 1, lastDimension); [EOL]     } [EOL] } <line_num>: 157,175
private int initFromStream(final InputStream is) throws MathParseException, IOException { [EOL]     for (int i = 1; i <= BITS; i++) { [EOL]         direction[0][i] = 1l << (BITS - i); [EOL]     } [EOL]     final Charset charset = Charset.forName(FILE_CHARSET); [EOL]     final BufferedReader reader = new BufferedReader(new InputStreamReader(is, charset)); [EOL]     int dim = -1; [EOL]     try { [EOL]         reader.readLine(); [EOL]         int lineNumber = 2; [EOL]         int index = 1; [EOL]         String line = null; [EOL]         while ((line = reader.readLine()) != null) { [EOL]             StringTokenizer st = new StringTokenizer(line, " "); [EOL]             try { [EOL]                 dim = Integer.parseInt(st.nextToken()); [EOL]                 if (dim >= 2 && dim <= dimension) { [EOL]                     final int s = Integer.parseInt(st.nextToken()); [EOL]                     final int a = Integer.parseInt(st.nextToken()); [EOL]                     final int[] m = new int[s + 1]; [EOL]                     for (int i = 1; i <= s; i++) { [EOL]                         m[i] = Integer.parseInt(st.nextToken()); [EOL]                     } [EOL]                     initDirectionVector(index++, a, m); [EOL]                 } [EOL]                 if (dim > dimension) { [EOL]                     return dim; [EOL]                 } [EOL]             } catch (NoSuchElementException e) { [EOL]                 throw new MathParseException(line, lineNumber); [EOL]             } catch (NumberFormatException e) { [EOL]                 throw new MathParseException(line, lineNumber); [EOL]             } [EOL]             lineNumber++; [EOL]         } [EOL]     } finally { [EOL]         reader.close(); [EOL]     } [EOL]     return dim; [EOL] } <line_num>: 188,235
private void initDirectionVector(final int d, final int a, final int[] m) { [EOL]     final int s = m.length - 1; [EOL]     for (int i = 1; i <= s; i++) { [EOL]         direction[d][i] = ((long) m[i]) << (BITS - i); [EOL]     } [EOL]     for (int i = s + 1; i <= BITS; i++) { [EOL]         direction[d][i] = direction[d][i - s] ^ (direction[d][i - s] >> s); [EOL]         for (int k = 1; k <= s - 1; k++) { [EOL]             direction[d][i] ^= ((a >> (s - 1 - k)) & 1) * direction[d][i - k]; [EOL]         } [EOL]     } [EOL] } <line_num>: 244,255
public double[] nextVector() { [EOL]     final double[] v = new double[dimension]; [EOL]     if (count == 0) { [EOL]         count++; [EOL]         return v; [EOL]     } [EOL]     int c = 1; [EOL]     int value = count - 1; [EOL]     while ((value & 1) == 1) { [EOL]         value >>= 1; [EOL]         c++; [EOL]     } [EOL]     for (int i = 0; i < dimension; i++) { [EOL]         x[i] = x[i] ^ direction[i][c]; [EOL]         v[i] = (double) x[i] / SCALE; [EOL]     } [EOL]     count++; [EOL]     return v; [EOL] } <line_num>: 258,279
public double[] skipTo(final int index) throws NotPositiveException { [EOL]     if (index == 0) { [EOL]         Arrays.fill(x, 0); [EOL]     } else { [EOL]         final int i = index - 1; [EOL]         final long grayCode = i ^ (i >> 1); [EOL]         for (int j = 0; j < dimension; j++) { [EOL]             long result = 0; [EOL]             for (int k = 1; k <= BITS; k++) { [EOL]                 final long shift = grayCode >> (k - 1); [EOL]                 if (shift == 0) { [EOL]                     break; [EOL]                 } [EOL]                 final long ik = shift & 1; [EOL]                 result ^= ik * direction[j][k]; [EOL]             } [EOL]             x[j] = result; [EOL]         } [EOL]     } [EOL]     count = index; [EOL]     return nextVector(); [EOL] } <line_num>: 290,314
public int getNextIndex() { [EOL]     return count; [EOL] } <line_num>: 322,324
