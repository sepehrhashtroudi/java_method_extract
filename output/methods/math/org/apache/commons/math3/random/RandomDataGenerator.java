public RandomDataGenerator() { [EOL] } <line_num>: 132,133
public RandomDataGenerator(RandomGenerator rand) { [EOL]     this.rand = rand; [EOL] } <line_num>: 142,144
public String nextHexString(int len) throws NotStrictlyPositiveException { [EOL]     if (len <= 0) { [EOL]         throw new NotStrictlyPositiveException(LocalizedFormats.LENGTH, len); [EOL]     } [EOL]     RandomGenerator ran = getRandomGenerator(); [EOL]     StringBuilder outBuffer = new StringBuilder(); [EOL]     byte[] randomBytes = new byte[(len / 2) + 1]; [EOL]     ran.nextBytes(randomBytes); [EOL]     for (int i = 0; i < randomBytes.length; i++) { [EOL]         Integer c = Integer.valueOf(randomBytes[i]); [EOL]         String hex = Integer.toHexString(c.intValue() + 128); [EOL]         if (hex.length() == 1) { [EOL]             hex = "0" + hex; [EOL]         } [EOL]         outBuffer.append(hex); [EOL]     } [EOL]     return outBuffer.toString().substring(0, len); [EOL] } <line_num>: 162,195
public int nextInt(final int lower, final int upper) throws NumberIsTooLargeException { [EOL]     return new UniformIntegerDistribution(getRandomGenerator(), lower, upper).sample(); [EOL] } <line_num>: 198,200
public long nextLong(final long lower, final long upper) throws NumberIsTooLargeException { [EOL]     if (lower >= upper) { [EOL]         throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND, lower, upper, false); [EOL]     } [EOL]     final long max = (upper - lower) + 1; [EOL]     if (max <= 0) { [EOL]         final RandomGenerator rng = getRandomGenerator(); [EOL]         while (true) { [EOL]             final long r = rng.nextLong(); [EOL]             if (r >= lower && r <= upper) { [EOL]                 return r; [EOL]             } [EOL]         } [EOL]     } else if (max < Integer.MAX_VALUE) { [EOL]         return lower + getRandomGenerator().nextInt((int) max); [EOL]     } else { [EOL]         return lower + nextLong(getRandomGenerator(), max); [EOL]     } [EOL] } <line_num>: 203,226
private static long nextLong(final RandomGenerator rng, final long n) throws IllegalArgumentException { [EOL]     if (n > 0) { [EOL]         final byte[] byteArray = new byte[8]; [EOL]         long bits; [EOL]         long val; [EOL]         do { [EOL]             rng.nextBytes(byteArray); [EOL]             bits = 0; [EOL]             for (final byte b : byteArray) { [EOL]                 bits = (bits << 8) | (((long) b) & 0xffL); [EOL]             } [EOL]             bits = bits & 0x7fffffffffffffffL; [EOL]             val = bits % n; [EOL]         } while (bits - val + (n - 1) < 0); [EOL]         return val; [EOL]     } [EOL]     throw new NotStrictlyPositiveException(n); [EOL] } <line_num>: 240,257
public String nextSecureHexString(int len) throws NotStrictlyPositiveException { [EOL]     if (len <= 0) { [EOL]         throw new NotStrictlyPositiveException(LocalizedFormats.LENGTH, len); [EOL]     } [EOL]     final RandomGenerator secRan = getSecRan(); [EOL]     MessageDigest alg = null; [EOL]     try { [EOL]         alg = MessageDigest.getInstance("SHA-1"); [EOL]     } catch (NoSuchAlgorithmException ex) { [EOL]         throw new MathInternalError(ex); [EOL]     } [EOL]     alg.reset(); [EOL]     int numIter = (len / 40) + 1; [EOL]     StringBuilder outBuffer = new StringBuilder(); [EOL]     for (int iter = 1; iter < numIter + 1; iter++) { [EOL]         byte[] randomBytes = new byte[40]; [EOL]         secRan.nextBytes(randomBytes); [EOL]         alg.update(randomBytes); [EOL]         byte[] hash = alg.digest(); [EOL]         for (int i = 0; i < hash.length; i++) { [EOL]             Integer c = Integer.valueOf(hash[i]); [EOL]             String hex = Integer.toHexString(c.intValue() + 128); [EOL]             if (hex.length() == 1) { [EOL]                 hex = "0" + hex; [EOL]             } [EOL]             outBuffer.append(hex); [EOL]         } [EOL]     } [EOL]     return outBuffer.toString().substring(0, len); [EOL] } <line_num>: 276,323
public int nextSecureInt(final int lower, final int upper) throws NumberIsTooLargeException { [EOL]     return new UniformIntegerDistribution(getSecRan(), lower, upper).sample(); [EOL] } <line_num>: 326,328
public long nextSecureLong(final long lower, final long upper) throws NumberIsTooLargeException { [EOL]     if (lower >= upper) { [EOL]         throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND, lower, upper, false); [EOL]     } [EOL]     final RandomGenerator rng = getSecRan(); [EOL]     final long max = (upper - lower) + 1; [EOL]     if (max <= 0) { [EOL]         while (true) { [EOL]             final long r = rng.nextLong(); [EOL]             if (r >= lower && r <= upper) { [EOL]                 return r; [EOL]             } [EOL]         } [EOL]     } else if (max < Integer.MAX_VALUE) { [EOL]         return lower + rng.nextInt((int) max); [EOL]     } else { [EOL]         return lower + nextLong(rng, max); [EOL]     } [EOL] } <line_num>: 331,354
public long nextPoisson(double mean) throws NotStrictlyPositiveException { [EOL]     return new PoissonDistribution(getRandomGenerator(), mean, PoissonDistribution.DEFAULT_EPSILON, PoissonDistribution.DEFAULT_MAX_ITERATIONS).sample(); [EOL] } <line_num>: 370,374
public double nextGaussian(double mu, double sigma) throws NotStrictlyPositiveException { [EOL]     if (sigma <= 0) { [EOL]         throw new NotStrictlyPositiveException(LocalizedFormats.STANDARD_DEVIATION, sigma); [EOL]     } [EOL]     return sigma * getRandomGenerator().nextGaussian() + mu; [EOL] } <line_num>: 377,382
public double nextExponential(double mean) throws NotStrictlyPositiveException { [EOL]     return new ExponentialDistribution(getRandomGenerator(), mean, ExponentialDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample(); [EOL] } <line_num>: 395,398
public double nextGamma(double shape, double scale) throws NotStrictlyPositiveException { [EOL]     return new GammaDistribution(getRandomGenerator(), shape, scale, GammaDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample(); [EOL] } <line_num>: 422,425
public int nextHypergeometric(int populationSize, int numberOfSuccesses, int sampleSize) throws NotPositiveException, NotStrictlyPositiveException, NumberIsTooLargeException { [EOL]     return new HypergeometricDistribution(getRandomGenerator(), populationSize, numberOfSuccesses, sampleSize).sample(); [EOL] } <line_num>: 439,442
public int nextPascal(int r, double p) throws NotStrictlyPositiveException, OutOfRangeException { [EOL]     return new PascalDistribution(getRandomGenerator(), r, p).sample(); [EOL] } <line_num>: 454,456
public double nextT(double df) throws NotStrictlyPositiveException { [EOL]     return new TDistribution(getRandomGenerator(), df, TDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample(); [EOL] } <line_num>: 465,468
public double nextWeibull(double shape, double scale) throws NotStrictlyPositiveException { [EOL]     return new WeibullDistribution(getRandomGenerator(), shape, scale, WeibullDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample(); [EOL] } <line_num>: 479,482
public int nextZipf(int numberOfElements, double exponent) throws NotStrictlyPositiveException { [EOL]     return new ZipfDistribution(getRandomGenerator(), numberOfElements, exponent).sample(); [EOL] } <line_num>: 493,495
public double nextBeta(double alpha, double beta) { [EOL]     return new BetaDistribution(getRandomGenerator(), alpha, beta, BetaDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample(); [EOL] } <line_num>: 504,507
public int nextBinomial(int numberOfTrials, double probabilityOfSuccess) { [EOL]     return new BinomialDistribution(getRandomGenerator(), numberOfTrials, probabilityOfSuccess).sample(); [EOL] } <line_num>: 516,518
public double nextCauchy(double median, double scale) { [EOL]     return new CauchyDistribution(getRandomGenerator(), median, scale, CauchyDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample(); [EOL] } <line_num>: 527,530
public double nextChiSquare(double df) { [EOL]     return new ChiSquaredDistribution(getRandomGenerator(), df, ChiSquaredDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample(); [EOL] } <line_num>: 538,541
public double nextF(double numeratorDf, double denominatorDf) throws NotStrictlyPositiveException { [EOL]     return new FDistribution(getRandomGenerator(), numeratorDf, denominatorDf, FDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample(); [EOL] } <line_num>: 552,555
public double nextUniform(double lower, double upper) throws NumberIsTooLargeException, NotFiniteNumberException, NotANumberException { [EOL]     return nextUniform(lower, upper, false); [EOL] } <line_num>: 570,573
public double nextUniform(double lower, double upper, boolean lowerInclusive) throws NumberIsTooLargeException, NotFiniteNumberException, NotANumberException { [EOL]     if (lower >= upper) { [EOL]         throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND, lower, upper, false); [EOL]     } [EOL]     if (Double.isInfinite(lower)) { [EOL]         throw new NotFiniteNumberException(LocalizedFormats.INFINITE_BOUND, lower); [EOL]     } [EOL]     if (Double.isInfinite(upper)) { [EOL]         throw new NotFiniteNumberException(LocalizedFormats.INFINITE_BOUND, upper); [EOL]     } [EOL]     if (Double.isNaN(lower) || Double.isNaN(upper)) { [EOL]         throw new NotANumberException(); [EOL]     } [EOL]     final RandomGenerator generator = getRandomGenerator(); [EOL]     double u = generator.nextDouble(); [EOL]     while (!lowerInclusive && u <= 0.0) { [EOL]         u = generator.nextDouble(); [EOL]     } [EOL]     return u * upper + (1.0 - u) * lower; [EOL] } <line_num>: 590,618
public int[] nextPermutation(int n, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException { [EOL]     if (k > n) { [EOL]         throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N, k, n, true); [EOL]     } [EOL]     if (k <= 0) { [EOL]         throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE, k); [EOL]     } [EOL]     int[] index = getNatural(n); [EOL]     MathArrays.shuffle(index, getRandomGenerator()); [EOL]     return MathArrays.copyOf(index, k); [EOL] } <line_num>: 630,646
public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException { [EOL]     int len = c.size(); [EOL]     if (k > len) { [EOL]         throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE, k, len, true); [EOL]     } [EOL]     if (k <= 0) { [EOL]         throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, k); [EOL]     } [EOL]     Object[] objects = c.toArray(); [EOL]     int[] index = nextPermutation(len, k); [EOL]     Object[] result = new Object[k]; [EOL]     for (int i = 0; i < k; i++) { [EOL]         result[i] = objects[index[i]]; [EOL]     } [EOL]     return result; [EOL] } <line_num>: 654,672
public void reSeed(long seed) { [EOL]     getRandomGenerator().setSeed(seed); [EOL] } <line_num>: 684,686
public void reSeedSecure() { [EOL]     getSecRan().setSeed(System.currentTimeMillis()); [EOL] } <line_num>: 695,697
public void reSeedSecure(long seed) { [EOL]     getSecRan().setSeed(seed); [EOL] } <line_num>: 707,709
public void reSeed() { [EOL]     getRandomGenerator().setSeed(System.currentTimeMillis() + System.identityHashCode(this)); [EOL] } <line_num>: 715,717
public void setSecureAlgorithm(String algorithm, String provider) throws NoSuchAlgorithmException, NoSuchProviderException { [EOL]     secRand = RandomGeneratorFactory.createRandomGenerator(SecureRandom.getInstance(algorithm, provider)); [EOL] } <line_num>: 735,738
public RandomGenerator getRandomGenerator() { [EOL]     if (rand == null) { [EOL]         initRan(); [EOL]     } [EOL]     return rand; [EOL] } <line_num>: 751,756
private void initRan() { [EOL]     rand = new Well19937c(System.currentTimeMillis() + System.identityHashCode(this)); [EOL] } <line_num>: 762,764
private RandomGenerator getSecRan() { [EOL]     if (secRand == null) { [EOL]         secRand = RandomGeneratorFactory.createRandomGenerator(new SecureRandom()); [EOL]         secRand.setSeed(System.currentTimeMillis() + System.identityHashCode(this)); [EOL]     } [EOL]     return secRand; [EOL] } <line_num>: 776,782
private int[] getNatural(int n) { [EOL]     int[] natural = new int[n]; [EOL]     for (int i = 0; i < n; i++) { [EOL]         natural[i] = i; [EOL]     } [EOL]     return natural; [EOL] } <line_num>: 790,796
