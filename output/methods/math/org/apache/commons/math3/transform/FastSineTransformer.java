public FastSineTransformer(final DstNormalization normalization) { [EOL]     this.normalization = normalization; [EOL] } <line_num>: 84,86
public double[] transform(final double[] f, final TransformType type) { [EOL]     if (normalization == DstNormalization.ORTHOGONAL_DST_I) { [EOL]         final double s = FastMath.sqrt(2.0 / f.length); [EOL]         return TransformUtils.scaleArray(fst(f), s); [EOL]     } [EOL]     if (type == TransformType.FORWARD) { [EOL]         return fst(f); [EOL]     } [EOL]     final double s = 2.0 / f.length; [EOL]     return TransformUtils.scaleArray(fst(f), s); [EOL] } <line_num>: 96,106
public double[] transform(final UnivariateFunction f, final double min, final double max, final int n, final TransformType type) { [EOL]     final double[] data = FunctionUtils.sample(f, min, max, n); [EOL]     data[0] = 0.0; [EOL]     return transform(data, type); [EOL] } <line_num>: 119,126
protected double[] fst(double[] f) throws MathIllegalArgumentException { [EOL]     final double[] transformed = new double[f.length]; [EOL]     if (!ArithmeticUtils.isPowerOfTwo(f.length)) { [EOL]         throw new MathIllegalArgumentException(LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING, Integer.valueOf(f.length)); [EOL]     } [EOL]     if (f[0] != 0.0) { [EOL]         throw new MathIllegalArgumentException(LocalizedFormats.FIRST_ELEMENT_NOT_ZERO, Double.valueOf(f[0])); [EOL]     } [EOL]     final int n = f.length; [EOL]     if (n == 1) { [EOL]         transformed[0] = 0.0; [EOL]         return transformed; [EOL]     } [EOL]     final double[] x = new double[n]; [EOL]     x[0] = 0.0; [EOL]     x[n >> 1] = 2.0 * f[n >> 1]; [EOL]     for (int i = 1; i < (n >> 1); i++) { [EOL]         final double a = FastMath.sin(i * FastMath.PI / n) * (f[i] + f[n - i]); [EOL]         final double b = 0.5 * (f[i] - f[n - i]); [EOL]         x[i] = a + b; [EOL]         x[n - i] = a - b; [EOL]     } [EOL]     FastFourierTransformer transformer; [EOL]     transformer = new FastFourierTransformer(DftNormalization.STANDARD); [EOL]     Complex[] y = transformer.transform(x, TransformType.FORWARD); [EOL]     transformed[0] = 0.0; [EOL]     transformed[1] = 0.5 * y[0].getReal(); [EOL]     for (int i = 1; i < (n >> 1); i++) { [EOL]         transformed[2 * i] = -y[i].getImaginary(); [EOL]         transformed[2 * i + 1] = y[i].getReal() + transformed[2 * i - 1]; [EOL]     } [EOL]     return transformed; [EOL] } <line_num>: 137,180
