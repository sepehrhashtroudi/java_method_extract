public double[] transform(final double[] f, final TransformType type) { [EOL]     if (type == TransformType.FORWARD) { [EOL]         return fht(f); [EOL]     } [EOL]     return TransformUtils.scaleArray(fht(f), 1.0 / f.length); [EOL] } <line_num>: 51,56
public double[] transform(final UnivariateFunction f, final double min, final double max, final int n, final TransformType type) { [EOL]     return transform(FunctionUtils.sample(f, min, max, n), type); [EOL] } <line_num>: 67,72
public int[] transform(final int[] f) { [EOL]     return fht(f); [EOL] } <line_num>: 83,85
protected double[] fht(double[] x) throws MathIllegalArgumentException { [EOL]     final int n = x.length; [EOL]     final int halfN = n / 2; [EOL]     if (!ArithmeticUtils.isPowerOfTwo(n)) { [EOL]         throw new MathIllegalArgumentException(LocalizedFormats.NOT_POWER_OF_TWO, Integer.valueOf(n)); [EOL]     } [EOL]     double[] yPrevious = new double[n]; [EOL]     double[] yCurrent = x.clone(); [EOL]     for (int j = 1; j < n; j <<= 1) { [EOL]         final double[] yTmp = yCurrent; [EOL]         yCurrent = yPrevious; [EOL]         yPrevious = yTmp; [EOL]         for (int i = 0; i < halfN; ++i) { [EOL]             final int twoI = 2 * i; [EOL]             yCurrent[i] = yPrevious[twoI] + yPrevious[twoI + 1]; [EOL]         } [EOL]         for (int i = halfN; i < n; ++i) { [EOL]             final int twoI = 2 * i; [EOL]             yCurrent[i] = yPrevious[twoI - n] - yPrevious[twoI - n + 1]; [EOL]         } [EOL]     } [EOL]     return yCurrent; [EOL] } <line_num>: 229,270
protected int[] fht(int[] x) throws MathIllegalArgumentException { [EOL]     final int n = x.length; [EOL]     final int halfN = n / 2; [EOL]     if (!ArithmeticUtils.isPowerOfTwo(n)) { [EOL]         throw new MathIllegalArgumentException(LocalizedFormats.NOT_POWER_OF_TWO, Integer.valueOf(n)); [EOL]     } [EOL]     int[] yPrevious = new int[n]; [EOL]     int[] yCurrent = x.clone(); [EOL]     for (int j = 1; j < n; j <<= 1) { [EOL]         final int[] yTmp = yCurrent; [EOL]         yCurrent = yPrevious; [EOL]         yPrevious = yTmp; [EOL]         for (int i = 0; i < halfN; ++i) { [EOL]             final int twoI = 2 * i; [EOL]             yCurrent[i] = yPrevious[twoI] + yPrevious[twoI + 1]; [EOL]         } [EOL]         for (int i = halfN; i < n; ++i) { [EOL]             final int twoI = 2 * i; [EOL]             yCurrent[i] = yPrevious[twoI - n] - yPrevious[twoI - n + 1]; [EOL]         } [EOL]     } [EOL]     return yCurrent; [EOL] } <line_num>: 280,322
