public FastFourierTransformer(final DftNormalization normalization) { [EOL]     this.normalization = normalization; [EOL] } <line_num>: 115,117
public MultiDimensionalComplexMatrix(Object multiDimensionalComplexArray) { [EOL]     this.multiDimensionalComplexArray = multiDimensionalComplexArray; [EOL]     int numOfDimensions = 0; [EOL]     for (Object lastDimension = multiDimensionalComplexArray; lastDimension instanceof Object[]; ) { [EOL]         final Object[] array = (Object[]) lastDimension; [EOL]         numOfDimensions++; [EOL]         lastDimension = array[0]; [EOL]     } [EOL]     dimensionSize = new int[numOfDimensions]; [EOL]     numOfDimensions = 0; [EOL]     for (Object lastDimension = multiDimensionalComplexArray; lastDimension instanceof Object[]; ) { [EOL]         final Object[] array = (Object[]) lastDimension; [EOL]         dimensionSize[numOfDimensions++] = array.length; [EOL]         lastDimension = array[0]; [EOL]     } [EOL] } <line_num>: 520,546
private static void bitReversalShuffle2(double[] a, double[] b) { [EOL]     final int n = a.length; [EOL]     assert b.length == n; [EOL]     final int halfOfN = n >> 1; [EOL]     int j = 0; [EOL]     for (int i = 0; i < n; i++) { [EOL]         if (i < j) { [EOL]             double temp = a[i]; [EOL]             a[i] = a[j]; [EOL]             a[j] = temp; [EOL]             temp = b[i]; [EOL]             b[i] = b[j]; [EOL]             b[j] = temp; [EOL]         } [EOL]         int k = halfOfN; [EOL]         while (k <= j && k > 0) { [EOL]             j -= k; [EOL]             k >>= 1; [EOL]         } [EOL]         j += k; [EOL]     } [EOL] } <line_num>: 129,154
private static void normalizeTransformedData(final double[][] dataRI, final DftNormalization normalization, final TransformType type) { [EOL]     final double[] dataR = dataRI[0]; [EOL]     final double[] dataI = dataRI[1]; [EOL]     final int n = dataR.length; [EOL]     assert dataI.length == n; [EOL]     switch(normalization) { [EOL]         case STANDARD: [EOL]             if (type == TransformType.INVERSE) { [EOL]                 final double scaleFactor = 1.0 / ((double) n); [EOL]                 for (int i = 0; i < n; i++) { [EOL]                     dataR[i] *= scaleFactor; [EOL]                     dataI[i] *= scaleFactor; [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case UNITARY: [EOL]             final double scaleFactor = 1.0 / FastMath.sqrt(n); [EOL]             for (int i = 0; i < n; i++) { [EOL]                 dataR[i] *= scaleFactor; [EOL]                 dataI[i] *= scaleFactor; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new MathIllegalStateException(); [EOL]     } [EOL] } <line_num>: 163,197
public static void transformInPlace(final double[][] dataRI, final DftNormalization normalization, final TransformType type) { [EOL]     if (dataRI.length != 2) { [EOL]         throw new DimensionMismatchException(dataRI.length, 2); [EOL]     } [EOL]     final double[] dataR = dataRI[0]; [EOL]     final double[] dataI = dataRI[1]; [EOL]     if (dataR.length != dataI.length) { [EOL]         throw new DimensionMismatchException(dataI.length, dataR.length); [EOL]     } [EOL]     final int n = dataR.length; [EOL]     if (!ArithmeticUtils.isPowerOfTwo(n)) { [EOL]         throw new MathIllegalArgumentException(LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING, Integer.valueOf(n)); [EOL]     } [EOL]     if (n == 1) { [EOL]         return; [EOL]     } else if (n == 2) { [EOL]         final double srcR0 = dataR[0]; [EOL]         final double srcI0 = dataI[0]; [EOL]         final double srcR1 = dataR[1]; [EOL]         final double srcI1 = dataI[1]; [EOL]         dataR[0] = srcR0 + srcR1; [EOL]         dataI[0] = srcI0 + srcI1; [EOL]         dataR[1] = srcR0 - srcR1; [EOL]         dataI[1] = srcI0 - srcI1; [EOL]         normalizeTransformedData(dataRI, normalization, type); [EOL]         return; [EOL]     } [EOL]     bitReversalShuffle2(dataR, dataI); [EOL]     if (type == TransformType.INVERSE) { [EOL]         for (int i0 = 0; i0 < n; i0 += 4) { [EOL]             final int i1 = i0 + 1; [EOL]             final int i2 = i0 + 2; [EOL]             final int i3 = i0 + 3; [EOL]             final double srcR0 = dataR[i0]; [EOL]             final double srcI0 = dataI[i0]; [EOL]             final double srcR1 = dataR[i2]; [EOL]             final double srcI1 = dataI[i2]; [EOL]             final double srcR2 = dataR[i1]; [EOL]             final double srcI2 = dataI[i1]; [EOL]             final double srcR3 = dataR[i3]; [EOL]             final double srcI3 = dataI[i3]; [EOL]             dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3; [EOL]             dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3; [EOL]             dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1); [EOL]             dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3); [EOL]             dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3; [EOL]             dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3; [EOL]             dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3); [EOL]             dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1); [EOL]         } [EOL]     } else { [EOL]         for (int i0 = 0; i0 < n; i0 += 4) { [EOL]             final int i1 = i0 + 1; [EOL]             final int i2 = i0 + 2; [EOL]             final int i3 = i0 + 3; [EOL]             final double srcR0 = dataR[i0]; [EOL]             final double srcI0 = dataI[i0]; [EOL]             final double srcR1 = dataR[i2]; [EOL]             final double srcI1 = dataI[i2]; [EOL]             final double srcR2 = dataR[i1]; [EOL]             final double srcI2 = dataI[i1]; [EOL]             final double srcR3 = dataR[i3]; [EOL]             final double srcI3 = dataI[i3]; [EOL]             dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3; [EOL]             dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3; [EOL]             dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3); [EOL]             dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1); [EOL]             dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3; [EOL]             dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3; [EOL]             dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1); [EOL]             dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3); [EOL]         } [EOL]     } [EOL]     int lastN0 = 4; [EOL]     int lastLogN0 = 2; [EOL]     while (lastN0 < n) { [EOL]         int n0 = lastN0 << 1; [EOL]         int logN0 = lastLogN0 + 1; [EOL]         double wSubN0R = W_SUB_N_R[logN0]; [EOL]         double wSubN0I = W_SUB_N_I[logN0]; [EOL]         if (type == TransformType.INVERSE) { [EOL]             wSubN0I = -wSubN0I; [EOL]         } [EOL]         for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) { [EOL]             int destOddStartIndex = destEvenStartIndex + lastN0; [EOL]             double wSubN0ToRR = 1; [EOL]             double wSubN0ToRI = 0; [EOL]             for (int r = 0; r < lastN0; r++) { [EOL]                 double grR = dataR[destEvenStartIndex + r]; [EOL]                 double grI = dataI[destEvenStartIndex + r]; [EOL]                 double hrR = dataR[destOddStartIndex + r]; [EOL]                 double hrI = dataI[destOddStartIndex + r]; [EOL]                 dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI; [EOL]                 dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR; [EOL]                 dataR[destOddStartIndex + r] = grR - (wSubN0ToRR * hrR - wSubN0ToRI * hrI); [EOL]                 dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR); [EOL]                 double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I; [EOL]                 double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R; [EOL]                 wSubN0ToRR = nextWsubN0ToRR; [EOL]                 wSubN0ToRI = nextWsubN0ToRI; [EOL]             } [EOL]         } [EOL]         lastN0 = n0; [EOL]         lastLogN0 = logN0; [EOL]     } [EOL]     normalizeTransformedData(dataRI, normalization, type); [EOL] } <line_num>: 215,360
public Complex[] transform(final double[] f, final TransformType type) { [EOL]     final double[][] dataRI = new double[][] { MathArrays.copyOf(f, f.length), new double[f.length] }; [EOL]     transformInPlace(dataRI, normalization, type); [EOL]     return TransformUtils.createComplexArray(dataRI); [EOL] } <line_num>: 370,378
public Complex[] transform(final UnivariateFunction f, final double min, final double max, final int n, final TransformType type) { [EOL]     final double[] data = FunctionUtils.sample(f, min, max, n); [EOL]     return transform(data, type); [EOL] } <line_num>: 397,403
public Complex[] transform(final Complex[] f, final TransformType type) { [EOL]     final double[][] dataRI = TransformUtils.createRealImaginaryArray(f); [EOL]     transformInPlace(dataRI, normalization, type); [EOL]     return TransformUtils.createComplexArray(dataRI); [EOL] } <line_num>: 413,419
@Deprecated [EOL] public Object mdfft(Object mdca, TransformType type) { [EOL]     MultiDimensionalComplexMatrix mdcm = (MultiDimensionalComplexMatrix) new MultiDimensionalComplexMatrix(mdca).clone(); [EOL]     int[] dimensionSize = mdcm.getDimensionSizes(); [EOL]     for (int i = 0; i < dimensionSize.length; i++) { [EOL]         mdfft(mdcm, type, i, new int[0]); [EOL]     } [EOL]     return mdcm.getArray(); [EOL] } <line_num>: 436,446
@Deprecated [EOL] private void mdfft(MultiDimensionalComplexMatrix mdcm, TransformType type, int d, int[] subVector) { [EOL]     int[] dimensionSize = mdcm.getDimensionSizes(); [EOL]     if (subVector.length == dimensionSize.length) { [EOL]         Complex[] temp = new Complex[dimensionSize[d]]; [EOL]         for (int i = 0; i < dimensionSize[d]; i++) { [EOL]             subVector[d] = i; [EOL]             temp[i] = mdcm.get(subVector); [EOL]         } [EOL]         temp = transform(temp, type); [EOL]         for (int i = 0; i < dimensionSize[d]; i++) { [EOL]             subVector[d] = i; [EOL]             mdcm.set(temp[i], subVector); [EOL]         } [EOL]     } else { [EOL]         int[] vector = new int[subVector.length + 1]; [EOL]         System.arraycopy(subVector, 0, vector, 0, subVector.length); [EOL]         if (subVector.length == d) { [EOL]             vector[d] = 0; [EOL]             mdfft(mdcm, type, d, vector); [EOL]         } else { [EOL]             for (int i = 0; i < dimensionSize[subVector.length]; i++) { [EOL]                 vector[subVector.length] = i; [EOL]                 mdfft(mdcm, type, d, vector); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 458,494
public Complex get(int... vector) throws DimensionMismatchException { [EOL]     if (vector == null) { [EOL]         if (dimensionSize.length > 0) { [EOL]             throw new DimensionMismatchException(0, dimensionSize.length); [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (vector.length != dimensionSize.length) { [EOL]         throw new DimensionMismatchException(vector.length, dimensionSize.length); [EOL]     } [EOL]     Object lastDimension = multiDimensionalComplexArray; [EOL]     for (int i = 0; i < dimensionSize.length; i++) { [EOL]         lastDimension = ((Object[]) lastDimension)[vector[i]]; [EOL]     } [EOL]     return (Complex) lastDimension; [EOL] } <line_num>: 555,578
public Complex set(Complex magnitude, int... vector) throws DimensionMismatchException { [EOL]     if (vector == null) { [EOL]         if (dimensionSize.length > 0) { [EOL]             throw new DimensionMismatchException(0, dimensionSize.length); [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (vector.length != dimensionSize.length) { [EOL]         throw new DimensionMismatchException(vector.length, dimensionSize.length); [EOL]     } [EOL]     Object[] lastDimension = (Object[]) multiDimensionalComplexArray; [EOL]     for (int i = 0; i < dimensionSize.length - 1; i++) { [EOL]         lastDimension = (Object[]) lastDimension[vector[i]]; [EOL]     } [EOL]     Complex lastValue = (Complex) lastDimension[vector[dimensionSize.length - 1]]; [EOL]     lastDimension[vector[dimensionSize.length - 1]] = magnitude; [EOL]     return lastValue; [EOL] } <line_num>: 588,614
public int[] getDimensionSizes() { [EOL]     return dimensionSize.clone(); [EOL] } <line_num>: 621,623
public Object getArray() { [EOL]     return multiDimensionalComplexArray; [EOL] } <line_num>: 630,632
@Override [EOL] public Object clone() { [EOL]     MultiDimensionalComplexMatrix mdcm = new MultiDimensionalComplexMatrix(Array.newInstance(Complex.class, dimensionSize)); [EOL]     clone(mdcm); [EOL]     return mdcm; [EOL] } <line_num>: 635,642
private void clone(MultiDimensionalComplexMatrix mdcm) { [EOL]     int[] vector = new int[dimensionSize.length]; [EOL]     int size = 1; [EOL]     for (int i = 0; i < dimensionSize.length; i++) { [EOL]         size *= dimensionSize[i]; [EOL]     } [EOL]     int[][] vectorList = new int[size][dimensionSize.length]; [EOL]     for (int[] nextVector : vectorList) { [EOL]         System.arraycopy(vector, 0, nextVector, 0, dimensionSize.length); [EOL]         for (int i = 0; i < dimensionSize.length; i++) { [EOL]             vector[i]++; [EOL]             if (vector[i] < dimensionSize[i]) { [EOL]                 break; [EOL]             } else { [EOL]                 vector[i] = 0; [EOL]             } [EOL]         } [EOL]     } [EOL]     for (int[] nextVector : vectorList) { [EOL]         mdcm.set(get(nextVector), nextVector); [EOL]     } [EOL] } <line_num>: 649,673
