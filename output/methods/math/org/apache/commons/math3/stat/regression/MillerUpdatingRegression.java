@SuppressWarnings("unused") [EOL] private MillerUpdatingRegression() { [EOL]     this(-1, false, Double.NaN); [EOL] } <line_num>: 87,90
public MillerUpdatingRegression(int numberOfVariables, boolean includeConstant, double errorTolerance) throws ModelSpecificationException { [EOL]     if (numberOfVariables < 1) { [EOL]         throw new ModelSpecificationException(LocalizedFormats.NO_REGRESSORS); [EOL]     } [EOL]     if (includeConstant) { [EOL]         this.nvars = numberOfVariables + 1; [EOL]     } else { [EOL]         this.nvars = numberOfVariables; [EOL]     } [EOL]     this.hasIntercept = includeConstant; [EOL]     this.nobs = 0; [EOL]     this.d = new double[this.nvars]; [EOL]     this.rhs = new double[this.nvars]; [EOL]     this.r = new double[this.nvars * (this.nvars - 1) / 2]; [EOL]     this.tol = new double[this.nvars]; [EOL]     this.rss = new double[this.nvars]; [EOL]     this.vorder = new int[this.nvars]; [EOL]     this.x_sing = new double[this.nvars]; [EOL]     this.work_sing = new double[this.nvars]; [EOL]     this.work_tolset = new double[this.nvars]; [EOL]     this.lindep = new boolean[this.nvars]; [EOL]     for (int i = 0; i < this.nvars; i++) { [EOL]         vorder[i] = i; [EOL]     } [EOL]     if (errorTolerance > 0) { [EOL]         this.epsilon = errorTolerance; [EOL]     } else { [EOL]         this.epsilon = -errorTolerance; [EOL]     } [EOL] } <line_num>: 100,130
public MillerUpdatingRegression(int numberOfVariables, boolean includeConstant) throws ModelSpecificationException { [EOL]     this(numberOfVariables, includeConstant, Precision.EPSILON); [EOL] } <line_num>: 139,142
public boolean hasIntercept() { [EOL]     return this.hasIntercept; [EOL] } <line_num>: 148,150
public long getN() { [EOL]     return this.nobs; [EOL] } <line_num>: 156,158
public void addObservation(final double[] x, final double y) throws ModelSpecificationException { [EOL]     if ((!this.hasIntercept && x.length != nvars) || (this.hasIntercept && x.length + 1 != nvars)) { [EOL]         throw new ModelSpecificationException(LocalizedFormats.INVALID_REGRESSION_OBSERVATION, x.length, nvars); [EOL]     } [EOL]     if (!this.hasIntercept) { [EOL]         include(MathArrays.copyOf(x, x.length), 1.0, y); [EOL]     } else { [EOL]         final double[] tmp = new double[x.length + 1]; [EOL]         System.arraycopy(x, 0, tmp, 1, x.length); [EOL]         tmp[0] = 1.0; [EOL]         include(tmp, 1.0, y); [EOL]     } [EOL]     ++nobs; [EOL] } <line_num>: 167,185
public void addObservations(double[][] x, double[] y) throws ModelSpecificationException { [EOL]     if ((x == null) || (y == null) || (x.length != y.length)) { [EOL]         throw new ModelSpecificationException(LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, (x == null) ? 0 : x.length, (y == null) ? 0 : y.length); [EOL]     } [EOL]     if (x.length == 0) { [EOL]         throw new ModelSpecificationException(LocalizedFormats.NO_DATA); [EOL]     } [EOL]     if (x[0].length + 1 > x.length) { [EOL]         throw new ModelSpecificationException(LocalizedFormats.NOT_ENOUGH_DATA_FOR_NUMBER_OF_PREDICTORS, x.length, x[0].length); [EOL]     } [EOL]     for (int i = 0; i < x.length; i++) { [EOL]         addObservation(x[i], y[i]); [EOL]     } [EOL] } <line_num>: 194,213
private void include(final double[] x, final double wi, final double yi) { [EOL]     int nextr = 0; [EOL]     double w = wi; [EOL]     double y = yi; [EOL]     double xi; [EOL]     double di; [EOL]     double wxi; [EOL]     double dpi; [EOL]     double xk; [EOL]     double _w; [EOL]     this.rss_set = false; [EOL]     sumy = smartAdd(yi, sumy); [EOL]     sumsqy = smartAdd(sumsqy, yi * yi); [EOL]     for (int i = 0; i < x.length; i++) { [EOL]         if (w == 0.0) { [EOL]             return; [EOL]         } [EOL]         xi = x[i]; [EOL]         if (xi == 0.0) { [EOL]             nextr += nvars - i - 1; [EOL]             continue; [EOL]         } [EOL]         di = d[i]; [EOL]         wxi = w * xi; [EOL]         _w = w; [EOL]         if (di != 0.0) { [EOL]             dpi = smartAdd(di, wxi * xi); [EOL]             final double tmp = wxi * xi / di; [EOL]             if (FastMath.abs(tmp) > Precision.EPSILON) { [EOL]                 w = (di * w) / dpi; [EOL]             } [EOL]         } else { [EOL]             dpi = wxi * xi; [EOL]             w = 0.0; [EOL]         } [EOL]         d[i] = dpi; [EOL]         for (int k = i + 1; k < nvars; k++) { [EOL]             xk = x[k]; [EOL]             x[k] = smartAdd(xk, -xi * r[nextr]); [EOL]             if (di != 0.0) { [EOL]                 r[nextr] = smartAdd(di * r[nextr], (_w * xi) * xk) / dpi; [EOL]             } else { [EOL]                 r[nextr] = xk / xi; [EOL]             } [EOL]             ++nextr; [EOL]         } [EOL]         xk = y; [EOL]         y = smartAdd(xk, -xi * rhs[i]); [EOL]         if (di != 0.0) { [EOL]             rhs[i] = smartAdd(di * rhs[i], wxi * xk) / dpi; [EOL]         } else { [EOL]             rhs[i] = xk / xi; [EOL]         } [EOL]     } [EOL]     sserr = smartAdd(sserr, w * y * y); [EOL] } <line_num>: 229,285
private double smartAdd(double a, double b) { [EOL]     final double _a = FastMath.abs(a); [EOL]     final double _b = FastMath.abs(b); [EOL]     if (_a > _b) { [EOL]         final double eps = _a * Precision.EPSILON; [EOL]         if (_b > eps) { [EOL]             return a + b; [EOL]         } [EOL]         return a; [EOL]     } else { [EOL]         final double eps = _b * Precision.EPSILON; [EOL]         if (_a > eps) { [EOL]             return a + b; [EOL]         } [EOL]         return b; [EOL]     } [EOL] } <line_num>: 294,310
public void clear() { [EOL]     Arrays.fill(this.d, 0.0); [EOL]     Arrays.fill(this.rhs, 0.0); [EOL]     Arrays.fill(this.r, 0.0); [EOL]     Arrays.fill(this.tol, 0.0); [EOL]     Arrays.fill(this.rss, 0.0); [EOL]     Arrays.fill(this.work_tolset, 0.0); [EOL]     Arrays.fill(this.work_sing, 0.0); [EOL]     Arrays.fill(this.x_sing, 0.0); [EOL]     Arrays.fill(this.lindep, false); [EOL]     for (int i = 0; i < nvars; i++) { [EOL]         this.vorder[i] = i; [EOL]     } [EOL]     this.nobs = 0; [EOL]     this.sserr = 0.0; [EOL]     this.sumy = 0.0; [EOL]     this.sumsqy = 0.0; [EOL]     this.rss_set = false; [EOL]     this.tol_set = false; [EOL] } <line_num>: 316,335
private void tolset() { [EOL]     int pos; [EOL]     double total; [EOL]     final double eps = this.epsilon; [EOL]     for (int i = 0; i < nvars; i++) { [EOL]         this.work_tolset[i] = Math.sqrt(d[i]); [EOL]     } [EOL]     tol[0] = eps * this.work_tolset[0]; [EOL]     for (int col = 1; col < nvars; col++) { [EOL]         pos = col - 1; [EOL]         total = work_tolset[col]; [EOL]         for (int row = 0; row < col; row++) { [EOL]             total += Math.abs(r[pos]) * work_tolset[row]; [EOL]             pos += nvars - row - 2; [EOL]         } [EOL]         tol[col] = eps * total; [EOL]     } [EOL]     tol_set = true; [EOL] } <line_num>: 340,358
private double[] regcf(int nreq) throws ModelSpecificationException { [EOL]     int nextr; [EOL]     if (nreq < 1) { [EOL]         throw new ModelSpecificationException(LocalizedFormats.NO_REGRESSORS); [EOL]     } [EOL]     if (nreq > this.nvars) { [EOL]         throw new ModelSpecificationException(LocalizedFormats.TOO_MANY_REGRESSORS, nreq, this.nvars); [EOL]     } [EOL]     if (!this.tol_set) { [EOL]         tolset(); [EOL]     } [EOL]     final double[] ret = new double[nreq]; [EOL]     boolean rankProblem = false; [EOL]     for (int i = nreq - 1; i > -1; i--) { [EOL]         if (Math.sqrt(d[i]) < tol[i]) { [EOL]             ret[i] = 0.0; [EOL]             d[i] = 0.0; [EOL]             rankProblem = true; [EOL]         } else { [EOL]             ret[i] = rhs[i]; [EOL]             nextr = i * (nvars + nvars - i - 1) / 2; [EOL]             for (int j = i + 1; j < nreq; j++) { [EOL]                 ret[i] = smartAdd(ret[i], -r[nextr] * ret[j]); [EOL]                 ++nextr; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (rankProblem) { [EOL]         for (int i = 0; i < nreq; i++) { [EOL]             if (this.lindep[i]) { [EOL]                 ret[i] = Double.NaN; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ret; [EOL] } <line_num>: 371,407
private void singcheck() { [EOL]     int pos; [EOL]     for (int i = 0; i < nvars; i++) { [EOL]         work_sing[i] = Math.sqrt(d[i]); [EOL]     } [EOL]     for (int col = 0; col < nvars; col++) { [EOL]         final double temp = tol[col]; [EOL]         pos = col - 1; [EOL]         for (int row = 0; row < col - 1; row++) { [EOL]             if (Math.abs(r[pos]) * work_sing[row] < temp) { [EOL]                 r[pos] = 0.0; [EOL]             } [EOL]             pos += nvars - row - 2; [EOL]         } [EOL]         lindep[col] = false; [EOL]         if (work_sing[col] < temp) { [EOL]             lindep[col] = true; [EOL]             if (col < nvars - 1) { [EOL]                 Arrays.fill(x_sing, 0.0); [EOL]                 int _pi = col * (nvars + nvars - col - 1) / 2; [EOL]                 for (int _xi = col + 1; _xi < nvars; _xi++, _pi++) { [EOL]                     x_sing[_xi] = r[_pi]; [EOL]                     r[_pi] = 0.0; [EOL]                 } [EOL]                 final double y = rhs[col]; [EOL]                 final double weight = d[col]; [EOL]                 d[col] = 0.0; [EOL]                 rhs[col] = 0.0; [EOL]                 this.include(x_sing, weight, y); [EOL]             } else { [EOL]                 sserr += d[col] * rhs[col] * rhs[col]; [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 413,453
private void ss() { [EOL]     double total = sserr; [EOL]     rss[nvars - 1] = sserr; [EOL]     for (int i = nvars - 1; i > 0; i--) { [EOL]         total += d[i] * rhs[i] * rhs[i]; [EOL]         rss[i - 1] = total; [EOL]     } [EOL]     rss_set = true; [EOL] } <line_num>: 464,472
private double[] cov(int nreq) { [EOL]     if (this.nobs <= nreq) { [EOL]         return null; [EOL]     } [EOL]     double rnk = 0.0; [EOL]     for (int i = 0; i < nreq; i++) { [EOL]         if (!this.lindep[i]) { [EOL]             rnk += 1.0; [EOL]         } [EOL]     } [EOL]     final double var = rss[nreq - 1] / (nobs - rnk); [EOL]     final double[] rinv = new double[nreq * (nreq - 1) / 2]; [EOL]     inverse(rinv, nreq); [EOL]     final double[] covmat = new double[nreq * (nreq + 1) / 2]; [EOL]     Arrays.fill(covmat, Double.NaN); [EOL]     int pos2; [EOL]     int pos1; [EOL]     int start = 0; [EOL]     double total = 0; [EOL]     for (int row = 0; row < nreq; row++) { [EOL]         pos2 = start; [EOL]         if (!this.lindep[row]) { [EOL]             for (int col = row; col < nreq; col++) { [EOL]                 if (!this.lindep[col]) { [EOL]                     pos1 = start + col - row; [EOL]                     if (row == col) { [EOL]                         total = 1.0 / d[col]; [EOL]                     } else { [EOL]                         total = rinv[pos1 - 1] / d[col]; [EOL]                     } [EOL]                     for (int k = col + 1; k < nreq; k++) { [EOL]                         if (!this.lindep[k]) { [EOL]                             total += rinv[pos1] * rinv[pos2] / d[k]; [EOL]                         } [EOL]                         ++pos1; [EOL]                         ++pos2; [EOL]                     } [EOL]                     covmat[(col + 1) * col / 2 + row] = total * var; [EOL]                 } else { [EOL]                     pos2 += nreq - col - 1; [EOL]                 } [EOL]             } [EOL]         } [EOL]         start += nreq - row - 1; [EOL]     } [EOL]     return covmat; [EOL] } <line_num>: 492,538
private void inverse(double[] rinv, int nreq) { [EOL]     int pos = nreq * (nreq - 1) / 2 - 1; [EOL]     int pos1 = -1; [EOL]     int pos2 = -1; [EOL]     double total = 0.0; [EOL]     Arrays.fill(rinv, Double.NaN); [EOL]     for (int row = nreq - 1; row > 0; --row) { [EOL]         if (!this.lindep[row]) { [EOL]             final int start = (row - 1) * (nvars + nvars - row) / 2; [EOL]             for (int col = nreq; col > row; --col) { [EOL]                 pos1 = start; [EOL]                 pos2 = pos; [EOL]                 total = 0.0; [EOL]                 for (int k = row; k < col - 1; k++) { [EOL]                     pos2 += nreq - k - 1; [EOL]                     if (!this.lindep[k]) { [EOL]                         total += -r[pos1] * rinv[pos2]; [EOL]                     } [EOL]                     ++pos1; [EOL]                 } [EOL]                 rinv[pos] = total - r[pos1]; [EOL]                 --pos; [EOL]             } [EOL]         } else { [EOL]             pos -= nreq - row; [EOL]         } [EOL]     } [EOL] } <line_num>: 547,574
public double[] getPartialCorrelations(int in) { [EOL]     final double[] output = new double[(nvars - in + 1) * (nvars - in) / 2]; [EOL]     int pos; [EOL]     int pos1; [EOL]     int pos2; [EOL]     final int rms_off = -in; [EOL]     final int wrk_off = -(in + 1); [EOL]     final double[] rms = new double[nvars - in]; [EOL]     final double[] work = new double[nvars - in - 1]; [EOL]     double sumxx; [EOL]     double sumxy; [EOL]     double sumyy; [EOL]     final int offXX = (nvars - in) * (nvars - in - 1) / 2; [EOL]     if (in < -1 || in >= nvars) { [EOL]         return null; [EOL]     } [EOL]     final int nvm = nvars - 1; [EOL]     final int base_pos = r.length - (nvm - in) * (nvm - in + 1) / 2; [EOL]     if (d[in] > 0.0) { [EOL]         rms[in + rms_off] = 1.0 / Math.sqrt(d[in]); [EOL]     } [EOL]     for (int col = in + 1; col < nvars; col++) { [EOL]         pos = base_pos + col - 1 - in; [EOL]         sumxx = d[col]; [EOL]         for (int row = in; row < col; row++) { [EOL]             sumxx += d[row] * r[pos] * r[pos]; [EOL]             pos += nvars - row - 2; [EOL]         } [EOL]         if (sumxx > 0.0) { [EOL]             rms[col + rms_off] = 1.0 / Math.sqrt(sumxx); [EOL]         } else { [EOL]             rms[col + rms_off] = 0.0; [EOL]         } [EOL]     } [EOL]     sumyy = sserr; [EOL]     for (int row = in; row < nvars; row++) { [EOL]         sumyy += d[row] * rhs[row] * rhs[row]; [EOL]     } [EOL]     if (sumyy > 0.0) { [EOL]         sumyy = 1.0 / Math.sqrt(sumyy); [EOL]     } [EOL]     pos = 0; [EOL]     for (int col1 = in; col1 < nvars; col1++) { [EOL]         sumxy = 0.0; [EOL]         Arrays.fill(work, 0.0); [EOL]         pos1 = base_pos + col1 - in - 1; [EOL]         for (int row = in; row < col1; row++) { [EOL]             pos2 = pos1 + 1; [EOL]             for (int col2 = col1 + 1; col2 < nvars; col2++) { [EOL]                 work[col2 + wrk_off] += d[row] * r[pos1] * r[pos2]; [EOL]                 pos2++; [EOL]             } [EOL]             sumxy += d[row] * r[pos1] * rhs[row]; [EOL]             pos1 += nvars - row - 2; [EOL]         } [EOL]         pos2 = pos1 + 1; [EOL]         for (int col2 = col1 + 1; col2 < nvars; col2++) { [EOL]             work[col2 + wrk_off] += d[col1] * r[pos2]; [EOL]             ++pos2; [EOL]             output[(col2 - 1 - in) * (col2 - in) / 2 + col1 - in] = work[col2 + wrk_off] * rms[col1 + rms_off] * rms[col2 + rms_off]; [EOL]             ++pos; [EOL]         } [EOL]         sumxy += d[col1] * rhs[col1]; [EOL]         output[col1 + rms_off + offXX] = sumxy * rms[col1 + rms_off] * sumyy; [EOL]     } [EOL]     return output; [EOL] } <line_num>: 609,677
private void vmove(int from, int to) { [EOL]     double d1; [EOL]     double d2; [EOL]     double X; [EOL]     double d1new; [EOL]     double d2new; [EOL]     double cbar; [EOL]     double sbar; [EOL]     double Y; [EOL]     int first; [EOL]     int inc; [EOL]     int m1; [EOL]     int m2; [EOL]     int mp1; [EOL]     int pos; [EOL]     boolean bSkipTo40 = false; [EOL]     if (from == to) { [EOL]         return; [EOL]     } [EOL]     if (!this.rss_set) { [EOL]         ss(); [EOL]     } [EOL]     int count = 0; [EOL]     if (from < to) { [EOL]         first = from; [EOL]         inc = 1; [EOL]         count = to - from; [EOL]     } else { [EOL]         first = from - 1; [EOL]         inc = -1; [EOL]         count = from - to; [EOL]     } [EOL]     int m = first; [EOL]     int idx = 0; [EOL]     while (idx < count) { [EOL]         m1 = m * (nvars + nvars - m - 1) / 2; [EOL]         m2 = m1 + nvars - m - 1; [EOL]         mp1 = m + 1; [EOL]         d1 = d[m]; [EOL]         d2 = d[mp1]; [EOL]         if (d1 > this.epsilon || d2 > this.epsilon) { [EOL]             X = r[m1]; [EOL]             if (Math.abs(X) * Math.sqrt(d1) < tol[mp1]) { [EOL]                 X = 0.0; [EOL]             } [EOL]             if (d1 < this.epsilon || Math.abs(X) < this.epsilon) { [EOL]                 d[m] = d2; [EOL]                 d[mp1] = d1; [EOL]                 r[m1] = 0.0; [EOL]                 for (int col = m + 2; col < nvars; col++) { [EOL]                     ++m1; [EOL]                     X = r[m1]; [EOL]                     r[m1] = r[m2]; [EOL]                     r[m2] = X; [EOL]                     ++m2; [EOL]                 } [EOL]                 X = rhs[m]; [EOL]                 rhs[m] = rhs[mp1]; [EOL]                 rhs[mp1] = X; [EOL]                 bSkipTo40 = true; [EOL]             } else if (d2 < this.epsilon) { [EOL]                 d[m] = d1 * X * X; [EOL]                 r[m1] = 1.0 / X; [EOL]                 for (int _i = m1 + 1; _i < m1 + nvars - m - 1; _i++) { [EOL]                     r[_i] /= X; [EOL]                 } [EOL]                 rhs[m] = rhs[m] / X; [EOL]                 bSkipTo40 = true; [EOL]             } [EOL]             if (!bSkipTo40) { [EOL]                 d1new = d2 + d1 * X * X; [EOL]                 cbar = d2 / d1new; [EOL]                 sbar = X * d1 / d1new; [EOL]                 d2new = d1 * cbar; [EOL]                 d[m] = d1new; [EOL]                 d[mp1] = d2new; [EOL]                 r[m1] = sbar; [EOL]                 for (int col = m + 2; col < nvars; col++) { [EOL]                     ++m1; [EOL]                     Y = r[m1]; [EOL]                     r[m1] = cbar * r[m2] + sbar * Y; [EOL]                     r[m2] = Y - X * r[m2]; [EOL]                     ++m2; [EOL]                 } [EOL]                 Y = rhs[m]; [EOL]                 rhs[m] = cbar * rhs[mp1] + sbar * Y; [EOL]                 rhs[mp1] = Y - X * rhs[mp1]; [EOL]             } [EOL]         } [EOL]         if (m > 0) { [EOL]             pos = m; [EOL]             for (int row = 0; row < m; row++) { [EOL]                 X = r[pos]; [EOL]                 r[pos] = r[pos - 1]; [EOL]                 r[pos - 1] = X; [EOL]                 pos += nvars - row - 2; [EOL]             } [EOL]         } [EOL]         m1 = vorder[m]; [EOL]         vorder[m] = vorder[mp1]; [EOL]         vorder[mp1] = m1; [EOL]         X = tol[m]; [EOL]         tol[m] = tol[mp1]; [EOL]         tol[mp1] = X; [EOL]         rss[m] = rss[mp1] + d[mp1] * rhs[mp1] * rhs[mp1]; [EOL]         m += inc; [EOL]         ++idx; [EOL]     } [EOL] } <line_num>: 687,803
private int reorderRegressors(int[] list, int pos1) { [EOL]     int next; [EOL]     int i; [EOL]     int l; [EOL]     if (list.length < 1 || list.length > nvars + 1 - pos1) { [EOL]         return -1; [EOL]     } [EOL]     next = pos1; [EOL]     i = pos1; [EOL]     while (i < nvars) { [EOL]         l = vorder[i]; [EOL]         for (int j = 0; j < list.length; j++) { [EOL]             if (l == list[j] && i > next) { [EOL]                 this.vmove(i, next); [EOL]                 ++next; [EOL]                 if (next >= list.length + pos1) { [EOL]                     return 0; [EOL]                 } else { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]         } [EOL]         ++i; [EOL]     } [EOL]     return 0; [EOL] } <line_num>: 820,845
public double getDiagonalOfHatMatrix(double[] row_data) { [EOL]     double[] wk = new double[this.nvars]; [EOL]     int pos; [EOL]     double total; [EOL]     if (row_data.length > nvars) { [EOL]         return Double.NaN; [EOL]     } [EOL]     double[] xrow; [EOL]     if (this.hasIntercept) { [EOL]         xrow = new double[row_data.length + 1]; [EOL]         xrow[0] = 1.0; [EOL]         System.arraycopy(row_data, 0, xrow, 1, row_data.length); [EOL]     } else { [EOL]         xrow = row_data; [EOL]     } [EOL]     double hii = 0.0; [EOL]     for (int col = 0; col < xrow.length; col++) { [EOL]         if (Math.sqrt(d[col]) < tol[col]) { [EOL]             wk[col] = 0.0; [EOL]         } else { [EOL]             pos = col - 1; [EOL]             total = xrow[col]; [EOL]             for (int row = 0; row < col; row++) { [EOL]                 total = smartAdd(total, -wk[row] * r[pos]); [EOL]                 pos += nvars - row - 2; [EOL]             } [EOL]             wk[col] = total; [EOL]             hii = smartAdd(hii, (total * total) / d[col]); [EOL]         } [EOL]     } [EOL]     return hii; [EOL] } <line_num>: 853,885
public int[] getOrderOfRegressors() { [EOL]     return MathArrays.copyOf(vorder); [EOL] } <line_num>: 894,896
public RegressionResults regress() throws ModelSpecificationException { [EOL]     return regress(this.nvars); [EOL] } <line_num>: 905,907
public RegressionResults regress(int numberOfRegressors) throws ModelSpecificationException { [EOL]     if (this.nobs <= numberOfRegressors) { [EOL]         throw new ModelSpecificationException(LocalizedFormats.NOT_ENOUGH_DATA_FOR_NUMBER_OF_PREDICTORS, this.nobs, numberOfRegressors); [EOL]     } [EOL]     if (numberOfRegressors > this.nvars) { [EOL]         throw new ModelSpecificationException(LocalizedFormats.TOO_MANY_REGRESSORS, numberOfRegressors, this.nvars); [EOL]     } [EOL]     tolset(); [EOL]     singcheck(); [EOL]     double[] beta = this.regcf(numberOfRegressors); [EOL]     ss(); [EOL]     double[] cov = this.cov(numberOfRegressors); [EOL]     int rnk = 0; [EOL]     for (int i = 0; i < this.lindep.length; i++) { [EOL]         if (!this.lindep[i]) { [EOL]             ++rnk; [EOL]         } [EOL]     } [EOL]     boolean needsReorder = false; [EOL]     for (int i = 0; i < numberOfRegressors; i++) { [EOL]         if (this.vorder[i] != i) { [EOL]             needsReorder = true; [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (!needsReorder) { [EOL]         return new RegressionResults(beta, new double[][] { cov }, true, this.nobs, rnk, this.sumy, this.sumsqy, this.sserr, this.hasIntercept, false); [EOL]     } else { [EOL]         double[] betaNew = new double[beta.length]; [EOL]         double[] covNew = new double[cov.length]; [EOL]         int[] newIndices = new int[beta.length]; [EOL]         for (int i = 0; i < nvars; i++) { [EOL]             for (int j = 0; j < numberOfRegressors; j++) { [EOL]                 if (this.vorder[j] == i) { [EOL]                     betaNew[i] = beta[j]; [EOL]                     newIndices[i] = j; [EOL]                 } [EOL]             } [EOL]         } [EOL]         int idx1 = 0; [EOL]         int idx2; [EOL]         int _i; [EOL]         int _j; [EOL]         for (int i = 0; i < beta.length; i++) { [EOL]             _i = newIndices[i]; [EOL]             for (int j = 0; j <= i; j++, idx1++) { [EOL]                 _j = newIndices[j]; [EOL]                 if (_i > _j) { [EOL]                     idx2 = _i * (_i + 1) / 2 + _j; [EOL]                 } else { [EOL]                     idx2 = _j * (_j + 1) / 2 + _i; [EOL]                 } [EOL]                 covNew[idx1] = cov[idx2]; [EOL]             } [EOL]         } [EOL]         return new RegressionResults(betaNew, new double[][] { covNew }, true, this.nobs, rnk, this.sumy, this.sumsqy, this.sserr, this.hasIntercept, false); [EOL]     } [EOL] } <line_num>: 919,991
public RegressionResults regress(int[] variablesToInclude) throws ModelSpecificationException { [EOL]     if (variablesToInclude.length > this.nvars) { [EOL]         throw new ModelSpecificationException(LocalizedFormats.TOO_MANY_REGRESSORS, variablesToInclude.length, this.nvars); [EOL]     } [EOL]     if (this.nobs <= this.nvars) { [EOL]         throw new ModelSpecificationException(LocalizedFormats.NOT_ENOUGH_DATA_FOR_NUMBER_OF_PREDICTORS, this.nobs, this.nvars); [EOL]     } [EOL]     Arrays.sort(variablesToInclude); [EOL]     int iExclude = 0; [EOL]     for (int i = 0; i < variablesToInclude.length; i++) { [EOL]         if (i >= this.nvars) { [EOL]             throw new ModelSpecificationException(LocalizedFormats.INDEX_LARGER_THAN_MAX, i, this.nvars); [EOL]         } [EOL]         if (i > 0 && variablesToInclude[i] == variablesToInclude[i - 1]) { [EOL]             variablesToInclude[i] = -1; [EOL]             ++iExclude; [EOL]         } [EOL]     } [EOL]     int[] series; [EOL]     if (iExclude > 0) { [EOL]         int j = 0; [EOL]         series = new int[variablesToInclude.length - iExclude]; [EOL]         for (int i = 0; i < variablesToInclude.length; i++) { [EOL]             if (variablesToInclude[i] > -1) { [EOL]                 series[j] = variablesToInclude[i]; [EOL]                 ++j; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         series = variablesToInclude; [EOL]     } [EOL]     reorderRegressors(series, 0); [EOL]     tolset(); [EOL]     singcheck(); [EOL]     double[] beta = this.regcf(series.length); [EOL]     ss(); [EOL]     double[] cov = this.cov(series.length); [EOL]     int rnk = 0; [EOL]     for (int i = 0; i < this.lindep.length; i++) { [EOL]         if (!this.lindep[i]) { [EOL]             ++rnk; [EOL]         } [EOL]     } [EOL]     boolean needsReorder = false; [EOL]     for (int i = 0; i < this.nvars; i++) { [EOL]         if (this.vorder[i] != series[i]) { [EOL]             needsReorder = true; [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (!needsReorder) { [EOL]         return new RegressionResults(beta, new double[][] { cov }, true, this.nobs, rnk, this.sumy, this.sumsqy, this.sserr, this.hasIntercept, false); [EOL]     } else { [EOL]         double[] betaNew = new double[beta.length]; [EOL]         int[] newIndices = new int[beta.length]; [EOL]         for (int i = 0; i < series.length; i++) { [EOL]             for (int j = 0; j < this.vorder.length; j++) { [EOL]                 if (this.vorder[j] == series[i]) { [EOL]                     betaNew[i] = beta[j]; [EOL]                     newIndices[i] = j; [EOL]                 } [EOL]             } [EOL]         } [EOL]         double[] covNew = new double[cov.length]; [EOL]         int idx1 = 0; [EOL]         int idx2; [EOL]         int _i; [EOL]         int _j; [EOL]         for (int i = 0; i < beta.length; i++) { [EOL]             _i = newIndices[i]; [EOL]             for (int j = 0; j <= i; j++, idx1++) { [EOL]                 _j = newIndices[j]; [EOL]                 if (_i > _j) { [EOL]                     idx2 = _i * (_i + 1) / 2 + _j; [EOL]                 } else { [EOL]                     idx2 = _j * (_j + 1) / 2 + _i; [EOL]                 } [EOL]                 covNew[idx1] = cov[idx2]; [EOL]             } [EOL]         } [EOL]         return new RegressionResults(betaNew, new double[][] { covNew }, true, this.nobs, rnk, this.sumy, this.sumsqy, this.sserr, this.hasIntercept, false); [EOL]     } [EOL] } <line_num>: 1005,1101
