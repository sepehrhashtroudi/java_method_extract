public NaturalRanking() { [EOL]     super(); [EOL]     tiesStrategy = DEFAULT_TIES_STRATEGY; [EOL]     nanStrategy = DEFAULT_NAN_STRATEGY; [EOL]     randomData = null; [EOL] } <line_num>: 91,96
public NaturalRanking(TiesStrategy tiesStrategy) { [EOL]     super(); [EOL]     this.tiesStrategy = tiesStrategy; [EOL]     nanStrategy = DEFAULT_NAN_STRATEGY; [EOL]     randomData = new RandomDataGenerator(); [EOL] } <line_num>: 103,108
public NaturalRanking(NaNStrategy nanStrategy) { [EOL]     super(); [EOL]     this.nanStrategy = nanStrategy; [EOL]     tiesStrategy = DEFAULT_TIES_STRATEGY; [EOL]     randomData = null; [EOL] } <line_num>: 115,120
public NaturalRanking(NaNStrategy nanStrategy, TiesStrategy tiesStrategy) { [EOL]     super(); [EOL]     this.nanStrategy = nanStrategy; [EOL]     this.tiesStrategy = tiesStrategy; [EOL]     randomData = new RandomDataGenerator(); [EOL] } <line_num>: 128,133
public NaturalRanking(RandomGenerator randomGenerator) { [EOL]     super(); [EOL]     this.tiesStrategy = TiesStrategy.RANDOM; [EOL]     nanStrategy = DEFAULT_NAN_STRATEGY; [EOL]     randomData = new RandomDataGenerator(randomGenerator); [EOL] } <line_num>: 141,146
public NaturalRanking(NaNStrategy nanStrategy, RandomGenerator randomGenerator) { [EOL]     super(); [EOL]     this.nanStrategy = nanStrategy; [EOL]     this.tiesStrategy = TiesStrategy.RANDOM; [EOL]     randomData = new RandomDataGenerator(randomGenerator); [EOL] } <line_num>: 156,162
public IntDoublePair(double value, int position) { [EOL]     this.value = value; [EOL]     this.position = position; [EOL] } <line_num>: 441,444
public NaNStrategy getNanStrategy() { [EOL]     return nanStrategy; [EOL] } <line_num>: 169,171
public TiesStrategy getTiesStrategy() { [EOL]     return tiesStrategy; [EOL] } <line_num>: 178,180
public double[] rank(double[] data) { [EOL]     IntDoublePair[] ranks = new IntDoublePair[data.length]; [EOL]     for (int i = 0; i < data.length; i++) { [EOL]         ranks[i] = new IntDoublePair(data[i], i); [EOL]     } [EOL]     List<Integer> nanPositions = null; [EOL]     switch(nanStrategy) { [EOL]         case MAXIMAL: [EOL]             recodeNaNs(ranks, Double.POSITIVE_INFINITY); [EOL]             break; [EOL]         case MINIMAL: [EOL]             recodeNaNs(ranks, Double.NEGATIVE_INFINITY); [EOL]             break; [EOL]         case REMOVED: [EOL]             ranks = removeNaNs(ranks); [EOL]             break; [EOL]         case FIXED: [EOL]             nanPositions = getNanPositions(ranks); [EOL]             break; [EOL]         case FAILED: [EOL]             nanPositions = getNanPositions(ranks); [EOL]             if (nanPositions.size() > 0) { [EOL]                 throw new NotANumberException(); [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new MathInternalError(); [EOL]     } [EOL]     Arrays.sort(ranks); [EOL]     double[] out = new double[ranks.length]; [EOL]     int pos = 1; [EOL]     out[ranks[0].getPosition()] = pos; [EOL]     List<Integer> tiesTrace = new ArrayList<Integer>(); [EOL]     tiesTrace.add(ranks[0].getPosition()); [EOL]     for (int i = 1; i < ranks.length; i++) { [EOL]         if (Double.compare(ranks[i].getValue(), ranks[i - 1].getValue()) > 0) { [EOL]             pos = i + 1; [EOL]             if (tiesTrace.size() > 1) { [EOL]                 resolveTie(out, tiesTrace); [EOL]             } [EOL]             tiesTrace = new ArrayList<Integer>(); [EOL]             tiesTrace.add(ranks[i].getPosition()); [EOL]         } else { [EOL]             tiesTrace.add(ranks[i].getPosition()); [EOL]         } [EOL]         out[ranks[i].getPosition()] = pos; [EOL]     } [EOL]     if (tiesTrace.size() > 1) { [EOL]         resolveTie(out, tiesTrace); [EOL]     } [EOL]     if (nanStrategy == NaNStrategy.FIXED) { [EOL]         restoreNaNs(out, nanPositions); [EOL]     } [EOL]     return out; [EOL] } <line_num>: 192,257
private IntDoublePair[] removeNaNs(IntDoublePair[] ranks) { [EOL]     if (!containsNaNs(ranks)) { [EOL]         return ranks; [EOL]     } [EOL]     IntDoublePair[] outRanks = new IntDoublePair[ranks.length]; [EOL]     int j = 0; [EOL]     for (int i = 0; i < ranks.length; i++) { [EOL]         if (Double.isNaN(ranks[i].getValue())) { [EOL]             for (int k = i + 1; k < ranks.length; k++) { [EOL]                 ranks[k] = new IntDoublePair(ranks[k].getValue(), ranks[k].getPosition() - 1); [EOL]             } [EOL]         } else { [EOL]             outRanks[j] = new IntDoublePair(ranks[i].getValue(), ranks[i].getPosition()); [EOL]             j++; [EOL]         } [EOL]     } [EOL]     IntDoublePair[] returnRanks = new IntDoublePair[j]; [EOL]     System.arraycopy(outRanks, 0, returnRanks, 0, j); [EOL]     return returnRanks; [EOL] } <line_num>: 266,288
private void recodeNaNs(IntDoublePair[] ranks, double value) { [EOL]     for (int i = 0; i < ranks.length; i++) { [EOL]         if (Double.isNaN(ranks[i].getValue())) { [EOL]             ranks[i] = new IntDoublePair(value, ranks[i].getPosition()); [EOL]         } [EOL]     } [EOL] } <line_num>: 296,303
private boolean containsNaNs(IntDoublePair[] ranks) { [EOL]     for (int i = 0; i < ranks.length; i++) { [EOL]         if (Double.isNaN(ranks[i].getValue())) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 311,318
private void resolveTie(double[] ranks, List<Integer> tiesTrace) { [EOL]     final double c = ranks[tiesTrace.get(0)]; [EOL]     final int length = tiesTrace.size(); [EOL]     switch(tiesStrategy) { [EOL]         case AVERAGE: [EOL]             fill(ranks, tiesTrace, (2 * c + length - 1) / 2d); [EOL]             break; [EOL]         case MAXIMUM: [EOL]             fill(ranks, tiesTrace, c + length - 1); [EOL]             break; [EOL]         case MINIMUM: [EOL]             fill(ranks, tiesTrace, c); [EOL]             break; [EOL]         case RANDOM: [EOL]             Iterator<Integer> iterator = tiesTrace.iterator(); [EOL]             long f = FastMath.round(c); [EOL]             while (iterator.hasNext()) { [EOL]                 ranks[iterator.next()] = randomData.nextLong(f, f + length - 1); [EOL]             } [EOL]             break; [EOL]         case SEQUENTIAL: [EOL]             iterator = tiesTrace.iterator(); [EOL]             f = FastMath.round(c); [EOL]             int i = 0; [EOL]             while (iterator.hasNext()) { [EOL]                 ranks[iterator.next()] = f + i++; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new MathInternalError(); [EOL]     } [EOL] } <line_num>: 334,373
private void fill(double[] data, List<Integer> tiesTrace, double value) { [EOL]     Iterator<Integer> iterator = tiesTrace.iterator(); [EOL]     while (iterator.hasNext()) { [EOL]         data[iterator.next()] = value; [EOL]     } [EOL] } <line_num>: 382,387
private void restoreNaNs(double[] ranks, List<Integer> nanPositions) { [EOL]     if (nanPositions.size() == 0) { [EOL]         return; [EOL]     } [EOL]     Iterator<Integer> iterator = nanPositions.iterator(); [EOL]     while (iterator.hasNext()) { [EOL]         ranks[iterator.next().intValue()] = Double.NaN; [EOL]     } [EOL] } <line_num>: 395,404
private List<Integer> getNanPositions(IntDoublePair[] ranks) { [EOL]     ArrayList<Integer> out = new ArrayList<Integer>(); [EOL]     for (int i = 0; i < ranks.length; i++) { [EOL]         if (Double.isNaN(ranks[i].getValue())) { [EOL]             out.add(Integer.valueOf(i)); [EOL]         } [EOL]     } [EOL]     return out; [EOL] } <line_num>: 412,420
public int compareTo(IntDoublePair other) { [EOL]     return Double.compare(value, other.value); [EOL] } <line_num>: 453,455
public double getValue() { [EOL]     return value; [EOL] } <line_num>: 463,465
public int getPosition() { [EOL]     return position; [EOL] } <line_num>: 471,473
