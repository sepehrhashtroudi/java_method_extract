public KMeansPlusPlusClusterer(final Random random) { [EOL]     this(random, EmptyClusterStrategy.LARGEST_VARIANCE); [EOL] } <line_num>: 75,77
public KMeansPlusPlusClusterer(final Random random, final EmptyClusterStrategy emptyStrategy) { [EOL]     this.random = random; [EOL]     this.emptyStrategy = emptyStrategy; [EOL] } <line_num>: 85,88
public List<Cluster<T>> cluster(final Collection<T> points, final int k, int numTrials, int maxIterationsPerTrial) throws MathIllegalArgumentException, ConvergenceException { [EOL]     List<Cluster<T>> best = null; [EOL]     double bestVarianceSum = Double.POSITIVE_INFINITY; [EOL]     for (int i = 0; i < numTrials; ++i) { [EOL]         List<Cluster<T>> clusters = cluster(points, k, maxIterationsPerTrial); [EOL]         double varianceSum = 0.0; [EOL]         for (final Cluster<T> cluster : clusters) { [EOL]             if (!cluster.getPoints().isEmpty()) { [EOL]                 final T center = cluster.getCenter(); [EOL]                 final Variance stat = new Variance(); [EOL]                 for (final T point : cluster.getPoints()) { [EOL]                     stat.increment(point.distanceFrom(center)); [EOL]                 } [EOL]                 varianceSum += stat.getResult(); [EOL]             } [EOL]         } [EOL]         if (varianceSum <= bestVarianceSum) { [EOL]             best = clusters; [EOL]             bestVarianceSum = varianceSum; [EOL]         } [EOL]     } [EOL]     return best; [EOL] } <line_num>: 104,145
public List<Cluster<T>> cluster(final Collection<T> points, final int k, final int maxIterations) throws MathIllegalArgumentException, ConvergenceException { [EOL]     MathUtils.checkNotNull(points); [EOL]     if (points.size() < k) { [EOL]         throw new NumberIsTooSmallException(points.size(), k, false); [EOL]     } [EOL]     List<Cluster<T>> clusters = chooseInitialCenters(points, k, random); [EOL]     int[] assignments = new int[points.size()]; [EOL]     assignPointsToClusters(clusters, points, assignments); [EOL]     final int max = (maxIterations < 0) ? Integer.MAX_VALUE : maxIterations; [EOL]     for (int count = 0; count < max; count++) { [EOL]         boolean emptyCluster = false; [EOL]         List<Cluster<T>> newClusters = new ArrayList<Cluster<T>>(); [EOL]         for (final Cluster<T> cluster : clusters) { [EOL]             final T newCenter; [EOL]             if (cluster.getPoints().isEmpty()) { [EOL]                 switch(emptyStrategy) { [EOL]                     case LARGEST_VARIANCE: [EOL]                         newCenter = getPointFromLargestVarianceCluster(clusters); [EOL]                         break; [EOL]                     case LARGEST_POINTS_NUMBER: [EOL]                         newCenter = getPointFromLargestNumberCluster(clusters); [EOL]                         break; [EOL]                     case FARTHEST_POINT: [EOL]                         newCenter = getFarthestPoint(clusters); [EOL]                         break; [EOL]                     default: [EOL]                         throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS); [EOL]                 } [EOL]                 emptyCluster = true; [EOL]             } else { [EOL]                 newCenter = cluster.getCenter().centroidOf(cluster.getPoints()); [EOL]             } [EOL]             newClusters.add(new Cluster<T>(newCenter)); [EOL]         } [EOL]         int changes = assignPointsToClusters(newClusters, points, assignments); [EOL]         clusters = newClusters; [EOL]         if (changes == 0 && !emptyCluster) { [EOL]             return clusters; [EOL]         } [EOL]     } [EOL]     return clusters; [EOL] } <line_num>: 160,217
private static <T extends Clusterable<T>> int assignPointsToClusters(final List<Cluster<T>> clusters, final Collection<T> points, final int[] assignments) { [EOL]     int assignedDifferently = 0; [EOL]     int pointIndex = 0; [EOL]     for (final T p : points) { [EOL]         int clusterIndex = getNearestCluster(clusters, p); [EOL]         if (clusterIndex != assignments[pointIndex]) { [EOL]             assignedDifferently++; [EOL]         } [EOL]         Cluster<T> cluster = clusters.get(clusterIndex); [EOL]         cluster.addPoint(p); [EOL]         assignments[pointIndex++] = clusterIndex; [EOL]     } [EOL]     return assignedDifferently; [EOL] } <line_num>: 228,245
private static <T extends Clusterable<T>> List<Cluster<T>> chooseInitialCenters(final Collection<T> points, final int k, final Random random) { [EOL]     final List<T> pointList = Collections.unmodifiableList(new ArrayList<T>(points)); [EOL]     final int numPoints = pointList.size(); [EOL]     final boolean[] taken = new boolean[numPoints]; [EOL]     final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>(); [EOL]     final int firstPointIndex = random.nextInt(numPoints); [EOL]     final T firstPoint = pointList.get(firstPointIndex); [EOL]     resultSet.add(new Cluster<T>(firstPoint)); [EOL]     taken[firstPointIndex] = true; [EOL]     final double[] minDistSquared = new double[numPoints]; [EOL]     for (int i = 0; i < numPoints; i++) { [EOL]         if (i != firstPointIndex) { [EOL]             double d = firstPoint.distanceFrom(pointList.get(i)); [EOL]             minDistSquared[i] = d * d; [EOL]         } [EOL]     } [EOL]     while (resultSet.size() < k) { [EOL]         double distSqSum = 0.0; [EOL]         for (int i = 0; i < numPoints; i++) { [EOL]             if (!taken[i]) { [EOL]                 distSqSum += minDistSquared[i]; [EOL]             } [EOL]         } [EOL]         final double r = random.nextDouble() * distSqSum; [EOL]         int nextPointIndex = -1; [EOL]         double sum = 0.0; [EOL]         for (int i = 0; i < numPoints; i++) { [EOL]             if (!taken[i]) { [EOL]                 sum += minDistSquared[i]; [EOL]                 if (sum >= r) { [EOL]                     nextPointIndex = i; [EOL]                     break; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (nextPointIndex == -1) { [EOL]             for (int i = numPoints - 1; i >= 0; i--) { [EOL]                 if (!taken[i]) { [EOL]                     nextPointIndex = i; [EOL]                     break; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (nextPointIndex >= 0) { [EOL]             final T p = pointList.get(nextPointIndex); [EOL]             resultSet.add(new Cluster<T>(p)); [EOL]             taken[nextPointIndex] = true; [EOL]             if (resultSet.size() < k) { [EOL]                 for (int j = 0; j < numPoints; j++) { [EOL]                     if (!taken[j]) { [EOL]                         double d = p.distanceFrom(pointList.get(j)); [EOL]                         double d2 = d * d; [EOL]                         if (d2 < minDistSquared[j]) { [EOL]                             minDistSquared[j] = d2; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return resultSet; [EOL] } <line_num>: 256,374
private T getPointFromLargestVarianceCluster(final Collection<Cluster<T>> clusters) throws ConvergenceException { [EOL]     double maxVariance = Double.NEGATIVE_INFINITY; [EOL]     Cluster<T> selected = null; [EOL]     for (final Cluster<T> cluster : clusters) { [EOL]         if (!cluster.getPoints().isEmpty()) { [EOL]             final T center = cluster.getCenter(); [EOL]             final Variance stat = new Variance(); [EOL]             for (final T point : cluster.getPoints()) { [EOL]                 stat.increment(point.distanceFrom(center)); [EOL]             } [EOL]             final double variance = stat.getResult(); [EOL]             if (variance > maxVariance) { [EOL]                 maxVariance = variance; [EOL]                 selected = cluster; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (selected == null) { [EOL]         throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS); [EOL]     } [EOL]     final List<T> selectedPoints = selected.getPoints(); [EOL]     return selectedPoints.remove(random.nextInt(selectedPoints.size())); [EOL] } <line_num>: 383,417
private T getPointFromLargestNumberCluster(final Collection<Cluster<T>> clusters) throws ConvergenceException { [EOL]     int maxNumber = 0; [EOL]     Cluster<T> selected = null; [EOL]     for (final Cluster<T> cluster : clusters) { [EOL]         final int number = cluster.getPoints().size(); [EOL]         if (number > maxNumber) { [EOL]             maxNumber = number; [EOL]             selected = cluster; [EOL]         } [EOL]     } [EOL]     if (selected == null) { [EOL]         throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS); [EOL]     } [EOL]     final List<T> selectedPoints = selected.getPoints(); [EOL]     return selectedPoints.remove(random.nextInt(selectedPoints.size())); [EOL] } <line_num>: 426,452
private T getFarthestPoint(final Collection<Cluster<T>> clusters) throws ConvergenceException { [EOL]     double maxDistance = Double.NEGATIVE_INFINITY; [EOL]     Cluster<T> selectedCluster = null; [EOL]     int selectedPoint = -1; [EOL]     for (final Cluster<T> cluster : clusters) { [EOL]         final T center = cluster.getCenter(); [EOL]         final List<T> points = cluster.getPoints(); [EOL]         for (int i = 0; i < points.size(); ++i) { [EOL]             final double distance = points.get(i).distanceFrom(center); [EOL]             if (distance > maxDistance) { [EOL]                 maxDistance = distance; [EOL]                 selectedCluster = cluster; [EOL]                 selectedPoint = i; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (selectedCluster == null) { [EOL]         throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS); [EOL]     } [EOL]     return selectedCluster.getPoints().remove(selectedPoint); [EOL] } <line_num>: 461,489
private static <T extends Clusterable<T>> int getNearestCluster(final Collection<Cluster<T>> clusters, final T point) { [EOL]     double minDistance = Double.MAX_VALUE; [EOL]     int clusterIndex = 0; [EOL]     int minCluster = 0; [EOL]     for (final Cluster<T> c : clusters) { [EOL]         final double distance = point.distanceFrom(c.getCenter()); [EOL]         if (distance < minDistance) { [EOL]             minDistance = distance; [EOL]             minCluster = clusterIndex; [EOL]         } [EOL]         clusterIndex++; [EOL]     } [EOL]     return minCluster; [EOL] } <line_num>: 499,513
