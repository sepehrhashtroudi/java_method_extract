protected GaussNewtonOptimizer() { [EOL] } <line_num>: 54,54
protected GaussNewtonOptimizer(GaussNewtonOptimizer other) { [EOL]     super(other); [EOL]     this.useLU = other.useLU; [EOL] } <line_num>: 61,65
public static GaussNewtonOptimizer create() { [EOL]     return new GaussNewtonOptimizer(); [EOL] } <line_num>: 77,79
@Override [EOL] public GaussNewtonOptimizer shallowCopy() { [EOL]     return new GaussNewtonOptimizer(this); [EOL] } <line_num>: 82,85
public GaussNewtonOptimizer withLU(boolean newUseLU) { [EOL]     this.useLU = newUseLU; [EOL]     return self(); [EOL] } <line_num>: 91,94
public boolean getLU() { [EOL]     return useLU; [EOL] } <line_num>: 99,101
@Override [EOL] public PointVectorValuePair doOptimize() { [EOL]     final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); [EOL]     if (checker == null) { [EOL]         throw new NullArgumentException(); [EOL]     } [EOL]     final double[] targetValues = getTarget(); [EOL]     final int nR = targetValues.length; [EOL]     final RealMatrix weightMatrix = getWeight(); [EOL]     if (weightMatrix.getRowDimension() != nR) { [EOL]         throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR); [EOL]     } [EOL]     if (weightMatrix.getColumnDimension() != nR) { [EOL]         throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR); [EOL]     } [EOL]     final double[] residualsWeights = new double[nR]; [EOL]     for (int i = 0; i < nR; i++) { [EOL]         residualsWeights[i] = weightMatrix.getEntry(i, i); [EOL]     } [EOL]     final double[] currentPoint = getStart(); [EOL]     final int nC = currentPoint.length; [EOL]     PointVectorValuePair current = null; [EOL]     for (boolean converged = false; !converged; ) { [EOL]         incrementIterationCount(); [EOL]         PointVectorValuePair previous = current; [EOL]         final double[] currentObjective = computeObjectiveValue(currentPoint); [EOL]         final double[] currentResiduals = computeResiduals(currentObjective); [EOL]         final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint); [EOL]         current = new PointVectorValuePair(currentPoint, currentObjective); [EOL]         final double[] b = new double[nC]; [EOL]         final double[][] a = new double[nC][nC]; [EOL]         for (int i = 0; i < nR; ++i) { [EOL]             final double[] grad = weightedJacobian.getRow(i); [EOL]             final double weight = residualsWeights[i]; [EOL]             final double residual = currentResiduals[i]; [EOL]             final double wr = weight * residual; [EOL]             for (int j = 0; j < nC; ++j) { [EOL]                 b[j] += wr * grad[j]; [EOL]             } [EOL]             for (int k = 0; k < nC; ++k) { [EOL]                 double[] ak = a[k]; [EOL]                 double wgk = weight * grad[k]; [EOL]                 for (int l = 0; l < nC; ++l) { [EOL]                     ak[l] += wgk * grad[l]; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (previous != null) { [EOL]             converged = checker.converged(getIterations(), previous, current); [EOL]             if (converged) { [EOL]                 return current; [EOL]             } [EOL]         } [EOL]         try { [EOL]             RealMatrix mA = new BlockRealMatrix(a); [EOL]             DecompositionSolver solver = useLU ? new LUDecomposition(mA).getSolver() : new QRDecomposition(mA).getSolver(); [EOL]             final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray(); [EOL]             for (int i = 0; i < nC; ++i) { [EOL]                 currentPoint[i] += dX[i]; [EOL]             } [EOL]         } catch (SingularMatrixException e) { [EOL]             throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM); [EOL]         } [EOL]     } [EOL]     throw new MathInternalError(); [EOL] } <line_num>: 104,197
