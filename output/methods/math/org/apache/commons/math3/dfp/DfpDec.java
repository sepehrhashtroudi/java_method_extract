protected DfpDec(final DfpField factory) { [EOL]     super(factory); [EOL] } <line_num>: 32,34
protected DfpDec(final DfpField factory, byte x) { [EOL]     super(factory, x); [EOL] } <line_num>: 40,42
protected DfpDec(final DfpField factory, int x) { [EOL]     super(factory, x); [EOL] } <line_num>: 48,50
protected DfpDec(final DfpField factory, long x) { [EOL]     super(factory, x); [EOL] } <line_num>: 56,58
protected DfpDec(final DfpField factory, double x) { [EOL]     super(factory, x); [EOL]     round(0); [EOL] } <line_num>: 64,67
public DfpDec(final Dfp d) { [EOL]     super(d); [EOL]     round(0); [EOL] } <line_num>: 72,75
protected DfpDec(final DfpField factory, final String s) { [EOL]     super(factory, s); [EOL]     round(0); [EOL] } <line_num>: 81,84
protected DfpDec(final DfpField factory, final byte sign, final byte nans) { [EOL]     super(factory, sign, nans); [EOL] } <line_num>: 92,94
@Override [EOL] public Dfp newInstance() { [EOL]     return new DfpDec(getField()); [EOL] } <line_num>: 97,100
@Override [EOL] public Dfp newInstance(final byte x) { [EOL]     return new DfpDec(getField(), x); [EOL] } <line_num>: 103,106
@Override [EOL] public Dfp newInstance(final int x) { [EOL]     return new DfpDec(getField(), x); [EOL] } <line_num>: 109,112
@Override [EOL] public Dfp newInstance(final long x) { [EOL]     return new DfpDec(getField(), x); [EOL] } <line_num>: 115,118
@Override [EOL] public Dfp newInstance(final double x) { [EOL]     return new DfpDec(getField(), x); [EOL] } <line_num>: 121,124
@Override [EOL] public Dfp newInstance(final Dfp d) { [EOL]     if (getField().getRadixDigits() != d.getField().getRadixDigits()) { [EOL]         getField().setIEEEFlagsBits(DfpField.FLAG_INVALID); [EOL]         final Dfp result = newInstance(getZero()); [EOL]         result.nans = QNAN; [EOL]         return dotrap(DfpField.FLAG_INVALID, "newInstance", d, result); [EOL]     } [EOL]     return new DfpDec(d); [EOL] } <line_num>: 127,140
@Override [EOL] public Dfp newInstance(final String s) { [EOL]     return new DfpDec(getField(), s); [EOL] } <line_num>: 143,146
@Override [EOL] public Dfp newInstance(final byte sign, final byte nans) { [EOL]     return new DfpDec(getField(), sign, nans); [EOL] } <line_num>: 149,152
protected int getDecimalDigits() { [EOL]     return getRadixDigits() * 4 - 3; [EOL] } <line_num>: 159,161
@Override [EOL] protected int round(int in) { [EOL]     int msb = mant[mant.length - 1]; [EOL]     if (msb == 0) { [EOL]         return 0; [EOL]     } [EOL]     int cmaxdigits = mant.length * 4; [EOL]     int lsbthreshold = 1000; [EOL]     while (lsbthreshold > msb) { [EOL]         lsbthreshold /= 10; [EOL]         cmaxdigits--; [EOL]     } [EOL]     final int digits = getDecimalDigits(); [EOL]     final int lsbshift = cmaxdigits - digits; [EOL]     final int lsd = lsbshift / 4; [EOL]     lsbthreshold = 1; [EOL]     for (int i = 0; i < lsbshift % 4; i++) { [EOL]         lsbthreshold *= 10; [EOL]     } [EOL]     final int lsb = mant[lsd]; [EOL]     if (lsbthreshold <= 1 && digits == 4 * mant.length - 3) { [EOL]         return super.round(in); [EOL]     } [EOL]     int discarded = in; [EOL]     final int n; [EOL]     if (lsbthreshold == 1) { [EOL]         n = (mant[lsd - 1] / 1000) % 10; [EOL]         mant[lsd - 1] %= 1000; [EOL]         discarded |= mant[lsd - 1]; [EOL]     } else { [EOL]         n = (lsb * 10 / lsbthreshold) % 10; [EOL]         discarded |= lsb % (lsbthreshold / 10); [EOL]     } [EOL]     for (int i = 0; i < lsd; i++) { [EOL]         discarded |= mant[i]; [EOL]         mant[i] = 0; [EOL]     } [EOL]     mant[lsd] = lsb / lsbthreshold * lsbthreshold; [EOL]     final boolean inc; [EOL]     switch(getField().getRoundingMode()) { [EOL]         case ROUND_DOWN: [EOL]             inc = false; [EOL]             break; [EOL]         case ROUND_UP: [EOL]             inc = (n != 0) || (discarded != 0); [EOL]             break; [EOL]         case ROUND_HALF_UP: [EOL]             inc = n >= 5; [EOL]             break; [EOL]         case ROUND_HALF_DOWN: [EOL]             inc = n > 5; [EOL]             break; [EOL]         case ROUND_HALF_EVEN: [EOL]             inc = (n > 5) || (n == 5 && discarded != 0) || (n == 5 && discarded == 0 && ((lsb / lsbthreshold) & 1) == 1); [EOL]             break; [EOL]         case ROUND_HALF_ODD: [EOL]             inc = (n > 5) || (n == 5 && discarded != 0) || (n == 5 && discarded == 0 && ((lsb / lsbthreshold) & 1) == 0); [EOL]             break; [EOL]         case ROUND_CEIL: [EOL]             inc = (sign == 1) && (n != 0 || discarded != 0); [EOL]             break; [EOL]         case ROUND_FLOOR: [EOL]         default: [EOL]             inc = (sign == -1) && (n != 0 || discarded != 0); [EOL]             break; [EOL]     } [EOL]     if (inc) { [EOL]         int rh = lsbthreshold; [EOL]         for (int i = lsd; i < mant.length; i++) { [EOL]             final int r = mant[i] + rh; [EOL]             rh = r / RADIX; [EOL]             mant[i] = r % RADIX; [EOL]         } [EOL]         if (rh != 0) { [EOL]             shiftRight(); [EOL]             mant[mant.length - 1] = rh; [EOL]         } [EOL]     } [EOL]     if (exp < MIN_EXP) { [EOL]         getField().setIEEEFlagsBits(DfpField.FLAG_UNDERFLOW); [EOL]         return DfpField.FLAG_UNDERFLOW; [EOL]     } [EOL]     if (exp > MAX_EXP) { [EOL]         getField().setIEEEFlagsBits(DfpField.FLAG_OVERFLOW); [EOL]         return DfpField.FLAG_OVERFLOW; [EOL]     } [EOL]     if (n != 0 || discarded != 0) { [EOL]         getField().setIEEEFlagsBits(DfpField.FLAG_INEXACT); [EOL]         return DfpField.FLAG_INEXACT; [EOL]     } [EOL]     return 0; [EOL] } <line_num>: 164,289
@Override [EOL] public Dfp nextAfter(Dfp x) { [EOL]     final String trapName = "nextAfter"; [EOL]     if (getField().getRadixDigits() != x.getField().getRadixDigits()) { [EOL]         getField().setIEEEFlagsBits(DfpField.FLAG_INVALID); [EOL]         final Dfp result = newInstance(getZero()); [EOL]         result.nans = QNAN; [EOL]         return dotrap(DfpField.FLAG_INVALID, trapName, x, result); [EOL]     } [EOL]     boolean up = false; [EOL]     Dfp result; [EOL]     Dfp inc; [EOL]     if (this.lessThan(x)) { [EOL]         up = true; [EOL]     } [EOL]     if (equals(x)) { [EOL]         return newInstance(x); [EOL]     } [EOL]     if (lessThan(getZero())) { [EOL]         up = !up; [EOL]     } [EOL]     if (up) { [EOL]         inc = power10(intLog10() - getDecimalDigits() + 1); [EOL]         inc = copysign(inc, this); [EOL]         if (this.equals(getZero())) { [EOL]             inc = power10K(MIN_EXP - mant.length - 1); [EOL]         } [EOL]         if (inc.equals(getZero())) { [EOL]             result = copysign(newInstance(getZero()), this); [EOL]         } else { [EOL]             result = add(inc); [EOL]         } [EOL]     } else { [EOL]         inc = power10(intLog10()); [EOL]         inc = copysign(inc, this); [EOL]         if (this.equals(inc)) { [EOL]             inc = inc.divide(power10(getDecimalDigits())); [EOL]         } else { [EOL]             inc = inc.divide(power10(getDecimalDigits() - 1)); [EOL]         } [EOL]         if (this.equals(getZero())) { [EOL]             inc = power10K(MIN_EXP - mant.length - 1); [EOL]         } [EOL]         if (inc.equals(getZero())) { [EOL]             result = copysign(newInstance(getZero()), this); [EOL]         } else { [EOL]             result = subtract(inc); [EOL]         } [EOL]     } [EOL]     if (result.classify() == INFINITE && this.classify() != INFINITE) { [EOL]         getField().setIEEEFlagsBits(DfpField.FLAG_INEXACT); [EOL]         result = dotrap(DfpField.FLAG_INEXACT, trapName, x, result); [EOL]     } [EOL]     if (result.equals(getZero()) && this.equals(getZero()) == false) { [EOL]         getField().setIEEEFlagsBits(DfpField.FLAG_INEXACT); [EOL]         result = dotrap(DfpField.FLAG_INEXACT, trapName, x, result); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 292,367
