protected Dfp(final DfpField field) { [EOL]     mant = new int[field.getRadixDigits()]; [EOL]     sign = 1; [EOL]     exp = 0; [EOL]     nans = FINITE; [EOL]     this.field = field; [EOL] } <line_num>: 183,189
protected Dfp(final DfpField field, byte x) { [EOL]     this(field, (long) x); [EOL] } <line_num>: 195,197
protected Dfp(final DfpField field, int x) { [EOL]     this(field, (long) x); [EOL] } <line_num>: 203,205
protected Dfp(final DfpField field, long x) { [EOL]     mant = new int[field.getRadixDigits()]; [EOL]     nans = FINITE; [EOL]     this.field = field; [EOL]     boolean isLongMin = false; [EOL]     if (x == Long.MIN_VALUE) { [EOL]         isLongMin = true; [EOL]         ++x; [EOL]     } [EOL]     if (x < 0) { [EOL]         sign = -1; [EOL]         x = -x; [EOL]     } else { [EOL]         sign = 1; [EOL]     } [EOL]     exp = 0; [EOL]     while (x != 0) { [EOL]         System.arraycopy(mant, mant.length - exp, mant, mant.length - 1 - exp, exp); [EOL]         mant[mant.length - 1] = (int) (x % RADIX); [EOL]         x /= RADIX; [EOL]         exp++; [EOL]     } [EOL]     if (isLongMin) { [EOL]         for (int i = 0; i < mant.length - 1; i++) { [EOL]             if (mant[i] != 0) { [EOL]                 mant[i]++; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 211,252
protected Dfp(final DfpField field, double x) { [EOL]     mant = new int[field.getRadixDigits()]; [EOL]     sign = 1; [EOL]     exp = 0; [EOL]     nans = FINITE; [EOL]     this.field = field; [EOL]     long bits = Double.doubleToLongBits(x); [EOL]     long mantissa = bits & 0x000fffffffffffffL; [EOL]     int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023; [EOL]     if (exponent == -1023) { [EOL]         if (x == 0) { [EOL]             if ((bits & 0x8000000000000000L) != 0) { [EOL]                 sign = -1; [EOL]             } [EOL]             return; [EOL]         } [EOL]         exponent++; [EOL]         while ((mantissa & 0x0010000000000000L) == 0) { [EOL]             exponent--; [EOL]             mantissa <<= 1; [EOL]         } [EOL]         mantissa &= 0x000fffffffffffffL; [EOL]     } [EOL]     if (exponent == 1024) { [EOL]         if (x != x) { [EOL]             sign = (byte) 1; [EOL]             nans = QNAN; [EOL]         } else if (x < 0) { [EOL]             sign = (byte) -1; [EOL]             nans = INFINITE; [EOL]         } else { [EOL]             sign = (byte) 1; [EOL]             nans = INFINITE; [EOL]         } [EOL]         return; [EOL]     } [EOL]     Dfp xdfp = new Dfp(field, mantissa); [EOL]     xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne()); [EOL]     xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent)); [EOL]     if ((bits & 0x8000000000000000L) != 0) { [EOL]         xdfp = xdfp.negate(); [EOL]     } [EOL]     System.arraycopy(xdfp.mant, 0, mant, 0, mant.length); [EOL]     sign = xdfp.sign; [EOL]     exp = xdfp.exp; [EOL]     nans = xdfp.nans; [EOL] } <line_num>: 258,319
public Dfp(final Dfp d) { [EOL]     mant = d.mant.clone(); [EOL]     sign = d.sign; [EOL]     exp = d.exp; [EOL]     nans = d.nans; [EOL]     field = d.field; [EOL] } <line_num>: 324,330
protected Dfp(final DfpField field, final String s) { [EOL]     mant = new int[field.getRadixDigits()]; [EOL]     sign = 1; [EOL]     exp = 0; [EOL]     nans = FINITE; [EOL]     this.field = field; [EOL]     boolean decimalFound = false; [EOL]     final int rsize = 4; [EOL]     final int offset = 4; [EOL]     final char[] striped = new char[getRadixDigits() * rsize + offset * 2]; [EOL]     if (s.equals(POS_INFINITY_STRING)) { [EOL]         sign = (byte) 1; [EOL]         nans = INFINITE; [EOL]         return; [EOL]     } [EOL]     if (s.equals(NEG_INFINITY_STRING)) { [EOL]         sign = (byte) -1; [EOL]         nans = INFINITE; [EOL]         return; [EOL]     } [EOL]     if (s.equals(NAN_STRING)) { [EOL]         sign = (byte) 1; [EOL]         nans = QNAN; [EOL]         return; [EOL]     } [EOL]     int p = s.indexOf("e"); [EOL]     if (p == -1) { [EOL]         p = s.indexOf("E"); [EOL]     } [EOL]     final String fpdecimal; [EOL]     int sciexp = 0; [EOL]     if (p != -1) { [EOL]         fpdecimal = s.substring(0, p); [EOL]         String fpexp = s.substring(p + 1); [EOL]         boolean negative = false; [EOL]         for (int i = 0; i < fpexp.length(); i++) { [EOL]             if (fpexp.charAt(i) == '-') { [EOL]                 negative = true; [EOL]                 continue; [EOL]             } [EOL]             if (fpexp.charAt(i) >= '0' && fpexp.charAt(i) <= '9') { [EOL]                 sciexp = sciexp * 10 + fpexp.charAt(i) - '0'; [EOL]             } [EOL]         } [EOL]         if (negative) { [EOL]             sciexp = -sciexp; [EOL]         } [EOL]     } else { [EOL]         fpdecimal = s; [EOL]     } [EOL]     if (fpdecimal.indexOf("-") != -1) { [EOL]         sign = -1; [EOL]     } [EOL]     p = 0; [EOL]     int decimalPos = 0; [EOL]     for (; ; ) { [EOL]         if (fpdecimal.charAt(p) >= '1' && fpdecimal.charAt(p) <= '9') { [EOL]             break; [EOL]         } [EOL]         if (decimalFound && fpdecimal.charAt(p) == '0') { [EOL]             decimalPos--; [EOL]         } [EOL]         if (fpdecimal.charAt(p) == '.') { [EOL]             decimalFound = true; [EOL]         } [EOL]         p++; [EOL]         if (p == fpdecimal.length()) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     int q = offset; [EOL]     striped[0] = '0'; [EOL]     striped[1] = '0'; [EOL]     striped[2] = '0'; [EOL]     striped[3] = '0'; [EOL]     int significantDigits = 0; [EOL]     for (; ; ) { [EOL]         if (p == (fpdecimal.length())) { [EOL]             break; [EOL]         } [EOL]         if (q == mant.length * rsize + offset + 1) { [EOL]             break; [EOL]         } [EOL]         if (fpdecimal.charAt(p) == '.') { [EOL]             decimalFound = true; [EOL]             decimalPos = significantDigits; [EOL]             p++; [EOL]             continue; [EOL]         } [EOL]         if (fpdecimal.charAt(p) < '0' || fpdecimal.charAt(p) > '9') { [EOL]             p++; [EOL]             continue; [EOL]         } [EOL]         striped[q] = fpdecimal.charAt(p); [EOL]         q++; [EOL]         p++; [EOL]         significantDigits++; [EOL]     } [EOL]     if (decimalFound && q != offset) { [EOL]         for (; ; ) { [EOL]             q--; [EOL]             if (q == offset) { [EOL]                 break; [EOL]             } [EOL]             if (striped[q] == '0') { [EOL]                 significantDigits--; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (decimalFound && significantDigits == 0) { [EOL]         decimalPos = 0; [EOL]     } [EOL]     if (!decimalFound) { [EOL]         decimalPos = q - offset; [EOL]     } [EOL]     q = offset; [EOL]     p = significantDigits - 1 + offset; [EOL]     while (p > q) { [EOL]         if (striped[p] != '0') { [EOL]             break; [EOL]         } [EOL]         p--; [EOL]     } [EOL]     int i = ((rsize * 100) - decimalPos - sciexp % rsize) % rsize; [EOL]     q -= i; [EOL]     decimalPos += i; [EOL]     while ((p - q) < (mant.length * rsize)) { [EOL]         for (i = 0; i < rsize; i++) { [EOL]             striped[++p] = '0'; [EOL]         } [EOL]     } [EOL]     for (i = mant.length - 1; i >= 0; i--) { [EOL]         mant[i] = (striped[q] - '0') * 1000 + (striped[q + 1] - '0') * 100 + (striped[q + 2] - '0') * 10 + (striped[q + 3] - '0'); [EOL]         q += 4; [EOL]     } [EOL]     exp = (decimalPos + sciexp) / rsize; [EOL]     if (q < striped.length) { [EOL]         round((striped[q] - '0') * 1000); [EOL]     } [EOL] } <line_num>: 336,535
protected Dfp(final DfpField field, final byte sign, final byte nans) { [EOL]     this.field = field; [EOL]     this.mant = new int[field.getRadixDigits()]; [EOL]     this.sign = sign; [EOL]     this.exp = 0; [EOL]     this.nans = nans; [EOL] } <line_num>: 543,549
public Dfp newInstance() { [EOL]     return new Dfp(getField()); [EOL] } <line_num>: 555,557
public Dfp newInstance(final byte x) { [EOL]     return new Dfp(getField(), x); [EOL] } <line_num>: 563,565
public Dfp newInstance(final int x) { [EOL]     return new Dfp(getField(), x); [EOL] } <line_num>: 571,573
public Dfp newInstance(final long x) { [EOL]     return new Dfp(getField(), x); [EOL] } <line_num>: 579,581
public Dfp newInstance(final double x) { [EOL]     return new Dfp(getField(), x); [EOL] } <line_num>: 587,589
public Dfp newInstance(final Dfp d) { [EOL]     if (field.getRadixDigits() != d.field.getRadixDigits()) { [EOL]         field.setIEEEFlagsBits(DfpField.FLAG_INVALID); [EOL]         final Dfp result = newInstance(getZero()); [EOL]         result.nans = QNAN; [EOL]         return dotrap(DfpField.FLAG_INVALID, NEW_INSTANCE_TRAP, d, result); [EOL]     } [EOL]     return new Dfp(d); [EOL] } <line_num>: 596,608
public Dfp newInstance(final String s) { [EOL]     return new Dfp(field, s); [EOL] } <line_num>: 615,617
public Dfp newInstance(final byte sig, final byte code) { [EOL]     return field.newDfp(sig, code); [EOL] } <line_num>: 625,627
public DfpField getField() { [EOL]     return field; [EOL] } <line_num>: 636,638
public int getRadixDigits() { [EOL]     return field.getRadixDigits(); [EOL] } <line_num>: 643,645
public Dfp getZero() { [EOL]     return field.getZero(); [EOL] } <line_num>: 650,652
public Dfp getOne() { [EOL]     return field.getOne(); [EOL] } <line_num>: 657,659
public Dfp getTwo() { [EOL]     return field.getTwo(); [EOL] } <line_num>: 664,666
protected void shiftLeft() { [EOL]     for (int i = mant.length - 1; i > 0; i--) { [EOL]         mant[i] = mant[i - 1]; [EOL]     } [EOL]     mant[0] = 0; [EOL]     exp--; [EOL] } <line_num>: 670,676
protected void shiftRight() { [EOL]     for (int i = 0; i < mant.length - 1; i++) { [EOL]         mant[i] = mant[i + 1]; [EOL]     } [EOL]     mant[mant.length - 1] = 0; [EOL]     exp++; [EOL] } <line_num>: 682,688
protected int align(int e) { [EOL]     int lostdigit = 0; [EOL]     boolean inexact = false; [EOL]     int diff = exp - e; [EOL]     int adiff = diff; [EOL]     if (adiff < 0) { [EOL]         adiff = -adiff; [EOL]     } [EOL]     if (diff == 0) { [EOL]         return 0; [EOL]     } [EOL]     if (adiff > (mant.length + 1)) { [EOL]         Arrays.fill(mant, 0); [EOL]         exp = e; [EOL]         field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); [EOL]         dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this); [EOL]         return 0; [EOL]     } [EOL]     for (int i = 0; i < adiff; i++) { [EOL]         if (diff < 0) { [EOL]             if (lostdigit != 0) { [EOL]                 inexact = true; [EOL]             } [EOL]             lostdigit = mant[0]; [EOL]             shiftRight(); [EOL]         } else { [EOL]             shiftLeft(); [EOL]         } [EOL]     } [EOL]     if (inexact) { [EOL]         field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); [EOL]         dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this); [EOL]     } [EOL]     return lostdigit; [EOL] } <line_num>: 698,749
public boolean lessThan(final Dfp x) { [EOL]     if (field.getRadixDigits() != x.field.getRadixDigits()) { [EOL]         field.setIEEEFlagsBits(DfpField.FLAG_INVALID); [EOL]         final Dfp result = newInstance(getZero()); [EOL]         result.nans = QNAN; [EOL]         dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, result); [EOL]         return false; [EOL]     } [EOL]     if (isNaN() || x.isNaN()) { [EOL]         field.setIEEEFlagsBits(DfpField.FLAG_INVALID); [EOL]         dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, newInstance(getZero())); [EOL]         return false; [EOL]     } [EOL]     return compare(this, x) < 0; [EOL] } <line_num>: 755,774
public boolean greaterThan(final Dfp x) { [EOL]     if (field.getRadixDigits() != x.field.getRadixDigits()) { [EOL]         field.setIEEEFlagsBits(DfpField.FLAG_INVALID); [EOL]         final Dfp result = newInstance(getZero()); [EOL]         result.nans = QNAN; [EOL]         dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, result); [EOL]         return false; [EOL]     } [EOL]     if (isNaN() || x.isNaN()) { [EOL]         field.setIEEEFlagsBits(DfpField.FLAG_INVALID); [EOL]         dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, newInstance(getZero())); [EOL]         return false; [EOL]     } [EOL]     return compare(this, x) > 0; [EOL] } <line_num>: 780,799
public boolean negativeOrNull() { [EOL]     if (isNaN()) { [EOL]         field.setIEEEFlagsBits(DfpField.FLAG_INVALID); [EOL]         dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, this, newInstance(getZero())); [EOL]         return false; [EOL]     } [EOL]     return (sign < 0) || ((mant[mant.length - 1] == 0) && !isInfinite()); [EOL] } <line_num>: 804,814
public boolean strictlyNegative() { [EOL]     if (isNaN()) { [EOL]         field.setIEEEFlagsBits(DfpField.FLAG_INVALID); [EOL]         dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, this, newInstance(getZero())); [EOL]         return false; [EOL]     } [EOL]     return (sign < 0) && ((mant[mant.length - 1] != 0) || isInfinite()); [EOL] } <line_num>: 819,829
public boolean positiveOrNull() { [EOL]     if (isNaN()) { [EOL]         field.setIEEEFlagsBits(DfpField.FLAG_INVALID); [EOL]         dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, this, newInstance(getZero())); [EOL]         return false; [EOL]     } [EOL]     return (sign > 0) || ((mant[mant.length - 1] == 0) && !isInfinite()); [EOL] } <line_num>: 834,844
public boolean strictlyPositive() { [EOL]     if (isNaN()) { [EOL]         field.setIEEEFlagsBits(DfpField.FLAG_INVALID); [EOL]         dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, this, newInstance(getZero())); [EOL]         return false; [EOL]     } [EOL]     return (sign > 0) && ((mant[mant.length - 1] != 0) || isInfinite()); [EOL] } <line_num>: 849,859
public Dfp abs() { [EOL]     Dfp result = newInstance(this); [EOL]     result.sign = 1; [EOL]     return result; [EOL] } <line_num>: 865,869
public boolean isInfinite() { [EOL]     return nans == INFINITE; [EOL] } <line_num>: 874,876
public boolean isNaN() { [EOL]     return (nans == QNAN) || (nans == SNAN); [EOL] } <line_num>: 881,883
public boolean isZero() { [EOL]     if (isNaN()) { [EOL]         field.setIEEEFlagsBits(DfpField.FLAG_INVALID); [EOL]         dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, this, newInstance(getZero())); [EOL]         return false; [EOL]     } [EOL]     return (mant[mant.length - 1] == 0) && !isInfinite(); [EOL] } <line_num>: 888,898
@Override [EOL] public boolean equals(final Object other) { [EOL]     if (other instanceof Dfp) { [EOL]         final Dfp x = (Dfp) other; [EOL]         if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) { [EOL]             return false; [EOL]         } [EOL]         return compare(this, x) == 0; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 904,918
@Override [EOL] public int hashCode() { [EOL]     return 17 + (sign << 8) + (nans << 16) + exp + Arrays.hashCode(mant); [EOL] } <line_num>: 924,927
public boolean unequal(final Dfp x) { [EOL]     if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) { [EOL]         return false; [EOL]     } [EOL]     return greaterThan(x) || lessThan(x); [EOL] } <line_num>: 933,939
private static int compare(final Dfp a, final Dfp b) { [EOL]     if (a.mant[a.mant.length - 1] == 0 && b.mant[b.mant.length - 1] == 0 && a.nans == FINITE && b.nans == FINITE) { [EOL]         return 0; [EOL]     } [EOL]     if (a.sign != b.sign) { [EOL]         if (a.sign == -1) { [EOL]             return -1; [EOL]         } else { [EOL]             return 1; [EOL]         } [EOL]     } [EOL]     if (a.nans == INFINITE && b.nans == FINITE) { [EOL]         return a.sign; [EOL]     } [EOL]     if (a.nans == FINITE && b.nans == INFINITE) { [EOL]         return -b.sign; [EOL]     } [EOL]     if (a.nans == INFINITE && b.nans == INFINITE) { [EOL]         return 0; [EOL]     } [EOL]     if (b.mant[b.mant.length - 1] != 0 && a.mant[b.mant.length - 1] != 0) { [EOL]         if (a.exp < b.exp) { [EOL]             return -a.sign; [EOL]         } [EOL]         if (a.exp > b.exp) { [EOL]             return a.sign; [EOL]         } [EOL]     } [EOL]     for (int i = a.mant.length - 1; i >= 0; i--) { [EOL]         if (a.mant[i] > b.mant[i]) { [EOL]             return a.sign; [EOL]         } [EOL]         if (a.mant[i] < b.mant[i]) { [EOL]             return -a.sign; [EOL]         } [EOL]     } [EOL]     return 0; [EOL] } <line_num>: 947,999
public Dfp rint() { [EOL]     return trunc(DfpField.RoundingMode.ROUND_HALF_EVEN); [EOL] } <line_num>: 1007,1009
public Dfp floor() { [EOL]     return trunc(DfpField.RoundingMode.ROUND_FLOOR); [EOL] } <line_num>: 1016,1018
public Dfp ceil() { [EOL]     return trunc(DfpField.RoundingMode.ROUND_CEIL); [EOL] } <line_num>: 1025,1027
public Dfp remainder(final Dfp d) { [EOL]     final Dfp result = this.subtract(this.divide(d).rint().multiply(d)); [EOL]     if (result.mant[mant.length - 1] == 0) { [EOL]         result.sign = sign; [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1034,1045
protected Dfp trunc(final DfpField.RoundingMode rmode) { [EOL]     boolean changed = false; [EOL]     if (isNaN()) { [EOL]         return newInstance(this); [EOL]     } [EOL]     if (nans == INFINITE) { [EOL]         return newInstance(this); [EOL]     } [EOL]     if (mant[mant.length - 1] == 0) { [EOL]         return newInstance(this); [EOL]     } [EOL]     if (exp < 0) { [EOL]         field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); [EOL]         Dfp result = newInstance(getZero()); [EOL]         result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result); [EOL]         return result; [EOL]     } [EOL]     if (exp >= mant.length) { [EOL]         return newInstance(this); [EOL]     } [EOL]     Dfp result = newInstance(this); [EOL]     for (int i = 0; i < mant.length - result.exp; i++) { [EOL]         changed |= result.mant[i] != 0; [EOL]         result.mant[i] = 0; [EOL]     } [EOL]     if (changed) { [EOL]         switch(rmode) { [EOL]             case ROUND_FLOOR: [EOL]                 if (result.sign == -1) { [EOL]                     result = result.add(newInstance(-1)); [EOL]                 } [EOL]                 break; [EOL]             case ROUND_CEIL: [EOL]                 if (result.sign == 1) { [EOL]                     result = result.add(getOne()); [EOL]                 } [EOL]                 break; [EOL]             case ROUND_HALF_EVEN: [EOL]             default: [EOL]                 final Dfp half = newInstance("0.5"); [EOL]                 Dfp a = subtract(result); [EOL]                 a.sign = 1; [EOL]                 if (a.greaterThan(half)) { [EOL]                     a = newInstance(getOne()); [EOL]                     a.sign = sign; [EOL]                     result = result.add(a); [EOL]                 } [EOL]                 if (a.equals(half) && result.exp > 0 && (result.mant[mant.length - result.exp] & 1) != 0) { [EOL]                     a = newInstance(getOne()); [EOL]                     a.sign = sign; [EOL]                     result = result.add(a); [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); [EOL]         result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result); [EOL]         return result; [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1051,1135
public int intValue() { [EOL]     Dfp rounded; [EOL]     int result = 0; [EOL]     rounded = rint(); [EOL]     if (rounded.greaterThan(newInstance(2147483647))) { [EOL]         return 2147483647; [EOL]     } [EOL]     if (rounded.lessThan(newInstance(-2147483648))) { [EOL]         return -2147483648; [EOL]     } [EOL]     for (int i = mant.length - 1; i >= mant.length - rounded.exp; i--) { [EOL]         result = result * RADIX + rounded.mant[i]; [EOL]     } [EOL]     if (rounded.sign == -1) { [EOL]         result = -result; [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1141,1164
public int log10K() { [EOL]     return exp - 1; [EOL] } <line_num>: 1171,1173
public Dfp power10K(final int e) { [EOL]     Dfp d = newInstance(getOne()); [EOL]     d.exp = e + 1; [EOL]     return d; [EOL] } <line_num>: 1179,1183
public int intLog10() { [EOL]     if (mant[mant.length - 1] > 1000) { [EOL]         return exp * 4 - 1; [EOL]     } [EOL]     if (mant[mant.length - 1] > 100) { [EOL]         return exp * 4 - 2; [EOL]     } [EOL]     if (mant[mant.length - 1] > 10) { [EOL]         return exp * 4 - 3; [EOL]     } [EOL]     return exp * 4 - 4; [EOL] } <line_num>: 1189,1200
public Dfp power10(final int e) { [EOL]     Dfp d = newInstance(getOne()); [EOL]     if (e >= 0) { [EOL]         d.exp = e / 4 + 1; [EOL]     } else { [EOL]         d.exp = (e + 1) / 4; [EOL]     } [EOL]     switch((e % 4 + 4) % 4) { [EOL]         case 0: [EOL]             break; [EOL]         case 1: [EOL]             d = d.multiply(10); [EOL]             break; [EOL]         case 2: [EOL]             d = d.multiply(100); [EOL]             break; [EOL]         default: [EOL]             d = d.multiply(1000); [EOL]     } [EOL]     return d; [EOL] } <line_num>: 1206,1229
protected int complement(int extra) { [EOL]     extra = RADIX - extra; [EOL]     for (int i = 0; i < mant.length; i++) { [EOL]         mant[i] = RADIX - mant[i] - 1; [EOL]     } [EOL]     int rh = extra / RADIX; [EOL]     extra = extra - rh * RADIX; [EOL]     for (int i = 0; i < mant.length; i++) { [EOL]         final int r = mant[i] + rh; [EOL]         rh = r / RADIX; [EOL]         mant[i] = r - rh * RADIX; [EOL]     } [EOL]     return extra; [EOL] } <line_num>: 1237,1253
public Dfp add(final Dfp x) { [EOL]     if (field.getRadixDigits() != x.field.getRadixDigits()) { [EOL]         field.setIEEEFlagsBits(DfpField.FLAG_INVALID); [EOL]         final Dfp result = newInstance(getZero()); [EOL]         result.nans = QNAN; [EOL]         return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result); [EOL]     } [EOL]     if (nans != FINITE || x.nans != FINITE) { [EOL]         if (isNaN()) { [EOL]             return this; [EOL]         } [EOL]         if (x.isNaN()) { [EOL]             return x; [EOL]         } [EOL]         if (nans == INFINITE && x.nans == FINITE) { [EOL]             return this; [EOL]         } [EOL]         if (x.nans == INFINITE && nans == FINITE) { [EOL]             return x; [EOL]         } [EOL]         if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) { [EOL]             return x; [EOL]         } [EOL]         if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) { [EOL]             field.setIEEEFlagsBits(DfpField.FLAG_INVALID); [EOL]             Dfp result = newInstance(getZero()); [EOL]             result.nans = QNAN; [EOL]             result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result); [EOL]             return result; [EOL]         } [EOL]     } [EOL]     Dfp a = newInstance(this); [EOL]     Dfp b = newInstance(x); [EOL]     Dfp result = newInstance(getZero()); [EOL]     final byte asign = a.sign; [EOL]     final byte bsign = b.sign; [EOL]     a.sign = 1; [EOL]     b.sign = 1; [EOL]     byte rsign = bsign; [EOL]     if (compare(a, b) > 0) { [EOL]         rsign = asign; [EOL]     } [EOL]     if (b.mant[mant.length - 1] == 0) { [EOL]         b.exp = a.exp; [EOL]     } [EOL]     if (a.mant[mant.length - 1] == 0) { [EOL]         a.exp = b.exp; [EOL]     } [EOL]     int aextradigit = 0; [EOL]     int bextradigit = 0; [EOL]     if (a.exp < b.exp) { [EOL]         aextradigit = a.align(b.exp); [EOL]     } else { [EOL]         bextradigit = b.align(a.exp); [EOL]     } [EOL]     if (asign != bsign) { [EOL]         if (asign == rsign) { [EOL]             bextradigit = b.complement(bextradigit); [EOL]         } else { [EOL]             aextradigit = a.complement(aextradigit); [EOL]         } [EOL]     } [EOL]     int rh = 0; [EOL]     for (int i = 0; i < mant.length; i++) { [EOL]         final int r = a.mant[i] + b.mant[i] + rh; [EOL]         rh = r / RADIX; [EOL]         result.mant[i] = r - rh * RADIX; [EOL]     } [EOL]     result.exp = a.exp; [EOL]     result.sign = rsign; [EOL]     if (rh != 0 && (asign == bsign)) { [EOL]         final int lostdigit = result.mant[0]; [EOL]         result.shiftRight(); [EOL]         result.mant[mant.length - 1] = rh; [EOL]         final int excp = result.round(lostdigit); [EOL]         if (excp != 0) { [EOL]             result = dotrap(excp, ADD_TRAP, x, result); [EOL]         } [EOL]     } [EOL]     for (int i = 0; i < mant.length; i++) { [EOL]         if (result.mant[mant.length - 1] != 0) { [EOL]             break; [EOL]         } [EOL]         result.shiftLeft(); [EOL]         if (i == 0) { [EOL]             result.mant[0] = aextradigit + bextradigit; [EOL]             aextradigit = 0; [EOL]             bextradigit = 0; [EOL]         } [EOL]     } [EOL]     if (result.mant[mant.length - 1] == 0) { [EOL]         result.exp = 0; [EOL]         if (asign != bsign) { [EOL]             result.sign = 1; [EOL]         } [EOL]     } [EOL]     final int excp = result.round(aextradigit + bextradigit); [EOL]     if (excp != 0) { [EOL]         result = dotrap(excp, ADD_TRAP, x, result); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1259,1402
public Dfp negate() { [EOL]     Dfp result = newInstance(this); [EOL]     result.sign = (byte) -result.sign; [EOL]     return result; [EOL] } <line_num>: 1407,1411
public Dfp subtract(final Dfp x) { [EOL]     return add(x.negate()); [EOL] } <line_num>: 1417,1419
protected int round(int n) { [EOL]     boolean inc = false; [EOL]     switch(field.getRoundingMode()) { [EOL]         case ROUND_DOWN: [EOL]             inc = false; [EOL]             break; [EOL]         case ROUND_UP: [EOL]             inc = n != 0; [EOL]             break; [EOL]         case ROUND_HALF_UP: [EOL]             inc = n >= 5000; [EOL]             break; [EOL]         case ROUND_HALF_DOWN: [EOL]             inc = n > 5000; [EOL]             break; [EOL]         case ROUND_HALF_EVEN: [EOL]             inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 1); [EOL]             break; [EOL]         case ROUND_HALF_ODD: [EOL]             inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 0); [EOL]             break; [EOL]         case ROUND_CEIL: [EOL]             inc = sign == 1 && n != 0; [EOL]             break; [EOL]         case ROUND_FLOOR: [EOL]         default: [EOL]             inc = sign == -1 && n != 0; [EOL]             break; [EOL]     } [EOL]     if (inc) { [EOL]         int rh = 1; [EOL]         for (int i = 0; i < mant.length; i++) { [EOL]             final int r = mant[i] + rh; [EOL]             rh = r / RADIX; [EOL]             mant[i] = r - rh * RADIX; [EOL]         } [EOL]         if (rh != 0) { [EOL]             shiftRight(); [EOL]             mant[mant.length - 1] = rh; [EOL]         } [EOL]     } [EOL]     if (exp < MIN_EXP) { [EOL]         field.setIEEEFlagsBits(DfpField.FLAG_UNDERFLOW); [EOL]         return DfpField.FLAG_UNDERFLOW; [EOL]     } [EOL]     if (exp > MAX_EXP) { [EOL]         field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW); [EOL]         return DfpField.FLAG_OVERFLOW; [EOL]     } [EOL]     if (n != 0) { [EOL]         field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); [EOL]         return DfpField.FLAG_INEXACT; [EOL]     } [EOL]     return 0; [EOL] } <line_num>: 1425,1498
public Dfp multiply(final Dfp x) { [EOL]     if (field.getRadixDigits() != x.field.getRadixDigits()) { [EOL]         field.setIEEEFlagsBits(DfpField.FLAG_INVALID); [EOL]         final Dfp result = newInstance(getZero()); [EOL]         result.nans = QNAN; [EOL]         return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result); [EOL]     } [EOL]     Dfp result = newInstance(getZero()); [EOL]     if (nans != FINITE || x.nans != FINITE) { [EOL]         if (isNaN()) { [EOL]             return this; [EOL]         } [EOL]         if (x.isNaN()) { [EOL]             return x; [EOL]         } [EOL]         if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length - 1] != 0) { [EOL]             result = newInstance(this); [EOL]             result.sign = (byte) (sign * x.sign); [EOL]             return result; [EOL]         } [EOL]         if (x.nans == INFINITE && nans == FINITE && mant[mant.length - 1] != 0) { [EOL]             result = newInstance(x); [EOL]             result.sign = (byte) (sign * x.sign); [EOL]             return result; [EOL]         } [EOL]         if (x.nans == INFINITE && nans == INFINITE) { [EOL]             result = newInstance(this); [EOL]             result.sign = (byte) (sign * x.sign); [EOL]             return result; [EOL]         } [EOL]         if ((x.nans == INFINITE && nans == FINITE && mant[mant.length - 1] == 0) || (nans == INFINITE && x.nans == FINITE && x.mant[mant.length - 1] == 0)) { [EOL]             field.setIEEEFlagsBits(DfpField.FLAG_INVALID); [EOL]             result = newInstance(getZero()); [EOL]             result.nans = QNAN; [EOL]             result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result); [EOL]             return result; [EOL]         } [EOL]     } [EOL]     int[] product = new int[mant.length * 2]; [EOL]     for (int i = 0; i < mant.length; i++) { [EOL]         int rh = 0; [EOL]         for (int j = 0; j < mant.length; j++) { [EOL]             int r = mant[i] * x.mant[j]; [EOL]             r = r + product[i + j] + rh; [EOL]             rh = r / RADIX; [EOL]             product[i + j] = r - rh * RADIX; [EOL]         } [EOL]         product[i + mant.length] = rh; [EOL]     } [EOL]     int md = mant.length * 2 - 1; [EOL]     for (int i = mant.length * 2 - 1; i >= 0; i--) { [EOL]         if (product[i] != 0) { [EOL]             md = i; [EOL]             break; [EOL]         } [EOL]     } [EOL]     for (int i = 0; i < mant.length; i++) { [EOL]         result.mant[mant.length - i - 1] = product[md - i]; [EOL]     } [EOL]     result.exp = exp + x.exp + md - 2 * mant.length + 1; [EOL]     result.sign = (byte) ((sign == x.sign) ? 1 : -1); [EOL]     if (result.mant[mant.length - 1] == 0) { [EOL]         result.exp = 0; [EOL]     } [EOL]     final int excp; [EOL]     if (md > (mant.length - 1)) { [EOL]         excp = result.round(product[md - mant.length]); [EOL]     } else { [EOL]         excp = result.round(0); [EOL]     } [EOL]     if (excp != 0) { [EOL]         result = dotrap(excp, MULTIPLY_TRAP, x, result); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1504,1604
public Dfp multiply(final int x) { [EOL]     if (x >= 0 && x < RADIX) { [EOL]         return multiplyFast(x); [EOL]     } else { [EOL]         return multiply(newInstance(x)); [EOL]     } [EOL] } <line_num>: 1610,1616
private Dfp multiplyFast(final int x) { [EOL]     Dfp result = newInstance(this); [EOL]     if (nans != FINITE) { [EOL]         if (isNaN()) { [EOL]             return this; [EOL]         } [EOL]         if (nans == INFINITE && x != 0) { [EOL]             result = newInstance(this); [EOL]             return result; [EOL]         } [EOL]         if (nans == INFINITE && x == 0) { [EOL]             field.setIEEEFlagsBits(DfpField.FLAG_INVALID); [EOL]             result = newInstance(getZero()); [EOL]             result.nans = QNAN; [EOL]             result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, newInstance(getZero()), result); [EOL]             return result; [EOL]         } [EOL]     } [EOL]     if (x < 0 || x >= RADIX) { [EOL]         field.setIEEEFlagsBits(DfpField.FLAG_INVALID); [EOL]         result = newInstance(getZero()); [EOL]         result.nans = QNAN; [EOL]         result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result); [EOL]         return result; [EOL]     } [EOL]     int rh = 0; [EOL]     for (int i = 0; i < mant.length; i++) { [EOL]         final int r = mant[i] * x + rh; [EOL]         rh = r / RADIX; [EOL]         result.mant[i] = r - rh * RADIX; [EOL]     } [EOL]     int lostdigit = 0; [EOL]     if (rh != 0) { [EOL]         lostdigit = result.mant[0]; [EOL]         result.shiftRight(); [EOL]         result.mant[mant.length - 1] = rh; [EOL]     } [EOL]     if (result.mant[mant.length - 1] == 0) { [EOL]         result.exp = 0; [EOL]     } [EOL]     final int excp = result.round(lostdigit); [EOL]     if (excp != 0) { [EOL]         result = dotrap(excp, MULTIPLY_TRAP, result, result); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1623,1679
public Dfp divide(Dfp divisor) { [EOL]     int[] dividend; [EOL]     int[] quotient; [EOL]     int[] remainder; [EOL]     int qd; [EOL]     int nsqd; [EOL]     int trial = 0; [EOL]     int minadj; [EOL]     boolean trialgood; [EOL]     int md = 0; [EOL]     int excp; [EOL]     if (field.getRadixDigits() != divisor.field.getRadixDigits()) { [EOL]         field.setIEEEFlagsBits(DfpField.FLAG_INVALID); [EOL]         final Dfp result = newInstance(getZero()); [EOL]         result.nans = QNAN; [EOL]         return dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result); [EOL]     } [EOL]     Dfp result = newInstance(getZero()); [EOL]     if (nans != FINITE || divisor.nans != FINITE) { [EOL]         if (isNaN()) { [EOL]             return this; [EOL]         } [EOL]         if (divisor.isNaN()) { [EOL]             return divisor; [EOL]         } [EOL]         if (nans == INFINITE && divisor.nans == FINITE) { [EOL]             result = newInstance(this); [EOL]             result.sign = (byte) (sign * divisor.sign); [EOL]             return result; [EOL]         } [EOL]         if (divisor.nans == INFINITE && nans == FINITE) { [EOL]             result = newInstance(getZero()); [EOL]             result.sign = (byte) (sign * divisor.sign); [EOL]             return result; [EOL]         } [EOL]         if (divisor.nans == INFINITE && nans == INFINITE) { [EOL]             field.setIEEEFlagsBits(DfpField.FLAG_INVALID); [EOL]             result = newInstance(getZero()); [EOL]             result.nans = QNAN; [EOL]             result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result); [EOL]             return result; [EOL]         } [EOL]     } [EOL]     if (divisor.mant[mant.length - 1] == 0) { [EOL]         field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO); [EOL]         result = newInstance(getZero()); [EOL]         result.sign = (byte) (sign * divisor.sign); [EOL]         result.nans = INFINITE; [EOL]         result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, divisor, result); [EOL]         return result; [EOL]     } [EOL]     dividend = new int[mant.length + 1]; [EOL]     quotient = new int[mant.length + 2]; [EOL]     remainder = new int[mant.length + 1]; [EOL]     dividend[mant.length] = 0; [EOL]     quotient[mant.length] = 0; [EOL]     quotient[mant.length + 1] = 0; [EOL]     remainder[mant.length] = 0; [EOL]     for (int i = 0; i < mant.length; i++) { [EOL]         dividend[i] = mant[i]; [EOL]         quotient[i] = 0; [EOL]         remainder[i] = 0; [EOL]     } [EOL]     nsqd = 0; [EOL]     for (qd = mant.length + 1; qd >= 0; qd--) { [EOL]         final int divMsb = dividend[mant.length] * RADIX + dividend[mant.length - 1]; [EOL]         int min = divMsb / (divisor.mant[mant.length - 1] + 1); [EOL]         int max = (divMsb + 1) / divisor.mant[mant.length - 1]; [EOL]         trialgood = false; [EOL]         while (!trialgood) { [EOL]             trial = (min + max) / 2; [EOL]             int rh = 0; [EOL]             for (int i = 0; i < mant.length + 1; i++) { [EOL]                 int dm = (i < mant.length) ? divisor.mant[i] : 0; [EOL]                 final int r = (dm * trial) + rh; [EOL]                 rh = r / RADIX; [EOL]                 remainder[i] = r - rh * RADIX; [EOL]             } [EOL]             rh = 1; [EOL]             for (int i = 0; i < mant.length + 1; i++) { [EOL]                 final int r = ((RADIX - 1) - remainder[i]) + dividend[i] + rh; [EOL]                 rh = r / RADIX; [EOL]                 remainder[i] = r - rh * RADIX; [EOL]             } [EOL]             if (rh == 0) { [EOL]                 max = trial - 1; [EOL]                 continue; [EOL]             } [EOL]             minadj = (remainder[mant.length] * RADIX) + remainder[mant.length - 1]; [EOL]             minadj = minadj / (divisor.mant[mant.length - 1] + 1); [EOL]             if (minadj >= 2) { [EOL]                 min = trial + minadj; [EOL]                 continue; [EOL]             } [EOL]             trialgood = false; [EOL]             for (int i = mant.length - 1; i >= 0; i--) { [EOL]                 if (divisor.mant[i] > remainder[i]) { [EOL]                     trialgood = true; [EOL]                 } [EOL]                 if (divisor.mant[i] < remainder[i]) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             if (remainder[mant.length] != 0) { [EOL]                 trialgood = false; [EOL]             } [EOL]             if (trialgood == false) { [EOL]                 min = trial + 1; [EOL]             } [EOL]         } [EOL]         quotient[qd] = trial; [EOL]         if (trial != 0 || nsqd != 0) { [EOL]             nsqd++; [EOL]         } [EOL]         if (field.getRoundingMode() == DfpField.RoundingMode.ROUND_DOWN && nsqd == mant.length) { [EOL]             break; [EOL]         } [EOL]         if (nsqd > mant.length) { [EOL]             break; [EOL]         } [EOL]         dividend[0] = 0; [EOL]         for (int i = 0; i < mant.length; i++) { [EOL]             dividend[i + 1] = remainder[i]; [EOL]         } [EOL]     } [EOL]     md = mant.length; [EOL]     for (int i = mant.length + 1; i >= 0; i--) { [EOL]         if (quotient[i] != 0) { [EOL]             md = i; [EOL]             break; [EOL]         } [EOL]     } [EOL]     for (int i = 0; i < mant.length; i++) { [EOL]         result.mant[mant.length - i - 1] = quotient[md - i]; [EOL]     } [EOL]     result.exp = exp - divisor.exp + md - mant.length; [EOL]     result.sign = (byte) ((sign == divisor.sign) ? 1 : -1); [EOL]     if (result.mant[mant.length - 1] == 0) { [EOL]         result.exp = 0; [EOL]     } [EOL]     if (md > (mant.length - 1)) { [EOL]         excp = result.round(quotient[md - mant.length]); [EOL]     } else { [EOL]         excp = result.round(0); [EOL]     } [EOL]     if (excp != 0) { [EOL]         result = dotrap(excp, DIVIDE_TRAP, divisor, result); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1685,1893
public Dfp divide(int divisor) { [EOL]     if (nans != FINITE) { [EOL]         if (isNaN()) { [EOL]             return this; [EOL]         } [EOL]         if (nans == INFINITE) { [EOL]             return newInstance(this); [EOL]         } [EOL]     } [EOL]     if (divisor == 0) { [EOL]         field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO); [EOL]         Dfp result = newInstance(getZero()); [EOL]         result.sign = sign; [EOL]         result.nans = INFINITE; [EOL]         result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, getZero(), result); [EOL]         return result; [EOL]     } [EOL]     if (divisor < 0 || divisor >= RADIX) { [EOL]         field.setIEEEFlagsBits(DfpField.FLAG_INVALID); [EOL]         Dfp result = newInstance(getZero()); [EOL]         result.nans = QNAN; [EOL]         result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, result, result); [EOL]         return result; [EOL]     } [EOL]     Dfp result = newInstance(this); [EOL]     int rl = 0; [EOL]     for (int i = mant.length - 1; i >= 0; i--) { [EOL]         final int r = rl * RADIX + result.mant[i]; [EOL]         final int rh = r / divisor; [EOL]         rl = r - rh * divisor; [EOL]         result.mant[i] = rh; [EOL]     } [EOL]     if (result.mant[mant.length - 1] == 0) { [EOL]         result.shiftLeft(); [EOL]         final int r = rl * RADIX; [EOL]         final int rh = r / divisor; [EOL]         rl = r - rh * divisor; [EOL]         result.mant[0] = rh; [EOL]     } [EOL]     final int excp = result.round(rl * RADIX / divisor); [EOL]     if (excp != 0) { [EOL]         result = dotrap(excp, DIVIDE_TRAP, result, result); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1900,1958
public Dfp reciprocal() { [EOL]     return field.getOne().divide(this); [EOL] } <line_num>: 1961,1963
public Dfp sqrt() { [EOL]     if (nans == FINITE && mant[mant.length - 1] == 0) { [EOL]         return newInstance(this); [EOL]     } [EOL]     if (nans != FINITE) { [EOL]         if (nans == INFINITE && sign == 1) { [EOL]             return newInstance(this); [EOL]         } [EOL]         if (nans == QNAN) { [EOL]             return newInstance(this); [EOL]         } [EOL]         if (nans == SNAN) { [EOL]             Dfp result; [EOL]             field.setIEEEFlagsBits(DfpField.FLAG_INVALID); [EOL]             result = newInstance(this); [EOL]             result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result); [EOL]             return result; [EOL]         } [EOL]     } [EOL]     if (sign == -1) { [EOL]         Dfp result; [EOL]         field.setIEEEFlagsBits(DfpField.FLAG_INVALID); [EOL]         result = newInstance(this); [EOL]         result.nans = QNAN; [EOL]         result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result); [EOL]         return result; [EOL]     } [EOL]     Dfp x = newInstance(this); [EOL]     if (x.exp < -1 || x.exp > 1) { [EOL]         x.exp = this.exp / 2; [EOL]     } [EOL]     switch(x.mant[mant.length - 1] / 2000) { [EOL]         case 0: [EOL]             x.mant[mant.length - 1] = x.mant[mant.length - 1] / 2 + 1; [EOL]             break; [EOL]         case 2: [EOL]             x.mant[mant.length - 1] = 1500; [EOL]             break; [EOL]         case 3: [EOL]             x.mant[mant.length - 1] = 2200; [EOL]             break; [EOL]         default: [EOL]             x.mant[mant.length - 1] = 3000; [EOL]     } [EOL]     Dfp dx = newInstance(x); [EOL]     Dfp px = getZero(); [EOL]     Dfp ppx = getZero(); [EOL]     while (x.unequal(px)) { [EOL]         dx = newInstance(x); [EOL]         dx.sign = -1; [EOL]         dx = dx.add(this.divide(x)); [EOL]         dx = dx.divide(2); [EOL]         ppx = px; [EOL]         px = x; [EOL]         x = x.add(dx); [EOL]         if (x.equals(ppx)) { [EOL]             break; [EOL]         } [EOL]         if (dx.mant[mant.length - 1] == 0) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return x; [EOL] } <line_num>: 1969,2060
@Override [EOL] public String toString() { [EOL]     if (nans != FINITE) { [EOL]         if (nans == INFINITE) { [EOL]             return (sign < 0) ? NEG_INFINITY_STRING : POS_INFINITY_STRING; [EOL]         } else { [EOL]             return NAN_STRING; [EOL]         } [EOL]     } [EOL]     if (exp > mant.length || exp < -1) { [EOL]         return dfp2sci(); [EOL]     } [EOL]     return dfp2string(); [EOL] } <line_num>: 2065,2082
protected String dfp2sci() { [EOL]     char[] rawdigits = new char[mant.length * 4]; [EOL]     char[] outputbuffer = new char[mant.length * 4 + 20]; [EOL]     int p; [EOL]     int q; [EOL]     int e; [EOL]     int ae; [EOL]     int shf; [EOL]     p = 0; [EOL]     for (int i = mant.length - 1; i >= 0; i--) { [EOL]         rawdigits[p++] = (char) ((mant[i] / 1000) + '0'); [EOL]         rawdigits[p++] = (char) (((mant[i] / 100) % 10) + '0'); [EOL]         rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0'); [EOL]         rawdigits[p++] = (char) (((mant[i]) % 10) + '0'); [EOL]     } [EOL]     for (p = 0; p < rawdigits.length; p++) { [EOL]         if (rawdigits[p] != '0') { [EOL]             break; [EOL]         } [EOL]     } [EOL]     shf = p; [EOL]     q = 0; [EOL]     if (sign == -1) { [EOL]         outputbuffer[q++] = '-'; [EOL]     } [EOL]     if (p != rawdigits.length) { [EOL]         outputbuffer[q++] = rawdigits[p++]; [EOL]         outputbuffer[q++] = '.'; [EOL]         while (p < rawdigits.length) { [EOL]             outputbuffer[q++] = rawdigits[p++]; [EOL]         } [EOL]     } else { [EOL]         outputbuffer[q++] = '0'; [EOL]         outputbuffer[q++] = '.'; [EOL]         outputbuffer[q++] = '0'; [EOL]         outputbuffer[q++] = 'e'; [EOL]         outputbuffer[q++] = '0'; [EOL]         return new String(outputbuffer, 0, 5); [EOL]     } [EOL]     outputbuffer[q++] = 'e'; [EOL]     e = exp * 4 - shf - 1; [EOL]     ae = e; [EOL]     if (e < 0) { [EOL]         ae = -e; [EOL]     } [EOL]     for (p = 1000000000; p > ae; p /= 10) { [EOL]     } [EOL]     if (e < 0) { [EOL]         outputbuffer[q++] = '-'; [EOL]     } [EOL]     while (p > 0) { [EOL]         outputbuffer[q++] = (char) (ae / p + '0'); [EOL]         ae = ae % p; [EOL]         p = p / 10; [EOL]     } [EOL]     return new String(outputbuffer, 0, q); [EOL] } <line_num>: 2087,2163
protected String dfp2string() { [EOL]     char[] buffer = new char[mant.length * 4 + 20]; [EOL]     int p = 1; [EOL]     int q; [EOL]     int e = exp; [EOL]     boolean pointInserted = false; [EOL]     buffer[0] = ' '; [EOL]     if (e <= 0) { [EOL]         buffer[p++] = '0'; [EOL]         buffer[p++] = '.'; [EOL]         pointInserted = true; [EOL]     } [EOL]     while (e < 0) { [EOL]         buffer[p++] = '0'; [EOL]         buffer[p++] = '0'; [EOL]         buffer[p++] = '0'; [EOL]         buffer[p++] = '0'; [EOL]         e++; [EOL]     } [EOL]     for (int i = mant.length - 1; i >= 0; i--) { [EOL]         buffer[p++] = (char) ((mant[i] / 1000) + '0'); [EOL]         buffer[p++] = (char) (((mant[i] / 100) % 10) + '0'); [EOL]         buffer[p++] = (char) (((mant[i] / 10) % 10) + '0'); [EOL]         buffer[p++] = (char) (((mant[i]) % 10) + '0'); [EOL]         if (--e == 0) { [EOL]             buffer[p++] = '.'; [EOL]             pointInserted = true; [EOL]         } [EOL]     } [EOL]     while (e > 0) { [EOL]         buffer[p++] = '0'; [EOL]         buffer[p++] = '0'; [EOL]         buffer[p++] = '0'; [EOL]         buffer[p++] = '0'; [EOL]         e--; [EOL]     } [EOL]     if (!pointInserted) { [EOL]         buffer[p++] = '.'; [EOL]     } [EOL]     q = 1; [EOL]     while (buffer[q] == '0') { [EOL]         q++; [EOL]     } [EOL]     if (buffer[q] == '.') { [EOL]         q--; [EOL]     } [EOL]     while (buffer[p - 1] == '0') { [EOL]         p--; [EOL]     } [EOL]     if (sign < 0) { [EOL]         buffer[--q] = '-'; [EOL]     } [EOL]     return new String(buffer, q, p - q); [EOL] } <line_num>: 2168,2236
public Dfp dotrap(int type, String what, Dfp oper, Dfp result) { [EOL]     Dfp def = result; [EOL]     switch(type) { [EOL]         case DfpField.FLAG_INVALID: [EOL]             def = newInstance(getZero()); [EOL]             def.sign = result.sign; [EOL]             def.nans = QNAN; [EOL]             break; [EOL]         case DfpField.FLAG_DIV_ZERO: [EOL]             if (nans == FINITE && mant[mant.length - 1] != 0) { [EOL]                 def = newInstance(getZero()); [EOL]                 def.sign = (byte) (sign * oper.sign); [EOL]                 def.nans = INFINITE; [EOL]             } [EOL]             if (nans == FINITE && mant[mant.length - 1] == 0) { [EOL]                 def = newInstance(getZero()); [EOL]                 def.nans = QNAN; [EOL]             } [EOL]             if (nans == INFINITE || nans == QNAN) { [EOL]                 def = newInstance(getZero()); [EOL]                 def.nans = QNAN; [EOL]             } [EOL]             if (nans == INFINITE || nans == SNAN) { [EOL]                 def = newInstance(getZero()); [EOL]                 def.nans = QNAN; [EOL]             } [EOL]             break; [EOL]         case DfpField.FLAG_UNDERFLOW: [EOL]             if ((result.exp + mant.length) < MIN_EXP) { [EOL]                 def = newInstance(getZero()); [EOL]                 def.sign = result.sign; [EOL]             } else { [EOL]                 def = newInstance(result); [EOL]             } [EOL]             result.exp = result.exp + ERR_SCALE; [EOL]             break; [EOL]         case DfpField.FLAG_OVERFLOW: [EOL]             result.exp = result.exp - ERR_SCALE; [EOL]             def = newInstance(getZero()); [EOL]             def.sign = result.sign; [EOL]             def.nans = INFINITE; [EOL]             break; [EOL]         default: [EOL]             def = result; [EOL]             break; [EOL]     } [EOL]     return trap(type, what, oper, def, result); [EOL] } <line_num>: 2245,2302
protected Dfp trap(int type, String what, Dfp oper, Dfp def, Dfp result) { [EOL]     return def; [EOL] } <line_num>: 2315,2317
public int classify() { [EOL]     return nans; [EOL] } <line_num>: 2322,2324
public static Dfp copysign(final Dfp x, final Dfp y) { [EOL]     Dfp result = x.newInstance(x); [EOL]     result.sign = y.sign; [EOL]     return result; [EOL] } <line_num>: 2332,2336
public Dfp nextAfter(final Dfp x) { [EOL]     if (field.getRadixDigits() != x.field.getRadixDigits()) { [EOL]         field.setIEEEFlagsBits(DfpField.FLAG_INVALID); [EOL]         final Dfp result = newInstance(getZero()); [EOL]         result.nans = QNAN; [EOL]         return dotrap(DfpField.FLAG_INVALID, NEXT_AFTER_TRAP, x, result); [EOL]     } [EOL]     boolean up = false; [EOL]     if (this.lessThan(x)) { [EOL]         up = true; [EOL]     } [EOL]     if (compare(this, x) == 0) { [EOL]         return newInstance(x); [EOL]     } [EOL]     if (lessThan(getZero())) { [EOL]         up = !up; [EOL]     } [EOL]     final Dfp inc; [EOL]     Dfp result; [EOL]     if (up) { [EOL]         inc = newInstance(getOne()); [EOL]         inc.exp = this.exp - mant.length + 1; [EOL]         inc.sign = this.sign; [EOL]         if (this.equals(getZero())) { [EOL]             inc.exp = MIN_EXP - mant.length; [EOL]         } [EOL]         result = add(inc); [EOL]     } else { [EOL]         inc = newInstance(getOne()); [EOL]         inc.exp = this.exp; [EOL]         inc.sign = this.sign; [EOL]         if (this.equals(inc)) { [EOL]             inc.exp = this.exp - mant.length; [EOL]         } else { [EOL]             inc.exp = this.exp - mant.length + 1; [EOL]         } [EOL]         if (this.equals(getZero())) { [EOL]             inc.exp = MIN_EXP - mant.length; [EOL]         } [EOL]         result = this.subtract(inc); [EOL]     } [EOL]     if (result.classify() == INFINITE && this.classify() != INFINITE) { [EOL]         field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); [EOL]         result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result); [EOL]     } [EOL]     if (result.equals(getZero()) && this.equals(getZero()) == false) { [EOL]         field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); [EOL]         result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 2343,2409
public double toDouble() { [EOL]     if (isInfinite()) { [EOL]         if (lessThan(getZero())) { [EOL]             return Double.NEGATIVE_INFINITY; [EOL]         } else { [EOL]             return Double.POSITIVE_INFINITY; [EOL]         } [EOL]     } [EOL]     if (isNaN()) { [EOL]         return Double.NaN; [EOL]     } [EOL]     Dfp y = this; [EOL]     boolean negate = false; [EOL]     int cmp0 = compare(this, getZero()); [EOL]     if (cmp0 == 0) { [EOL]         return sign < 0 ? -0.0 : +0.0; [EOL]     } else if (cmp0 < 0) { [EOL]         y = negate(); [EOL]         negate = true; [EOL]     } [EOL]     int exponent = (int) (y.intLog10() * 3.32); [EOL]     if (exponent < 0) { [EOL]         exponent--; [EOL]     } [EOL]     Dfp tempDfp = DfpMath.pow(getTwo(), exponent); [EOL]     while (tempDfp.lessThan(y) || tempDfp.equals(y)) { [EOL]         tempDfp = tempDfp.multiply(2); [EOL]         exponent++; [EOL]     } [EOL]     exponent--; [EOL]     y = y.divide(DfpMath.pow(getTwo(), exponent)); [EOL]     if (exponent > -1023) { [EOL]         y = y.subtract(getOne()); [EOL]     } [EOL]     if (exponent < -1074) { [EOL]         return 0; [EOL]     } [EOL]     if (exponent > 1023) { [EOL]         return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY; [EOL]     } [EOL]     y = y.multiply(newInstance(4503599627370496l)).rint(); [EOL]     String str = y.toString(); [EOL]     str = str.substring(0, str.length() - 1); [EOL]     long mantissa = Long.parseLong(str); [EOL]     if (mantissa == 4503599627370496L) { [EOL]         mantissa = 0; [EOL]         exponent++; [EOL]     } [EOL]     if (exponent <= -1023) { [EOL]         exponent--; [EOL]     } [EOL]     while (exponent < -1023) { [EOL]         exponent++; [EOL]         mantissa >>>= 1; [EOL]     } [EOL]     long bits = mantissa | ((exponent + 1023L) << 52); [EOL]     double x = Double.longBitsToDouble(bits); [EOL]     if (negate) { [EOL]         x = -x; [EOL]     } [EOL]     return x; [EOL] } <line_num>: 2415,2499
public double[] toSplitDouble() { [EOL]     double[] split = new double[2]; [EOL]     long mask = 0xffffffffc0000000L; [EOL]     split[0] = Double.longBitsToDouble(Double.doubleToLongBits(toDouble()) & mask); [EOL]     split[1] = subtract(newInstance(split[0])).toDouble(); [EOL]     return split; [EOL] } <line_num>: 2505,2513
public double getReal() { [EOL]     return toDouble(); [EOL] } <line_num>: 2518,2520
public Dfp add(final double a) { [EOL]     return add(newInstance(a)); [EOL] } <line_num>: 2525,2527
public Dfp subtract(final double a) { [EOL]     return subtract(newInstance(a)); [EOL] } <line_num>: 2532,2534
public Dfp multiply(final double a) { [EOL]     return multiply(newInstance(a)); [EOL] } <line_num>: 2539,2541
public Dfp divide(final double a) { [EOL]     return divide(newInstance(a)); [EOL] } <line_num>: 2546,2548
public Dfp remainder(final double a) { [EOL]     return remainder(newInstance(a)); [EOL] } <line_num>: 2553,2555
public long round() { [EOL]     return FastMath.round(toDouble()); [EOL] } <line_num>: 2560,2562
public Dfp signum() { [EOL]     if (isNaN() || isZero()) { [EOL]         return this; [EOL]     } else { [EOL]         return newInstance(sign > 0 ? +1 : -1); [EOL]     } [EOL] } <line_num>: 2567,2573
public Dfp copySign(final Dfp s) { [EOL]     if ((sign >= 0 && s.sign >= 0) || (sign < 0 && s.sign < 0)) { [EOL]         return this; [EOL]     } [EOL]     return negate(); [EOL] } <line_num>: 2578,2583
public Dfp copySign(final double s) { [EOL]     long sb = Double.doubleToLongBits(s); [EOL]     if ((sign >= 0 && sb >= 0) || (sign < 0 && sb < 0)) { [EOL]         return this; [EOL]     } [EOL]     return negate(); [EOL] } <line_num>: 2588,2594
public Dfp scalb(final int n) { [EOL]     return multiply(DfpMath.pow(getTwo(), n)); [EOL] } <line_num>: 2599,2601
public Dfp hypot(final Dfp y) { [EOL]     return multiply(this).add(y.multiply(y)).sqrt(); [EOL] } <line_num>: 2606,2608
public Dfp cbrt() { [EOL]     return rootN(3); [EOL] } <line_num>: 2613,2615
public Dfp rootN(final int n) { [EOL]     return (sign >= 0) ? DfpMath.pow(this, getOne().divide(n)) : DfpMath.pow(negate(), getOne().divide(n)).negate(); [EOL] } <line_num>: 2620,2624
public Dfp pow(final double p) { [EOL]     return DfpMath.pow(this, newInstance(p)); [EOL] } <line_num>: 2629,2631
public Dfp pow(final int n) { [EOL]     return DfpMath.pow(this, n); [EOL] } <line_num>: 2636,2638
public Dfp pow(final Dfp e) { [EOL]     return DfpMath.pow(this, e); [EOL] } <line_num>: 2643,2645
public Dfp exp() { [EOL]     return DfpMath.exp(this); [EOL] } <line_num>: 2650,2652
public Dfp expm1() { [EOL]     return DfpMath.exp(this).subtract(getOne()); [EOL] } <line_num>: 2657,2659
public Dfp log() { [EOL]     return DfpMath.log(this); [EOL] } <line_num>: 2664,2666
public Dfp log1p() { [EOL]     return DfpMath.log(this.add(getOne())); [EOL] } <line_num>: 2671,2673
@Deprecated [EOL] public int log10() { [EOL]     return intLog10(); [EOL] } <line_num>: 2681,2684
public Dfp cos() { [EOL]     return DfpMath.cos(this); [EOL] } <line_num>: 2697,2699
public Dfp sin() { [EOL]     return DfpMath.sin(this); [EOL] } <line_num>: 2704,2706
public Dfp tan() { [EOL]     return DfpMath.tan(this); [EOL] } <line_num>: 2711,2713
public Dfp acos() { [EOL]     return DfpMath.acos(this); [EOL] } <line_num>: 2718,2720
public Dfp asin() { [EOL]     return DfpMath.asin(this); [EOL] } <line_num>: 2725,2727
public Dfp atan() { [EOL]     return DfpMath.atan(this); [EOL] } <line_num>: 2732,2734
public Dfp atan2(final Dfp x) throws DimensionMismatchException { [EOL]     final Dfp r = x.multiply(x).add(multiply(this)).sqrt(); [EOL]     if (x.sign >= 0) { [EOL]         return getTwo().multiply(divide(r.add(x)).atan()); [EOL]     } else { [EOL]         final Dfp tmp = getTwo().multiply(divide(r.subtract(x)).atan()); [EOL]         final Dfp pmPi = newInstance((tmp.sign <= 0) ? -FastMath.PI : FastMath.PI); [EOL]         return pmPi.subtract(tmp); [EOL]     } [EOL] } <line_num>: 2739,2759
public Dfp cosh() { [EOL]     return DfpMath.exp(this).add(DfpMath.exp(negate())).divide(2); [EOL] } <line_num>: 2764,2766
public Dfp sinh() { [EOL]     return DfpMath.exp(this).subtract(DfpMath.exp(negate())).divide(2); [EOL] } <line_num>: 2771,2773
public Dfp tanh() { [EOL]     final Dfp ePlus = DfpMath.exp(this); [EOL]     final Dfp eMinus = DfpMath.exp(negate()); [EOL]     return ePlus.subtract(eMinus).divide(ePlus.add(eMinus)); [EOL] } <line_num>: 2778,2782
public Dfp acosh() { [EOL]     return multiply(this).subtract(getOne()).sqrt().add(this).log(); [EOL] } <line_num>: 2787,2789
public Dfp asinh() { [EOL]     return multiply(this).add(getOne()).sqrt().add(this).log(); [EOL] } <line_num>: 2794,2796
public Dfp atanh() { [EOL]     return getOne().add(this).divide(getOne().subtract(this)).log().divide(2); [EOL] } <line_num>: 2801,2803
public Dfp linearCombination(final Dfp[] a, final Dfp[] b) throws DimensionMismatchException { [EOL]     if (a.length != b.length) { [EOL]         throw new DimensionMismatchException(a.length, b.length); [EOL]     } [EOL]     Dfp r = getZero(); [EOL]     for (int i = 0; i < a.length; ++i) { [EOL]         r = r.add(a[i].multiply(b[i])); [EOL]     } [EOL]     return r; [EOL] } <line_num>: 2808,2818
public Dfp linearCombination(final double[] a, final Dfp[] b) throws DimensionMismatchException { [EOL]     if (a.length != b.length) { [EOL]         throw new DimensionMismatchException(a.length, b.length); [EOL]     } [EOL]     Dfp r = getZero(); [EOL]     for (int i = 0; i < a.length; ++i) { [EOL]         r = r.add(b[i].multiply(a[i])); [EOL]     } [EOL]     return r; [EOL] } <line_num>: 2823,2833
public Dfp linearCombination(final Dfp a1, final Dfp b1, final Dfp a2, final Dfp b2) { [EOL]     return a1.multiply(b1).add(a2.multiply(b2)); [EOL] } <line_num>: 2838,2840
public Dfp linearCombination(final double a1, final Dfp b1, final double a2, final Dfp b2) { [EOL]     return b1.multiply(a1).add(b2.multiply(a2)); [EOL] } <line_num>: 2845,2847
public Dfp linearCombination(final Dfp a1, final Dfp b1, final Dfp a2, final Dfp b2, final Dfp a3, final Dfp b3) { [EOL]     return a1.multiply(b1).add(a2.multiply(b2)).add(a3.multiply(b3)); [EOL] } <line_num>: 2852,2856
public Dfp linearCombination(final double a1, final Dfp b1, final double a2, final Dfp b2, final double a3, final Dfp b3) { [EOL]     return b1.multiply(a1).add(b2.multiply(a2)).add(b3.multiply(a3)); [EOL] } <line_num>: 2861,2865
public Dfp linearCombination(final Dfp a1, final Dfp b1, final Dfp a2, final Dfp b2, final Dfp a3, final Dfp b3, final Dfp a4, final Dfp b4) { [EOL]     return a1.multiply(b1).add(a2.multiply(b2)).add(a3.multiply(b3)).add(a4.multiply(b4)); [EOL] } <line_num>: 2870,2873
public Dfp linearCombination(final double a1, final Dfp b1, final double a2, final Dfp b2, final double a3, final Dfp b3, final double a4, final Dfp b4) { [EOL]     return b1.multiply(a1).add(b2.multiply(a2)).add(b3.multiply(a3)).add(b4.multiply(a4)); [EOL] } <line_num>: 2878,2881
