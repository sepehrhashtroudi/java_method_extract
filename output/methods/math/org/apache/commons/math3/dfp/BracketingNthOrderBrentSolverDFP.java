public BracketingNthOrderBrentSolverDFP(final Dfp relativeAccuracy, final Dfp absoluteAccuracy, final Dfp functionValueAccuracy, final int maximalOrder) throws NumberIsTooSmallException { [EOL]     if (maximalOrder < 2) { [EOL]         throw new NumberIsTooSmallException(maximalOrder, 2, true); [EOL]     } [EOL]     this.maximalOrder = maximalOrder; [EOL]     this.absoluteAccuracy = absoluteAccuracy; [EOL]     this.relativeAccuracy = relativeAccuracy; [EOL]     this.functionValueAccuracy = functionValueAccuracy; [EOL] } <line_num>: 73,85
public int getMaximalOrder() { [EOL]     return maximalOrder; [EOL] } <line_num>: 90,92
public int getMaxEvaluations() { [EOL]     return evaluations.getMaximalCount(); [EOL] } <line_num>: 99,101
public int getEvaluations() { [EOL]     return evaluations.getCount(); [EOL] } <line_num>: 111,113
public Dfp getAbsoluteAccuracy() { [EOL]     return absoluteAccuracy; [EOL] } <line_num>: 119,121
public Dfp getRelativeAccuracy() { [EOL]     return relativeAccuracy; [EOL] } <line_num>: 127,129
public Dfp getFunctionValueAccuracy() { [EOL]     return functionValueAccuracy; [EOL] } <line_num>: 135,137
public Dfp solve(final int maxEval, final UnivariateDfpFunction f, final Dfp min, final Dfp max, final AllowedSolution allowedSolution) throws NullArgumentException, NoBracketingException { [EOL]     return solve(maxEval, f, min, max, min.add(max).divide(2), allowedSolution); [EOL] } <line_num>: 155,159
public Dfp solve(final int maxEval, final UnivariateDfpFunction f, final Dfp min, final Dfp max, final Dfp startValue, final AllowedSolution allowedSolution) throws NullArgumentException, NoBracketingException { [EOL]     MathUtils.checkNotNull(f); [EOL]     evaluations.setMaximalCount(maxEval); [EOL]     evaluations.resetCount(); [EOL]     Dfp zero = startValue.getZero(); [EOL]     Dfp nan = zero.newInstance((byte) 1, Dfp.QNAN); [EOL]     final Dfp[] x = new Dfp[maximalOrder + 1]; [EOL]     final Dfp[] y = new Dfp[maximalOrder + 1]; [EOL]     x[0] = min; [EOL]     x[1] = startValue; [EOL]     x[2] = max; [EOL]     evaluations.incrementCount(); [EOL]     y[1] = f.value(x[1]); [EOL]     if (y[1].isZero()) { [EOL]         return x[1]; [EOL]     } [EOL]     evaluations.incrementCount(); [EOL]     y[0] = f.value(x[0]); [EOL]     if (y[0].isZero()) { [EOL]         return x[0]; [EOL]     } [EOL]     int nbPoints; [EOL]     int signChangeIndex; [EOL]     if (y[0].multiply(y[1]).negativeOrNull()) { [EOL]         nbPoints = 2; [EOL]         signChangeIndex = 1; [EOL]     } else { [EOL]         evaluations.incrementCount(); [EOL]         y[2] = f.value(x[2]); [EOL]         if (y[2].isZero()) { [EOL]             return x[2]; [EOL]         } [EOL]         if (y[1].multiply(y[2]).negativeOrNull()) { [EOL]             nbPoints = 3; [EOL]             signChangeIndex = 2; [EOL]         } else { [EOL]             throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(), y[0].toDouble(), y[2].toDouble()); [EOL]         } [EOL]     } [EOL]     final Dfp[] tmpX = new Dfp[x.length]; [EOL]     Dfp xA = x[signChangeIndex - 1]; [EOL]     Dfp yA = y[signChangeIndex - 1]; [EOL]     Dfp absXA = xA.abs(); [EOL]     Dfp absYA = yA.abs(); [EOL]     int agingA = 0; [EOL]     Dfp xB = x[signChangeIndex]; [EOL]     Dfp yB = y[signChangeIndex]; [EOL]     Dfp absXB = xB.abs(); [EOL]     Dfp absYB = yB.abs(); [EOL]     int agingB = 0; [EOL]     while (true) { [EOL]         Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA; [EOL]         Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA; [EOL]         final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX)); [EOL]         if (xB.subtract(xA).subtract(xTol).negativeOrNull() || maxY.lessThan(functionValueAccuracy)) { [EOL]             switch(allowedSolution) { [EOL]                 case ANY_SIDE: [EOL]                     return absYA.lessThan(absYB) ? xA : xB; [EOL]                 case LEFT_SIDE: [EOL]                     return xA; [EOL]                 case RIGHT_SIDE: [EOL]                     return xB; [EOL]                 case BELOW_SIDE: [EOL]                     return yA.lessThan(zero) ? xA : xB; [EOL]                 case ABOVE_SIDE: [EOL]                     return yA.lessThan(zero) ? xB : xA; [EOL]                 default: [EOL]                     throw new MathInternalError(null); [EOL]             } [EOL]         } [EOL]         Dfp targetY; [EOL]         if (agingA >= MAXIMAL_AGING) { [EOL]             targetY = yB.divide(16).negate(); [EOL]         } else if (agingB >= MAXIMAL_AGING) { [EOL]             targetY = yA.divide(16).negate(); [EOL]         } else { [EOL]             targetY = zero; [EOL]         } [EOL]         Dfp nextX; [EOL]         int start = 0; [EOL]         int end = nbPoints; [EOL]         do { [EOL]             System.arraycopy(x, start, tmpX, start, end - start); [EOL]             nextX = guessX(targetY, tmpX, y, start, end); [EOL]             if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) { [EOL]                 if (signChangeIndex - start >= end - signChangeIndex) { [EOL]                     ++start; [EOL]                 } else { [EOL]                     --end; [EOL]                 } [EOL]                 nextX = nan; [EOL]             } [EOL]         } while (nextX.isNaN() && (end - start > 1)); [EOL]         if (nextX.isNaN()) { [EOL]             nextX = xA.add(xB.subtract(xA).divide(2)); [EOL]             start = signChangeIndex - 1; [EOL]             end = signChangeIndex; [EOL]         } [EOL]         evaluations.incrementCount(); [EOL]         final Dfp nextY = f.value(nextX); [EOL]         if (nextY.isZero()) { [EOL]             return nextX; [EOL]         } [EOL]         if ((nbPoints > 2) && (end - start != nbPoints)) { [EOL]             nbPoints = end - start; [EOL]             System.arraycopy(x, start, x, 0, nbPoints); [EOL]             System.arraycopy(y, start, y, 0, nbPoints); [EOL]             signChangeIndex -= start; [EOL]         } else if (nbPoints == x.length) { [EOL]             nbPoints--; [EOL]             if (signChangeIndex >= (x.length + 1) / 2) { [EOL]                 System.arraycopy(x, 1, x, 0, nbPoints); [EOL]                 System.arraycopy(y, 1, y, 0, nbPoints); [EOL]                 --signChangeIndex; [EOL]             } [EOL]         } [EOL]         System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex); [EOL]         x[signChangeIndex] = nextX; [EOL]         System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex); [EOL]         y[signChangeIndex] = nextY; [EOL]         ++nbPoints; [EOL]         if (nextY.multiply(yA).negativeOrNull()) { [EOL]             xB = nextX; [EOL]             yB = nextY; [EOL]             absYB = yB.abs(); [EOL]             ++agingA; [EOL]             agingB = 0; [EOL]         } else { [EOL]             xA = nextX; [EOL]             yA = nextY; [EOL]             absYA = yA.abs(); [EOL]             agingA = 0; [EOL]             ++agingB; [EOL]             signChangeIndex++; [EOL]         } [EOL]     } [EOL] } <line_num>: 178,400
private Dfp guessX(final Dfp targetY, final Dfp[] x, final Dfp[] y, final int start, final int end) { [EOL]     for (int i = start; i < end - 1; ++i) { [EOL]         final int delta = i + 1 - start; [EOL]         for (int j = end - 1; j > i; --j) { [EOL]             x[j] = x[j].subtract(x[j - 1]).divide(y[j].subtract(y[j - delta])); [EOL]         } [EOL]     } [EOL]     Dfp x0 = targetY.getZero(); [EOL]     for (int j = end - 1; j >= start; --j) { [EOL]         x0 = x[j].add(x0.multiply(targetY.subtract(y[j]))); [EOL]     } [EOL]     return x0; [EOL] } <line_num>: 416,435
