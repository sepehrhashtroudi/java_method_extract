private DfpMath() { [EOL] } <line_num>: 33,34
protected static Dfp[] split(final DfpField field, final String a) { [EOL]     Dfp[] result = new Dfp[2]; [EOL]     char[] buf; [EOL]     boolean leading = true; [EOL]     int sp = 0; [EOL]     int sig = 0; [EOL]     buf = new char[a.length()]; [EOL]     for (int i = 0; i < buf.length; i++) { [EOL]         buf[i] = a.charAt(i); [EOL]         if (buf[i] >= '1' && buf[i] <= '9') { [EOL]             leading = false; [EOL]         } [EOL]         if (buf[i] == '.') { [EOL]             sig += (400 - sig) % 4; [EOL]             leading = false; [EOL]         } [EOL]         if (sig == (field.getRadixDigits() / 2) * 4) { [EOL]             sp = i; [EOL]             break; [EOL]         } [EOL]         if (buf[i] >= '0' && buf[i] <= '9' && !leading) { [EOL]             sig++; [EOL]         } [EOL]     } [EOL]     result[0] = field.newDfp(new String(buf, 0, sp)); [EOL]     for (int i = 0; i < buf.length; i++) { [EOL]         buf[i] = a.charAt(i); [EOL]         if (buf[i] >= '0' && buf[i] <= '9' && i < sp) { [EOL]             buf[i] = '0'; [EOL]         } [EOL]     } [EOL]     result[1] = field.newDfp(new String(buf)); [EOL]     return result; [EOL] } <line_num>: 45,88
protected static Dfp[] split(final Dfp a) { [EOL]     final Dfp[] result = new Dfp[2]; [EOL]     final Dfp shift = a.multiply(a.power10K(a.getRadixDigits() / 2)); [EOL]     result[0] = a.add(shift).subtract(shift); [EOL]     result[1] = a.subtract(result[0]); [EOL]     return result; [EOL] } <line_num>: 94,100
protected static Dfp[] splitMult(final Dfp[] a, final Dfp[] b) { [EOL]     final Dfp[] result = new Dfp[2]; [EOL]     result[1] = a[0].getZero(); [EOL]     result[0] = a[0].multiply(b[0]); [EOL]     if (result[0].classify() == Dfp.INFINITE || result[0].equals(result[1])) { [EOL]         return result; [EOL]     } [EOL]     result[1] = a[0].multiply(b[1]).add(a[1].multiply(b[0])).add(a[1].multiply(b[1])); [EOL]     return result; [EOL] } <line_num>: 110,127
protected static Dfp[] splitDiv(final Dfp[] a, final Dfp[] b) { [EOL]     final Dfp[] result; [EOL]     result = new Dfp[2]; [EOL]     result[0] = a[0].divide(b[0]); [EOL]     result[1] = a[1].multiply(b[0]).subtract(a[0].multiply(b[1])); [EOL]     result[1] = result[1].divide(b[0].multiply(b[0]).add(b[0].multiply(b[1]))); [EOL]     return result; [EOL] } <line_num>: 136,146
protected static Dfp splitPow(final Dfp[] base, int a) { [EOL]     boolean invert = false; [EOL]     Dfp[] r = new Dfp[2]; [EOL]     Dfp[] result = new Dfp[2]; [EOL]     result[0] = base[0].getOne(); [EOL]     result[1] = base[0].getZero(); [EOL]     if (a == 0) { [EOL]         return result[0].add(result[1]); [EOL]     } [EOL]     if (a < 0) { [EOL]         invert = true; [EOL]         a = -a; [EOL]     } [EOL]     do { [EOL]         r[0] = new Dfp(base[0]); [EOL]         r[1] = new Dfp(base[1]); [EOL]         int trial = 1; [EOL]         int prevtrial; [EOL]         while (true) { [EOL]             prevtrial = trial; [EOL]             trial = trial * 2; [EOL]             if (trial > a) { [EOL]                 break; [EOL]             } [EOL]             r = splitMult(r, r); [EOL]         } [EOL]         trial = prevtrial; [EOL]         a -= trial; [EOL]         result = splitMult(result, r); [EOL]     } while (a >= 1); [EOL]     result[0] = result[0].add(result[1]); [EOL]     if (invert) { [EOL]         result[0] = base[0].getOne().divide(result[0]); [EOL]     } [EOL]     return result[0]; [EOL] } <line_num>: 153,204
public static Dfp pow(Dfp base, int a) { [EOL]     boolean invert = false; [EOL]     Dfp result = base.getOne(); [EOL]     if (a == 0) { [EOL]         return result; [EOL]     } [EOL]     if (a < 0) { [EOL]         invert = true; [EOL]         a = -a; [EOL]     } [EOL]     do { [EOL]         Dfp r = new Dfp(base); [EOL]         Dfp prevr; [EOL]         int trial = 1; [EOL]         int prevtrial; [EOL]         do { [EOL]             prevr = new Dfp(r); [EOL]             prevtrial = trial; [EOL]             r = r.multiply(r); [EOL]             trial = trial * 2; [EOL]         } while (a > trial); [EOL]         r = prevr; [EOL]         trial = prevtrial; [EOL]         a = a - trial; [EOL]         result = result.multiply(r); [EOL]     } while (a >= 1); [EOL]     if (invert) { [EOL]         result = base.getOne().divide(result); [EOL]     } [EOL]     return base.newInstance(result); [EOL] } <line_num>: 211,255
public static Dfp exp(final Dfp a) { [EOL]     final Dfp inta = a.rint(); [EOL]     final Dfp fraca = a.subtract(inta); [EOL]     final int ia = inta.intValue(); [EOL]     if (ia > 2147483646) { [EOL]         return a.newInstance((byte) 1, Dfp.INFINITE); [EOL]     } [EOL]     if (ia < -2147483646) { [EOL]         return a.newInstance(); [EOL]     } [EOL]     final Dfp einta = splitPow(a.getField().getESplit(), ia); [EOL]     final Dfp efraca = expInternal(fraca); [EOL]     return einta.multiply(efraca); [EOL] } <line_num>: 264,284
protected static Dfp expInternal(final Dfp a) { [EOL]     Dfp y = a.getOne(); [EOL]     Dfp x = a.getOne(); [EOL]     Dfp fact = a.getOne(); [EOL]     Dfp py = new Dfp(y); [EOL]     for (int i = 1; i < 90; i++) { [EOL]         x = x.multiply(a); [EOL]         fact = fact.divide(i); [EOL]         y = y.add(x.multiply(fact)); [EOL]         if (y.equals(py)) { [EOL]             break; [EOL]         } [EOL]         py = new Dfp(y); [EOL]     } [EOL]     return y; [EOL] } <line_num>: 291,308
public static Dfp log(Dfp a) { [EOL]     int lr; [EOL]     Dfp x; [EOL]     int ix; [EOL]     int p2 = 0; [EOL]     if (a.equals(a.getZero()) || a.lessThan(a.getZero()) || a.isNaN()) { [EOL]         a.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID); [EOL]         return a.dotrap(DfpField.FLAG_INVALID, "ln", a, a.newInstance((byte) 1, Dfp.QNAN)); [EOL]     } [EOL]     if (a.classify() == Dfp.INFINITE) { [EOL]         return a; [EOL]     } [EOL]     x = new Dfp(a); [EOL]     lr = x.log10K(); [EOL]     x = x.divide(pow(a.newInstance(10000), lr)); [EOL]     ix = x.floor().intValue(); [EOL]     while (ix > 2) { [EOL]         ix >>= 1; [EOL]         p2++; [EOL]     } [EOL]     Dfp[] spx = split(x); [EOL]     Dfp[] spy = new Dfp[2]; [EOL]     spy[0] = pow(a.getTwo(), p2); [EOL]     spx[0] = spx[0].divide(spy[0]); [EOL]     spx[1] = spx[1].divide(spy[0]); [EOL]     spy[0] = a.newInstance("1.33333"); [EOL]     while (spx[0].add(spx[1]).greaterThan(spy[0])) { [EOL]         spx[0] = spx[0].divide(2); [EOL]         spx[1] = spx[1].divide(2); [EOL]         p2++; [EOL]     } [EOL]     Dfp[] spz = logInternal(spx); [EOL]     spx[0] = a.newInstance(new StringBuilder().append(p2 + 4 * lr).toString()); [EOL]     spx[1] = a.getZero(); [EOL]     spy = splitMult(a.getField().getLn2Split(), spx); [EOL]     spz[0] = spz[0].add(spy[0]); [EOL]     spz[1] = spz[1].add(spy[1]); [EOL]     spx[0] = a.newInstance(new StringBuilder().append(4 * lr).toString()); [EOL]     spx[1] = a.getZero(); [EOL]     spy = splitMult(a.getField().getLn5Split(), spx); [EOL]     spz[0] = spz[0].add(spy[0]); [EOL]     spz[1] = spz[1].add(spy[1]); [EOL]     return a.newInstance(spz[0].add(spz[1])); [EOL] } <line_num>: 317,378
protected static Dfp[] logInternal(final Dfp[] a) { [EOL]     Dfp t = a[0].divide(4).add(a[1].divide(4)); [EOL]     Dfp x = t.add(a[0].newInstance("-0.25")).divide(t.add(a[0].newInstance("0.25"))); [EOL]     Dfp y = new Dfp(x); [EOL]     Dfp num = new Dfp(x); [EOL]     Dfp py = new Dfp(y); [EOL]     int den = 1; [EOL]     for (int i = 0; i < 10000; i++) { [EOL]         num = num.multiply(x); [EOL]         num = num.multiply(x); [EOL]         den = den + 2; [EOL]         t = num.divide(den); [EOL]         y = y.add(t); [EOL]         if (y.equals(py)) { [EOL]             break; [EOL]         } [EOL]         py = new Dfp(y); [EOL]     } [EOL]     y = y.multiply(a[0].getTwo()); [EOL]     return split(y); [EOL] } <line_num>: 435,463
public static Dfp pow(Dfp x, final Dfp y) { [EOL]     if (x.getField().getRadixDigits() != y.getField().getRadixDigits()) { [EOL]         x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID); [EOL]         final Dfp result = x.newInstance(x.getZero()); [EOL]         result.nans = Dfp.QNAN; [EOL]         return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, result); [EOL]     } [EOL]     final Dfp zero = x.getZero(); [EOL]     final Dfp one = x.getOne(); [EOL]     final Dfp two = x.getTwo(); [EOL]     boolean invert = false; [EOL]     int ui; [EOL]     if (y.equals(zero)) { [EOL]         return x.newInstance(one); [EOL]     } [EOL]     if (y.equals(one)) { [EOL]         if (x.isNaN()) { [EOL]             x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID); [EOL]             return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x); [EOL]         } [EOL]         return x; [EOL]     } [EOL]     if (x.isNaN() || y.isNaN()) { [EOL]         x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID); [EOL]         return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte) 1, Dfp.QNAN)); [EOL]     } [EOL]     if (x.equals(zero)) { [EOL]         if (Dfp.copysign(one, x).greaterThan(zero)) { [EOL]             if (y.greaterThan(zero)) { [EOL]                 return x.newInstance(zero); [EOL]             } else { [EOL]                 return x.newInstance(x.newInstance((byte) 1, Dfp.INFINITE)); [EOL]             } [EOL]         } else { [EOL]             if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) { [EOL]                 if (y.greaterThan(zero)) { [EOL]                     return x.newInstance(zero.negate()); [EOL]                 } else { [EOL]                     return x.newInstance(x.newInstance((byte) -1, Dfp.INFINITE)); [EOL]                 } [EOL]             } else { [EOL]                 if (y.greaterThan(zero)) { [EOL]                     return x.newInstance(zero); [EOL]                 } else { [EOL]                     return x.newInstance(x.newInstance((byte) 1, Dfp.INFINITE)); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (x.lessThan(zero)) { [EOL]         x = x.negate(); [EOL]         invert = true; [EOL]     } [EOL]     if (x.greaterThan(one) && y.classify() == Dfp.INFINITE) { [EOL]         if (y.greaterThan(zero)) { [EOL]             return y; [EOL]         } else { [EOL]             return x.newInstance(zero); [EOL]         } [EOL]     } [EOL]     if (x.lessThan(one) && y.classify() == Dfp.INFINITE) { [EOL]         if (y.greaterThan(zero)) { [EOL]             return x.newInstance(zero); [EOL]         } else { [EOL]             return x.newInstance(Dfp.copysign(y, one)); [EOL]         } [EOL]     } [EOL]     if (x.equals(one) && y.classify() == Dfp.INFINITE) { [EOL]         x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID); [EOL]         return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte) 1, Dfp.QNAN)); [EOL]     } [EOL]     if (x.classify() == Dfp.INFINITE) { [EOL]         if (invert) { [EOL]             if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) { [EOL]                 if (y.greaterThan(zero)) { [EOL]                     return x.newInstance(x.newInstance((byte) -1, Dfp.INFINITE)); [EOL]                 } else { [EOL]                     return x.newInstance(zero.negate()); [EOL]                 } [EOL]             } else { [EOL]                 if (y.greaterThan(zero)) { [EOL]                     return x.newInstance(x.newInstance((byte) 1, Dfp.INFINITE)); [EOL]                 } else { [EOL]                     return x.newInstance(zero); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (y.greaterThan(zero)) { [EOL]                 return x; [EOL]             } else { [EOL]                 return x.newInstance(zero); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (invert && !y.rint().equals(y)) { [EOL]         x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID); [EOL]         return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte) 1, Dfp.QNAN)); [EOL]     } [EOL]     Dfp r; [EOL]     if (y.lessThan(x.newInstance(100000000)) && y.greaterThan(x.newInstance(-100000000))) { [EOL]         final Dfp u = y.rint(); [EOL]         ui = u.intValue(); [EOL]         final Dfp v = y.subtract(u); [EOL]         if (v.unequal(zero)) { [EOL]             final Dfp a = v.multiply(log(x)); [EOL]             final Dfp b = a.divide(x.getField().getLn2()).rint(); [EOL]             final Dfp c = a.subtract(b.multiply(x.getField().getLn2())); [EOL]             r = splitPow(split(x), ui); [EOL]             r = r.multiply(pow(two, b.intValue())); [EOL]             r = r.multiply(exp(c)); [EOL]         } else { [EOL]             r = splitPow(split(x), ui); [EOL]         } [EOL]     } else { [EOL]         r = exp(log(x).multiply(y)); [EOL]     } [EOL]     if (invert && y.rint().equals(y) && !y.remainder(two).equals(zero)) { [EOL]         r = r.negate(); [EOL]     } [EOL]     return x.newInstance(r); [EOL] } <line_num>: 505,663
protected static Dfp sinInternal(Dfp[] a) { [EOL]     Dfp c = a[0].add(a[1]); [EOL]     Dfp y = c; [EOL]     c = c.multiply(c); [EOL]     Dfp x = y; [EOL]     Dfp fact = a[0].getOne(); [EOL]     Dfp py = new Dfp(y); [EOL]     for (int i = 3; i < 90; i += 2) { [EOL]         x = x.multiply(c); [EOL]         x = x.negate(); [EOL]         fact = fact.divide((i - 1) * i); [EOL]         y = y.add(x.multiply(fact)); [EOL]         if (y.equals(py)) { [EOL]             break; [EOL]         } [EOL]         py = new Dfp(y); [EOL]     } [EOL]     return y; [EOL] } <line_num>: 670,693
protected static Dfp cosInternal(Dfp[] a) { [EOL]     final Dfp one = a[0].getOne(); [EOL]     Dfp x = one; [EOL]     Dfp y = one; [EOL]     Dfp c = a[0].add(a[1]); [EOL]     c = c.multiply(c); [EOL]     Dfp fact = one; [EOL]     Dfp py = new Dfp(y); [EOL]     for (int i = 2; i < 90; i += 2) { [EOL]         x = x.multiply(c); [EOL]         x = x.negate(); [EOL]         fact = fact.divide((i - 1) * i); [EOL]         y = y.add(x.multiply(fact)); [EOL]         if (y.equals(py)) { [EOL]             break; [EOL]         } [EOL]         py = new Dfp(y); [EOL]     } [EOL]     return y; [EOL] } <line_num>: 700,727
public static Dfp sin(final Dfp a) { [EOL]     final Dfp pi = a.getField().getPi(); [EOL]     final Dfp zero = a.getField().getZero(); [EOL]     boolean neg = false; [EOL]     Dfp x = a.remainder(pi.multiply(2)); [EOL]     if (x.lessThan(zero)) { [EOL]         x = x.negate(); [EOL]         neg = true; [EOL]     } [EOL]     if (x.greaterThan(pi.divide(2))) { [EOL]         x = pi.subtract(x); [EOL]     } [EOL]     Dfp y; [EOL]     if (x.lessThan(pi.divide(4))) { [EOL]         Dfp[] c = new Dfp[2]; [EOL]         c[0] = x; [EOL]         c[1] = zero; [EOL]         y = sinInternal(split(x)); [EOL]     } else { [EOL]         final Dfp[] c = new Dfp[2]; [EOL]         final Dfp[] piSplit = a.getField().getPiSplit(); [EOL]         c[0] = piSplit[0].divide(2).subtract(x); [EOL]         c[1] = piSplit[1].divide(2); [EOL]         y = cosInternal(c); [EOL]     } [EOL]     if (neg) { [EOL]         y = y.negate(); [EOL]     } [EOL]     return a.newInstance(y); [EOL] } <line_num>: 733,778
public static Dfp cos(Dfp a) { [EOL]     final Dfp pi = a.getField().getPi(); [EOL]     final Dfp zero = a.getField().getZero(); [EOL]     boolean neg = false; [EOL]     Dfp x = a.remainder(pi.multiply(2)); [EOL]     if (x.lessThan(zero)) { [EOL]         x = x.negate(); [EOL]     } [EOL]     if (x.greaterThan(pi.divide(2))) { [EOL]         x = pi.subtract(x); [EOL]         neg = true; [EOL]     } [EOL]     Dfp y; [EOL]     if (x.lessThan(pi.divide(4))) { [EOL]         Dfp[] c = new Dfp[2]; [EOL]         c[0] = x; [EOL]         c[1] = zero; [EOL]         y = cosInternal(c); [EOL]     } else { [EOL]         final Dfp[] c = new Dfp[2]; [EOL]         final Dfp[] piSplit = a.getField().getPiSplit(); [EOL]         c[0] = piSplit[0].divide(2).subtract(x); [EOL]         c[1] = piSplit[1].divide(2); [EOL]         y = sinInternal(c); [EOL]     } [EOL]     if (neg) { [EOL]         y = y.negate(); [EOL]     } [EOL]     return a.newInstance(y); [EOL] } <line_num>: 784,828
public static Dfp tan(final Dfp a) { [EOL]     return sin(a).divide(cos(a)); [EOL] } <line_num>: 834,836
protected static Dfp atanInternal(final Dfp a) { [EOL]     Dfp y = new Dfp(a); [EOL]     Dfp x = new Dfp(y); [EOL]     Dfp py = new Dfp(y); [EOL]     for (int i = 3; i < 90; i += 2) { [EOL]         x = x.multiply(a); [EOL]         x = x.multiply(a); [EOL]         x = x.negate(); [EOL]         y = y.add(x.divide(i)); [EOL]         if (y.equals(py)) { [EOL]             break; [EOL]         } [EOL]         py = new Dfp(y); [EOL]     } [EOL]     return y; [EOL] } <line_num>: 842,861
public static Dfp atan(final Dfp a) { [EOL]     final Dfp zero = a.getField().getZero(); [EOL]     final Dfp one = a.getField().getOne(); [EOL]     final Dfp[] sqr2Split = a.getField().getSqr2Split(); [EOL]     final Dfp[] piSplit = a.getField().getPiSplit(); [EOL]     boolean recp = false; [EOL]     boolean neg = false; [EOL]     boolean sub = false; [EOL]     final Dfp ty = sqr2Split[0].subtract(one).add(sqr2Split[1]); [EOL]     Dfp x = new Dfp(a); [EOL]     if (x.lessThan(zero)) { [EOL]         neg = true; [EOL]         x = x.negate(); [EOL]     } [EOL]     if (x.greaterThan(one)) { [EOL]         recp = true; [EOL]         x = one.divide(x); [EOL]     } [EOL]     if (x.greaterThan(ty)) { [EOL]         Dfp[] sty = new Dfp[2]; [EOL]         sub = true; [EOL]         sty[0] = sqr2Split[0].subtract(one); [EOL]         sty[1] = sqr2Split[1]; [EOL]         Dfp[] xs = split(x); [EOL]         Dfp[] ds = splitMult(xs, sty); [EOL]         ds[0] = ds[0].add(one); [EOL]         xs[0] = xs[0].subtract(sty[0]); [EOL]         xs[1] = xs[1].subtract(sty[1]); [EOL]         xs = splitDiv(xs, ds); [EOL]         x = xs[0].add(xs[1]); [EOL]     } [EOL]     Dfp y = atanInternal(x); [EOL]     if (sub) { [EOL]         y = y.add(piSplit[0].divide(8)).add(piSplit[1].divide(8)); [EOL]     } [EOL]     if (recp) { [EOL]         y = piSplit[0].divide(2).subtract(y).add(piSplit[1].divide(2)); [EOL]     } [EOL]     if (neg) { [EOL]         y = y.negate(); [EOL]     } [EOL]     return a.newInstance(y); [EOL] } <line_num>: 876,935
public static Dfp asin(final Dfp a) { [EOL]     return atan(a.divide(a.getOne().subtract(a.multiply(a)).sqrt())); [EOL] } <line_num>: 941,943
public static Dfp acos(Dfp a) { [EOL]     Dfp result; [EOL]     boolean negative = false; [EOL]     if (a.lessThan(a.getZero())) { [EOL]         negative = true; [EOL]     } [EOL]     a = Dfp.copysign(a, a.getOne()); [EOL]     result = atan(a.getOne().subtract(a.multiply(a)).sqrt().divide(a)); [EOL]     if (negative) { [EOL]         result = a.getField().getPi().subtract(result); [EOL]     } [EOL]     return a.newInstance(result); [EOL] } <line_num>: 949,966
