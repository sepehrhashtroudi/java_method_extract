private FastMath() { [EOL] } <line_num>: 359,359
CodyWaite(double xa) { [EOL]     int k = (int) (xa * 0.6366197723675814); [EOL]     double remA; [EOL]     double remB; [EOL]     while (true) { [EOL]         double a = -k * 1.570796251296997; [EOL]         remA = xa + a; [EOL]         remB = -(remA - xa - a); [EOL]         a = -k * 7.549789948768648E-8; [EOL]         double b = remA; [EOL]         remA = a + b; [EOL]         remB += -(remA - b - a); [EOL]         a = -k * 6.123233995736766E-17; [EOL]         b = remA; [EOL]         remA = a + b; [EOL]         remB += -(remA - b - a); [EOL]         if (remA > 0) { [EOL]             break; [EOL]         } [EOL]         --k; [EOL]     } [EOL]     this.finalK = k; [EOL]     this.finalRemA = remA; [EOL]     this.finalRemB = remB; [EOL] } <line_num>: 3825,3861
private static double doubleHighPart(double d) { [EOL]     if (d > -Precision.SAFE_MIN && d < Precision.SAFE_MIN) { [EOL]         return d; [EOL]     } [EOL]     long xl = Double.doubleToRawLongBits(d); [EOL]     xl = xl & MASK_30BITS; [EOL]     return Double.longBitsToDouble(xl); [EOL] } <line_num>: 370,377
public static double sqrt(final double a) { [EOL]     return Math.sqrt(a); [EOL] } <line_num>: 384,386
public static double cosh(double x) { [EOL]     if (x != x) { [EOL]         return x; [EOL]     } [EOL]     if (x > 20) { [EOL]         if (x >= LOG_MAX_VALUE) { [EOL]             final double t = exp(0.5 * x); [EOL]             return (0.5 * t) * t; [EOL]         } else { [EOL]             return 0.5 * exp(x); [EOL]         } [EOL]     } else if (x < -20) { [EOL]         if (x <= -LOG_MAX_VALUE) { [EOL]             final double t = exp(-0.5 * x); [EOL]             return (0.5 * t) * t; [EOL]         } else { [EOL]             return 0.5 * exp(-x); [EOL]         } [EOL]     } [EOL]     final double[] hiPrec = new double[2]; [EOL]     if (x < 0.0) { [EOL]         x = -x; [EOL]     } [EOL]     exp(x, 0.0, hiPrec); [EOL]     double ya = hiPrec[0] + hiPrec[1]; [EOL]     double yb = -(ya - hiPrec[0] - hiPrec[1]); [EOL]     double temp = ya * HEX_40000000; [EOL]     double yaa = ya + temp - temp; [EOL]     double yab = ya - yaa; [EOL]     double recip = 1.0 / ya; [EOL]     temp = recip * HEX_40000000; [EOL]     double recipa = recip + temp - temp; [EOL]     double recipb = recip - recipa; [EOL]     recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip; [EOL]     recipb += -yb * recip * recip; [EOL]     temp = ya + recipa; [EOL]     yb += -(temp - ya - recipa); [EOL]     ya = temp; [EOL]     temp = ya + recipb; [EOL]     yb += -(temp - ya - recipb); [EOL]     ya = temp; [EOL]     double result = ya + yb; [EOL]     result *= 0.5; [EOL]     return result; [EOL] } <line_num>: 392,455
public static double sinh(double x) { [EOL]     boolean negate = false; [EOL]     if (x != x) { [EOL]         return x; [EOL]     } [EOL]     if (x > 20) { [EOL]         if (x >= LOG_MAX_VALUE) { [EOL]             final double t = exp(0.5 * x); [EOL]             return (0.5 * t) * t; [EOL]         } else { [EOL]             return 0.5 * exp(x); [EOL]         } [EOL]     } else if (x < -20) { [EOL]         if (x <= -LOG_MAX_VALUE) { [EOL]             final double t = exp(-0.5 * x); [EOL]             return (-0.5 * t) * t; [EOL]         } else { [EOL]             return -0.5 * exp(-x); [EOL]         } [EOL]     } [EOL]     if (x == 0) { [EOL]         return x; [EOL]     } [EOL]     if (x < 0.0) { [EOL]         x = -x; [EOL]         negate = true; [EOL]     } [EOL]     double result; [EOL]     if (x > 0.25) { [EOL]         double[] hiPrec = new double[2]; [EOL]         exp(x, 0.0, hiPrec); [EOL]         double ya = hiPrec[0] + hiPrec[1]; [EOL]         double yb = -(ya - hiPrec[0] - hiPrec[1]); [EOL]         double temp = ya * HEX_40000000; [EOL]         double yaa = ya + temp - temp; [EOL]         double yab = ya - yaa; [EOL]         double recip = 1.0 / ya; [EOL]         temp = recip * HEX_40000000; [EOL]         double recipa = recip + temp - temp; [EOL]         double recipb = recip - recipa; [EOL]         recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip; [EOL]         recipb += -yb * recip * recip; [EOL]         recipa = -recipa; [EOL]         recipb = -recipb; [EOL]         temp = ya + recipa; [EOL]         yb += -(temp - ya - recipa); [EOL]         ya = temp; [EOL]         temp = ya + recipb; [EOL]         yb += -(temp - ya - recipb); [EOL]         ya = temp; [EOL]         result = ya + yb; [EOL]         result *= 0.5; [EOL]     } else { [EOL]         double[] hiPrec = new double[2]; [EOL]         expm1(x, hiPrec); [EOL]         double ya = hiPrec[0] + hiPrec[1]; [EOL]         double yb = -(ya - hiPrec[0] - hiPrec[1]); [EOL]         double denom = 1.0 + ya; [EOL]         double denomr = 1.0 / denom; [EOL]         double denomb = -(denom - 1.0 - ya) + yb; [EOL]         double ratio = ya * denomr; [EOL]         double temp = ratio * HEX_40000000; [EOL]         double ra = ratio + temp - temp; [EOL]         double rb = ratio - ra; [EOL]         temp = denom * HEX_40000000; [EOL]         double za = denom + temp - temp; [EOL]         double zb = denom - za; [EOL]         rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr; [EOL]         rb += yb * denomr; [EOL]         rb += -ya * denomb * denomr * denomr; [EOL]         temp = ya + ra; [EOL]         yb += -(temp - ya - ra); [EOL]         ya = temp; [EOL]         temp = ya + rb; [EOL]         yb += -(temp - ya - rb); [EOL]         ya = temp; [EOL]         result = ya + yb; [EOL]         result *= 0.5; [EOL]     } [EOL]     if (negate) { [EOL]         result = -result; [EOL]     } [EOL]     return result; [EOL] } <line_num>: 461,580
public static double tanh(double x) { [EOL]     boolean negate = false; [EOL]     if (x != x) { [EOL]         return x; [EOL]     } [EOL]     if (x > 20.0) { [EOL]         return 1.0; [EOL]     } [EOL]     if (x < -20) { [EOL]         return -1.0; [EOL]     } [EOL]     if (x == 0) { [EOL]         return x; [EOL]     } [EOL]     if (x < 0.0) { [EOL]         x = -x; [EOL]         negate = true; [EOL]     } [EOL]     double result; [EOL]     if (x >= 0.5) { [EOL]         double[] hiPrec = new double[2]; [EOL]         exp(x * 2.0, 0.0, hiPrec); [EOL]         double ya = hiPrec[0] + hiPrec[1]; [EOL]         double yb = -(ya - hiPrec[0] - hiPrec[1]); [EOL]         double na = -1.0 + ya; [EOL]         double nb = -(na + 1.0 - ya); [EOL]         double temp = na + yb; [EOL]         nb += -(temp - na - yb); [EOL]         na = temp; [EOL]         double da = 1.0 + ya; [EOL]         double db = -(da - 1.0 - ya); [EOL]         temp = da + yb; [EOL]         db += -(temp - da - yb); [EOL]         da = temp; [EOL]         temp = da * HEX_40000000; [EOL]         double daa = da + temp - temp; [EOL]         double dab = da - daa; [EOL]         double ratio = na / da; [EOL]         temp = ratio * HEX_40000000; [EOL]         double ratioa = ratio + temp - temp; [EOL]         double ratiob = ratio - ratioa; [EOL]         ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da; [EOL]         ratiob += nb / da; [EOL]         ratiob += -db * na / da / da; [EOL]         result = ratioa + ratiob; [EOL]     } else { [EOL]         double[] hiPrec = new double[2]; [EOL]         expm1(x * 2.0, hiPrec); [EOL]         double ya = hiPrec[0] + hiPrec[1]; [EOL]         double yb = -(ya - hiPrec[0] - hiPrec[1]); [EOL]         double na = ya; [EOL]         double nb = yb; [EOL]         double da = 2.0 + ya; [EOL]         double db = -(da - 2.0 - ya); [EOL]         double temp = da + yb; [EOL]         db += -(temp - da - yb); [EOL]         da = temp; [EOL]         temp = da * HEX_40000000; [EOL]         double daa = da + temp - temp; [EOL]         double dab = da - daa; [EOL]         double ratio = na / da; [EOL]         temp = ratio * HEX_40000000; [EOL]         double ratioa = ratio + temp - temp; [EOL]         double ratiob = ratio - ratioa; [EOL]         ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da; [EOL]         ratiob += nb / da; [EOL]         ratiob += -db * na / da / da; [EOL]         result = ratioa + ratiob; [EOL]     } [EOL]     if (negate) { [EOL]         result = -result; [EOL]     } [EOL]     return result; [EOL] } <line_num>: 586,704
public static double acosh(final double a) { [EOL]     return FastMath.log(a + FastMath.sqrt(a * a - 1)); [EOL] } <line_num>: 710,712
public static double asinh(double a) { [EOL]     boolean negative = false; [EOL]     if (a < 0) { [EOL]         negative = true; [EOL]         a = -a; [EOL]     } [EOL]     double absAsinh; [EOL]     if (a > 0.167) { [EOL]         absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a); [EOL]     } else { [EOL]         final double a2 = a * a; [EOL]         if (a > 0.097) { [EOL]             absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2); [EOL]         } else if (a > 0.036) { [EOL]             absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2); [EOL]         } else if (a > 0.0036) { [EOL]             absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2); [EOL]         } else { [EOL]             absAsinh = a * (1 - a2 * (F_1_3 - a2 * F_1_5 * F_3_4) * F_1_2); [EOL]         } [EOL]     } [EOL]     return negative ? -absAsinh : absAsinh; [EOL] } <line_num>: 718,742
public static double atanh(double a) { [EOL]     boolean negative = false; [EOL]     if (a < 0) { [EOL]         negative = true; [EOL]         a = -a; [EOL]     } [EOL]     double absAtanh; [EOL]     if (a > 0.15) { [EOL]         absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a)); [EOL]     } else { [EOL]         final double a2 = a * a; [EOL]         if (a > 0.087) { [EOL]             absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17)))))))); [EOL]         } else if (a > 0.031) { [EOL]             absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13)))))); [EOL]         } else if (a > 0.003) { [EOL]             absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9)))); [EOL]         } else { [EOL]             absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5)); [EOL]         } [EOL]     } [EOL]     return negative ? -absAtanh : absAtanh; [EOL] } <line_num>: 748,772
public static double signum(final double a) { [EOL]     return (a < 0.0) ? -1.0 : ((a > 0.0) ? 1.0 : a); [EOL] } <line_num>: 779,781
public static float signum(final float a) { [EOL]     return (a < 0.0f) ? -1.0f : ((a > 0.0f) ? 1.0f : a); [EOL] } <line_num>: 788,790
public static double nextUp(final double a) { [EOL]     return nextAfter(a, Double.POSITIVE_INFINITY); [EOL] } <line_num>: 796,798
public static float nextUp(final float a) { [EOL]     return nextAfter(a, Float.POSITIVE_INFINITY); [EOL] } <line_num>: 804,806
public static double random() { [EOL]     return Math.random(); [EOL] } <line_num>: 812,814
public static double exp(double x) { [EOL]     return exp(x, 0.0, null); [EOL] } <line_num>: 836,838
private static double exp(double x, double extra, double[] hiPrec) { [EOL]     double intPartA; [EOL]     double intPartB; [EOL]     int intVal; [EOL]     if (x < 0.0) { [EOL]         intVal = (int) -x; [EOL]         if (intVal > 746) { [EOL]             if (hiPrec != null) { [EOL]                 hiPrec[0] = 0.0; [EOL]                 hiPrec[1] = 0.0; [EOL]             } [EOL]             return 0.0; [EOL]         } [EOL]         if (intVal > 709) { [EOL]             final double result = exp(x + 40.19140625, extra, hiPrec) / 285040095144011776.0; [EOL]             if (hiPrec != null) { [EOL]                 hiPrec[0] /= 285040095144011776.0; [EOL]                 hiPrec[1] /= 285040095144011776.0; [EOL]             } [EOL]             return result; [EOL]         } [EOL]         if (intVal == 709) { [EOL]             final double result = exp(x + 1.494140625, extra, hiPrec) / 4.455505956692756620; [EOL]             if (hiPrec != null) { [EOL]                 hiPrec[0] /= 4.455505956692756620; [EOL]                 hiPrec[1] /= 4.455505956692756620; [EOL]             } [EOL]             return result; [EOL]         } [EOL]         intVal++; [EOL]         intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX - intVal]; [EOL]         intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX - intVal]; [EOL]         intVal = -intVal; [EOL]     } else { [EOL]         intVal = (int) x; [EOL]         if (intVal > 709) { [EOL]             if (hiPrec != null) { [EOL]                 hiPrec[0] = Double.POSITIVE_INFINITY; [EOL]                 hiPrec[1] = 0.0; [EOL]             } [EOL]             return Double.POSITIVE_INFINITY; [EOL]         } [EOL]         intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX + intVal]; [EOL]         intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX + intVal]; [EOL]     } [EOL]     final int intFrac = (int) ((x - intVal) * 1024.0); [EOL]     final double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac]; [EOL]     final double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac]; [EOL]     final double epsilon = x - (intVal + intFrac / 1024.0); [EOL]     double z = 0.04168701738764507; [EOL]     z = z * epsilon + 0.1666666505023083; [EOL]     z = z * epsilon + 0.5000000000042687; [EOL]     z = z * epsilon + 1.0; [EOL]     z = z * epsilon + -3.940510424527919E-20; [EOL]     double tempA = intPartA * fracPartA; [EOL]     double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB; [EOL]     final double tempC = tempB + tempA; [EOL]     final double result; [EOL]     if (extra != 0.0) { [EOL]         result = tempC * extra * z + tempC * extra + tempC * z + tempB + tempA; [EOL]     } else { [EOL]         result = tempC * z + tempB + tempA; [EOL]     } [EOL]     if (hiPrec != null) { [EOL]         hiPrec[0] = tempA; [EOL]         hiPrec[1] = tempC * extra * z + tempC * extra + tempC * z + tempB; [EOL]     } [EOL]     return result; [EOL] } <line_num>: 847,962
public static double expm1(double x) { [EOL]     return expm1(x, null); [EOL] } <line_num>: 968,970
private static double expm1(double x, double[] hiPrecOut) { [EOL]     if (x != x || x == 0.0) { [EOL]         return x; [EOL]     } [EOL]     if (x <= -1.0 || x >= 1.0) { [EOL]         double[] hiPrec = new double[2]; [EOL]         exp(x, 0.0, hiPrec); [EOL]         if (x > 0.0) { [EOL]             return -1.0 + hiPrec[0] + hiPrec[1]; [EOL]         } else { [EOL]             final double ra = -1.0 + hiPrec[0]; [EOL]             double rb = -(ra + 1.0 - hiPrec[0]); [EOL]             rb += hiPrec[1]; [EOL]             return ra + rb; [EOL]         } [EOL]     } [EOL]     double baseA; [EOL]     double baseB; [EOL]     double epsilon; [EOL]     boolean negative = false; [EOL]     if (x < 0.0) { [EOL]         x = -x; [EOL]         negative = true; [EOL]     } [EOL]     { [EOL]         int intFrac = (int) (x * 1024.0); [EOL]         double tempA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac] - 1.0; [EOL]         double tempB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac]; [EOL]         double temp = tempA + tempB; [EOL]         tempB = -(temp - tempA - tempB); [EOL]         tempA = temp; [EOL]         temp = tempA * HEX_40000000; [EOL]         baseA = tempA + temp - temp; [EOL]         baseB = tempB + (tempA - baseA); [EOL]         epsilon = x - intFrac / 1024.0; [EOL]     } [EOL]     double zb = 0.008336750013465571; [EOL]     zb = zb * epsilon + 0.041666663879186654; [EOL]     zb = zb * epsilon + 0.16666666666745392; [EOL]     zb = zb * epsilon + 0.49999999999999994; [EOL]     zb = zb * epsilon; [EOL]     zb = zb * epsilon; [EOL]     double za = epsilon; [EOL]     double temp = za + zb; [EOL]     zb = -(temp - za - zb); [EOL]     za = temp; [EOL]     temp = za * HEX_40000000; [EOL]     temp = za + temp - temp; [EOL]     zb += za - temp; [EOL]     za = temp; [EOL]     double ya = za * baseA; [EOL]     temp = ya + za * baseB; [EOL]     double yb = -(temp - ya - za * baseB); [EOL]     ya = temp; [EOL]     temp = ya + zb * baseA; [EOL]     yb += -(temp - ya - zb * baseA); [EOL]     ya = temp; [EOL]     temp = ya + zb * baseB; [EOL]     yb += -(temp - ya - zb * baseB); [EOL]     ya = temp; [EOL]     temp = ya + baseA; [EOL]     yb += -(temp - baseA - ya); [EOL]     ya = temp; [EOL]     temp = ya + za; [EOL]     yb += -(temp - ya - za); [EOL]     ya = temp; [EOL]     temp = ya + baseB; [EOL]     yb += -(temp - ya - baseB); [EOL]     ya = temp; [EOL]     temp = ya + zb; [EOL]     yb += -(temp - ya - zb); [EOL]     ya = temp; [EOL]     if (negative) { [EOL]         double denom = 1.0 + ya; [EOL]         double denomr = 1.0 / denom; [EOL]         double denomb = -(denom - 1.0 - ya) + yb; [EOL]         double ratio = ya * denomr; [EOL]         temp = ratio * HEX_40000000; [EOL]         final double ra = ratio + temp - temp; [EOL]         double rb = ratio - ra; [EOL]         temp = denom * HEX_40000000; [EOL]         za = denom + temp - temp; [EOL]         zb = denom - za; [EOL]         rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr; [EOL]         rb += yb * denomr; [EOL]         rb += -ya * denomb * denomr * denomr; [EOL]         ya = -ra; [EOL]         yb = -rb; [EOL]     } [EOL]     if (hiPrecOut != null) { [EOL]         hiPrecOut[0] = ya; [EOL]         hiPrecOut[1] = yb; [EOL]     } [EOL]     return ya + yb; [EOL] } <line_num>: 977,1117
public static double log(final double x) { [EOL]     return log(x, null); [EOL] } <line_num>: 1125,1127
private static double log(final double x, final double[] hiPrec) { [EOL]     if (x == 0) { [EOL]         return Double.NEGATIVE_INFINITY; [EOL]     } [EOL]     long bits = Double.doubleToRawLongBits(x); [EOL]     if (((bits & 0x8000000000000000L) != 0 || x != x) && x != 0.0) { [EOL]         if (hiPrec != null) { [EOL]             hiPrec[0] = Double.NaN; [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     if (x == Double.POSITIVE_INFINITY) { [EOL]         if (hiPrec != null) { [EOL]             hiPrec[0] = Double.POSITIVE_INFINITY; [EOL]         } [EOL]         return Double.POSITIVE_INFINITY; [EOL]     } [EOL]     int exp = (int) (bits >> 52) - 1023; [EOL]     if ((bits & 0x7ff0000000000000L) == 0) { [EOL]         if (x == 0) { [EOL]             if (hiPrec != null) { [EOL]                 hiPrec[0] = Double.NEGATIVE_INFINITY; [EOL]             } [EOL]             return Double.NEGATIVE_INFINITY; [EOL]         } [EOL]         bits <<= 1; [EOL]         while ((bits & 0x0010000000000000L) == 0) { [EOL]             --exp; [EOL]             bits <<= 1; [EOL]         } [EOL]     } [EOL]     if ((exp == -1 || exp == 0) && x < 1.01 && x > 0.99 && hiPrec == null) { [EOL]         double xa = x - 1.0; [EOL]         double xb = xa - x + 1.0; [EOL]         double tmp = xa * HEX_40000000; [EOL]         double aa = xa + tmp - tmp; [EOL]         double ab = xa - aa; [EOL]         xa = aa; [EOL]         xb = ab; [EOL]         final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1]; [EOL]         double ya = lnCoef_last[0]; [EOL]         double yb = lnCoef_last[1]; [EOL]         for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) { [EOL]             aa = ya * xa; [EOL]             ab = ya * xb + yb * xa + yb * xb; [EOL]             tmp = aa * HEX_40000000; [EOL]             ya = aa + tmp - tmp; [EOL]             yb = aa - ya + ab; [EOL]             final double[] lnCoef_i = LN_QUICK_COEF[i]; [EOL]             aa = ya + lnCoef_i[0]; [EOL]             ab = yb + lnCoef_i[1]; [EOL]             tmp = aa * HEX_40000000; [EOL]             ya = aa + tmp - tmp; [EOL]             yb = aa - ya + ab; [EOL]         } [EOL]         aa = ya * xa; [EOL]         ab = ya * xb + yb * xa + yb * xb; [EOL]         tmp = aa * HEX_40000000; [EOL]         ya = aa + tmp - tmp; [EOL]         yb = aa - ya + ab; [EOL]         return ya + yb; [EOL]     } [EOL]     final double[] lnm = lnMant.LN_MANT[(int) ((bits & 0x000ffc0000000000L) >> 42)]; [EOL]     final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L)); [EOL]     double lnza = 0.0; [EOL]     double lnzb = 0.0; [EOL]     if (hiPrec != null) { [EOL]         double tmp = epsilon * HEX_40000000; [EOL]         double aa = epsilon + tmp - tmp; [EOL]         double ab = epsilon - aa; [EOL]         double xa = aa; [EOL]         double xb = ab; [EOL]         final double numer = bits & 0x3ffffffffffL; [EOL]         final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L); [EOL]         aa = numer - xa * denom - xb * denom; [EOL]         xb += aa / denom; [EOL]         final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length - 1]; [EOL]         double ya = lnCoef_last[0]; [EOL]         double yb = lnCoef_last[1]; [EOL]         for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) { [EOL]             aa = ya * xa; [EOL]             ab = ya * xb + yb * xa + yb * xb; [EOL]             tmp = aa * HEX_40000000; [EOL]             ya = aa + tmp - tmp; [EOL]             yb = aa - ya + ab; [EOL]             final double[] lnCoef_i = LN_HI_PREC_COEF[i]; [EOL]             aa = ya + lnCoef_i[0]; [EOL]             ab = yb + lnCoef_i[1]; [EOL]             tmp = aa * HEX_40000000; [EOL]             ya = aa + tmp - tmp; [EOL]             yb = aa - ya + ab; [EOL]         } [EOL]         aa = ya * xa; [EOL]         ab = ya * xb + yb * xa + yb * xb; [EOL]         lnza = aa + ab; [EOL]         lnzb = -(lnza - aa - ab); [EOL]     } else { [EOL]         lnza = -0.16624882440418567; [EOL]         lnza = lnza * epsilon + 0.19999954120254515; [EOL]         lnza = lnza * epsilon + -0.2499999997677497; [EOL]         lnza = lnza * epsilon + 0.3333333333332802; [EOL]         lnza = lnza * epsilon + -0.5; [EOL]         lnza = lnza * epsilon + 1.0; [EOL]         lnza = lnza * epsilon; [EOL]     } [EOL]     double a = LN_2_A * exp; [EOL]     double b = 0.0; [EOL]     double c = a + lnm[0]; [EOL]     double d = -(c - a - lnm[0]); [EOL]     a = c; [EOL]     b = b + d; [EOL]     c = a + lnza; [EOL]     d = -(c - a - lnza); [EOL]     a = c; [EOL]     b = b + d; [EOL]     c = a + LN_2_B * exp; [EOL]     d = -(c - a - LN_2_B * exp); [EOL]     a = c; [EOL]     b = b + d; [EOL]     c = a + lnm[1]; [EOL]     d = -(c - a - lnm[1]); [EOL]     a = c; [EOL]     b = b + d; [EOL]     c = a + lnzb; [EOL]     d = -(c - a - lnzb); [EOL]     a = c; [EOL]     b = b + d; [EOL]     if (hiPrec != null) { [EOL]         hiPrec[0] = a; [EOL]         hiPrec[1] = b; [EOL]     } [EOL]     return a + b; [EOL] } <line_num>: 1135,1355
public static double log1p(final double x) { [EOL]     if (x == -1) { [EOL]         return Double.NEGATIVE_INFINITY; [EOL]     } [EOL]     if (x == Double.POSITIVE_INFINITY) { [EOL]         return Double.POSITIVE_INFINITY; [EOL]     } [EOL]     if (x > 1e-6 || x < -1e-6) { [EOL]         final double xpa = 1 + x; [EOL]         final double xpb = -(xpa - 1 - x); [EOL]         final double[] hiPrec = new double[2]; [EOL]         final double lores = log(xpa, hiPrec); [EOL]         if (Double.isInfinite(lores)) { [EOL]             return lores; [EOL]         } [EOL]         final double fx1 = xpb / xpa; [EOL]         final double epsilon = 0.5 * fx1 + 1; [EOL]         return epsilon * fx1 + hiPrec[1] + hiPrec[0]; [EOL]     } else { [EOL]         final double y = (x * F_1_3 - F_1_2) * x + 1; [EOL]         return y * x; [EOL]     } [EOL] } <line_num>: 1363,1393
public static double log10(final double x) { [EOL]     final double[] hiPrec = new double[2]; [EOL]     final double lores = log(x, hiPrec); [EOL]     if (Double.isInfinite(lores)) { [EOL]         return lores; [EOL]     } [EOL]     final double tmp = hiPrec[0] * HEX_40000000; [EOL]     final double lna = hiPrec[0] + tmp - tmp; [EOL]     final double lnb = hiPrec[0] - lna + hiPrec[1]; [EOL]     final double rln10a = 0.4342944622039795; [EOL]     final double rln10b = 1.9699272335463627E-8; [EOL]     return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna; [EOL] } <line_num>: 1399,1415
public static double log(double base, double x) { [EOL]     return log(x) / log(base); [EOL] } <line_num>: 1433,1435
public static double pow(double x, double y) { [EOL]     final double[] lns = new double[2]; [EOL]     if (y == 0.0) { [EOL]         return 1.0; [EOL]     } [EOL]     if (x != x) { [EOL]         return x; [EOL]     } [EOL]     if (x == 0) { [EOL]         long bits = Double.doubleToRawLongBits(x); [EOL]         if ((bits & 0x8000000000000000L) != 0) { [EOL]             long yi = (long) y; [EOL]             if (y < 0 && y == yi && (yi & 1) == 1) { [EOL]                 return Double.NEGATIVE_INFINITY; [EOL]             } [EOL]             if (y > 0 && y == yi && (yi & 1) == 1) { [EOL]                 return -0.0; [EOL]             } [EOL]         } [EOL]         if (y < 0) { [EOL]             return Double.POSITIVE_INFINITY; [EOL]         } [EOL]         if (y > 0) { [EOL]             return 0.0; [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     if (x == Double.POSITIVE_INFINITY) { [EOL]         if (y != y) { [EOL]             return y; [EOL]         } [EOL]         if (y < 0.0) { [EOL]             return 0.0; [EOL]         } else { [EOL]             return Double.POSITIVE_INFINITY; [EOL]         } [EOL]     } [EOL]     if (y == Double.POSITIVE_INFINITY) { [EOL]         if (x * x == 1.0) { [EOL]             return Double.NaN; [EOL]         } [EOL]         if (x * x > 1.0) { [EOL]             return Double.POSITIVE_INFINITY; [EOL]         } else { [EOL]             return 0.0; [EOL]         } [EOL]     } [EOL]     if (x == Double.NEGATIVE_INFINITY) { [EOL]         if (y != y) { [EOL]             return y; [EOL]         } [EOL]         if (y < 0) { [EOL]             long yi = (long) y; [EOL]             if (y == yi && (yi & 1) == 1) { [EOL]                 return -0.0; [EOL]             } [EOL]             return 0.0; [EOL]         } [EOL]         if (y > 0) { [EOL]             long yi = (long) y; [EOL]             if (y == yi && (yi & 1) == 1) { [EOL]                 return Double.NEGATIVE_INFINITY; [EOL]             } [EOL]             return Double.POSITIVE_INFINITY; [EOL]         } [EOL]     } [EOL]     if (y == Double.NEGATIVE_INFINITY) { [EOL]         if (x * x == 1.0) { [EOL]             return Double.NaN; [EOL]         } [EOL]         if (x * x < 1.0) { [EOL]             return Double.POSITIVE_INFINITY; [EOL]         } else { [EOL]             return 0.0; [EOL]         } [EOL]     } [EOL]     if (x < 0) { [EOL]         if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) { [EOL]             return pow(-x, y); [EOL]         } [EOL]         if (y == (long) y) { [EOL]             return ((long) y & 1) == 0 ? pow(-x, y) : -pow(-x, y); [EOL]         } else { [EOL]             return Double.NaN; [EOL]         } [EOL]     } [EOL]     double ya; [EOL]     double yb; [EOL]     if (y < 8e298 && y > -8e298) { [EOL]         double tmp1 = y * HEX_40000000; [EOL]         ya = y + tmp1 - tmp1; [EOL]         yb = y - ya; [EOL]     } else { [EOL]         double tmp1 = y * 9.31322574615478515625E-10; [EOL]         double tmp2 = tmp1 * 9.31322574615478515625E-10; [EOL]         ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000; [EOL]         yb = y - ya; [EOL]     } [EOL]     final double lores = log(x, lns); [EOL]     if (Double.isInfinite(lores)) { [EOL]         return lores; [EOL]     } [EOL]     double lna = lns[0]; [EOL]     double lnb = lns[1]; [EOL]     double tmp1 = lna * HEX_40000000; [EOL]     double tmp2 = lna + tmp1 - tmp1; [EOL]     lnb += lna - tmp2; [EOL]     lna = tmp2; [EOL]     final double aa = lna * ya; [EOL]     final double ab = lna * yb + lnb * ya + lnb * yb; [EOL]     lna = aa + ab; [EOL]     lnb = -(lna - aa - ab); [EOL]     double z = 1.0 / 120.0; [EOL]     z = z * lnb + (1.0 / 24.0); [EOL]     z = z * lnb + (1.0 / 6.0); [EOL]     z = z * lnb + 0.5; [EOL]     z = z * lnb + 1.0; [EOL]     z = z * lnb; [EOL]     final double result = exp(lna, z, null); [EOL]     return result; [EOL] } <line_num>: 1444,1602
public static double pow(double d, int e) { [EOL]     if (e == 0) { [EOL]         return 1.0; [EOL]     } else if (e < 0) { [EOL]         e = -e; [EOL]         d = 1.0 / d; [EOL]     } [EOL]     final int splitFactor = 0x8000001; [EOL]     final double cd = splitFactor * d; [EOL]     final double d1High = cd - (cd - d); [EOL]     final double d1Low = d - d1High; [EOL]     double resultHigh = 1; [EOL]     double resultLow = 0; [EOL]     double d2p = d; [EOL]     double d2pHigh = d1High; [EOL]     double d2pLow = d1Low; [EOL]     while (e != 0) { [EOL]         if ((e & 0x1) != 0) { [EOL]             final double tmpHigh = resultHigh * d2p; [EOL]             final double cRH = splitFactor * resultHigh; [EOL]             final double rHH = cRH - (cRH - resultHigh); [EOL]             final double rHL = resultHigh - rHH; [EOL]             final double tmpLow = rHL * d2pLow - (((tmpHigh - rHH * d2pHigh) - rHL * d2pHigh) - rHH * d2pLow); [EOL]             resultHigh = tmpHigh; [EOL]             resultLow = resultLow * d2p + tmpLow; [EOL]         } [EOL]         final double tmpHigh = d2pHigh * d2p; [EOL]         final double cD2pH = splitFactor * d2pHigh; [EOL]         final double d2pHH = cD2pH - (cD2pH - d2pHigh); [EOL]         final double d2pHL = d2pHigh - d2pHH; [EOL]         final double tmpLow = d2pHL * d2pLow - (((tmpHigh - d2pHH * d2pHigh) - d2pHL * d2pHigh) - d2pHH * d2pLow); [EOL]         final double cTmpH = splitFactor * tmpHigh; [EOL]         d2pHigh = cTmpH - (cTmpH - tmpHigh); [EOL]         d2pLow = d2pLow * d2p + tmpLow + (tmpHigh - d2pHigh); [EOL]         d2p = d2pHigh + d2pLow; [EOL]         e = e >> 1; [EOL]     } [EOL]     return resultHigh + resultLow; [EOL] } <line_num>: 1613,1670
private static double polySine(final double x) { [EOL]     double x2 = x * x; [EOL]     double p = 2.7553817452272217E-6; [EOL]     p = p * x2 + -1.9841269659586505E-4; [EOL]     p = p * x2 + 0.008333333333329196; [EOL]     p = p * x2 + -0.16666666666666666; [EOL]     p = p * x2 * x; [EOL]     return p; [EOL] } <line_num>: 1678,1691
private static double polyCosine(double x) { [EOL]     double x2 = x * x; [EOL]     double p = 2.479773539153719E-5; [EOL]     p = p * x2 + -0.0013888888689039883; [EOL]     p = p * x2 + 0.041666666666621166; [EOL]     p = p * x2 + -0.49999999999999994; [EOL]     p *= x2; [EOL]     return p; [EOL] } <line_num>: 1699,1709
private static double sinQ(double xa, double xb) { [EOL]     int idx = (int) ((xa * 8.0) + 0.5); [EOL]     final double epsilon = xa - EIGHTHS[idx]; [EOL]     final double sintA = SINE_TABLE_A[idx]; [EOL]     final double sintB = SINE_TABLE_B[idx]; [EOL]     final double costA = COSINE_TABLE_A[idx]; [EOL]     final double costB = COSINE_TABLE_B[idx]; [EOL]     double sinEpsA = epsilon; [EOL]     double sinEpsB = polySine(epsilon); [EOL]     final double cosEpsA = 1.0; [EOL]     final double cosEpsB = polyCosine(epsilon); [EOL]     final double temp = sinEpsA * HEX_40000000; [EOL]     double temp2 = (sinEpsA + temp) - temp; [EOL]     sinEpsB += sinEpsA - temp2; [EOL]     sinEpsA = temp2; [EOL]     double result; [EOL]     double a = 0; [EOL]     double b = 0; [EOL]     double t = sintA; [EOL]     double c = a + t; [EOL]     double d = -(c - a - t); [EOL]     a = c; [EOL]     b = b + d; [EOL]     t = costA * sinEpsA; [EOL]     c = a + t; [EOL]     d = -(c - a - t); [EOL]     a = c; [EOL]     b = b + d; [EOL]     b = b + sintA * cosEpsB + costA * sinEpsB; [EOL]     b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB; [EOL]     if (xb != 0.0) { [EOL]         t = ((costA + costB) * (cosEpsA + cosEpsB) - (sintA + sintB) * (sinEpsA + sinEpsB)) * xb; [EOL]         c = a + t; [EOL]         d = -(c - a - t); [EOL]         a = c; [EOL]         b = b + d; [EOL]     } [EOL]     result = a + b; [EOL]     return result; [EOL] } <line_num>: 1718,1833
private static double cosQ(double xa, double xb) { [EOL]     final double pi2a = 1.5707963267948966; [EOL]     final double pi2b = 6.123233995736766E-17; [EOL]     final double a = pi2a - xa; [EOL]     double b = -(a - pi2a + xa); [EOL]     b += pi2b - xb; [EOL]     return sinQ(a, b); [EOL] } <line_num>: 1842,1851
private static double tanQ(double xa, double xb, boolean cotanFlag) { [EOL]     int idx = (int) ((xa * 8.0) + 0.5); [EOL]     final double epsilon = xa - EIGHTHS[idx]; [EOL]     final double sintA = SINE_TABLE_A[idx]; [EOL]     final double sintB = SINE_TABLE_B[idx]; [EOL]     final double costA = COSINE_TABLE_A[idx]; [EOL]     final double costB = COSINE_TABLE_B[idx]; [EOL]     double sinEpsA = epsilon; [EOL]     double sinEpsB = polySine(epsilon); [EOL]     final double cosEpsA = 1.0; [EOL]     final double cosEpsB = polyCosine(epsilon); [EOL]     double temp = sinEpsA * HEX_40000000; [EOL]     double temp2 = (sinEpsA + temp) - temp; [EOL]     sinEpsB += sinEpsA - temp2; [EOL]     sinEpsA = temp2; [EOL]     double a = 0; [EOL]     double b = 0; [EOL]     double t = sintA; [EOL]     double c = a + t; [EOL]     double d = -(c - a - t); [EOL]     a = c; [EOL]     b = b + d; [EOL]     t = costA * sinEpsA; [EOL]     c = a + t; [EOL]     d = -(c - a - t); [EOL]     a = c; [EOL]     b = b + d; [EOL]     b = b + sintA * cosEpsB + costA * sinEpsB; [EOL]     b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB; [EOL]     double sina = a + b; [EOL]     double sinb = -(sina - a - b); [EOL]     a = b = c = d = 0.0; [EOL]     t = costA * cosEpsA; [EOL]     c = a + t; [EOL]     d = -(c - a - t); [EOL]     a = c; [EOL]     b = b + d; [EOL]     t = -sintA * sinEpsA; [EOL]     c = a + t; [EOL]     d = -(c - a - t); [EOL]     a = c; [EOL]     b = b + d; [EOL]     b = b + costB * cosEpsA + costA * cosEpsB + costB * cosEpsB; [EOL]     b = b - (sintB * sinEpsA + sintA * sinEpsB + sintB * sinEpsB); [EOL]     double cosa = a + b; [EOL]     double cosb = -(cosa - a - b); [EOL]     if (cotanFlag) { [EOL]         double tmp; [EOL]         tmp = cosa; [EOL]         cosa = sina; [EOL]         sina = tmp; [EOL]         tmp = cosb; [EOL]         cosb = sinb; [EOL]         sinb = tmp; [EOL]     } [EOL]     double est = sina / cosa; [EOL]     temp = est * HEX_40000000; [EOL]     double esta = (est + temp) - temp; [EOL]     double estb = est - esta; [EOL]     temp = cosa * HEX_40000000; [EOL]     double cosaa = (cosa + temp) - temp; [EOL]     double cosab = cosa - cosaa; [EOL]     double err = (sina - esta * cosaa - esta * cosab - estb * cosaa - estb * cosab) / cosa; [EOL]     err += sinb / cosa; [EOL]     err += -sina * cosb / cosa / cosa; [EOL]     if (xb != 0.0) { [EOL]         double xbadj = xb + est * est * xb; [EOL]         if (cotanFlag) { [EOL]             xbadj = -xbadj; [EOL]         } [EOL]         err += xbadj; [EOL]     } [EOL]     return est + err; [EOL] } <line_num>: 1861,1996
private static void reducePayneHanek(double x, double[] result) { [EOL]     long inbits = Double.doubleToRawLongBits(x); [EOL]     int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; [EOL]     inbits &= 0x000fffffffffffffL; [EOL]     inbits |= 0x0010000000000000L; [EOL]     exponent++; [EOL]     inbits <<= 11; [EOL]     long shpi0; [EOL]     long shpiA; [EOL]     long shpiB; [EOL]     int idx = exponent >> 6; [EOL]     int shift = exponent - (idx << 6); [EOL]     if (shift != 0) { [EOL]         shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx - 1] << shift); [EOL]         shpi0 |= RECIP_2PI[idx] >>> (64 - shift); [EOL]         shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx + 1] >>> (64 - shift)); [EOL]         shpiB = (RECIP_2PI[idx + 1] << shift) | (RECIP_2PI[idx + 2] >>> (64 - shift)); [EOL]     } else { [EOL]         shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx - 1]; [EOL]         shpiA = RECIP_2PI[idx]; [EOL]         shpiB = RECIP_2PI[idx + 1]; [EOL]     } [EOL]     long a = inbits >>> 32; [EOL]     long b = inbits & 0xffffffffL; [EOL]     long c = shpiA >>> 32; [EOL]     long d = shpiA & 0xffffffffL; [EOL]     long ac = a * c; [EOL]     long bd = b * d; [EOL]     long bc = b * c; [EOL]     long ad = a * d; [EOL]     long prodB = bd + (ad << 32); [EOL]     long prodA = ac + (ad >>> 32); [EOL]     boolean bita = (bd & 0x8000000000000000L) != 0; [EOL]     boolean bitb = (ad & 0x80000000L) != 0; [EOL]     boolean bitsum = (prodB & 0x8000000000000000L) != 0; [EOL]     if ((bita && bitb) || ((bita || bitb) && !bitsum)) { [EOL]         prodA++; [EOL]     } [EOL]     bita = (prodB & 0x8000000000000000L) != 0; [EOL]     bitb = (bc & 0x80000000L) != 0; [EOL]     prodB = prodB + (bc << 32); [EOL]     prodA = prodA + (bc >>> 32); [EOL]     bitsum = (prodB & 0x8000000000000000L) != 0; [EOL]     if ((bita && bitb) || ((bita || bitb) && !bitsum)) { [EOL]         prodA++; [EOL]     } [EOL]     c = shpiB >>> 32; [EOL]     d = shpiB & 0xffffffffL; [EOL]     ac = a * c; [EOL]     bc = b * c; [EOL]     ad = a * d; [EOL]     ac = ac + ((bc + ad) >>> 32); [EOL]     bita = (prodB & 0x8000000000000000L) != 0; [EOL]     bitb = (ac & 0x8000000000000000L) != 0; [EOL]     prodB += ac; [EOL]     bitsum = (prodB & 0x8000000000000000L) != 0; [EOL]     if ((bita && bitb) || ((bita || bitb) && !bitsum)) { [EOL]         prodA++; [EOL]     } [EOL]     c = shpi0 >>> 32; [EOL]     d = shpi0 & 0xffffffffL; [EOL]     bd = b * d; [EOL]     bc = b * c; [EOL]     ad = a * d; [EOL]     prodA += bd + ((bc + ad) << 32); [EOL]     int intPart = (int) (prodA >>> 62); [EOL]     prodA <<= 2; [EOL]     prodA |= prodB >>> 62; [EOL]     prodB <<= 2; [EOL]     a = prodA >>> 32; [EOL]     b = prodA & 0xffffffffL; [EOL]     c = PI_O_4_BITS[0] >>> 32; [EOL]     d = PI_O_4_BITS[0] & 0xffffffffL; [EOL]     ac = a * c; [EOL]     bd = b * d; [EOL]     bc = b * c; [EOL]     ad = a * d; [EOL]     long prod2B = bd + (ad << 32); [EOL]     long prod2A = ac + (ad >>> 32); [EOL]     bita = (bd & 0x8000000000000000L) != 0; [EOL]     bitb = (ad & 0x80000000L) != 0; [EOL]     bitsum = (prod2B & 0x8000000000000000L) != 0; [EOL]     if ((bita && bitb) || ((bita || bitb) && !bitsum)) { [EOL]         prod2A++; [EOL]     } [EOL]     bita = (prod2B & 0x8000000000000000L) != 0; [EOL]     bitb = (bc & 0x80000000L) != 0; [EOL]     prod2B = prod2B + (bc << 32); [EOL]     prod2A = prod2A + (bc >>> 32); [EOL]     bitsum = (prod2B & 0x8000000000000000L) != 0; [EOL]     if ((bita && bitb) || ((bita || bitb) && !bitsum)) { [EOL]         prod2A++; [EOL]     } [EOL]     c = PI_O_4_BITS[1] >>> 32; [EOL]     d = PI_O_4_BITS[1] & 0xffffffffL; [EOL]     ac = a * c; [EOL]     bc = b * c; [EOL]     ad = a * d; [EOL]     ac = ac + ((bc + ad) >>> 32); [EOL]     bita = (prod2B & 0x8000000000000000L) != 0; [EOL]     bitb = (ac & 0x8000000000000000L) != 0; [EOL]     prod2B += ac; [EOL]     bitsum = (prod2B & 0x8000000000000000L) != 0; [EOL]     if ((bita && bitb) || ((bita || bitb) && !bitsum)) { [EOL]         prod2A++; [EOL]     } [EOL]     a = prodB >>> 32; [EOL]     b = prodB & 0xffffffffL; [EOL]     c = PI_O_4_BITS[0] >>> 32; [EOL]     d = PI_O_4_BITS[0] & 0xffffffffL; [EOL]     ac = a * c; [EOL]     bc = b * c; [EOL]     ad = a * d; [EOL]     ac = ac + ((bc + ad) >>> 32); [EOL]     bita = (prod2B & 0x8000000000000000L) != 0; [EOL]     bitb = (ac & 0x8000000000000000L) != 0; [EOL]     prod2B += ac; [EOL]     bitsum = (prod2B & 0x8000000000000000L) != 0; [EOL]     if ((bita && bitb) || ((bita || bitb) && !bitsum)) { [EOL]         prod2A++; [EOL]     } [EOL]     double tmpA = (prod2A >>> 12) / TWO_POWER_52; [EOL]     double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; [EOL]     double sumA = tmpA + tmpB; [EOL]     double sumB = -(sumA - tmpA - tmpB); [EOL]     result[0] = intPart; [EOL]     result[1] = sumA * 2.0; [EOL]     result[2] = sumB * 2.0; [EOL] } <line_num>: 2009,2219
public static double sin(double x) { [EOL]     boolean negative = false; [EOL]     int quadrant = 0; [EOL]     double xa; [EOL]     double xb = 0.0; [EOL]     xa = x; [EOL]     if (x < 0) { [EOL]         negative = true; [EOL]         xa = -xa; [EOL]     } [EOL]     if (xa == 0.0) { [EOL]         long bits = Double.doubleToRawLongBits(x); [EOL]         if (bits < 0) { [EOL]             return -0.0; [EOL]         } [EOL]         return 0.0; [EOL]     } [EOL]     if (xa != xa || xa == Double.POSITIVE_INFINITY) { [EOL]         return Double.NaN; [EOL]     } [EOL]     if (xa > 3294198.0) { [EOL]         double[] reduceResults = new double[3]; [EOL]         reducePayneHanek(xa, reduceResults); [EOL]         quadrant = ((int) reduceResults[0]) & 3; [EOL]         xa = reduceResults[1]; [EOL]         xb = reduceResults[2]; [EOL]     } else if (xa > 1.5707963267948966) { [EOL]         final CodyWaite cw = new CodyWaite(xa); [EOL]         quadrant = cw.getK() & 3; [EOL]         xa = cw.getRemA(); [EOL]         xb = cw.getRemB(); [EOL]     } [EOL]     if (negative) { [EOL]         quadrant ^= 2; [EOL]     } [EOL]     switch(quadrant) { [EOL]         case 0: [EOL]             return sinQ(xa, xb); [EOL]         case 1: [EOL]             return cosQ(xa, xb); [EOL]         case 2: [EOL]             return -sinQ(xa, xb); [EOL]         case 3: [EOL]             return -cosQ(xa, xb); [EOL]         default: [EOL]             return Double.NaN; [EOL]     } [EOL] } <line_num>: 2227,2286
public static double cos(double x) { [EOL]     int quadrant = 0; [EOL]     double xa = x; [EOL]     if (x < 0) { [EOL]         xa = -xa; [EOL]     } [EOL]     if (xa != xa || xa == Double.POSITIVE_INFINITY) { [EOL]         return Double.NaN; [EOL]     } [EOL]     double xb = 0; [EOL]     if (xa > 3294198.0) { [EOL]         double[] reduceResults = new double[3]; [EOL]         reducePayneHanek(xa, reduceResults); [EOL]         quadrant = ((int) reduceResults[0]) & 3; [EOL]         xa = reduceResults[1]; [EOL]         xb = reduceResults[2]; [EOL]     } else if (xa > 1.5707963267948966) { [EOL]         final CodyWaite cw = new CodyWaite(xa); [EOL]         quadrant = cw.getK() & 3; [EOL]         xa = cw.getRemA(); [EOL]         xb = cw.getRemB(); [EOL]     } [EOL]     switch(quadrant) { [EOL]         case 0: [EOL]             return cosQ(xa, xb); [EOL]         case 1: [EOL]             return -sinQ(xa, xb); [EOL]         case 2: [EOL]             return -cosQ(xa, xb); [EOL]         case 3: [EOL]             return sinQ(xa, xb); [EOL]         default: [EOL]             return Double.NaN; [EOL]     } [EOL] } <line_num>: 2294,2340
public static double tan(double x) { [EOL]     boolean negative = false; [EOL]     int quadrant = 0; [EOL]     double xa = x; [EOL]     if (x < 0) { [EOL]         negative = true; [EOL]         xa = -xa; [EOL]     } [EOL]     if (xa == 0.0) { [EOL]         long bits = Double.doubleToRawLongBits(x); [EOL]         if (bits < 0) { [EOL]             return -0.0; [EOL]         } [EOL]         return 0.0; [EOL]     } [EOL]     if (xa != xa || xa == Double.POSITIVE_INFINITY) { [EOL]         return Double.NaN; [EOL]     } [EOL]     double xb = 0; [EOL]     if (xa > 3294198.0) { [EOL]         double[] reduceResults = new double[3]; [EOL]         reducePayneHanek(xa, reduceResults); [EOL]         quadrant = ((int) reduceResults[0]) & 3; [EOL]         xa = reduceResults[1]; [EOL]         xb = reduceResults[2]; [EOL]     } else if (xa > 1.5707963267948966) { [EOL]         final CodyWaite cw = new CodyWaite(xa); [EOL]         quadrant = cw.getK() & 3; [EOL]         xa = cw.getRemA(); [EOL]         xb = cw.getRemB(); [EOL]     } [EOL]     if (xa > 1.5) { [EOL]         final double pi2a = 1.5707963267948966; [EOL]         final double pi2b = 6.123233995736766E-17; [EOL]         final double a = pi2a - xa; [EOL]         double b = -(a - pi2a + xa); [EOL]         b += pi2b - xb; [EOL]         xa = a + b; [EOL]         xb = -(xa - a - b); [EOL]         quadrant ^= 1; [EOL]         negative ^= true; [EOL]     } [EOL]     double result; [EOL]     if ((quadrant & 1) == 0) { [EOL]         result = tanQ(xa, xb, false); [EOL]     } else { [EOL]         result = -tanQ(xa, xb, true); [EOL]     } [EOL]     if (negative) { [EOL]         result = -result; [EOL]     } [EOL]     return result; [EOL] } <line_num>: 2348,2417
public static double atan(double x) { [EOL]     return atan(x, 0.0, false); [EOL] } <line_num>: 2424,2426
private static double atan(double xa, double xb, boolean leftPlane) { [EOL]     boolean negate = false; [EOL]     int idx; [EOL]     if (xa == 0.0) { [EOL]         return leftPlane ? copySign(Math.PI, xa) : xa; [EOL]     } [EOL]     if (xa < 0) { [EOL]         xa = -xa; [EOL]         xb = -xb; [EOL]         negate = true; [EOL]     } [EOL]     if (xa > 1.633123935319537E16) { [EOL]         return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2); [EOL]     } [EOL]     if (xa < 1) { [EOL]         idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5); [EOL]     } else { [EOL]         final double oneOverXa = 1 / xa; [EOL]         idx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07); [EOL]     } [EOL]     double epsA = xa - TANGENT_TABLE_A[idx]; [EOL]     double epsB = -(epsA - xa + TANGENT_TABLE_A[idx]); [EOL]     epsB += xb - TANGENT_TABLE_B[idx]; [EOL]     double temp = epsA + epsB; [EOL]     epsB = -(temp - epsA - epsB); [EOL]     epsA = temp; [EOL]     temp = xa * HEX_40000000; [EOL]     double ya = xa + temp - temp; [EOL]     double yb = xb + xa - ya; [EOL]     xa = ya; [EOL]     xb += yb; [EOL]     if (idx == 0) { [EOL]         final double denom = 1d / (1d + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx])); [EOL]         ya = epsA * denom; [EOL]         yb = epsB * denom; [EOL]     } else { [EOL]         double temp2 = xa * TANGENT_TABLE_A[idx]; [EOL]         double za = 1d + temp2; [EOL]         double zb = -(za - 1d - temp2); [EOL]         temp2 = xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx]; [EOL]         temp = za + temp2; [EOL]         zb += -(temp - za - temp2); [EOL]         za = temp; [EOL]         zb += xb * TANGENT_TABLE_B[idx]; [EOL]         ya = epsA / za; [EOL]         temp = ya * HEX_40000000; [EOL]         final double yaa = (ya + temp) - temp; [EOL]         final double yab = ya - yaa; [EOL]         temp = za * HEX_40000000; [EOL]         final double zaa = (za + temp) - temp; [EOL]         final double zab = za - zaa; [EOL]         yb = (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za; [EOL]         yb += -epsA * zb / za / za; [EOL]         yb += epsB / za; [EOL]     } [EOL]     epsA = ya; [EOL]     epsB = yb; [EOL]     final double epsA2 = epsA * epsA; [EOL]     yb = 0.07490822288864472; [EOL]     yb = yb * epsA2 + -0.09088450866185192; [EOL]     yb = yb * epsA2 + 0.11111095942313305; [EOL]     yb = yb * epsA2 + -0.1428571423679182; [EOL]     yb = yb * epsA2 + 0.19999999999923582; [EOL]     yb = yb * epsA2 + -0.33333333333333287; [EOL]     yb = yb * epsA2 * epsA; [EOL]     ya = epsA; [EOL]     temp = ya + yb; [EOL]     yb = -(temp - ya - yb); [EOL]     ya = temp; [EOL]     yb += epsB / (1d + epsA * epsA); [EOL]     double za = EIGHTHS[idx] + ya; [EOL]     double zb = -(za - EIGHTHS[idx] - ya); [EOL]     temp = za + yb; [EOL]     zb += -(temp - za - yb); [EOL]     za = temp; [EOL]     double result = za + zb; [EOL]     if (leftPlane) { [EOL]         final double resultb = -(result - za - zb); [EOL]         final double pia = 1.5707963267948966 * 2; [EOL]         final double pib = 6.123233995736766E-17 * 2; [EOL]         za = pia - result; [EOL]         zb = -(za - pia + result); [EOL]         zb += pib - resultb; [EOL]         result = za + zb; [EOL]     } [EOL]     if (negate ^ leftPlane) { [EOL]         result = -result; [EOL]     } [EOL]     return result; [EOL] } <line_num>: 2434,2572
public static double atan2(double y, double x) { [EOL]     if (x != x || y != y) { [EOL]         return Double.NaN; [EOL]     } [EOL]     if (y == 0) { [EOL]         final double result = x * y; [EOL]         final double invx = 1d / x; [EOL]         final double invy = 1d / y; [EOL]         if (invx == 0) { [EOL]             if (x > 0) { [EOL]                 return y; [EOL]             } else { [EOL]                 return copySign(Math.PI, y); [EOL]             } [EOL]         } [EOL]         if (x < 0 || invx < 0) { [EOL]             if (y < 0 || invy < 0) { [EOL]                 return -Math.PI; [EOL]             } else { [EOL]                 return Math.PI; [EOL]             } [EOL]         } else { [EOL]             return result; [EOL]         } [EOL]     } [EOL]     if (y == Double.POSITIVE_INFINITY) { [EOL]         if (x == Double.POSITIVE_INFINITY) { [EOL]             return Math.PI * F_1_4; [EOL]         } [EOL]         if (x == Double.NEGATIVE_INFINITY) { [EOL]             return Math.PI * F_3_4; [EOL]         } [EOL]         return Math.PI * F_1_2; [EOL]     } [EOL]     if (y == Double.NEGATIVE_INFINITY) { [EOL]         if (x == Double.POSITIVE_INFINITY) { [EOL]             return -Math.PI * F_1_4; [EOL]         } [EOL]         if (x == Double.NEGATIVE_INFINITY) { [EOL]             return -Math.PI * F_3_4; [EOL]         } [EOL]         return -Math.PI * F_1_2; [EOL]     } [EOL]     if (x == Double.POSITIVE_INFINITY) { [EOL]         if (y > 0 || 1 / y > 0) { [EOL]             return 0d; [EOL]         } [EOL]         if (y < 0 || 1 / y < 0) { [EOL]             return -0d; [EOL]         } [EOL]     } [EOL]     if (x == Double.NEGATIVE_INFINITY) { [EOL]         if (y > 0.0 || 1 / y > 0.0) { [EOL]             return Math.PI; [EOL]         } [EOL]         if (y < 0 || 1 / y < 0) { [EOL]             return -Math.PI; [EOL]         } [EOL]     } [EOL]     if (x == 0) { [EOL]         if (y > 0 || 1 / y > 0) { [EOL]             return Math.PI * F_1_2; [EOL]         } [EOL]         if (y < 0 || 1 / y < 0) { [EOL]             return -Math.PI * F_1_2; [EOL]         } [EOL]     } [EOL]     final double r = y / x; [EOL]     if (Double.isInfinite(r)) { [EOL]         return atan(r, 0, x < 0); [EOL]     } [EOL]     double ra = doubleHighPart(r); [EOL]     double rb = r - ra; [EOL]     final double xa = doubleHighPart(x); [EOL]     final double xb = x - xa; [EOL]     rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x; [EOL]     final double temp = ra + rb; [EOL]     rb = -(temp - ra - rb); [EOL]     ra = temp; [EOL]     if (ra == 0) { [EOL]         ra = copySign(0d, y); [EOL]     } [EOL]     final double result = atan(ra, rb, x < 0); [EOL]     return result; [EOL] } <line_num>: 2580,2695
public static double asin(double x) { [EOL]     if (x != x) { [EOL]         return Double.NaN; [EOL]     } [EOL]     if (x > 1.0 || x < -1.0) { [EOL]         return Double.NaN; [EOL]     } [EOL]     if (x == 1.0) { [EOL]         return Math.PI / 2.0; [EOL]     } [EOL]     if (x == -1.0) { [EOL]         return -Math.PI / 2.0; [EOL]     } [EOL]     if (x == 0.0) { [EOL]         return x; [EOL]     } [EOL]     double temp = x * HEX_40000000; [EOL]     final double xa = x + temp - temp; [EOL]     final double xb = x - xa; [EOL]     double ya = xa * xa; [EOL]     double yb = xa * xb * 2.0 + xb * xb; [EOL]     ya = -ya; [EOL]     yb = -yb; [EOL]     double za = 1.0 + ya; [EOL]     double zb = -(za - 1.0 - ya); [EOL]     temp = za + yb; [EOL]     zb += -(temp - za - yb); [EOL]     za = temp; [EOL]     double y; [EOL]     y = sqrt(za); [EOL]     temp = y * HEX_40000000; [EOL]     ya = y + temp - temp; [EOL]     yb = y - ya; [EOL]     yb += (za - ya * ya - 2 * ya * yb - yb * yb) / (2.0 * y); [EOL]     double dx = zb / (2.0 * y); [EOL]     double r = x / y; [EOL]     temp = r * HEX_40000000; [EOL]     double ra = r + temp - temp; [EOL]     double rb = r - ra; [EOL]     rb += (x - ra * ya - ra * yb - rb * ya - rb * yb) / y; [EOL]     rb += -x * dx / y / y; [EOL]     temp = ra + rb; [EOL]     rb = -(temp - ra - rb); [EOL]     ra = temp; [EOL]     return atan(ra, rb, false); [EOL] } <line_num>: 2701,2771
public static double acos(double x) { [EOL]     if (x != x) { [EOL]         return Double.NaN; [EOL]     } [EOL]     if (x > 1.0 || x < -1.0) { [EOL]         return Double.NaN; [EOL]     } [EOL]     if (x == -1.0) { [EOL]         return Math.PI; [EOL]     } [EOL]     if (x == 1.0) { [EOL]         return 0.0; [EOL]     } [EOL]     if (x == 0) { [EOL]         return Math.PI / 2.0; [EOL]     } [EOL]     double temp = x * HEX_40000000; [EOL]     final double xa = x + temp - temp; [EOL]     final double xb = x - xa; [EOL]     double ya = xa * xa; [EOL]     double yb = xa * xb * 2.0 + xb * xb; [EOL]     ya = -ya; [EOL]     yb = -yb; [EOL]     double za = 1.0 + ya; [EOL]     double zb = -(za - 1.0 - ya); [EOL]     temp = za + yb; [EOL]     zb += -(temp - za - yb); [EOL]     za = temp; [EOL]     double y = sqrt(za); [EOL]     temp = y * HEX_40000000; [EOL]     ya = y + temp - temp; [EOL]     yb = y - ya; [EOL]     yb += (za - ya * ya - 2 * ya * yb - yb * yb) / (2.0 * y); [EOL]     yb += zb / (2.0 * y); [EOL]     y = ya + yb; [EOL]     yb = -(y - ya - yb); [EOL]     double r = y / x; [EOL]     if (Double.isInfinite(r)) { [EOL]         return Math.PI / 2; [EOL]     } [EOL]     double ra = doubleHighPart(r); [EOL]     double rb = r - ra; [EOL]     rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x; [EOL]     rb += yb / x; [EOL]     temp = ra + rb; [EOL]     rb = -(temp - ra - rb); [EOL]     ra = temp; [EOL]     return atan(ra, rb, x < 0); [EOL] } <line_num>: 2777,2853
public static double cbrt(double x) { [EOL]     long inbits = Double.doubleToRawLongBits(x); [EOL]     int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; [EOL]     boolean subnormal = false; [EOL]     if (exponent == -1023) { [EOL]         if (x == 0) { [EOL]             return x; [EOL]         } [EOL]         subnormal = true; [EOL]         x *= 1.8014398509481984E16; [EOL]         inbits = Double.doubleToRawLongBits(x); [EOL]         exponent = (int) ((inbits >> 52) & 0x7ff) - 1023; [EOL]     } [EOL]     if (exponent == 1024) { [EOL]         return x; [EOL]     } [EOL]     int exp3 = exponent / 3; [EOL]     double p2 = Double.longBitsToDouble((inbits & 0x8000000000000000L) | (long) (((exp3 + 1023) & 0x7ff)) << 52); [EOL]     final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L); [EOL]     double est = -0.010714690733195933; [EOL]     est = est * mant + 0.0875862700108075; [EOL]     est = est * mant + -0.3058015757857271; [EOL]     est = est * mant + 0.7249995199969751; [EOL]     est = est * mant + 0.5039018405998233; [EOL]     est *= CBRTTWO[exponent % 3 + 2]; [EOL]     final double xs = x / (p2 * p2 * p2); [EOL]     est += (xs - est * est * est) / (3 * est * est); [EOL]     est += (xs - est * est * est) / (3 * est * est); [EOL]     double temp = est * HEX_40000000; [EOL]     double ya = est + temp - temp; [EOL]     double yb = est - ya; [EOL]     double za = ya * ya; [EOL]     double zb = ya * yb * 2.0 + yb * yb; [EOL]     temp = za * HEX_40000000; [EOL]     double temp2 = za + temp - temp; [EOL]     zb += za - temp2; [EOL]     za = temp2; [EOL]     zb = za * yb + ya * zb + zb * yb; [EOL]     za = za * ya; [EOL]     double na = xs - za; [EOL]     double nb = -(na - xs + za); [EOL]     nb -= zb; [EOL]     est += (na + nb) / (3 * est * est); [EOL]     est *= p2; [EOL]     if (subnormal) { [EOL]         est *= 3.814697265625E-6; [EOL]     } [EOL]     return est; [EOL] } <line_num>: 2859,2937
public static double toRadians(double x) { [EOL]     if (Double.isInfinite(x) || x == 0.0) { [EOL]         return x; [EOL]     } [EOL]     final double facta = 0.01745329052209854; [EOL]     final double factb = 1.997844754509471E-9; [EOL]     double xa = doubleHighPart(x); [EOL]     double xb = x - xa; [EOL]     double result = xb * factb + xb * facta + xa * factb + xa * facta; [EOL]     if (result == 0) { [EOL]         result = result * x; [EOL]     } [EOL]     return result; [EOL] } <line_num>: 2944,2962
public static double toDegrees(double x) { [EOL]     if (Double.isInfinite(x) || x == 0.0) { [EOL]         return x; [EOL]     } [EOL]     final double facta = 57.2957763671875; [EOL]     final double factb = 3.145894820876798E-6; [EOL]     double xa = doubleHighPart(x); [EOL]     double xb = x - xa; [EOL]     return xb * factb + xb * facta + xa * factb + xa * facta; [EOL] } <line_num>: 2969,2983
public static int abs(final int x) { [EOL]     final int i = x >>> 31; [EOL]     return (x ^ (~i + 1)) + i; [EOL] } <line_num>: 2990,2993
public static long abs(final long x) { [EOL]     final long l = x >>> 63; [EOL]     return (x ^ (~l + 1)) + l; [EOL] } <line_num>: 3000,3007
public static float abs(final float x) { [EOL]     return Float.intBitsToFloat(MASK_NON_SIGN_INT & Float.floatToRawIntBits(x)); [EOL] } <line_num>: 3014,3016
public static double abs(double x) { [EOL]     return Double.longBitsToDouble(MASK_NON_SIGN_LONG & Double.doubleToRawLongBits(x)); [EOL] } <line_num>: 3023,3025
public static double ulp(double x) { [EOL]     if (Double.isInfinite(x)) { [EOL]         return Double.POSITIVE_INFINITY; [EOL]     } [EOL]     return abs(x - Double.longBitsToDouble(Double.doubleToRawLongBits(x) ^ 1)); [EOL] } <line_num>: 3032,3037
public static float ulp(float x) { [EOL]     if (Float.isInfinite(x)) { [EOL]         return Float.POSITIVE_INFINITY; [EOL]     } [EOL]     return abs(x - Float.intBitsToFloat(Float.floatToIntBits(x) ^ 1)); [EOL] } <line_num>: 3044,3049
public static double scalb(final double d, final int n) { [EOL]     if ((n > -1023) && (n < 1024)) { [EOL]         return d * Double.longBitsToDouble(((long) (n + 1023)) << 52); [EOL]     } [EOL]     if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) { [EOL]         return d; [EOL]     } [EOL]     if (n < -2098) { [EOL]         return (d > 0) ? 0.0 : -0.0; [EOL]     } [EOL]     if (n > 2097) { [EOL]         return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; [EOL]     } [EOL]     final long bits = Double.doubleToRawLongBits(d); [EOL]     final long sign = bits & 0x8000000000000000L; [EOL]     int exponent = ((int) (bits >>> 52)) & 0x7ff; [EOL]     long mantissa = bits & 0x000fffffffffffffL; [EOL]     int scaledExponent = exponent + n; [EOL]     if (n < 0) { [EOL]         if (scaledExponent > 0) { [EOL]             return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); [EOL]         } else if (scaledExponent > -53) { [EOL]             mantissa = mantissa | (1L << 52); [EOL]             final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent)); [EOL]             mantissa = mantissa >>> (1 - scaledExponent); [EOL]             if (mostSignificantLostBit != 0) { [EOL]                 mantissa++; [EOL]             } [EOL]             return Double.longBitsToDouble(sign | mantissa); [EOL]         } else { [EOL]             return (sign == 0L) ? 0.0 : -0.0; [EOL]         } [EOL]     } else { [EOL]         if (exponent == 0) { [EOL]             while ((mantissa >>> 52) != 1) { [EOL]                 mantissa = mantissa << 1; [EOL]                 --scaledExponent; [EOL]             } [EOL]             ++scaledExponent; [EOL]             mantissa = mantissa & 0x000fffffffffffffL; [EOL]             if (scaledExponent < 2047) { [EOL]                 return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); [EOL]             } else { [EOL]                 return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; [EOL]             } [EOL]         } else if (scaledExponent < 2047) { [EOL]             return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa); [EOL]         } else { [EOL]             return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY; [EOL]         } [EOL]     } [EOL] } <line_num>: 3057,3133
public static float scalb(final float f, final int n) { [EOL]     if ((n > -127) && (n < 128)) { [EOL]         return f * Float.intBitsToFloat((n + 127) << 23); [EOL]     } [EOL]     if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) { [EOL]         return f; [EOL]     } [EOL]     if (n < -277) { [EOL]         return (f > 0) ? 0.0f : -0.0f; [EOL]     } [EOL]     if (n > 276) { [EOL]         return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; [EOL]     } [EOL]     final int bits = Float.floatToIntBits(f); [EOL]     final int sign = bits & 0x80000000; [EOL]     int exponent = (bits >>> 23) & 0xff; [EOL]     int mantissa = bits & 0x007fffff; [EOL]     int scaledExponent = exponent + n; [EOL]     if (n < 0) { [EOL]         if (scaledExponent > 0) { [EOL]             return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); [EOL]         } else if (scaledExponent > -24) { [EOL]             mantissa = mantissa | (1 << 23); [EOL]             final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent)); [EOL]             mantissa = mantissa >>> (1 - scaledExponent); [EOL]             if (mostSignificantLostBit != 0) { [EOL]                 mantissa++; [EOL]             } [EOL]             return Float.intBitsToFloat(sign | mantissa); [EOL]         } else { [EOL]             return (sign == 0) ? 0.0f : -0.0f; [EOL]         } [EOL]     } else { [EOL]         if (exponent == 0) { [EOL]             while ((mantissa >>> 23) != 1) { [EOL]                 mantissa = mantissa << 1; [EOL]                 --scaledExponent; [EOL]             } [EOL]             ++scaledExponent; [EOL]             mantissa = mantissa & 0x007fffff; [EOL]             if (scaledExponent < 255) { [EOL]                 return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); [EOL]             } else { [EOL]                 return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; [EOL]             } [EOL]         } else if (scaledExponent < 255) { [EOL]             return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa); [EOL]         } else { [EOL]             return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY; [EOL]         } [EOL]     } [EOL] } <line_num>: 3141,3217
public static double nextAfter(double d, double direction) { [EOL]     if (Double.isNaN(d) || Double.isNaN(direction)) { [EOL]         return Double.NaN; [EOL]     } else if (d == direction) { [EOL]         return direction; [EOL]     } else if (Double.isInfinite(d)) { [EOL]         return (d < 0) ? -Double.MAX_VALUE : Double.MAX_VALUE; [EOL]     } else if (d == 0) { [EOL]         return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE; [EOL]     } [EOL]     final long bits = Double.doubleToRawLongBits(d); [EOL]     final long sign = bits & 0x8000000000000000L; [EOL]     if ((direction < d) ^ (sign == 0L)) { [EOL]         return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1)); [EOL]     } else { [EOL]         return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) - 1)); [EOL]     } [EOL] } <line_num>: 3250,3273
public static float nextAfter(final float f, final double direction) { [EOL]     if (Double.isNaN(f) || Double.isNaN(direction)) { [EOL]         return Float.NaN; [EOL]     } else if (f == direction) { [EOL]         return (float) direction; [EOL]     } else if (Float.isInfinite(f)) { [EOL]         return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE; [EOL]     } else if (f == 0f) { [EOL]         return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE; [EOL]     } [EOL]     final int bits = Float.floatToIntBits(f); [EOL]     final int sign = bits & 0x80000000; [EOL]     if ((direction < f) ^ (sign == 0)) { [EOL]         return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1)); [EOL]     } else { [EOL]         return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) - 1)); [EOL]     } [EOL] } <line_num>: 3306,3329
public static double floor(double x) { [EOL]     long y; [EOL]     if (x != x) { [EOL]         return x; [EOL]     } [EOL]     if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) { [EOL]         return x; [EOL]     } [EOL]     y = (long) x; [EOL]     if (x < 0 && y != x) { [EOL]         y--; [EOL]     } [EOL]     if (y == 0) { [EOL]         return x * y; [EOL]     } [EOL]     return y; [EOL] } <line_num>: 3335,3356
public static double ceil(double x) { [EOL]     double y; [EOL]     if (x != x) { [EOL]         return x; [EOL]     } [EOL]     y = floor(x); [EOL]     if (y == x) { [EOL]         return y; [EOL]     } [EOL]     y += 1.0; [EOL]     if (y == 0) { [EOL]         return x * y; [EOL]     } [EOL]     return y; [EOL] } <line_num>: 3362,3381
public static double rint(double x) { [EOL]     double y = floor(x); [EOL]     double d = x - y; [EOL]     if (d > 0.5) { [EOL]         if (y == -1.0) { [EOL]             return -0.0; [EOL]         } [EOL]         return y + 1.0; [EOL]     } [EOL]     if (d < 0.5) { [EOL]         return y; [EOL]     } [EOL]     long z = (long) y; [EOL]     return (z & 1) == 0 ? y : y + 1.0; [EOL] } <line_num>: 3387,3404
public static long round(double x) { [EOL]     return (long) floor(x + 0.5); [EOL] } <line_num>: 3410,3412
public static int round(final float x) { [EOL]     return (int) floor(x + 0.5f); [EOL] } <line_num>: 3418,3420
public static int min(final int a, final int b) { [EOL]     return (a <= b) ? a : b; [EOL] } <line_num>: 3427,3429
public static long min(final long a, final long b) { [EOL]     return (a <= b) ? a : b; [EOL] } <line_num>: 3436,3438
public static float min(final float a, final float b) { [EOL]     if (a > b) { [EOL]         return b; [EOL]     } [EOL]     if (a < b) { [EOL]         return a; [EOL]     } [EOL]     if (a != b) { [EOL]         return Float.NaN; [EOL]     } [EOL]     int bits = Float.floatToRawIntBits(a); [EOL]     if (bits == 0x80000000) { [EOL]         return a; [EOL]     } [EOL]     return b; [EOL] } <line_num>: 3445,3463
public static double min(final double a, final double b) { [EOL]     if (a > b) { [EOL]         return b; [EOL]     } [EOL]     if (a < b) { [EOL]         return a; [EOL]     } [EOL]     if (a != b) { [EOL]         return Double.NaN; [EOL]     } [EOL]     long bits = Double.doubleToRawLongBits(a); [EOL]     if (bits == 0x8000000000000000L) { [EOL]         return a; [EOL]     } [EOL]     return b; [EOL] } <line_num>: 3470,3488
public static int max(final int a, final int b) { [EOL]     return (a <= b) ? b : a; [EOL] } <line_num>: 3495,3497
public static long max(final long a, final long b) { [EOL]     return (a <= b) ? b : a; [EOL] } <line_num>: 3504,3506
public static float max(final float a, final float b) { [EOL]     if (a > b) { [EOL]         return a; [EOL]     } [EOL]     if (a < b) { [EOL]         return b; [EOL]     } [EOL]     if (a != b) { [EOL]         return Float.NaN; [EOL]     } [EOL]     int bits = Float.floatToRawIntBits(a); [EOL]     if (bits == 0x80000000) { [EOL]         return b; [EOL]     } [EOL]     return a; [EOL] } <line_num>: 3513,3531
public static double max(final double a, final double b) { [EOL]     if (a > b) { [EOL]         return a; [EOL]     } [EOL]     if (a < b) { [EOL]         return b; [EOL]     } [EOL]     if (a != b) { [EOL]         return Double.NaN; [EOL]     } [EOL]     long bits = Double.doubleToRawLongBits(a); [EOL]     if (bits == 0x8000000000000000L) { [EOL]         return b; [EOL]     } [EOL]     return a; [EOL] } <line_num>: 3538,3556
public static double hypot(final double x, final double y) { [EOL]     if (Double.isInfinite(x) || Double.isInfinite(y)) { [EOL]         return Double.POSITIVE_INFINITY; [EOL]     } else if (Double.isNaN(x) || Double.isNaN(y)) { [EOL]         return Double.NaN; [EOL]     } else { [EOL]         final int expX = getExponent(x); [EOL]         final int expY = getExponent(y); [EOL]         if (expX > expY + 27) { [EOL]             return abs(x); [EOL]         } else if (expY > expX + 27) { [EOL]             return abs(y); [EOL]         } else { [EOL]             final int middleExp = (expX + expY) / 2; [EOL]             final double scaledX = scalb(x, -middleExp); [EOL]             final double scaledY = scalb(y, -middleExp); [EOL]             final double scaledH = sqrt(scaledX * scaledX + scaledY * scaledY); [EOL]             return scalb(scaledH, middleExp); [EOL]         } [EOL]     } [EOL] } <line_num>: 3572,3605
public static double IEEEremainder(double dividend, double divisor) { [EOL]     return StrictMath.IEEEremainder(dividend, divisor); [EOL] } <line_num>: 3627,3629
public static double copySign(double magnitude, double sign) { [EOL]     final long m = Double.doubleToRawLongBits(magnitude); [EOL]     final long s = Double.doubleToRawLongBits(sign); [EOL]     if ((m ^ s) >= 0) { [EOL]         return magnitude; [EOL]     } [EOL]     return -magnitude; [EOL] } <line_num>: 3639,3650
public static float copySign(float magnitude, float sign) { [EOL]     final int m = Float.floatToRawIntBits(magnitude); [EOL]     final int s = Float.floatToRawIntBits(sign); [EOL]     if ((m ^ s) >= 0) { [EOL]         return magnitude; [EOL]     } [EOL]     return -magnitude; [EOL] } <line_num>: 3660,3671
public static int getExponent(final double d) { [EOL]     return (int) ((Double.doubleToRawLongBits(d) >>> 52) & 0x7ff) - 1023; [EOL] } <line_num>: 3682,3685
public static int getExponent(final float f) { [EOL]     return ((Float.floatToRawIntBits(f) >>> 23) & 0xff) - 127; [EOL] } <line_num>: 3696,3699
public static void main(String[] a) { [EOL]     PrintStream out = System.out; [EOL]     FastMathCalc.printarray(out, "EXP_INT_TABLE_A", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_A); [EOL]     FastMathCalc.printarray(out, "EXP_INT_TABLE_B", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_B); [EOL]     FastMathCalc.printarray(out, "EXP_FRAC_TABLE_A", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_A); [EOL]     FastMathCalc.printarray(out, "EXP_FRAC_TABLE_B", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_B); [EOL]     FastMathCalc.printarray(out, "LN_MANT", LN_MANT_LEN, lnMant.LN_MANT); [EOL]     FastMathCalc.printarray(out, "SINE_TABLE_A", SINE_TABLE_LEN, SINE_TABLE_A); [EOL]     FastMathCalc.printarray(out, "SINE_TABLE_B", SINE_TABLE_LEN, SINE_TABLE_B); [EOL]     FastMathCalc.printarray(out, "COSINE_TABLE_A", SINE_TABLE_LEN, COSINE_TABLE_A); [EOL]     FastMathCalc.printarray(out, "COSINE_TABLE_B", SINE_TABLE_LEN, COSINE_TABLE_B); [EOL]     FastMathCalc.printarray(out, "TANGENT_TABLE_A", SINE_TABLE_LEN, TANGENT_TABLE_A); [EOL]     FastMathCalc.printarray(out, "TANGENT_TABLE_B", SINE_TABLE_LEN, TANGENT_TABLE_B); [EOL] } <line_num>: 3706,3719
int getK() { [EOL]     return finalK; [EOL] } <line_num>: 3866,3868
double getRemA() { [EOL]     return finalRemA; [EOL] } <line_num>: 3872,3874
double getRemB() { [EOL]     return finalRemB; [EOL] } <line_num>: 3878,3880
