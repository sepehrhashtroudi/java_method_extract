public OpenIntToDoubleHashMap() { [EOL]     this(DEFAULT_EXPECTED_SIZE, Double.NaN); [EOL] } <line_num>: 91,93
public OpenIntToDoubleHashMap(final double missingEntries) { [EOL]     this(DEFAULT_EXPECTED_SIZE, missingEntries); [EOL] } <line_num>: 99,101
public OpenIntToDoubleHashMap(final int expectedSize) { [EOL]     this(expectedSize, Double.NaN); [EOL] } <line_num>: 107,109
public OpenIntToDoubleHashMap(final int expectedSize, final double missingEntries) { [EOL]     final int capacity = computeCapacity(expectedSize); [EOL]     keys = new int[capacity]; [EOL]     values = new double[capacity]; [EOL]     states = new byte[capacity]; [EOL]     this.missingEntries = missingEntries; [EOL]     mask = capacity - 1; [EOL] } <line_num>: 116,124
public OpenIntToDoubleHashMap(final OpenIntToDoubleHashMap source) { [EOL]     final int length = source.keys.length; [EOL]     keys = new int[length]; [EOL]     System.arraycopy(source.keys, 0, keys, 0, length); [EOL]     values = new double[length]; [EOL]     System.arraycopy(source.values, 0, values, 0, length); [EOL]     states = new byte[length]; [EOL]     System.arraycopy(source.states, 0, states, 0, length); [EOL]     missingEntries = source.missingEntries; [EOL]     size = source.size; [EOL]     mask = source.mask; [EOL]     count = source.count; [EOL] } <line_num>: 130,142
private Iterator() { [EOL]     referenceCount = count; [EOL]     next = -1; [EOL]     try { [EOL]         advance(); [EOL]     } catch (NoSuchElementException nsee) { [EOL]     } [EOL] } <line_num>: 495,508
private static int computeCapacity(final int expectedSize) { [EOL]     if (expectedSize == 0) { [EOL]         return 1; [EOL]     } [EOL]     final int capacity = (int) FastMath.ceil(expectedSize / LOAD_FACTOR); [EOL]     final int powerOfTwo = Integer.highestOneBit(capacity); [EOL]     if (powerOfTwo == capacity) { [EOL]         return capacity; [EOL]     } [EOL]     return nextPowerOfTwo(capacity); [EOL] } <line_num>: 149,159
private static int nextPowerOfTwo(final int i) { [EOL]     return Integer.highestOneBit(i) << 1; [EOL] } <line_num>: 166,168
public double get(final int key) { [EOL]     final int hash = hashOf(key); [EOL]     int index = hash & mask; [EOL]     if (containsKey(key, index)) { [EOL]         return values[index]; [EOL]     } [EOL]     if (states[index] == FREE) { [EOL]         return missingEntries; [EOL]     } [EOL]     int j = index; [EOL]     for (int perturb = perturb(hash); states[index] != FREE; perturb >>= PERTURB_SHIFT) { [EOL]         j = probe(perturb, j); [EOL]         index = j & mask; [EOL]         if (containsKey(key, index)) { [EOL]             return values[index]; [EOL]         } [EOL]     } [EOL]     return missingEntries; [EOL] } <line_num>: 175,198
public boolean containsKey(final int key) { [EOL]     final int hash = hashOf(key); [EOL]     int index = hash & mask; [EOL]     if (containsKey(key, index)) { [EOL]         return true; [EOL]     } [EOL]     if (states[index] == FREE) { [EOL]         return false; [EOL]     } [EOL]     int j = index; [EOL]     for (int perturb = perturb(hash); states[index] != FREE; perturb >>= PERTURB_SHIFT) { [EOL]         j = probe(perturb, j); [EOL]         index = j & mask; [EOL]         if (containsKey(key, index)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 205,228
public Iterator iterator() { [EOL]     return new Iterator(); [EOL] } <line_num>: 237,239
private static int perturb(final int hash) { [EOL]     return hash & 0x7fffffff; [EOL] } <line_num>: 246,248
private int findInsertionIndex(final int key) { [EOL]     return findInsertionIndex(keys, states, key, mask); [EOL] } <line_num>: 255,257
private static int findInsertionIndex(final int[] keys, final byte[] states, final int key, final int mask) { [EOL]     final int hash = hashOf(key); [EOL]     int index = hash & mask; [EOL]     if (states[index] == FREE) { [EOL]         return index; [EOL]     } else if (states[index] == FULL && keys[index] == key) { [EOL]         return changeIndexSign(index); [EOL]     } [EOL]     int perturb = perturb(hash); [EOL]     int j = index; [EOL]     if (states[index] == FULL) { [EOL]         while (true) { [EOL]             j = probe(perturb, j); [EOL]             index = j & mask; [EOL]             perturb >>= PERTURB_SHIFT; [EOL]             if (states[index] != FULL || keys[index] == key) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (states[index] == FREE) { [EOL]         return index; [EOL]     } else if (states[index] == FULL) { [EOL]         return changeIndexSign(index); [EOL]     } [EOL]     final int firstRemoved = index; [EOL]     while (true) { [EOL]         j = probe(perturb, j); [EOL]         index = j & mask; [EOL]         if (states[index] == FREE) { [EOL]             return firstRemoved; [EOL]         } else if (states[index] == FULL && keys[index] == key) { [EOL]             return changeIndexSign(index); [EOL]         } [EOL]         perturb >>= PERTURB_SHIFT; [EOL]     } [EOL] } <line_num>: 267,314
private static int probe(final int perturb, final int j) { [EOL]     return (j << 2) + j + perturb + 1; [EOL] } <line_num>: 322,324
private static int changeIndexSign(final int index) { [EOL]     return -index - 1; [EOL] } <line_num>: 331,333
public int size() { [EOL]     return size; [EOL] } <line_num>: 339,341
public double remove(final int key) { [EOL]     final int hash = hashOf(key); [EOL]     int index = hash & mask; [EOL]     if (containsKey(key, index)) { [EOL]         return doRemove(index); [EOL]     } [EOL]     if (states[index] == FREE) { [EOL]         return missingEntries; [EOL]     } [EOL]     int j = index; [EOL]     for (int perturb = perturb(hash); states[index] != FREE; perturb >>= PERTURB_SHIFT) { [EOL]         j = probe(perturb, j); [EOL]         index = j & mask; [EOL]         if (containsKey(key, index)) { [EOL]             return doRemove(index); [EOL]         } [EOL]     } [EOL]     return missingEntries; [EOL] } <line_num>: 349,372
private boolean containsKey(final int key, final int index) { [EOL]     return (key != 0 || states[index] == FULL) && keys[index] == key; [EOL] } <line_num>: 381,383
private double doRemove(int index) { [EOL]     keys[index] = 0; [EOL]     states[index] = REMOVED; [EOL]     final double previous = values[index]; [EOL]     values[index] = missingEntries; [EOL]     --size; [EOL]     ++count; [EOL]     return previous; [EOL] } <line_num>: 390,398
public double put(final int key, final double value) { [EOL]     int index = findInsertionIndex(key); [EOL]     double previous = missingEntries; [EOL]     boolean newMapping = true; [EOL]     if (index < 0) { [EOL]         index = changeIndexSign(index); [EOL]         previous = values[index]; [EOL]         newMapping = false; [EOL]     } [EOL]     keys[index] = key; [EOL]     states[index] = FULL; [EOL]     values[index] = value; [EOL]     if (newMapping) { [EOL]         ++size; [EOL]         if (shouldGrowTable()) { [EOL]             growTable(); [EOL]         } [EOL]         ++count; [EOL]     } [EOL]     return previous; [EOL] } <line_num>: 406,427
private void growTable() { [EOL]     final int oldLength = states.length; [EOL]     final int[] oldKeys = keys; [EOL]     final double[] oldValues = values; [EOL]     final byte[] oldStates = states; [EOL]     final int newLength = RESIZE_MULTIPLIER * oldLength; [EOL]     final int[] newKeys = new int[newLength]; [EOL]     final double[] newValues = new double[newLength]; [EOL]     final byte[] newStates = new byte[newLength]; [EOL]     final int newMask = newLength - 1; [EOL]     for (int i = 0; i < oldLength; ++i) { [EOL]         if (oldStates[i] == FULL) { [EOL]             final int key = oldKeys[i]; [EOL]             final int index = findInsertionIndex(newKeys, newStates, key, newMask); [EOL]             newKeys[index] = key; [EOL]             newValues[index] = oldValues[i]; [EOL]             newStates[index] = FULL; [EOL]         } [EOL]     } [EOL]     mask = newMask; [EOL]     keys = newKeys; [EOL]     values = newValues; [EOL]     states = newStates; [EOL] } <line_num>: 432,459
private boolean shouldGrowTable() { [EOL]     return size > (mask + 1) * LOAD_FACTOR; [EOL] } <line_num>: 465,467
private static int hashOf(final int key) { [EOL]     final int h = key ^ ((key >>> 20) ^ (key >>> 12)); [EOL]     return h ^ (h >>> 7) ^ (h >>> 4); [EOL] } <line_num>: 474,477
public boolean hasNext() { [EOL]     return next >= 0; [EOL] } <line_num>: 514,516
public int key() throws ConcurrentModificationException, NoSuchElementException { [EOL]     if (referenceCount != count) { [EOL]         throw new ConcurrentModificationException(); [EOL]     } [EOL]     if (current < 0) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     return keys[current]; [EOL] } <line_num>: 524,533
public double value() throws ConcurrentModificationException, NoSuchElementException { [EOL]     if (referenceCount != count) { [EOL]         throw new ConcurrentModificationException(); [EOL]     } [EOL]     if (current < 0) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     return values[current]; [EOL] } <line_num>: 541,550
public void advance() throws ConcurrentModificationException, NoSuchElementException { [EOL]     if (referenceCount != count) { [EOL]         throw new ConcurrentModificationException(); [EOL]     } [EOL]     current = next; [EOL]     try { [EOL]         while (states[++next] != FULL) { [EOL]         } [EOL]     } catch (ArrayIndexOutOfBoundsException e) { [EOL]         next = -2; [EOL]         if (current < 0) { [EOL]             throw new NoSuchElementException(); [EOL]         } [EOL]     } [EOL] } <line_num>: 557,579
private void readObject(final ObjectInputStream stream) throws IOException, ClassNotFoundException { [EOL]     stream.defaultReadObject(); [EOL]     count = 0; [EOL] } <line_num>: 590,594
