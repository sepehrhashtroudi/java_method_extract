private ArithmeticUtils() { [EOL]     super(); [EOL] } <line_num>: 36,38
public static int addAndCheck(int x, int y) throws MathArithmeticException { [EOL]     long s = (long) x + (long) y; [EOL]     if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) { [EOL]         throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, x, y); [EOL]     } [EOL]     return (int) s; [EOL] } <line_num>: 50,57
public static long addAndCheck(long a, long b) throws MathArithmeticException { [EOL]     return ArithmeticUtils.addAndCheck(a, b, LocalizedFormats.OVERFLOW_IN_ADDITION); [EOL] } <line_num>: 69,71
public static long binomialCoefficient(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException { [EOL]     return CombinatoricsUtils.binomialCoefficient(n, k); [EOL] } <line_num>: 100,103
public static double binomialCoefficientDouble(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException { [EOL]     return CombinatoricsUtils.binomialCoefficientDouble(n, k); [EOL] } <line_num>: 131,134
public static double binomialCoefficientLog(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException { [EOL]     return CombinatoricsUtils.binomialCoefficientLog(n, k); [EOL] } <line_num>: 158,161
public static long factorial(final int n) throws NotPositiveException, MathArithmeticException { [EOL]     return CombinatoricsUtils.factorial(n); [EOL] } <line_num>: 188,190
public static double factorialDouble(final int n) throws NotPositiveException { [EOL]     return CombinatoricsUtils.factorialDouble(n); [EOL] } <line_num>: 206,208
public static double factorialLog(final int n) throws NotPositiveException { [EOL]     return CombinatoricsUtils.factorialLog(n); [EOL] } <line_num>: 218,220
public static int gcd(int p, int q) throws MathArithmeticException { [EOL]     int a = p; [EOL]     int b = q; [EOL]     if (a == 0 || b == 0) { [EOL]         if (a == Integer.MIN_VALUE || b == Integer.MIN_VALUE) { [EOL]             throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q); [EOL]         } [EOL]         return FastMath.abs(a + b); [EOL]     } [EOL]     long al = a; [EOL]     long bl = b; [EOL]     boolean useLong = false; [EOL]     if (a < 0) { [EOL]         if (Integer.MIN_VALUE == a) { [EOL]             useLong = true; [EOL]         } else { [EOL]             a = -a; [EOL]         } [EOL]         al = -al; [EOL]     } [EOL]     if (b < 0) { [EOL]         if (Integer.MIN_VALUE == b) { [EOL]             useLong = true; [EOL]         } else { [EOL]             b = -b; [EOL]         } [EOL]         bl = -bl; [EOL]     } [EOL]     if (useLong) { [EOL]         if (al == bl) { [EOL]             throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q); [EOL]         } [EOL]         long blbu = bl; [EOL]         bl = al; [EOL]         al = blbu % al; [EOL]         if (al == 0) { [EOL]             if (bl > Integer.MAX_VALUE) { [EOL]                 throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q); [EOL]             } [EOL]             return (int) bl; [EOL]         } [EOL]         blbu = bl; [EOL]         b = (int) al; [EOL]         a = (int) (blbu % al); [EOL]     } [EOL]     return gcdPositive(a, b); [EOL] } <line_num>: 250,307
private static int gcdPositive(int a, int b) { [EOL]     if (a == 0) { [EOL]         return b; [EOL]     } else if (b == 0) { [EOL]         return a; [EOL]     } [EOL]     final int aTwos = Integer.numberOfTrailingZeros(a); [EOL]     a >>= aTwos; [EOL]     final int bTwos = Integer.numberOfTrailingZeros(b); [EOL]     b >>= bTwos; [EOL]     final int shift = Math.min(aTwos, bTwos); [EOL]     while (a != b) { [EOL]         final int delta = a - b; [EOL]         b = Math.min(a, b); [EOL]         a = Math.abs(delta); [EOL]         a >>= Integer.numberOfTrailingZeros(a); [EOL]     } [EOL]     return a << shift; [EOL] } <line_num>: 329,362
public static long gcd(final long p, final long q) throws MathArithmeticException { [EOL]     long u = p; [EOL]     long v = q; [EOL]     if ((u == 0) || (v == 0)) { [EOL]         if ((u == Long.MIN_VALUE) || (v == Long.MIN_VALUE)) { [EOL]             throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS, p, q); [EOL]         } [EOL]         return FastMath.abs(u) + FastMath.abs(v); [EOL]     } [EOL]     if (u > 0) { [EOL]         u = -u; [EOL]     } [EOL]     if (v > 0) { [EOL]         v = -v; [EOL]     } [EOL]     int k = 0; [EOL]     while ((u & 1) == 0 && (v & 1) == 0 && k < 63) { [EOL]         u /= 2; [EOL]         v /= 2; [EOL]         k++; [EOL]     } [EOL]     if (k == 63) { [EOL]         throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS, p, q); [EOL]     } [EOL]     long t = ((u & 1) == 1) ? v : -(u / 2); [EOL]     do { [EOL]         while ((t & 1) == 0) { [EOL]             t /= 2; [EOL]         } [EOL]         if (t > 0) { [EOL]             u = -t; [EOL]         } else { [EOL]             v = t; [EOL]         } [EOL]         t = (v - u) / 2; [EOL]     } while (t != 0); [EOL]     return -u * (1L << k); [EOL] } <line_num>: 393,449
public static int lcm(int a, int b) throws MathArithmeticException { [EOL]     if (a == 0 || b == 0) { [EOL]         return 0; [EOL]     } [EOL]     int lcm = FastMath.abs(ArithmeticUtils.mulAndCheck(a / gcd(a, b), b)); [EOL]     if (lcm == Integer.MIN_VALUE) { [EOL]         throw new MathArithmeticException(LocalizedFormats.LCM_OVERFLOW_32_BITS, a, b); [EOL]     } [EOL]     return lcm; [EOL] } <line_num>: 473,483
public static long lcm(long a, long b) throws MathArithmeticException { [EOL]     if (a == 0 || b == 0) { [EOL]         return 0; [EOL]     } [EOL]     long lcm = FastMath.abs(ArithmeticUtils.mulAndCheck(a / gcd(a, b), b)); [EOL]     if (lcm == Long.MIN_VALUE) { [EOL]         throw new MathArithmeticException(LocalizedFormats.LCM_OVERFLOW_64_BITS, a, b); [EOL]     } [EOL]     return lcm; [EOL] } <line_num>: 507,517
public static int mulAndCheck(int x, int y) throws MathArithmeticException { [EOL]     long m = ((long) x) * ((long) y); [EOL]     if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) { [EOL]         throw new MathArithmeticException(); [EOL]     } [EOL]     return (int) m; [EOL] } <line_num>: 529,535
public static long mulAndCheck(long a, long b) throws MathArithmeticException { [EOL]     long ret; [EOL]     if (a > b) { [EOL]         ret = mulAndCheck(b, a); [EOL]     } else { [EOL]         if (a < 0) { [EOL]             if (b < 0) { [EOL]                 if (a >= Long.MAX_VALUE / b) { [EOL]                     ret = a * b; [EOL]                 } else { [EOL]                     throw new MathArithmeticException(); [EOL]                 } [EOL]             } else if (b > 0) { [EOL]                 if (Long.MIN_VALUE / b <= a) { [EOL]                     ret = a * b; [EOL]                 } else { [EOL]                     throw new MathArithmeticException(); [EOL]                 } [EOL]             } else { [EOL]                 ret = 0; [EOL]             } [EOL]         } else if (a > 0) { [EOL]             if (a <= Long.MAX_VALUE / b) { [EOL]                 ret = a * b; [EOL]             } else { [EOL]                 throw new MathArithmeticException(); [EOL]             } [EOL]         } else { [EOL]             ret = 0; [EOL]         } [EOL]     } [EOL]     return ret; [EOL] } <line_num>: 547,589
public static int subAndCheck(int x, int y) throws MathArithmeticException { [EOL]     long s = (long) x - (long) y; [EOL]     if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) { [EOL]         throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, x, y); [EOL]     } [EOL]     return (int) s; [EOL] } <line_num>: 601,607
public static long subAndCheck(long a, long b) throws MathArithmeticException { [EOL]     long ret; [EOL]     if (b == Long.MIN_VALUE) { [EOL]         if (a < 0) { [EOL]             ret = a - b; [EOL]         } else { [EOL]             throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, a, -b); [EOL]         } [EOL]     } else { [EOL]         ret = addAndCheck(a, -b, LocalizedFormats.OVERFLOW_IN_ADDITION); [EOL]     } [EOL]     return ret; [EOL] } <line_num>: 619,632
public static int pow(final int k, int e) throws NotPositiveException { [EOL]     if (e < 0) { [EOL]         throw new NotPositiveException(LocalizedFormats.EXPONENT, e); [EOL]     } [EOL]     int result = 1; [EOL]     int k2p = k; [EOL]     while (e != 0) { [EOL]         if ((e & 0x1) != 0) { [EOL]             result *= k2p; [EOL]         } [EOL]         k2p *= k2p; [EOL]         e = e >> 1; [EOL]     } [EOL]     return result; [EOL] } <line_num>: 642,658
public static int pow(final int k, long e) throws NotPositiveException { [EOL]     if (e < 0) { [EOL]         throw new NotPositiveException(LocalizedFormats.EXPONENT, e); [EOL]     } [EOL]     int result = 1; [EOL]     int k2p = k; [EOL]     while (e != 0) { [EOL]         if ((e & 0x1) != 0) { [EOL]             result *= k2p; [EOL]         } [EOL]         k2p *= k2p; [EOL]         e = e >> 1; [EOL]     } [EOL]     return result; [EOL] } <line_num>: 668,684
public static long pow(final long k, int e) throws NotPositiveException { [EOL]     if (e < 0) { [EOL]         throw new NotPositiveException(LocalizedFormats.EXPONENT, e); [EOL]     } [EOL]     long result = 1l; [EOL]     long k2p = k; [EOL]     while (e != 0) { [EOL]         if ((e & 0x1) != 0) { [EOL]             result *= k2p; [EOL]         } [EOL]         k2p *= k2p; [EOL]         e = e >> 1; [EOL]     } [EOL]     return result; [EOL] } <line_num>: 694,710
public static long pow(final long k, long e) throws NotPositiveException { [EOL]     if (e < 0) { [EOL]         throw new NotPositiveException(LocalizedFormats.EXPONENT, e); [EOL]     } [EOL]     long result = 1l; [EOL]     long k2p = k; [EOL]     while (e != 0) { [EOL]         if ((e & 0x1) != 0) { [EOL]             result *= k2p; [EOL]         } [EOL]         k2p *= k2p; [EOL]         e = e >> 1; [EOL]     } [EOL]     return result; [EOL] } <line_num>: 720,736
public static BigInteger pow(final BigInteger k, int e) throws NotPositiveException { [EOL]     if (e < 0) { [EOL]         throw new NotPositiveException(LocalizedFormats.EXPONENT, e); [EOL]     } [EOL]     return k.pow(e); [EOL] } <line_num>: 746,752
public static BigInteger pow(final BigInteger k, long e) throws NotPositiveException { [EOL]     if (e < 0) { [EOL]         throw new NotPositiveException(LocalizedFormats.EXPONENT, e); [EOL]     } [EOL]     BigInteger result = BigInteger.ONE; [EOL]     BigInteger k2p = k; [EOL]     while (e != 0) { [EOL]         if ((e & 0x1) != 0) { [EOL]             result = result.multiply(k2p); [EOL]         } [EOL]         k2p = k2p.multiply(k2p); [EOL]         e = e >> 1; [EOL]     } [EOL]     return result; [EOL] } <line_num>: 762,779
public static BigInteger pow(final BigInteger k, BigInteger e) throws NotPositiveException { [EOL]     if (e.compareTo(BigInteger.ZERO) < 0) { [EOL]         throw new NotPositiveException(LocalizedFormats.EXPONENT, e); [EOL]     } [EOL]     BigInteger result = BigInteger.ONE; [EOL]     BigInteger k2p = k; [EOL]     while (!BigInteger.ZERO.equals(e)) { [EOL]         if (e.testBit(0)) { [EOL]             result = result.multiply(k2p); [EOL]         } [EOL]         k2p = k2p.multiply(k2p); [EOL]         e = e.shiftRight(1); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 789,805
public static long stirlingS2(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException { [EOL]     return CombinatoricsUtils.stirlingS2(n, k); [EOL] } <line_num>: 827,831
private static long addAndCheck(long a, long b, Localizable pattern) throws MathArithmeticException { [EOL]     long ret; [EOL]     if (a > b) { [EOL]         ret = addAndCheck(b, a, pattern); [EOL]     } else { [EOL]         if (a < 0) { [EOL]             if (b < 0) { [EOL]                 if (Long.MIN_VALUE - b <= a) { [EOL]                     ret = a + b; [EOL]                 } else { [EOL]                     throw new MathArithmeticException(pattern, a, b); [EOL]                 } [EOL]             } else { [EOL]                 ret = a + b; [EOL]             } [EOL]         } else { [EOL]             if (a <= Long.MAX_VALUE - b) { [EOL]                 ret = a + b; [EOL]             } else { [EOL]                 throw new MathArithmeticException(pattern, a, b); [EOL]             } [EOL]         } [EOL]     } [EOL]     return ret; [EOL] } <line_num>: 844,877
public static boolean isPowerOfTwo(long n) { [EOL]     return (n > 0) && ((n & (n - 1)) == 0); [EOL] } <line_num>: 885,887
