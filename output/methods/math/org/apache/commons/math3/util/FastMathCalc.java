private FastMathCalc() { [EOL] } <line_num>: 89,90
@SuppressWarnings("unused") [EOL] private static void buildSinCosTables(double[] SINE_TABLE_A, double[] SINE_TABLE_B, double[] COSINE_TABLE_A, double[] COSINE_TABLE_B, int SINE_TABLE_LEN, double[] TANGENT_TABLE_A, double[] TANGENT_TABLE_B) { [EOL]     final double[] result = new double[2]; [EOL]     for (int i = 0; i < 7; i++) { [EOL]         double x = i / 8.0; [EOL]         slowSin(x, result); [EOL]         SINE_TABLE_A[i] = result[0]; [EOL]         SINE_TABLE_B[i] = result[1]; [EOL]         slowCos(x, result); [EOL]         COSINE_TABLE_A[i] = result[0]; [EOL]         COSINE_TABLE_B[i] = result[1]; [EOL]     } [EOL]     for (int i = 7; i < SINE_TABLE_LEN; i++) { [EOL]         double[] xs = new double[2]; [EOL]         double[] ys = new double[2]; [EOL]         double[] as = new double[2]; [EOL]         double[] bs = new double[2]; [EOL]         double[] temps = new double[2]; [EOL]         if ((i & 1) == 0) { [EOL]             xs[0] = SINE_TABLE_A[i / 2]; [EOL]             xs[1] = SINE_TABLE_B[i / 2]; [EOL]             ys[0] = COSINE_TABLE_A[i / 2]; [EOL]             ys[1] = COSINE_TABLE_B[i / 2]; [EOL]             splitMult(xs, ys, result); [EOL]             SINE_TABLE_A[i] = result[0] * 2.0; [EOL]             SINE_TABLE_B[i] = result[1] * 2.0; [EOL]             splitMult(ys, ys, as); [EOL]             splitMult(xs, xs, temps); [EOL]             temps[0] = -temps[0]; [EOL]             temps[1] = -temps[1]; [EOL]             splitAdd(as, temps, result); [EOL]             COSINE_TABLE_A[i] = result[0]; [EOL]             COSINE_TABLE_B[i] = result[1]; [EOL]         } else { [EOL]             xs[0] = SINE_TABLE_A[i / 2]; [EOL]             xs[1] = SINE_TABLE_B[i / 2]; [EOL]             ys[0] = COSINE_TABLE_A[i / 2]; [EOL]             ys[1] = COSINE_TABLE_B[i / 2]; [EOL]             as[0] = SINE_TABLE_A[i / 2 + 1]; [EOL]             as[1] = SINE_TABLE_B[i / 2 + 1]; [EOL]             bs[0] = COSINE_TABLE_A[i / 2 + 1]; [EOL]             bs[1] = COSINE_TABLE_B[i / 2 + 1]; [EOL]             splitMult(xs, bs, temps); [EOL]             splitMult(ys, as, result); [EOL]             splitAdd(result, temps, result); [EOL]             SINE_TABLE_A[i] = result[0]; [EOL]             SINE_TABLE_B[i] = result[1]; [EOL]             splitMult(ys, bs, result); [EOL]             splitMult(xs, as, temps); [EOL]             temps[0] = -temps[0]; [EOL]             temps[1] = -temps[1]; [EOL]             splitAdd(result, temps, result); [EOL]             COSINE_TABLE_A[i] = result[0]; [EOL]             COSINE_TABLE_B[i] = result[1]; [EOL]         } [EOL]     } [EOL]     for (int i = 0; i < SINE_TABLE_LEN; i++) { [EOL]         double[] xs = new double[2]; [EOL]         double[] ys = new double[2]; [EOL]         double[] as = new double[2]; [EOL]         as[0] = COSINE_TABLE_A[i]; [EOL]         as[1] = COSINE_TABLE_B[i]; [EOL]         splitReciprocal(as, ys); [EOL]         xs[0] = SINE_TABLE_A[i]; [EOL]         xs[1] = SINE_TABLE_B[i]; [EOL]         splitMult(xs, ys, as); [EOL]         TANGENT_TABLE_A[i] = as[0]; [EOL]         TANGENT_TABLE_B[i] = as[1]; [EOL]     } [EOL] } <line_num>: 101,196
static double slowCos(final double x, final double[] result) { [EOL]     final double[] xs = new double[2]; [EOL]     final double[] ys = new double[2]; [EOL]     final double[] facts = new double[2]; [EOL]     final double[] as = new double[2]; [EOL]     split(x, xs); [EOL]     ys[0] = ys[1] = 0.0; [EOL]     for (int i = FACT.length - 1; i >= 0; i--) { [EOL]         splitMult(xs, ys, as); [EOL]         ys[0] = as[0]; [EOL]         ys[1] = as[1]; [EOL]         if ((i & 1) != 0) { [EOL]             continue; [EOL]         } [EOL]         split(FACT[i], as); [EOL]         splitReciprocal(as, facts); [EOL]         if ((i & 2) != 0) { [EOL]             facts[0] = -facts[0]; [EOL]             facts[1] = -facts[1]; [EOL]         } [EOL]         splitAdd(ys, facts, as); [EOL]         ys[0] = as[0]; [EOL]         ys[1] = as[1]; [EOL]     } [EOL]     if (result != null) { [EOL]         result[0] = ys[0]; [EOL]         result[1] = ys[1]; [EOL]     } [EOL]     return ys[0] + ys[1]; [EOL] } <line_num>: 206,241
static double slowSin(final double x, final double[] result) { [EOL]     final double[] xs = new double[2]; [EOL]     final double[] ys = new double[2]; [EOL]     final double[] facts = new double[2]; [EOL]     final double[] as = new double[2]; [EOL]     split(x, xs); [EOL]     ys[0] = ys[1] = 0.0; [EOL]     for (int i = FACT.length - 1; i >= 0; i--) { [EOL]         splitMult(xs, ys, as); [EOL]         ys[0] = as[0]; [EOL]         ys[1] = as[1]; [EOL]         if ((i & 1) == 0) { [EOL]             continue; [EOL]         } [EOL]         split(FACT[i], as); [EOL]         splitReciprocal(as, facts); [EOL]         if ((i & 2) != 0) { [EOL]             facts[0] = -facts[0]; [EOL]             facts[1] = -facts[1]; [EOL]         } [EOL]         splitAdd(ys, facts, as); [EOL]         ys[0] = as[0]; [EOL]         ys[1] = as[1]; [EOL]     } [EOL]     if (result != null) { [EOL]         result[0] = ys[0]; [EOL]         result[1] = ys[1]; [EOL]     } [EOL]     return ys[0] + ys[1]; [EOL] } <line_num>: 251,285
static double slowexp(final double x, final double[] result) { [EOL]     final double[] xs = new double[2]; [EOL]     final double[] ys = new double[2]; [EOL]     final double[] facts = new double[2]; [EOL]     final double[] as = new double[2]; [EOL]     split(x, xs); [EOL]     ys[0] = ys[1] = 0.0; [EOL]     for (int i = FACT.length - 1; i >= 0; i--) { [EOL]         splitMult(xs, ys, as); [EOL]         ys[0] = as[0]; [EOL]         ys[1] = as[1]; [EOL]         split(FACT[i], as); [EOL]         splitReciprocal(as, facts); [EOL]         splitAdd(ys, facts, as); [EOL]         ys[0] = as[0]; [EOL]         ys[1] = as[1]; [EOL]     } [EOL]     if (result != null) { [EOL]         result[0] = ys[0]; [EOL]         result[1] = ys[1]; [EOL]     } [EOL]     return ys[0] + ys[1]; [EOL] } <line_num>: 295,322
private static void split(final double d, final double[] split) { [EOL]     if (d < 8e298 && d > -8e298) { [EOL]         final double a = d * HEX_40000000; [EOL]         split[0] = (d + a) - a; [EOL]         split[1] = d - split[0]; [EOL]     } else { [EOL]         final double a = d * 9.31322574615478515625E-10; [EOL]         split[0] = (d + a - d) * HEX_40000000; [EOL]         split[1] = d - split[0]; [EOL]     } [EOL] } <line_num>: 329,339
private static void resplit(final double[] a) { [EOL]     final double c = a[0] + a[1]; [EOL]     final double d = -(c - a[0] - a[1]); [EOL]     if (c < 8e298 && c > -8e298) { [EOL]         double z = c * HEX_40000000; [EOL]         a[0] = (c + z) - z; [EOL]         a[1] = c - a[0] + d; [EOL]     } else { [EOL]         double z = c * 9.31322574615478515625E-10; [EOL]         a[0] = (c + z - c) * HEX_40000000; [EOL]         a[1] = c - a[0] + d; [EOL]     } [EOL] } <line_num>: 345,358
private static void splitMult(double[] a, double[] b, double[] ans) { [EOL]     ans[0] = a[0] * b[0]; [EOL]     ans[1] = a[0] * b[1] + a[1] * b[0] + a[1] * b[1]; [EOL]     resplit(ans); [EOL] } <line_num>: 365,371
private static void splitAdd(final double[] a, final double[] b, final double[] ans) { [EOL]     ans[0] = a[0] + b[0]; [EOL]     ans[1] = a[1] + b[1]; [EOL]     resplit(ans); [EOL] } <line_num>: 378,383
static void splitReciprocal(final double[] in, final double[] result) { [EOL]     final double b = 1.0 / 4194304.0; [EOL]     final double a = 1.0 - b; [EOL]     if (in[0] == 0.0) { [EOL]         in[0] = in[1]; [EOL]         in[1] = 0.0; [EOL]     } [EOL]     result[0] = a / in[0]; [EOL]     result[1] = (b * in[0] - a * in[1]) / (in[0] * in[0] + in[0] * in[1]); [EOL]     if (result[1] != result[1]) { [EOL]         result[1] = 0.0; [EOL]     } [EOL]     resplit(result); [EOL]     for (int i = 0; i < 2; i++) { [EOL]         double err = 1.0 - result[0] * in[0] - result[0] * in[1] - result[1] * in[0] - result[1] * in[1]; [EOL]         err = err * (result[0] + result[1]); [EOL]         result[1] += err; [EOL]     } [EOL] } <line_num>: 403,431
private static void quadMult(final double[] a, final double[] b, final double[] result) { [EOL]     final double[] xs = new double[2]; [EOL]     final double[] ys = new double[2]; [EOL]     final double[] zs = new double[2]; [EOL]     split(a[0], xs); [EOL]     split(b[0], ys); [EOL]     splitMult(xs, ys, zs); [EOL]     result[0] = zs[0]; [EOL]     result[1] = zs[1]; [EOL]     split(b[1], ys); [EOL]     splitMult(xs, ys, zs); [EOL]     double tmp = result[0] + zs[0]; [EOL]     result[1] = result[1] - (tmp - result[0] - zs[0]); [EOL]     result[0] = tmp; [EOL]     tmp = result[0] + zs[1]; [EOL]     result[1] = result[1] - (tmp - result[0] - zs[1]); [EOL]     result[0] = tmp; [EOL]     split(a[1], xs); [EOL]     split(b[0], ys); [EOL]     splitMult(xs, ys, zs); [EOL]     tmp = result[0] + zs[0]; [EOL]     result[1] = result[1] - (tmp - result[0] - zs[0]); [EOL]     result[0] = tmp; [EOL]     tmp = result[0] + zs[1]; [EOL]     result[1] = result[1] - (tmp - result[0] - zs[1]); [EOL]     result[0] = tmp; [EOL]     split(a[1], xs); [EOL]     split(b[1], ys); [EOL]     splitMult(xs, ys, zs); [EOL]     tmp = result[0] + zs[0]; [EOL]     result[1] = result[1] - (tmp - result[0] - zs[0]); [EOL]     result[0] = tmp; [EOL]     tmp = result[0] + zs[1]; [EOL]     result[1] = result[1] - (tmp - result[0] - zs[1]); [EOL]     result[0] = tmp; [EOL] } <line_num>: 438,485
static double expint(int p, final double[] result) { [EOL]     final double[] xs = new double[2]; [EOL]     final double[] as = new double[2]; [EOL]     final double[] ys = new double[2]; [EOL]     xs[0] = 2.718281828459045; [EOL]     xs[1] = 1.4456468917292502E-16; [EOL]     split(1.0, ys); [EOL]     while (p > 0) { [EOL]         if ((p & 1) != 0) { [EOL]             quadMult(ys, xs, as); [EOL]             ys[0] = as[0]; [EOL]             ys[1] = as[1]; [EOL]         } [EOL]         quadMult(xs, xs, as); [EOL]         xs[0] = as[0]; [EOL]         xs[1] = as[1]; [EOL]         p >>= 1; [EOL]     } [EOL]     if (result != null) { [EOL]         result[0] = ys[0]; [EOL]         result[1] = ys[1]; [EOL]         resplit(result); [EOL]     } [EOL]     return ys[0] + ys[1]; [EOL] } <line_num>: 492,530
static double[] slowLog(double xi) { [EOL]     double[] x = new double[2]; [EOL]     double[] x2 = new double[2]; [EOL]     double[] y = new double[2]; [EOL]     double[] a = new double[2]; [EOL]     split(xi, x); [EOL]     x[0] += 1.0; [EOL]     resplit(x); [EOL]     splitReciprocal(x, a); [EOL]     x[0] -= 2.0; [EOL]     resplit(x); [EOL]     splitMult(x, a, y); [EOL]     x[0] = y[0]; [EOL]     x[1] = y[1]; [EOL]     splitMult(x, x, x2); [EOL]     y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length - 1][0]; [EOL]     y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length - 1][1]; [EOL]     for (int i = LN_SPLIT_COEF.length - 2; i >= 0; i--) { [EOL]         splitMult(y, x2, a); [EOL]         y[0] = a[0]; [EOL]         y[1] = a[1]; [EOL]         splitAdd(y, LN_SPLIT_COEF[i], a); [EOL]         y[0] = a[0]; [EOL]         y[1] = a[1]; [EOL]     } [EOL]     splitMult(y, x, a); [EOL]     y[0] = a[0]; [EOL]     y[1] = a[1]; [EOL]     return y; [EOL] } <line_num>: 550,592
static void printarray(PrintStream out, String name, int expectedLen, double[][] array2d) { [EOL]     out.println(name); [EOL]     checkLen(expectedLen, array2d.length); [EOL]     out.println(TABLE_START_DECL + " "); [EOL]     int i = 0; [EOL]     for (double[] array : array2d) { [EOL]         out.print("        {"); [EOL]         for (double d : array) { [EOL]             out.printf("%-25.25s", format(d)); [EOL]         } [EOL]         out.println("}, // " + i++); [EOL]     } [EOL]     out.println(TABLE_END_DECL); [EOL] } <line_num>: 602,615
static void printarray(PrintStream out, String name, int expectedLen, double[] array) { [EOL]     out.println(name + "="); [EOL]     checkLen(expectedLen, array.length); [EOL]     out.println(TABLE_START_DECL); [EOL]     for (double d : array) { [EOL]         out.printf("        %s%n", format(d)); [EOL]     } [EOL]     out.println(TABLE_END_DECL); [EOL] } <line_num>: 624,632
static String format(double d) { [EOL]     if (d != d) { [EOL]         return "Double.NaN,"; [EOL]     } else { [EOL]         return ((d >= 0) ? "+" : "") + Double.toString(d) + "d,"; [EOL]     } [EOL] } <line_num>: 638,644
private static void checkLen(int expectedLen, int actual) throws DimensionMismatchException { [EOL]     if (expectedLen != actual) { [EOL]         throw new DimensionMismatchException(actual, expectedLen); [EOL]     } [EOL] } <line_num>: 652,657
