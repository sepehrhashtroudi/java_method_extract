public OpenIntToFieldHashMap(final Field<T> field) { [EOL]     this(field, DEFAULT_EXPECTED_SIZE, field.getZero()); [EOL] } <line_num>: 99,101
public OpenIntToFieldHashMap(final Field<T> field, final T missingEntries) { [EOL]     this(field, DEFAULT_EXPECTED_SIZE, missingEntries); [EOL] } <line_num>: 108,110
public OpenIntToFieldHashMap(final Field<T> field, final int expectedSize) { [EOL]     this(field, expectedSize, field.getZero()); [EOL] } <line_num>: 117,119
public OpenIntToFieldHashMap(final Field<T> field, final int expectedSize, final T missingEntries) { [EOL]     this.field = field; [EOL]     final int capacity = computeCapacity(expectedSize); [EOL]     keys = new int[capacity]; [EOL]     values = buildArray(capacity); [EOL]     states = new byte[capacity]; [EOL]     this.missingEntries = missingEntries; [EOL]     mask = capacity - 1; [EOL] } <line_num>: 127,136
public OpenIntToFieldHashMap(final OpenIntToFieldHashMap<T> source) { [EOL]     field = source.field; [EOL]     final int length = source.keys.length; [EOL]     keys = new int[length]; [EOL]     System.arraycopy(source.keys, 0, keys, 0, length); [EOL]     values = buildArray(length); [EOL]     System.arraycopy(source.values, 0, values, 0, length); [EOL]     states = new byte[length]; [EOL]     System.arraycopy(source.states, 0, states, 0, length); [EOL]     missingEntries = source.missingEntries; [EOL]     size = source.size; [EOL]     mask = source.mask; [EOL]     count = source.count; [EOL] } <line_num>: 142,155
private Iterator() { [EOL]     referenceCount = count; [EOL]     next = -1; [EOL]     try { [EOL]         advance(); [EOL]     } catch (NoSuchElementException nsee) { [EOL]     } [EOL] } <line_num>: 508,521
private static int computeCapacity(final int expectedSize) { [EOL]     if (expectedSize == 0) { [EOL]         return 1; [EOL]     } [EOL]     final int capacity = (int) FastMath.ceil(expectedSize / LOAD_FACTOR); [EOL]     final int powerOfTwo = Integer.highestOneBit(capacity); [EOL]     if (powerOfTwo == capacity) { [EOL]         return capacity; [EOL]     } [EOL]     return nextPowerOfTwo(capacity); [EOL] } <line_num>: 162,172
private static int nextPowerOfTwo(final int i) { [EOL]     return Integer.highestOneBit(i) << 1; [EOL] } <line_num>: 179,181
public T get(final int key) { [EOL]     final int hash = hashOf(key); [EOL]     int index = hash & mask; [EOL]     if (containsKey(key, index)) { [EOL]         return values[index]; [EOL]     } [EOL]     if (states[index] == FREE) { [EOL]         return missingEntries; [EOL]     } [EOL]     int j = index; [EOL]     for (int perturb = perturb(hash); states[index] != FREE; perturb >>= PERTURB_SHIFT) { [EOL]         j = probe(perturb, j); [EOL]         index = j & mask; [EOL]         if (containsKey(key, index)) { [EOL]             return values[index]; [EOL]         } [EOL]     } [EOL]     return missingEntries; [EOL] } <line_num>: 188,211
public boolean containsKey(final int key) { [EOL]     final int hash = hashOf(key); [EOL]     int index = hash & mask; [EOL]     if (containsKey(key, index)) { [EOL]         return true; [EOL]     } [EOL]     if (states[index] == FREE) { [EOL]         return false; [EOL]     } [EOL]     int j = index; [EOL]     for (int perturb = perturb(hash); states[index] != FREE; perturb >>= PERTURB_SHIFT) { [EOL]         j = probe(perturb, j); [EOL]         index = j & mask; [EOL]         if (containsKey(key, index)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 218,241
public Iterator iterator() { [EOL]     return new Iterator(); [EOL] } <line_num>: 250,252
private static int perturb(final int hash) { [EOL]     return hash & 0x7fffffff; [EOL] } <line_num>: 259,261
private int findInsertionIndex(final int key) { [EOL]     return findInsertionIndex(keys, states, key, mask); [EOL] } <line_num>: 268,270
private static int findInsertionIndex(final int[] keys, final byte[] states, final int key, final int mask) { [EOL]     final int hash = hashOf(key); [EOL]     int index = hash & mask; [EOL]     if (states[index] == FREE) { [EOL]         return index; [EOL]     } else if (states[index] == FULL && keys[index] == key) { [EOL]         return changeIndexSign(index); [EOL]     } [EOL]     int perturb = perturb(hash); [EOL]     int j = index; [EOL]     if (states[index] == FULL) { [EOL]         while (true) { [EOL]             j = probe(perturb, j); [EOL]             index = j & mask; [EOL]             perturb >>= PERTURB_SHIFT; [EOL]             if (states[index] != FULL || keys[index] == key) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (states[index] == FREE) { [EOL]         return index; [EOL]     } else if (states[index] == FULL) { [EOL]         return changeIndexSign(index); [EOL]     } [EOL]     final int firstRemoved = index; [EOL]     while (true) { [EOL]         j = probe(perturb, j); [EOL]         index = j & mask; [EOL]         if (states[index] == FREE) { [EOL]             return firstRemoved; [EOL]         } else if (states[index] == FULL && keys[index] == key) { [EOL]             return changeIndexSign(index); [EOL]         } [EOL]         perturb >>= PERTURB_SHIFT; [EOL]     } [EOL] } <line_num>: 280,327
private static int probe(final int perturb, final int j) { [EOL]     return (j << 2) + j + perturb + 1; [EOL] } <line_num>: 335,337
private static int changeIndexSign(final int index) { [EOL]     return -index - 1; [EOL] } <line_num>: 344,346
public int size() { [EOL]     return size; [EOL] } <line_num>: 352,354
public T remove(final int key) { [EOL]     final int hash = hashOf(key); [EOL]     int index = hash & mask; [EOL]     if (containsKey(key, index)) { [EOL]         return doRemove(index); [EOL]     } [EOL]     if (states[index] == FREE) { [EOL]         return missingEntries; [EOL]     } [EOL]     int j = index; [EOL]     for (int perturb = perturb(hash); states[index] != FREE; perturb >>= PERTURB_SHIFT) { [EOL]         j = probe(perturb, j); [EOL]         index = j & mask; [EOL]         if (containsKey(key, index)) { [EOL]             return doRemove(index); [EOL]         } [EOL]     } [EOL]     return missingEntries; [EOL] } <line_num>: 362,385
private boolean containsKey(final int key, final int index) { [EOL]     return (key != 0 || states[index] == FULL) && keys[index] == key; [EOL] } <line_num>: 394,396
private T doRemove(int index) { [EOL]     keys[index] = 0; [EOL]     states[index] = REMOVED; [EOL]     final T previous = values[index]; [EOL]     values[index] = missingEntries; [EOL]     --size; [EOL]     ++count; [EOL]     return previous; [EOL] } <line_num>: 403,411
public T put(final int key, final T value) { [EOL]     int index = findInsertionIndex(key); [EOL]     T previous = missingEntries; [EOL]     boolean newMapping = true; [EOL]     if (index < 0) { [EOL]         index = changeIndexSign(index); [EOL]         previous = values[index]; [EOL]         newMapping = false; [EOL]     } [EOL]     keys[index] = key; [EOL]     states[index] = FULL; [EOL]     values[index] = value; [EOL]     if (newMapping) { [EOL]         ++size; [EOL]         if (shouldGrowTable()) { [EOL]             growTable(); [EOL]         } [EOL]         ++count; [EOL]     } [EOL]     return previous; [EOL] } <line_num>: 419,440
private void growTable() { [EOL]     final int oldLength = states.length; [EOL]     final int[] oldKeys = keys; [EOL]     final T[] oldValues = values; [EOL]     final byte[] oldStates = states; [EOL]     final int newLength = RESIZE_MULTIPLIER * oldLength; [EOL]     final int[] newKeys = new int[newLength]; [EOL]     final T[] newValues = buildArray(newLength); [EOL]     final byte[] newStates = new byte[newLength]; [EOL]     final int newMask = newLength - 1; [EOL]     for (int i = 0; i < oldLength; ++i) { [EOL]         if (oldStates[i] == FULL) { [EOL]             final int key = oldKeys[i]; [EOL]             final int index = findInsertionIndex(newKeys, newStates, key, newMask); [EOL]             newKeys[index] = key; [EOL]             newValues[index] = oldValues[i]; [EOL]             newStates[index] = FULL; [EOL]         } [EOL]     } [EOL]     mask = newMask; [EOL]     keys = newKeys; [EOL]     values = newValues; [EOL]     states = newStates; [EOL] } <line_num>: 445,472
private boolean shouldGrowTable() { [EOL]     return size > (mask + 1) * LOAD_FACTOR; [EOL] } <line_num>: 478,480
private static int hashOf(final int key) { [EOL]     final int h = key ^ ((key >>> 20) ^ (key >>> 12)); [EOL]     return h ^ (h >>> 7) ^ (h >>> 4); [EOL] } <line_num>: 487,490
public boolean hasNext() { [EOL]     return next >= 0; [EOL] } <line_num>: 527,529
public int key() throws ConcurrentModificationException, NoSuchElementException { [EOL]     if (referenceCount != count) { [EOL]         throw new ConcurrentModificationException(); [EOL]     } [EOL]     if (current < 0) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     return keys[current]; [EOL] } <line_num>: 537,546
public T value() throws ConcurrentModificationException, NoSuchElementException { [EOL]     if (referenceCount != count) { [EOL]         throw new ConcurrentModificationException(); [EOL]     } [EOL]     if (current < 0) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     return values[current]; [EOL] } <line_num>: 554,563
public void advance() throws ConcurrentModificationException, NoSuchElementException { [EOL]     if (referenceCount != count) { [EOL]         throw new ConcurrentModificationException(); [EOL]     } [EOL]     current = next; [EOL]     try { [EOL]         while (states[++next] != FULL) { [EOL]         } [EOL]     } catch (ArrayIndexOutOfBoundsException e) { [EOL]         next = -2; [EOL]         if (current < 0) { [EOL]             throw new NoSuchElementException(); [EOL]         } [EOL]     } [EOL] } <line_num>: 570,592
private void readObject(final ObjectInputStream stream) throws IOException, ClassNotFoundException { [EOL]     stream.defaultReadObject(); [EOL]     count = 0; [EOL] } <line_num>: 603,607
@SuppressWarnings("unchecked") [EOL] private T[] buildArray(final int length) { [EOL]     return (T[]) Array.newInstance(field.getRuntimeClass(), length); [EOL] } <line_num>: 613,616
