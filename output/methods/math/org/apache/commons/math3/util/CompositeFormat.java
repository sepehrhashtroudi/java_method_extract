private CompositeFormat() { [EOL] } <line_num>: 34,34
public static NumberFormat getDefaultNumberFormat() { [EOL]     return getDefaultNumberFormat(Locale.getDefault()); [EOL] } <line_num>: 42,44
public static NumberFormat getDefaultNumberFormat(final Locale locale) { [EOL]     final NumberFormat nf = NumberFormat.getInstance(locale); [EOL]     nf.setMaximumFractionDigits(10); [EOL]     return nf; [EOL] } <line_num>: 53,57
public static void parseAndIgnoreWhitespace(final String source, final ParsePosition pos) { [EOL]     parseNextCharacter(source, pos); [EOL]     pos.setIndex(pos.getIndex() - 1); [EOL] } <line_num>: 66,70
public static char parseNextCharacter(final String source, final ParsePosition pos) { [EOL]     int index = pos.getIndex(); [EOL]     final int n = source.length(); [EOL]     char ret = 0; [EOL]     if (index < n) { [EOL]         char c; [EOL]         do { [EOL]             c = source.charAt(index++); [EOL]         } while (Character.isWhitespace(c) && index < n); [EOL]         pos.setIndex(index); [EOL]         if (index < n) { [EOL]             ret = c; [EOL]         } [EOL]     } [EOL]     return ret; [EOL] } <line_num>: 79,98
private static Number parseNumber(final String source, final double value, final ParsePosition pos) { [EOL]     Number ret = null; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append('('); [EOL]     sb.append(value); [EOL]     sb.append(')'); [EOL]     final int n = sb.length(); [EOL]     final int startIndex = pos.getIndex(); [EOL]     final int endIndex = startIndex + n; [EOL]     if (endIndex < source.length() && source.substring(startIndex, endIndex).compareTo(sb.toString()) == 0) { [EOL]         ret = Double.valueOf(value); [EOL]         pos.setIndex(endIndex); [EOL]     } [EOL]     return ret; [EOL] } <line_num>: 109,128
public static Number parseNumber(final String source, final NumberFormat format, final ParsePosition pos) { [EOL]     final int startIndex = pos.getIndex(); [EOL]     Number number = format.parse(source, pos); [EOL]     final int endIndex = pos.getIndex(); [EOL]     if (startIndex == endIndex) { [EOL]         final double[] special = { Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY }; [EOL]         for (int i = 0; i < special.length; ++i) { [EOL]             number = parseNumber(source, special[i], pos); [EOL]             if (number != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return number; [EOL] } <line_num>: 140,161
public static boolean parseFixedstring(final String source, final String expected, final ParsePosition pos) { [EOL]     final int startIndex = pos.getIndex(); [EOL]     final int endIndex = startIndex + expected.length(); [EOL]     if ((startIndex >= source.length()) || (endIndex > source.length()) || (source.substring(startIndex, endIndex).compareTo(expected) != 0)) { [EOL]         pos.setIndex(startIndex); [EOL]         pos.setErrorIndex(startIndex); [EOL]         return false; [EOL]     } [EOL]     pos.setIndex(endIndex); [EOL]     return true; [EOL] } <line_num>: 170,188
public static StringBuffer formatDouble(final double value, final NumberFormat format, final StringBuffer toAppendTo, final FieldPosition pos) { [EOL]     if (Double.isNaN(value) || Double.isInfinite(value)) { [EOL]         toAppendTo.append('('); [EOL]         toAppendTo.append(value); [EOL]         toAppendTo.append(')'); [EOL]     } else { [EOL]         format.format(value, toAppendTo, pos); [EOL]     } [EOL]     return toAppendTo; [EOL] } <line_num>: 207,218
