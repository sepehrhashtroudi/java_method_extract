private CombinatoricsUtils() { [EOL]     super(); [EOL] } <line_num>: 50,52
public LexicographicCombinationIterator(int n, int k) { [EOL]     this.k = k; [EOL]     c = new int[k + 3]; [EOL]     if (k == 0 || k >= n) { [EOL]         more = false; [EOL]         return; [EOL]     } [EOL]     for (int i = 1; i <= k; i++) { [EOL]         c[i] = i - 1; [EOL]     } [EOL]     c[k + 1] = n; [EOL]     c[k + 2] = 0; [EOL]     j = k; [EOL] } <line_num>: 502,517
public SingletonIterator(final int[] singleton) { [EOL]     this.singleton = singleton; [EOL] } <line_num>: 597,599
public static long binomialCoefficient(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException { [EOL]     CombinatoricsUtils.checkBinomial(n, k); [EOL]     if ((n == k) || (k == 0)) { [EOL]         return 1; [EOL]     } [EOL]     if ((k == 1) || (k == n - 1)) { [EOL]         return n; [EOL]     } [EOL]     if (k > n / 2) { [EOL]         return binomialCoefficient(n, n - k); [EOL]     } [EOL]     long result = 1; [EOL]     if (n <= 61) { [EOL]         int i = n - k + 1; [EOL]         for (int j = 1; j <= k; j++) { [EOL]             result = result * i / j; [EOL]             i++; [EOL]         } [EOL]     } else if (n <= 66) { [EOL]         int i = n - k + 1; [EOL]         for (int j = 1; j <= k; j++) { [EOL]             final long d = ArithmeticUtils.gcd(i, j); [EOL]             result = (result / (j / d)) * (i / d); [EOL]             i++; [EOL]         } [EOL]     } else { [EOL]         int i = n - k + 1; [EOL]         for (int j = 1; j <= k; j++) { [EOL]             final long d = ArithmeticUtils.gcd(i, j); [EOL]             result = ArithmeticUtils.mulAndCheck(result / (j / d), i / d); [EOL]             i++; [EOL]         } [EOL]     } [EOL]     return result; [EOL] } <line_num>: 81,135
public static double binomialCoefficientDouble(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException { [EOL]     CombinatoricsUtils.checkBinomial(n, k); [EOL]     if ((n == k) || (k == 0)) { [EOL]         return 1d; [EOL]     } [EOL]     if ((k == 1) || (k == n - 1)) { [EOL]         return n; [EOL]     } [EOL]     if (k > n / 2) { [EOL]         return binomialCoefficientDouble(n, n - k); [EOL]     } [EOL]     if (n < 67) { [EOL]         return binomialCoefficient(n, k); [EOL]     } [EOL]     double result = 1d; [EOL]     for (int i = 1; i <= k; i++) { [EOL]         result *= (double) (n - k + i) / (double) i; [EOL]     } [EOL]     return FastMath.floor(result + 0.5); [EOL] } <line_num>: 162,184
public static double binomialCoefficientLog(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException { [EOL]     CombinatoricsUtils.checkBinomial(n, k); [EOL]     if ((n == k) || (k == 0)) { [EOL]         return 0; [EOL]     } [EOL]     if ((k == 1) || (k == n - 1)) { [EOL]         return FastMath.log(n); [EOL]     } [EOL]     if (n < 67) { [EOL]         return FastMath.log(binomialCoefficient(n, k)); [EOL]     } [EOL]     if (n < 1030) { [EOL]         return FastMath.log(binomialCoefficientDouble(n, k)); [EOL]     } [EOL]     if (k > n / 2) { [EOL]         return binomialCoefficientLog(n, n - k); [EOL]     } [EOL]     double logSum = 0; [EOL]     for (int i = n - k + 1; i <= n; i++) { [EOL]         logSum += FastMath.log(i); [EOL]     } [EOL]     for (int i = 2; i <= k; i++) { [EOL]         logSum -= FastMath.log(i); [EOL]     } [EOL]     return logSum; [EOL] } <line_num>: 207,253
public static long factorial(final int n) throws NotPositiveException, MathArithmeticException { [EOL]     if (n < 0) { [EOL]         throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n); [EOL]     } [EOL]     if (n > 20) { [EOL]         throw new MathArithmeticException(); [EOL]     } [EOL]     return FACTORIALS[n]; [EOL] } <line_num>: 279,288
public static double factorialDouble(final int n) throws NotPositiveException { [EOL]     if (n < 0) { [EOL]         throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n); [EOL]     } [EOL]     if (n < 21) { [EOL]         return FACTORIALS[n]; [EOL]     } [EOL]     return FastMath.floor(FastMath.exp(CombinatoricsUtils.factorialLog(n)) + 0.5); [EOL] } <line_num>: 303,312
public static double factorialLog(final int n) throws NotPositiveException { [EOL]     if (n < 0) { [EOL]         throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n); [EOL]     } [EOL]     if (n < 21) { [EOL]         return FastMath.log(FACTORIALS[n]); [EOL]     } [EOL]     double logSum = 0; [EOL]     for (int i = 2; i <= n; i++) { [EOL]         logSum += FastMath.log(i); [EOL]     } [EOL]     return logSum; [EOL] } <line_num>: 321,334
public static long stirlingS2(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException { [EOL]     if (k < 0) { [EOL]         throw new NotPositiveException(k); [EOL]     } [EOL]     if (k > n) { [EOL]         throw new NumberIsTooLargeException(k, n, true); [EOL]     } [EOL]     long[][] stirlingS2 = STIRLING_S2.get(); [EOL]     if (stirlingS2 == null) { [EOL]         final int maxIndex = 26; [EOL]         stirlingS2 = new long[maxIndex][]; [EOL]         stirlingS2[0] = new long[] { 1l }; [EOL]         for (int i = 1; i < stirlingS2.length; ++i) { [EOL]             stirlingS2[i] = new long[i + 1]; [EOL]             stirlingS2[i][0] = 0; [EOL]             stirlingS2[i][1] = 1; [EOL]             stirlingS2[i][i] = 1; [EOL]             for (int j = 2; j < i; ++j) { [EOL]                 stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1]; [EOL]             } [EOL]         } [EOL]         STIRLING_S2.compareAndSet(null, stirlingS2); [EOL]     } [EOL]     if (n < stirlingS2.length) { [EOL]         return stirlingS2[n][k]; [EOL]     } else { [EOL]         if (k == 0) { [EOL]             return 0; [EOL]         } else if (k == 1 || k == n) { [EOL]             return 1; [EOL]         } else if (k == 2) { [EOL]             return (1l << (n - 1)) - 1l; [EOL]         } else if (k == n - 1) { [EOL]             return binomialCoefficient(n, 2); [EOL]         } else { [EOL]             long sum = 0; [EOL]             long sign = ((k & 0x1) == 0) ? 1 : -1; [EOL]             for (int j = 1; j <= k; ++j) { [EOL]                 sign = -sign; [EOL]                 sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n); [EOL]                 if (sum < 0) { [EOL]                     throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN, n, 0, stirlingS2.length - 1); [EOL]                 } [EOL]             } [EOL]             return sum / factorial(k); [EOL]         } [EOL]     } [EOL] } <line_num>: 355,420
public static Iterator<int[]> combinationsIterator(int n, int k) { [EOL]     checkBinomial(n, k); [EOL]     if (k == 0) { [EOL]         return new SingletonIterator(new int[] {}); [EOL]     } [EOL]     if (k == n) { [EOL]         final int[] natural = new int[n]; [EOL]         for (int i = 0; i < n; i++) { [EOL]             natural[i] = i; [EOL]         } [EOL]         return new SingletonIterator(natural); [EOL]     } [EOL]     return new LexicographicCombinationIterator(n, k); [EOL] } <line_num>: 442,456
public boolean hasNext() { [EOL]     return more; [EOL] } <line_num>: 522,524
public int[] next() { [EOL]     if (!more) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     final int[] ret = new int[k]; [EOL]     System.arraycopy(c, 1, ret, 0, k); [EOL]     int x = 0; [EOL]     if (j > 0) { [EOL]         x = j; [EOL]         c[j] = x; [EOL]         j--; [EOL]         return ret; [EOL]     } [EOL]     if (c[1] + 1 < c[2]) { [EOL]         c[1] = c[1] + 1; [EOL]         return ret; [EOL]     } else { [EOL]         j = 2; [EOL]     } [EOL]     boolean stepDone = false; [EOL]     while (!stepDone) { [EOL]         c[j - 1] = j - 2; [EOL]         x = c[j] + 1; [EOL]         if (x == c[j + 1]) { [EOL]             j++; [EOL]         } else { [EOL]             stepDone = true; [EOL]         } [EOL]     } [EOL]     if (j > k) { [EOL]         more = false; [EOL]         return ret; [EOL]     } [EOL]     c[j] = x; [EOL]     j--; [EOL]     return ret; [EOL] } <line_num>: 529,574
public void remove() { [EOL]     throw new UnsupportedOperationException(); [EOL] } <line_num>: 579,581
public boolean hasNext() { [EOL]     return more; [EOL] } <line_num>: 601,603
public int[] next() { [EOL]     if (more) { [EOL]         more = false; [EOL]         return singleton; [EOL]     } else { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL] } <line_num>: 605,612
public void remove() { [EOL]     throw new UnsupportedOperationException(); [EOL] } <line_num>: 614,616
private static void checkBinomial(final int n, final int k) throws NumberIsTooLargeException, NotPositiveException { [EOL]     if (n < k) { [EOL]         throw new NumberIsTooLargeException(LocalizedFormats.BINOMIAL_INVALID_PARAMETERS_ORDER, k, n, true); [EOL]     } [EOL]     if (n < 0) { [EOL]         throw new NotPositiveException(LocalizedFormats.BINOMIAL_NEGATIVE_PARAMETER, n); [EOL]     } [EOL] } <line_num>: 627,635
