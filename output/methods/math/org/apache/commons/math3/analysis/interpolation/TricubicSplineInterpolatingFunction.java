public TricubicSplineInterpolatingFunction(double[] x, double[] y, double[] z, double[][][] f, double[][][] dFdX, double[][][] dFdY, double[][][] dFdZ, double[][][] d2FdXdY, double[][][] d2FdXdZ, double[][][] d2FdYdZ, double[][][] d3FdXdYdZ) throws NoDataException, DimensionMismatchException, NonMonotonicSequenceException { [EOL]     final int xLen = x.length; [EOL]     final int yLen = y.length; [EOL]     final int zLen = z.length; [EOL]     if (xLen == 0 || yLen == 0 || z.length == 0 || f.length == 0 || f[0].length == 0) { [EOL]         throw new NoDataException(); [EOL]     } [EOL]     if (xLen != f.length) { [EOL]         throw new DimensionMismatchException(xLen, f.length); [EOL]     } [EOL]     if (xLen != dFdX.length) { [EOL]         throw new DimensionMismatchException(xLen, dFdX.length); [EOL]     } [EOL]     if (xLen != dFdY.length) { [EOL]         throw new DimensionMismatchException(xLen, dFdY.length); [EOL]     } [EOL]     if (xLen != dFdZ.length) { [EOL]         throw new DimensionMismatchException(xLen, dFdZ.length); [EOL]     } [EOL]     if (xLen != d2FdXdY.length) { [EOL]         throw new DimensionMismatchException(xLen, d2FdXdY.length); [EOL]     } [EOL]     if (xLen != d2FdXdZ.length) { [EOL]         throw new DimensionMismatchException(xLen, d2FdXdZ.length); [EOL]     } [EOL]     if (xLen != d2FdYdZ.length) { [EOL]         throw new DimensionMismatchException(xLen, d2FdYdZ.length); [EOL]     } [EOL]     if (xLen != d3FdXdYdZ.length) { [EOL]         throw new DimensionMismatchException(xLen, d3FdXdYdZ.length); [EOL]     } [EOL]     MathArrays.checkOrder(x); [EOL]     MathArrays.checkOrder(y); [EOL]     MathArrays.checkOrder(z); [EOL]     xval = x.clone(); [EOL]     yval = y.clone(); [EOL]     zval = z.clone(); [EOL]     final int lastI = xLen - 1; [EOL]     final int lastJ = yLen - 1; [EOL]     final int lastK = zLen - 1; [EOL]     splines = new TricubicSplineFunction[lastI][lastJ][lastK]; [EOL]     for (int i = 0; i < lastI; i++) { [EOL]         if (f[i].length != yLen) { [EOL]             throw new DimensionMismatchException(f[i].length, yLen); [EOL]         } [EOL]         if (dFdX[i].length != yLen) { [EOL]             throw new DimensionMismatchException(dFdX[i].length, yLen); [EOL]         } [EOL]         if (dFdY[i].length != yLen) { [EOL]             throw new DimensionMismatchException(dFdY[i].length, yLen); [EOL]         } [EOL]         if (dFdZ[i].length != yLen) { [EOL]             throw new DimensionMismatchException(dFdZ[i].length, yLen); [EOL]         } [EOL]         if (d2FdXdY[i].length != yLen) { [EOL]             throw new DimensionMismatchException(d2FdXdY[i].length, yLen); [EOL]         } [EOL]         if (d2FdXdZ[i].length != yLen) { [EOL]             throw new DimensionMismatchException(d2FdXdZ[i].length, yLen); [EOL]         } [EOL]         if (d2FdYdZ[i].length != yLen) { [EOL]             throw new DimensionMismatchException(d2FdYdZ[i].length, yLen); [EOL]         } [EOL]         if (d3FdXdYdZ[i].length != yLen) { [EOL]             throw new DimensionMismatchException(d3FdXdYdZ[i].length, yLen); [EOL]         } [EOL]         final int ip1 = i + 1; [EOL]         for (int j = 0; j < lastJ; j++) { [EOL]             if (f[i][j].length != zLen) { [EOL]                 throw new DimensionMismatchException(f[i][j].length, zLen); [EOL]             } [EOL]             if (dFdX[i][j].length != zLen) { [EOL]                 throw new DimensionMismatchException(dFdX[i][j].length, zLen); [EOL]             } [EOL]             if (dFdY[i][j].length != zLen) { [EOL]                 throw new DimensionMismatchException(dFdY[i][j].length, zLen); [EOL]             } [EOL]             if (dFdZ[i][j].length != zLen) { [EOL]                 throw new DimensionMismatchException(dFdZ[i][j].length, zLen); [EOL]             } [EOL]             if (d2FdXdY[i][j].length != zLen) { [EOL]                 throw new DimensionMismatchException(d2FdXdY[i][j].length, zLen); [EOL]             } [EOL]             if (d2FdXdZ[i][j].length != zLen) { [EOL]                 throw new DimensionMismatchException(d2FdXdZ[i][j].length, zLen); [EOL]             } [EOL]             if (d2FdYdZ[i][j].length != zLen) { [EOL]                 throw new DimensionMismatchException(d2FdYdZ[i][j].length, zLen); [EOL]             } [EOL]             if (d3FdXdYdZ[i][j].length != zLen) { [EOL]                 throw new DimensionMismatchException(d3FdXdYdZ[i][j].length, zLen); [EOL]             } [EOL]             final int jp1 = j + 1; [EOL]             for (int k = 0; k < lastK; k++) { [EOL]                 final int kp1 = k + 1; [EOL]                 final double[] beta = new double[] { f[i][j][k], f[ip1][j][k], f[i][jp1][k], f[ip1][jp1][k], f[i][j][kp1], f[ip1][j][kp1], f[i][jp1][kp1], f[ip1][jp1][kp1], dFdX[i][j][k], dFdX[ip1][j][k], dFdX[i][jp1][k], dFdX[ip1][jp1][k], dFdX[i][j][kp1], dFdX[ip1][j][kp1], dFdX[i][jp1][kp1], dFdX[ip1][jp1][kp1], dFdY[i][j][k], dFdY[ip1][j][k], dFdY[i][jp1][k], dFdY[ip1][jp1][k], dFdY[i][j][kp1], dFdY[ip1][j][kp1], dFdY[i][jp1][kp1], dFdY[ip1][jp1][kp1], dFdZ[i][j][k], dFdZ[ip1][j][k], dFdZ[i][jp1][k], dFdZ[ip1][jp1][k], dFdZ[i][j][kp1], dFdZ[ip1][j][kp1], dFdZ[i][jp1][kp1], dFdZ[ip1][jp1][kp1], d2FdXdY[i][j][k], d2FdXdY[ip1][j][k], d2FdXdY[i][jp1][k], d2FdXdY[ip1][jp1][k], d2FdXdY[i][j][kp1], d2FdXdY[ip1][j][kp1], d2FdXdY[i][jp1][kp1], d2FdXdY[ip1][jp1][kp1], d2FdXdZ[i][j][k], d2FdXdZ[ip1][j][k], d2FdXdZ[i][jp1][k], d2FdXdZ[ip1][jp1][k], d2FdXdZ[i][j][kp1], d2FdXdZ[ip1][j][kp1], d2FdXdZ[i][jp1][kp1], d2FdXdZ[ip1][jp1][kp1], d2FdYdZ[i][j][k], d2FdYdZ[ip1][j][k], d2FdYdZ[i][jp1][k], d2FdYdZ[ip1][jp1][k], d2FdYdZ[i][j][kp1], d2FdYdZ[ip1][j][kp1], d2FdYdZ[i][jp1][kp1], d2FdYdZ[ip1][jp1][kp1], d3FdXdYdZ[i][j][k], d3FdXdYdZ[ip1][j][k], d3FdXdYdZ[i][jp1][k], d3FdXdYdZ[ip1][jp1][k], d3FdXdYdZ[i][j][kp1], d3FdXdYdZ[ip1][j][kp1], d3FdXdYdZ[i][jp1][kp1], d3FdXdYdZ[ip1][jp1][kp1] }; [EOL]                 splines[i][j][k] = new TricubicSplineFunction(computeSplineCoefficients(beta)); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 137,299
public TricubicSplineFunction(double[] aV) { [EOL]     for (int i = 0; i < N; i++) { [EOL]         for (int j = 0; j < N; j++) { [EOL]             for (int k = 0; k < N; k++) { [EOL]                 a[i][j][k] = aV[i + N * (j + N * k)]; [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 429,437
public double value(double x, double y, double z) throws OutOfRangeException { [EOL]     final int i = searchIndex(x, xval); [EOL]     if (i == -1) { [EOL]         throw new OutOfRangeException(x, xval[0], xval[xval.length - 1]); [EOL]     } [EOL]     final int j = searchIndex(y, yval); [EOL]     if (j == -1) { [EOL]         throw new OutOfRangeException(y, yval[0], yval[yval.length - 1]); [EOL]     } [EOL]     final int k = searchIndex(z, zval); [EOL]     if (k == -1) { [EOL]         throw new OutOfRangeException(z, zval[0], zval[zval.length - 1]); [EOL]     } [EOL]     final double xN = (x - xval[i]) / (xval[i + 1] - xval[i]); [EOL]     final double yN = (y - yval[j]) / (yval[j + 1] - yval[j]); [EOL]     final double zN = (z - zval[k]) / (zval[k + 1] - zval[k]); [EOL]     return splines[i][j][k].value(xN, yN, zN); [EOL] } <line_num>: 306,326
private int searchIndex(double c, double[] val) { [EOL]     if (c < val[0]) { [EOL]         return -1; [EOL]     } [EOL]     final int max = val.length; [EOL]     for (int i = 1; i < max; i++) { [EOL]         if (c <= val[i]) { [EOL]             return i - 1; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] } <line_num>: 334,347
private double[] computeSplineCoefficients(double[] beta) { [EOL]     final int sz = 64; [EOL]     final double[] a = new double[sz]; [EOL]     for (int i = 0; i < sz; i++) { [EOL]         double result = 0; [EOL]         final double[] row = AINV[i]; [EOL]         for (int j = 0; j < sz; j++) { [EOL]             result += row[j] * beta[j]; [EOL]         } [EOL]         a[i] = result; [EOL]     } [EOL]     return a; [EOL] } <line_num>: 397,411
public double value(double x, double y, double z) throws OutOfRangeException { [EOL]     if (x < 0 || x > 1) { [EOL]         throw new OutOfRangeException(x, 0, 1); [EOL]     } [EOL]     if (y < 0 || y > 1) { [EOL]         throw new OutOfRangeException(y, 0, 1); [EOL]     } [EOL]     if (z < 0 || z > 1) { [EOL]         throw new OutOfRangeException(z, 0, 1); [EOL]     } [EOL]     final double x2 = x * x; [EOL]     final double x3 = x2 * x; [EOL]     final double[] pX = { 1, x, x2, x3 }; [EOL]     final double y2 = y * y; [EOL]     final double y3 = y2 * y; [EOL]     final double[] pY = { 1, y, y2, y3 }; [EOL]     final double z2 = z * z; [EOL]     final double z3 = z2 * z; [EOL]     final double[] pZ = { 1, z, z2, z3 }; [EOL]     double result = 0; [EOL]     for (int i = 0; i < N; i++) { [EOL]         for (int j = 0; j < N; j++) { [EOL]             for (int k = 0; k < N; k++) { [EOL]                 result += a[i][j][k] * pX[i] * pY[j] * pZ[k]; [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] } <line_num>: 447,481
