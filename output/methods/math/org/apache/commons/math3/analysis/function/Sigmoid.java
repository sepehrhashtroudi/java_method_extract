public Sigmoid() { [EOL]     this(0, 1); [EOL] } <line_num>: 52,54
public Sigmoid(double lo, double hi) { [EOL]     this.lo = lo; [EOL]     this.hi = hi; [EOL] } <line_num>: 62,66
@Deprecated [EOL] public UnivariateFunction derivative() { [EOL]     return FunctionUtils.toDifferentiableUnivariateFunction(this).derivative(); [EOL] } <line_num>: 71,74
public double value(double x) { [EOL]     return value(x, lo, hi); [EOL] } <line_num>: 77,79
public double value(double x, double... param) throws NullArgumentException, DimensionMismatchException { [EOL]     validateParameters(param); [EOL]     return Sigmoid.value(x, param[0], param[1]); [EOL] } <line_num>: 101,106
public double[] gradient(double x, double... param) throws NullArgumentException, DimensionMismatchException { [EOL]     validateParameters(param); [EOL]     final double invExp1 = 1 / (1 + FastMath.exp(-x)); [EOL]     return new double[] { 1 - invExp1, invExp1 }; [EOL] } <line_num>: 121,129
private void validateParameters(double[] param) throws NullArgumentException, DimensionMismatchException { [EOL]     if (param == null) { [EOL]         throw new NullArgumentException(); [EOL]     } [EOL]     if (param.length != 2) { [EOL]         throw new DimensionMismatchException(param.length, 2); [EOL]     } [EOL] } <line_num>: 141,150
private static double value(double x, double lo, double hi) { [EOL]     return lo + (hi - lo) / (1 + FastMath.exp(-x)); [EOL] } <line_num>: 159,163
public DerivativeStructure value(final DerivativeStructure t) throws DimensionMismatchException { [EOL]     double[] f = new double[t.getOrder() + 1]; [EOL]     final double exp = FastMath.exp(-t.getValue()); [EOL]     if (Double.isInfinite(exp)) { [EOL]         f[0] = lo; [EOL]         Arrays.fill(f, 1, f.length, 0.0); [EOL]     } else { [EOL]         final double[] p = new double[f.length]; [EOL]         final double inv = 1 / (1 + exp); [EOL]         double coeff = hi - lo; [EOL]         for (int n = 0; n < f.length; ++n) { [EOL]             double v = 0; [EOL]             p[n] = 1; [EOL]             for (int k = n; k >= 0; --k) { [EOL]                 v = v * exp + p[k]; [EOL]                 if (k > 1) { [EOL]                     p[k - 1] = (n - k + 2) * p[k - 2] - (k - 1) * p[k - 1]; [EOL]                 } else { [EOL]                     p[0] = 0; [EOL]                 } [EOL]             } [EOL]             coeff *= inv; [EOL]             f[n] = coeff * v; [EOL]         } [EOL]         f[0] += lo; [EOL]     } [EOL]     return t.compose(f); [EOL] } <line_num>: 168,217
