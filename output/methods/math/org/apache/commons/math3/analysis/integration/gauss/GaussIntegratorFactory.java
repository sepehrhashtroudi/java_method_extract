public GaussIntegrator legendre(int numberOfPoints) { [EOL]     return new GaussIntegrator(getRule(legendre, numberOfPoints)); [EOL] } <line_num>: 50,52
public GaussIntegrator legendre(int numberOfPoints, double lowerBound, double upperBound) throws NotStrictlyPositiveException { [EOL]     return new GaussIntegrator(transform(getRule(legendre, numberOfPoints), lowerBound, upperBound)); [EOL] } <line_num>: 66,72
public GaussIntegrator legendreHighPrecision(int numberOfPoints) throws NotStrictlyPositiveException { [EOL]     return new GaussIntegrator(getRule(legendreHighPrecision, numberOfPoints)); [EOL] } <line_num>: 85,88
public GaussIntegrator legendreHighPrecision(int numberOfPoints, double lowerBound, double upperBound) throws NotStrictlyPositiveException { [EOL]     return new GaussIntegrator(transform(getRule(legendreHighPrecision, numberOfPoints), lowerBound, upperBound)); [EOL] } <line_num>: 101,107
public SymmetricGaussIntegrator hermite(int numberOfPoints) { [EOL]     return new SymmetricGaussIntegrator(getRule(hermite, numberOfPoints)); [EOL] } <line_num>: 125,127
private static Pair<double[], double[]> getRule(BaseRuleFactory<? extends Number> factory, int numberOfPoints) throws NotStrictlyPositiveException, DimensionMismatchException { [EOL]     return factory.getRule(numberOfPoints); [EOL] } <line_num>: 137,141
private static Pair<double[], double[]> transform(Pair<double[], double[]> rule, double a, double b) { [EOL]     final double[] points = rule.getFirst(); [EOL]     final double[] weights = rule.getSecond(); [EOL]     final double scale = (b - a) / 2; [EOL]     final double shift = a + scale; [EOL]     for (int i = 0; i < points.length; i++) { [EOL]         points[i] = points[i] * scale + shift; [EOL]         weights[i] *= scale; [EOL]     } [EOL]     return new Pair<double[], double[]>(points, weights); [EOL] } <line_num>: 153,169
