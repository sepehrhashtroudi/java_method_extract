public LoessInterpolator() { [EOL]     this.bandwidth = DEFAULT_BANDWIDTH; [EOL]     this.robustnessIters = DEFAULT_ROBUSTNESS_ITERS; [EOL]     this.accuracy = DEFAULT_ACCURACY; [EOL] } <line_num>: 95,99
public LoessInterpolator(double bandwidth, int robustnessIters) { [EOL]     this(bandwidth, robustnessIters, DEFAULT_ACCURACY); [EOL] } <line_num>: 123,125
public LoessInterpolator(double bandwidth, int robustnessIters, double accuracy) throws OutOfRangeException, NotPositiveException { [EOL]     if (bandwidth < 0 || bandwidth > 1) { [EOL]         throw new OutOfRangeException(LocalizedFormats.BANDWIDTH, bandwidth, 0, 1); [EOL]     } [EOL]     this.bandwidth = bandwidth; [EOL]     if (robustnessIters < 0) { [EOL]         throw new NotPositiveException(LocalizedFormats.ROBUSTNESS_ITERATIONS, robustnessIters); [EOL]     } [EOL]     this.robustnessIters = robustnessIters; [EOL]     this.accuracy = accuracy; [EOL] } <line_num>: 148,161
public final PolynomialSplineFunction interpolate(final double[] xval, final double[] yval) throws NonMonotonicSequenceException, DimensionMismatchException, NoDataException, NotFiniteNumberException, NumberIsTooSmallException { [EOL]     return new SplineInterpolator().interpolate(xval, smooth(xval, yval)); [EOL] } <line_num>: 184,192
public final double[] smooth(final double[] xval, final double[] yval, final double[] weights) throws NonMonotonicSequenceException, DimensionMismatchException, NoDataException, NotFiniteNumberException, NumberIsTooSmallException { [EOL]     if (xval.length != yval.length) { [EOL]         throw new DimensionMismatchException(xval.length, yval.length); [EOL]     } [EOL]     final int n = xval.length; [EOL]     if (n == 0) { [EOL]         throw new NoDataException(); [EOL]     } [EOL]     checkAllFiniteReal(xval); [EOL]     checkAllFiniteReal(yval); [EOL]     checkAllFiniteReal(weights); [EOL]     MathArrays.checkOrder(xval); [EOL]     if (n == 1) { [EOL]         return new double[] { yval[0] }; [EOL]     } [EOL]     if (n == 2) { [EOL]         return new double[] { yval[0], yval[1] }; [EOL]     } [EOL]     int bandwidthInPoints = (int) (bandwidth * n); [EOL]     if (bandwidthInPoints < 2) { [EOL]         throw new NumberIsTooSmallException(LocalizedFormats.BANDWIDTH, bandwidthInPoints, 2, true); [EOL]     } [EOL]     final double[] res = new double[n]; [EOL]     final double[] residuals = new double[n]; [EOL]     final double[] sortedResiduals = new double[n]; [EOL]     final double[] robustnessWeights = new double[n]; [EOL]     Arrays.fill(robustnessWeights, 1); [EOL]     for (int iter = 0; iter <= robustnessIters; ++iter) { [EOL]         final int[] bandwidthInterval = { 0, bandwidthInPoints - 1 }; [EOL]         for (int i = 0; i < n; ++i) { [EOL]             final double x = xval[i]; [EOL]             if (i > 0) { [EOL]                 updateBandwidthInterval(xval, weights, i, bandwidthInterval); [EOL]             } [EOL]             final int ileft = bandwidthInterval[0]; [EOL]             final int iright = bandwidthInterval[1]; [EOL]             final int edge; [EOL]             if (xval[i] - xval[ileft] > xval[iright] - xval[i]) { [EOL]                 edge = ileft; [EOL]             } else { [EOL]                 edge = iright; [EOL]             } [EOL]             double sumWeights = 0; [EOL]             double sumX = 0; [EOL]             double sumXSquared = 0; [EOL]             double sumY = 0; [EOL]             double sumXY = 0; [EOL]             double denom = FastMath.abs(1.0 / (xval[edge] - x)); [EOL]             for (int k = ileft; k <= iright; ++k) { [EOL]                 final double xk = xval[k]; [EOL]                 final double yk = yval[k]; [EOL]                 final double dist = (k < i) ? x - xk : xk - x; [EOL]                 final double w = tricube(dist * denom) * robustnessWeights[k] * weights[k]; [EOL]                 final double xkw = xk * w; [EOL]                 sumWeights += w; [EOL]                 sumX += xkw; [EOL]                 sumXSquared += xk * xkw; [EOL]                 sumY += yk * w; [EOL]                 sumXY += yk * xkw; [EOL]             } [EOL]             final double meanX = sumX / sumWeights; [EOL]             final double meanY = sumY / sumWeights; [EOL]             final double meanXY = sumXY / sumWeights; [EOL]             final double meanXSquared = sumXSquared / sumWeights; [EOL]             final double beta; [EOL]             if (FastMath.sqrt(FastMath.abs(meanXSquared - meanX * meanX)) < accuracy) { [EOL]                 beta = 0; [EOL]             } else { [EOL]                 beta = (meanXY - meanX * meanY) / (meanXSquared - meanX * meanX); [EOL]             } [EOL]             final double alpha = meanY - beta * meanX; [EOL]             res[i] = beta * x + alpha; [EOL]             residuals[i] = FastMath.abs(yval[i] - res[i]); [EOL]         } [EOL]         if (iter == robustnessIters) { [EOL]             break; [EOL]         } [EOL]         System.arraycopy(residuals, 0, sortedResiduals, 0, n); [EOL]         Arrays.sort(sortedResiduals); [EOL]         final double medianResidual = sortedResiduals[n / 2]; [EOL]         if (FastMath.abs(medianResidual) < accuracy) { [EOL]             break; [EOL]         } [EOL]         for (int i = 0; i < n; ++i) { [EOL]             final double arg = residuals[i] / (6 * medianResidual); [EOL]             if (arg >= 1) { [EOL]                 robustnessWeights[i] = 0; [EOL]             } else { [EOL]                 final double w = 1 - arg * arg; [EOL]                 robustnessWeights[i] = w * w; [EOL]             } [EOL]         } [EOL]     } [EOL]     return res; [EOL] } <line_num>: 214,363
public final double[] smooth(final double[] xval, final double[] yval) throws NonMonotonicSequenceException, DimensionMismatchException, NoDataException, NotFiniteNumberException, NumberIsTooSmallException { [EOL]     if (xval.length != yval.length) { [EOL]         throw new DimensionMismatchException(xval.length, yval.length); [EOL]     } [EOL]     final double[] unitWeights = new double[xval.length]; [EOL]     Arrays.fill(unitWeights, 1.0); [EOL]     return smooth(xval, yval, unitWeights); [EOL] } <line_num>: 382,396
private static void updateBandwidthInterval(final double[] xval, final double[] weights, final int i, final int[] bandwidthInterval) { [EOL]     final int left = bandwidthInterval[0]; [EOL]     final int right = bandwidthInterval[1]; [EOL]     int nextRight = nextNonzero(weights, right); [EOL]     if (nextRight < xval.length && xval[nextRight] - xval[i] < xval[i] - xval[left]) { [EOL]         int nextLeft = nextNonzero(weights, bandwidthInterval[0]); [EOL]         bandwidthInterval[0] = nextLeft; [EOL]         bandwidthInterval[1] = nextRight; [EOL]     } [EOL] } <line_num>: 413,427
private static int nextNonzero(final double[] weights, final int i) { [EOL]     int j = i + 1; [EOL]     while (j < weights.length && weights[j] == 0) { [EOL]         ++j; [EOL]     } [EOL]     return j; [EOL] } <line_num>: 437,443
private static double tricube(final double x) { [EOL]     final double absX = FastMath.abs(x); [EOL]     if (absX >= 1.0) { [EOL]         return 0.0; [EOL]     } [EOL]     final double tmp = 1 - absX * absX * absX; [EOL]     return tmp * tmp * tmp; [EOL] } <line_num>: 453,460
private static void checkAllFiniteReal(final double[] values) { [EOL]     for (int i = 0; i < values.length; i++) { [EOL]         MathUtils.checkFinite(values[i]); [EOL]     } [EOL] } <line_num>: 469,473
