private PolynomialsUtils() { [EOL] } <line_num>: 89,90
public JacobiKey(final int v, final int w) { [EOL]     this.v = v; [EOL]     this.w = w; [EOL] } <line_num>: 268,271
public BigFraction[] generate(int k) { [EOL]     return coeffs; [EOL] } <line_num>: 110,112
public static PolynomialFunction createChebyshevPolynomial(final int degree) { [EOL]     return buildPolynomial(degree, CHEBYSHEV_COEFFICIENTS, new RecurrenceCoefficientsGenerator() { [EOL]  [EOL]         private final BigFraction[] coeffs = { BigFraction.ZERO, BigFraction.TWO, BigFraction.ONE }; [EOL]  [EOL]         public BigFraction[] generate(int k) { [EOL]             return coeffs; [EOL]         } [EOL]     }); [EOL] } <line_num>: 105,114
public BigFraction[] generate(int k) { [EOL]     return new BigFraction[] { BigFraction.ZERO, BigFraction.TWO, new BigFraction(2 * k) }; [EOL] } <line_num>: 134,139
public static PolynomialFunction createHermitePolynomial(final int degree) { [EOL]     return buildPolynomial(degree, HERMITE_COEFFICIENTS, new RecurrenceCoefficientsGenerator() { [EOL]  [EOL]         public BigFraction[] generate(int k) { [EOL]             return new BigFraction[] { BigFraction.ZERO, BigFraction.TWO, new BigFraction(2 * k) }; [EOL]         } [EOL]     }); [EOL] } <line_num>: 130,141
public BigFraction[] generate(int k) { [EOL]     final int kP1 = k + 1; [EOL]     return new BigFraction[] { new BigFraction(2 * k + 1, kP1), new BigFraction(-1, kP1), new BigFraction(k, kP1) }; [EOL] } <line_num>: 160,166
public static PolynomialFunction createLaguerrePolynomial(final int degree) { [EOL]     return buildPolynomial(degree, LAGUERRE_COEFFICIENTS, new RecurrenceCoefficientsGenerator() { [EOL]  [EOL]         public BigFraction[] generate(int k) { [EOL]             final int kP1 = k + 1; [EOL]             return new BigFraction[] { new BigFraction(2 * k + 1, kP1), new BigFraction(-1, kP1), new BigFraction(k, kP1) }; [EOL]         } [EOL]     }); [EOL] } <line_num>: 156,168
public BigFraction[] generate(int k) { [EOL]     final int kP1 = k + 1; [EOL]     return new BigFraction[] { BigFraction.ZERO, new BigFraction(k + kP1, kP1), new BigFraction(k, kP1) }; [EOL] } <line_num>: 187,193
public static PolynomialFunction createLegendrePolynomial(final int degree) { [EOL]     return buildPolynomial(degree, LEGENDRE_COEFFICIENTS, new RecurrenceCoefficientsGenerator() { [EOL]  [EOL]         public BigFraction[] generate(int k) { [EOL]             final int kP1 = k + 1; [EOL]             return new BigFraction[] { BigFraction.ZERO, new BigFraction(k + kP1, kP1), new BigFraction(k, kP1) }; [EOL]         } [EOL]     }); [EOL] } <line_num>: 183,195
public BigFraction[] generate(int k) { [EOL]     k++; [EOL]     final int kvw = k + v + w; [EOL]     final int twoKvw = kvw + k; [EOL]     final int twoKvwM1 = twoKvw - 1; [EOL]     final int twoKvwM2 = twoKvw - 2; [EOL]     final int den = 2 * k * kvw * twoKvwM2; [EOL]     return new BigFraction[] { new BigFraction(twoKvwM1 * (v * v - w * w), den), new BigFraction(twoKvwM1 * twoKvw * twoKvwM2, den), new BigFraction(2 * (k + v - 1) * (k + w - 1) * twoKvw, den) }; [EOL] } <line_num>: 237,250
public static PolynomialFunction createJacobiPolynomial(final int degree, final int v, final int w) { [EOL]     final JacobiKey key = new JacobiKey(v, w); [EOL]     if (!JACOBI_COEFFICIENTS.containsKey(key)) { [EOL]         final List<BigFraction> list = new ArrayList<BigFraction>(); [EOL]         JACOBI_COEFFICIENTS.put(key, list); [EOL]         list.add(BigFraction.ONE); [EOL]         list.add(new BigFraction(v - w, 2)); [EOL]         list.add(new BigFraction(2 + v + w, 2)); [EOL]     } [EOL]     return buildPolynomial(degree, JACOBI_COEFFICIENTS.get(key), new RecurrenceCoefficientsGenerator() { [EOL]  [EOL]         public BigFraction[] generate(int k) { [EOL]             k++; [EOL]             final int kvw = k + v + w; [EOL]             final int twoKvw = kvw + k; [EOL]             final int twoKvwM1 = twoKvw - 1; [EOL]             final int twoKvwM2 = twoKvw - 2; [EOL]             final int den = 2 * k * kvw * twoKvwM2; [EOL]             return new BigFraction[] { new BigFraction(twoKvwM1 * (v * v - w * w), den), new BigFraction(twoKvwM1 * twoKvw * twoKvwM2, den), new BigFraction(2 * (k + v - 1) * (k + w - 1) * twoKvw, den) }; [EOL]         } [EOL]     }); [EOL] } <line_num>: 214,253
@Override [EOL] public int hashCode() { [EOL]     return (v << 16) ^ w; [EOL] } <line_num>: 276,279
@Override [EOL] public boolean equals(final Object key) { [EOL]     if ((key == null) || !(key instanceof JacobiKey)) { [EOL]         return false; [EOL]     } [EOL]     final JacobiKey otherK = (JacobiKey) key; [EOL]     return (v == otherK.v) && (w == otherK.w); [EOL] } <line_num>: 285,295
public static double[] shift(final double[] coefficients, final double shift) { [EOL]     final int dp1 = coefficients.length; [EOL]     final double[] newCoefficients = new double[dp1]; [EOL]     final int[][] coeff = new int[dp1][dp1]; [EOL]     for (int i = 0; i < dp1; i++) { [EOL]         for (int j = 0; j <= i; j++) { [EOL]             coeff[i][j] = (int) CombinatoricsUtils.binomialCoefficient(i, j); [EOL]         } [EOL]     } [EOL]     for (int i = 0; i < dp1; i++) { [EOL]         newCoefficients[0] += coefficients[i] * FastMath.pow(shift, i); [EOL]     } [EOL]     final int d = dp1 - 1; [EOL]     for (int i = 0; i < d; i++) { [EOL]         for (int j = i; j < d; j++) { [EOL]             newCoefficients[i + 1] += coeff[j + 1][j - i] * coefficients[j + 1] * FastMath.pow(shift, j - i); [EOL]         } [EOL]     } [EOL]     return newCoefficients; [EOL] } <line_num>: 322,350
private static PolynomialFunction buildPolynomial(final int degree, final List<BigFraction> coefficients, final RecurrenceCoefficientsGenerator generator) { [EOL]     final int maxDegree = (int) FastMath.floor(FastMath.sqrt(2 * coefficients.size())) - 1; [EOL]     synchronized (PolynomialsUtils.class) { [EOL]         if (degree > maxDegree) { [EOL]             computeUpToDegree(degree, maxDegree, generator, coefficients); [EOL]         } [EOL]     } [EOL]     final int start = degree * (degree + 1) / 2; [EOL]     final double[] a = new double[degree + 1]; [EOL]     for (int i = 0; i <= degree; ++i) { [EOL]         a[i] = coefficients.get(start + i).doubleValue(); [EOL]     } [EOL]     return new PolynomialFunction(a); [EOL] } <line_num>: 359,388
private static void computeUpToDegree(final int degree, final int maxDegree, final RecurrenceCoefficientsGenerator generator, final List<BigFraction> coefficients) { [EOL]     int startK = (maxDegree - 1) * maxDegree / 2; [EOL]     for (int k = maxDegree; k < degree; ++k) { [EOL]         int startKm1 = startK; [EOL]         startK += k; [EOL]         BigFraction[] ai = generator.generate(k); [EOL]         BigFraction ck = coefficients.get(startK); [EOL]         BigFraction ckm1 = coefficients.get(startKm1); [EOL]         coefficients.add(ck.multiply(ai[0]).subtract(ckm1.multiply(ai[2]))); [EOL]         for (int i = 1; i < k; ++i) { [EOL]             final BigFraction ckPrev = ck; [EOL]             ck = coefficients.get(startK + i); [EOL]             ckm1 = coefficients.get(startKm1 + i); [EOL]             coefficients.add(ck.multiply(ai[0]).add(ckPrev.multiply(ai[1])).subtract(ckm1.multiply(ai[2]))); [EOL]         } [EOL]         final BigFraction ckPrev = ck; [EOL]         ck = coefficients.get(startK + k); [EOL]         coefficients.add(ck.multiply(ai[0]).add(ckPrev.multiply(ai[1]))); [EOL]         coefficients.add(ck.multiply(ai[1])); [EOL]     } [EOL] } <line_num>: 396,434
BigFraction[] generate(int k); <line_num>: 444,444
