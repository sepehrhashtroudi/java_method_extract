@Override [EOL] protected Pair<Double[], Double[]> computeRule(int numberOfPoints) throws DimensionMismatchException { [EOL]     if (numberOfPoints == 1) { [EOL]         return new Pair<Double[], Double[]>(new Double[] { 0d }, new Double[] { SQRT_PI }); [EOL]     } [EOL]     final int lastNumPoints = numberOfPoints - 1; [EOL]     final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst(); [EOL]     final Double[] points = new Double[numberOfPoints]; [EOL]     final Double[] weights = new Double[numberOfPoints]; [EOL]     final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints); [EOL]     final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints); [EOL]     final int iMax = numberOfPoints / 2; [EOL]     for (int i = 0; i < iMax; i++) { [EOL]         double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue(); [EOL]         double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue(); [EOL]         double hma = H0; [EOL]         double ha = H1 * a; [EOL]         double hmb = H0; [EOL]         double hb = H1 * b; [EOL]         for (int j = 1; j < numberOfPoints; j++) { [EOL]             final double jp1 = j + 1; [EOL]             final double s = FastMath.sqrt(2 / jp1); [EOL]             final double sm = FastMath.sqrt(j / jp1); [EOL]             final double hpa = s * a * ha - sm * hma; [EOL]             final double hpb = s * b * hb - sm * hmb; [EOL]             hma = ha; [EOL]             ha = hpa; [EOL]             hmb = hb; [EOL]             hb = hpb; [EOL]         } [EOL]         double c = 0.5 * (a + b); [EOL]         double hmc = H0; [EOL]         double hc = H1 * c; [EOL]         boolean done = false; [EOL]         while (!done) { [EOL]             done = b - a <= Math.ulp(c); [EOL]             hmc = H0; [EOL]             hc = H1 * c; [EOL]             for (int j = 1; j < numberOfPoints; j++) { [EOL]                 final double jp1 = j + 1; [EOL]                 final double s = FastMath.sqrt(2 / jp1); [EOL]                 final double sm = FastMath.sqrt(j / jp1); [EOL]                 final double hpc = s * c * hc - sm * hmc; [EOL]                 hmc = hc; [EOL]                 hc = hpc; [EOL]             } [EOL]             if (!done) { [EOL]                 if (ha * hc < 0) { [EOL]                     b = c; [EOL]                     hmb = hmc; [EOL]                     hb = hc; [EOL]                 } else { [EOL]                     a = c; [EOL]                     hma = hmc; [EOL]                     ha = hc; [EOL]                 } [EOL]                 c = 0.5 * (a + b); [EOL]             } [EOL]         } [EOL]         final double d = sqrtTwoTimesNumPoints * hmc; [EOL]         final double w = 2 / (d * d); [EOL]         points[i] = c; [EOL]         weights[i] = w; [EOL]         final int idx = lastNumPoints - i; [EOL]         points[idx] = -c; [EOL]         weights[idx] = w; [EOL]     } [EOL]     if (numberOfPoints % 2 != 0) { [EOL]         double hm = H0; [EOL]         for (int j = 1; j < numberOfPoints; j += 2) { [EOL]             final double jp1 = j + 1; [EOL]             hm = -FastMath.sqrt(j / jp1) * hm; [EOL]         } [EOL]         final double d = sqrtTwoTimesNumPoints * hm; [EOL]         final double w = 2 / (d * d); [EOL]         points[iMax] = 0d; [EOL]         weights[iMax] = w; [EOL]     } [EOL]     return new Pair<Double[], Double[]>(points, weights); [EOL] } <line_num>: 62,178
