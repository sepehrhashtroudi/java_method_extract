public LaguerreSolver() { [EOL]     this(DEFAULT_ABSOLUTE_ACCURACY); [EOL] } <line_num>: 54,56
public LaguerreSolver(double absoluteAccuracy) { [EOL]     super(absoluteAccuracy); [EOL] } <line_num>: 62,64
public LaguerreSolver(double relativeAccuracy, double absoluteAccuracy) { [EOL]     super(relativeAccuracy, absoluteAccuracy); [EOL] } <line_num>: 71,74
public LaguerreSolver(double relativeAccuracy, double absoluteAccuracy, double functionValueAccuracy) { [EOL]     super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy); [EOL] } <line_num>: 82,86
@Override [EOL] public double doSolve() throws TooManyEvaluationsException, NumberIsTooLargeException, NoBracketingException { [EOL]     final double min = getMin(); [EOL]     final double max = getMax(); [EOL]     final double initial = getStartValue(); [EOL]     final double functionValueAccuracy = getFunctionValueAccuracy(); [EOL]     verifySequence(min, initial, max); [EOL]     final double yInitial = computeObjectiveValue(initial); [EOL]     if (FastMath.abs(yInitial) <= functionValueAccuracy) { [EOL]         return initial; [EOL]     } [EOL]     final double yMin = computeObjectiveValue(min); [EOL]     if (FastMath.abs(yMin) <= functionValueAccuracy) { [EOL]         return min; [EOL]     } [EOL]     if (yInitial * yMin < 0) { [EOL]         return laguerre(min, initial, yMin, yInitial); [EOL]     } [EOL]     final double yMax = computeObjectiveValue(max); [EOL]     if (FastMath.abs(yMax) <= functionValueAccuracy) { [EOL]         return max; [EOL]     } [EOL]     if (yInitial * yMax < 0) { [EOL]         return laguerre(initial, max, yInitial, yMax); [EOL]     } [EOL]     throw new NoBracketingException(min, max, yMin, yMax); [EOL] } <line_num>: 91,132
@Deprecated [EOL] public double laguerre(double lo, double hi, double fLo, double fHi) { [EOL]     final Complex[] c = ComplexUtils.convertToComplex(getCoefficients()); [EOL]     final Complex initial = new Complex(0.5 * (lo + hi), 0); [EOL]     final Complex z = complexSolver.solve(c, initial); [EOL]     if (complexSolver.isRoot(lo, hi, z)) { [EOL]         return z.getReal(); [EOL]     } else { [EOL]         double r = Double.NaN; [EOL]         Complex[] root = complexSolver.solveAll(c, initial); [EOL]         for (int i = 0; i < root.length; i++) { [EOL]             if (complexSolver.isRoot(lo, hi, root[i])) { [EOL]                 r = root[i].getReal(); [EOL]                 break; [EOL]             } [EOL]         } [EOL]         return r; [EOL]     } [EOL] } <line_num>: 154,175
public Complex[] solveAllComplex(double[] coefficients, double initial) throws NullArgumentException, NoDataException, TooManyEvaluationsException { [EOL]     setup(Integer.MAX_VALUE, new PolynomialFunction(coefficients), Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, initial); [EOL]     return complexSolver.solveAll(ComplexUtils.convertToComplex(coefficients), new Complex(initial, 0d)); [EOL] } <line_num>: 193,205
public Complex solveComplex(double[] coefficients, double initial) throws NullArgumentException, NoDataException, TooManyEvaluationsException { [EOL]     setup(Integer.MAX_VALUE, new PolynomialFunction(coefficients), Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, initial); [EOL]     return complexSolver.solve(ComplexUtils.convertToComplex(coefficients), new Complex(initial, 0d)); [EOL] } <line_num>: 223,235
public boolean isRoot(double min, double max, Complex z) { [EOL]     if (isSequence(min, z.getReal(), max)) { [EOL]         double tolerance = FastMath.max(getRelativeAccuracy() * z.abs(), getAbsoluteAccuracy()); [EOL]         return (FastMath.abs(z.getImaginary()) <= tolerance) || (z.abs() <= getFunctionValueAccuracy()); [EOL]     } [EOL]     return false; [EOL] } <line_num>: 250,257
public Complex[] solveAll(Complex[] coefficients, Complex initial) throws NullArgumentException, NoDataException, TooManyEvaluationsException { [EOL]     if (coefficients == null) { [EOL]         throw new NullArgumentException(); [EOL]     } [EOL]     final int n = coefficients.length - 1; [EOL]     if (n == 0) { [EOL]         throw new NoDataException(LocalizedFormats.POLYNOMIAL); [EOL]     } [EOL]     final Complex[] c = new Complex[n + 1]; [EOL]     for (int i = 0; i <= n; i++) { [EOL]         c[i] = coefficients[i]; [EOL]     } [EOL]     final Complex[] root = new Complex[n]; [EOL]     for (int i = 0; i < n; i++) { [EOL]         final Complex[] subarray = new Complex[n - i + 1]; [EOL]         System.arraycopy(c, 0, subarray, 0, subarray.length); [EOL]         root[i] = solve(subarray, initial); [EOL]         Complex newc = c[n - i]; [EOL]         Complex oldc = null; [EOL]         for (int j = n - i - 1; j >= 0; j--) { [EOL]             oldc = c[j]; [EOL]             c[j] = newc; [EOL]             newc = oldc.add(newc.multiply(root[i])); [EOL]         } [EOL]     } [EOL]     return root; [EOL] } <line_num>: 272,306
public Complex solve(Complex[] coefficients, Complex initial) throws NullArgumentException, NoDataException, TooManyEvaluationsException { [EOL]     if (coefficients == null) { [EOL]         throw new NullArgumentException(); [EOL]     } [EOL]     final int n = coefficients.length - 1; [EOL]     if (n == 0) { [EOL]         throw new NoDataException(LocalizedFormats.POLYNOMIAL); [EOL]     } [EOL]     final double absoluteAccuracy = getAbsoluteAccuracy(); [EOL]     final double relativeAccuracy = getRelativeAccuracy(); [EOL]     final double functionValueAccuracy = getFunctionValueAccuracy(); [EOL]     final Complex nC = new Complex(n, 0); [EOL]     final Complex n1C = new Complex(n - 1, 0); [EOL]     Complex z = initial; [EOL]     Complex oldz = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY); [EOL]     while (true) { [EOL]         Complex pv = coefficients[n]; [EOL]         Complex dv = Complex.ZERO; [EOL]         Complex d2v = Complex.ZERO; [EOL]         for (int j = n - 1; j >= 0; j--) { [EOL]             d2v = dv.add(z.multiply(d2v)); [EOL]             dv = pv.add(z.multiply(dv)); [EOL]             pv = coefficients[j].add(z.multiply(pv)); [EOL]         } [EOL]         d2v = d2v.multiply(new Complex(2.0, 0.0)); [EOL]         final double tolerance = FastMath.max(relativeAccuracy * z.abs(), absoluteAccuracy); [EOL]         if ((z.subtract(oldz)).abs() <= tolerance) { [EOL]             return z; [EOL]         } [EOL]         if (pv.abs() <= functionValueAccuracy) { [EOL]             return z; [EOL]         } [EOL]         final Complex G = dv.divide(pv); [EOL]         final Complex G2 = G.multiply(G); [EOL]         final Complex H = G2.subtract(d2v.divide(pv)); [EOL]         final Complex delta = n1C.multiply((nC.multiply(H)).subtract(G2)); [EOL]         final Complex deltaSqrt = delta.sqrt(); [EOL]         final Complex dplus = G.add(deltaSqrt); [EOL]         final Complex dminus = G.subtract(deltaSqrt); [EOL]         final Complex denominator = dplus.abs() > dminus.abs() ? dplus : dminus; [EOL]         if (denominator.equals(new Complex(0.0, 0.0))) { [EOL]             z = z.add(new Complex(absoluteAccuracy, absoluteAccuracy)); [EOL]             oldz = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY); [EOL]         } else { [EOL]             oldz = z; [EOL]             z = z.subtract(nC.divide(denominator)); [EOL]         } [EOL]         incrementEvaluationCount(); [EOL]     } [EOL] } <line_num>: 321,389
