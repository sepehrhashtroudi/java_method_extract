public Gaussian(double norm, double mean, double sigma) throws NotStrictlyPositiveException { [EOL]     if (sigma <= 0) { [EOL]         throw new NotStrictlyPositiveException(sigma); [EOL]     } [EOL]     this.norm = norm; [EOL]     this.mean = mean; [EOL]     this.is = 1 / sigma; [EOL]     this.i2s2 = 0.5 * is * is; [EOL] } <line_num>: 59,71
public Gaussian(double mean, double sigma) throws NotStrictlyPositiveException { [EOL]     this(1 / (sigma * FastMath.sqrt(2 * Math.PI)), mean, sigma); [EOL] } <line_num>: 80,84
public Gaussian() { [EOL]     this(0, 1); [EOL] } <line_num>: 89,91
public double value(double x) { [EOL]     return value(x - mean, norm, i2s2); [EOL] } <line_num>: 94,96
@Deprecated [EOL] public UnivariateFunction derivative() { [EOL]     return FunctionUtils.toDifferentiableUnivariateFunction(this).derivative(); [EOL] } <line_num>: 101,104
public double value(double x, double... param) throws NullArgumentException, DimensionMismatchException, NotStrictlyPositiveException { [EOL]     validateParameters(param); [EOL]     final double diff = x - param[1]; [EOL]     final double i2s2 = 1 / (2 * param[2] * param[2]); [EOL]     return Gaussian.value(diff, param[0], i2s2); [EOL] } <line_num>: 127,136
public double[] gradient(double x, double... param) throws NullArgumentException, DimensionMismatchException, NotStrictlyPositiveException { [EOL]     validateParameters(param); [EOL]     final double norm = param[0]; [EOL]     final double diff = x - param[1]; [EOL]     final double sigma = param[2]; [EOL]     final double i2s2 = 1 / (2 * sigma * sigma); [EOL]     final double n = Gaussian.value(diff, 1, i2s2); [EOL]     final double m = norm * n * 2 * i2s2 * diff; [EOL]     final double s = m * diff / sigma; [EOL]     return new double[] { n, m, s }; [EOL] } <line_num>: 152,168
private void validateParameters(double[] param) throws NullArgumentException, DimensionMismatchException, NotStrictlyPositiveException { [EOL]     if (param == null) { [EOL]         throw new NullArgumentException(); [EOL]     } [EOL]     if (param.length != 3) { [EOL]         throw new DimensionMismatchException(param.length, 3); [EOL]     } [EOL]     if (param[2] <= 0) { [EOL]         throw new NotStrictlyPositiveException(param[2]); [EOL]     } [EOL] } <line_num>: 181,194
private static double value(double xMinusMean, double norm, double i2s2) { [EOL]     return norm * FastMath.exp(-xMinusMean * xMinusMean * i2s2); [EOL] } <line_num>: 203,207
public DerivativeStructure value(final DerivativeStructure t) throws DimensionMismatchException { [EOL]     final double u = is * (t.getValue() - mean); [EOL]     double[] f = new double[t.getOrder() + 1]; [EOL]     final double[] p = new double[f.length]; [EOL]     p[0] = 1; [EOL]     final double u2 = u * u; [EOL]     double coeff = norm * FastMath.exp(-0.5 * u2); [EOL]     if (coeff <= Precision.SAFE_MIN) { [EOL]         Arrays.fill(f, 0.0); [EOL]     } else { [EOL]         f[0] = coeff; [EOL]         for (int n = 1; n < f.length; ++n) { [EOL]             double v = 0; [EOL]             p[n] = -p[n - 1]; [EOL]             for (int k = n; k >= 0; k -= 2) { [EOL]                 v = v * u2 + p[k]; [EOL]                 if (k > 2) { [EOL]                     p[k - 2] = (k - 1) * p[k - 1] - p[k - 3]; [EOL]                 } else if (k == 2) { [EOL]                     p[0] = p[1]; [EOL]                 } [EOL]             } [EOL]             if ((n & 0x1) == 1) { [EOL]                 v *= u; [EOL]             } [EOL]             coeff *= is; [EOL]             f[n] = coeff * v; [EOL]         } [EOL]     } [EOL]     return t.compose(f); [EOL] } <line_num>: 212,258
