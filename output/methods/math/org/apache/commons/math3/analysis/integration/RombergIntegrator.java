public RombergIntegrator(final double relativeAccuracy, final double absoluteAccuracy, final int minimalIterationCount, final int maximalIterationCount) throws NotStrictlyPositiveException, NumberIsTooSmallException, NumberIsTooLargeException { [EOL]     super(relativeAccuracy, absoluteAccuracy, minimalIterationCount, maximalIterationCount); [EOL]     if (maximalIterationCount > ROMBERG_MAX_ITERATIONS_COUNT) { [EOL]         throw new NumberIsTooLargeException(maximalIterationCount, ROMBERG_MAX_ITERATIONS_COUNT, false); [EOL]     } [EOL] } <line_num>: 58,68
public RombergIntegrator(final int minimalIterationCount, final int maximalIterationCount) throws NotStrictlyPositiveException, NumberIsTooSmallException, NumberIsTooLargeException { [EOL]     super(minimalIterationCount, maximalIterationCount); [EOL]     if (maximalIterationCount > ROMBERG_MAX_ITERATIONS_COUNT) { [EOL]         throw new NumberIsTooLargeException(maximalIterationCount, ROMBERG_MAX_ITERATIONS_COUNT, false); [EOL]     } [EOL] } <line_num>: 82,90
public RombergIntegrator() { [EOL]     super(DEFAULT_MIN_ITERATIONS_COUNT, ROMBERG_MAX_ITERATIONS_COUNT); [EOL] } <line_num>: 96,98
@Override [EOL] protected double doIntegrate() throws TooManyEvaluationsException, MaxCountExceededException { [EOL]     final int m = iterations.getMaximalCount() + 1; [EOL]     double[] previousRow = new double[m]; [EOL]     double[] currentRow = new double[m]; [EOL]     TrapezoidIntegrator qtrap = new TrapezoidIntegrator(); [EOL]     currentRow[0] = qtrap.stage(this, 0); [EOL]     iterations.incrementCount(); [EOL]     double olds = currentRow[0]; [EOL]     while (true) { [EOL]         final int i = iterations.getCount(); [EOL]         final double[] tmpRow = previousRow; [EOL]         previousRow = currentRow; [EOL]         currentRow = tmpRow; [EOL]         currentRow[0] = qtrap.stage(this, i); [EOL]         iterations.incrementCount(); [EOL]         for (int j = 1; j <= i; j++) { [EOL]             final double r = (1L << (2 * j)) - 1; [EOL]             final double tIJm1 = currentRow[j - 1]; [EOL]             currentRow[j] = tIJm1 + (tIJm1 - previousRow[j - 1]) / r; [EOL]         } [EOL]         final double s = currentRow[i]; [EOL]         if (i >= getMinimalIterationCount()) { [EOL]             final double delta = FastMath.abs(s - olds); [EOL]             final double rLimit = getRelativeAccuracy() * (FastMath.abs(olds) + FastMath.abs(s)) * 0.5; [EOL]             if ((delta <= rLimit) || (delta <= getAbsoluteAccuracy())) { [EOL]                 return s; [EOL]             } [EOL]         } [EOL]         olds = s; [EOL]     } [EOL] } <line_num>: 101,141
