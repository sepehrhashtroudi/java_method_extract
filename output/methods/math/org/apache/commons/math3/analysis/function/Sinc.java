public Sinc() { [EOL]     this(false); [EOL] } <line_num>: 71,73
public Sinc(boolean normalized) { [EOL]     this.normalized = normalized; [EOL] } <line_num>: 81,83
public double value(final double x) { [EOL]     final double scaledX = normalized ? FastMath.PI * x : x; [EOL]     if (FastMath.abs(scaledX) <= SHORTCUT) { [EOL]         final double scaledX2 = scaledX * scaledX; [EOL]         return ((scaledX2 - 20) * scaledX2 + 120) / 120; [EOL]     } else { [EOL]         return FastMath.sin(scaledX) / scaledX; [EOL]     } [EOL] } <line_num>: 86,96
@Deprecated [EOL] public UnivariateFunction derivative() { [EOL]     return FunctionUtils.toDifferentiableUnivariateFunction(this).derivative(); [EOL] } <line_num>: 101,104
public DerivativeStructure value(final DerivativeStructure t) throws DimensionMismatchException { [EOL]     final double scaledX = (normalized ? FastMath.PI : 1) * t.getValue(); [EOL]     final double scaledX2 = scaledX * scaledX; [EOL]     double[] f = new double[t.getOrder() + 1]; [EOL]     if (FastMath.abs(scaledX) <= SHORTCUT) { [EOL]         for (int i = 0; i < f.length; ++i) { [EOL]             final int k = i / 2; [EOL]             if ((i & 0x1) == 0) { [EOL]                 f[i] = (((k & 0x1) == 0) ? 1 : -1) * (1.0 / (i + 1) - scaledX2 * (1.0 / (2 * i + 6) - scaledX2 / (24 * i + 120))); [EOL]             } else { [EOL]                 f[i] = (((k & 0x1) == 0) ? -scaledX : scaledX) * (1.0 / (i + 2) - scaledX2 * (1.0 / (6 * i + 24) - scaledX2 / (120 * i + 720))); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         final double inv = 1 / scaledX; [EOL]         final double cos = FastMath.cos(scaledX); [EOL]         final double sin = FastMath.sin(scaledX); [EOL]         f[0] = inv * sin; [EOL]         final double[] sc = new double[f.length]; [EOL]         sc[0] = 1; [EOL]         double coeff = inv; [EOL]         for (int n = 1; n < f.length; ++n) { [EOL]             double s = 0; [EOL]             double c = 0; [EOL]             final int kStart; [EOL]             if ((n & 0x1) == 0) { [EOL]                 sc[n] = 0; [EOL]                 kStart = n; [EOL]             } else { [EOL]                 sc[n] = sc[n - 1]; [EOL]                 c = sc[n]; [EOL]                 kStart = n - 1; [EOL]             } [EOL]             for (int k = kStart; k > 1; k -= 2) { [EOL]                 sc[k] = (k - n) * sc[k] - sc[k - 1]; [EOL]                 s = s * scaledX2 + sc[k]; [EOL]                 sc[k - 1] = (k - 1 - n) * sc[k - 1] + sc[k - 2]; [EOL]                 c = c * scaledX2 + sc[k - 1]; [EOL]             } [EOL]             sc[0] *= -n; [EOL]             s = s * scaledX2 + sc[0]; [EOL]             coeff *= inv; [EOL]             f[n] = coeff * (s * sin + c * scaledX * cos); [EOL]         } [EOL]     } [EOL]     if (normalized) { [EOL]         double scale = FastMath.PI; [EOL]         for (int i = 1; i < f.length; ++i) { [EOL]             f[i] *= scale; [EOL]             scale *= FastMath.PI; [EOL]         } [EOL]     } [EOL]     return t.compose(f); [EOL] } <line_num>: 109,204
