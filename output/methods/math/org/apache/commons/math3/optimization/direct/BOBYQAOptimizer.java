public BOBYQAOptimizer(int numberOfInterpolationPoints) { [EOL]     this(numberOfInterpolationPoints, DEFAULT_INITIAL_RADIUS, DEFAULT_STOPPING_RADIUS); [EOL] } <line_num>: 211,215
public BOBYQAOptimizer(int numberOfInterpolationPoints, double initialTrustRegionRadius, double stoppingTrustRegionRadius) { [EOL]     super(null); [EOL]     this.numberOfInterpolationPoints = numberOfInterpolationPoints; [EOL]     this.initialTrustRegionRadius = initialTrustRegionRadius; [EOL]     this.stoppingTrustRegionRadius = stoppingTrustRegionRadius; [EOL] } <line_num>: 225,232
PathIsExploredException() { [EOL]     super(PATH_IS_EXPLORED + " " + BOBYQAOptimizer.caller(3)); [EOL] } <line_num>: 2460,2462
@Override [EOL] protected PointValuePair doOptimize() { [EOL]     final double[] lowerBound = getLowerBound(); [EOL]     final double[] upperBound = getUpperBound(); [EOL]     setup(lowerBound, upperBound); [EOL]     isMinimize = (getGoalType() == GoalType.MINIMIZE); [EOL]     currentBest = new ArrayRealVector(getStartPoint()); [EOL]     final double value = bobyqa(lowerBound, upperBound); [EOL]     return new PointValuePair(currentBest.getDataRef(), isMinimize ? value : -value); [EOL] } <line_num>: 235,250
private double bobyqa(double[] lowerBound, double[] upperBound) { [EOL]     printMethod(); [EOL]     final int n = currentBest.getDimension(); [EOL]     for (int j = 0; j < n; j++) { [EOL]         final double boundDiff = boundDifference[j]; [EOL]         lowerDifference.setEntry(j, lowerBound[j] - currentBest.getEntry(j)); [EOL]         upperDifference.setEntry(j, upperBound[j] - currentBest.getEntry(j)); [EOL]         if (lowerDifference.getEntry(j) >= -initialTrustRegionRadius) { [EOL]             if (lowerDifference.getEntry(j) >= ZERO) { [EOL]                 currentBest.setEntry(j, lowerBound[j]); [EOL]                 lowerDifference.setEntry(j, ZERO); [EOL]                 upperDifference.setEntry(j, boundDiff); [EOL]             } else { [EOL]                 currentBest.setEntry(j, lowerBound[j] + initialTrustRegionRadius); [EOL]                 lowerDifference.setEntry(j, -initialTrustRegionRadius); [EOL]                 final double deltaOne = upperBound[j] - currentBest.getEntry(j); [EOL]                 upperDifference.setEntry(j, Math.max(deltaOne, initialTrustRegionRadius)); [EOL]             } [EOL]         } else if (upperDifference.getEntry(j) <= initialTrustRegionRadius) { [EOL]             if (upperDifference.getEntry(j) <= ZERO) { [EOL]                 currentBest.setEntry(j, upperBound[j]); [EOL]                 lowerDifference.setEntry(j, -boundDiff); [EOL]                 upperDifference.setEntry(j, ZERO); [EOL]             } else { [EOL]                 currentBest.setEntry(j, upperBound[j] - initialTrustRegionRadius); [EOL]                 final double deltaOne = lowerBound[j] - currentBest.getEntry(j); [EOL]                 final double deltaTwo = -initialTrustRegionRadius; [EOL]                 lowerDifference.setEntry(j, Math.min(deltaOne, deltaTwo)); [EOL]                 upperDifference.setEntry(j, initialTrustRegionRadius); [EOL]             } [EOL]         } [EOL]     } [EOL]     return bobyqb(lowerBound, upperBound); [EOL] } <line_num>: 287,335
private double bobyqb(double[] lowerBound, double[] upperBound) { [EOL]     printMethod(); [EOL]     final int n = currentBest.getDimension(); [EOL]     final int npt = numberOfInterpolationPoints; [EOL]     final int np = n + 1; [EOL]     final int nptm = npt - np; [EOL]     final int nh = n * np / 2; [EOL]     final ArrayRealVector work1 = new ArrayRealVector(n); [EOL]     final ArrayRealVector work2 = new ArrayRealVector(npt); [EOL]     final ArrayRealVector work3 = new ArrayRealVector(npt); [EOL]     double cauchy = Double.NaN; [EOL]     double alpha = Double.NaN; [EOL]     double dsq = Double.NaN; [EOL]     double crvmin = Double.NaN; [EOL]     trustRegionCenterInterpolationPointIndex = 0; [EOL]     prelim(lowerBound, upperBound); [EOL]     double xoptsq = ZERO; [EOL]     for (int i = 0; i < n; i++) { [EOL]         trustRegionCenterOffset.setEntry(i, interpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex, i)); [EOL]         final double deltaOne = trustRegionCenterOffset.getEntry(i); [EOL]         xoptsq += deltaOne * deltaOne; [EOL]     } [EOL]     double fsave = fAtInterpolationPoints.getEntry(0); [EOL]     final int kbase = 0; [EOL]     int ntrits = 0; [EOL]     int itest = 0; [EOL]     int knew = 0; [EOL]     int nfsav = getEvaluations(); [EOL]     double rho = initialTrustRegionRadius; [EOL]     double delta = rho; [EOL]     double diffa = ZERO; [EOL]     double diffb = ZERO; [EOL]     double diffc = ZERO; [EOL]     double f = ZERO; [EOL]     double beta = ZERO; [EOL]     double adelt = ZERO; [EOL]     double denom = ZERO; [EOL]     double ratio = ZERO; [EOL]     double dnorm = ZERO; [EOL]     double scaden = ZERO; [EOL]     double biglsq = ZERO; [EOL]     double distsq = ZERO; [EOL]     int state = 20; [EOL]     for (; ; ) switch(state) { [EOL]         case 20: [EOL]             { [EOL]                 printState(20); [EOL]                 if (trustRegionCenterInterpolationPointIndex != kbase) { [EOL]                     int ih = 0; [EOL]                     for (int j = 0; j < n; j++) { [EOL]                         for (int i = 0; i <= j; i++) { [EOL]                             if (i < j) { [EOL]                                 gradientAtTrustRegionCenter.setEntry(j, gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(i)); [EOL]                             } [EOL]                             gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(j)); [EOL]                             ih++; [EOL]                         } [EOL]                     } [EOL]                     if (getEvaluations() > npt) { [EOL]                         for (int k = 0; k < npt; k++) { [EOL]                             double temp = ZERO; [EOL]                             for (int j = 0; j < n; j++) { [EOL]                                 temp += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j); [EOL]                             } [EOL]                             temp *= modelSecondDerivativesParameters.getEntry(k); [EOL]                             for (int i = 0; i < n; i++) { [EOL]                                 gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i)); [EOL]                             } [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         case 60: [EOL]             { [EOL]                 printState(60); [EOL]                 final ArrayRealVector gnew = new ArrayRealVector(n); [EOL]                 final ArrayRealVector xbdi = new ArrayRealVector(n); [EOL]                 final ArrayRealVector s = new ArrayRealVector(n); [EOL]                 final ArrayRealVector hs = new ArrayRealVector(n); [EOL]                 final ArrayRealVector hred = new ArrayRealVector(n); [EOL]                 final double[] dsqCrvmin = trsbox(delta, gnew, xbdi, s, hs, hred); [EOL]                 dsq = dsqCrvmin[0]; [EOL]                 crvmin = dsqCrvmin[1]; [EOL]                 double deltaOne = delta; [EOL]                 double deltaTwo = Math.sqrt(dsq); [EOL]                 dnorm = Math.min(deltaOne, deltaTwo); [EOL]                 if (dnorm < HALF * rho) { [EOL]                     ntrits = -1; [EOL]                     deltaOne = TEN * rho; [EOL]                     distsq = deltaOne * deltaOne; [EOL]                     if (getEvaluations() <= nfsav + 2) { [EOL]                         state = 650; [EOL]                         break; [EOL]                     } [EOL]                     deltaOne = Math.max(diffa, diffb); [EOL]                     final double errbig = Math.max(deltaOne, diffc); [EOL]                     final double frhosq = rho * ONE_OVER_EIGHT * rho; [EOL]                     if (crvmin > ZERO && errbig > frhosq * crvmin) { [EOL]                         state = 650; [EOL]                         break; [EOL]                     } [EOL]                     final double bdtol = errbig / rho; [EOL]                     for (int j = 0; j < n; j++) { [EOL]                         double bdtest = bdtol; [EOL]                         if (newPoint.getEntry(j) == lowerDifference.getEntry(j)) { [EOL]                             bdtest = work1.getEntry(j); [EOL]                         } [EOL]                         if (newPoint.getEntry(j) == upperDifference.getEntry(j)) { [EOL]                             bdtest = -work1.getEntry(j); [EOL]                         } [EOL]                         if (bdtest < bdtol) { [EOL]                             double curv = modelSecondDerivativesValues.getEntry((j + j * j) / 2); [EOL]                             for (int k = 0; k < npt; k++) { [EOL]                                 final double d1 = interpolationPoints.getEntry(k, j); [EOL]                                 curv += modelSecondDerivativesParameters.getEntry(k) * (d1 * d1); [EOL]                             } [EOL]                             bdtest += HALF * curv * rho; [EOL]                             if (bdtest < bdtol) { [EOL]                                 state = 650; [EOL]                                 break; [EOL]                             } [EOL]                         } [EOL]                     } [EOL]                     state = 680; [EOL]                     break; [EOL]                 } [EOL]                 ++ntrits; [EOL]             } [EOL]         case 90: [EOL]             { [EOL]                 printState(90); [EOL]                 if (dsq <= xoptsq * ONE_OVER_A_THOUSAND) { [EOL]                     final double fracsq = xoptsq * ONE_OVER_FOUR; [EOL]                     double sumpq = ZERO; [EOL]                     for (int k = 0; k < npt; k++) { [EOL]                         sumpq += modelSecondDerivativesParameters.getEntry(k); [EOL]                         double sum = -HALF * xoptsq; [EOL]                         for (int i = 0; i < n; i++) { [EOL]                             sum += interpolationPoints.getEntry(k, i) * trustRegionCenterOffset.getEntry(i); [EOL]                         } [EOL]                         work2.setEntry(k, sum); [EOL]                         final double temp = fracsq - HALF * sum; [EOL]                         for (int i = 0; i < n; i++) { [EOL]                             work1.setEntry(i, bMatrix.getEntry(k, i)); [EOL]                             lagrangeValuesAtNewPoint.setEntry(i, sum * interpolationPoints.getEntry(k, i) + temp * trustRegionCenterOffset.getEntry(i)); [EOL]                             final int ip = npt + i; [EOL]                             for (int j = 0; j <= i; j++) { [EOL]                                 bMatrix.setEntry(ip, j, bMatrix.getEntry(ip, j) + work1.getEntry(i) * lagrangeValuesAtNewPoint.getEntry(j) + lagrangeValuesAtNewPoint.getEntry(i) * work1.getEntry(j)); [EOL]                             } [EOL]                         } [EOL]                     } [EOL]                     for (int m = 0; m < nptm; m++) { [EOL]                         double sumz = ZERO; [EOL]                         double sumw = ZERO; [EOL]                         for (int k = 0; k < npt; k++) { [EOL]                             sumz += zMatrix.getEntry(k, m); [EOL]                             lagrangeValuesAtNewPoint.setEntry(k, work2.getEntry(k) * zMatrix.getEntry(k, m)); [EOL]                             sumw += lagrangeValuesAtNewPoint.getEntry(k); [EOL]                         } [EOL]                         for (int j = 0; j < n; j++) { [EOL]                             double sum = (fracsq * sumz - HALF * sumw) * trustRegionCenterOffset.getEntry(j); [EOL]                             for (int k = 0; k < npt; k++) { [EOL]                                 sum += lagrangeValuesAtNewPoint.getEntry(k) * interpolationPoints.getEntry(k, j); [EOL]                             } [EOL]                             work1.setEntry(j, sum); [EOL]                             for (int k = 0; k < npt; k++) { [EOL]                                 bMatrix.setEntry(k, j, bMatrix.getEntry(k, j) + sum * zMatrix.getEntry(k, m)); [EOL]                             } [EOL]                         } [EOL]                         for (int i = 0; i < n; i++) { [EOL]                             final int ip = i + npt; [EOL]                             final double temp = work1.getEntry(i); [EOL]                             for (int j = 0; j <= i; j++) { [EOL]                                 bMatrix.setEntry(ip, j, bMatrix.getEntry(ip, j) + temp * work1.getEntry(j)); [EOL]                             } [EOL]                         } [EOL]                     } [EOL]                     int ih = 0; [EOL]                     for (int j = 0; j < n; j++) { [EOL]                         work1.setEntry(j, -HALF * sumpq * trustRegionCenterOffset.getEntry(j)); [EOL]                         for (int k = 0; k < npt; k++) { [EOL]                             work1.setEntry(j, work1.getEntry(j) + modelSecondDerivativesParameters.getEntry(k) * interpolationPoints.getEntry(k, j)); [EOL]                             interpolationPoints.setEntry(k, j, interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j)); [EOL]                         } [EOL]                         for (int i = 0; i <= j; i++) { [EOL]                             modelSecondDerivativesValues.setEntry(ih, modelSecondDerivativesValues.getEntry(ih) + work1.getEntry(i) * trustRegionCenterOffset.getEntry(j) + trustRegionCenterOffset.getEntry(i) * work1.getEntry(j)); [EOL]                             bMatrix.setEntry(npt + i, j, bMatrix.getEntry(npt + j, i)); [EOL]                             ih++; [EOL]                         } [EOL]                     } [EOL]                     for (int i = 0; i < n; i++) { [EOL]                         originShift.setEntry(i, originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i)); [EOL]                         newPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i)); [EOL]                         lowerDifference.setEntry(i, lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)); [EOL]                         upperDifference.setEntry(i, upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)); [EOL]                         trustRegionCenterOffset.setEntry(i, ZERO); [EOL]                     } [EOL]                     xoptsq = ZERO; [EOL]                 } [EOL]                 if (ntrits == 0) { [EOL]                     state = 210; [EOL]                     break; [EOL]                 } [EOL]                 state = 230; [EOL]                 break; [EOL]             } [EOL]         case 210: [EOL]             { [EOL]                 printState(210); [EOL]                 final double[] alphaCauchy = altmov(knew, adelt); [EOL]                 alpha = alphaCauchy[0]; [EOL]                 cauchy = alphaCauchy[1]; [EOL]                 for (int i = 0; i < n; i++) { [EOL]                     trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i)); [EOL]                 } [EOL]             } [EOL]         case 230: [EOL]             { [EOL]                 printState(230); [EOL]                 for (int k = 0; k < npt; k++) { [EOL]                     double suma = ZERO; [EOL]                     double sumb = ZERO; [EOL]                     double sum = ZERO; [EOL]                     for (int j = 0; j < n; j++) { [EOL]                         suma += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j); [EOL]                         sumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j); [EOL]                         sum += bMatrix.getEntry(k, j) * trialStepPoint.getEntry(j); [EOL]                     } [EOL]                     work3.setEntry(k, suma * (HALF * suma + sumb)); [EOL]                     lagrangeValuesAtNewPoint.setEntry(k, sum); [EOL]                     work2.setEntry(k, suma); [EOL]                 } [EOL]                 beta = ZERO; [EOL]                 for (int m = 0; m < nptm; m++) { [EOL]                     double sum = ZERO; [EOL]                     for (int k = 0; k < npt; k++) { [EOL]                         sum += zMatrix.getEntry(k, m) * work3.getEntry(k); [EOL]                     } [EOL]                     beta -= sum * sum; [EOL]                     for (int k = 0; k < npt; k++) { [EOL]                         lagrangeValuesAtNewPoint.setEntry(k, lagrangeValuesAtNewPoint.getEntry(k) + sum * zMatrix.getEntry(k, m)); [EOL]                     } [EOL]                 } [EOL]                 dsq = ZERO; [EOL]                 double bsum = ZERO; [EOL]                 double dx = ZERO; [EOL]                 for (int j = 0; j < n; j++) { [EOL]                     final double d1 = trialStepPoint.getEntry(j); [EOL]                     dsq += d1 * d1; [EOL]                     double sum = ZERO; [EOL]                     for (int k = 0; k < npt; k++) { [EOL]                         sum += work3.getEntry(k) * bMatrix.getEntry(k, j); [EOL]                     } [EOL]                     bsum += sum * trialStepPoint.getEntry(j); [EOL]                     final int jp = npt + j; [EOL]                     for (int i = 0; i < n; i++) { [EOL]                         sum += bMatrix.getEntry(jp, i) * trialStepPoint.getEntry(i); [EOL]                     } [EOL]                     lagrangeValuesAtNewPoint.setEntry(jp, sum); [EOL]                     bsum += sum * trialStepPoint.getEntry(j); [EOL]                     dx += trialStepPoint.getEntry(j) * trustRegionCenterOffset.getEntry(j); [EOL]                 } [EOL]                 beta = dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) + beta - bsum; [EOL]                 lagrangeValuesAtNewPoint.setEntry(trustRegionCenterInterpolationPointIndex, lagrangeValuesAtNewPoint.getEntry(trustRegionCenterInterpolationPointIndex) + ONE); [EOL]                 if (ntrits == 0) { [EOL]                     final double d1 = lagrangeValuesAtNewPoint.getEntry(knew); [EOL]                     denom = d1 * d1 + alpha * beta; [EOL]                     if (denom < cauchy && cauchy > ZERO) { [EOL]                         for (int i = 0; i < n; i++) { [EOL]                             newPoint.setEntry(i, alternativeNewPoint.getEntry(i)); [EOL]                             trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i)); [EOL]                         } [EOL]                         cauchy = ZERO; [EOL]                         state = 230; [EOL]                         break; [EOL]                     } [EOL]                 } else { [EOL]                     final double delsq = delta * delta; [EOL]                     scaden = ZERO; [EOL]                     biglsq = ZERO; [EOL]                     knew = 0; [EOL]                     for (int k = 0; k < npt; k++) { [EOL]                         if (k == trustRegionCenterInterpolationPointIndex) { [EOL]                             continue; [EOL]                         } [EOL]                         double hdiag = ZERO; [EOL]                         for (int m = 0; m < nptm; m++) { [EOL]                             final double d1 = zMatrix.getEntry(k, m); [EOL]                             hdiag += d1 * d1; [EOL]                         } [EOL]                         final double d2 = lagrangeValuesAtNewPoint.getEntry(k); [EOL]                         final double den = beta * hdiag + d2 * d2; [EOL]                         distsq = ZERO; [EOL]                         for (int j = 0; j < n; j++) { [EOL]                             final double d3 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j); [EOL]                             distsq += d3 * d3; [EOL]                         } [EOL]                         final double d4 = distsq / delsq; [EOL]                         final double temp = Math.max(ONE, d4 * d4); [EOL]                         if (temp * den > scaden) { [EOL]                             scaden = temp * den; [EOL]                             knew = k; [EOL]                             denom = den; [EOL]                         } [EOL]                         final double d5 = lagrangeValuesAtNewPoint.getEntry(k); [EOL]                         biglsq = Math.max(biglsq, temp * (d5 * d5)); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         case 360: [EOL]             { [EOL]                 printState(360); [EOL]                 for (int i = 0; i < n; i++) { [EOL]                     final double d3 = lowerBound[i]; [EOL]                     final double d4 = originShift.getEntry(i) + newPoint.getEntry(i); [EOL]                     final double d1 = Math.max(d3, d4); [EOL]                     final double d2 = upperBound[i]; [EOL]                     currentBest.setEntry(i, Math.min(d1, d2)); [EOL]                     if (newPoint.getEntry(i) == lowerDifference.getEntry(i)) { [EOL]                         currentBest.setEntry(i, lowerBound[i]); [EOL]                     } [EOL]                     if (newPoint.getEntry(i) == upperDifference.getEntry(i)) { [EOL]                         currentBest.setEntry(i, upperBound[i]); [EOL]                     } [EOL]                 } [EOL]                 f = computeObjectiveValue(currentBest.toArray()); [EOL]                 if (!isMinimize) [EOL]                     f = -f; [EOL]                 if (ntrits == -1) { [EOL]                     fsave = f; [EOL]                     state = 720; [EOL]                     break; [EOL]                 } [EOL]                 final double fopt = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex); [EOL]                 double vquad = ZERO; [EOL]                 int ih = 0; [EOL]                 for (int j = 0; j < n; j++) { [EOL]                     vquad += trialStepPoint.getEntry(j) * gradientAtTrustRegionCenter.getEntry(j); [EOL]                     for (int i = 0; i <= j; i++) { [EOL]                         double temp = trialStepPoint.getEntry(i) * trialStepPoint.getEntry(j); [EOL]                         if (i == j) { [EOL]                             temp *= HALF; [EOL]                         } [EOL]                         vquad += modelSecondDerivativesValues.getEntry(ih) * temp; [EOL]                         ih++; [EOL]                     } [EOL]                 } [EOL]                 for (int k = 0; k < npt; k++) { [EOL]                     final double d1 = work2.getEntry(k); [EOL]                     final double d2 = d1 * d1; [EOL]                     vquad += HALF * modelSecondDerivativesParameters.getEntry(k) * d2; [EOL]                 } [EOL]                 final double diff = f - fopt - vquad; [EOL]                 diffc = diffb; [EOL]                 diffb = diffa; [EOL]                 diffa = Math.abs(diff); [EOL]                 if (dnorm > rho) { [EOL]                     nfsav = getEvaluations(); [EOL]                 } [EOL]                 if (ntrits > 0) { [EOL]                     if (vquad >= ZERO) { [EOL]                         throw new MathIllegalStateException(LocalizedFormats.TRUST_REGION_STEP_FAILED, vquad); [EOL]                     } [EOL]                     ratio = (f - fopt) / vquad; [EOL]                     final double hDelta = HALF * delta; [EOL]                     if (ratio <= ONE_OVER_TEN) { [EOL]                         delta = Math.min(hDelta, dnorm); [EOL]                     } else if (ratio <= .7) { [EOL]                         delta = Math.max(hDelta, dnorm); [EOL]                     } else { [EOL]                         delta = Math.max(hDelta, 2 * dnorm); [EOL]                     } [EOL]                     if (delta <= rho * 1.5) { [EOL]                         delta = rho; [EOL]                     } [EOL]                     if (f < fopt) { [EOL]                         final int ksav = knew; [EOL]                         final double densav = denom; [EOL]                         final double delsq = delta * delta; [EOL]                         scaden = ZERO; [EOL]                         biglsq = ZERO; [EOL]                         knew = 0; [EOL]                         for (int k = 0; k < npt; k++) { [EOL]                             double hdiag = ZERO; [EOL]                             for (int m = 0; m < nptm; m++) { [EOL]                                 final double d1 = zMatrix.getEntry(k, m); [EOL]                                 hdiag += d1 * d1; [EOL]                             } [EOL]                             final double d1 = lagrangeValuesAtNewPoint.getEntry(k); [EOL]                             final double den = beta * hdiag + d1 * d1; [EOL]                             distsq = ZERO; [EOL]                             for (int j = 0; j < n; j++) { [EOL]                                 final double d2 = interpolationPoints.getEntry(k, j) - newPoint.getEntry(j); [EOL]                                 distsq += d2 * d2; [EOL]                             } [EOL]                             final double d3 = distsq / delsq; [EOL]                             final double temp = Math.max(ONE, d3 * d3); [EOL]                             if (temp * den > scaden) { [EOL]                                 scaden = temp * den; [EOL]                                 knew = k; [EOL]                                 denom = den; [EOL]                             } [EOL]                             final double d4 = lagrangeValuesAtNewPoint.getEntry(k); [EOL]                             final double d5 = temp * (d4 * d4); [EOL]                             biglsq = Math.max(biglsq, d5); [EOL]                         } [EOL]                         if (scaden <= HALF * biglsq) { [EOL]                             knew = ksav; [EOL]                             denom = densav; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]                 update(beta, denom, knew); [EOL]                 ih = 0; [EOL]                 final double pqold = modelSecondDerivativesParameters.getEntry(knew); [EOL]                 modelSecondDerivativesParameters.setEntry(knew, ZERO); [EOL]                 for (int i = 0; i < n; i++) { [EOL]                     final double temp = pqold * interpolationPoints.getEntry(knew, i); [EOL]                     for (int j = 0; j <= i; j++) { [EOL]                         modelSecondDerivativesValues.setEntry(ih, modelSecondDerivativesValues.getEntry(ih) + temp * interpolationPoints.getEntry(knew, j)); [EOL]                         ih++; [EOL]                     } [EOL]                 } [EOL]                 for (int m = 0; m < nptm; m++) { [EOL]                     final double temp = diff * zMatrix.getEntry(knew, m); [EOL]                     for (int k = 0; k < npt; k++) { [EOL]                         modelSecondDerivativesParameters.setEntry(k, modelSecondDerivativesParameters.getEntry(k) + temp * zMatrix.getEntry(k, m)); [EOL]                     } [EOL]                 } [EOL]                 fAtInterpolationPoints.setEntry(knew, f); [EOL]                 for (int i = 0; i < n; i++) { [EOL]                     interpolationPoints.setEntry(knew, i, newPoint.getEntry(i)); [EOL]                     work1.setEntry(i, bMatrix.getEntry(knew, i)); [EOL]                 } [EOL]                 for (int k = 0; k < npt; k++) { [EOL]                     double suma = ZERO; [EOL]                     for (int m = 0; m < nptm; m++) { [EOL]                         suma += zMatrix.getEntry(knew, m) * zMatrix.getEntry(k, m); [EOL]                     } [EOL]                     double sumb = ZERO; [EOL]                     for (int j = 0; j < n; j++) { [EOL]                         sumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j); [EOL]                     } [EOL]                     final double temp = suma * sumb; [EOL]                     for (int i = 0; i < n; i++) { [EOL]                         work1.setEntry(i, work1.getEntry(i) + temp * interpolationPoints.getEntry(k, i)); [EOL]                     } [EOL]                 } [EOL]                 for (int i = 0; i < n; i++) { [EOL]                     gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + diff * work1.getEntry(i)); [EOL]                 } [EOL]                 if (f < fopt) { [EOL]                     trustRegionCenterInterpolationPointIndex = knew; [EOL]                     xoptsq = ZERO; [EOL]                     ih = 0; [EOL]                     for (int j = 0; j < n; j++) { [EOL]                         trustRegionCenterOffset.setEntry(j, newPoint.getEntry(j)); [EOL]                         final double d1 = trustRegionCenterOffset.getEntry(j); [EOL]                         xoptsq += d1 * d1; [EOL]                         for (int i = 0; i <= j; i++) { [EOL]                             if (i < j) { [EOL]                                 gradientAtTrustRegionCenter.setEntry(j, gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(i)); [EOL]                             } [EOL]                             gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(j)); [EOL]                             ih++; [EOL]                         } [EOL]                     } [EOL]                     for (int k = 0; k < npt; k++) { [EOL]                         double temp = ZERO; [EOL]                         for (int j = 0; j < n; j++) { [EOL]                             temp += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j); [EOL]                         } [EOL]                         temp *= modelSecondDerivativesParameters.getEntry(k); [EOL]                         for (int i = 0; i < n; i++) { [EOL]                             gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i)); [EOL]                         } [EOL]                     } [EOL]                 } [EOL]                 if (ntrits > 0) { [EOL]                     for (int k = 0; k < npt; k++) { [EOL]                         lagrangeValuesAtNewPoint.setEntry(k, fAtInterpolationPoints.getEntry(k) - fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)); [EOL]                         work3.setEntry(k, ZERO); [EOL]                     } [EOL]                     for (int j = 0; j < nptm; j++) { [EOL]                         double sum = ZERO; [EOL]                         for (int k = 0; k < npt; k++) { [EOL]                             sum += zMatrix.getEntry(k, j) * lagrangeValuesAtNewPoint.getEntry(k); [EOL]                         } [EOL]                         for (int k = 0; k < npt; k++) { [EOL]                             work3.setEntry(k, work3.getEntry(k) + sum * zMatrix.getEntry(k, j)); [EOL]                         } [EOL]                     } [EOL]                     for (int k = 0; k < npt; k++) { [EOL]                         double sum = ZERO; [EOL]                         for (int j = 0; j < n; j++) { [EOL]                             sum += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j); [EOL]                         } [EOL]                         work2.setEntry(k, work3.getEntry(k)); [EOL]                         work3.setEntry(k, sum * work3.getEntry(k)); [EOL]                     } [EOL]                     double gqsq = ZERO; [EOL]                     double gisq = ZERO; [EOL]                     for (int i = 0; i < n; i++) { [EOL]                         double sum = ZERO; [EOL]                         for (int k = 0; k < npt; k++) { [EOL]                             sum += bMatrix.getEntry(k, i) * lagrangeValuesAtNewPoint.getEntry(k) + interpolationPoints.getEntry(k, i) * work3.getEntry(k); [EOL]                         } [EOL]                         if (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i)) { [EOL]                             final double d1 = Math.min(ZERO, gradientAtTrustRegionCenter.getEntry(i)); [EOL]                             gqsq += d1 * d1; [EOL]                             final double d2 = Math.min(ZERO, sum); [EOL]                             gisq += d2 * d2; [EOL]                         } else if (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i)) { [EOL]                             final double d1 = Math.max(ZERO, gradientAtTrustRegionCenter.getEntry(i)); [EOL]                             gqsq += d1 * d1; [EOL]                             final double d2 = Math.max(ZERO, sum); [EOL]                             gisq += d2 * d2; [EOL]                         } else { [EOL]                             final double d1 = gradientAtTrustRegionCenter.getEntry(i); [EOL]                             gqsq += d1 * d1; [EOL]                             gisq += sum * sum; [EOL]                         } [EOL]                         lagrangeValuesAtNewPoint.setEntry(npt + i, sum); [EOL]                     } [EOL]                     ++itest; [EOL]                     if (gqsq < TEN * gisq) { [EOL]                         itest = 0; [EOL]                     } [EOL]                     if (itest >= 3) { [EOL]                         for (int i = 0, max = Math.max(npt, nh); i < max; i++) { [EOL]                             if (i < n) { [EOL]                                 gradientAtTrustRegionCenter.setEntry(i, lagrangeValuesAtNewPoint.getEntry(npt + i)); [EOL]                             } [EOL]                             if (i < npt) { [EOL]                                 modelSecondDerivativesParameters.setEntry(i, work2.getEntry(i)); [EOL]                             } [EOL]                             if (i < nh) { [EOL]                                 modelSecondDerivativesValues.setEntry(i, ZERO); [EOL]                             } [EOL]                             itest = 0; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]                 if (ntrits == 0) { [EOL]                     state = 60; [EOL]                     break; [EOL]                 } [EOL]                 if (f <= fopt + ONE_OVER_TEN * vquad) { [EOL]                     state = 60; [EOL]                     break; [EOL]                 } [EOL]                 final double d1 = TWO * delta; [EOL]                 final double d2 = TEN * rho; [EOL]                 distsq = Math.max(d1 * d1, d2 * d2); [EOL]             } [EOL]         case 650: [EOL]             { [EOL]                 printState(650); [EOL]                 knew = -1; [EOL]                 for (int k = 0; k < npt; k++) { [EOL]                     double sum = ZERO; [EOL]                     for (int j = 0; j < n; j++) { [EOL]                         final double d1 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j); [EOL]                         sum += d1 * d1; [EOL]                     } [EOL]                     if (sum > distsq) { [EOL]                         knew = k; [EOL]                         distsq = sum; [EOL]                     } [EOL]                 } [EOL]                 if (knew >= 0) { [EOL]                     final double dist = Math.sqrt(distsq); [EOL]                     if (ntrits == -1) { [EOL]                         delta = Math.min(ONE_OVER_TEN * delta, HALF * dist); [EOL]                         if (delta <= rho * 1.5) { [EOL]                             delta = rho; [EOL]                         } [EOL]                     } [EOL]                     ntrits = 0; [EOL]                     final double d1 = Math.min(ONE_OVER_TEN * dist, delta); [EOL]                     adelt = Math.max(d1, rho); [EOL]                     dsq = adelt * adelt; [EOL]                     state = 90; [EOL]                     break; [EOL]                 } [EOL]                 if (ntrits == -1) { [EOL]                     state = 680; [EOL]                     break; [EOL]                 } [EOL]                 if (ratio > ZERO) { [EOL]                     state = 60; [EOL]                     break; [EOL]                 } [EOL]                 if (Math.max(delta, dnorm) > rho) { [EOL]                     state = 60; [EOL]                     break; [EOL]                 } [EOL]             } [EOL]         case 680: [EOL]             { [EOL]                 printState(680); [EOL]                 if (rho > stoppingTrustRegionRadius) { [EOL]                     delta = HALF * rho; [EOL]                     ratio = rho / stoppingTrustRegionRadius; [EOL]                     if (ratio <= SIXTEEN) { [EOL]                         rho = stoppingTrustRegionRadius; [EOL]                     } else if (ratio <= TWO_HUNDRED_FIFTY) { [EOL]                         rho = Math.sqrt(ratio) * stoppingTrustRegionRadius; [EOL]                     } else { [EOL]                         rho *= ONE_OVER_TEN; [EOL]                     } [EOL]                     delta = Math.max(delta, rho); [EOL]                     ntrits = 0; [EOL]                     nfsav = getEvaluations(); [EOL]                     state = 60; [EOL]                     break; [EOL]                 } [EOL]                 if (ntrits == -1) { [EOL]                     state = 360; [EOL]                     break; [EOL]                 } [EOL]             } [EOL]         case 720: [EOL]             { [EOL]                 printState(720); [EOL]                 if (fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex) <= fsave) { [EOL]                     for (int i = 0; i < n; i++) { [EOL]                         final double d3 = lowerBound[i]; [EOL]                         final double d4 = originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i); [EOL]                         final double d1 = Math.max(d3, d4); [EOL]                         final double d2 = upperBound[i]; [EOL]                         currentBest.setEntry(i, Math.min(d1, d2)); [EOL]                         if (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i)) { [EOL]                             currentBest.setEntry(i, lowerBound[i]); [EOL]                         } [EOL]                         if (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i)) { [EOL]                             currentBest.setEntry(i, upperBound[i]); [EOL]                         } [EOL]                     } [EOL]                     f = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex); [EOL]                 } [EOL]                 return f; [EOL]             } [EOL]         default: [EOL]             { [EOL]                 throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, "bobyqb"); [EOL]             } [EOL]     } [EOL] } <line_num>: 376,1221
private double[] altmov(int knew, double adelt) { [EOL]     printMethod(); [EOL]     final int n = currentBest.getDimension(); [EOL]     final int npt = numberOfInterpolationPoints; [EOL]     final ArrayRealVector glag = new ArrayRealVector(n); [EOL]     final ArrayRealVector hcol = new ArrayRealVector(npt); [EOL]     final ArrayRealVector work1 = new ArrayRealVector(n); [EOL]     final ArrayRealVector work2 = new ArrayRealVector(n); [EOL]     for (int k = 0; k < npt; k++) { [EOL]         hcol.setEntry(k, ZERO); [EOL]     } [EOL]     for (int j = 0, max = npt - n - 1; j < max; j++) { [EOL]         final double tmp = zMatrix.getEntry(knew, j); [EOL]         for (int k = 0; k < npt; k++) { [EOL]             hcol.setEntry(k, hcol.getEntry(k) + tmp * zMatrix.getEntry(k, j)); [EOL]         } [EOL]     } [EOL]     final double alpha = hcol.getEntry(knew); [EOL]     final double ha = HALF * alpha; [EOL]     for (int i = 0; i < n; i++) { [EOL]         glag.setEntry(i, bMatrix.getEntry(knew, i)); [EOL]     } [EOL]     for (int k = 0; k < npt; k++) { [EOL]         double tmp = ZERO; [EOL]         for (int j = 0; j < n; j++) { [EOL]             tmp += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j); [EOL]         } [EOL]         tmp *= hcol.getEntry(k); [EOL]         for (int i = 0; i < n; i++) { [EOL]             glag.setEntry(i, glag.getEntry(i) + tmp * interpolationPoints.getEntry(k, i)); [EOL]         } [EOL]     } [EOL]     double presav = ZERO; [EOL]     double step = Double.NaN; [EOL]     int ksav = 0; [EOL]     int ibdsav = 0; [EOL]     double stpsav = 0; [EOL]     for (int k = 0; k < npt; k++) { [EOL]         if (k == trustRegionCenterInterpolationPointIndex) { [EOL]             continue; [EOL]         } [EOL]         double dderiv = ZERO; [EOL]         double distsq = ZERO; [EOL]         for (int i = 0; i < n; i++) { [EOL]             final double tmp = interpolationPoints.getEntry(k, i) - trustRegionCenterOffset.getEntry(i); [EOL]             dderiv += glag.getEntry(i) * tmp; [EOL]             distsq += tmp * tmp; [EOL]         } [EOL]         double subd = adelt / Math.sqrt(distsq); [EOL]         double slbd = -subd; [EOL]         int ilbd = 0; [EOL]         int iubd = 0; [EOL]         final double sumin = Math.min(ONE, subd); [EOL]         for (int i = 0; i < n; i++) { [EOL]             final double tmp = interpolationPoints.getEntry(k, i) - trustRegionCenterOffset.getEntry(i); [EOL]             if (tmp > ZERO) { [EOL]                 if (slbd * tmp < lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) { [EOL]                     slbd = (lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp; [EOL]                     ilbd = -i - 1; [EOL]                 } [EOL]                 if (subd * tmp > upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) { [EOL]                     subd = Math.max(sumin, (upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp); [EOL]                     iubd = i + 1; [EOL]                 } [EOL]             } else if (tmp < ZERO) { [EOL]                 if (slbd * tmp > upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) { [EOL]                     slbd = (upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp; [EOL]                     ilbd = i + 1; [EOL]                 } [EOL]                 if (subd * tmp < lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) { [EOL]                     subd = Math.max(sumin, (lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp); [EOL]                     iubd = -i - 1; [EOL]                 } [EOL]             } [EOL]         } [EOL]         step = slbd; [EOL]         int isbd = ilbd; [EOL]         double vlag = Double.NaN; [EOL]         if (k == knew) { [EOL]             final double diff = dderiv - ONE; [EOL]             vlag = slbd * (dderiv - slbd * diff); [EOL]             final double d1 = subd * (dderiv - subd * diff); [EOL]             if (Math.abs(d1) > Math.abs(vlag)) { [EOL]                 step = subd; [EOL]                 vlag = d1; [EOL]                 isbd = iubd; [EOL]             } [EOL]             final double d2 = HALF * dderiv; [EOL]             final double d3 = d2 - diff * slbd; [EOL]             final double d4 = d2 - diff * subd; [EOL]             if (d3 * d4 < ZERO) { [EOL]                 final double d5 = d2 * d2 / diff; [EOL]                 if (Math.abs(d5) > Math.abs(vlag)) { [EOL]                     step = d2 / diff; [EOL]                     vlag = d5; [EOL]                     isbd = 0; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             vlag = slbd * (ONE - slbd); [EOL]             final double tmp = subd * (ONE - subd); [EOL]             if (Math.abs(tmp) > Math.abs(vlag)) { [EOL]                 step = subd; [EOL]                 vlag = tmp; [EOL]                 isbd = iubd; [EOL]             } [EOL]             if (subd > HALF && Math.abs(vlag) < ONE_OVER_FOUR) { [EOL]                 step = HALF; [EOL]                 vlag = ONE_OVER_FOUR; [EOL]                 isbd = 0; [EOL]             } [EOL]             vlag *= dderiv; [EOL]         } [EOL]         final double tmp = step * (ONE - step) * distsq; [EOL]         final double predsq = vlag * vlag * (vlag * vlag + ha * tmp * tmp); [EOL]         if (predsq > presav) { [EOL]             presav = predsq; [EOL]             ksav = k; [EOL]             stpsav = step; [EOL]             ibdsav = isbd; [EOL]         } [EOL]     } [EOL]     for (int i = 0; i < n; i++) { [EOL]         final double tmp = trustRegionCenterOffset.getEntry(i) + stpsav * (interpolationPoints.getEntry(ksav, i) - trustRegionCenterOffset.getEntry(i)); [EOL]         newPoint.setEntry(i, Math.max(lowerDifference.getEntry(i), Math.min(upperDifference.getEntry(i), tmp))); [EOL]     } [EOL]     if (ibdsav < 0) { [EOL]         newPoint.setEntry(-ibdsav - 1, lowerDifference.getEntry(-ibdsav - 1)); [EOL]     } [EOL]     if (ibdsav > 0) { [EOL]         newPoint.setEntry(ibdsav - 1, upperDifference.getEntry(ibdsav - 1)); [EOL]     } [EOL]     final double bigstp = adelt + adelt; [EOL]     int iflag = 0; [EOL]     double cauchy = Double.NaN; [EOL]     double csave = ZERO; [EOL]     while (true) { [EOL]         double wfixsq = ZERO; [EOL]         double ggfree = ZERO; [EOL]         for (int i = 0; i < n; i++) { [EOL]             final double glagValue = glag.getEntry(i); [EOL]             work1.setEntry(i, ZERO); [EOL]             if (Math.min(trustRegionCenterOffset.getEntry(i) - lowerDifference.getEntry(i), glagValue) > ZERO || Math.max(trustRegionCenterOffset.getEntry(i) - upperDifference.getEntry(i), glagValue) < ZERO) { [EOL]                 work1.setEntry(i, bigstp); [EOL]                 ggfree += glagValue * glagValue; [EOL]             } [EOL]         } [EOL]         if (ggfree == ZERO) { [EOL]             return new double[] { alpha, ZERO }; [EOL]         } [EOL]         final double tmp1 = adelt * adelt - wfixsq; [EOL]         if (tmp1 > ZERO) { [EOL]             step = Math.sqrt(tmp1 / ggfree); [EOL]             ggfree = ZERO; [EOL]             for (int i = 0; i < n; i++) { [EOL]                 if (work1.getEntry(i) == bigstp) { [EOL]                     final double tmp2 = trustRegionCenterOffset.getEntry(i) - step * glag.getEntry(i); [EOL]                     if (tmp2 <= lowerDifference.getEntry(i)) { [EOL]                         work1.setEntry(i, lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)); [EOL]                         final double d1 = work1.getEntry(i); [EOL]                         wfixsq += d1 * d1; [EOL]                     } else if (tmp2 >= upperDifference.getEntry(i)) { [EOL]                         work1.setEntry(i, upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)); [EOL]                         final double d1 = work1.getEntry(i); [EOL]                         wfixsq += d1 * d1; [EOL]                     } else { [EOL]                         final double d1 = glag.getEntry(i); [EOL]                         ggfree += d1 * d1; [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         double gw = ZERO; [EOL]         for (int i = 0; i < n; i++) { [EOL]             final double glagValue = glag.getEntry(i); [EOL]             if (work1.getEntry(i) == bigstp) { [EOL]                 work1.setEntry(i, -step * glagValue); [EOL]                 final double min = Math.min(upperDifference.getEntry(i), trustRegionCenterOffset.getEntry(i) + work1.getEntry(i)); [EOL]                 alternativeNewPoint.setEntry(i, Math.max(lowerDifference.getEntry(i), min)); [EOL]             } else if (work1.getEntry(i) == ZERO) { [EOL]                 alternativeNewPoint.setEntry(i, trustRegionCenterOffset.getEntry(i)); [EOL]             } else if (glagValue > ZERO) { [EOL]                 alternativeNewPoint.setEntry(i, lowerDifference.getEntry(i)); [EOL]             } else { [EOL]                 alternativeNewPoint.setEntry(i, upperDifference.getEntry(i)); [EOL]             } [EOL]             gw += glagValue * work1.getEntry(i); [EOL]         } [EOL]         double curv = ZERO; [EOL]         for (int k = 0; k < npt; k++) { [EOL]             double tmp = ZERO; [EOL]             for (int j = 0; j < n; j++) { [EOL]                 tmp += interpolationPoints.getEntry(k, j) * work1.getEntry(j); [EOL]             } [EOL]             curv += hcol.getEntry(k) * tmp * tmp; [EOL]         } [EOL]         if (iflag == 1) { [EOL]             curv = -curv; [EOL]         } [EOL]         if (curv > -gw && curv < -gw * (ONE + Math.sqrt(TWO))) { [EOL]             final double scale = -gw / curv; [EOL]             for (int i = 0; i < n; i++) { [EOL]                 final double tmp = trustRegionCenterOffset.getEntry(i) + scale * work1.getEntry(i); [EOL]                 alternativeNewPoint.setEntry(i, Math.max(lowerDifference.getEntry(i), Math.min(upperDifference.getEntry(i), tmp))); [EOL]             } [EOL]             final double d1 = HALF * gw * scale; [EOL]             cauchy = d1 * d1; [EOL]         } else { [EOL]             final double d1 = gw + HALF * curv; [EOL]             cauchy = d1 * d1; [EOL]         } [EOL]         if (iflag == 0) { [EOL]             for (int i = 0; i < n; i++) { [EOL]                 glag.setEntry(i, -glag.getEntry(i)); [EOL]                 work2.setEntry(i, alternativeNewPoint.getEntry(i)); [EOL]             } [EOL]             csave = cauchy; [EOL]             iflag = 1; [EOL]         } else { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (csave > cauchy) { [EOL]         for (int i = 0; i < n; i++) { [EOL]             alternativeNewPoint.setEntry(i, work2.getEntry(i)); [EOL]         } [EOL]         cauchy = csave; [EOL]     } [EOL]     return new double[] { alpha, cauchy }; [EOL] } <line_num>: 1258,1558
private void prelim(double[] lowerBound, double[] upperBound) { [EOL]     printMethod(); [EOL]     final int n = currentBest.getDimension(); [EOL]     final int npt = numberOfInterpolationPoints; [EOL]     final int ndim = bMatrix.getRowDimension(); [EOL]     final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius; [EOL]     final double recip = 1d / rhosq; [EOL]     final int np = n + 1; [EOL]     for (int j = 0; j < n; j++) { [EOL]         originShift.setEntry(j, currentBest.getEntry(j)); [EOL]         for (int k = 0; k < npt; k++) { [EOL]             interpolationPoints.setEntry(k, j, ZERO); [EOL]         } [EOL]         for (int i = 0; i < ndim; i++) { [EOL]             bMatrix.setEntry(i, j, ZERO); [EOL]         } [EOL]     } [EOL]     for (int i = 0, max = n * np / 2; i < max; i++) { [EOL]         modelSecondDerivativesValues.setEntry(i, ZERO); [EOL]     } [EOL]     for (int k = 0; k < npt; k++) { [EOL]         modelSecondDerivativesParameters.setEntry(k, ZERO); [EOL]         for (int j = 0, max = npt - np; j < max; j++) { [EOL]             zMatrix.setEntry(k, j, ZERO); [EOL]         } [EOL]     } [EOL]     int ipt = 0; [EOL]     int jpt = 0; [EOL]     double fbeg = Double.NaN; [EOL]     do { [EOL]         final int nfm = getEvaluations(); [EOL]         final int nfx = nfm - n; [EOL]         final int nfmm = nfm - 1; [EOL]         final int nfxm = nfx - 1; [EOL]         double stepa = 0; [EOL]         double stepb = 0; [EOL]         if (nfm <= 2 * n) { [EOL]             if (nfm >= 1 && nfm <= n) { [EOL]                 stepa = initialTrustRegionRadius; [EOL]                 if (upperDifference.getEntry(nfmm) == ZERO) { [EOL]                     stepa = -stepa; [EOL]                 } [EOL]                 interpolationPoints.setEntry(nfm, nfmm, stepa); [EOL]             } else if (nfm > n) { [EOL]                 stepa = interpolationPoints.getEntry(nfx, nfxm); [EOL]                 stepb = -initialTrustRegionRadius; [EOL]                 if (lowerDifference.getEntry(nfxm) == ZERO) { [EOL]                     stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm)); [EOL]                 } [EOL]                 if (upperDifference.getEntry(nfxm) == ZERO) { [EOL]                     stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm)); [EOL]                 } [EOL]                 interpolationPoints.setEntry(nfm, nfxm, stepb); [EOL]             } [EOL]         } else { [EOL]             final int tmp1 = (nfm - np) / n; [EOL]             jpt = nfm - tmp1 * n - n; [EOL]             ipt = jpt + tmp1; [EOL]             if (ipt > n) { [EOL]                 final int tmp2 = jpt; [EOL]                 jpt = ipt - n; [EOL]                 ipt = tmp2; [EOL]             } [EOL]             final int iptMinus1 = ipt - 1; [EOL]             final int jptMinus1 = jpt - 1; [EOL]             interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1)); [EOL]             interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1)); [EOL]         } [EOL]         for (int j = 0; j < n; j++) { [EOL]             currentBest.setEntry(j, Math.min(Math.max(lowerBound[j], originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)), upperBound[j])); [EOL]             if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) { [EOL]                 currentBest.setEntry(j, lowerBound[j]); [EOL]             } [EOL]             if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) { [EOL]                 currentBest.setEntry(j, upperBound[j]); [EOL]             } [EOL]         } [EOL]         final double objectiveValue = computeObjectiveValue(currentBest.toArray()); [EOL]         final double f = isMinimize ? objectiveValue : -objectiveValue; [EOL]         final int numEval = getEvaluations(); [EOL]         fAtInterpolationPoints.setEntry(nfm, f); [EOL]         if (numEval == 1) { [EOL]             fbeg = f; [EOL]             trustRegionCenterInterpolationPointIndex = 0; [EOL]         } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) { [EOL]             trustRegionCenterInterpolationPointIndex = nfm; [EOL]         } [EOL]         if (numEval <= 2 * n + 1) { [EOL]             if (numEval >= 2 && numEval <= n + 1) { [EOL]                 gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa); [EOL]                 if (npt < numEval + n) { [EOL]                     final double oneOverStepA = ONE / stepa; [EOL]                     bMatrix.setEntry(0, nfmm, -oneOverStepA); [EOL]                     bMatrix.setEntry(nfm, nfmm, oneOverStepA); [EOL]                     bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq); [EOL]                 } [EOL]             } else if (numEval >= n + 2) { [EOL]                 final int ih = nfx * (nfx + 1) / 2 - 1; [EOL]                 final double tmp = (f - fbeg) / stepb; [EOL]                 final double diff = stepb - stepa; [EOL]                 modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff); [EOL]                 gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff); [EOL]                 if (stepa * stepb < ZERO && f < fAtInterpolationPoints.getEntry(nfm - n)) { [EOL]                     fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n)); [EOL]                     fAtInterpolationPoints.setEntry(nfm - n, f); [EOL]                     if (trustRegionCenterInterpolationPointIndex == nfm) { [EOL]                         trustRegionCenterInterpolationPointIndex = nfm - n; [EOL]                     } [EOL]                     interpolationPoints.setEntry(nfm - n, nfxm, stepb); [EOL]                     interpolationPoints.setEntry(nfm, nfxm, stepa); [EOL]                 } [EOL]                 bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb)); [EOL]                 bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm)); [EOL]                 bMatrix.setEntry(nfm - n, nfxm, -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm)); [EOL]                 zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb)); [EOL]                 zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq); [EOL]                 zMatrix.setEntry(nfm - n, nfxm, -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm)); [EOL]             } [EOL]         } else { [EOL]             zMatrix.setEntry(0, nfxm, recip); [EOL]             zMatrix.setEntry(nfm, nfxm, recip); [EOL]             zMatrix.setEntry(ipt, nfxm, -recip); [EOL]             zMatrix.setEntry(jpt, nfxm, -recip); [EOL]             final int ih = ipt * (ipt - 1) / 2 + jpt - 1; [EOL]             final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1); [EOL]             modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp); [EOL]         } [EOL]     } while (getEvaluations() < npt); [EOL] } <line_num>: 1582,1753
private double[] trsbox(double delta, ArrayRealVector gnew, ArrayRealVector xbdi, ArrayRealVector s, ArrayRealVector hs, ArrayRealVector hred) { [EOL]     printMethod(); [EOL]     final int n = currentBest.getDimension(); [EOL]     final int npt = numberOfInterpolationPoints; [EOL]     double dsq = Double.NaN; [EOL]     double crvmin = Double.NaN; [EOL]     double ds; [EOL]     int iu; [EOL]     double dhd, dhs, cth, shs, sth, ssq, beta = 0, sdec, blen; [EOL]     int iact = -1; [EOL]     int nact = 0; [EOL]     double angt = 0, qred; [EOL]     int isav; [EOL]     double temp = 0, xsav = 0, xsum = 0, angbd = 0, dredg = 0, sredg = 0; [EOL]     int iterc; [EOL]     double resid = 0, delsq = 0, ggsav = 0, tempa = 0, tempb = 0, redmax = 0, dredsq = 0, redsav = 0, gredsq = 0, rednew = 0; [EOL]     int itcsav = 0; [EOL]     double rdprev = 0, rdnext = 0, stplen = 0, stepsq = 0; [EOL]     int itermax = 0; [EOL]     iterc = 0; [EOL]     nact = 0; [EOL]     for (int i = 0; i < n; i++) { [EOL]         xbdi.setEntry(i, ZERO); [EOL]         if (trustRegionCenterOffset.getEntry(i) <= lowerDifference.getEntry(i)) { [EOL]             if (gradientAtTrustRegionCenter.getEntry(i) >= ZERO) { [EOL]                 xbdi.setEntry(i, MINUS_ONE); [EOL]             } [EOL]         } else if (trustRegionCenterOffset.getEntry(i) >= upperDifference.getEntry(i) && gradientAtTrustRegionCenter.getEntry(i) <= ZERO) { [EOL]             xbdi.setEntry(i, ONE); [EOL]         } [EOL]         if (xbdi.getEntry(i) != ZERO) { [EOL]             ++nact; [EOL]         } [EOL]         trialStepPoint.setEntry(i, ZERO); [EOL]         gnew.setEntry(i, gradientAtTrustRegionCenter.getEntry(i)); [EOL]     } [EOL]     delsq = delta * delta; [EOL]     qred = ZERO; [EOL]     crvmin = MINUS_ONE; [EOL]     int state = 20; [EOL]     for (; ; ) { [EOL]         switch(state) { [EOL]             case 20: [EOL]                 { [EOL]                     printState(20); [EOL]                     beta = ZERO; [EOL]                 } [EOL]             case 30: [EOL]                 { [EOL]                     printState(30); [EOL]                     stepsq = ZERO; [EOL]                     for (int i = 0; i < n; i++) { [EOL]                         if (xbdi.getEntry(i) != ZERO) { [EOL]                             s.setEntry(i, ZERO); [EOL]                         } else if (beta == ZERO) { [EOL]                             s.setEntry(i, -gnew.getEntry(i)); [EOL]                         } else { [EOL]                             s.setEntry(i, beta * s.getEntry(i) - gnew.getEntry(i)); [EOL]                         } [EOL]                         final double d1 = s.getEntry(i); [EOL]                         stepsq += d1 * d1; [EOL]                     } [EOL]                     if (stepsq == ZERO) { [EOL]                         state = 190; [EOL]                         break; [EOL]                     } [EOL]                     if (beta == ZERO) { [EOL]                         gredsq = stepsq; [EOL]                         itermax = iterc + n - nact; [EOL]                     } [EOL]                     if (gredsq * delsq <= qred * 1e-4 * qred) { [EOL]                         state = 190; [EOL]                         break; [EOL]                     } [EOL]                     state = 210; [EOL]                     break; [EOL]                 } [EOL]             case 50: [EOL]                 { [EOL]                     printState(50); [EOL]                     resid = delsq; [EOL]                     ds = ZERO; [EOL]                     shs = ZERO; [EOL]                     for (int i = 0; i < n; i++) { [EOL]                         if (xbdi.getEntry(i) == ZERO) { [EOL]                             final double d1 = trialStepPoint.getEntry(i); [EOL]                             resid -= d1 * d1; [EOL]                             ds += s.getEntry(i) * trialStepPoint.getEntry(i); [EOL]                             shs += s.getEntry(i) * hs.getEntry(i); [EOL]                         } [EOL]                     } [EOL]                     if (resid <= ZERO) { [EOL]                         state = 90; [EOL]                         break; [EOL]                     } [EOL]                     temp = Math.sqrt(stepsq * resid + ds * ds); [EOL]                     if (ds < ZERO) { [EOL]                         blen = (temp - ds) / stepsq; [EOL]                     } else { [EOL]                         blen = resid / (temp + ds); [EOL]                     } [EOL]                     stplen = blen; [EOL]                     if (shs > ZERO) { [EOL]                         stplen = Math.min(blen, gredsq / shs); [EOL]                     } [EOL]                     iact = -1; [EOL]                     for (int i = 0; i < n; i++) { [EOL]                         if (s.getEntry(i) != ZERO) { [EOL]                             xsum = trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i); [EOL]                             if (s.getEntry(i) > ZERO) { [EOL]                                 temp = (upperDifference.getEntry(i) - xsum) / s.getEntry(i); [EOL]                             } else { [EOL]                                 temp = (lowerDifference.getEntry(i) - xsum) / s.getEntry(i); [EOL]                             } [EOL]                             if (temp < stplen) { [EOL]                                 stplen = temp; [EOL]                                 iact = i; [EOL]                             } [EOL]                         } [EOL]                     } [EOL]                     sdec = ZERO; [EOL]                     if (stplen > ZERO) { [EOL]                         ++iterc; [EOL]                         temp = shs / stepsq; [EOL]                         if (iact == -1 && temp > ZERO) { [EOL]                             crvmin = Math.min(crvmin, temp); [EOL]                             if (crvmin == MINUS_ONE) { [EOL]                                 crvmin = temp; [EOL]                             } [EOL]                         } [EOL]                         ggsav = gredsq; [EOL]                         gredsq = ZERO; [EOL]                         for (int i = 0; i < n; i++) { [EOL]                             gnew.setEntry(i, gnew.getEntry(i) + stplen * hs.getEntry(i)); [EOL]                             if (xbdi.getEntry(i) == ZERO) { [EOL]                                 final double d1 = gnew.getEntry(i); [EOL]                                 gredsq += d1 * d1; [EOL]                             } [EOL]                             trialStepPoint.setEntry(i, trialStepPoint.getEntry(i) + stplen * s.getEntry(i)); [EOL]                         } [EOL]                         final double d1 = stplen * (ggsav - HALF * stplen * shs); [EOL]                         sdec = Math.max(d1, ZERO); [EOL]                         qred += sdec; [EOL]                     } [EOL]                     if (iact >= 0) { [EOL]                         ++nact; [EOL]                         xbdi.setEntry(iact, ONE); [EOL]                         if (s.getEntry(iact) < ZERO) { [EOL]                             xbdi.setEntry(iact, MINUS_ONE); [EOL]                         } [EOL]                         final double d1 = trialStepPoint.getEntry(iact); [EOL]                         delsq -= d1 * d1; [EOL]                         if (delsq <= ZERO) { [EOL]                             state = 190; [EOL]                             break; [EOL]                         } [EOL]                         state = 20; [EOL]                         break; [EOL]                     } [EOL]                     if (stplen < blen) { [EOL]                         if (iterc == itermax) { [EOL]                             state = 190; [EOL]                             break; [EOL]                         } [EOL]                         if (sdec <= qred * .01) { [EOL]                             state = 190; [EOL]                             break; [EOL]                         } [EOL]                         beta = gredsq / ggsav; [EOL]                         state = 30; [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             case 90: [EOL]                 { [EOL]                     printState(90); [EOL]                     crvmin = ZERO; [EOL]                 } [EOL]             case 100: [EOL]                 { [EOL]                     printState(100); [EOL]                     if (nact >= n - 1) { [EOL]                         state = 190; [EOL]                         break; [EOL]                     } [EOL]                     dredsq = ZERO; [EOL]                     dredg = ZERO; [EOL]                     gredsq = ZERO; [EOL]                     for (int i = 0; i < n; i++) { [EOL]                         if (xbdi.getEntry(i) == ZERO) { [EOL]                             double d1 = trialStepPoint.getEntry(i); [EOL]                             dredsq += d1 * d1; [EOL]                             dredg += trialStepPoint.getEntry(i) * gnew.getEntry(i); [EOL]                             d1 = gnew.getEntry(i); [EOL]                             gredsq += d1 * d1; [EOL]                             s.setEntry(i, trialStepPoint.getEntry(i)); [EOL]                         } else { [EOL]                             s.setEntry(i, ZERO); [EOL]                         } [EOL]                     } [EOL]                     itcsav = iterc; [EOL]                     state = 210; [EOL]                     break; [EOL]                 } [EOL]             case 120: [EOL]                 { [EOL]                     printState(120); [EOL]                     ++iterc; [EOL]                     temp = gredsq * dredsq - dredg * dredg; [EOL]                     if (temp <= qred * 1e-4 * qred) { [EOL]                         state = 190; [EOL]                         break; [EOL]                     } [EOL]                     temp = Math.sqrt(temp); [EOL]                     for (int i = 0; i < n; i++) { [EOL]                         if (xbdi.getEntry(i) == ZERO) { [EOL]                             s.setEntry(i, (dredg * trialStepPoint.getEntry(i) - dredsq * gnew.getEntry(i)) / temp); [EOL]                         } else { [EOL]                             s.setEntry(i, ZERO); [EOL]                         } [EOL]                     } [EOL]                     sredg = -temp; [EOL]                     angbd = ONE; [EOL]                     iact = -1; [EOL]                     for (int i = 0; i < n; i++) { [EOL]                         if (xbdi.getEntry(i) == ZERO) { [EOL]                             tempa = trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i) - lowerDifference.getEntry(i); [EOL]                             tempb = upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i) - trialStepPoint.getEntry(i); [EOL]                             if (tempa <= ZERO) { [EOL]                                 ++nact; [EOL]                                 xbdi.setEntry(i, MINUS_ONE); [EOL]                                 state = 100; [EOL]                                 break; [EOL]                             } else if (tempb <= ZERO) { [EOL]                                 ++nact; [EOL]                                 xbdi.setEntry(i, ONE); [EOL]                                 state = 100; [EOL]                                 break; [EOL]                             } [EOL]                             double d1 = trialStepPoint.getEntry(i); [EOL]                             double d2 = s.getEntry(i); [EOL]                             ssq = d1 * d1 + d2 * d2; [EOL]                             d1 = trustRegionCenterOffset.getEntry(i) - lowerDifference.getEntry(i); [EOL]                             temp = ssq - d1 * d1; [EOL]                             if (temp > ZERO) { [EOL]                                 temp = Math.sqrt(temp) - s.getEntry(i); [EOL]                                 if (angbd * temp > tempa) { [EOL]                                     angbd = tempa / temp; [EOL]                                     iact = i; [EOL]                                     xsav = MINUS_ONE; [EOL]                                 } [EOL]                             } [EOL]                             d1 = upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i); [EOL]                             temp = ssq - d1 * d1; [EOL]                             if (temp > ZERO) { [EOL]                                 temp = Math.sqrt(temp) + s.getEntry(i); [EOL]                                 if (angbd * temp > tempb) { [EOL]                                     angbd = tempb / temp; [EOL]                                     iact = i; [EOL]                                     xsav = ONE; [EOL]                                 } [EOL]                             } [EOL]                         } [EOL]                     } [EOL]                     state = 210; [EOL]                     break; [EOL]                 } [EOL]             case 150: [EOL]                 { [EOL]                     printState(150); [EOL]                     shs = ZERO; [EOL]                     dhs = ZERO; [EOL]                     dhd = ZERO; [EOL]                     for (int i = 0; i < n; i++) { [EOL]                         if (xbdi.getEntry(i) == ZERO) { [EOL]                             shs += s.getEntry(i) * hs.getEntry(i); [EOL]                             dhs += trialStepPoint.getEntry(i) * hs.getEntry(i); [EOL]                             dhd += trialStepPoint.getEntry(i) * hred.getEntry(i); [EOL]                         } [EOL]                     } [EOL]                     redmax = ZERO; [EOL]                     isav = -1; [EOL]                     redsav = ZERO; [EOL]                     iu = (int) (angbd * 17. + 3.1); [EOL]                     for (int i = 0; i < iu; i++) { [EOL]                         angt = angbd * i / iu; [EOL]                         sth = (angt + angt) / (ONE + angt * angt); [EOL]                         temp = shs + angt * (angt * dhd - dhs - dhs); [EOL]                         rednew = sth * (angt * dredg - sredg - HALF * sth * temp); [EOL]                         if (rednew > redmax) { [EOL]                             redmax = rednew; [EOL]                             isav = i; [EOL]                             rdprev = redsav; [EOL]                         } else if (i == isav + 1) { [EOL]                             rdnext = rednew; [EOL]                         } [EOL]                         redsav = rednew; [EOL]                     } [EOL]                     if (isav < 0) { [EOL]                         state = 190; [EOL]                         break; [EOL]                     } [EOL]                     if (isav < iu) { [EOL]                         temp = (rdnext - rdprev) / (redmax + redmax - rdprev - rdnext); [EOL]                         angt = angbd * (isav + HALF * temp) / iu; [EOL]                     } [EOL]                     cth = (ONE - angt * angt) / (ONE + angt * angt); [EOL]                     sth = (angt + angt) / (ONE + angt * angt); [EOL]                     temp = shs + angt * (angt * dhd - dhs - dhs); [EOL]                     sdec = sth * (angt * dredg - sredg - HALF * sth * temp); [EOL]                     if (sdec <= ZERO) { [EOL]                         state = 190; [EOL]                         break; [EOL]                     } [EOL]                     dredg = ZERO; [EOL]                     gredsq = ZERO; [EOL]                     for (int i = 0; i < n; i++) { [EOL]                         gnew.setEntry(i, gnew.getEntry(i) + (cth - ONE) * hred.getEntry(i) + sth * hs.getEntry(i)); [EOL]                         if (xbdi.getEntry(i) == ZERO) { [EOL]                             trialStepPoint.setEntry(i, cth * trialStepPoint.getEntry(i) + sth * s.getEntry(i)); [EOL]                             dredg += trialStepPoint.getEntry(i) * gnew.getEntry(i); [EOL]                             final double d1 = gnew.getEntry(i); [EOL]                             gredsq += d1 * d1; [EOL]                         } [EOL]                         hred.setEntry(i, cth * hred.getEntry(i) + sth * hs.getEntry(i)); [EOL]                     } [EOL]                     qred += sdec; [EOL]                     if (iact >= 0 && isav == iu) { [EOL]                         ++nact; [EOL]                         xbdi.setEntry(iact, xsav); [EOL]                         state = 100; [EOL]                         break; [EOL]                     } [EOL]                     if (sdec > qred * .01) { [EOL]                         state = 120; [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             case 190: [EOL]                 { [EOL]                     printState(190); [EOL]                     dsq = ZERO; [EOL]                     for (int i = 0; i < n; i++) { [EOL]                         final double min = Math.min(trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i), upperDifference.getEntry(i)); [EOL]                         newPoint.setEntry(i, Math.max(min, lowerDifference.getEntry(i))); [EOL]                         if (xbdi.getEntry(i) == MINUS_ONE) { [EOL]                             newPoint.setEntry(i, lowerDifference.getEntry(i)); [EOL]                         } [EOL]                         if (xbdi.getEntry(i) == ONE) { [EOL]                             newPoint.setEntry(i, upperDifference.getEntry(i)); [EOL]                         } [EOL]                         trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i)); [EOL]                         final double d1 = trialStepPoint.getEntry(i); [EOL]                         dsq += d1 * d1; [EOL]                     } [EOL]                     return new double[] { dsq, crvmin }; [EOL]                 } [EOL]             case 210: [EOL]                 { [EOL]                     printState(210); [EOL]                     int ih = 0; [EOL]                     for (int j = 0; j < n; j++) { [EOL]                         hs.setEntry(j, ZERO); [EOL]                         for (int i = 0; i <= j; i++) { [EOL]                             if (i < j) { [EOL]                                 hs.setEntry(j, hs.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * s.getEntry(i)); [EOL]                             } [EOL]                             hs.setEntry(i, hs.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * s.getEntry(j)); [EOL]                             ih++; [EOL]                         } [EOL]                     } [EOL]                     final RealVector tmp = interpolationPoints.operate(s).ebeMultiply(modelSecondDerivativesParameters); [EOL]                     for (int k = 0; k < npt; k++) { [EOL]                         if (modelSecondDerivativesParameters.getEntry(k) != ZERO) { [EOL]                             for (int i = 0; i < n; i++) { [EOL]                                 hs.setEntry(i, hs.getEntry(i) + tmp.getEntry(k) * interpolationPoints.getEntry(k, i)); [EOL]                             } [EOL]                         } [EOL]                     } [EOL]                     if (crvmin != ZERO) { [EOL]                         state = 50; [EOL]                         break; [EOL]                     } [EOL]                     if (iterc > itcsav) { [EOL]                         state = 150; [EOL]                         break; [EOL]                     } [EOL]                     for (int i = 0; i < n; i++) { [EOL]                         hred.setEntry(i, hs.getEntry(i)); [EOL]                     } [EOL]                     state = 120; [EOL]                     break; [EOL]                 } [EOL]             default: [EOL]                 { [EOL]                     throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, "trsbox"); [EOL]                 } [EOL]         } [EOL]     } [EOL] } <line_num>: 1802,2275
private void update(double beta, double denom, int knew) { [EOL]     printMethod(); [EOL]     final int n = currentBest.getDimension(); [EOL]     final int npt = numberOfInterpolationPoints; [EOL]     final int nptm = npt - n - 1; [EOL]     final ArrayRealVector work = new ArrayRealVector(npt + n); [EOL]     double ztest = ZERO; [EOL]     for (int k = 0; k < npt; k++) { [EOL]         for (int j = 0; j < nptm; j++) { [EOL]             ztest = Math.max(ztest, Math.abs(zMatrix.getEntry(k, j))); [EOL]         } [EOL]     } [EOL]     ztest *= 1e-20; [EOL]     for (int j = 1; j < nptm; j++) { [EOL]         final double d1 = zMatrix.getEntry(knew, j); [EOL]         if (Math.abs(d1) > ztest) { [EOL]             final double d2 = zMatrix.getEntry(knew, 0); [EOL]             final double d3 = zMatrix.getEntry(knew, j); [EOL]             final double d4 = Math.sqrt(d2 * d2 + d3 * d3); [EOL]             final double d5 = zMatrix.getEntry(knew, 0) / d4; [EOL]             final double d6 = zMatrix.getEntry(knew, j) / d4; [EOL]             for (int i = 0; i < npt; i++) { [EOL]                 final double d7 = d5 * zMatrix.getEntry(i, 0) + d6 * zMatrix.getEntry(i, j); [EOL]                 zMatrix.setEntry(i, j, d5 * zMatrix.getEntry(i, j) - d6 * zMatrix.getEntry(i, 0)); [EOL]                 zMatrix.setEntry(i, 0, d7); [EOL]             } [EOL]         } [EOL]         zMatrix.setEntry(knew, j, ZERO); [EOL]     } [EOL]     for (int i = 0; i < npt; i++) { [EOL]         work.setEntry(i, zMatrix.getEntry(knew, 0) * zMatrix.getEntry(i, 0)); [EOL]     } [EOL]     final double alpha = work.getEntry(knew); [EOL]     final double tau = lagrangeValuesAtNewPoint.getEntry(knew); [EOL]     lagrangeValuesAtNewPoint.setEntry(knew, lagrangeValuesAtNewPoint.getEntry(knew) - ONE); [EOL]     final double sqrtDenom = Math.sqrt(denom); [EOL]     final double d1 = tau / sqrtDenom; [EOL]     final double d2 = zMatrix.getEntry(knew, 0) / sqrtDenom; [EOL]     for (int i = 0; i < npt; i++) { [EOL]         zMatrix.setEntry(i, 0, d1 * zMatrix.getEntry(i, 0) - d2 * lagrangeValuesAtNewPoint.getEntry(i)); [EOL]     } [EOL]     for (int j = 0; j < n; j++) { [EOL]         final int jp = npt + j; [EOL]         work.setEntry(jp, bMatrix.getEntry(knew, j)); [EOL]         final double d3 = (alpha * lagrangeValuesAtNewPoint.getEntry(jp) - tau * work.getEntry(jp)) / denom; [EOL]         final double d4 = (-beta * work.getEntry(jp) - tau * lagrangeValuesAtNewPoint.getEntry(jp)) / denom; [EOL]         for (int i = 0; i <= jp; i++) { [EOL]             bMatrix.setEntry(i, j, bMatrix.getEntry(i, j) + d3 * lagrangeValuesAtNewPoint.getEntry(i) + d4 * work.getEntry(i)); [EOL]             if (i >= npt) { [EOL]                 bMatrix.setEntry(jp, (i - npt), bMatrix.getEntry(i, j)); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 2292,2371
private void setup(double[] lowerBound, double[] upperBound) { [EOL]     printMethod(); [EOL]     double[] init = getStartPoint(); [EOL]     final int dimension = init.length; [EOL]     if (dimension < MINIMUM_PROBLEM_DIMENSION) { [EOL]         throw new NumberIsTooSmallException(dimension, MINIMUM_PROBLEM_DIMENSION, true); [EOL]     } [EOL]     final int[] nPointsInterval = { dimension + 2, (dimension + 2) * (dimension + 1) / 2 }; [EOL]     if (numberOfInterpolationPoints < nPointsInterval[0] || numberOfInterpolationPoints > nPointsInterval[1]) { [EOL]         throw new OutOfRangeException(LocalizedFormats.NUMBER_OF_INTERPOLATION_POINTS, numberOfInterpolationPoints, nPointsInterval[0], nPointsInterval[1]); [EOL]     } [EOL]     boundDifference = new double[dimension]; [EOL]     double requiredMinDiff = 2 * initialTrustRegionRadius; [EOL]     double minDiff = Double.POSITIVE_INFINITY; [EOL]     for (int i = 0; i < dimension; i++) { [EOL]         boundDifference[i] = upperBound[i] - lowerBound[i]; [EOL]         minDiff = Math.min(minDiff, boundDifference[i]); [EOL]     } [EOL]     if (minDiff < requiredMinDiff) { [EOL]         initialTrustRegionRadius = minDiff / 3.0; [EOL]     } [EOL]     bMatrix = new Array2DRowRealMatrix(dimension + numberOfInterpolationPoints, dimension); [EOL]     zMatrix = new Array2DRowRealMatrix(numberOfInterpolationPoints, numberOfInterpolationPoints - dimension - 1); [EOL]     interpolationPoints = new Array2DRowRealMatrix(numberOfInterpolationPoints, dimension); [EOL]     originShift = new ArrayRealVector(dimension); [EOL]     fAtInterpolationPoints = new ArrayRealVector(numberOfInterpolationPoints); [EOL]     trustRegionCenterOffset = new ArrayRealVector(dimension); [EOL]     gradientAtTrustRegionCenter = new ArrayRealVector(dimension); [EOL]     lowerDifference = new ArrayRealVector(dimension); [EOL]     upperDifference = new ArrayRealVector(dimension); [EOL]     modelSecondDerivativesParameters = new ArrayRealVector(numberOfInterpolationPoints); [EOL]     newPoint = new ArrayRealVector(dimension); [EOL]     alternativeNewPoint = new ArrayRealVector(dimension); [EOL]     trialStepPoint = new ArrayRealVector(dimension); [EOL]     lagrangeValuesAtNewPoint = new ArrayRealVector(dimension + numberOfInterpolationPoints); [EOL]     modelSecondDerivativesValues = new ArrayRealVector(dimension * (dimension + 1) / 2); [EOL] } <line_num>: 2379,2432
private static String caller(int n) { [EOL]     final Throwable t = new Throwable(); [EOL]     final StackTraceElement[] elements = t.getStackTrace(); [EOL]     final StackTraceElement e = elements[n]; [EOL]     return e.getMethodName() + " (at line " + e.getLineNumber() + ")"; [EOL] } <line_num>: 2435,2440
private static void printState(int s) { [EOL] } <line_num>: 2442,2444
private static void printMethod() { [EOL] } <line_num>: 2446,2448
