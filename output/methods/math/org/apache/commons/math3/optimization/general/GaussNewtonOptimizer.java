@Deprecated [EOL] public GaussNewtonOptimizer() { [EOL]     this(true); [EOL] } <line_num>: 61,64
public GaussNewtonOptimizer(ConvergenceChecker<PointVectorValuePair> checker) { [EOL]     this(true, checker); [EOL] } <line_num>: 72,74
@Deprecated [EOL] public GaussNewtonOptimizer(final boolean useLU) { [EOL]     this(useLU, new SimpleVectorValueChecker()); [EOL] } <line_num>: 86,89
public GaussNewtonOptimizer(final boolean useLU, ConvergenceChecker<PointVectorValuePair> checker) { [EOL]     super(checker); [EOL]     this.useLU = useLU; [EOL] } <line_num>: 97,101
@Override [EOL] public PointVectorValuePair doOptimize() { [EOL]     final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker(); [EOL]     if (checker == null) { [EOL]         throw new NullArgumentException(); [EOL]     } [EOL]     final double[] targetValues = getTarget(); [EOL]     final int nR = targetValues.length; [EOL]     final RealMatrix weightMatrix = getWeight(); [EOL]     final double[] residualsWeights = new double[nR]; [EOL]     for (int i = 0; i < nR; i++) { [EOL]         residualsWeights[i] = weightMatrix.getEntry(i, i); [EOL]     } [EOL]     final double[] currentPoint = getStartPoint(); [EOL]     final int nC = currentPoint.length; [EOL]     PointVectorValuePair current = null; [EOL]     int iter = 0; [EOL]     for (boolean converged = false; !converged; ) { [EOL]         ++iter; [EOL]         PointVectorValuePair previous = current; [EOL]         final double[] currentObjective = computeObjectiveValue(currentPoint); [EOL]         final double[] currentResiduals = computeResiduals(currentObjective); [EOL]         final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint); [EOL]         current = new PointVectorValuePair(currentPoint, currentObjective); [EOL]         final double[] b = new double[nC]; [EOL]         final double[][] a = new double[nC][nC]; [EOL]         for (int i = 0; i < nR; ++i) { [EOL]             final double[] grad = weightedJacobian.getRow(i); [EOL]             final double weight = residualsWeights[i]; [EOL]             final double residual = currentResiduals[i]; [EOL]             final double wr = weight * residual; [EOL]             for (int j = 0; j < nC; ++j) { [EOL]                 b[j] += wr * grad[j]; [EOL]             } [EOL]             for (int k = 0; k < nC; ++k) { [EOL]                 double[] ak = a[k]; [EOL]                 double wgk = weight * grad[k]; [EOL]                 for (int l = 0; l < nC; ++l) { [EOL]                     ak[l] += wgk * grad[l]; [EOL]                 } [EOL]             } [EOL]         } [EOL]         try { [EOL]             RealMatrix mA = new BlockRealMatrix(a); [EOL]             DecompositionSolver solver = useLU ? new LUDecomposition(mA).getSolver() : new QRDecomposition(mA).getSolver(); [EOL]             final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray(); [EOL]             for (int i = 0; i < nC; ++i) { [EOL]                 currentPoint[i] += dX[i]; [EOL]             } [EOL]         } catch (SingularMatrixException e) { [EOL]             throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM); [EOL]         } [EOL]         if (previous != null) { [EOL]             converged = checker.converged(iter, previous, current); [EOL]             if (converged) { [EOL]                 cost = computeCost(currentResiduals); [EOL]                 point = current.getPoint(); [EOL]                 return current; [EOL]             } [EOL]         } [EOL]     } [EOL]     throw new MathInternalError(); [EOL] } <line_num>: 104,194
