@Deprecated [EOL] public NonLinearConjugateGradientOptimizer(final ConjugateGradientFormula updateFormula) { [EOL]     this(updateFormula, new SimpleValueChecker()); [EOL] } <line_num>: 68,72
public NonLinearConjugateGradientOptimizer(final ConjugateGradientFormula updateFormula, ConvergenceChecker<PointValuePair> checker) { [EOL]     this(updateFormula, checker, new BrentSolver(), new IdentityPreconditioner()); [EOL] } <line_num>: 83,89
public NonLinearConjugateGradientOptimizer(final ConjugateGradientFormula updateFormula, ConvergenceChecker<PointValuePair> checker, final UnivariateSolver lineSearchSolver) { [EOL]     this(updateFormula, checker, lineSearchSolver, new IdentityPreconditioner()); [EOL] } <line_num>: 101,108
public NonLinearConjugateGradientOptimizer(final ConjugateGradientFormula updateFormula, ConvergenceChecker<PointValuePair> checker, final UnivariateSolver lineSearchSolver, final Preconditioner preconditioner) { [EOL]     super(checker); [EOL]     this.updateFormula = updateFormula; [EOL]     solver = lineSearchSolver; [EOL]     this.preconditioner = preconditioner; [EOL]     initialStep = 1.0; [EOL] } <line_num>: 118,128
public LineSearchFunction(final double[] searchDirection) { [EOL]     this.searchDirection = searchDirection; [EOL] } <line_num>: 288,290
public void setInitialStep(final double initialStep) { [EOL]     if (initialStep <= 0) { [EOL]         this.initialStep = 1.0; [EOL]     } else { [EOL]         this.initialStep = initialStep; [EOL]     } [EOL] } <line_num>: 140,146
@Override [EOL] protected PointValuePair doOptimize() { [EOL]     final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker(); [EOL]     point = getStartPoint(); [EOL]     final GoalType goal = getGoalType(); [EOL]     final int n = point.length; [EOL]     double[] r = computeObjectiveGradient(point); [EOL]     if (goal == GoalType.MINIMIZE) { [EOL]         for (int i = 0; i < n; ++i) { [EOL]             r[i] = -r[i]; [EOL]         } [EOL]     } [EOL]     double[] steepestDescent = preconditioner.precondition(point, r); [EOL]     double[] searchDirection = steepestDescent.clone(); [EOL]     double delta = 0; [EOL]     for (int i = 0; i < n; ++i) { [EOL]         delta += r[i] * searchDirection[i]; [EOL]     } [EOL]     PointValuePair current = null; [EOL]     int iter = 0; [EOL]     int maxEval = getMaxEvaluations(); [EOL]     while (true) { [EOL]         ++iter; [EOL]         final double objective = computeObjectiveValue(point); [EOL]         PointValuePair previous = current; [EOL]         current = new PointValuePair(point, objective); [EOL]         if (previous != null && checker.converged(iter, previous, current)) { [EOL]             return current; [EOL]         } [EOL]         final UnivariateFunction lsf = new LineSearchFunction(searchDirection); [EOL]         final double uB = findUpperBound(lsf, 0, initialStep); [EOL]         final double step = solver.solve(maxEval, lsf, 0, uB, 1e-15); [EOL]         maxEval -= solver.getEvaluations(); [EOL]         for (int i = 0; i < point.length; ++i) { [EOL]             point[i] += step * searchDirection[i]; [EOL]         } [EOL]         r = computeObjectiveGradient(point); [EOL]         if (goal == GoalType.MINIMIZE) { [EOL]             for (int i = 0; i < n; ++i) { [EOL]                 r[i] = -r[i]; [EOL]             } [EOL]         } [EOL]         final double deltaOld = delta; [EOL]         final double[] newSteepestDescent = preconditioner.precondition(point, r); [EOL]         delta = 0; [EOL]         for (int i = 0; i < n; ++i) { [EOL]             delta += r[i] * newSteepestDescent[i]; [EOL]         } [EOL]         final double beta; [EOL]         if (updateFormula == ConjugateGradientFormula.FLETCHER_REEVES) { [EOL]             beta = delta / deltaOld; [EOL]         } else { [EOL]             double deltaMid = 0; [EOL]             for (int i = 0; i < r.length; ++i) { [EOL]                 deltaMid += r[i] * steepestDescent[i]; [EOL]             } [EOL]             beta = (delta - deltaMid) / deltaOld; [EOL]         } [EOL]         steepestDescent = newSteepestDescent; [EOL]         if (iter % n == 0 || beta < 0) { [EOL]             searchDirection = steepestDescent.clone(); [EOL]         } else { [EOL]             for (int i = 0; i < n; ++i) { [EOL]                 searchDirection[i] = steepestDescent[i] + beta * searchDirection[i]; [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 149,238
private double findUpperBound(final UnivariateFunction f, final double a, final double h) { [EOL]     final double yA = f.value(a); [EOL]     double yB = yA; [EOL]     for (double step = h; step < Double.MAX_VALUE; step *= FastMath.max(2, yA / yB)) { [EOL]         final double b = a + step; [EOL]         yB = f.value(b); [EOL]         if (yA * yB <= 0) { [EOL]             return b; [EOL]         } [EOL]     } [EOL]     throw new MathIllegalStateException(LocalizedFormats.UNABLE_TO_BRACKET_OPTIMUM_IN_LINE_SEARCH); [EOL] } <line_num>: 249,261
public double[] precondition(double[] variables, double[] r) { [EOL]     return r.clone(); [EOL] } <line_num>: 267,269
public double value(double x) { [EOL]     final double[] shiftedPoint = point.clone(); [EOL]     for (int i = 0; i < shiftedPoint.length; ++i) { [EOL]         shiftedPoint[i] += x * searchDirection[i]; [EOL]     } [EOL]     final double[] gradient = computeObjectiveGradient(shiftedPoint); [EOL]     double dotProduct = 0; [EOL]     for (int i = 0; i < gradient.length; ++i) { [EOL]         dotProduct += gradient[i] * searchDirection[i]; [EOL]     } [EOL]     return dotProduct; [EOL] } <line_num>: 293,310
