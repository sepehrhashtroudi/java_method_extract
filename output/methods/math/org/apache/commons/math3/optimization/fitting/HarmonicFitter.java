public HarmonicFitter(final DifferentiableMultivariateVectorOptimizer optimizer) { [EOL]     super(optimizer); [EOL] } <line_num>: 47,49
public ParameterGuesser(WeightedObservedPoint[] observations) { [EOL]     if (observations.length < 4) { [EOL]         throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE, observations.length, 4, true); [EOL]     } [EOL]     final WeightedObservedPoint[] sorted = sortObservations(observations); [EOL]     final double[] aOmega = guessAOmega(sorted); [EOL]     a = aOmega[0]; [EOL]     omega = aOmega[1]; [EOL]     phi = guessPhi(sorted); [EOL] } <line_num>: 198,211
public double[] fit(double[] initialGuess) { [EOL]     return fit(new HarmonicOscillator.Parametric(), initialGuess); [EOL] } <line_num>: 63,65
public double[] fit() { [EOL]     return fit((new ParameterGuesser(getObservations())).guess()); [EOL] } <line_num>: 78,80
public double[] guess() { [EOL]     return new double[] { a, omega, phi }; [EOL] } <line_num>: 223,225
private WeightedObservedPoint[] sortObservations(WeightedObservedPoint[] unsorted) { [EOL]     final WeightedObservedPoint[] observations = unsorted.clone(); [EOL]     WeightedObservedPoint curr = observations[0]; [EOL]     for (int j = 1; j < observations.length; ++j) { [EOL]         WeightedObservedPoint prec = curr; [EOL]         curr = observations[j]; [EOL]         if (curr.getX() < prec.getX()) { [EOL]             int i = j - 1; [EOL]             WeightedObservedPoint mI = observations[i]; [EOL]             while ((i >= 0) && (curr.getX() < mI.getX())) { [EOL]                 observations[i + 1] = mI; [EOL]                 if (i-- != 0) { [EOL]                     mI = observations[i]; [EOL]                 } [EOL]             } [EOL]             observations[i + 1] = curr; [EOL]             curr = observations[j]; [EOL]         } [EOL]     } [EOL]     return observations; [EOL] } <line_num>: 233,259
private double[] guessAOmega(WeightedObservedPoint[] observations) { [EOL]     final double[] aOmega = new double[2]; [EOL]     double sx2 = 0; [EOL]     double sy2 = 0; [EOL]     double sxy = 0; [EOL]     double sxz = 0; [EOL]     double syz = 0; [EOL]     double currentX = observations[0].getX(); [EOL]     double currentY = observations[0].getY(); [EOL]     double f2Integral = 0; [EOL]     double fPrime2Integral = 0; [EOL]     final double startX = currentX; [EOL]     for (int i = 1; i < observations.length; ++i) { [EOL]         final double previousX = currentX; [EOL]         final double previousY = currentY; [EOL]         currentX = observations[i].getX(); [EOL]         currentY = observations[i].getY(); [EOL]         final double dx = currentX - previousX; [EOL]         final double dy = currentY - previousY; [EOL]         final double f2StepIntegral = dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3; [EOL]         final double fPrime2StepIntegral = dy * dy / dx; [EOL]         final double x = currentX - startX; [EOL]         f2Integral += f2StepIntegral; [EOL]         fPrime2Integral += fPrime2StepIntegral; [EOL]         sx2 += x * x; [EOL]         sy2 += f2Integral * f2Integral; [EOL]         sxy += x * f2Integral; [EOL]         sxz += x * fPrime2Integral; [EOL]         syz += f2Integral * fPrime2Integral; [EOL]     } [EOL]     double c1 = sy2 * sxz - sxy * syz; [EOL]     double c2 = sxy * sxz - sx2 * syz; [EOL]     double c3 = sx2 * sy2 - sxy * sxy; [EOL]     if ((c1 / c2 < 0) || (c2 / c3 < 0)) { [EOL]         final int last = observations.length - 1; [EOL]         final double xRange = observations[last].getX() - observations[0].getX(); [EOL]         if (xRange == 0) { [EOL]             throw new ZeroException(); [EOL]         } [EOL]         aOmega[1] = 2 * Math.PI / xRange; [EOL]         double yMin = Double.POSITIVE_INFINITY; [EOL]         double yMax = Double.NEGATIVE_INFINITY; [EOL]         for (int i = 1; i < observations.length; ++i) { [EOL]             final double y = observations[i].getY(); [EOL]             if (y < yMin) { [EOL]                 yMin = y; [EOL]             } [EOL]             if (y > yMax) { [EOL]                 yMax = y; [EOL]             } [EOL]         } [EOL]         aOmega[0] = 0.5 * (yMax - yMin); [EOL]     } else { [EOL]         if (c2 == 0) { [EOL]             throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR); [EOL]         } [EOL]         aOmega[0] = FastMath.sqrt(c1 / c2); [EOL]         aOmega[1] = FastMath.sqrt(c2 / c3); [EOL]     } [EOL]     return aOmega; [EOL] } <line_num>: 273,352
private double guessPhi(WeightedObservedPoint[] observations) { [EOL]     double fcMean = 0; [EOL]     double fsMean = 0; [EOL]     double currentX = observations[0].getX(); [EOL]     double currentY = observations[0].getY(); [EOL]     for (int i = 1; i < observations.length; ++i) { [EOL]         final double previousX = currentX; [EOL]         final double previousY = currentY; [EOL]         currentX = observations[i].getX(); [EOL]         currentY = observations[i].getY(); [EOL]         final double currentYPrime = (currentY - previousY) / (currentX - previousX); [EOL]         double omegaX = omega * currentX; [EOL]         double cosine = FastMath.cos(omegaX); [EOL]         double sine = FastMath.sin(omegaX); [EOL]         fcMean += omega * currentY * cosine - currentYPrime * sine; [EOL]         fsMean += omega * currentY * sine + currentYPrime * cosine; [EOL]     } [EOL]     return FastMath.atan2(-fsMean, fcMean); [EOL] } <line_num>: 360,383
