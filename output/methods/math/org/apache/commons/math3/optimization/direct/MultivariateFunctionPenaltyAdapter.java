public MultivariateFunctionPenaltyAdapter(final MultivariateFunction bounded, final double[] lower, final double[] upper, final double offset, final double[] scale) { [EOL]     MathUtils.checkNotNull(lower); [EOL]     MathUtils.checkNotNull(upper); [EOL]     MathUtils.checkNotNull(scale); [EOL]     if (lower.length != upper.length) { [EOL]         throw new DimensionMismatchException(lower.length, upper.length); [EOL]     } [EOL]     if (lower.length != scale.length) { [EOL]         throw new DimensionMismatchException(lower.length, scale.length); [EOL]     } [EOL]     for (int i = 0; i < lower.length; ++i) { [EOL]         if (!(upper[i] >= lower[i])) { [EOL]             throw new NumberIsTooSmallException(upper[i], lower[i], true); [EOL]         } [EOL]     } [EOL]     this.bounded = bounded; [EOL]     this.lower = lower.clone(); [EOL]     this.upper = upper.clone(); [EOL]     this.offset = offset; [EOL]     this.scale = scale.clone(); [EOL] } <line_num>: 125,152
public double value(double[] point) { [EOL]     for (int i = 0; i < scale.length; ++i) { [EOL]         if ((point[i] < lower[i]) || (point[i] > upper[i])) { [EOL]             double sum = 0; [EOL]             for (int j = i; j < scale.length; ++j) { [EOL]                 final double overshoot; [EOL]                 if (point[j] < lower[j]) { [EOL]                     overshoot = scale[j] * (lower[j] - point[j]); [EOL]                 } else if (point[j] > upper[j]) { [EOL]                     overshoot = scale[j] * (point[j] - upper[j]); [EOL]                 } else { [EOL]                     overshoot = 0; [EOL]                 } [EOL]                 sum += FastMath.sqrt(overshoot); [EOL]             } [EOL]             return offset + sum; [EOL]         } [EOL]     } [EOL]     return bounded.value(point); [EOL] } <line_num>: 164,189
