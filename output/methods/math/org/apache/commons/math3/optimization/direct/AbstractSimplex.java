protected AbstractSimplex(int n) { [EOL]     this(n, 1d); [EOL] } <line_num>: 66,68
protected AbstractSimplex(int n, double sideLength) { [EOL]     this(createHypercubeSteps(n, sideLength)); [EOL] } <line_num>: 76,79
protected AbstractSimplex(final double[] steps) { [EOL]     if (steps == null) { [EOL]         throw new NullArgumentException(); [EOL]     } [EOL]     if (steps.length == 0) { [EOL]         throw new ZeroException(); [EOL]     } [EOL]     dimension = steps.length; [EOL]     startConfiguration = new double[dimension][dimension]; [EOL]     for (int i = 0; i < dimension; i++) { [EOL]         final double[] vertexI = startConfiguration[i]; [EOL]         for (int j = 0; j < i + 1; j++) { [EOL]             if (steps[j] == 0) { [EOL]                 throw new ZeroException(LocalizedFormats.EQUAL_VERTICES_IN_SIMPLEX); [EOL]             } [EOL]             System.arraycopy(steps, 0, vertexI, 0, j + 1); [EOL]         } [EOL]     } [EOL] } <line_num>: 99,120
protected AbstractSimplex(final double[][] referenceSimplex) { [EOL]     if (referenceSimplex.length <= 0) { [EOL]         throw new NotStrictlyPositiveException(LocalizedFormats.SIMPLEX_NEED_ONE_POINT, referenceSimplex.length); [EOL]     } [EOL]     dimension = referenceSimplex.length - 1; [EOL]     startConfiguration = new double[dimension][dimension]; [EOL]     final double[] ref0 = referenceSimplex[0]; [EOL]     for (int i = 0; i < referenceSimplex.length; i++) { [EOL]         final double[] refI = referenceSimplex[i]; [EOL]         if (refI.length != dimension) { [EOL]             throw new DimensionMismatchException(refI.length, dimension); [EOL]         } [EOL]         for (int j = 0; j < i; j++) { [EOL]             final double[] refJ = referenceSimplex[j]; [EOL]             boolean allEquals = true; [EOL]             for (int k = 0; k < dimension; k++) { [EOL]                 if (refI[k] != refJ[k]) { [EOL]                     allEquals = false; [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             if (allEquals) { [EOL]                 throw new MathIllegalArgumentException(LocalizedFormats.EQUAL_VERTICES_IN_SIMPLEX, i, j); [EOL]             } [EOL]         } [EOL]         if (i > 0) { [EOL]             final double[] confI = startConfiguration[i - 1]; [EOL]             for (int k = 0; k < dimension; k++) { [EOL]                 confI[k] = refI[k] - ref0[k]; [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 134,177
public int getDimension() { [EOL]     return dimension; [EOL] } <line_num>: 184,186
public int getSize() { [EOL]     return simplex.length; [EOL] } <line_num>: 195,197
public abstract void iterate(final MultivariateFunction evaluationFunction, final Comparator<PointValuePair> comparator); <line_num>: 208,209
public void build(final double[] startPoint) { [EOL]     if (dimension != startPoint.length) { [EOL]         throw new DimensionMismatchException(dimension, startPoint.length); [EOL]     } [EOL]     simplex = new PointValuePair[dimension + 1]; [EOL]     simplex[0] = new PointValuePair(startPoint, Double.NaN); [EOL]     for (int i = 0; i < dimension; i++) { [EOL]         final double[] confI = startConfiguration[i]; [EOL]         final double[] vertexI = new double[dimension]; [EOL]         for (int k = 0; k < dimension; k++) { [EOL]             vertexI[k] = startPoint[k] + confI[k]; [EOL]         } [EOL]         simplex[i + 1] = new PointValuePair(vertexI, Double.NaN); [EOL]     } [EOL] } <line_num>: 218,236
public void evaluate(final MultivariateFunction evaluationFunction, final Comparator<PointValuePair> comparator) { [EOL]     for (int i = 0; i < simplex.length; i++) { [EOL]         final PointValuePair vertex = simplex[i]; [EOL]         final double[] point = vertex.getPointRef(); [EOL]         if (Double.isNaN(vertex.getValue())) { [EOL]             simplex[i] = new PointValuePair(point, evaluationFunction.value(point), false); [EOL]         } [EOL]     } [EOL]     Arrays.sort(simplex, comparator); [EOL] } <line_num>: 246,259
protected void replaceWorstPoint(PointValuePair pointValuePair, final Comparator<PointValuePair> comparator) { [EOL]     for (int i = 0; i < dimension; i++) { [EOL]         if (comparator.compare(simplex[i], pointValuePair) > 0) { [EOL]             PointValuePair tmp = simplex[i]; [EOL]             simplex[i] = pointValuePair; [EOL]             pointValuePair = tmp; [EOL]         } [EOL]     } [EOL]     simplex[dimension] = pointValuePair; [EOL] } <line_num>: 268,278
public PointValuePair[] getPoints() { [EOL]     final PointValuePair[] copy = new PointValuePair[simplex.length]; [EOL]     System.arraycopy(simplex, 0, copy, 0, simplex.length); [EOL]     return copy; [EOL] } <line_num>: 285,289
public PointValuePair getPoint(int index) { [EOL]     if (index < 0 || index >= simplex.length) { [EOL]         throw new OutOfRangeException(index, 0, simplex.length - 1); [EOL]     } [EOL]     return simplex[index]; [EOL] } <line_num>: 297,303
protected void setPoint(int index, PointValuePair point) { [EOL]     if (index < 0 || index >= simplex.length) { [EOL]         throw new OutOfRangeException(index, 0, simplex.length - 1); [EOL]     } [EOL]     simplex[index] = point; [EOL] } <line_num>: 312,318
protected void setPoints(PointValuePair[] points) { [EOL]     if (points.length != simplex.length) { [EOL]         throw new DimensionMismatchException(points.length, simplex.length); [EOL]     } [EOL]     simplex = points; [EOL] } <line_num>: 326,331
private static double[] createHypercubeSteps(int n, double sideLength) { [EOL]     final double[] steps = new double[n]; [EOL]     for (int i = 0; i < n; i++) { [EOL]         steps[i] = sideLength; [EOL]     } [EOL]     return steps; [EOL] } <line_num>: 340,347
