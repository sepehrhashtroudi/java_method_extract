public StepNormalizer(final double h, final FixedStepHandler handler) { [EOL]     this(h, handler, StepNormalizerMode.INCREMENT, StepNormalizerBounds.FIRST); [EOL] } <line_num>: 126,129
public StepNormalizer(final double h, final FixedStepHandler handler, final StepNormalizerMode mode) { [EOL]     this(h, handler, mode, StepNormalizerBounds.FIRST); [EOL] } <line_num>: 138,141
public StepNormalizer(final double h, final FixedStepHandler handler, final StepNormalizerBounds bounds) { [EOL]     this(h, handler, StepNormalizerMode.INCREMENT, bounds); [EOL] } <line_num>: 150,153
public StepNormalizer(final double h, final FixedStepHandler handler, final StepNormalizerMode mode, final StepNormalizerBounds bounds) { [EOL]     this.h = FastMath.abs(h); [EOL]     this.handler = handler; [EOL]     this.mode = mode; [EOL]     this.bounds = bounds; [EOL]     firstTime = Double.NaN; [EOL]     lastTime = Double.NaN; [EOL]     lastState = null; [EOL]     lastDerivatives = null; [EOL]     forward = true; [EOL] } <line_num>: 162,174
public void init(double t0, double[] y0, double t) { [EOL]     firstTime = Double.NaN; [EOL]     lastTime = Double.NaN; [EOL]     lastState = null; [EOL]     lastDerivatives = null; [EOL]     forward = true; [EOL]     handler.init(t0, y0, t); [EOL] } <line_num>: 177,188
public void handleStep(final StepInterpolator interpolator, final boolean isLast) throws MaxCountExceededException { [EOL]     if (lastState == null) { [EOL]         firstTime = interpolator.getPreviousTime(); [EOL]         lastTime = interpolator.getPreviousTime(); [EOL]         interpolator.setInterpolatedTime(lastTime); [EOL]         lastState = interpolator.getInterpolatedState().clone(); [EOL]         lastDerivatives = interpolator.getInterpolatedDerivatives().clone(); [EOL]         forward = interpolator.getCurrentTime() >= lastTime; [EOL]         if (!forward) { [EOL]             h = -h; [EOL]         } [EOL]     } [EOL]     double nextTime = (mode == StepNormalizerMode.INCREMENT) ? lastTime + h : (FastMath.floor(lastTime / h) + 1) * h; [EOL]     if (mode == StepNormalizerMode.MULTIPLES && Precision.equals(nextTime, lastTime, 1)) { [EOL]         nextTime += h; [EOL]     } [EOL]     boolean nextInStep = isNextInStep(nextTime, interpolator); [EOL]     while (nextInStep) { [EOL]         doNormalizedStep(false); [EOL]         storeStep(interpolator, nextTime); [EOL]         nextTime += h; [EOL]         nextInStep = isNextInStep(nextTime, interpolator); [EOL]     } [EOL]     if (isLast) { [EOL]         boolean addLast = bounds.lastIncluded() && lastTime != interpolator.getCurrentTime(); [EOL]         doNormalizedStep(!addLast); [EOL]         if (addLast) { [EOL]             storeStep(interpolator, interpolator.getCurrentTime()); [EOL]             doNormalizedStep(true); [EOL]         } [EOL]     } [EOL] } <line_num>: 203,255
private boolean isNextInStep(double nextTime, StepInterpolator interpolator) { [EOL]     return forward ? nextTime <= interpolator.getCurrentTime() : nextTime >= interpolator.getCurrentTime(); [EOL] } <line_num>: 266,271
private void doNormalizedStep(boolean isLast) { [EOL]     if (!bounds.firstIncluded() && firstTime == lastTime) { [EOL]         return; [EOL]     } [EOL]     handler.handleStep(lastTime, lastState, lastDerivatives, isLast); [EOL] } <line_num>: 277,282
private void storeStep(StepInterpolator interpolator, double t) throws MaxCountExceededException { [EOL]     lastTime = t; [EOL]     interpolator.setInterpolatedTime(lastTime); [EOL]     System.arraycopy(interpolator.getInterpolatedState(), 0, lastState, 0, lastState.length); [EOL]     System.arraycopy(interpolator.getInterpolatedDerivatives(), 0, lastDerivatives, 0, lastDerivatives.length); [EOL] } <line_num>: 292,300
