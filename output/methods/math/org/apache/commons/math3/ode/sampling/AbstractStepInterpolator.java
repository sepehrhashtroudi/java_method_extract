protected AbstractStepInterpolator() { [EOL]     globalPreviousTime = Double.NaN; [EOL]     globalCurrentTime = Double.NaN; [EOL]     softPreviousTime = Double.NaN; [EOL]     softCurrentTime = Double.NaN; [EOL]     h = Double.NaN; [EOL]     interpolatedTime = Double.NaN; [EOL]     currentState = null; [EOL]     finalized = false; [EOL]     this.forward = true; [EOL]     this.dirtyState = true; [EOL]     primaryMapper = null; [EOL]     secondaryMappers = null; [EOL]     allocateInterpolatedArrays(-1); [EOL] } <line_num>: 112,126
protected AbstractStepInterpolator(final double[] y, final boolean forward, final EquationsMapper primaryMapper, final EquationsMapper[] secondaryMappers) { [EOL]     globalPreviousTime = Double.NaN; [EOL]     globalCurrentTime = Double.NaN; [EOL]     softPreviousTime = Double.NaN; [EOL]     softCurrentTime = Double.NaN; [EOL]     h = Double.NaN; [EOL]     interpolatedTime = Double.NaN; [EOL]     currentState = y; [EOL]     finalized = false; [EOL]     this.forward = forward; [EOL]     this.dirtyState = true; [EOL]     this.primaryMapper = primaryMapper; [EOL]     this.secondaryMappers = (secondaryMappers == null) ? null : secondaryMappers.clone(); [EOL]     allocateInterpolatedArrays(y.length); [EOL] } <line_num>: 135,153
protected AbstractStepInterpolator(final AbstractStepInterpolator interpolator) { [EOL]     globalPreviousTime = interpolator.globalPreviousTime; [EOL]     globalCurrentTime = interpolator.globalCurrentTime; [EOL]     softPreviousTime = interpolator.softPreviousTime; [EOL]     softCurrentTime = interpolator.softCurrentTime; [EOL]     h = interpolator.h; [EOL]     interpolatedTime = interpolator.interpolatedTime; [EOL]     if (interpolator.currentState == null) { [EOL]         currentState = null; [EOL]         primaryMapper = null; [EOL]         secondaryMappers = null; [EOL]         allocateInterpolatedArrays(-1); [EOL]     } else { [EOL]         currentState = interpolator.currentState.clone(); [EOL]         interpolatedState = interpolator.interpolatedState.clone(); [EOL]         interpolatedDerivatives = interpolator.interpolatedDerivatives.clone(); [EOL]         interpolatedPrimaryState = interpolator.interpolatedPrimaryState.clone(); [EOL]         interpolatedPrimaryDerivatives = interpolator.interpolatedPrimaryDerivatives.clone(); [EOL]         interpolatedSecondaryState = new double[interpolator.interpolatedSecondaryState.length][]; [EOL]         interpolatedSecondaryDerivatives = new double[interpolator.interpolatedSecondaryDerivatives.length][]; [EOL]         for (int i = 0; i < interpolatedSecondaryState.length; ++i) { [EOL]             interpolatedSecondaryState[i] = interpolator.interpolatedSecondaryState[i].clone(); [EOL]             interpolatedSecondaryDerivatives[i] = interpolator.interpolatedSecondaryDerivatives[i].clone(); [EOL]         } [EOL]     } [EOL]     finalized = interpolator.finalized; [EOL]     forward = interpolator.forward; [EOL]     dirtyState = interpolator.dirtyState; [EOL]     primaryMapper = interpolator.primaryMapper; [EOL]     secondaryMappers = (interpolator.secondaryMappers == null) ? null : interpolator.secondaryMappers.clone(); [EOL] } <line_num>: 172,207
private void allocateInterpolatedArrays(final int dimension) { [EOL]     if (dimension < 0) { [EOL]         interpolatedState = null; [EOL]         interpolatedDerivatives = null; [EOL]         interpolatedPrimaryState = null; [EOL]         interpolatedPrimaryDerivatives = null; [EOL]         interpolatedSecondaryState = null; [EOL]         interpolatedSecondaryDerivatives = null; [EOL]     } else { [EOL]         interpolatedState = new double[dimension]; [EOL]         interpolatedDerivatives = new double[dimension]; [EOL]         interpolatedPrimaryState = new double[primaryMapper.getDimension()]; [EOL]         interpolatedPrimaryDerivatives = new double[primaryMapper.getDimension()]; [EOL]         if (secondaryMappers == null) { [EOL]             interpolatedSecondaryState = null; [EOL]             interpolatedSecondaryDerivatives = null; [EOL]         } else { [EOL]             interpolatedSecondaryState = new double[secondaryMappers.length][]; [EOL]             interpolatedSecondaryDerivatives = new double[secondaryMappers.length][]; [EOL]             for (int i = 0; i < secondaryMappers.length; ++i) { [EOL]                 interpolatedSecondaryState[i] = new double[secondaryMappers[i].getDimension()]; [EOL]                 interpolatedSecondaryDerivatives[i] = new double[secondaryMappers[i].getDimension()]; [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 212,237
protected void reinitialize(final double[] y, final boolean isForward, final EquationsMapper primary, final EquationsMapper[] secondary) { [EOL]     globalPreviousTime = Double.NaN; [EOL]     globalCurrentTime = Double.NaN; [EOL]     softPreviousTime = Double.NaN; [EOL]     softCurrentTime = Double.NaN; [EOL]     h = Double.NaN; [EOL]     interpolatedTime = Double.NaN; [EOL]     currentState = y; [EOL]     finalized = false; [EOL]     this.forward = isForward; [EOL]     this.dirtyState = true; [EOL]     this.primaryMapper = primary; [EOL]     this.secondaryMappers = secondary.clone(); [EOL]     allocateInterpolatedArrays(y.length); [EOL] } <line_num>: 245,263
public StepInterpolator copy() throws MaxCountExceededException { [EOL]     finalizeStep(); [EOL]     return doCopy(); [EOL] } <line_num>: 266,274
protected abstract StepInterpolator doCopy(); <line_num>: 283,283
public void shift() { [EOL]     globalPreviousTime = globalCurrentTime; [EOL]     softPreviousTime = globalPreviousTime; [EOL]     softCurrentTime = globalCurrentTime; [EOL] } <line_num>: 289,293
public void storeTime(final double t) { [EOL]     globalCurrentTime = t; [EOL]     softCurrentTime = globalCurrentTime; [EOL]     h = globalCurrentTime - globalPreviousTime; [EOL]     setInterpolatedTime(t); [EOL]     finalized = false; [EOL] } <line_num>: 298,308
public void setSoftPreviousTime(final double softPreviousTime) { [EOL]     this.softPreviousTime = softPreviousTime; [EOL] } <line_num>: 320,322
public void setSoftCurrentTime(final double softCurrentTime) { [EOL]     this.softCurrentTime = softCurrentTime; [EOL] } <line_num>: 334,336
public double getGlobalPreviousTime() { [EOL]     return globalPreviousTime; [EOL] } <line_num>: 342,344
public double getGlobalCurrentTime() { [EOL]     return globalCurrentTime; [EOL] } <line_num>: 350,352
public double getPreviousTime() { [EOL]     return softPreviousTime; [EOL] } <line_num>: 359,361
public double getCurrentTime() { [EOL]     return softCurrentTime; [EOL] } <line_num>: 368,370
public double getInterpolatedTime() { [EOL]     return interpolatedTime; [EOL] } <line_num>: 373,375
public void setInterpolatedTime(final double time) { [EOL]     interpolatedTime = time; [EOL]     dirtyState = true; [EOL] } <line_num>: 378,381
public boolean isForward() { [EOL]     return forward; [EOL] } <line_num>: 384,386
protected abstract void computeInterpolatedStateAndDerivatives(double theta, double oneMinusThetaH) throws MaxCountExceededException; <line_num>: 397,399
private void evaluateCompleteInterpolatedState() throws MaxCountExceededException { [EOL]     if (dirtyState) { [EOL]         final double oneMinusThetaH = globalCurrentTime - interpolatedTime; [EOL]         final double theta = (h == 0) ? 0 : (h - oneMinusThetaH) / h; [EOL]         computeInterpolatedStateAndDerivatives(theta, oneMinusThetaH); [EOL]         dirtyState = false; [EOL]     } [EOL] } <line_num>: 404,413
public double[] getInterpolatedState() throws MaxCountExceededException { [EOL]     evaluateCompleteInterpolatedState(); [EOL]     primaryMapper.extractEquationData(interpolatedState, interpolatedPrimaryState); [EOL]     return interpolatedPrimaryState; [EOL] } <line_num>: 416,421
public double[] getInterpolatedDerivatives() throws MaxCountExceededException { [EOL]     evaluateCompleteInterpolatedState(); [EOL]     primaryMapper.extractEquationData(interpolatedDerivatives, interpolatedPrimaryDerivatives); [EOL]     return interpolatedPrimaryDerivatives; [EOL] } <line_num>: 424,429
public double[] getInterpolatedSecondaryState(final int index) throws MaxCountExceededException { [EOL]     evaluateCompleteInterpolatedState(); [EOL]     secondaryMappers[index].extractEquationData(interpolatedState, interpolatedSecondaryState[index]); [EOL]     return interpolatedSecondaryState[index]; [EOL] } <line_num>: 432,437
public double[] getInterpolatedSecondaryDerivatives(final int index) throws MaxCountExceededException { [EOL]     evaluateCompleteInterpolatedState(); [EOL]     secondaryMappers[index].extractEquationData(interpolatedDerivatives, interpolatedSecondaryDerivatives[index]); [EOL]     return interpolatedSecondaryDerivatives[index]; [EOL] } <line_num>: 440,445
public final void finalizeStep() throws MaxCountExceededException { [EOL]     if (!finalized) { [EOL]         doFinalize(); [EOL]         finalized = true; [EOL]     } [EOL] } <line_num>: 488,493
protected void doFinalize() throws MaxCountExceededException { [EOL] } <line_num>: 500,501
public abstract void writeExternal(ObjectOutput out) throws IOException; <line_num>: 504,505
public abstract void readExternal(ObjectInput in) throws IOException, ClassNotFoundException; <line_num>: 508,509
protected void writeBaseExternal(final ObjectOutput out) throws IOException { [EOL]     if (currentState == null) { [EOL]         out.writeInt(-1); [EOL]     } else { [EOL]         out.writeInt(currentState.length); [EOL]     } [EOL]     out.writeDouble(globalPreviousTime); [EOL]     out.writeDouble(globalCurrentTime); [EOL]     out.writeDouble(softPreviousTime); [EOL]     out.writeDouble(softCurrentTime); [EOL]     out.writeDouble(h); [EOL]     out.writeBoolean(forward); [EOL]     out.writeObject(primaryMapper); [EOL]     out.write(secondaryMappers.length); [EOL]     for (final EquationsMapper mapper : secondaryMappers) { [EOL]         out.writeObject(mapper); [EOL]     } [EOL]     if (currentState != null) { [EOL]         for (int i = 0; i < currentState.length; ++i) { [EOL]             out.writeDouble(currentState[i]); [EOL]         } [EOL]     } [EOL]     out.writeDouble(interpolatedTime); [EOL]     try { [EOL]         finalizeStep(); [EOL]     } catch (MaxCountExceededException mcee) { [EOL]         final IOException ioe = new IOException(mcee.getLocalizedMessage()); [EOL]         ioe.initCause(mcee); [EOL]         throw ioe; [EOL]     } [EOL] } <line_num>: 517,557
protected double readBaseExternal(final ObjectInput in) throws IOException, ClassNotFoundException { [EOL]     final int dimension = in.readInt(); [EOL]     globalPreviousTime = in.readDouble(); [EOL]     globalCurrentTime = in.readDouble(); [EOL]     softPreviousTime = in.readDouble(); [EOL]     softCurrentTime = in.readDouble(); [EOL]     h = in.readDouble(); [EOL]     forward = in.readBoolean(); [EOL]     primaryMapper = (EquationsMapper) in.readObject(); [EOL]     secondaryMappers = new EquationsMapper[in.read()]; [EOL]     for (int i = 0; i < secondaryMappers.length; ++i) { [EOL]         secondaryMappers[i] = (EquationsMapper) in.readObject(); [EOL]     } [EOL]     dirtyState = true; [EOL]     if (dimension < 0) { [EOL]         currentState = null; [EOL]     } else { [EOL]         currentState = new double[dimension]; [EOL]         for (int i = 0; i < currentState.length; ++i) { [EOL]             currentState[i] = in.readDouble(); [EOL]         } [EOL]     } [EOL]     interpolatedTime = Double.NaN; [EOL]     allocateInterpolatedArrays(dimension); [EOL]     finalized = true; [EOL]     return in.readDouble(); [EOL] } <line_num>: 570,604
