public AdamsBashforthIntegrator(final int nSteps, final double minStep, final double maxStep, final double scalAbsoluteTolerance, final double scalRelativeTolerance) throws NumberIsTooSmallException { [EOL]     super(METHOD_NAME, nSteps, nSteps, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); [EOL] } <line_num>: 161,168
public AdamsBashforthIntegrator(final int nSteps, final double minStep, final double maxStep, final double[] vecAbsoluteTolerance, final double[] vecRelativeTolerance) throws IllegalArgumentException { [EOL]     super(METHOD_NAME, nSteps, nSteps, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance); [EOL] } <line_num>: 183,190
@Override [EOL] public void integrate(final ExpandableStatefulODE equations, final double t) throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException { [EOL]     sanityChecks(equations, t); [EOL]     setEquations(equations); [EOL]     final boolean forward = t > equations.getTime(); [EOL]     final double[] y0 = equations.getCompleteState(); [EOL]     final double[] y = y0.clone(); [EOL]     final double[] yDot = new double[y.length]; [EOL]     final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator(); [EOL]     interpolator.reinitialize(y, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers()); [EOL]     initIntegration(equations.getTime(), y0, t); [EOL]     start(equations.getTime(), y, t); [EOL]     interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck); [EOL]     interpolator.storeTime(stepStart); [EOL]     final int lastRow = nordsieck.getRowDimension() - 1; [EOL]     double hNew = stepSize; [EOL]     interpolator.rescale(hNew); [EOL]     isLastStep = false; [EOL]     do { [EOL]         double error = 10; [EOL]         while (error >= 1.0) { [EOL]             stepSize = hNew; [EOL]             error = 0; [EOL]             for (int i = 0; i < mainSetDimension; ++i) { [EOL]                 final double yScale = FastMath.abs(y[i]); [EOL]                 final double tol = (vecAbsoluteTolerance == null) ? (scalAbsoluteTolerance + scalRelativeTolerance * yScale) : (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale); [EOL]                 final double ratio = nordsieck.getEntry(lastRow, i) / tol; [EOL]                 error += ratio * ratio; [EOL]             } [EOL]             error = FastMath.sqrt(error / mainSetDimension); [EOL]             if (error >= 1.0) { [EOL]                 final double factor = computeStepGrowShrinkFactor(error); [EOL]                 hNew = filterStep(stepSize * factor, forward, false); [EOL]                 interpolator.rescale(hNew); [EOL]             } [EOL]         } [EOL]         final double stepEnd = stepStart + stepSize; [EOL]         interpolator.shift(); [EOL]         interpolator.setInterpolatedTime(stepEnd); [EOL]         final ExpandableStatefulODE expandable = getExpandable(); [EOL]         final EquationsMapper primary = expandable.getPrimaryMapper(); [EOL]         primary.insertEquationData(interpolator.getInterpolatedState(), y); [EOL]         int index = 0; [EOL]         for (final EquationsMapper secondary : expandable.getSecondaryMappers()) { [EOL]             secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index), y); [EOL]             ++index; [EOL]         } [EOL]         computeDerivatives(stepEnd, y, yDot); [EOL]         final double[] predictedScaled = new double[y0.length]; [EOL]         for (int j = 0; j < y0.length; ++j) { [EOL]             predictedScaled[j] = stepSize * yDot[j]; [EOL]         } [EOL]         final Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck); [EOL]         updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp); [EOL]         interpolator.reinitialize(stepEnd, stepSize, predictedScaled, nordsieckTmp); [EOL]         interpolator.storeTime(stepEnd); [EOL]         stepStart = acceptStep(interpolator, y, yDot, t); [EOL]         scaled = predictedScaled; [EOL]         nordsieck = nordsieckTmp; [EOL]         interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck); [EOL]         if (!isLastStep) { [EOL]             interpolator.storeTime(stepStart); [EOL]             if (resetOccurred) { [EOL]                 start(stepStart, y, t); [EOL]                 interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck); [EOL]             } [EOL]             final double factor = computeStepGrowShrinkFactor(error); [EOL]             final double scaledH = stepSize * factor; [EOL]             final double nextT = stepStart + scaledH; [EOL]             final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t); [EOL]             hNew = filterStep(scaledH, forward, nextIsLast); [EOL]             final double filteredNextT = stepStart + hNew; [EOL]             final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t); [EOL]             if (filteredNextIsLast) { [EOL]                 hNew = t - stepStart; [EOL]             } [EOL]             interpolator.rescale(hNew); [EOL]         } [EOL]     } while (!isLastStep); [EOL]     equations.setTime(stepStart); [EOL]     equations.setCompleteState(y); [EOL]     resetInternalState(); [EOL] } <line_num>: 193,324
