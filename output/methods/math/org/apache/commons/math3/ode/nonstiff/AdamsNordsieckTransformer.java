private AdamsNordsieckTransformer(final int nSteps) { [EOL]     FieldMatrix<BigFraction> bigP = buildP(nSteps); [EOL]     FieldDecompositionSolver<BigFraction> pSolver = new FieldLUDecomposition<BigFraction>(bigP).getSolver(); [EOL]     BigFraction[] u = new BigFraction[nSteps]; [EOL]     Arrays.fill(u, BigFraction.ONE); [EOL]     BigFraction[] bigC1 = pSolver.solve(new ArrayFieldVector<BigFraction>(u, false)).toArray(); [EOL]     BigFraction[][] shiftedP = bigP.getData(); [EOL]     for (int i = shiftedP.length - 1; i > 0; --i) { [EOL]         shiftedP[i] = shiftedP[i - 1]; [EOL]     } [EOL]     shiftedP[0] = new BigFraction[nSteps]; [EOL]     Arrays.fill(shiftedP[0], BigFraction.ZERO); [EOL]     FieldMatrix<BigFraction> bigMSupdate = pSolver.solve(new Array2DRowFieldMatrix<BigFraction>(shiftedP, false)); [EOL]     update = MatrixUtils.bigFractionMatrixToRealMatrix(bigMSupdate); [EOL]     c1 = new double[nSteps]; [EOL]     for (int i = 0; i < nSteps; ++i) { [EOL]         c1[i] = bigC1[i].doubleValue(); [EOL]     } [EOL] } <line_num>: 151,183
public static AdamsNordsieckTransformer getInstance(final int nSteps) { [EOL]     synchronized (CACHE) { [EOL]         AdamsNordsieckTransformer t = CACHE.get(nSteps); [EOL]         if (t == null) { [EOL]             t = new AdamsNordsieckTransformer(nSteps); [EOL]             CACHE.put(nSteps, t); [EOL]         } [EOL]         return t; [EOL]     } [EOL] } <line_num>: 190,199
public int getNSteps() { [EOL]     return c1.length; [EOL] } <line_num>: 206,208
private FieldMatrix<BigFraction> buildP(final int nSteps) { [EOL]     final BigFraction[][] pData = new BigFraction[nSteps][nSteps]; [EOL]     for (int i = 0; i < pData.length; ++i) { [EOL]         final BigFraction[] pI = pData[i]; [EOL]         final int factor = -(i + 1); [EOL]         int aj = factor; [EOL]         for (int j = 0; j < pI.length; ++j) { [EOL]             pI[j] = new BigFraction(aj * (j + 2)); [EOL]             aj *= factor; [EOL]         } [EOL]     } [EOL]     return new Array2DRowFieldMatrix<BigFraction>(pData, false); [EOL] } <line_num>: 223,240
public Array2DRowRealMatrix initializeHighOrderDerivatives(final double h, final double[] t, final double[][] y, final double[][] yDot) { [EOL]     final double[][] a = new double[2 * (y.length - 1)][c1.length]; [EOL]     final double[][] b = new double[2 * (y.length - 1)][y[0].length]; [EOL]     final double[] y0 = y[0]; [EOL]     final double[] yDot0 = yDot[0]; [EOL]     for (int i = 1; i < y.length; ++i) { [EOL]         final double di = t[i] - t[0]; [EOL]         final double ratio = di / h; [EOL]         double dikM1Ohk = 1 / h; [EOL]         final double[] aI = a[2 * i - 2]; [EOL]         final double[] aDotI = a[2 * i - 1]; [EOL]         for (int j = 0; j < aI.length; ++j) { [EOL]             dikM1Ohk *= ratio; [EOL]             aI[j] = di * dikM1Ohk; [EOL]             aDotI[j] = (j + 2) * dikM1Ohk; [EOL]         } [EOL]         final double[] yI = y[i]; [EOL]         final double[] yDotI = yDot[i]; [EOL]         final double[] bI = b[2 * i - 2]; [EOL]         final double[] bDotI = b[2 * i - 1]; [EOL]         for (int j = 0; j < yI.length; ++j) { [EOL]             bI[j] = yI[j] - y0[j] - di * yDot0[j]; [EOL]             bDotI[j] = yDotI[j] - yDot0[j]; [EOL]         } [EOL]     } [EOL]     QRDecomposition decomposition; [EOL]     decomposition = new QRDecomposition(new Array2DRowRealMatrix(a, false)); [EOL]     RealMatrix x = decomposition.getSolver().solve(new Array2DRowRealMatrix(b, false)); [EOL]     return new Array2DRowRealMatrix(x.getData(), false); [EOL] } <line_num>: 250,297
public Array2DRowRealMatrix updateHighOrderDerivativesPhase1(final Array2DRowRealMatrix highOrder) { [EOL]     return update.multiply(highOrder); [EOL] } <line_num>: 310,312
public void updateHighOrderDerivativesPhase2(final double[] start, final double[] end, final Array2DRowRealMatrix highOrder) { [EOL]     final double[][] data = highOrder.getDataRef(); [EOL]     for (int i = 0; i < data.length; ++i) { [EOL]         final double[] dataI = data[i]; [EOL]         final double c1I = c1[i]; [EOL]         for (int j = 0; j < dataI.length; ++j) { [EOL]             dataI[j] += c1I * (start[j] - end[j]); [EOL]         } [EOL]     } [EOL] } <line_num>: 327,338
