protected RungeKuttaIntegrator(final String name, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double step) { [EOL]     super(name); [EOL]     this.c = c; [EOL]     this.a = a; [EOL]     this.b = b; [EOL]     this.prototype = prototype; [EOL]     this.step = FastMath.abs(step); [EOL] } <line_num>: 81,91
@Override [EOL] public void integrate(final ExpandableStatefulODE equations, final double t) throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException { [EOL]     sanityChecks(equations, t); [EOL]     setEquations(equations); [EOL]     final boolean forward = t > equations.getTime(); [EOL]     final double[] y0 = equations.getCompleteState(); [EOL]     final double[] y = y0.clone(); [EOL]     final int stages = c.length + 1; [EOL]     final double[][] yDotK = new double[stages][]; [EOL]     for (int i = 0; i < stages; ++i) { [EOL]         yDotK[i] = new double[y0.length]; [EOL]     } [EOL]     final double[] yTmp = y0.clone(); [EOL]     final double[] yDotTmp = new double[y0.length]; [EOL]     final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy(); [EOL]     interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers()); [EOL]     interpolator.storeTime(equations.getTime()); [EOL]     stepStart = equations.getTime(); [EOL]     stepSize = forward ? step : -step; [EOL]     initIntegration(equations.getTime(), y0, t); [EOL]     isLastStep = false; [EOL]     do { [EOL]         interpolator.shift(); [EOL]         computeDerivatives(stepStart, y, yDotK[0]); [EOL]         for (int k = 1; k < stages; ++k) { [EOL]             for (int j = 0; j < y0.length; ++j) { [EOL]                 double sum = a[k - 1][0] * yDotK[0][j]; [EOL]                 for (int l = 1; l < k; ++l) { [EOL]                     sum += a[k - 1][l] * yDotK[l][j]; [EOL]                 } [EOL]                 yTmp[j] = y[j] + stepSize * sum; [EOL]             } [EOL]             computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]); [EOL]         } [EOL]         for (int j = 0; j < y0.length; ++j) { [EOL]             double sum = b[0] * yDotK[0][j]; [EOL]             for (int l = 1; l < stages; ++l) { [EOL]                 sum += b[l] * yDotK[l][j]; [EOL]             } [EOL]             yTmp[j] = y[j] + stepSize * sum; [EOL]         } [EOL]         interpolator.storeTime(stepStart + stepSize); [EOL]         System.arraycopy(yTmp, 0, y, 0, y0.length); [EOL]         System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length); [EOL]         stepStart = acceptStep(interpolator, y, yDotTmp, t); [EOL]         if (!isLastStep) { [EOL]             interpolator.storeTime(stepStart); [EOL]             final double nextT = stepStart + stepSize; [EOL]             final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t); [EOL]             if (nextIsLast) { [EOL]                 stepSize = t - stepStart; [EOL]             } [EOL]         } [EOL]     } while (!isLastStep); [EOL]     equations.setTime(stepStart); [EOL]     equations.setCompleteState(y); [EOL]     stepStart = Double.NaN; [EOL]     stepSize = Double.NaN; [EOL] } <line_num>: 94,186
