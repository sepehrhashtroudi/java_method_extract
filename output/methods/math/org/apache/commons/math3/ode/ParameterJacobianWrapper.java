public ParameterJacobianWrapper(final FirstOrderDifferentialEquations fode, final ParameterizedODE pode, final ParameterConfiguration[] paramsAndSteps) { [EOL]     this.fode = fode; [EOL]     this.pode = pode; [EOL]     this.hParam = new HashMap<String, Double>(); [EOL]     for (final ParameterConfiguration param : paramsAndSteps) { [EOL]         final String name = param.getParameterName(); [EOL]         if (pode.isSupported(name)) { [EOL]             hParam.put(name, param.getHP()); [EOL]         } [EOL]     } [EOL] } <line_num>: 50,64
public Collection<String> getParametersNames() { [EOL]     return pode.getParametersNames(); [EOL] } <line_num>: 67,69
public boolean isSupported(String name) { [EOL]     return pode.isSupported(name); [EOL] } <line_num>: 72,74
public void computeParameterJacobian(double t, double[] y, double[] yDot, String paramName, double[] dFdP) throws DimensionMismatchException, MaxCountExceededException { [EOL]     final int n = fode.getDimension(); [EOL]     if (pode.isSupported(paramName)) { [EOL]         final double[] tmpDot = new double[n]; [EOL]         final double p = pode.getParameter(paramName); [EOL]         final double hP = hParam.get(paramName); [EOL]         pode.setParameter(paramName, p + hP); [EOL]         fode.computeDerivatives(t, y, tmpDot); [EOL]         for (int i = 0; i < n; ++i) { [EOL]             dFdP[i] = (tmpDot[i] - yDot[i]) / hP; [EOL]         } [EOL]         pode.setParameter(paramName, p); [EOL]     } else { [EOL]         Arrays.fill(dFdP, 0, n, 0.0); [EOL]     } [EOL] } <line_num>: 77,98
