public EventState(final EventHandler handler, final double maxCheckInterval, final double convergence, final int maxIterationCount, final UnivariateSolver solver) { [EOL]     this.handler = handler; [EOL]     this.maxCheckInterval = maxCheckInterval; [EOL]     this.convergence = FastMath.abs(convergence); [EOL]     this.maxIterationCount = maxIterationCount; [EOL]     this.solver = solver; [EOL]     expandable = null; [EOL]     t0 = Double.NaN; [EOL]     g0 = Double.NaN; [EOL]     g0Positive = true; [EOL]     pendingEvent = false; [EOL]     pendingEventTime = Double.NaN; [EOL]     previousEventTime = Double.NaN; [EOL]     increasing = true; [EOL]     nextAction = EventHandler.Action.CONTINUE; [EOL] } <line_num>: 105,125
public LocalMaxCountExceededException(final MaxCountExceededException exception) { [EOL]     wrapped = exception; [EOL] } <line_num>: 403,405
public EventHandler getEventHandler() { [EOL]     return handler; [EOL] } <line_num>: 130,132
public void setExpandable(final ExpandableStatefulODE expandable) { [EOL]     this.expandable = expandable; [EOL] } <line_num>: 137,139
public double getMaxCheckInterval() { [EOL]     return maxCheckInterval; [EOL] } <line_num>: 144,146
public double getConvergence() { [EOL]     return convergence; [EOL] } <line_num>: 151,153
public int getMaxIterationCount() { [EOL]     return maxIterationCount; [EOL] } <line_num>: 158,160
public void reinitializeBegin(final StepInterpolator interpolator) throws MaxCountExceededException { [EOL]     t0 = interpolator.getPreviousTime(); [EOL]     interpolator.setInterpolatedTime(t0); [EOL]     g0 = handler.g(t0, getCompleteState(interpolator)); [EOL]     if (g0 == 0) { [EOL]         final double epsilon = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(solver.getRelativeAccuracy() * t0)); [EOL]         final double tStart = t0 + 0.5 * epsilon; [EOL]         interpolator.setInterpolatedTime(tStart); [EOL]         g0 = handler.g(tStart, getCompleteState(interpolator)); [EOL]     } [EOL]     g0Positive = g0 >= 0; [EOL] } <line_num>: 167,195
private double[] getCompleteState(final StepInterpolator interpolator) { [EOL]     final double[] complete = new double[expandable.getTotalDimension()]; [EOL]     expandable.getPrimaryMapper().insertEquationData(interpolator.getInterpolatedState(), complete); [EOL]     int index = 0; [EOL]     for (EquationsMapper secondary : expandable.getSecondaryMappers()) { [EOL]         secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index++), complete); [EOL]     } [EOL]     return complete; [EOL] } <line_num>: 201,215
public double value(final double t) throws LocalMaxCountExceededException { [EOL]     try { [EOL]         interpolator.setInterpolatedTime(t); [EOL]         return handler.g(t, getCompleteState(interpolator)); [EOL]     } catch (MaxCountExceededException mcee) { [EOL]         throw new LocalMaxCountExceededException(mcee); [EOL]     } [EOL] } <line_num>: 240,247
public boolean evaluateStep(final StepInterpolator interpolator) throws MaxCountExceededException, NoBracketingException { [EOL]     try { [EOL]         forward = interpolator.isForward(); [EOL]         final double t1 = interpolator.getCurrentTime(); [EOL]         final double dt = t1 - t0; [EOL]         if (FastMath.abs(dt) < convergence) { [EOL]             return false; [EOL]         } [EOL]         final int n = FastMath.max(1, (int) FastMath.ceil(FastMath.abs(dt) / maxCheckInterval)); [EOL]         final double h = dt / n; [EOL]         final UnivariateFunction f = new UnivariateFunction() { [EOL]  [EOL]             public double value(final double t) throws LocalMaxCountExceededException { [EOL]                 try { [EOL]                     interpolator.setInterpolatedTime(t); [EOL]                     return handler.g(t, getCompleteState(interpolator)); [EOL]                 } catch (MaxCountExceededException mcee) { [EOL]                     throw new LocalMaxCountExceededException(mcee); [EOL]                 } [EOL]             } [EOL]         }; [EOL]         double ta = t0; [EOL]         double ga = g0; [EOL]         for (int i = 0; i < n; ++i) { [EOL]             final double tb = t0 + (i + 1) * h; [EOL]             interpolator.setInterpolatedTime(tb); [EOL]             final double gb = handler.g(tb, getCompleteState(interpolator)); [EOL]             if (g0Positive ^ (gb >= 0)) { [EOL]                 increasing = gb >= ga; [EOL]                 final double root; [EOL]                 if (solver instanceof BracketedUnivariateSolver<?>) { [EOL]                     @SuppressWarnings("unchecked") [EOL]                     BracketedUnivariateSolver<UnivariateFunction> bracketing = (BracketedUnivariateSolver<UnivariateFunction>) solver; [EOL]                     root = forward ? bracketing.solve(maxIterationCount, f, ta, tb, AllowedSolution.RIGHT_SIDE) : bracketing.solve(maxIterationCount, f, tb, ta, AllowedSolution.LEFT_SIDE); [EOL]                 } else { [EOL]                     final double baseRoot = forward ? solver.solve(maxIterationCount, f, ta, tb) : solver.solve(maxIterationCount, f, tb, ta); [EOL]                     final int remainingEval = maxIterationCount - solver.getEvaluations(); [EOL]                     BracketedUnivariateSolver<UnivariateFunction> bracketing = new PegasusSolver(solver.getRelativeAccuracy(), solver.getAbsoluteAccuracy()); [EOL]                     root = forward ? UnivariateSolverUtils.forceSide(remainingEval, f, bracketing, baseRoot, ta, tb, AllowedSolution.RIGHT_SIDE) : UnivariateSolverUtils.forceSide(remainingEval, f, bracketing, baseRoot, tb, ta, AllowedSolution.LEFT_SIDE); [EOL]                 } [EOL]                 if ((!Double.isNaN(previousEventTime)) && (FastMath.abs(root - ta) <= convergence) && (FastMath.abs(root - previousEventTime) <= convergence)) { [EOL]                     ta = forward ? ta + convergence : ta - convergence; [EOL]                     ga = f.value(ta); [EOL]                     --i; [EOL]                 } else if (Double.isNaN(previousEventTime) || (FastMath.abs(previousEventTime - root) > convergence)) { [EOL]                     pendingEventTime = root; [EOL]                     pendingEvent = true; [EOL]                     return true; [EOL]                 } else { [EOL]                     ta = tb; [EOL]                     ga = gb; [EOL]                 } [EOL]             } else { [EOL]                 ta = tb; [EOL]                 ga = gb; [EOL]             } [EOL]         } [EOL]         pendingEvent = false; [EOL]         pendingEventTime = Double.NaN; [EOL]         return false; [EOL]     } catch (LocalMaxCountExceededException lmcee) { [EOL]         throw lmcee.getException(); [EOL]     } [EOL] } <line_num>: 225,325
public double getEventTime() { [EOL]     return pendingEvent ? pendingEventTime : (forward ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY); [EOL] } <line_num>: 331,335
public void stepAccepted(final double t, final double[] y) { [EOL]     t0 = t; [EOL]     g0 = handler.g(t, y); [EOL]     if (pendingEvent && (FastMath.abs(pendingEventTime - t) <= convergence)) { [EOL]         previousEventTime = t; [EOL]         g0Positive = increasing; [EOL]         nextAction = handler.eventOccurred(t, y, !(increasing ^ forward)); [EOL]     } else { [EOL]         g0Positive = g0 >= 0; [EOL]         nextAction = EventHandler.Action.CONTINUE; [EOL]     } [EOL] } <line_num>: 343,357
public boolean stop() { [EOL]     return nextAction == EventHandler.Action.STOP; [EOL] } <line_num>: 363,365
public boolean reset(final double t, final double[] y) { [EOL]     if (!(pendingEvent && (FastMath.abs(pendingEventTime - t) <= convergence))) { [EOL]         return false; [EOL]     } [EOL]     if (nextAction == EventHandler.Action.RESET_STATE) { [EOL]         handler.resetState(t, y); [EOL]     } [EOL]     pendingEvent = false; [EOL]     pendingEventTime = Double.NaN; [EOL]     return (nextAction == EventHandler.Action.RESET_STATE) || (nextAction == EventHandler.Action.RESET_DERIVATIVES); [EOL] } <line_num>: 374,389
public MaxCountExceededException getException() { [EOL]     return wrapped; [EOL] } <line_num>: 410,412
