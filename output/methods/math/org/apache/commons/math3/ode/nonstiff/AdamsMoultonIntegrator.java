public AdamsMoultonIntegrator(final int nSteps, final double minStep, final double maxStep, final double scalAbsoluteTolerance, final double scalRelativeTolerance) throws NumberIsTooSmallException { [EOL]     super(METHOD_NAME, nSteps, nSteps + 1, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); [EOL] } <line_num>: 177,184
public AdamsMoultonIntegrator(final int nSteps, final double minStep, final double maxStep, final double[] vecAbsoluteTolerance, final double[] vecRelativeTolerance) throws IllegalArgumentException { [EOL]     super(METHOD_NAME, nSteps, nSteps + 1, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance); [EOL] } <line_num>: 199,206
public Corrector(final double[] previous, final double[] scaled, final double[] state) { [EOL]     this.previous = previous; [EOL]     this.scaled = scaled; [EOL]     this.after = state; [EOL]     this.before = state.clone(); [EOL] } <line_num>: 371,376
@Override [EOL] public void integrate(final ExpandableStatefulODE equations, final double t) throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException { [EOL]     sanityChecks(equations, t); [EOL]     setEquations(equations); [EOL]     final boolean forward = t > equations.getTime(); [EOL]     final double[] y0 = equations.getCompleteState(); [EOL]     final double[] y = y0.clone(); [EOL]     final double[] yDot = new double[y.length]; [EOL]     final double[] yTmp = new double[y.length]; [EOL]     final double[] predictedScaled = new double[y.length]; [EOL]     Array2DRowRealMatrix nordsieckTmp = null; [EOL]     final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator(); [EOL]     interpolator.reinitialize(y, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers()); [EOL]     initIntegration(equations.getTime(), y0, t); [EOL]     start(equations.getTime(), y, t); [EOL]     interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck); [EOL]     interpolator.storeTime(stepStart); [EOL]     double hNew = stepSize; [EOL]     interpolator.rescale(hNew); [EOL]     isLastStep = false; [EOL]     do { [EOL]         double error = 10; [EOL]         while (error >= 1.0) { [EOL]             stepSize = hNew; [EOL]             final double stepEnd = stepStart + stepSize; [EOL]             interpolator.setInterpolatedTime(stepEnd); [EOL]             final ExpandableStatefulODE expandable = getExpandable(); [EOL]             final EquationsMapper primary = expandable.getPrimaryMapper(); [EOL]             primary.insertEquationData(interpolator.getInterpolatedState(), yTmp); [EOL]             int index = 0; [EOL]             for (final EquationsMapper secondary : expandable.getSecondaryMappers()) { [EOL]                 secondary.insertEquationData(interpolator.getInterpolatedSecondaryState(index), yTmp); [EOL]                 ++index; [EOL]             } [EOL]             computeDerivatives(stepEnd, yTmp, yDot); [EOL]             for (int j = 0; j < y0.length; ++j) { [EOL]                 predictedScaled[j] = stepSize * yDot[j]; [EOL]             } [EOL]             nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck); [EOL]             updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp); [EOL]             error = nordsieckTmp.walkInOptimizedOrder(new Corrector(y, predictedScaled, yTmp)); [EOL]             if (error >= 1.0) { [EOL]                 final double factor = computeStepGrowShrinkFactor(error); [EOL]                 hNew = filterStep(stepSize * factor, forward, false); [EOL]                 interpolator.rescale(hNew); [EOL]             } [EOL]         } [EOL]         final double stepEnd = stepStart + stepSize; [EOL]         computeDerivatives(stepEnd, yTmp, yDot); [EOL]         final double[] correctedScaled = new double[y0.length]; [EOL]         for (int j = 0; j < y0.length; ++j) { [EOL]             correctedScaled[j] = stepSize * yDot[j]; [EOL]         } [EOL]         updateHighOrderDerivativesPhase2(predictedScaled, correctedScaled, nordsieckTmp); [EOL]         System.arraycopy(yTmp, 0, y, 0, y.length); [EOL]         interpolator.reinitialize(stepEnd, stepSize, correctedScaled, nordsieckTmp); [EOL]         interpolator.storeTime(stepStart); [EOL]         interpolator.shift(); [EOL]         interpolator.storeTime(stepEnd); [EOL]         stepStart = acceptStep(interpolator, y, yDot, t); [EOL]         scaled = correctedScaled; [EOL]         nordsieck = nordsieckTmp; [EOL]         if (!isLastStep) { [EOL]             interpolator.storeTime(stepStart); [EOL]             if (resetOccurred) { [EOL]                 start(stepStart, y, t); [EOL]                 interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck); [EOL]             } [EOL]             final double factor = computeStepGrowShrinkFactor(error); [EOL]             final double scaledH = stepSize * factor; [EOL]             final double nextT = stepStart + scaledH; [EOL]             final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t); [EOL]             hNew = filterStep(scaledH, forward, nextIsLast); [EOL]             final double filteredNextT = stepStart + hNew; [EOL]             final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t); [EOL]             if (filteredNextIsLast) { [EOL]                 hNew = t - stepStart; [EOL]             } [EOL]             interpolator.rescale(hNew); [EOL]         } [EOL]     } while (!isLastStep); [EOL]     equations.setTime(stepStart); [EOL]     equations.setCompleteState(y); [EOL]     resetInternalState(); [EOL] } <line_num>: 210,342
public void start(int rows, int columns, int startRow, int endRow, int startColumn, int endColumn) { [EOL]     Arrays.fill(after, 0.0); [EOL] } <line_num>: 379,382
public void visit(int row, int column, double value) { [EOL]     if ((row & 0x1) == 0) { [EOL]         after[column] -= value; [EOL]     } else { [EOL]         after[column] += value; [EOL]     } [EOL] } <line_num>: 385,391
public double end() { [EOL]     double error = 0; [EOL]     for (int i = 0; i < after.length; ++i) { [EOL]         after[i] += previous[i] + scaled[i]; [EOL]         if (i < mainSetDimension) { [EOL]             final double yScale = FastMath.max(FastMath.abs(previous[i]), FastMath.abs(after[i])); [EOL]             final double tol = (vecAbsoluteTolerance == null) ? (scalAbsoluteTolerance + scalRelativeTolerance * yScale) : (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale); [EOL]             final double ratio = (after[i] - before[i]) / tol; [EOL]             error += ratio * ratio; [EOL]         } [EOL]     } [EOL]     return FastMath.sqrt(error / mainSetDimension); [EOL] } <line_num>: 402,419
