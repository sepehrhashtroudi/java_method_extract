public NordsieckStepInterpolator() { [EOL] } <line_num>: 74,75
public NordsieckStepInterpolator(final NordsieckStepInterpolator interpolator) { [EOL]     super(interpolator); [EOL]     scalingH = interpolator.scalingH; [EOL]     referenceTime = interpolator.referenceTime; [EOL]     if (interpolator.scaled != null) { [EOL]         scaled = interpolator.scaled.clone(); [EOL]     } [EOL]     if (interpolator.nordsieck != null) { [EOL]         nordsieck = new Array2DRowRealMatrix(interpolator.nordsieck.getDataRef(), true); [EOL]     } [EOL]     if (interpolator.stateVariation != null) { [EOL]         stateVariation = interpolator.stateVariation.clone(); [EOL]     } [EOL] } <line_num>: 82,95
@Override [EOL] protected StepInterpolator doCopy() { [EOL]     return new NordsieckStepInterpolator(this); [EOL] } <line_num>: 98,101
@Override [EOL] public void reinitialize(final double[] y, final boolean forward, final EquationsMapper primaryMapper, final EquationsMapper[] secondaryMappers) { [EOL]     super.reinitialize(y, forward, primaryMapper, secondaryMappers); [EOL]     stateVariation = new double[y.length]; [EOL] } <line_num>: 112,118
public void reinitialize(final double time, final double stepSize, final double[] scaledDerivative, final Array2DRowRealMatrix nordsieckVector) { [EOL]     this.referenceTime = time; [EOL]     this.scalingH = stepSize; [EOL]     this.scaled = scaledDerivative; [EOL]     this.nordsieck = nordsieckVector; [EOL]     setInterpolatedTime(getInterpolatedTime()); [EOL] } <line_num>: 130,141
public void rescale(final double stepSize) { [EOL]     final double ratio = stepSize / scalingH; [EOL]     for (int i = 0; i < scaled.length; ++i) { [EOL]         scaled[i] *= ratio; [EOL]     } [EOL]     final double[][] nData = nordsieck.getDataRef(); [EOL]     double power = ratio; [EOL]     for (int i = 0; i < nData.length; ++i) { [EOL]         power *= ratio; [EOL]         final double[] nDataI = nData[i]; [EOL]         for (int j = 0; j < nDataI.length; ++j) { [EOL]             nDataI[j] *= power; [EOL]         } [EOL]     } [EOL]     scalingH = stepSize; [EOL] } <line_num>: 148,167
public double[] getInterpolatedStateVariation() throws MaxCountExceededException { [EOL]     getInterpolatedState(); [EOL]     return stateVariation; [EOL] } <line_num>: 181,186
@Override [EOL] protected void computeInterpolatedStateAndDerivatives(final double theta, final double oneMinusThetaH) { [EOL]     final double x = interpolatedTime - referenceTime; [EOL]     final double normalizedAbscissa = x / scalingH; [EOL]     Arrays.fill(stateVariation, 0.0); [EOL]     Arrays.fill(interpolatedDerivatives, 0.0); [EOL]     final double[][] nData = nordsieck.getDataRef(); [EOL]     for (int i = nData.length - 1; i >= 0; --i) { [EOL]         final int order = i + 2; [EOL]         final double[] nDataI = nData[i]; [EOL]         final double power = FastMath.pow(normalizedAbscissa, order); [EOL]         for (int j = 0; j < nDataI.length; ++j) { [EOL]             final double d = nDataI[j] * power; [EOL]             stateVariation[j] += d; [EOL]             interpolatedDerivatives[j] += order * d; [EOL]         } [EOL]     } [EOL]     for (int j = 0; j < currentState.length; ++j) { [EOL]         stateVariation[j] += scaled[j] * normalizedAbscissa; [EOL]         interpolatedState[j] = currentState[j] + stateVariation[j]; [EOL]         interpolatedDerivatives[j] = (interpolatedDerivatives[j] + scaled[j] * normalizedAbscissa) / x; [EOL]     } [EOL] } <line_num>: 189,219
@Override [EOL] public void writeExternal(final ObjectOutput out) throws IOException { [EOL]     writeBaseExternal(out); [EOL]     out.writeDouble(scalingH); [EOL]     out.writeDouble(referenceTime); [EOL]     final int n = (currentState == null) ? -1 : currentState.length; [EOL]     if (scaled == null) { [EOL]         out.writeBoolean(false); [EOL]     } else { [EOL]         out.writeBoolean(true); [EOL]         for (int j = 0; j < n; ++j) { [EOL]             out.writeDouble(scaled[j]); [EOL]         } [EOL]     } [EOL]     if (nordsieck == null) { [EOL]         out.writeBoolean(false); [EOL]     } else { [EOL]         out.writeBoolean(true); [EOL]         out.writeObject(nordsieck); [EOL]     } [EOL] } <line_num>: 222,252
@Override [EOL] public void readExternal(final ObjectInput in) throws IOException, ClassNotFoundException { [EOL]     final double t = readBaseExternal(in); [EOL]     scalingH = in.readDouble(); [EOL]     referenceTime = in.readDouble(); [EOL]     final int n = (currentState == null) ? -1 : currentState.length; [EOL]     final boolean hasScaled = in.readBoolean(); [EOL]     if (hasScaled) { [EOL]         scaled = new double[n]; [EOL]         for (int j = 0; j < n; ++j) { [EOL]             scaled[j] = in.readDouble(); [EOL]         } [EOL]     } else { [EOL]         scaled = null; [EOL]     } [EOL]     final boolean hasNordsieck = in.readBoolean(); [EOL]     if (hasNordsieck) { [EOL]         nordsieck = (Array2DRowRealMatrix) in.readObject(); [EOL]     } else { [EOL]         nordsieck = null; [EOL]     } [EOL]     if (hasScaled && hasNordsieck) { [EOL]         stateVariation = new double[n]; [EOL]         setInterpolatedTime(t); [EOL]     } else { [EOL]         stateVariation = null; [EOL]     } [EOL] } <line_num>: 255,292
