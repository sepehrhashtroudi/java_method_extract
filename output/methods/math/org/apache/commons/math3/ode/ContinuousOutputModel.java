public ContinuousOutputModel() { [EOL]     steps = new ArrayList<StepInterpolator>(); [EOL]     initialTime = Double.NaN; [EOL]     finalTime = Double.NaN; [EOL]     forward = true; [EOL]     index = 0; [EOL] } <line_num>: 114,120
public void append(final ContinuousOutputModel model) throws MathIllegalArgumentException, MaxCountExceededException { [EOL]     if (model.steps.size() == 0) { [EOL]         return; [EOL]     } [EOL]     if (steps.size() == 0) { [EOL]         initialTime = model.initialTime; [EOL]         forward = model.forward; [EOL]     } else { [EOL]         if (getInterpolatedState().length != model.getInterpolatedState().length) { [EOL]             throw new DimensionMismatchException(model.getInterpolatedState().length, getInterpolatedState().length); [EOL]         } [EOL]         if (forward ^ model.forward) { [EOL]             throw new MathIllegalArgumentException(LocalizedFormats.PROPAGATION_DIRECTION_MISMATCH); [EOL]         } [EOL]         final StepInterpolator lastInterpolator = steps.get(index); [EOL]         final double current = lastInterpolator.getCurrentTime(); [EOL]         final double previous = lastInterpolator.getPreviousTime(); [EOL]         final double step = current - previous; [EOL]         final double gap = model.getInitialTime() - current; [EOL]         if (FastMath.abs(gap) > 1.0e-3 * FastMath.abs(step)) { [EOL]             throw new MathIllegalArgumentException(LocalizedFormats.HOLE_BETWEEN_MODELS_TIME_RANGES, FastMath.abs(gap)); [EOL]         } [EOL]     } [EOL]     for (StepInterpolator interpolator : model.steps) { [EOL]         steps.add(interpolator.copy()); [EOL]     } [EOL]     index = steps.size() - 1; [EOL]     finalTime = (steps.get(index)).getCurrentTime(); [EOL] } <line_num>: 130,170
public void init(double t0, double[] y0, double t) { [EOL]     initialTime = Double.NaN; [EOL]     finalTime = Double.NaN; [EOL]     forward = true; [EOL]     index = 0; [EOL]     steps.clear(); [EOL] } <line_num>: 173,179
public void handleStep(final StepInterpolator interpolator, final boolean isLast) throws MaxCountExceededException { [EOL]     if (steps.size() == 0) { [EOL]         initialTime = interpolator.getPreviousTime(); [EOL]         forward = interpolator.isForward(); [EOL]     } [EOL]     steps.add(interpolator.copy()); [EOL]     if (isLast) { [EOL]         finalTime = interpolator.getCurrentTime(); [EOL]         index = steps.size() - 1; [EOL]     } [EOL] } <line_num>: 189,204
public double getInitialTime() { [EOL]     return initialTime; [EOL] } <line_num>: 210,212
public double getFinalTime() { [EOL]     return finalTime; [EOL] } <line_num>: 218,220
public double getInterpolatedTime() { [EOL]     return steps.get(index).getInterpolatedTime(); [EOL] } <line_num>: 228,230
public void setInterpolatedTime(final double time) { [EOL]     int iMin = 0; [EOL]     final StepInterpolator sMin = steps.get(iMin); [EOL]     double tMin = 0.5 * (sMin.getPreviousTime() + sMin.getCurrentTime()); [EOL]     int iMax = steps.size() - 1; [EOL]     final StepInterpolator sMax = steps.get(iMax); [EOL]     double tMax = 0.5 * (sMax.getPreviousTime() + sMax.getCurrentTime()); [EOL]     if (locatePoint(time, sMin) <= 0) { [EOL]         index = iMin; [EOL]         sMin.setInterpolatedTime(time); [EOL]         return; [EOL]     } [EOL]     if (locatePoint(time, sMax) >= 0) { [EOL]         index = iMax; [EOL]         sMax.setInterpolatedTime(time); [EOL]         return; [EOL]     } [EOL]     while (iMax - iMin > 5) { [EOL]         final StepInterpolator si = steps.get(index); [EOL]         final int location = locatePoint(time, si); [EOL]         if (location < 0) { [EOL]             iMax = index; [EOL]             tMax = 0.5 * (si.getPreviousTime() + si.getCurrentTime()); [EOL]         } else if (location > 0) { [EOL]             iMin = index; [EOL]             tMin = 0.5 * (si.getPreviousTime() + si.getCurrentTime()); [EOL]         } else { [EOL]             si.setInterpolatedTime(time); [EOL]             return; [EOL]         } [EOL]         final int iMed = (iMin + iMax) / 2; [EOL]         final StepInterpolator sMed = steps.get(iMed); [EOL]         final double tMed = 0.5 * (sMed.getPreviousTime() + sMed.getCurrentTime()); [EOL]         if ((FastMath.abs(tMed - tMin) < 1e-6) || (FastMath.abs(tMax - tMed) < 1e-6)) { [EOL]             index = iMed; [EOL]         } else { [EOL]             final double d12 = tMax - tMed; [EOL]             final double d23 = tMed - tMin; [EOL]             final double d13 = tMax - tMin; [EOL]             final double dt1 = time - tMax; [EOL]             final double dt2 = time - tMed; [EOL]             final double dt3 = time - tMin; [EOL]             final double iLagrange = ((dt2 * dt3 * d23) * iMax - (dt1 * dt3 * d13) * iMed + (dt1 * dt2 * d12) * iMin) / (d12 * d23 * d13); [EOL]             index = (int) FastMath.rint(iLagrange); [EOL]         } [EOL]         final int low = FastMath.max(iMin + 1, (9 * iMin + iMax) / 10); [EOL]         final int high = FastMath.min(iMax - 1, (iMin + 9 * iMax) / 10); [EOL]         if (index < low) { [EOL]             index = low; [EOL]         } else if (index > high) { [EOL]             index = high; [EOL]         } [EOL]     } [EOL]     index = iMin; [EOL]     while ((index <= iMax) && (locatePoint(time, steps.get(index)) > 0)) { [EOL]         ++index; [EOL]     } [EOL]     steps.get(index).setInterpolatedTime(time); [EOL] } <line_num>: 244,330
public double[] getInterpolatedState() throws MaxCountExceededException { [EOL]     return steps.get(index).getInterpolatedState(); [EOL] } <line_num>: 338,340
public double[] getInterpolatedSecondaryState(final int secondaryStateIndex) throws MaxCountExceededException { [EOL]     return steps.get(index).getInterpolatedSecondaryState(secondaryStateIndex); [EOL] } <line_num>: 352,355
private int locatePoint(final double time, final StepInterpolator interval) { [EOL]     if (forward) { [EOL]         if (time < interval.getPreviousTime()) { [EOL]             return -1; [EOL]         } else if (time > interval.getCurrentTime()) { [EOL]             return +1; [EOL]         } else { [EOL]             return 0; [EOL]         } [EOL]     } [EOL]     if (time > interval.getPreviousTime()) { [EOL]         return -1; [EOL]     } else if (time < interval.getCurrentTime()) { [EOL]         return +1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] } <line_num>: 364,381
