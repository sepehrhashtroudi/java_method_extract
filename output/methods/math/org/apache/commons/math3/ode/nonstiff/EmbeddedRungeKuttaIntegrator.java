protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double minStep, final double maxStep, final double scalAbsoluteTolerance, final double scalRelativeTolerance) { [EOL]     super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); [EOL]     this.fsal = fsal; [EOL]     this.c = c; [EOL]     this.a = a; [EOL]     this.b = b; [EOL]     this.prototype = prototype; [EOL]     exp = -1.0 / getOrder(); [EOL]     setSafety(0.9); [EOL]     setMinReduction(0.2); [EOL]     setMaxGrowth(10.0); [EOL] } <line_num>: 110,132
protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal, final double[] c, final double[][] a, final double[] b, final RungeKuttaStepInterpolator prototype, final double minStep, final double maxStep, final double[] vecAbsoluteTolerance, final double[] vecRelativeTolerance) { [EOL]     super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance); [EOL]     this.fsal = fsal; [EOL]     this.c = c; [EOL]     this.a = a; [EOL]     this.b = b; [EOL]     this.prototype = prototype; [EOL]     exp = -1.0 / getOrder(); [EOL]     setSafety(0.9); [EOL]     setMinReduction(0.2); [EOL]     setMaxGrowth(10.0); [EOL] } <line_num>: 148,170
public abstract int getOrder(); <line_num>: 175,175
public double getSafety() { [EOL]     return safety; [EOL] } <line_num>: 180,182
public void setSafety(final double safety) { [EOL]     this.safety = safety; [EOL] } <line_num>: 187,189
@Override [EOL] public void integrate(final ExpandableStatefulODE equations, final double t) throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException { [EOL]     sanityChecks(equations, t); [EOL]     setEquations(equations); [EOL]     final boolean forward = t > equations.getTime(); [EOL]     final double[] y0 = equations.getCompleteState(); [EOL]     final double[] y = y0.clone(); [EOL]     final int stages = c.length + 1; [EOL]     final double[][] yDotK = new double[stages][y.length]; [EOL]     final double[] yTmp = y0.clone(); [EOL]     final double[] yDotTmp = new double[y.length]; [EOL]     final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy(); [EOL]     interpolator.reinitialize(this, yTmp, yDotK, forward, equations.getPrimaryMapper(), equations.getSecondaryMappers()); [EOL]     interpolator.storeTime(equations.getTime()); [EOL]     stepStart = equations.getTime(); [EOL]     double hNew = 0; [EOL]     boolean firstTime = true; [EOL]     initIntegration(equations.getTime(), y0, t); [EOL]     isLastStep = false; [EOL]     do { [EOL]         interpolator.shift(); [EOL]         double error = 10; [EOL]         while (error >= 1.0) { [EOL]             if (firstTime || !fsal) { [EOL]                 computeDerivatives(stepStart, y, yDotK[0]); [EOL]             } [EOL]             if (firstTime) { [EOL]                 final double[] scale = new double[mainSetDimension]; [EOL]                 if (vecAbsoluteTolerance == null) { [EOL]                     for (int i = 0; i < scale.length; ++i) { [EOL]                         scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]); [EOL]                     } [EOL]                 } else { [EOL]                     for (int i = 0; i < scale.length; ++i) { [EOL]                         scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]); [EOL]                     } [EOL]                 } [EOL]                 hNew = initializeStep(forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]); [EOL]                 firstTime = false; [EOL]             } [EOL]             stepSize = hNew; [EOL]             if (forward) { [EOL]                 if (stepStart + stepSize >= t) { [EOL]                     stepSize = t - stepStart; [EOL]                 } [EOL]             } else { [EOL]                 if (stepStart + stepSize <= t) { [EOL]                     stepSize = t - stepStart; [EOL]                 } [EOL]             } [EOL]             for (int k = 1; k < stages; ++k) { [EOL]                 for (int j = 0; j < y0.length; ++j) { [EOL]                     double sum = a[k - 1][0] * yDotK[0][j]; [EOL]                     for (int l = 1; l < k; ++l) { [EOL]                         sum += a[k - 1][l] * yDotK[l][j]; [EOL]                     } [EOL]                     yTmp[j] = y[j] + stepSize * sum; [EOL]                 } [EOL]                 computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]); [EOL]             } [EOL]             for (int j = 0; j < y0.length; ++j) { [EOL]                 double sum = b[0] * yDotK[0][j]; [EOL]                 for (int l = 1; l < stages; ++l) { [EOL]                     sum += b[l] * yDotK[l][j]; [EOL]                 } [EOL]                 yTmp[j] = y[j] + stepSize * sum; [EOL]             } [EOL]             error = estimateError(yDotK, y, yTmp, stepSize); [EOL]             if (error >= 1.0) { [EOL]                 final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp))); [EOL]                 hNew = filterStep(stepSize * factor, forward, false); [EOL]             } [EOL]         } [EOL]         interpolator.storeTime(stepStart + stepSize); [EOL]         System.arraycopy(yTmp, 0, y, 0, y0.length); [EOL]         System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length); [EOL]         stepStart = acceptStep(interpolator, y, yDotTmp, t); [EOL]         System.arraycopy(y, 0, yTmp, 0, y.length); [EOL]         if (!isLastStep) { [EOL]             interpolator.storeTime(stepStart); [EOL]             if (fsal) { [EOL]                 System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length); [EOL]             } [EOL]             final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp))); [EOL]             final double scaledH = stepSize * factor; [EOL]             final double nextT = stepStart + scaledH; [EOL]             final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t); [EOL]             hNew = filterStep(scaledH, forward, nextIsLast); [EOL]             final double filteredNextT = stepStart + hNew; [EOL]             final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t); [EOL]             if (filteredNextIsLast) { [EOL]                 hNew = t - stepStart; [EOL]             } [EOL]         } [EOL]     } while (!isLastStep); [EOL]     equations.setTime(stepStart); [EOL]     equations.setCompleteState(y); [EOL]     resetInternalState(); [EOL] } <line_num>: 192,340
public double getMinReduction() { [EOL]     return minReduction; [EOL] } <line_num>: 345,347
public void setMinReduction(final double minReduction) { [EOL]     this.minReduction = minReduction; [EOL] } <line_num>: 352,354
public double getMaxGrowth() { [EOL]     return maxGrowth; [EOL] } <line_num>: 359,361
public void setMaxGrowth(final double maxGrowth) { [EOL]     this.maxGrowth = maxGrowth; [EOL] } <line_num>: 366,368
protected abstract double estimateError(double[][] yDotK, double[] y0, double[] y1, double h); <line_num>: 377,379
