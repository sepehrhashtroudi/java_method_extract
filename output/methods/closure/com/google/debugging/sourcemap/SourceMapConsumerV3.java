public SourceMapConsumerV3() { [EOL] } <line_num>: 56,58
MappingBuilder(String lineMap) { [EOL]     this.content = new StringCharIterator(lineMap); [EOL] } <line_num>: 288,290
StringCharIterator(String content) { [EOL]     this.content = content; [EOL]     this.length = content.length(); [EOL] } <line_num>: 553,556
UnmappedEntry(int column) { [EOL]     this.column = column; [EOL] } <line_num>: 591,593
UnnamedEntry(int column, int srcFile, int srcLine, int srcColumn) { [EOL]     super(column); [EOL]     this.srcFile = srcFile; [EOL]     this.srcLine = srcLine; [EOL]     this.srcColumn = srcColumn; [EOL] } <line_num>: 630,635
NamedEntry(int column, int srcFile, int srcLine, int srcColumn, int name) { [EOL]     super(column, srcFile, srcLine, srcColumn); [EOL]     this.name = name; [EOL] } <line_num>: 665,668
@Override [EOL] public String getSourceMap(String url) { [EOL]     return null; [EOL] } <line_num>: 61,64
@Override [EOL] public void parse(String contents) throws SourceMapParseException { [EOL]     parse(contents, null); [EOL] } <line_num>: 70,73
public void parse(String contents, SourceMapSupplier sectionSupplier) throws SourceMapParseException { [EOL]     try { [EOL]         JSONObject sourceMapRoot = new JSONObject(contents); [EOL]         parse(sourceMapRoot, sectionSupplier); [EOL]     } catch (JSONException ex) { [EOL]         throw new SourceMapParseException("JSON parse exception: " + ex); [EOL]     } [EOL] } <line_num>: 78,86
public void parse(JSONObject sourceMapRoot) throws SourceMapParseException { [EOL]     parse(sourceMapRoot, null); [EOL] } <line_num>: 91,93
public void parse(JSONObject sourceMapRoot, SourceMapSupplier sectionSupplier) throws SourceMapParseException { [EOL]     try { [EOL]         int version = sourceMapRoot.getInt("version"); [EOL]         if (version != 3) { [EOL]             throw new SourceMapParseException("Unknown version: " + version); [EOL]         } [EOL]         String file = sourceMapRoot.getString("file"); [EOL]         if (file.isEmpty()) { [EOL]             throw new SourceMapParseException("File entry is missing or empty"); [EOL]         } [EOL]         if (sourceMapRoot.has("sections")) { [EOL]             parseMetaMap(sourceMapRoot, sectionSupplier); [EOL]             return; [EOL]         } [EOL]         lineCount = sourceMapRoot.getInt("lineCount"); [EOL]         String lineMap = sourceMapRoot.getString("mappings"); [EOL]         sources = getJavaStringArray(sourceMapRoot.getJSONArray("sources")); [EOL]         names = getJavaStringArray(sourceMapRoot.getJSONArray("names")); [EOL]         lines = Lists.newArrayListWithCapacity(lineCount); [EOL]         new MappingBuilder(lineMap).build(); [EOL]     } catch (JSONException ex) { [EOL]         throw new SourceMapParseException("JSON parse exception: " + ex); [EOL]     } [EOL] } <line_num>: 98,130
private void parseMetaMap(JSONObject sourceMapRoot, SourceMapSupplier sectionSupplier) throws SourceMapParseException { [EOL]     if (sectionSupplier == null) { [EOL]         sectionSupplier = new DefaultSourceMapSupplier(); [EOL]     } [EOL]     try { [EOL]         int version = sourceMapRoot.getInt("version"); [EOL]         if (version != 3) { [EOL]             throw new SourceMapParseException("Unknown version: " + version); [EOL]         } [EOL]         String file = sourceMapRoot.getString("file"); [EOL]         if (file.isEmpty()) { [EOL]             throw new SourceMapParseException("File entry is missing or empty"); [EOL]         } [EOL]         if (sourceMapRoot.has("lineCount") || sourceMapRoot.has("mappings") || sourceMapRoot.has("sources") || sourceMapRoot.has("names")) { [EOL]             throw new SourceMapParseException("Invalid map format"); [EOL]         } [EOL]         SourceMapGeneratorV3 generator = new SourceMapGeneratorV3(); [EOL]         JSONArray sections = sourceMapRoot.getJSONArray("sections"); [EOL]         for (int i = 0, count = sections.length(); i < count; i++) { [EOL]             JSONObject section = sections.getJSONObject(i); [EOL]             if (section.has("map") && section.has("url")) { [EOL]                 throw new SourceMapParseException("Invalid map format: section may not have both 'map' and 'url'"); [EOL]             } [EOL]             JSONObject offset = section.getJSONObject("offset"); [EOL]             int line = offset.getInt("line"); [EOL]             int column = offset.getInt("column"); [EOL]             String mapSectionContents; [EOL]             if (section.has("url")) { [EOL]                 String url = section.getString("url"); [EOL]                 mapSectionContents = sectionSupplier.getSourceMap(url); [EOL]                 if (mapSectionContents == null) { [EOL]                     throw new SourceMapParseException("Unable to retrieve: " + url); [EOL]                 } [EOL]             } else if (section.has("map")) { [EOL]                 mapSectionContents = section.getString("map"); [EOL]             } else { [EOL]                 throw new SourceMapParseException("Invalid map format: section must have either 'map' or 'url'"); [EOL]             } [EOL]             generator.mergeMapSection(line, column, mapSectionContents); [EOL]         } [EOL]         StringBuilder sb = new StringBuilder(); [EOL]         try { [EOL]             generator.appendTo(sb, file); [EOL]         } catch (IOException e) { [EOL]             throw new RuntimeException(e); [EOL]         } [EOL]         parse(sb.toString()); [EOL]     } catch (IOException ex) { [EOL]         throw new SourceMapParseException("IO exception: " + ex); [EOL]     } catch (JSONException ex) { [EOL]         throw new SourceMapParseException("JSON parse exception: " + ex); [EOL]     } [EOL] } <line_num>: 136,203
@Override [EOL] public OriginalMapping getMappingForLine(int lineNumber, int column) { [EOL]     lineNumber--; [EOL]     column--; [EOL]     if (lineNumber < 0 || lineNumber >= lines.size()) { [EOL]         return null; [EOL]     } [EOL]     Preconditions.checkState(lineNumber >= 0); [EOL]     Preconditions.checkState(column >= 0); [EOL]     if (lines.get(lineNumber) == null) { [EOL]         return getPreviousMapping(lineNumber); [EOL]     } [EOL]     ArrayList<Entry> entries = lines.get(lineNumber); [EOL]     Preconditions.checkState(entries.size() > 0); [EOL]     if (entries.get(0).getGeneratedColumn() > column) { [EOL]         return getPreviousMapping(lineNumber); [EOL]     } [EOL]     int index = search(entries, column, 0, entries.size() - 1); [EOL]     Preconditions.checkState(index >= 0, "unexpected:%s", index); [EOL]     return getOriginalMappingForEntry(entries.get(index)); [EOL] } <line_num>: 205,234
@Override [EOL] public Collection<String> getOriginalSources() { [EOL]     return Arrays.asList(sources); [EOL] } <line_num>: 236,239
@Override [EOL] public Collection<OriginalMapping> getReverseMapping(String originalFile, int line, int column) { [EOL]     if (reverseSourceMapping == null) { [EOL]         createReverseMapping(); [EOL]     } [EOL]     Map<Integer, Collection<OriginalMapping>> sourceLineToCollectionMap = reverseSourceMapping.get(originalFile); [EOL]     if (sourceLineToCollectionMap == null) { [EOL]         return Collections.emptyList(); [EOL]     } else { [EOL]         Collection<OriginalMapping> mappings = sourceLineToCollectionMap.get(line); [EOL]         if (mappings == null) { [EOL]             return Collections.emptyList(); [EOL]         } else { [EOL]             return mappings; [EOL]         } [EOL]     } [EOL] } <line_num>: 241,267
private String[] getJavaStringArray(JSONArray array) throws JSONException { [EOL]     int len = array.length(); [EOL]     String[] result = new String[len]; [EOL]     for (int i = 0; i < len; i++) { [EOL]         result[i] = array.getString(i); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 269,276
void build() { [EOL]     int[] temp = new int[MAX_ENTRY_VALUES]; [EOL]     ArrayList<Entry> entries = new ArrayList<Entry>(); [EOL]     while (content.hasNext()) { [EOL]         if (tryConsumeToken(';')) { [EOL]             ArrayList<Entry> result; [EOL]             if (entries.size() > 0) { [EOL]                 result = entries; [EOL]                 entries = new ArrayList<Entry>(); [EOL]             } else { [EOL]                 result = null; [EOL]             } [EOL]             lines.add(result); [EOL]             entries.clear(); [EOL]             line++; [EOL]             previousCol = 0; [EOL]         } else { [EOL]             int entryValues = 0; [EOL]             while (!entryComplete()) { [EOL]                 temp[entryValues] = nextValue(); [EOL]                 entryValues++; [EOL]             } [EOL]             Entry entry = decodeEntry(temp, entryValues); [EOL]             validateEntry(entry); [EOL]             entries.add(entry); [EOL]             tryConsumeToken(','); [EOL]         } [EOL]     } [EOL] } <line_num>: 292,328
private void validateEntry(Entry entry) { [EOL]     Preconditions.checkState(line < lineCount); [EOL]     Preconditions.checkState(entry.getSourceFileId() == UNMAPPED || entry.getSourceFileId() < sources.length); [EOL]     Preconditions.checkState(entry.getNameId() == UNMAPPED || entry.getNameId() < names.length); [EOL] } <line_num>: 333,339
private Entry decodeEntry(int[] vals, int entryValues) { [EOL]     Entry entry; [EOL]     switch(entryValues) { [EOL]         case 1: [EOL]             entry = new UnmappedEntry(vals[0] + previousCol); [EOL]             previousCol = entry.getGeneratedColumn(); [EOL]             return entry; [EOL]         case 4: [EOL]             entry = new UnnamedEntry(vals[0] + previousCol, vals[1] + previousSrcId, vals[2] + previousSrcLine, vals[3] + previousSrcColumn); [EOL]             previousCol = entry.getGeneratedColumn(); [EOL]             previousSrcId = entry.getSourceFileId(); [EOL]             previousSrcLine = entry.getSourceLine(); [EOL]             previousSrcColumn = entry.getSourceColumn(); [EOL]             return entry; [EOL]         case 5: [EOL]             entry = new NamedEntry(vals[0] + previousCol, vals[1] + previousSrcId, vals[2] + previousSrcLine, vals[3] + previousSrcColumn, vals[4] + previousNameId); [EOL]             previousCol = entry.getGeneratedColumn(); [EOL]             previousSrcId = entry.getSourceFileId(); [EOL]             previousSrcLine = entry.getSourceLine(); [EOL]             previousSrcColumn = entry.getSourceColumn(); [EOL]             previousNameId = entry.getNameId(); [EOL]             return entry; [EOL]         default: [EOL]             throw new IllegalStateException("Unexpected number of values for entry:" + entryValues); [EOL]     } [EOL] } <line_num>: 349,406
private boolean tryConsumeToken(char token) { [EOL]     if (content.hasNext() && content.peek() == token) { [EOL]         content.next(); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 408,415
private boolean entryComplete() { [EOL]     if (!content.hasNext()) { [EOL]         return true; [EOL]     } [EOL]     char c = content.peek(); [EOL]     return (c == ';' || c == ','); [EOL] } <line_num>: 417,424
private int nextValue() { [EOL]     return Base64VLQ.decode(content); [EOL] } <line_num>: 426,428
private int search(ArrayList<Entry> entries, int target, int start, int end) { [EOL]     while (true) { [EOL]         int mid = ((end - start) / 2) + start; [EOL]         int compare = compareEntry(entries, mid, target); [EOL]         if (compare == 0) { [EOL]             return mid; [EOL]         } else if (compare < 0) { [EOL]             start = mid + 1; [EOL]             if (start > end) { [EOL]                 return end; [EOL]             } [EOL]         } else { [EOL]             end = mid - 1; [EOL]             if (end < start) { [EOL]                 return end; [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 435,455
private int compareEntry(ArrayList<Entry> entries, int entry, int target) { [EOL]     return entries.get(entry).getGeneratedColumn() - target; [EOL] } <line_num>: 460,462
private OriginalMapping getPreviousMapping(int lineNumber) { [EOL]     do { [EOL]         if (lineNumber == 0) { [EOL]             return null; [EOL]         } [EOL]         lineNumber--; [EOL]     } while (lines.get(lineNumber) == null); [EOL]     ArrayList<Entry> entries = lines.get(lineNumber); [EOL]     return getOriginalMappingForEntry(entries.get(entries.size() - 1)); [EOL] } <line_num>: 468,477
private OriginalMapping getOriginalMappingForEntry(Entry entry) { [EOL]     if (entry.getSourceFileId() == UNMAPPED) { [EOL]         return null; [EOL]     } else { [EOL]         Builder x = OriginalMapping.newBuilder().setOriginalFile(sources[entry.getSourceFileId()]).setLineNumber(entry.getSourceLine() + 1).setColumnPosition(entry.getSourceColumn() + 1); [EOL]         if (entry.getNameId() != UNMAPPED) { [EOL]             x.setIdentifier(names[entry.getNameId()]); [EOL]         } [EOL]         return x.build(); [EOL]     } [EOL] } <line_num>: 482,496
private void createReverseMapping() { [EOL]     reverseSourceMapping = new HashMap<String, Map<Integer, Collection<OriginalMapping>>>(); [EOL]     for (int targetLine = 0; targetLine < lines.size(); targetLine++) { [EOL]         ArrayList<Entry> entries = lines.get(targetLine); [EOL]         if (entries != null) { [EOL]             for (Entry entry : entries) { [EOL]                 if (entry.getSourceFileId() != UNMAPPED && entry.getSourceLine() != UNMAPPED) { [EOL]                     String originalFile = sources[entry.getSourceFileId()]; [EOL]                     if (!reverseSourceMapping.containsKey(originalFile)) { [EOL]                         reverseSourceMapping.put(originalFile, new HashMap<Integer, Collection<OriginalMapping>>()); [EOL]                     } [EOL]                     Map<Integer, Collection<OriginalMapping>> lineToCollectionMap = reverseSourceMapping.get(originalFile); [EOL]                     int sourceLine = entry.getSourceLine(); [EOL]                     if (!lineToCollectionMap.containsKey(sourceLine)) { [EOL]                         lineToCollectionMap.put(sourceLine, new ArrayList<OriginalMapping>(1)); [EOL]                     } [EOL]                     Collection<OriginalMapping> mappings = lineToCollectionMap.get(sourceLine); [EOL]                     Builder builder = OriginalMapping.newBuilder().setLineNumber(targetLine).setColumnPosition(entry.getGeneratedColumn()); [EOL]                     mappings.add(builder.build()); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 503,542
@Override [EOL] public char next() { [EOL]     return content.charAt(current++); [EOL] } <line_num>: 558,561
char peek() { [EOL]     return content.charAt(current); [EOL] } <line_num>: 563,565
@Override [EOL] public boolean hasNext() { [EOL]     return current < length; [EOL] } <line_num>: 567,570
int getGeneratedColumn(); <line_num>: 577,577
int getSourceFileId(); <line_num>: 578,578
int getSourceLine(); <line_num>: 579,579
int getSourceColumn(); <line_num>: 580,580
int getNameId(); <line_num>: 581,581
@Override [EOL] public int getGeneratedColumn() { [EOL]     return column; [EOL] } <line_num>: 595,598
@Override [EOL] public int getSourceFileId() { [EOL]     return UNMAPPED; [EOL] } <line_num>: 600,603
@Override [EOL] public int getSourceLine() { [EOL]     return UNMAPPED; [EOL] } <line_num>: 605,608
@Override [EOL] public int getSourceColumn() { [EOL]     return UNMAPPED; [EOL] } <line_num>: 610,613
@Override [EOL] public int getNameId() { [EOL]     return UNMAPPED; [EOL] } <line_num>: 615,618
@Override [EOL] public int getSourceFileId() { [EOL]     return srcFile; [EOL] } <line_num>: 637,640
@Override [EOL] public int getSourceLine() { [EOL]     return srcLine; [EOL] } <line_num>: 642,645
@Override [EOL] public int getSourceColumn() { [EOL]     return srcColumn; [EOL] } <line_num>: 647,650
@Override [EOL] public int getNameId() { [EOL]     return UNMAPPED; [EOL] } <line_num>: 652,655
@Override [EOL] public int getNameId() { [EOL]     return name; [EOL] } <line_num>: 670,673
void visit(String sourceName, String symbolName, FilePosition sourceStartPosition, FilePosition startPosition, FilePosition endPosition); <line_num>: 677,681
public void visitMappings(EntryVisitor visitor) { [EOL]     boolean pending = false; [EOL]     String sourceName = null; [EOL]     String symbolName = null; [EOL]     FilePosition sourceStartPosition = null; [EOL]     FilePosition startPosition = null; [EOL]     final int lineCount = lines.size(); [EOL]     for (int i = 0; i < lineCount; i++) { [EOL]         ArrayList<Entry> line = lines.get(i); [EOL]         if (line != null) { [EOL]             final int entryCount = line.size(); [EOL]             for (int j = 0; j < entryCount; j++) { [EOL]                 Entry entry = line.get(j); [EOL]                 if (pending) { [EOL]                     FilePosition endPosition = new FilePosition(i, entry.getGeneratedColumn()); [EOL]                     visitor.visit(sourceName, symbolName, sourceStartPosition, startPosition, endPosition); [EOL]                     pending = false; [EOL]                 } [EOL]                 if (entry.getSourceFileId() != UNMAPPED) { [EOL]                     pending = true; [EOL]                     sourceName = sources[entry.getSourceFileId()]; [EOL]                     symbolName = (entry.getNameId() != UNMAPPED) ? names[entry.getNameId()] : null; [EOL]                     sourceStartPosition = new FilePosition(entry.getSourceLine(), entry.getSourceColumn()); [EOL]                     startPosition = new FilePosition(i, entry.getGeneratedColumn()); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 684,723
