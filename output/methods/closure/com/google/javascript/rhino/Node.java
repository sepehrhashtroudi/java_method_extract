NumberNode(double number) { [EOL]     super(Token.NUMBER); [EOL]     this.number = number; [EOL] } <line_num>: 146,149
public NumberNode(double number, int lineno, int charno) { [EOL]     super(Token.NUMBER, lineno, charno); [EOL]     this.number = number; [EOL] } <line_num>: 151,154
StringNode(int type, String str) { [EOL]     super(type); [EOL]     if (null == str) { [EOL]         throw new IllegalArgumentException("StringNode: str is null"); [EOL]     } [EOL]     this.str = str; [EOL] } <line_num>: 187,193
StringNode(int type, String str, int lineno, int charno) { [EOL]     super(type, lineno, charno); [EOL]     if (null == str) { [EOL]         throw new IllegalArgumentException("StringNode: str is null"); [EOL]     } [EOL]     this.str = str; [EOL] } <line_num>: 195,201
AbstractPropListItem(int propType, PropListItem next) { [EOL]     this.propType = propType; [EOL]     this.next = next; [EOL] } <line_num>: 268,271
ObjectPropListItem(int propType, Object objectValue, PropListItem next) { [EOL]     super(propType, next); [EOL]     this.objectValue = objectValue; [EOL] } <line_num>: 294,297
IntPropListItem(int propType, int intValue, PropListItem next) { [EOL]     super(propType, next); [EOL]     this.intValue = intValue; [EOL] } <line_num>: 326,329
public Node(int nodeType) { [EOL]     type = nodeType; [EOL]     parent = null; [EOL]     sourcePosition = -1; [EOL] } <line_num>: 352,356
public Node(int nodeType, Node child) { [EOL]     Preconditions.checkArgument(child.parent == null, "new child has existing parent"); [EOL]     Preconditions.checkArgument(child.next == null, "new child has existing sibling"); [EOL]     type = nodeType; [EOL]     parent = null; [EOL]     first = last = child; [EOL]     child.next = null; [EOL]     child.parent = this; [EOL]     sourcePosition = -1; [EOL] } <line_num>: 358,370
public Node(int nodeType, Node left, Node right) { [EOL]     Preconditions.checkArgument(left.parent == null, "first new child has existing parent"); [EOL]     Preconditions.checkArgument(left.next == null, "first new child has existing sibling"); [EOL]     Preconditions.checkArgument(right.parent == null, "second new child has existing parent"); [EOL]     Preconditions.checkArgument(right.next == null, "second new child has existing sibling"); [EOL]     type = nodeType; [EOL]     parent = null; [EOL]     first = left; [EOL]     last = right; [EOL]     left.next = right; [EOL]     left.parent = this; [EOL]     right.next = null; [EOL]     right.parent = this; [EOL]     sourcePosition = -1; [EOL] } <line_num>: 372,390
public Node(int nodeType, Node left, Node mid, Node right) { [EOL]     Preconditions.checkArgument(left.parent == null); [EOL]     Preconditions.checkArgument(left.next == null); [EOL]     Preconditions.checkArgument(mid.parent == null); [EOL]     Preconditions.checkArgument(mid.next == null); [EOL]     Preconditions.checkArgument(right.parent == null); [EOL]     Preconditions.checkArgument(right.next == null); [EOL]     type = nodeType; [EOL]     parent = null; [EOL]     first = left; [EOL]     last = right; [EOL]     left.next = mid; [EOL]     left.parent = this; [EOL]     mid.next = right; [EOL]     mid.parent = this; [EOL]     right.next = null; [EOL]     right.parent = this; [EOL]     sourcePosition = -1; [EOL] } <line_num>: 392,410
public Node(int nodeType, Node left, Node mid, Node mid2, Node right) { [EOL]     Preconditions.checkArgument(left.parent == null); [EOL]     Preconditions.checkArgument(left.next == null); [EOL]     Preconditions.checkArgument(mid.parent == null); [EOL]     Preconditions.checkArgument(mid.next == null); [EOL]     Preconditions.checkArgument(mid2.parent == null); [EOL]     Preconditions.checkArgument(mid2.next == null); [EOL]     Preconditions.checkArgument(right.parent == null); [EOL]     Preconditions.checkArgument(right.next == null); [EOL]     type = nodeType; [EOL]     parent = null; [EOL]     first = left; [EOL]     last = right; [EOL]     left.next = mid; [EOL]     left.parent = this; [EOL]     mid.next = mid2; [EOL]     mid.parent = this; [EOL]     mid2.next = right; [EOL]     mid2.parent = this; [EOL]     right.next = null; [EOL]     right.parent = this; [EOL]     sourcePosition = -1; [EOL] } <line_num>: 412,434
public Node(int nodeType, int lineno, int charno) { [EOL]     type = nodeType; [EOL]     parent = null; [EOL]     sourcePosition = mergeLineCharNo(lineno, charno); [EOL] } <line_num>: 436,440
public Node(int nodeType, Node child, int lineno, int charno) { [EOL]     this(nodeType, child); [EOL]     sourcePosition = mergeLineCharNo(lineno, charno); [EOL] } <line_num>: 442,445
public Node(int nodeType, Node left, Node right, int lineno, int charno) { [EOL]     this(nodeType, left, right); [EOL]     sourcePosition = mergeLineCharNo(lineno, charno); [EOL] } <line_num>: 447,450
public Node(int nodeType, Node left, Node mid, Node right, int lineno, int charno) { [EOL]     this(nodeType, left, mid, right); [EOL]     sourcePosition = mergeLineCharNo(lineno, charno); [EOL] } <line_num>: 452,456
public Node(int nodeType, Node left, Node mid, Node mid2, Node right, int lineno, int charno) { [EOL]     this(nodeType, left, mid, mid2, right); [EOL]     sourcePosition = mergeLineCharNo(lineno, charno); [EOL] } <line_num>: 458,462
public Node(int nodeType, Node[] children, int lineno, int charno) { [EOL]     this(nodeType, children); [EOL]     sourcePosition = mergeLineCharNo(lineno, charno); [EOL] } <line_num>: 464,467
public Node(int nodeType, Node[] children) { [EOL]     this.type = nodeType; [EOL]     parent = null; [EOL]     if (children.length != 0) { [EOL]         this.first = children[0]; [EOL]         this.last = children[children.length - 1]; [EOL]         for (int i = 1; i < children.length; i++) { [EOL]             if (null != children[i - 1].next) { [EOL]                 throw new IllegalArgumentException("duplicate child"); [EOL]             } [EOL]             children[i - 1].next = children[i]; [EOL]             Preconditions.checkArgument(children[i - 1].parent == null); [EOL]             children[i - 1].parent = this; [EOL]         } [EOL]         Preconditions.checkArgument(children[children.length - 1].parent == null); [EOL]         children[children.length - 1].parent = this; [EOL]         if (null != this.last.next) { [EOL]             throw new IllegalArgumentException("duplicate child"); [EOL]         } [EOL]     } [EOL] } <line_num>: 469,493
SiblingNodeIterable(Node start) { [EOL]     this.start = start; [EOL]     this.current = start; [EOL]     this.used = false; [EOL] } <line_num>: 1252,1256
AncestorIterable(Node cur) { [EOL]     this.cur = cur; [EOL] } <line_num>: 1338,1340
public SideEffectFlags() { [EOL] } <line_num>: 2012,2013
public SideEffectFlags(int value) { [EOL]     this.value = value; [EOL] } <line_num>: 2015,2017
NodeMismatch(Node nodeA, Node nodeB) { [EOL]     this.nodeA = nodeA; [EOL]     this.nodeB = nodeB; [EOL] } <line_num>: 2126,2129
private static final String propToString(int propType) { [EOL]     switch(propType) { [EOL]         case VAR_ARGS_NAME: [EOL]             return "var_args_name"; [EOL]         case JSDOC_INFO_PROP: [EOL]             return "jsdoc_info"; [EOL]         case INCRDECR_PROP: [EOL]             return "incrdecr"; [EOL]         case QUOTED_PROP: [EOL]             return "quoted"; [EOL]         case OPT_ARG_NAME: [EOL]             return "opt_arg"; [EOL]         case SYNTHETIC_BLOCK_PROP: [EOL]             return "synthetic"; [EOL]         case EMPTY_BLOCK: [EOL]             return "empty_block"; [EOL]         case ORIGINALNAME_PROP: [EOL]             return "originalname"; [EOL]         case SIDE_EFFECT_FLAGS: [EOL]             return "side_effect_flags"; [EOL]         case IS_CONSTANT_NAME: [EOL]             return "is_constant_name"; [EOL]         case IS_NAMESPACE: [EOL]             return "is_namespace"; [EOL]         case IS_DISPATCHER: [EOL]             return "is_dispatcher"; [EOL]         case DIRECTIVES: [EOL]             return "directives"; [EOL]         case DIRECT_EVAL: [EOL]             return "direct_eval"; [EOL]         case FREE_CALL: [EOL]             return "free_call"; [EOL]         case STATIC_SOURCE_FILE: [EOL]             return "source_file"; [EOL]         case INPUT_ID: [EOL]             return "input_id"; [EOL]         case LENGTH: [EOL]             return "length"; [EOL]         case SLASH_V: [EOL]             return "slash_v"; [EOL]         case INFERRED_FUNCTION: [EOL]             return "inferred"; [EOL]         default: [EOL]             throw new IllegalStateException("unexpect prop id " + propType); [EOL]     } [EOL] } <line_num>: 111,140
@Override [EOL] public double getDouble() { [EOL]     return this.number; [EOL] } <line_num>: 156,159
@Override [EOL] public void setDouble(double d) { [EOL]     this.number = d; [EOL] } <line_num>: 161,164
@Override [EOL] boolean isEquivalentTo(Node node, boolean compareJsType, boolean recurse) { [EOL]     boolean equivalent = super.isEquivalentTo(node, compareJsType, recurse); [EOL]     if (equivalent) { [EOL]         double thisValue = getDouble(); [EOL]         double thatValue = ((NumberNode) node).getDouble(); [EOL]         if (thisValue == thatValue) { [EOL]             return (thisValue != 0.0) || (1 / thisValue == 1 / thatValue); [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 166,178
@Override [EOL] public String getString() { [EOL]     return this.str; [EOL] } <line_num>: 207,210
@Override [EOL] public void setString(String str) { [EOL]     if (null == str) { [EOL]         throw new IllegalArgumentException("StringNode: str is null"); [EOL]     } [EOL]     this.str = str; [EOL] } <line_num>: 216,222
@Override [EOL] boolean isEquivalentTo(Node node, boolean compareJsType, boolean recurse) { [EOL]     return (super.isEquivalentTo(node, compareJsType, recurse) && this.str.equals(((StringNode) node).str)); [EOL] } <line_num>: 224,228
@Override [EOL] public boolean isQuotedString() { [EOL]     return getBooleanProp(QUOTED_PROP); [EOL] } <line_num>: 236,239
@Override [EOL] public void setQuotedString() { [EOL]     putBooleanProp(QUOTED_PROP, true); [EOL] } <line_num>: 244,247
int getType(); <line_num>: 254,254
PropListItem getNext(); <line_num>: 255,255
PropListItem chain(PropListItem next); <line_num>: 256,256
Object getObjectValue(); <line_num>: 257,257
int getIntValue(); <line_num>: 258,258
@Override [EOL] public int getType() { [EOL]     return propType; [EOL] } <line_num>: 273,276
@Override [EOL] public PropListItem getNext() { [EOL]     return next; [EOL] } <line_num>: 278,281
@Override [EOL] public abstract PropListItem chain(PropListItem next); <line_num>: 283,284
@Override [EOL] public int getIntValue() { [EOL]     throw new UnsupportedOperationException(); [EOL] } <line_num>: 299,302
@Override [EOL] public Object getObjectValue() { [EOL]     return objectValue; [EOL] } <line_num>: 304,307
@Override [EOL] public String toString() { [EOL]     return objectValue == null ? "null" : objectValue.toString(); [EOL] } <line_num>: 309,312
@Override [EOL] public PropListItem chain(PropListItem next) { [EOL]     return new ObjectPropListItem(getType(), objectValue, next); [EOL] } <line_num>: 314,317
@Override [EOL] public int getIntValue() { [EOL]     return intValue; [EOL] } <line_num>: 331,334
@Override [EOL] public Object getObjectValue() { [EOL]     throw new UnsupportedOperationException(); [EOL] } <line_num>: 336,339
@Override [EOL] public String toString() { [EOL]     return String.valueOf(intValue); [EOL] } <line_num>: 341,344
@Override [EOL] public PropListItem chain(PropListItem next) { [EOL]     return new IntPropListItem(getType(), intValue, next); [EOL] } <line_num>: 346,349
public static Node newNumber(double number) { [EOL]     return new NumberNode(number); [EOL] } <line_num>: 495,497
public static Node newNumber(double number, int lineno, int charno) { [EOL]     return new NumberNode(number, lineno, charno); [EOL] } <line_num>: 499,501
public static Node newString(String str) { [EOL]     return new StringNode(Token.STRING, str); [EOL] } <line_num>: 503,505
public static Node newString(int type, String str) { [EOL]     return new StringNode(type, str); [EOL] } <line_num>: 507,509
public static Node newString(String str, int lineno, int charno) { [EOL]     return new StringNode(Token.STRING, str, lineno, charno); [EOL] } <line_num>: 511,513
public static Node newString(int type, String str, int lineno, int charno) { [EOL]     return new StringNode(type, str, lineno, charno); [EOL] } <line_num>: 515,517
public int getType() { [EOL]     return type; [EOL] } <line_num>: 519,521
public void setType(int type) { [EOL]     this.type = type; [EOL] } <line_num>: 523,525
public boolean hasChildren() { [EOL]     return first != null; [EOL] } <line_num>: 527,529
public Node getFirstChild() { [EOL]     return first; [EOL] } <line_num>: 531,533
public Node getLastChild() { [EOL]     return last; [EOL] } <line_num>: 535,537
public Node getNext() { [EOL]     return next; [EOL] } <line_num>: 539,541
public Node getChildBefore(Node child) { [EOL]     if (child == first) { [EOL]         return null; [EOL]     } [EOL]     Node n = first; [EOL]     while (n.next != child) { [EOL]         n = n.next; [EOL]         if (n == null) { [EOL]             throw new RuntimeException("node is not a child"); [EOL]         } [EOL]     } [EOL]     return n; [EOL] } <line_num>: 543,555
public Node getChildAtIndex(int i) { [EOL]     Node n = first; [EOL]     while (i > 0) { [EOL]         n = n.next; [EOL]         i--; [EOL]     } [EOL]     return n; [EOL] } <line_num>: 557,564
public int getIndexOfChild(Node child) { [EOL]     Node n = first; [EOL]     int i = 0; [EOL]     while (n != null) { [EOL]         if (child == n) { [EOL]             return i; [EOL]         } [EOL]         n = n.next; [EOL]         i++; [EOL]     } [EOL]     return -1; [EOL] } <line_num>: 566,578
public Node getLastSibling() { [EOL]     Node n = this; [EOL]     while (n.next != null) { [EOL]         n = n.next; [EOL]     } [EOL]     return n; [EOL] } <line_num>: 580,586
public void addChildToFront(Node child) { [EOL]     Preconditions.checkArgument(child.parent == null); [EOL]     Preconditions.checkArgument(child.next == null); [EOL]     child.parent = this; [EOL]     child.next = first; [EOL]     first = child; [EOL]     if (last == null) { [EOL]         last = child; [EOL]     } [EOL] } <line_num>: 588,597
public void addChildToBack(Node child) { [EOL]     Preconditions.checkArgument(child.parent == null); [EOL]     Preconditions.checkArgument(child.next == null); [EOL]     child.parent = this; [EOL]     child.next = null; [EOL]     if (last == null) { [EOL]         first = last = child; [EOL]         return; [EOL]     } [EOL]     last.next = child; [EOL]     last = child; [EOL] } <line_num>: 599,610
public void addChildrenToFront(Node children) { [EOL]     for (Node child = children; child != null; child = child.next) { [EOL]         Preconditions.checkArgument(child.parent == null); [EOL]         child.parent = this; [EOL]     } [EOL]     Node lastSib = children.getLastSibling(); [EOL]     lastSib.next = first; [EOL]     first = children; [EOL]     if (last == null) { [EOL]         last = lastSib; [EOL]     } [EOL] } <line_num>: 612,623
public void addChildrenToBack(Node children) { [EOL]     addChildrenAfter(children, getLastChild()); [EOL] } <line_num>: 625,627
public void addChildBefore(Node newChild, Node node) { [EOL]     Preconditions.checkArgument(node != null && node.parent == this, "The existing child node of the parent should not be null."); [EOL]     Preconditions.checkArgument(newChild.next == null, "The new child node has siblings."); [EOL]     Preconditions.checkArgument(newChild.parent == null, "The new child node already has a parent."); [EOL]     if (first == node) { [EOL]         newChild.parent = this; [EOL]         newChild.next = first; [EOL]         first = newChild; [EOL]         return; [EOL]     } [EOL]     Node prev = getChildBefore(node); [EOL]     addChildAfter(newChild, prev); [EOL] } <line_num>: 632,647
public void addChildAfter(Node newChild, Node node) { [EOL]     Preconditions.checkArgument(newChild.next == null, "The new child node has siblings."); [EOL]     addChildrenAfter(newChild, node); [EOL] } <line_num>: 652,656
public void addChildrenAfter(Node children, Node node) { [EOL]     Preconditions.checkArgument(node == null || node.parent == this); [EOL]     for (Node child = children; child != null; child = child.next) { [EOL]         Preconditions.checkArgument(child.parent == null); [EOL]         child.parent = this; [EOL]     } [EOL]     Node lastSibling = children.getLastSibling(); [EOL]     if (node != null) { [EOL]         Node oldNext = node.next; [EOL]         node.next = children; [EOL]         lastSibling.next = oldNext; [EOL]         if (node == last) { [EOL]             last = lastSibling; [EOL]         } [EOL]     } else { [EOL]         if (first != null) { [EOL]             lastSibling.next = first; [EOL]         } else { [EOL]             last = lastSibling; [EOL]         } [EOL]         first = children; [EOL]     } [EOL] } <line_num>: 661,685
public void removeChild(Node child) { [EOL]     Node prev = getChildBefore(child); [EOL]     if (prev == null) [EOL]         first = first.next; [EOL]     else [EOL]         prev.next = child.next; [EOL]     if (child == last) [EOL]         last = prev; [EOL]     child.next = null; [EOL]     child.parent = null; [EOL] } <line_num>: 690,699
public void replaceChild(Node child, Node newChild) { [EOL]     Preconditions.checkArgument(newChild.next == null, "The new child node has siblings."); [EOL]     Preconditions.checkArgument(newChild.parent == null, "The new child node already has a parent."); [EOL]     newChild.copyInformationFrom(child); [EOL]     newChild.next = child.next; [EOL]     newChild.parent = this; [EOL]     if (child == first) { [EOL]         first = newChild; [EOL]     } else { [EOL]         Node prev = getChildBefore(child); [EOL]         prev.next = newChild; [EOL]     } [EOL]     if (child == last) [EOL]         last = newChild; [EOL]     child.next = null; [EOL]     child.parent = null; [EOL] } <line_num>: 704,725
public void replaceChildAfter(Node prevChild, Node newChild) { [EOL]     Preconditions.checkArgument(prevChild.parent == this, "prev is not a child of this node."); [EOL]     Preconditions.checkArgument(newChild.next == null, "The new child node has siblings."); [EOL]     Preconditions.checkArgument(newChild.parent == null, "The new child node already has a parent."); [EOL]     newChild.copyInformationFrom(prevChild); [EOL]     Node child = prevChild.next; [EOL]     newChild.next = child.next; [EOL]     newChild.parent = this; [EOL]     prevChild.next = newChild; [EOL]     if (child == last) [EOL]         last = newChild; [EOL]     child.next = null; [EOL]     child.parent = null; [EOL] } <line_num>: 727,747
@VisibleForTesting [EOL] PropListItem lookupProperty(int propType) { [EOL]     PropListItem x = propListHead; [EOL]     while (x != null && propType != x.getType()) { [EOL]         x = x.getNext(); [EOL]     } [EOL]     return x; [EOL] } <line_num>: 749,756
public Node clonePropsFrom(Node other) { [EOL]     Preconditions.checkState(this.propListHead == null, "Node has existing properties."); [EOL]     this.propListHead = other.propListHead; [EOL]     return this; [EOL] } <line_num>: 765,770
public void removeProp(int propType) { [EOL]     PropListItem result = removeProp(propListHead, propType); [EOL]     if (result != propListHead) { [EOL]         propListHead = result; [EOL]     } [EOL] } <line_num>: 772,777
private PropListItem removeProp(PropListItem item, int propType) { [EOL]     if (item == null) { [EOL]         return null; [EOL]     } else if (item.getType() == propType) { [EOL]         return item.getNext(); [EOL]     } else { [EOL]         PropListItem result = removeProp(item.getNext(), propType); [EOL]         if (result != item.getNext()) { [EOL]             return item.chain(result); [EOL]         } else { [EOL]             return item; [EOL]         } [EOL]     } [EOL] } <line_num>: 785,798
public Object getProp(int propType) { [EOL]     PropListItem item = lookupProperty(propType); [EOL]     if (item == null) { [EOL]         return null; [EOL]     } [EOL]     return item.getObjectValue(); [EOL] } <line_num>: 800,806
public boolean getBooleanProp(int propType) { [EOL]     return getIntProp(propType) != 0; [EOL] } <line_num>: 808,810
public int getIntProp(int propType) { [EOL]     PropListItem item = lookupProperty(propType); [EOL]     if (item == null) { [EOL]         return 0; [EOL]     } [EOL]     return item.getIntValue(); [EOL] } <line_num>: 816,822
public int getExistingIntProp(int propType) { [EOL]     PropListItem item = lookupProperty(propType); [EOL]     if (item == null) { [EOL]         throw new IllegalStateException("missing prop: " + propType); [EOL]     } [EOL]     return item.getIntValue(); [EOL] } <line_num>: 824,830
public void putProp(int propType, Object value) { [EOL]     removeProp(propType); [EOL]     if (value != null) { [EOL]         propListHead = createProp(propType, value, propListHead); [EOL]     } [EOL] } <line_num>: 832,837
public void putBooleanProp(int propType, boolean value) { [EOL]     putIntProp(propType, value ? 1 : 0); [EOL] } <line_num>: 839,841
public void putIntProp(int propType, int value) { [EOL]     removeProp(propType); [EOL]     if (value != 0) { [EOL]         propListHead = createProp(propType, value, propListHead); [EOL]     } [EOL] } <line_num>: 843,848
PropListItem createProp(int propType, Object value, PropListItem next) { [EOL]     return new ObjectPropListItem(propType, value, next); [EOL] } <line_num>: 850,852
PropListItem createProp(int propType, int value, PropListItem next) { [EOL]     return new IntPropListItem(propType, value, next); [EOL] } <line_num>: 854,856
private int[] getSortedPropTypes() { [EOL]     int count = 0; [EOL]     for (PropListItem x = propListHead; x != null; x = x.getNext()) { [EOL]         count++; [EOL]     } [EOL]     int[] keys = new int[count]; [EOL]     for (PropListItem x = propListHead; x != null; x = x.getNext()) { [EOL]         count--; [EOL]         keys[count] = x.getType(); [EOL]     } [EOL]     Arrays.sort(keys); [EOL]     return keys; [EOL] } <line_num>: 859,873
public double getDouble() throws UnsupportedOperationException { [EOL]     if (this.getType() == Token.NUMBER) { [EOL]         throw new IllegalStateException("Number node not created with Node.newNumber"); [EOL]     } else { [EOL]         throw new UnsupportedOperationException(this + " is not a number node"); [EOL]     } [EOL] } <line_num>: 876,883
public void setDouble(double s) throws UnsupportedOperationException { [EOL]     if (this.getType() == Token.NUMBER) { [EOL]         throw new IllegalStateException("Number node not created with Node.newNumber"); [EOL]     } else { [EOL]         throw new UnsupportedOperationException(this + " is not a string node"); [EOL]     } [EOL] } <line_num>: 886,893
public String getString() throws UnsupportedOperationException { [EOL]     if (this.getType() == Token.STRING) { [EOL]         throw new IllegalStateException("String node not created with Node.newString"); [EOL]     } else { [EOL]         throw new UnsupportedOperationException(this + " is not a string node"); [EOL]     } [EOL] } <line_num>: 896,903
public void setString(String s) throws UnsupportedOperationException { [EOL]     if (this.getType() == Token.STRING) { [EOL]         throw new IllegalStateException("String node not created with Node.newString"); [EOL]     } else { [EOL]         throw new UnsupportedOperationException(this + " is not a string node"); [EOL]     } [EOL] } <line_num>: 906,913
@Override [EOL] public String toString() { [EOL]     return toString(true, true, true); [EOL] } <line_num>: 915,918
public String toString(boolean printSource, boolean printAnnotations, boolean printType) { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     toString(sb, printSource, printAnnotations, printType); [EOL]     return sb.toString(); [EOL] } <line_num>: 920,927
private void toString(StringBuilder sb, boolean printSource, boolean printAnnotations, boolean printType) { [EOL]     sb.append(Token.name(type)); [EOL]     if (this instanceof StringNode) { [EOL]         sb.append(' '); [EOL]         sb.append(getString()); [EOL]     } else if (type == Token.FUNCTION) { [EOL]         sb.append(' '); [EOL]         if (first == null || first.getType() != Token.NAME) { [EOL]             sb.append("<invalid>"); [EOL]         } else { [EOL]             sb.append(first.getString()); [EOL]         } [EOL]     } else if (type == Token.NUMBER) { [EOL]         sb.append(' '); [EOL]         sb.append(getDouble()); [EOL]     } [EOL]     if (printSource) { [EOL]         int lineno = getLineno(); [EOL]         if (lineno != -1) { [EOL]             sb.append(' '); [EOL]             sb.append(lineno); [EOL]         } [EOL]     } [EOL]     if (printAnnotations) { [EOL]         int[] keys = getSortedPropTypes(); [EOL]         for (int i = 0; i < keys.length; i++) { [EOL]             int type = keys[i]; [EOL]             PropListItem x = lookupProperty(type); [EOL]             sb.append(" ["); [EOL]             sb.append(propToString(type)); [EOL]             sb.append(": "); [EOL]             String value; [EOL]             switch(type) { [EOL]                 default: [EOL]                     value = x.toString(); [EOL]                     break; [EOL]             } [EOL]             sb.append(value); [EOL]             sb.append(']'); [EOL]         } [EOL]     } [EOL]     if (printType) { [EOL]         if (jsType != null) { [EOL]             String jsTypeString = jsType.toString(); [EOL]             if (jsTypeString != null) { [EOL]                 sb.append(" : "); [EOL]                 sb.append(jsTypeString); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 929,988
public String toStringTree() { [EOL]     return toStringTreeImpl(); [EOL] } <line_num>: 991,993
private String toStringTreeImpl() { [EOL]     try { [EOL]         StringBuilder s = new StringBuilder(); [EOL]         appendStringTree(s); [EOL]         return s.toString(); [EOL]     } catch (IOException e) { [EOL]         throw new RuntimeException("Should not happen\n" + e); [EOL]     } [EOL] } <line_num>: 995,1003
public void appendStringTree(Appendable appendable) throws IOException { [EOL]     toStringTreeHelper(this, 0, appendable); [EOL] } <line_num>: 1005,1007
private static void toStringTreeHelper(Node n, int level, Appendable sb) throws IOException { [EOL]     for (int i = 0; i != level; ++i) { [EOL]         sb.append("    "); [EOL]     } [EOL]     sb.append(n.toString()); [EOL]     sb.append('\n'); [EOL]     for (Node cursor = n.getFirstChild(); cursor != null; cursor = cursor.getNext()) { [EOL]         toStringTreeHelper(cursor, level + 1, sb); [EOL]     } [EOL] } <line_num>: 1009,1021
public void setStaticSourceFile(StaticSourceFile file) { [EOL]     this.putProp(STATIC_SOURCE_FILE, file); [EOL] } <line_num>: 1075,1077
public void setSourceFileForTesting(String name) { [EOL]     this.putProp(STATIC_SOURCE_FILE, new SimpleSourceFile(name, false)); [EOL] } <line_num>: 1080,1082
public String getSourceFileName() { [EOL]     StaticSourceFile file = getStaticSourceFile(); [EOL]     return file == null ? null : file.getName(); [EOL] } <line_num>: 1084,1087
public StaticSourceFile getStaticSourceFile() { [EOL]     return ((StaticSourceFile) this.getProp(STATIC_SOURCE_FILE)); [EOL] } <line_num>: 1090,1092
public void setInputId(InputId inputId) { [EOL]     this.putProp(INPUT_ID, inputId); [EOL] } <line_num>: 1097,1099
public InputId getInputId() { [EOL]     return ((InputId) this.getProp(INPUT_ID)); [EOL] } <line_num>: 1104,1106
public boolean isFromExterns() { [EOL]     StaticSourceFile file = getStaticSourceFile(); [EOL]     return file == null ? false : file.isExtern(); [EOL] } <line_num>: 1108,1111
public int getLength() { [EOL]     return getIntProp(LENGTH); [EOL] } <line_num>: 1113,1115
public void setLength(int length) { [EOL]     putIntProp(LENGTH, length); [EOL] } <line_num>: 1117,1119
public int getLineno() { [EOL]     return extractLineno(sourcePosition); [EOL] } <line_num>: 1121,1123
public int getCharno() { [EOL]     return extractCharno(sourcePosition); [EOL] } <line_num>: 1125,1127
public int getSourceOffset() { [EOL]     StaticSourceFile file = getStaticSourceFile(); [EOL]     if (file == null) { [EOL]         return -1; [EOL]     } [EOL]     int lineno = getLineno(); [EOL]     if (lineno == -1) { [EOL]         return -1; [EOL]     } [EOL]     return file.getLineOffset(lineno) + getCharno(); [EOL] } <line_num>: 1129,1139
public int getSourcePosition() { [EOL]     return sourcePosition; [EOL] } <line_num>: 1141,1143
public void setLineno(int lineno) { [EOL]     int charno = getCharno(); [EOL]     if (charno == -1) { [EOL]         charno = 0; [EOL]     } [EOL]     sourcePosition = mergeLineCharNo(lineno, charno); [EOL] } <line_num>: 1145,1151
public void setCharno(int charno) { [EOL]     sourcePosition = mergeLineCharNo(getLineno(), charno); [EOL] } <line_num>: 1153,1155
public void setSourceEncodedPosition(int sourcePosition) { [EOL]     this.sourcePosition = sourcePosition; [EOL] } <line_num>: 1157,1159
public void setSourceEncodedPositionForTree(int sourcePosition) { [EOL]     this.sourcePosition = sourcePosition; [EOL]     for (Node child = getFirstChild(); child != null; child = child.getNext()) { [EOL]         child.setSourceEncodedPositionForTree(sourcePosition); [EOL]     } [EOL] } <line_num>: 1161,1168
protected static int mergeLineCharNo(int lineno, int charno) { [EOL]     if (lineno < 0 || charno < 0) { [EOL]         return -1; [EOL]     } else if ((charno & ~COLUMN_MASK) != 0) { [EOL]         return lineno << COLUMN_BITS | COLUMN_MASK; [EOL]     } else { [EOL]         return lineno << COLUMN_BITS | (charno & COLUMN_MASK); [EOL]     } [EOL] } <line_num>: 1176,1184
protected static int extractLineno(int lineCharNo) { [EOL]     if (lineCharNo == -1) { [EOL]         return -1; [EOL]     } else { [EOL]         return lineCharNo >>> COLUMN_BITS; [EOL]     } [EOL] } <line_num>: 1190,1196
protected static int extractCharno(int lineCharNo) { [EOL]     if (lineCharNo == -1) { [EOL]         return -1; [EOL]     } else { [EOL]         return lineCharNo & COLUMN_MASK; [EOL]     } [EOL] } <line_num>: 1202,1208
public Iterable<Node> children() { [EOL]     if (first == null) { [EOL]         return Collections.emptySet(); [EOL]     } else { [EOL]         return new SiblingNodeIterable(first); [EOL]     } [EOL] } <line_num>: 1222,1228
public Iterable<Node> siblings() { [EOL]     return new SiblingNodeIterable(this); [EOL] } <line_num>: 1239,1241
@Override [EOL] public Iterator<Node> iterator() { [EOL]     if (!used) { [EOL]         used = true; [EOL]         return this; [EOL]     } else { [EOL]         return (new SiblingNodeIterable(start)).iterator(); [EOL]     } [EOL] } <line_num>: 1258,1272
@Override [EOL] public boolean hasNext() { [EOL]     return current != null; [EOL] } <line_num>: 1274,1277
@Override [EOL] public Node next() { [EOL]     if (current == null) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     try { [EOL]         return current; [EOL]     } finally { [EOL]         current = current.getNext(); [EOL]     } [EOL] } <line_num>: 1279,1289
@Override [EOL] public void remove() { [EOL]     throw new UnsupportedOperationException(); [EOL] } <line_num>: 1291,1294
PropListItem getPropListHeadForTesting() { [EOL]     return propListHead; [EOL] } <line_num>: 1300,1302
public Node getParent() { [EOL]     return parent; [EOL] } <line_num>: 1304,1306
public Node getAncestor(int level) { [EOL]     Preconditions.checkArgument(level >= 0); [EOL]     Node node = this; [EOL]     while (node != null && level-- > 0) { [EOL]         node = node.getParent(); [EOL]     } [EOL]     return node; [EOL] } <line_num>: 1313,1320
public AncestorIterable getAncestors() { [EOL]     return new AncestorIterable(this.getParent()); [EOL] } <line_num>: 1325,1327
@Override [EOL] public boolean hasNext() { [EOL]     return cur != null; [EOL] } <line_num>: 1345,1348
@Override [EOL] public Node next() { [EOL]     if (!hasNext()) [EOL]         throw new NoSuchElementException(); [EOL]     Node n = cur; [EOL]     cur = cur.getParent(); [EOL]     return n; [EOL] } <line_num>: 1350,1356
@Override [EOL] public void remove() { [EOL]     throw new UnsupportedOperationException(); [EOL] } <line_num>: 1358,1361
@Override [EOL] public Iterator<Node> iterator() { [EOL]     return new Iterator<Node>() { [EOL]  [EOL]         @Override [EOL]         public boolean hasNext() { [EOL]             return cur != null; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public Node next() { [EOL]             if (!hasNext()) [EOL]                 throw new NoSuchElementException(); [EOL]             Node n = cur; [EOL]             cur = cur.getParent(); [EOL]             return n; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void remove() { [EOL]             throw new UnsupportedOperationException(); [EOL]         } [EOL]     }; [EOL] } <line_num>: 1342,1363
public boolean hasOneChild() { [EOL]     return first != null && first == last; [EOL] } <line_num>: 1372,1374
public boolean hasMoreThanOneChild() { [EOL]     return first != null && first != last; [EOL] } <line_num>: 1382,1384
public int getChildCount() { [EOL]     int c = 0; [EOL]     for (Node n = first; n != null; n = n.next) c++; [EOL]     return c; [EOL] } <line_num>: 1386,1392
public boolean hasChild(Node child) { [EOL]     for (Node n = first; n != null; n = n.getNext()) { [EOL]         if (child == n) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1395,1402
public String checkTreeEquals(Node node2) { [EOL]     NodeMismatch diff = checkTreeEqualsImpl(node2); [EOL]     if (diff != null) { [EOL]         return "Node tree inequality:" + "\nTree1:\n" + toStringTree() + "\n\nTree2:\n" + node2.toStringTree() + "\n\nSubtree1: " + diff.nodeA.toStringTree() + "\n\nSubtree2: " + diff.nodeB.toStringTree(); [EOL]     } [EOL]     return null; [EOL] } <line_num>: 1408,1418
NodeMismatch checkTreeEqualsImpl(Node node2) { [EOL]     if (!isEquivalentTo(node2, false, false)) { [EOL]         return new NodeMismatch(this, node2); [EOL]     } [EOL]     NodeMismatch res = null; [EOL]     Node n, n2; [EOL]     for (n = first, n2 = node2.first; res == null && n != null; n = n.next, n2 = n2.next) { [EOL]         if (node2 == null) { [EOL]             throw new IllegalStateException(); [EOL]         } [EOL]         res = n.checkTreeEqualsImpl(n2); [EOL]         if (res != null) { [EOL]             return res; [EOL]         } [EOL]     } [EOL]     return res; [EOL] } <line_num>: 1425,1444
NodeMismatch checkTreeTypeAwareEqualsImpl(Node node2) { [EOL]     if (!isEquivalentTo(node2, true, false)) { [EOL]         return new NodeMismatch(this, node2); [EOL]     } [EOL]     NodeMismatch res = null; [EOL]     Node n, n2; [EOL]     for (n = first, n2 = node2.first; res == null && n != null; n = n.next, n2 = n2.next) { [EOL]         res = n.checkTreeTypeAwareEqualsImpl(n2); [EOL]         if (res != null) { [EOL]             return res; [EOL]         } [EOL]     } [EOL]     return res; [EOL] } <line_num>: 1451,1468
public boolean isEquivalentTo(Node node) { [EOL]     return isEquivalentTo(node, false, true); [EOL] } <line_num>: 1471,1473
public boolean isEquivalentToTyped(Node node) { [EOL]     return isEquivalentTo(node, true, true); [EOL] } <line_num>: 1479,1481
boolean isEquivalentTo(Node node, boolean compareJsType, boolean recurse) { [EOL]     if (type != node.getType() || getChildCount() != node.getChildCount() || this.getClass() != node.getClass()) { [EOL]         return false; [EOL]     } [EOL]     if (compareJsType && !JSType.isEquivalent(jsType, node.getJSType())) { [EOL]         return false; [EOL]     } [EOL]     if (type == Token.INC || type == Token.DEC) { [EOL]         int post1 = this.getIntProp(INCRDECR_PROP); [EOL]         int post2 = node.getIntProp(INCRDECR_PROP); [EOL]         if (post1 != post2) { [EOL]             return false; [EOL]         } [EOL]     } else if (type == Token.STRING || type == Token.STRING_KEY) { [EOL]         if (type == Token.STRING_KEY) { [EOL]             int quoted1 = this.getIntProp(QUOTED_PROP); [EOL]             int quoted2 = node.getIntProp(QUOTED_PROP); [EOL]             if (quoted1 != quoted2) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         int slashV1 = this.getIntProp(SLASH_V); [EOL]         int slashV2 = node.getIntProp(SLASH_V); [EOL]         if (slashV1 != slashV2) { [EOL]             return false; [EOL]         } [EOL]     } else if (type == Token.CALL) { [EOL]         if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if (recurse) { [EOL]         Node n, n2; [EOL]         for (n = first, n2 = node.first; n != null; n = n.next, n2 = n2.next) { [EOL]             if (!n.isEquivalentTo(n2, compareJsType, true)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 1489,1538
public String getQualifiedName() { [EOL]     if (type == Token.NAME) { [EOL]         String name = getString(); [EOL]         return name.isEmpty() ? null : name; [EOL]     } else if (type == Token.GETPROP) { [EOL]         String left = getFirstChild().getQualifiedName(); [EOL]         if (left == null) { [EOL]             return null; [EOL]         } [EOL]         return left + "." + getLastChild().getString(); [EOL]     } else if (type == Token.THIS) { [EOL]         return "this"; [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] } <line_num>: 1548,1563
public boolean isQualifiedName() { [EOL]     switch(getType()) { [EOL]         case Token.NAME: [EOL]             return getString().isEmpty() ? false : true; [EOL]         case Token.THIS: [EOL]             return true; [EOL]         case Token.GETPROP: [EOL]             return getFirstChild().isQualifiedName(); [EOL]         default: [EOL]             return false; [EOL]     } [EOL] } <line_num>: 1569,1580
public boolean isUnscopedQualifiedName() { [EOL]     switch(getType()) { [EOL]         case Token.NAME: [EOL]             return getString().isEmpty() ? false : true; [EOL]         case Token.GETPROP: [EOL]             return getFirstChild().isUnscopedQualifiedName(); [EOL]         default: [EOL]             return false; [EOL]     } [EOL] } <line_num>: 1587,1596
public Node detachFromParent() { [EOL]     Preconditions.checkState(parent != null); [EOL]     parent.removeChild(this); [EOL]     return this; [EOL] } <line_num>: 1605,1609
public Node removeFirstChild() { [EOL]     Node child = first; [EOL]     if (child != null) { [EOL]         removeChild(child); [EOL]     } [EOL]     return child; [EOL] } <line_num>: 1617,1623
public Node removeChildren() { [EOL]     Node children = first; [EOL]     for (Node child = first; child != null; child = child.getNext()) { [EOL]         child.parent = null; [EOL]     } [EOL]     first = null; [EOL]     last = null; [EOL]     return children; [EOL] } <line_num>: 1628,1636
public void detachChildren() { [EOL]     for (Node child = first; child != null; ) { [EOL]         Node nextChild = child.getNext(); [EOL]         child.parent = null; [EOL]         child.next = null; [EOL]         child = nextChild; [EOL]     } [EOL]     first = null; [EOL]     last = null; [EOL] } <line_num>: 1642,1651
public Node removeChildAfter(Node prev) { [EOL]     Preconditions.checkArgument(prev.parent == this, "prev is not a child of this node."); [EOL]     Preconditions.checkArgument(prev.next != null, "no next sibling."); [EOL]     Node child = prev.next; [EOL]     prev.next = child.next; [EOL]     if (child == last) [EOL]         last = prev; [EOL]     child.next = null; [EOL]     child.parent = null; [EOL]     return child; [EOL] } <line_num>: 1653,1665
public Node cloneNode() { [EOL]     Node result; [EOL]     try { [EOL]         result = (Node) super.clone(); [EOL]         result.next = null; [EOL]         result.first = null; [EOL]         result.last = null; [EOL]         result.parent = null; [EOL]     } catch (CloneNotSupportedException e) { [EOL]         throw new RuntimeException(e.getMessage()); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1670,1684
public Node cloneTree() { [EOL]     Node result = cloneNode(); [EOL]     for (Node n2 = getFirstChild(); n2 != null; n2 = n2.getNext()) { [EOL]         Node n2clone = n2.cloneTree(); [EOL]         n2clone.parent = result; [EOL]         if (result.last != null) { [EOL]             result.last.next = n2clone; [EOL]         } [EOL]         if (result.first == null) { [EOL]             result.first = n2clone; [EOL]         } [EOL]         result.last = n2clone; [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1689,1703
public Node copyInformationFrom(Node other) { [EOL]     if (getProp(ORIGINALNAME_PROP) == null) { [EOL]         putProp(ORIGINALNAME_PROP, other.getProp(ORIGINALNAME_PROP)); [EOL]     } [EOL]     if (getProp(STATIC_SOURCE_FILE) == null) { [EOL]         putProp(STATIC_SOURCE_FILE, other.getProp(STATIC_SOURCE_FILE)); [EOL]         sourcePosition = other.sourcePosition; [EOL]     } [EOL]     return this; [EOL] } <line_num>: 1712,1723
public Node copyInformationFromForTree(Node other) { [EOL]     copyInformationFrom(other); [EOL]     for (Node child = getFirstChild(); child != null; child = child.getNext()) { [EOL]         child.copyInformationFromForTree(other); [EOL]     } [EOL]     return this; [EOL] } <line_num>: 1731,1739
public Node useSourceInfoFrom(Node other) { [EOL]     putProp(ORIGINALNAME_PROP, other.getProp(ORIGINALNAME_PROP)); [EOL]     putProp(STATIC_SOURCE_FILE, other.getProp(STATIC_SOURCE_FILE)); [EOL]     sourcePosition = other.sourcePosition; [EOL]     return this; [EOL] } <line_num>: 1745,1750
public Node srcref(Node other) { [EOL]     return useSourceInfoFrom(other); [EOL] } <line_num>: 1752,1754
public Node useSourceInfoFromForTree(Node other) { [EOL]     useSourceInfoFrom(other); [EOL]     for (Node child = getFirstChild(); child != null; child = child.getNext()) { [EOL]         child.useSourceInfoFromForTree(other); [EOL]     } [EOL]     return this; [EOL] } <line_num>: 1760,1768
public Node srcrefTree(Node other) { [EOL]     return useSourceInfoFromForTree(other); [EOL] } <line_num>: 1770,1772
public Node useSourceInfoIfMissingFrom(Node other) { [EOL]     if (getProp(ORIGINALNAME_PROP) == null) { [EOL]         putProp(ORIGINALNAME_PROP, other.getProp(ORIGINALNAME_PROP)); [EOL]     } [EOL]     if (getProp(STATIC_SOURCE_FILE) == null) { [EOL]         putProp(STATIC_SOURCE_FILE, other.getProp(STATIC_SOURCE_FILE)); [EOL]         sourcePosition = other.sourcePosition; [EOL]     } [EOL]     return this; [EOL] } <line_num>: 1778,1789
public Node useSourceInfoIfMissingFromForTree(Node other) { [EOL]     useSourceInfoIfMissingFrom(other); [EOL]     for (Node child = getFirstChild(); child != null; child = child.getNext()) { [EOL]         child.useSourceInfoIfMissingFromForTree(other); [EOL]     } [EOL]     return this; [EOL] } <line_num>: 1795,1803
public JSType getJSType() { [EOL]     return jsType; [EOL] } <line_num>: 1808,1810
public void setJSType(JSType jsType) { [EOL]     this.jsType = jsType; [EOL] } <line_num>: 1812,1814
public FileLevelJsDocBuilder getJsDocBuilderForNode() { [EOL]     return new FileLevelJsDocBuilder(); [EOL] } <line_num>: 1816,1818
public void append(String fileLevelComment) { [EOL]     JSDocInfo jsDocInfo = getJSDocInfo(); [EOL]     if (jsDocInfo == null) { [EOL]         jsDocInfo = new JSDocInfo(false); [EOL]     } [EOL]     String license = jsDocInfo.getLicense(); [EOL]     if (license == null) { [EOL]         license = ""; [EOL]     } [EOL]     jsDocInfo.setLicense(license + fileLevelComment); [EOL]     setJSDocInfo(jsDocInfo); [EOL] } <line_num>: 1829,1842
public JSDocInfo getJSDocInfo() { [EOL]     return (JSDocInfo) getProp(JSDOC_INFO_PROP); [EOL] } <line_num>: 1850,1852
public Node setJSDocInfo(JSDocInfo info) { [EOL]     putProp(JSDOC_INFO_PROP, info); [EOL]     return this; [EOL] } <line_num>: 1857,1860
public void setVarArgs(boolean varArgs) { [EOL]     putBooleanProp(VAR_ARGS_NAME, varArgs); [EOL] } <line_num>: 1867,1869
public boolean isVarArgs() { [EOL]     return getBooleanProp(VAR_ARGS_NAME); [EOL] } <line_num>: 1876,1878
public void setOptionalArg(boolean optionalArg) { [EOL]     putBooleanProp(OPT_ARG_NAME, optionalArg); [EOL] } <line_num>: 1885,1887
public boolean isOptionalArg() { [EOL]     return getBooleanProp(OPT_ARG_NAME); [EOL] } <line_num>: 1894,1896
public void setIsSyntheticBlock(boolean val) { [EOL]     putBooleanProp(SYNTHETIC_BLOCK_PROP, val); [EOL] } <line_num>: 1902,1904
public boolean isSyntheticBlock() { [EOL]     return getBooleanProp(SYNTHETIC_BLOCK_PROP); [EOL] } <line_num>: 1910,1912
public void setDirectives(Set<String> val) { [EOL]     putProp(DIRECTIVES, val); [EOL] } <line_num>: 1917,1919
@SuppressWarnings("unchecked") [EOL] public Set<String> getDirectives() { [EOL]     return (Set<String>) getProp(DIRECTIVES); [EOL] } <line_num>: 1924,1927
public void addSuppression(String warning) { [EOL]     if (getJSDocInfo() == null) { [EOL]         setJSDocInfo(new JSDocInfo(false)); [EOL]     } [EOL]     getJSDocInfo().addSuppression(warning); [EOL] } <line_num>: 1933,1938
public void setWasEmptyNode(boolean val) { [EOL]     putBooleanProp(EMPTY_BLOCK, val); [EOL] } <line_num>: 1944,1946
public boolean wasEmptyNode() { [EOL]     return getBooleanProp(EMPTY_BLOCK); [EOL] } <line_num>: 1952,1954
public void setSideEffectFlags(int flags) { [EOL]     Preconditions.checkArgument(getType() == Token.CALL || getType() == Token.NEW, "setIsNoSideEffectsCall only supports CALL and NEW nodes, got " + Token.name(getType())); [EOL]     putIntProp(SIDE_EFFECT_FLAGS, flags); [EOL] } <line_num>: 1985,1992
public void setSideEffectFlags(SideEffectFlags flags) { [EOL]     setSideEffectFlags(flags.valueOf()); [EOL] } <line_num>: 1994,1996
public int getSideEffectFlags() { [EOL]     return getIntProp(SIDE_EFFECT_FLAGS); [EOL] } <line_num>: 2001,2003
public int valueOf() { [EOL]     return value; [EOL] } <line_num>: 2019,2021
public void setAllFlags() { [EOL]     value = Node.SIDE_EFFECTS_ALL; [EOL] } <line_num>: 2024,2026
public void clearAllFlags() { [EOL]     value = Node.NO_SIDE_EFFECTS | Node.FLAG_LOCAL_RESULTS; [EOL] } <line_num>: 2029,2031
public boolean areAllFlagsSet() { [EOL]     return value == Node.SIDE_EFFECTS_ALL; [EOL] } <line_num>: 2033,2035
public void clearSideEffectFlags() { [EOL]     value |= Node.NO_SIDE_EFFECTS; [EOL] } <line_num>: 2041,2043
public void setMutatesGlobalState() { [EOL]     removeFlag(Node.FLAG_GLOBAL_STATE_UNMODIFIED); [EOL]     removeFlag(Node.FLAG_ARGUMENTS_UNMODIFIED); [EOL]     removeFlag(Node.FLAG_THIS_UNMODIFIED); [EOL] } <line_num>: 2045,2050
public void setThrows() { [EOL]     removeFlag(Node.FLAG_NO_THROWS); [EOL] } <line_num>: 2052,2054
public void setMutatesThis() { [EOL]     removeFlag(Node.FLAG_THIS_UNMODIFIED); [EOL] } <line_num>: 2056,2058
public void setMutatesArguments() { [EOL]     removeFlag(Node.FLAG_ARGUMENTS_UNMODIFIED); [EOL] } <line_num>: 2060,2062
public void setReturnsTainted() { [EOL]     removeFlag(Node.FLAG_LOCAL_RESULTS); [EOL] } <line_num>: 2064,2066
private void removeFlag(int flag) { [EOL]     value &= ~flag; [EOL] } <line_num>: 2068,2070
public boolean isOnlyModifiesThisCall() { [EOL]     return areBitFlagsSet(getSideEffectFlags() & Node.NO_SIDE_EFFECTS, Node.FLAG_GLOBAL_STATE_UNMODIFIED | Node.FLAG_ARGUMENTS_UNMODIFIED | Node.FLAG_NO_THROWS); [EOL] } <line_num>: 2076,2082
public boolean isNoSideEffectsCall() { [EOL]     return areBitFlagsSet(getSideEffectFlags(), NO_SIDE_EFFECTS); [EOL] } <line_num>: 2088,2090
public boolean isLocalResultCall() { [EOL]     return areBitFlagsSet(getSideEffectFlags(), FLAG_LOCAL_RESULTS); [EOL] } <line_num>: 2097,2099
private boolean areBitFlagsSet(int value, int flags) { [EOL]     return (value & flags) == flags; [EOL] } <line_num>: 2104,2106
public boolean isQuotedString() { [EOL]     return false; [EOL] } <line_num>: 2111,2113
public void setQuotedString() { [EOL]     throw new IllegalStateException("not a StringNode"); [EOL] } <line_num>: 2118,2120
@Override [EOL] public boolean equals(Object object) { [EOL]     if (object instanceof NodeMismatch) { [EOL]         NodeMismatch that = (NodeMismatch) object; [EOL]         return that.nodeA.equals(this.nodeA) && that.nodeB.equals(this.nodeB); [EOL]     } [EOL]     return false; [EOL] } <line_num>: 2131,2138
@Override [EOL] public int hashCode() { [EOL]     return Objects.hashCode(nodeA, nodeB); [EOL] } <line_num>: 2140,2143
public boolean isAdd() { [EOL]     return this.getType() == Token.ADD; [EOL] } <line_num>: 2149,2151
public boolean isAnd() { [EOL]     return this.getType() == Token.AND; [EOL] } <line_num>: 2153,2155
public boolean isArrayLit() { [EOL]     return this.getType() == Token.ARRAYLIT; [EOL] } <line_num>: 2157,2159
public boolean isAssign() { [EOL]     return this.getType() == Token.ASSIGN; [EOL] } <line_num>: 2161,2163
public boolean isAssignAdd() { [EOL]     return this.getType() == Token.ASSIGN_ADD; [EOL] } <line_num>: 2165,2167
public boolean isBlock() { [EOL]     return this.getType() == Token.BLOCK; [EOL] } <line_num>: 2169,2171
public boolean isBreak() { [EOL]     return this.getType() == Token.BREAK; [EOL] } <line_num>: 2173,2175
public boolean isCall() { [EOL]     return this.getType() == Token.CALL; [EOL] } <line_num>: 2177,2179
public boolean isCase() { [EOL]     return this.getType() == Token.CASE; [EOL] } <line_num>: 2181,2183
public boolean isCast() { [EOL]     return this.getType() == Token.CAST; [EOL] } <line_num>: 2185,2187
public boolean isCatch() { [EOL]     return this.getType() == Token.CATCH; [EOL] } <line_num>: 2189,2191
public boolean isComma() { [EOL]     return this.getType() == Token.COMMA; [EOL] } <line_num>: 2193,2195
public boolean isContinue() { [EOL]     return this.getType() == Token.CONTINUE; [EOL] } <line_num>: 2197,2199
public boolean isDebugger() { [EOL]     return this.getType() == Token.DEBUGGER; [EOL] } <line_num>: 2201,2203
public boolean isDec() { [EOL]     return this.getType() == Token.DEC; [EOL] } <line_num>: 2205,2207
public boolean isDefaultCase() { [EOL]     return this.getType() == Token.DEFAULT_CASE; [EOL] } <line_num>: 2209,2211
public boolean isDelProp() { [EOL]     return this.getType() == Token.DELPROP; [EOL] } <line_num>: 2213,2215
public boolean isDo() { [EOL]     return this.getType() == Token.DO; [EOL] } <line_num>: 2217,2219
public boolean isEmpty() { [EOL]     return this.getType() == Token.EMPTY; [EOL] } <line_num>: 2221,2223
public boolean isExprResult() { [EOL]     return this.getType() == Token.EXPR_RESULT; [EOL] } <line_num>: 2225,2227
public boolean isFalse() { [EOL]     return this.getType() == Token.FALSE; [EOL] } <line_num>: 2229,2231
public boolean isFor() { [EOL]     return this.getType() == Token.FOR; [EOL] } <line_num>: 2233,2235
public boolean isFunction() { [EOL]     return this.getType() == Token.FUNCTION; [EOL] } <line_num>: 2237,2239
public boolean isGetterDef() { [EOL]     return this.getType() == Token.GETTER_DEF; [EOL] } <line_num>: 2241,2243
public boolean isGetElem() { [EOL]     return this.getType() == Token.GETELEM; [EOL] } <line_num>: 2245,2247
public boolean isGetProp() { [EOL]     return this.getType() == Token.GETPROP; [EOL] } <line_num>: 2249,2251
public boolean isHook() { [EOL]     return this.getType() == Token.HOOK; [EOL] } <line_num>: 2253,2255
public boolean isIf() { [EOL]     return this.getType() == Token.IF; [EOL] } <line_num>: 2257,2259
public boolean isIn() { [EOL]     return this.getType() == Token.IN; [EOL] } <line_num>: 2261,2263
public boolean isInc() { [EOL]     return this.getType() == Token.INC; [EOL] } <line_num>: 2265,2267
public boolean isInstanceOf() { [EOL]     return this.getType() == Token.INSTANCEOF; [EOL] } <line_num>: 2269,2271
public boolean isLabel() { [EOL]     return this.getType() == Token.LABEL; [EOL] } <line_num>: 2273,2275
public boolean isLabelName() { [EOL]     return this.getType() == Token.LABEL_NAME; [EOL] } <line_num>: 2277,2279
public boolean isName() { [EOL]     return this.getType() == Token.NAME; [EOL] } <line_num>: 2281,2283
public boolean isNE() { [EOL]     return this.getType() == Token.NE; [EOL] } <line_num>: 2285,2287
public boolean isNew() { [EOL]     return this.getType() == Token.NEW; [EOL] } <line_num>: 2289,2291
public boolean isNot() { [EOL]     return this.getType() == Token.NOT; [EOL] } <line_num>: 2293,2295
public boolean isNull() { [EOL]     return this.getType() == Token.NULL; [EOL] } <line_num>: 2297,2299
public boolean isNumber() { [EOL]     return this.getType() == Token.NUMBER; [EOL] } <line_num>: 2301,2303
public boolean isObjectLit() { [EOL]     return this.getType() == Token.OBJECTLIT; [EOL] } <line_num>: 2305,2307
public boolean isOr() { [EOL]     return this.getType() == Token.OR; [EOL] } <line_num>: 2309,2311
public boolean isParamList() { [EOL]     return this.getType() == Token.PARAM_LIST; [EOL] } <line_num>: 2313,2315
public boolean isRegExp() { [EOL]     return this.getType() == Token.REGEXP; [EOL] } <line_num>: 2317,2319
public boolean isReturn() { [EOL]     return this.getType() == Token.RETURN; [EOL] } <line_num>: 2321,2323
public boolean isScript() { [EOL]     return this.getType() == Token.SCRIPT; [EOL] } <line_num>: 2325,2327
public boolean isSetterDef() { [EOL]     return this.getType() == Token.SETTER_DEF; [EOL] } <line_num>: 2329,2331
public boolean isString() { [EOL]     return this.getType() == Token.STRING; [EOL] } <line_num>: 2333,2335
public boolean isStringKey() { [EOL]     return this.getType() == Token.STRING_KEY; [EOL] } <line_num>: 2337,2339
public boolean isSwitch() { [EOL]     return this.getType() == Token.SWITCH; [EOL] } <line_num>: 2341,2343
public boolean isThis() { [EOL]     return this.getType() == Token.THIS; [EOL] } <line_num>: 2345,2347
public boolean isThrow() { [EOL]     return this.getType() == Token.THROW; [EOL] } <line_num>: 2349,2351
public boolean isTrue() { [EOL]     return this.getType() == Token.TRUE; [EOL] } <line_num>: 2353,2355
public boolean isTry() { [EOL]     return this.getType() == Token.TRY; [EOL] } <line_num>: 2357,2359
public boolean isTypeOf() { [EOL]     return this.getType() == Token.TYPEOF; [EOL] } <line_num>: 2361,2363
public boolean isVar() { [EOL]     return this.getType() == Token.VAR; [EOL] } <line_num>: 2365,2367
public boolean isVoid() { [EOL]     return this.getType() == Token.VOID; [EOL] } <line_num>: 2369,2371
public boolean isWhile() { [EOL]     return this.getType() == Token.WHILE; [EOL] } <line_num>: 2373,2375
public boolean isWith() { [EOL]     return this.getType() == Token.WITH; [EOL] } <line_num>: 2377,2379
