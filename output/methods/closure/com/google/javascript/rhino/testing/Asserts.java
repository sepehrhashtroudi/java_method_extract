private Asserts() { [EOL] } <line_num>: 56,56
public static JSType assertResolvesToSame(JSType type) { [EOL]     Assert.assertSame(type, assertValidResolve(type)); [EOL]     return type; [EOL] } <line_num>: 58,61
public static JSType assertValidResolve(JSType type) { [EOL]     return assertValidResolve(type, MapBasedScope.emptyScope()); [EOL] } <line_num>: 64,66
public static JSType assertValidResolve(JSType type, StaticScope<JSType> scope) { [EOL]     ErrorReporter t = TestErrorReporter.forNoExpectedReports(); [EOL]     JSType resolvedType = type.resolve(t, scope); [EOL]     assertTypeEquals("JSType#resolve should not affect object equality", type, resolvedType); [EOL]     return resolvedType; [EOL] } <line_num>: 69,76
public static void assertTypeNotEquals(JSType a, JSType b) { [EOL]     assertTypeNotEquals("", a, b); [EOL] } <line_num>: 78,80
public static void assertTypeNotEquals(String message, JSType a, JSType b) { [EOL]     Assert.assertFalse(message + (message.isEmpty() ? "" : "\n") + "Type: " + b + "\n", a.isEquivalentTo(b)); [EOL]     Assert.assertFalse(message + " Equals is not symmetric.\n" + "Type: " + b + "\n", b.isEquivalentTo(a)); [EOL] } <line_num>: 82,93
public static void assertTypeEquals(JSType a, JSType b) { [EOL]     assertTypeEquals("", a, b); [EOL] } <line_num>: 95,97
public static void assertTypeEquals(String message, JSType a, JSType b) { [EOL]     Assert.assertTrue("Both types must be null, or both must be non-null " + a + "," + b, (a == null) == (b == null)); [EOL]     if (a == null) { [EOL]         return; [EOL]     } [EOL]     Assert.assertTrue(message + (message.isEmpty() ? "" : "\n") + "Expected: " + a + "\n" + "Actual  : " + b, a.isEquivalentTo(b)); [EOL]     Assert.assertTrue(message + " Equals is not symmetric.\n" + "Expected: " + b + "\n" + "Actual  : " + a, b.isEquivalentTo(a)); [EOL] } <line_num>: 99,118
public static <T extends JSType, S extends JSType> void assertTypeCollectionEquals(Iterable<T> a, Iterable<S> b) { [EOL]     Assert.assertEquals(Iterables.size(a), Iterables.size(b)); [EOL]     Iterator<T> aIterator = a.iterator(); [EOL]     Iterator<S> bIterator = b.iterator(); [EOL]     while (aIterator.hasNext()) { [EOL]         assertTypeEquals(aIterator.next(), bIterator.next()); [EOL]     } [EOL] } <line_num>: 120,128
public static void assertEquivalenceOperations(JSType a, JSType b) { [EOL]     Assert.assertTrue(a.isEquivalentTo(b)); [EOL]     Assert.assertTrue(a.isEquivalentTo(a)); [EOL]     Assert.assertTrue(b.isEquivalentTo(b)); [EOL]     Assert.assertTrue(b.isEquivalentTo(a)); [EOL]     Assert.assertTrue(a.isSubtype(b)); [EOL]     Assert.assertTrue(a.isSubtype(a)); [EOL]     Assert.assertTrue(b.isSubtype(b)); [EOL]     Assert.assertTrue(b.isSubtype(a)); [EOL]     assertTypeEquals(a, a.getGreatestSubtype(b)); [EOL]     assertTypeEquals(a, a.getGreatestSubtype(a)); [EOL]     assertTypeEquals(a, b.getGreatestSubtype(b)); [EOL]     assertTypeEquals(a, b.getGreatestSubtype(a)); [EOL]     assertTypeEquals(a, a.getLeastSupertype(b)); [EOL]     assertTypeEquals(a, a.getLeastSupertype(a)); [EOL]     assertTypeEquals(a, b.getLeastSupertype(b)); [EOL]     assertTypeEquals(a, b.getLeastSupertype(a)); [EOL]     Assert.assertTrue(a.canCastTo(b)); [EOL]     Assert.assertTrue(a.canCastTo(a)); [EOL]     Assert.assertTrue(b.canCastTo(b)); [EOL]     Assert.assertTrue(b.canCastTo(a)); [EOL] } <line_num>: 134,159
