FunctionType(JSTypeRegistry registry, String name, Node source, ArrowType arrowType, JSType typeOfThis, ImmutableList<String> templateKeys, boolean isConstructor, boolean nativeType) { [EOL]     super(registry, name, registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE), nativeType, templateKeys, null); [EOL]     setPrettyPrint(true); [EOL]     Preconditions.checkArgument(source == null || Token.FUNCTION == source.getType()); [EOL]     Preconditions.checkNotNull(arrowType); [EOL]     this.source = source; [EOL]     if (isConstructor) { [EOL]         this.kind = Kind.CONSTRUCTOR; [EOL]         this.propAccess = PropAccess.ANY; [EOL]         this.typeOfThis = typeOfThis != null ? typeOfThis : new InstanceObjectType(registry, this, nativeType, null); [EOL]     } else { [EOL]         this.kind = Kind.ORDINARY; [EOL]         this.typeOfThis = typeOfThis != null ? typeOfThis : registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE); [EOL]     } [EOL]     this.call = arrowType; [EOL] } <line_num>: 134,159
private FunctionType(JSTypeRegistry registry, String name, Node source) { [EOL]     super(registry, name, registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE)); [EOL]     setPrettyPrint(true); [EOL]     Preconditions.checkArgument(source == null || Token.FUNCTION == source.getType()); [EOL]     Preconditions.checkArgument(name != null); [EOL]     this.source = source; [EOL]     this.call = new ArrowType(registry, new Node(Token.PARAM_LIST), null); [EOL]     this.kind = Kind.INTERFACE; [EOL]     this.typeOfThis = new InstanceObjectType(registry, this); [EOL] } <line_num>: 162,174
static FunctionType forInterface(JSTypeRegistry registry, String name, Node source) { [EOL]     return new FunctionType(registry, name, source); [EOL] } <line_num>: 177,180
@Override [EOL] public boolean isInstanceType() { [EOL]     return this == registry.getNativeType(U2U_CONSTRUCTOR_TYPE); [EOL] } <line_num>: 182,187
@Override [EOL] public boolean isConstructor() { [EOL]     return kind == Kind.CONSTRUCTOR; [EOL] } <line_num>: 189,192
@Override [EOL] public boolean isInterface() { [EOL]     return kind == Kind.INTERFACE; [EOL] } <line_num>: 194,197
@Override [EOL] public boolean isOrdinaryFunction() { [EOL]     return kind == Kind.ORDINARY; [EOL] } <line_num>: 199,202
public boolean makesStructs() { [EOL]     if (!isConstructor()) { [EOL]         return false; [EOL]     } [EOL]     if (propAccess == PropAccess.STRUCT) { [EOL]         return true; [EOL]     } [EOL]     FunctionType superc = getSuperClassConstructor(); [EOL]     if (superc != null && superc.makesStructs()) { [EOL]         setStruct(); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 209,222
public boolean makesDicts() { [EOL]     if (!isConstructor()) { [EOL]         return false; [EOL]     } [EOL]     if (propAccess == PropAccess.DICT) { [EOL]         return true; [EOL]     } [EOL]     FunctionType superc = getSuperClassConstructor(); [EOL]     if (superc != null && superc.makesDicts()) { [EOL]         setDict(); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 229,242
public void setStruct() { [EOL]     propAccess = PropAccess.STRUCT; [EOL] } <line_num>: 244,246
public void setDict() { [EOL]     propAccess = PropAccess.DICT; [EOL] } <line_num>: 248,250
@Override [EOL] public FunctionType toMaybeFunctionType() { [EOL]     return this; [EOL] } <line_num>: 252,255
@Override [EOL] public boolean canBeCalled() { [EOL]     return true; [EOL] } <line_num>: 257,260
public boolean hasImplementedInterfaces() { [EOL]     if (!implementedInterfaces.isEmpty()) { [EOL]         return true; [EOL]     } [EOL]     FunctionType superCtor = isConstructor() ? getSuperClassConstructor() : null; [EOL]     if (superCtor != null) { [EOL]         return superCtor.hasImplementedInterfaces(); [EOL]     } [EOL]     return false; [EOL] } <line_num>: 262,272
public Iterable<Node> getParameters() { [EOL]     Node n = getParametersNode(); [EOL]     if (n != null) { [EOL]         return n.children(); [EOL]     } else { [EOL]         return Collections.emptySet(); [EOL]     } [EOL] } <line_num>: 274,281
public Node getParametersNode() { [EOL]     return call.parameters; [EOL] } <line_num>: 284,286
public int getMinArguments() { [EOL]     int i = 0; [EOL]     int min = 0; [EOL]     for (Node n : getParameters()) { [EOL]         i++; [EOL]         if (!n.isOptionalArg() && !n.isVarArgs()) { [EOL]             min = i; [EOL]         } [EOL]     } [EOL]     return min; [EOL] } <line_num>: 289,302
public int getMaxArguments() { [EOL]     Node params = getParametersNode(); [EOL]     if (params != null) { [EOL]         Node lastParam = params.getLastChild(); [EOL]         if (lastParam == null || !lastParam.isVarArgs()) { [EOL]             return params.getChildCount(); [EOL]         } [EOL]     } [EOL]     return Integer.MAX_VALUE; [EOL] } <line_num>: 308,318
public JSType getReturnType() { [EOL]     return call.returnType; [EOL] } <line_num>: 320,322
public boolean isReturnTypeInferred() { [EOL]     return call.returnTypeInferred; [EOL] } <line_num>: 324,326
ArrowType getInternalArrowType() { [EOL]     return call; [EOL] } <line_num>: 329,331
@Override [EOL] public Property getSlot(String name) { [EOL]     if ("prototype".equals(name)) { [EOL]         getPrototype(); [EOL]         return prototypeSlot; [EOL]     } else { [EOL]         return super.getSlot(name); [EOL]     } [EOL] } <line_num>: 333,342
@Override [EOL] public Set<String> getOwnPropertyNames() { [EOL]     if (prototypeSlot == null) { [EOL]         return super.getOwnPropertyNames(); [EOL]     } else { [EOL]         Set<String> names = Sets.newHashSet("prototype"); [EOL]         names.addAll(super.getOwnPropertyNames()); [EOL]         return names; [EOL]     } [EOL] } <line_num>: 348,357
public ObjectType getPrototype() { [EOL]     if (prototypeSlot == null) { [EOL]         String refName = getReferenceName(); [EOL]         if (refName == null) { [EOL]             setPrototypeNoCheck(registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE), null); [EOL]         } else { [EOL]             setPrototype(new PrototypeObjectType(registry, getReferenceName() + ".prototype", registry.getNativeObjectType(OBJECT_TYPE), isNativeObjectType(), null, null), null); [EOL]         } [EOL]     } [EOL]     return (ObjectType) prototypeSlot.getType(); [EOL] } <line_num>: 363,385
public void setPrototypeBasedOn(ObjectType baseType) { [EOL]     setPrototypeBasedOn(baseType, null); [EOL] } <line_num>: 392,394
void setPrototypeBasedOn(ObjectType baseType, Node propertyNode) { [EOL]     if (baseType.hasReferenceName() || isNativeObjectType() || baseType.isFunctionPrototypeType()) { [EOL]         baseType = new PrototypeObjectType(registry, getReferenceName() + ".prototype", baseType); [EOL]     } [EOL]     setPrototype(baseType, propertyNode); [EOL] } <line_num>: 396,421
boolean setPrototype(ObjectType prototype, Node propertyNode) { [EOL]     if (prototype == null) { [EOL]         return false; [EOL]     } [EOL]     if (isConstructor() && prototype == getInstanceType()) { [EOL]         return false; [EOL]     } [EOL]     return setPrototypeNoCheck(prototype, propertyNode); [EOL] } <line_num>: 428,437
private boolean setPrototypeNoCheck(ObjectType prototype, Node propertyNode) { [EOL]     ObjectType oldPrototype = prototypeSlot == null ? null : (ObjectType) prototypeSlot.getType(); [EOL]     boolean replacedPrototype = oldPrototype != null; [EOL]     this.prototypeSlot = new Property("prototype", prototype, true, propertyNode == null ? source : propertyNode); [EOL]     prototype.setOwnerFunction(this); [EOL]     if (oldPrototype != null) { [EOL]         oldPrototype.setOwnerFunction(null); [EOL]     } [EOL]     if (isConstructor() || isInterface()) { [EOL]         FunctionType superClass = getSuperClassConstructor(); [EOL]         if (superClass != null) { [EOL]             superClass.addSubType(this); [EOL]         } [EOL]         if (isInterface()) { [EOL]             for (ObjectType interfaceType : getExtendedInterfaces()) { [EOL]                 if (interfaceType.getConstructor() != null) { [EOL]                     interfaceType.getConstructor().addSubType(this); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (replacedPrototype) { [EOL]         clearCachedValues(); [EOL]     } [EOL]     return true; [EOL] } <line_num>: 440,475
public Iterable<ObjectType> getAllImplementedInterfaces() { [EOL]     Set<ObjectType> interfaces = Sets.newLinkedHashSet(); [EOL]     for (ObjectType type : getImplementedInterfaces()) { [EOL]         addRelatedInterfaces(type, interfaces); [EOL]     } [EOL]     return interfaces; [EOL] } <line_num>: 482,491
private void addRelatedInterfaces(ObjectType instance, Set<ObjectType> set) { [EOL]     FunctionType constructor = instance.getConstructor(); [EOL]     if (constructor != null) { [EOL]         if (!constructor.isInterface()) { [EOL]             return; [EOL]         } [EOL]         set.add(instance); [EOL]         for (ObjectType interfaceType : instance.getCtorExtendedInterfaces()) { [EOL]             addRelatedInterfaces(interfaceType, set); [EOL]         } [EOL]     } [EOL] } <line_num>: 493,506
public Iterable<ObjectType> getImplementedInterfaces() { [EOL]     FunctionType superCtor = isConstructor() ? getSuperClassConstructor() : null; [EOL]     if (superCtor == null) { [EOL]         return implementedInterfaces; [EOL]     } else { [EOL]         return Iterables.concat(implementedInterfaces, superCtor.getImplementedInterfaces()); [EOL]     } [EOL] } <line_num>: 509,518
public Iterable<ObjectType> getOwnImplementedInterfaces() { [EOL]     return implementedInterfaces; [EOL] } <line_num>: 521,523
public void setImplementedInterfaces(List<ObjectType> implementedInterfaces) { [EOL]     if (isConstructor()) { [EOL]         for (ObjectType type : implementedInterfaces) { [EOL]             registry.registerTypeImplementingInterface(this, type); [EOL]         } [EOL]         this.implementedInterfaces = ImmutableList.copyOf(implementedInterfaces); [EOL]     } else { [EOL]         throw new UnsupportedOperationException(); [EOL]     } [EOL] } <line_num>: 525,535
public Iterable<ObjectType> getAllExtendedInterfaces() { [EOL]     Set<ObjectType> extendedInterfaces = Sets.newLinkedHashSet(); [EOL]     for (ObjectType interfaceType : getExtendedInterfaces()) { [EOL]         addRelatedExtendedInterfaces(interfaceType, extendedInterfaces); [EOL]     } [EOL]     return extendedInterfaces; [EOL] } <line_num>: 542,551
private void addRelatedExtendedInterfaces(ObjectType instance, Set<ObjectType> set) { [EOL]     FunctionType constructor = instance.getConstructor(); [EOL]     if (constructor != null) { [EOL]         set.add(instance); [EOL]         for (ObjectType interfaceType : constructor.getExtendedInterfaces()) { [EOL]             addRelatedExtendedInterfaces(interfaceType, set); [EOL]         } [EOL]     } [EOL] } <line_num>: 553,563
public Iterable<ObjectType> getExtendedInterfaces() { [EOL]     return extendedInterfaces; [EOL] } <line_num>: 566,568
public int getExtendedInterfacesCount() { [EOL]     return extendedInterfaces.size(); [EOL] } <line_num>: 571,573
public void setExtendedInterfaces(List<ObjectType> extendedInterfaces) throws UnsupportedOperationException { [EOL]     if (isInterface()) { [EOL]         this.extendedInterfaces = ImmutableList.copyOf(extendedInterfaces); [EOL]     } else { [EOL]         throw new UnsupportedOperationException(); [EOL]     } [EOL] } <line_num>: 575,582
@Override [EOL] public JSType getPropertyType(String name) { [EOL]     if (!hasOwnProperty(name)) { [EOL]         boolean isCall = "call".equals(name); [EOL]         boolean isBind = "bind".equals(name); [EOL]         if (isCall || isBind) { [EOL]             defineDeclaredProperty(name, getCallOrBindSignature(isCall), source); [EOL]         } else if ("apply".equals(name)) { [EOL]             FunctionParamBuilder builder = new FunctionParamBuilder(registry); [EOL]             builder.addOptionalParams(registry.createNullableType(getTypeOfThis()), registry.createNullableType(registry.getNativeType(JSTypeNative.OBJECT_TYPE))); [EOL]             defineDeclaredProperty(name, new FunctionBuilder(registry).withParams(builder).withReturnType(getReturnType()).withTemplateKeys(getTemplateKeys()).build(), source); [EOL]         } [EOL]     } [EOL]     return super.getPropertyType(name); [EOL] } <line_num>: 584,616
public FunctionType getBindReturnType(int argsToBind) { [EOL]     FunctionBuilder builder = new FunctionBuilder(registry).withReturnType(getReturnType()).withTemplateKeys(getTemplateKeys()); [EOL]     if (argsToBind >= 0) { [EOL]         Node origParams = getParametersNode(); [EOL]         if (origParams != null) { [EOL]             Node params = origParams.cloneTree(); [EOL]             for (int i = 1; i < argsToBind && params.getFirstChild() != null; i++) { [EOL]                 if (params.getFirstChild().isVarArgs()) { [EOL]                     break; [EOL]                 } [EOL]                 params.removeFirstChild(); [EOL]             } [EOL]             builder.withParamsNode(params); [EOL]         } [EOL]     } [EOL]     return builder.build(); [EOL] } <line_num>: 625,643
private FunctionType getCallOrBindSignature(boolean isCall) { [EOL]     boolean isBind = !isCall; [EOL]     FunctionBuilder builder = new FunctionBuilder(registry).withReturnType(isCall ? getReturnType() : getBindReturnType(-1)).withTemplateKeys(getTemplateKeys()); [EOL]     Node origParams = getParametersNode(); [EOL]     if (origParams != null) { [EOL]         Node params = origParams.cloneTree(); [EOL]         Node thisTypeNode = Node.newString(Token.NAME, "thisType"); [EOL]         thisTypeNode.setJSType(registry.createOptionalNullableType(getTypeOfThis())); [EOL]         params.addChildToFront(thisTypeNode); [EOL]         if (isBind) { [EOL]             for (Node current = thisTypeNode.getNext(); current != null; current = current.getNext()) { [EOL]                 current.setOptionalArg(true); [EOL]             } [EOL]         } else if (isCall) { [EOL]             Node firstArg = thisTypeNode.getNext(); [EOL]             if (firstArg == null || firstArg.isOptionalArg() || firstArg.isVarArgs()) { [EOL]                 thisTypeNode.setOptionalArg(true); [EOL]             } [EOL]         } [EOL]         builder.withParamsNode(params); [EOL]     } [EOL]     return builder.build(); [EOL] } <line_num>: 650,687
@Override [EOL] boolean defineProperty(String name, JSType type, boolean inferred, Node propertyNode) { [EOL]     if ("prototype".equals(name)) { [EOL]         ObjectType objType = type.toObjectType(); [EOL]         if (objType != null) { [EOL]             if (prototypeSlot != null && objType.isEquivalentTo(prototypeSlot.getType())) { [EOL]                 return true; [EOL]             } [EOL]             setPrototypeBasedOn(objType, propertyNode); [EOL]             return true; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return super.defineProperty(name, type, inferred, propertyNode); [EOL] } <line_num>: 689,706
FunctionType supAndInfHelper(FunctionType that, boolean leastSuper) { [EOL]     Preconditions.checkNotNull(that); [EOL]     if (isEquivalentTo(that)) { [EOL]         return this; [EOL]     } [EOL]     if (isOrdinaryFunction() && that.isOrdinaryFunction() && !this.call.hasUnknownParamsOrReturn() && !that.call.hasUnknownParamsOrReturn()) { [EOL]         boolean isSubtypeOfThat = isSubtype(that); [EOL]         boolean isSubtypeOfThis = that.isSubtype(this); [EOL]         if (isSubtypeOfThat && !isSubtypeOfThis) { [EOL]             return leastSuper ? that : this; [EOL]         } else if (isSubtypeOfThis && !isSubtypeOfThat) { [EOL]             return leastSuper ? this : that; [EOL]         } [EOL]         FunctionType merged = tryMergeFunctionPiecewise(that, leastSuper); [EOL]         if (merged != null) { [EOL]             return merged; [EOL]         } [EOL]     } [EOL]     JSType functionInstance = registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE); [EOL]     if (functionInstance.isEquivalentTo(that)) { [EOL]         return leastSuper ? that : this; [EOL]     } else if (functionInstance.isEquivalentTo(this)) { [EOL]         return leastSuper ? this : that; [EOL]     } [EOL]     FunctionType greatestFn = registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE); [EOL]     FunctionType leastFn = registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE); [EOL]     return leastSuper ? greatestFn : leastFn; [EOL] } <line_num>: 716,786
private FunctionType tryMergeFunctionPiecewise(FunctionType other, boolean leastSuper) { [EOL]     Node newParamsNode = null; [EOL]     if (call.hasEqualParameters(other.call, EquivalenceMethod.IDENTITY)) { [EOL]         newParamsNode = call.parameters; [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     JSType newReturnType = leastSuper ? call.returnType.getLeastSupertype(other.call.returnType) : call.returnType.getGreatestSubtype(other.call.returnType); [EOL]     JSType newTypeOfThis = null; [EOL]     if (isEquivalent(typeOfThis, other.typeOfThis)) { [EOL]         newTypeOfThis = typeOfThis; [EOL]     } else { [EOL]         JSType maybeNewTypeOfThis = leastSuper ? typeOfThis.getLeastSupertype(other.typeOfThis) : typeOfThis.getGreatestSubtype(other.typeOfThis); [EOL]         newTypeOfThis = maybeNewTypeOfThis; [EOL]     } [EOL]     boolean newReturnTypeInferred = call.returnTypeInferred || other.call.returnTypeInferred; [EOL]     return new FunctionType(registry, null, null, new ArrowType(registry, newParamsNode, newReturnType, newReturnTypeInferred), newTypeOfThis, null, false, false); [EOL] } <line_num>: 792,825
public FunctionType getSuperClassConstructor() { [EOL]     Preconditions.checkArgument(isConstructor() || isInterface()); [EOL]     ObjectType maybeSuperInstanceType = getPrototype().getImplicitPrototype(); [EOL]     if (maybeSuperInstanceType == null) { [EOL]         return null; [EOL]     } [EOL]     return maybeSuperInstanceType.getConstructor(); [EOL] } <line_num>: 831,838
public static ObjectType getTopDefiningInterface(ObjectType type, String propertyName) { [EOL]     ObjectType foundType = null; [EOL]     if (type.hasProperty(propertyName)) { [EOL]         foundType = type; [EOL]     } [EOL]     for (ObjectType interfaceType : type.getCtorExtendedInterfaces()) { [EOL]         if (interfaceType.hasProperty(propertyName)) { [EOL]             foundType = getTopDefiningInterface(interfaceType, propertyName); [EOL]         } [EOL]     } [EOL]     return foundType; [EOL] } <line_num>: 844,856
public ObjectType getTopMostDefiningType(String propertyName) { [EOL]     Preconditions.checkState(isConstructor() || isInterface()); [EOL]     Preconditions.checkArgument(getInstanceType().hasProperty(propertyName)); [EOL]     FunctionType ctor = this; [EOL]     if (isInterface()) { [EOL]         return getTopDefiningInterface(getInstanceType(), propertyName); [EOL]     } [EOL]     ObjectType topInstanceType = null; [EOL]     do { [EOL]         topInstanceType = ctor.getInstanceType(); [EOL]         ctor = ctor.getSuperClassConstructor(); [EOL]     } while (ctor != null && ctor.getPrototype().hasProperty(propertyName)); [EOL]     return topInstanceType; [EOL] } <line_num>: 863,880
boolean checkFunctionEquivalenceHelper(FunctionType that, EquivalenceMethod eqMethod) { [EOL]     if (isConstructor()) { [EOL]         if (that.isConstructor()) { [EOL]             return this == that; [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (isInterface()) { [EOL]         if (that.isInterface()) { [EOL]             return getReferenceName().equals(that.getReferenceName()); [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (that.isInterface()) { [EOL]         return false; [EOL]     } [EOL]     return typeOfThis.checkEquivalenceHelper(that.typeOfThis, eqMethod) && call.checkArrowEquivalenceHelper(that.call, eqMethod); [EOL] } <line_num>: 886,906
@Override [EOL] public int hashCode() { [EOL]     return isInterface() ? getReferenceName().hashCode() : call.hashCode(); [EOL] } <line_num>: 908,911
public boolean hasEqualCallType(FunctionType otherType) { [EOL]     return this.call.checkArrowEquivalenceHelper(otherType.call, EquivalenceMethod.IDENTITY); [EOL] } <line_num>: 913,916
@Override [EOL] String toStringHelper(boolean forAnnotations) { [EOL]     if (!isPrettyPrint() || this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) { [EOL]         return "Function"; [EOL]     } [EOL]     setPrettyPrint(false); [EOL]     StringBuilder b = new StringBuilder(32); [EOL]     b.append("function ("); [EOL]     int paramNum = call.parameters.getChildCount(); [EOL]     boolean hasKnownTypeOfThis = !(typeOfThis instanceof UnknownType); [EOL]     if (hasKnownTypeOfThis) { [EOL]         if (isConstructor()) { [EOL]             b.append("new:"); [EOL]         } else { [EOL]             b.append("this:"); [EOL]         } [EOL]         b.append(typeOfThis.toStringHelper(forAnnotations)); [EOL]     } [EOL]     if (paramNum > 0) { [EOL]         if (hasKnownTypeOfThis) { [EOL]             b.append(", "); [EOL]         } [EOL]         Node p = call.parameters.getFirstChild(); [EOL]         appendArgString(b, p, forAnnotations); [EOL]         p = p.getNext(); [EOL]         while (p != null) { [EOL]             b.append(", "); [EOL]             appendArgString(b, p, forAnnotations); [EOL]             p = p.getNext(); [EOL]         } [EOL]     } [EOL]     b.append("): "); [EOL]     b.append(call.returnType.toStringHelper(forAnnotations)); [EOL]     setPrettyPrint(true); [EOL]     return b.toString(); [EOL] } <line_num>: 924,964
private void appendArgString(StringBuilder b, Node p, boolean forAnnotations) { [EOL]     if (p.isVarArgs()) { [EOL]         appendVarArgsString(b, p.getJSType(), forAnnotations); [EOL]     } else if (p.isOptionalArg()) { [EOL]         appendOptionalArgString(b, p.getJSType(), forAnnotations); [EOL]     } else { [EOL]         b.append(p.getJSType().toStringHelper(forAnnotations)); [EOL]     } [EOL] } <line_num>: 966,975
private void appendVarArgsString(StringBuilder builder, JSType paramType, boolean forAnnotations) { [EOL]     if (paramType.isUnionType()) { [EOL]         paramType = paramType.toMaybeUnionType().getRestrictedUnion(registry.getNativeType(JSTypeNative.VOID_TYPE)); [EOL]     } [EOL]     builder.append("...[").append(paramType.toStringHelper(forAnnotations)).append("]"); [EOL] } <line_num>: 978,987
private void appendOptionalArgString(StringBuilder builder, JSType paramType, boolean forAnnotations) { [EOL]     if (paramType.isUnionType()) { [EOL]         paramType = paramType.toMaybeUnionType().getRestrictedUnion(registry.getNativeType(JSTypeNative.VOID_TYPE)); [EOL]     } [EOL]     builder.append(paramType.toStringHelper(forAnnotations)).append("="); [EOL] } <line_num>: 990,998
@Override [EOL] public boolean isSubtype(JSType that) { [EOL]     if (JSType.isSubtypeHelper(this, that)) { [EOL]         return true; [EOL]     } [EOL]     if (that.isFunctionType()) { [EOL]         FunctionType other = that.toMaybeFunctionType(); [EOL]         if (other.isInterface()) { [EOL]             return true; [EOL]         } [EOL]         if (isInterface()) { [EOL]             return false; [EOL]         } [EOL]         boolean treatThisTypesAsCovariant = (other.typeOfThis.toObjectType() != null && other.typeOfThis.toObjectType().getConstructor() != null && other.typeOfThis.toObjectType().getConstructor().isInterface()) || other.typeOfThis.isSubtype(this.typeOfThis) || this.typeOfThis.isSubtype(other.typeOfThis); [EOL]         return treatThisTypesAsCovariant && this.call.isSubtype(other.call); [EOL]     } [EOL]     return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that); [EOL] } <line_num>: 1005,1045
@Override [EOL] public <T> T visit(Visitor<T> visitor) { [EOL]     return visitor.caseFunctionType(this); [EOL] } <line_num>: 1047,1050
@Override [EOL] <T> T visit(RelationshipVisitor<T> visitor, JSType that) { [EOL]     return visitor.caseFunctionType(this, that); [EOL] } <line_num>: 1052,1054
public ObjectType getInstanceType() { [EOL]     Preconditions.checkState(hasInstanceType()); [EOL]     return typeOfThis.toObjectType(); [EOL] } <line_num>: 1061,1064
void setInstanceType(ObjectType instanceType) { [EOL]     typeOfThis = instanceType; [EOL] } <line_num>: 1070,1072
public boolean hasInstanceType() { [EOL]     return isConstructor() || isInterface(); [EOL] } <line_num>: 1077,1079
@Override [EOL] public JSType getTypeOfThis() { [EOL]     return typeOfThis.isEmptyType() ? registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE) : typeOfThis; [EOL] } <line_num>: 1084,1088
public Node getSource() { [EOL]     return source; [EOL] } <line_num>: 1093,1095
public void setSource(Node source) { [EOL]     if (prototypeSlot != null) { [EOL]         if (source == null || prototypeSlot.getNode() == null) { [EOL]             prototypeSlot = new Property(prototypeSlot.getName(), prototypeSlot.getType(), prototypeSlot.isTypeInferred(), source); [EOL]         } [EOL]     } [EOL]     this.source = source; [EOL] } <line_num>: 1100,1113
private void addSubType(FunctionType subType) { [EOL]     if (subTypes == null) { [EOL]         subTypes = Lists.newArrayList(); [EOL]     } [EOL]     subTypes.add(subType); [EOL] } <line_num>: 1116,1121
@Override [EOL] public void clearCachedValues() { [EOL]     super.clearCachedValues(); [EOL]     if (subTypes != null) { [EOL]         for (FunctionType subType : subTypes) { [EOL]             subType.clearCachedValues(); [EOL]         } [EOL]     } [EOL]     if (!isNativeObjectType()) { [EOL]         if (hasInstanceType()) { [EOL]             getInstanceType().clearCachedValues(); [EOL]         } [EOL]         if (prototypeSlot != null) { [EOL]             ((ObjectType) prototypeSlot.getType()).clearCachedValues(); [EOL]         } [EOL]     } [EOL] } <line_num>: 1123,1142
public List<FunctionType> getSubTypes() { [EOL]     return subTypes; [EOL] } <line_num>: 1149,1151
@Override [EOL] public boolean hasCachedValues() { [EOL]     return prototypeSlot != null || super.hasCachedValues(); [EOL] } <line_num>: 1153,1156
@Override [EOL] JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { [EOL]     setResolvedTypeInternal(this); [EOL]     call = (ArrowType) safeResolve(call, t, scope); [EOL]     if (prototypeSlot != null) { [EOL]         prototypeSlot.setType(safeResolve(prototypeSlot.getType(), t, scope)); [EOL]     } [EOL]     JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope); [EOL]     if (maybeTypeOfThis != null) { [EOL]         maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined(); [EOL]     } [EOL]     if (maybeTypeOfThis instanceof ObjectType) { [EOL]         typeOfThis = maybeTypeOfThis; [EOL]     } [EOL]     boolean changed = false; [EOL]     ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder(); [EOL]     for (ObjectType iface : implementedInterfaces) { [EOL]         ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope); [EOL]         resolvedInterfaces.add(resolvedIface); [EOL]         changed |= (resolvedIface != iface); [EOL]     } [EOL]     if (changed) { [EOL]         implementedInterfaces = resolvedInterfaces.build(); [EOL]     } [EOL]     if (subTypes != null) { [EOL]         for (int i = 0; i < subTypes.size(); i++) { [EOL]             subTypes.set(i, JSType.toMaybeFunctionType(subTypes.get(i).resolve(t, scope))); [EOL]         } [EOL]     } [EOL]     return super.resolveInternal(t, scope); [EOL] } <line_num>: 1158,1207
@Override [EOL] public String toDebugHashCodeString() { [EOL]     if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) { [EOL]         return super.toDebugHashCodeString(); [EOL]     } [EOL]     StringBuilder b = new StringBuilder(32); [EOL]     b.append("function ("); [EOL]     int paramNum = call.parameters.getChildCount(); [EOL]     boolean hasKnownTypeOfThis = !typeOfThis.isUnknownType(); [EOL]     if (hasKnownTypeOfThis) { [EOL]         b.append("this:"); [EOL]         b.append(getDebugHashCodeStringOf(typeOfThis)); [EOL]     } [EOL]     if (paramNum > 0) { [EOL]         if (hasKnownTypeOfThis) { [EOL]             b.append(", "); [EOL]         } [EOL]         Node p = call.parameters.getFirstChild(); [EOL]         b.append(getDebugHashCodeStringOf(p.getJSType())); [EOL]         p = p.getNext(); [EOL]         while (p != null) { [EOL]             b.append(", "); [EOL]             b.append(getDebugHashCodeStringOf(p.getJSType())); [EOL]             p = p.getNext(); [EOL]         } [EOL]     } [EOL]     b.append(")"); [EOL]     b.append(": "); [EOL]     b.append(getDebugHashCodeStringOf(call.returnType)); [EOL]     return b.toString(); [EOL] } <line_num>: 1209,1240
private String getDebugHashCodeStringOf(JSType type) { [EOL]     if (type == this) { [EOL]         return "me"; [EOL]     } else { [EOL]         return type.toDebugHashCodeString(); [EOL]     } [EOL] } <line_num>: 1242,1248
public FunctionType cloneWithoutArrowType() { [EOL]     FunctionType result = new FunctionType(registry, getReferenceName(), source, registry.createArrowType(null, null), getInstanceType(), null, true, false); [EOL]     result.setPrototypeBasedOn(getInstanceType()); [EOL]     return result; [EOL] } <line_num>: 1251,1258
@Override [EOL] public boolean hasAnyTemplateTypesInternal() { [EOL]     return !getTemplateKeys().isEmpty() || typeOfThis.hasAnyTemplateTypes() || call.hasAnyTemplateTypes(); [EOL] } <line_num>: 1260,1265
