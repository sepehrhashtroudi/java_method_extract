public JSTypeRegistry(ErrorReporter reporter) { [EOL]     this(reporter, false); [EOL] } <line_num>: 196,198
public JSTypeRegistry(ErrorReporter reporter, boolean tolerateUndefinedValues) { [EOL]     this.reporter = reporter; [EOL]     nativeTypes = new JSType[JSTypeNative.values().length]; [EOL]     namesToTypes = new HashMap<String, JSType>(); [EOL]     resetForTypeCheck(); [EOL]     this.tolerateUndefinedValues = tolerateUndefinedValues; [EOL] } <line_num>: 203,210
public void setResolveMode(ResolveMode mode) { [EOL]     this.resolveMode = mode; [EOL] } <line_num>: 216,218
ResolveMode getResolveMode() { [EOL]     return resolveMode; [EOL] } <line_num>: 220,222
public ErrorReporter getErrorReporter() { [EOL]     return reporter; [EOL] } <line_num>: 224,226
public boolean shouldTolerateUndefinedValues() { [EOL]     return tolerateUndefinedValues; [EOL] } <line_num>: 228,230
public void resetForTypeCheck() { [EOL]     typesIndexedByProperty.clear(); [EOL]     eachRefTypeIndexedByProperty.clear(); [EOL]     initializeBuiltInTypes(); [EOL]     namesToTypes.clear(); [EOL]     namespaces.clear(); [EOL]     initializeRegistry(); [EOL] } <line_num>: 235,242
@Override [EOL] public FunctionType getConstructor() { [EOL]     return registry.getNativeFunctionType(JSTypeNative.FUNCTION_FUNCTION_TYPE); [EOL] } <line_num>: 526,529
private void initializeBuiltInTypes() { [EOL]     BooleanType BOOLEAN_TYPE = new BooleanType(this); [EOL]     registerNativeType(JSTypeNative.BOOLEAN_TYPE, BOOLEAN_TYPE); [EOL]     NullType NULL_TYPE = new NullType(this); [EOL]     registerNativeType(JSTypeNative.NULL_TYPE, NULL_TYPE); [EOL]     NumberType NUMBER_TYPE = new NumberType(this); [EOL]     registerNativeType(JSTypeNative.NUMBER_TYPE, NUMBER_TYPE); [EOL]     StringType STRING_TYPE = new StringType(this); [EOL]     registerNativeType(JSTypeNative.STRING_TYPE, STRING_TYPE); [EOL]     UnknownType UNKNOWN_TYPE = new UnknownType(this, false); [EOL]     registerNativeType(JSTypeNative.UNKNOWN_TYPE, UNKNOWN_TYPE); [EOL]     UnknownType checkedUnknownType = new UnknownType(this, true); [EOL]     registerNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE, checkedUnknownType); [EOL]     VoidType VOID_TYPE = new VoidType(this); [EOL]     registerNativeType(JSTypeNative.VOID_TYPE, VOID_TYPE); [EOL]     AllType ALL_TYPE = new AllType(this); [EOL]     registerNativeType(JSTypeNative.ALL_TYPE, ALL_TYPE); [EOL]     PrototypeObjectType TOP_LEVEL_PROTOTYPE = new PrototypeObjectType(this, null, null, true, null, null); [EOL]     registerNativeType(JSTypeNative.TOP_LEVEL_PROTOTYPE, TOP_LEVEL_PROTOTYPE); [EOL]     FunctionType OBJECT_FUNCTION_TYPE = new FunctionType(this, "Object", null, createArrowType(createOptionalParameters(ALL_TYPE), UNKNOWN_TYPE), null, null, true, true); [EOL]     OBJECT_FUNCTION_TYPE.setPrototype(TOP_LEVEL_PROTOTYPE, null); [EOL]     registerNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE, OBJECT_FUNCTION_TYPE); [EOL]     ObjectType OBJECT_TYPE = OBJECT_FUNCTION_TYPE.getInstanceType(); [EOL]     registerNativeType(JSTypeNative.OBJECT_TYPE, OBJECT_TYPE); [EOL]     ObjectType OBJECT_PROTOTYPE = OBJECT_FUNCTION_TYPE.getPrototype(); [EOL]     registerNativeType(JSTypeNative.OBJECT_PROTOTYPE, OBJECT_PROTOTYPE); [EOL]     FunctionType FUNCTION_FUNCTION_TYPE = new FunctionType(this, "Function", null, createArrowType(createParametersWithVarArgs(ALL_TYPE), UNKNOWN_TYPE), null, null, true, true); [EOL]     FUNCTION_FUNCTION_TYPE.setPrototypeBasedOn(OBJECT_TYPE); [EOL]     registerNativeType(JSTypeNative.FUNCTION_FUNCTION_TYPE, FUNCTION_FUNCTION_TYPE); [EOL]     ObjectType FUNCTION_PROTOTYPE = FUNCTION_FUNCTION_TYPE.getPrototype(); [EOL]     registerNativeType(JSTypeNative.FUNCTION_PROTOTYPE, FUNCTION_PROTOTYPE); [EOL]     NoType NO_TYPE = new NoType(this); [EOL]     registerNativeType(JSTypeNative.NO_TYPE, NO_TYPE); [EOL]     NoObjectType NO_OBJECT_TYPE = new NoObjectType(this); [EOL]     registerNativeType(JSTypeNative.NO_OBJECT_TYPE, NO_OBJECT_TYPE); [EOL]     NoObjectType NO_RESOLVED_TYPE = new NoResolvedType(this); [EOL]     registerNativeType(JSTypeNative.NO_RESOLVED_TYPE, NO_RESOLVED_TYPE); [EOL]     FunctionType ARRAY_FUNCTION_TYPE = new FunctionType(this, "Array", null, createArrowType(createParametersWithVarArgs(ALL_TYPE), null), null, null, true, true); [EOL]     ARRAY_FUNCTION_TYPE.getInternalArrowType().returnType = ARRAY_FUNCTION_TYPE.getInstanceType(); [EOL]     ObjectType arrayPrototype = ARRAY_FUNCTION_TYPE.getPrototype(); [EOL]     registerNativeType(JSTypeNative.ARRAY_FUNCTION_TYPE, ARRAY_FUNCTION_TYPE); [EOL]     ObjectType ARRAY_TYPE = ARRAY_FUNCTION_TYPE.getInstanceType(); [EOL]     registerNativeType(JSTypeNative.ARRAY_TYPE, ARRAY_TYPE); [EOL]     FunctionType BOOLEAN_OBJECT_FUNCTION_TYPE = new FunctionType(this, "Boolean", null, createArrowType(createOptionalParameters(ALL_TYPE), BOOLEAN_TYPE), null, null, true, true); [EOL]     ObjectType booleanPrototype = BOOLEAN_OBJECT_FUNCTION_TYPE.getPrototype(); [EOL]     registerNativeType(JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE, BOOLEAN_OBJECT_FUNCTION_TYPE); [EOL]     ObjectType BOOLEAN_OBJECT_TYPE = BOOLEAN_OBJECT_FUNCTION_TYPE.getInstanceType(); [EOL]     registerNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE, BOOLEAN_OBJECT_TYPE); [EOL]     FunctionType DATE_FUNCTION_TYPE = new FunctionType(this, "Date", null, createArrowType(createOptionalParameters(UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE), STRING_TYPE), null, null, true, true); [EOL]     ObjectType datePrototype = DATE_FUNCTION_TYPE.getPrototype(); [EOL]     registerNativeType(JSTypeNative.DATE_FUNCTION_TYPE, DATE_FUNCTION_TYPE); [EOL]     ObjectType DATE_TYPE = DATE_FUNCTION_TYPE.getInstanceType(); [EOL]     registerNativeType(JSTypeNative.DATE_TYPE, DATE_TYPE); [EOL]     FunctionType ERROR_FUNCTION_TYPE = new ErrorFunctionType(this, "Error"); [EOL]     registerNativeType(JSTypeNative.ERROR_FUNCTION_TYPE, ERROR_FUNCTION_TYPE); [EOL]     ObjectType ERROR_TYPE = ERROR_FUNCTION_TYPE.getInstanceType(); [EOL]     registerNativeType(JSTypeNative.ERROR_TYPE, ERROR_TYPE); [EOL]     FunctionType EVAL_ERROR_FUNCTION_TYPE = new ErrorFunctionType(this, "EvalError"); [EOL]     EVAL_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE); [EOL]     registerNativeType(JSTypeNative.EVAL_ERROR_FUNCTION_TYPE, EVAL_ERROR_FUNCTION_TYPE); [EOL]     ObjectType EVAL_ERROR_TYPE = EVAL_ERROR_FUNCTION_TYPE.getInstanceType(); [EOL]     registerNativeType(JSTypeNative.EVAL_ERROR_TYPE, EVAL_ERROR_TYPE); [EOL]     FunctionType RANGE_ERROR_FUNCTION_TYPE = new ErrorFunctionType(this, "RangeError"); [EOL]     RANGE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE); [EOL]     registerNativeType(JSTypeNative.RANGE_ERROR_FUNCTION_TYPE, RANGE_ERROR_FUNCTION_TYPE); [EOL]     ObjectType RANGE_ERROR_TYPE = RANGE_ERROR_FUNCTION_TYPE.getInstanceType(); [EOL]     registerNativeType(JSTypeNative.RANGE_ERROR_TYPE, RANGE_ERROR_TYPE); [EOL]     FunctionType REFERENCE_ERROR_FUNCTION_TYPE = new ErrorFunctionType(this, "ReferenceError"); [EOL]     REFERENCE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE); [EOL]     registerNativeType(JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE, REFERENCE_ERROR_FUNCTION_TYPE); [EOL]     ObjectType REFERENCE_ERROR_TYPE = REFERENCE_ERROR_FUNCTION_TYPE.getInstanceType(); [EOL]     registerNativeType(JSTypeNative.REFERENCE_ERROR_TYPE, REFERENCE_ERROR_TYPE); [EOL]     FunctionType SYNTAX_ERROR_FUNCTION_TYPE = new ErrorFunctionType(this, "SyntaxError"); [EOL]     SYNTAX_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE); [EOL]     registerNativeType(JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE, SYNTAX_ERROR_FUNCTION_TYPE); [EOL]     ObjectType SYNTAX_ERROR_TYPE = SYNTAX_ERROR_FUNCTION_TYPE.getInstanceType(); [EOL]     registerNativeType(JSTypeNative.SYNTAX_ERROR_TYPE, SYNTAX_ERROR_TYPE); [EOL]     FunctionType TYPE_ERROR_FUNCTION_TYPE = new ErrorFunctionType(this, "TypeError"); [EOL]     TYPE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE); [EOL]     registerNativeType(JSTypeNative.TYPE_ERROR_FUNCTION_TYPE, TYPE_ERROR_FUNCTION_TYPE); [EOL]     ObjectType TYPE_ERROR_TYPE = TYPE_ERROR_FUNCTION_TYPE.getInstanceType(); [EOL]     registerNativeType(JSTypeNative.TYPE_ERROR_TYPE, TYPE_ERROR_TYPE); [EOL]     FunctionType URI_ERROR_FUNCTION_TYPE = new ErrorFunctionType(this, "URIError"); [EOL]     URI_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE); [EOL]     registerNativeType(JSTypeNative.URI_ERROR_FUNCTION_TYPE, URI_ERROR_FUNCTION_TYPE); [EOL]     ObjectType URI_ERROR_TYPE = URI_ERROR_FUNCTION_TYPE.getInstanceType(); [EOL]     registerNativeType(JSTypeNative.URI_ERROR_TYPE, URI_ERROR_TYPE); [EOL]     FunctionType NUMBER_OBJECT_FUNCTION_TYPE = new FunctionType(this, "Number", null, createArrowType(createOptionalParameters(ALL_TYPE), NUMBER_TYPE), null, null, true, true); [EOL]     ObjectType numberPrototype = NUMBER_OBJECT_FUNCTION_TYPE.getPrototype(); [EOL]     registerNativeType(JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE, NUMBER_OBJECT_FUNCTION_TYPE); [EOL]     ObjectType NUMBER_OBJECT_TYPE = NUMBER_OBJECT_FUNCTION_TYPE.getInstanceType(); [EOL]     registerNativeType(JSTypeNative.NUMBER_OBJECT_TYPE, NUMBER_OBJECT_TYPE); [EOL]     FunctionType REGEXP_FUNCTION_TYPE = new FunctionType(this, "RegExp", null, createArrowType(createOptionalParameters(ALL_TYPE, ALL_TYPE)), null, null, true, true); [EOL]     REGEXP_FUNCTION_TYPE.getInternalArrowType().returnType = REGEXP_FUNCTION_TYPE.getInstanceType(); [EOL]     ObjectType regexpPrototype = REGEXP_FUNCTION_TYPE.getPrototype(); [EOL]     registerNativeType(JSTypeNative.REGEXP_FUNCTION_TYPE, REGEXP_FUNCTION_TYPE); [EOL]     ObjectType REGEXP_TYPE = REGEXP_FUNCTION_TYPE.getInstanceType(); [EOL]     registerNativeType(JSTypeNative.REGEXP_TYPE, REGEXP_TYPE); [EOL]     FunctionType STRING_OBJECT_FUNCTION_TYPE = new FunctionType(this, "String", null, createArrowType(createOptionalParameters(ALL_TYPE), STRING_TYPE), null, null, true, true); [EOL]     ObjectType stringPrototype = STRING_OBJECT_FUNCTION_TYPE.getPrototype(); [EOL]     registerNativeType(JSTypeNative.STRING_OBJECT_FUNCTION_TYPE, STRING_OBJECT_FUNCTION_TYPE); [EOL]     ObjectType STRING_OBJECT_TYPE = STRING_OBJECT_FUNCTION_TYPE.getInstanceType(); [EOL]     registerNativeType(JSTypeNative.STRING_OBJECT_TYPE, STRING_OBJECT_TYPE); [EOL]     JSType NULL_VOID = createUnionType(NULL_TYPE, VOID_TYPE); [EOL]     registerNativeType(JSTypeNative.NULL_VOID, NULL_VOID); [EOL]     JSType OBJECT_NUMBER_STRING = createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE); [EOL]     registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING, OBJECT_NUMBER_STRING); [EOL]     JSType OBJECT_NUMBER_STRING_BOOLEAN = createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE); [EOL]     registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN, OBJECT_NUMBER_STRING_BOOLEAN); [EOL]     JSType NUMBER_STRING_BOOLEAN = createUnionType(NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE); [EOL]     registerNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN, NUMBER_STRING_BOOLEAN); [EOL]     JSType NUMBER_STRING = createUnionType(NUMBER_TYPE, STRING_TYPE); [EOL]     registerNativeType(JSTypeNative.NUMBER_STRING, NUMBER_STRING); [EOL]     JSType STRING_VALUE_OR_OBJECT_TYPE = createUnionType(STRING_OBJECT_TYPE, STRING_TYPE); [EOL]     registerNativeType(JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE, STRING_VALUE_OR_OBJECT_TYPE); [EOL]     JSType NUMBER_VALUE_OR_OBJECT_TYPE = createUnionType(NUMBER_OBJECT_TYPE, NUMBER_TYPE); [EOL]     registerNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE, NUMBER_VALUE_OR_OBJECT_TYPE); [EOL]     FunctionType U2U_FUNCTION_TYPE = createFunctionType(UNKNOWN_TYPE, true, UNKNOWN_TYPE); [EOL]     registerNativeType(JSTypeNative.U2U_FUNCTION_TYPE, U2U_FUNCTION_TYPE); [EOL]     FunctionType U2U_CONSTRUCTOR_TYPE = new FunctionType(this, "Function", null, createArrowType(createParametersWithVarArgs(UNKNOWN_TYPE), UNKNOWN_TYPE), UNKNOWN_TYPE, null, true, true) { [EOL]  [EOL]         private static final long serialVersionUID = 1L; [EOL]  [EOL]         @Override [EOL]         public FunctionType getConstructor() { [EOL]             return registry.getNativeFunctionType(JSTypeNative.FUNCTION_FUNCTION_TYPE); [EOL]         } [EOL]     }; [EOL]     registerNativeType(JSTypeNative.U2U_CONSTRUCTOR_TYPE, U2U_CONSTRUCTOR_TYPE); [EOL]     registerNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE, U2U_CONSTRUCTOR_TYPE); [EOL]     FUNCTION_FUNCTION_TYPE.setInstanceType(U2U_CONSTRUCTOR_TYPE); [EOL]     U2U_CONSTRUCTOR_TYPE.setImplicitPrototype(FUNCTION_PROTOTYPE); [EOL]     FunctionType LEAST_FUNCTION_TYPE = createNativeFunctionTypeWithVarArgs(NO_TYPE, ALL_TYPE); [EOL]     registerNativeType(JSTypeNative.LEAST_FUNCTION_TYPE, LEAST_FUNCTION_TYPE); [EOL]     FunctionType GLOBAL_THIS_CTOR = new FunctionType(this, "global this", null, createArrowType(createParameters(false, ALL_TYPE), NUMBER_TYPE), null, null, true, true); [EOL]     ObjectType GLOBAL_THIS = GLOBAL_THIS_CTOR.getInstanceType(); [EOL]     registerNativeType(JSTypeNative.GLOBAL_THIS, GLOBAL_THIS); [EOL]     FunctionType GREATEST_FUNCTION_TYPE = createNativeFunctionTypeWithVarArgs(ALL_TYPE, NO_TYPE); [EOL]     registerNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE, GREATEST_FUNCTION_TYPE); [EOL]     registerPropertyOnType("prototype", OBJECT_FUNCTION_TYPE); [EOL] } <line_num>: 244,563
private void initializeRegistry() { [EOL]     register(getNativeType(JSTypeNative.ARRAY_TYPE)); [EOL]     register(getNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE)); [EOL]     register(getNativeType(JSTypeNative.BOOLEAN_TYPE)); [EOL]     register(getNativeType(JSTypeNative.DATE_TYPE)); [EOL]     register(getNativeType(JSTypeNative.NULL_TYPE)); [EOL]     register(getNativeType(JSTypeNative.NULL_TYPE), "Null"); [EOL]     register(getNativeType(JSTypeNative.NUMBER_OBJECT_TYPE)); [EOL]     register(getNativeType(JSTypeNative.NUMBER_TYPE)); [EOL]     register(getNativeType(JSTypeNative.OBJECT_TYPE)); [EOL]     register(getNativeType(JSTypeNative.ERROR_TYPE)); [EOL]     register(getNativeType(JSTypeNative.URI_ERROR_TYPE)); [EOL]     register(getNativeType(JSTypeNative.EVAL_ERROR_TYPE)); [EOL]     register(getNativeType(JSTypeNative.TYPE_ERROR_TYPE)); [EOL]     register(getNativeType(JSTypeNative.RANGE_ERROR_TYPE)); [EOL]     register(getNativeType(JSTypeNative.REFERENCE_ERROR_TYPE)); [EOL]     register(getNativeType(JSTypeNative.SYNTAX_ERROR_TYPE)); [EOL]     register(getNativeType(JSTypeNative.REGEXP_TYPE)); [EOL]     register(getNativeType(JSTypeNative.STRING_OBJECT_TYPE)); [EOL]     register(getNativeType(JSTypeNative.STRING_TYPE)); [EOL]     register(getNativeType(JSTypeNative.VOID_TYPE)); [EOL]     register(getNativeType(JSTypeNative.VOID_TYPE), "Undefined"); [EOL]     register(getNativeType(JSTypeNative.VOID_TYPE), "void"); [EOL]     register(getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE), "Function"); [EOL] } <line_num>: 565,589
private void register(JSType type) { [EOL]     register(type, type.toString()); [EOL] } <line_num>: 591,593
private void register(JSType type, String name) { [EOL]     Preconditions.checkArgument(!name.contains("<"), "Type names cannot contain template annotations."); [EOL]     namesToTypes.put(name, type); [EOL]     while (name.indexOf('.') > 0) { [EOL]         name = name.substring(0, name.lastIndexOf('.')); [EOL]         namespaces.add(name); [EOL]     } [EOL] } <line_num>: 595,606
private void registerNativeType(JSTypeNative typeId, JSType type) { [EOL]     nativeTypes[typeId.ordinal()] = type; [EOL] } <line_num>: 608,610
public void registerPropertyOnType(String propertyName, JSType type) { [EOL]     UnionTypeBuilder typeSet = typesIndexedByProperty.get(propertyName); [EOL]     if (typeSet == null) { [EOL]         typeSet = new UnionTypeBuilder(this, PROPERTY_CHECKING_UNION_SIZE); [EOL]         typesIndexedByProperty.put(propertyName, typeSet); [EOL]     } [EOL]     typeSet.addAlternate(type); [EOL]     addReferenceTypeIndexedByProperty(propertyName, type); [EOL]     greatestSubtypeByProperty.remove(propertyName); [EOL] } <line_num>: 624,636
private void addReferenceTypeIndexedByProperty(String propertyName, JSType type) { [EOL]     if (type instanceof ObjectType && ((ObjectType) type).hasReferenceName()) { [EOL]         Map<String, ObjectType> typeSet = eachRefTypeIndexedByProperty.get(propertyName); [EOL]         if (typeSet == null) { [EOL]             typeSet = Maps.newHashMap(); [EOL]             eachRefTypeIndexedByProperty.put(propertyName, typeSet); [EOL]         } [EOL]         ObjectType objType = (ObjectType) type; [EOL]         typeSet.put(objType.getReferenceName(), objType); [EOL]     } else if (type instanceof NamedType) { [EOL]         addReferenceTypeIndexedByProperty(propertyName, ((NamedType) type).getReferencedType()); [EOL]     } else if (type.isUnionType()) { [EOL]         for (JSType alternate : type.toMaybeUnionType().getAlternates()) { [EOL]             addReferenceTypeIndexedByProperty(propertyName, alternate); [EOL]         } [EOL]     } [EOL] } <line_num>: 638,657
public void unregisterPropertyOnType(String propertyName, JSType type) { [EOL]     Map<String, ObjectType> typeSet = eachRefTypeIndexedByProperty.get(propertyName); [EOL]     if (typeSet != null) { [EOL]         typeSet.remove(type.toObjectType().getReferenceName()); [EOL]     } [EOL] } <line_num>: 667,674
public JSType getGreatestSubtypeWithProperty(JSType type, String propertyName) { [EOL]     if (greatestSubtypeByProperty.containsKey(propertyName)) { [EOL]         return greatestSubtypeByProperty.get(propertyName).getGreatestSubtype(type); [EOL]     } [EOL]     if (typesIndexedByProperty.containsKey(propertyName)) { [EOL]         JSType built = typesIndexedByProperty.get(propertyName).build(); [EOL]         greatestSubtypeByProperty.put(propertyName, built); [EOL]         return built.getGreatestSubtype(type); [EOL]     } [EOL]     return getNativeType(NO_TYPE); [EOL] } <line_num>: 680,692
public boolean canPropertyBeDefined(JSType type, String propertyName) { [EOL]     if (typesIndexedByProperty.containsKey(propertyName)) { [EOL]         for (JSType alt : typesIndexedByProperty.get(propertyName).getAlternates()) { [EOL]             JSType greatestSubtype = alt.getGreatestSubtype(type); [EOL]             if (!greatestSubtype.isEmptyType()) { [EOL]                 RecordType maybeRecordType = greatestSubtype.toMaybeRecordType(); [EOL]                 if (maybeRecordType != null && maybeRecordType.isSynthetic()) { [EOL]                     continue; [EOL]                 } [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 697,715
public Iterable<JSType> getTypesWithProperty(String propertyName) { [EOL]     if (typesIndexedByProperty.containsKey(propertyName)) { [EOL]         return typesIndexedByProperty.get(propertyName).getAlternates(); [EOL]     } else { [EOL]         return ImmutableList.of(); [EOL]     } [EOL] } <line_num>: 725,731
public Iterable<ObjectType> getEachReferenceTypeWithProperty(String propertyName) { [EOL]     if (eachRefTypeIndexedByProperty.containsKey(propertyName)) { [EOL]         return eachRefTypeIndexedByProperty.get(propertyName).values(); [EOL]     } else { [EOL]         return ImmutableList.of(); [EOL]     } [EOL] } <line_num>: 743,750
ObjectType findCommonSuperObject(ObjectType a, ObjectType b) { [EOL]     List<ObjectType> stackA = getSuperStack(a); [EOL]     List<ObjectType> stackB = getSuperStack(b); [EOL]     ObjectType result = getNativeObjectType(JSTypeNative.OBJECT_TYPE); [EOL]     while (!stackA.isEmpty() && !stackB.isEmpty()) { [EOL]         ObjectType currentA = stackA.remove(stackA.size() - 1); [EOL]         ObjectType currentB = stackB.remove(stackB.size() - 1); [EOL]         if (currentA.isEquivalentTo(currentB)) { [EOL]             result = currentA; [EOL]         } else { [EOL]             return result; [EOL]         } [EOL]     } [EOL]     return result; [EOL] } <line_num>: 755,770
private static List<ObjectType> getSuperStack(ObjectType a) { [EOL]     List<ObjectType> stack = Lists.newArrayListWithExpectedSize(5); [EOL]     for (ObjectType current = a; current != null; current = current.getImplicitPrototype()) { [EOL]         stack.add(current); [EOL]     } [EOL]     return stack; [EOL] } <line_num>: 772,780
public void incrementGeneration() { [EOL]     for (NamedType type : resolvedNamedTypes.values()) { [EOL]         type.clearResolved(); [EOL]     } [EOL]     unresolvedNamedTypes.putAll(resolvedNamedTypes); [EOL]     resolvedNamedTypes.clear(); [EOL] } <line_num>: 787,793
boolean isLastGeneration() { [EOL]     return lastGeneration; [EOL] } <line_num>: 795,797
public void setLastGeneration(boolean lastGeneration) { [EOL]     this.lastGeneration = lastGeneration; [EOL] } <line_num>: 803,805
void registerTypeImplementingInterface(FunctionType type, ObjectType interfaceInstance) { [EOL]     interfaceToImplementors.put(interfaceInstance.getReferenceName(), type); [EOL] } <line_num>: 813,816
public Collection<FunctionType> getDirectImplementors(ObjectType interfaceInstance) { [EOL]     return interfaceToImplementors.get(interfaceInstance.getReferenceName()); [EOL] } <line_num>: 824,827
public boolean declareType(String name, JSType t) { [EOL]     if (namesToTypes.containsKey(name)) { [EOL]         return false; [EOL]     } [EOL]     register(t, name); [EOL]     return true; [EOL] } <line_num>: 837,843
public void overwriteDeclaredType(String name, JSType t) { [EOL]     Preconditions.checkState(namesToTypes.containsKey(name)); [EOL]     register(t, name); [EOL] } <line_num>: 849,852
public void forwardDeclareType(String name) { [EOL]     forwardDeclaredTypes.add(name); [EOL] } <line_num>: 858,860
public boolean isForwardDeclaredType(String name) { [EOL]     return forwardDeclaredTypes.contains(name); [EOL] } <line_num>: 865,867
public boolean hasNamespace(String name) { [EOL]     return namespaces.contains(name); [EOL] } <line_num>: 870,872
public JSType getType(String jsTypeName) { [EOL]     TemplateType templateType = templateTypes.get(jsTypeName); [EOL]     if (templateType != null) { [EOL]         return templateType; [EOL]     } [EOL]     return namesToTypes.get(jsTypeName); [EOL] } <line_num>: 880,888
public JSType getNativeType(JSTypeNative typeId) { [EOL]     return nativeTypes[typeId.ordinal()]; [EOL] } <line_num>: 890,892
public ObjectType getNativeObjectType(JSTypeNative typeId) { [EOL]     return (ObjectType) getNativeType(typeId); [EOL] } <line_num>: 894,896
public FunctionType getNativeFunctionType(JSTypeNative typeId) { [EOL]     return (FunctionType) getNativeType(typeId); [EOL] } <line_num>: 898,900
public JSType getType(StaticScope<JSType> scope, String jsTypeName, String sourceName, int lineno, int charno) { [EOL]     JSType type = getType(jsTypeName); [EOL]     if (type == null) { [EOL]         NamedType namedType = new NamedType(this, jsTypeName, sourceName, lineno, charno); [EOL]         unresolvedNamedTypes.put(scope, namedType); [EOL]         type = namedType; [EOL]     } [EOL]     return type; [EOL] } <line_num>: 914,926
public void clearNamedTypes() { [EOL]     resolvedNamedTypes.clear(); [EOL]     unresolvedNamedTypes.clear(); [EOL] } <line_num>: 933,936
public void resolveTypesInScope(StaticScope<JSType> scope) { [EOL]     for (NamedType type : unresolvedNamedTypes.get(scope)) { [EOL]         type.resolve(reporter, scope); [EOL]     } [EOL]     resolvedNamedTypes.putAll(scope, unresolvedNamedTypes.removeAll(scope)); [EOL]     if (scope != null && scope.getParentScope() == null) { [EOL]         PrototypeObjectType globalThis = (PrototypeObjectType) getNativeType(JSTypeNative.GLOBAL_THIS); [EOL]         JSType windowType = getType("Window"); [EOL]         if (globalThis.isUnknownType()) { [EOL]             ObjectType windowObjType = ObjectType.cast(windowType); [EOL]             if (windowObjType != null) { [EOL]                 globalThis.setImplicitPrototype(windowObjType); [EOL]             } else { [EOL]                 globalThis.setImplicitPrototype(getNativeObjectType(JSTypeNative.OBJECT_TYPE)); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 941,965
public JSType createOptionalType(JSType type) { [EOL]     if (type instanceof UnknownType || type.isAllType()) { [EOL]         return type; [EOL]     } else { [EOL]         return createUnionType(type, getNativeType(JSTypeNative.VOID_TYPE)); [EOL]     } [EOL] } <line_num>: 971,977
public JSType createDefaultObjectUnion(JSType type) { [EOL]     if (type.isTemplateType()) { [EOL]         return type; [EOL]     } else { [EOL]         return shouldTolerateUndefinedValues() ? createOptionalNullableType(type) : createNullableType(type); [EOL]     } [EOL] } <line_num>: 983,993
public JSType createNullableType(JSType type) { [EOL]     return createUnionType(type, getNativeType(JSTypeNative.NULL_TYPE)); [EOL] } <line_num>: 999,1001
public JSType createOptionalNullableType(JSType type) { [EOL]     return createUnionType(type, getNativeType(JSTypeNative.VOID_TYPE), getNativeType(JSTypeNative.NULL_TYPE)); [EOL] } <line_num>: 1007,1010
public JSType createUnionType(JSType... variants) { [EOL]     UnionTypeBuilder builder = new UnionTypeBuilder(this); [EOL]     for (JSType type : variants) { [EOL]         builder.addAlternate(type); [EOL]     } [EOL]     return builder.build(); [EOL] } <line_num>: 1015,1021
public JSType createUnionType(JSTypeNative... variants) { [EOL]     UnionTypeBuilder builder = new UnionTypeBuilder(this); [EOL]     for (JSTypeNative typeId : variants) { [EOL]         builder.addAlternate(getNativeType(typeId)); [EOL]     } [EOL]     return builder.build(); [EOL] } <line_num>: 1027,1033
public EnumType createEnumType(String name, Node source, JSType elementsType) { [EOL]     return new EnumType(this, name, source, elementsType); [EOL] } <line_num>: 1038,1041
ArrowType createArrowType(Node parametersNode, JSType returnType) { [EOL]     return new ArrowType(this, parametersNode, returnType); [EOL] } <line_num>: 1051,1053
ArrowType createArrowType(Node parametersNode) { [EOL]     return new ArrowType(this, parametersNode, null); [EOL] } <line_num>: 1061,1063
public FunctionType createFunctionType(JSType returnType, JSType... parameterTypes) { [EOL]     return createFunctionType(returnType, createParameters(parameterTypes)); [EOL] } <line_num>: 1071,1074
public FunctionType createFunctionTypeWithVarArgs(JSType returnType, List<JSType> parameterTypes) { [EOL]     return createFunctionType(returnType, createParametersWithVarArgs(parameterTypes)); [EOL] } <line_num>: 1083,1087
public FunctionType createFunctionType(JSType returnType, List<JSType> parameterTypes) { [EOL]     return createFunctionType(returnType, createParameters(parameterTypes)); [EOL] } <line_num>: 1095,1098
public FunctionType createFunctionTypeWithVarArgs(JSType returnType, JSType... parameterTypes) { [EOL]     return createFunctionType(returnType, createParametersWithVarArgs(parameterTypes)); [EOL] } <line_num>: 1107,1111
private FunctionType createNativeFunctionTypeWithVarArgs(JSType returnType, JSType... parameterTypes) { [EOL]     return createNativeFunctionType(returnType, createParametersWithVarArgs(parameterTypes)); [EOL] } <line_num>: 1120,1124
public FunctionType createConstructorType(JSType returnType, JSType... parameterTypes) { [EOL]     return createConstructorType(null, null, createParameters(parameterTypes), returnType, null); [EOL] } <line_num>: 1132,1136
private FunctionType createConstructorTypeWithVarArgs(JSType returnType, JSType... parameterTypes) { [EOL]     return createConstructorType(null, null, createParametersWithVarArgs(parameterTypes), returnType, null); [EOL] } <line_num>: 1145,1150
public JSType createFunctionType(ObjectType instanceType, JSType returnType, List<JSType> parameterTypes) { [EOL]     return new FunctionBuilder(this).withParamsNode(createParameters(parameterTypes)).withReturnType(returnType).withTypeOfThis(instanceType).build(); [EOL] } <line_num>: 1159,1166
public JSType createFunctionTypeWithVarArgs(ObjectType instanceType, JSType returnType, List<JSType> parameterTypes) { [EOL]     return new FunctionBuilder(this).withParamsNode(createParametersWithVarArgs(parameterTypes)).withReturnType(returnType).withTypeOfThis(instanceType).build(); [EOL] } <line_num>: 1177,1184
public Node createParameters(List<JSType> parameterTypes) { [EOL]     return createParameters(parameterTypes.toArray(new JSType[parameterTypes.size()])); [EOL] } <line_num>: 1192,1195
public Node createParametersWithVarArgs(List<JSType> parameterTypes) { [EOL]     return createParametersWithVarArgs(parameterTypes.toArray(new JSType[parameterTypes.size()])); [EOL] } <line_num>: 1205,1208
public Node createParameters(JSType... parameterTypes) { [EOL]     return createParameters(false, parameterTypes); [EOL] } <line_num>: 1216,1218
public Node createParametersWithVarArgs(JSType... parameterTypes) { [EOL]     return createParameters(true, parameterTypes); [EOL] } <line_num>: 1228,1230
public Node createOptionalParameters(JSType... parameterTypes) { [EOL]     FunctionParamBuilder builder = new FunctionParamBuilder(this); [EOL]     builder.addOptionalParams(parameterTypes); [EOL]     return builder.build(); [EOL] } <line_num>: 1236,1240
private Node createParameters(boolean lastVarArgs, JSType... parameterTypes) { [EOL]     FunctionParamBuilder builder = new FunctionParamBuilder(this); [EOL]     int max = parameterTypes.length - 1; [EOL]     for (int i = 0; i <= max; i++) { [EOL]         if (lastVarArgs && i == max) { [EOL]             builder.addVarArgs(parameterTypes[i]); [EOL]         } else { [EOL]             builder.addRequiredParams(parameterTypes[i]); [EOL]         } [EOL]     } [EOL]     return builder.build(); [EOL] } <line_num>: 1252,1263
public FunctionType createFunctionType(JSType returnType, boolean lastVarArgs, JSType... parameterTypes) { [EOL]     if (lastVarArgs) { [EOL]         return createFunctionTypeWithVarArgs(returnType, parameterTypes); [EOL]     } else { [EOL]         return createFunctionType(returnType, parameterTypes); [EOL]     } [EOL] } <line_num>: 1272,1279
public FunctionType createFunctionTypeWithNewReturnType(FunctionType existingFunctionType, JSType returnType) { [EOL]     return new FunctionBuilder(this).copyFromOtherFunction(existingFunctionType).withReturnType(returnType).build(); [EOL] } <line_num>: 1287,1293
public FunctionType createFunctionTypeWithNewThisType(FunctionType existingFunctionType, ObjectType thisType) { [EOL]     return new FunctionBuilder(this).copyFromOtherFunction(existingFunctionType).withTypeOfThis(thisType).build(); [EOL] } <line_num>: 1301,1307
public FunctionType createFunctionType(JSType returnType, Node parameters) { [EOL]     return new FunctionBuilder(this).withParamsNode(parameters).withReturnType(returnType).build(); [EOL] } <line_num>: 1315,1321
private FunctionType createNativeFunctionType(JSType returnType, Node parameters) { [EOL]     return new FunctionBuilder(this).withParamsNode(parameters).withReturnType(returnType).forNativeType().build(); [EOL] } <line_num>: 1323,1330
public FunctionType createConstructorType(JSType returnType, boolean lastVarArgs, JSType... parameterTypes) { [EOL]     if (lastVarArgs) { [EOL]         return createConstructorTypeWithVarArgs(returnType, parameterTypes); [EOL]     } else { [EOL]         return createConstructorType(returnType, parameterTypes); [EOL]     } [EOL] } <line_num>: 1339,1346
public ObjectType createObjectType(ObjectType implicitPrototype) { [EOL]     return createObjectType(null, null, implicitPrototype); [EOL] } <line_num>: 1351,1353
public RecordType createRecordType(Map<String, RecordProperty> properties) { [EOL]     return new RecordType(this, properties); [EOL] } <line_num>: 1358,1360
public ObjectType createObjectType(String name, Node n, ObjectType implicitPrototype) { [EOL]     return new PrototypeObjectType(this, name, implicitPrototype); [EOL] } <line_num>: 1365,1368
public ObjectType createAnonymousObjectType(JSDocInfo info) { [EOL]     PrototypeObjectType type = new PrototypeObjectType(this, null, null); [EOL]     type.setPrettyPrint(true); [EOL]     type.setJSDocInfo(info); [EOL]     return type; [EOL] } <line_num>: 1374,1379
public boolean resetImplicitPrototype(JSType type, ObjectType newImplicitProto) { [EOL]     if (type instanceof PrototypeObjectType) { [EOL]         PrototypeObjectType poType = (PrototypeObjectType) type; [EOL]         poType.clearCachedValues(); [EOL]         poType.setImplicitPrototype(newImplicitProto); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1389,1398
ObjectType createNativeAnonymousObjectType() { [EOL]     PrototypeObjectType type = new PrototypeObjectType(this, null, null, true, null, null); [EOL]     type.setPrettyPrint(true); [EOL]     return type; [EOL] } <line_num>: 1403,1408
public FunctionType createConstructorType(String name, Node source, Node parameters, JSType returnType, ImmutableList<String> templateKeys) { [EOL]     return new FunctionType(this, name, source, createArrowType(parameters, returnType), null, templateKeys, true, false); [EOL] } <line_num>: 1422,1427
public FunctionType createInterfaceType(String name, Node source) { [EOL]     return FunctionType.forInterface(this, name, source); [EOL] } <line_num>: 1435,1437
public ParameterizedType createParameterizedType(ObjectType objectType, JSType parameterType) { [EOL]     return new ParameterizedType(this, objectType, parameterType); [EOL] } <line_num>: 1442,1445
public JSType createTemplatizedType(JSType baseType, ImmutableList<JSType> templatizedTypes) { [EOL]     if (baseType instanceof InstanceObjectType) { [EOL]         ObjectType baseObjType = baseType.toObjectType(); [EOL]         return new InstanceObjectType(this, baseObjType.getConstructor(), baseObjType.isNativeObjectType(), templatizedTypes); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Only instance object types can be templatized"); [EOL]     } [EOL] } <line_num>: 1453,1466
@VisibleForTesting [EOL] public JSType createNamedType(String reference, String sourceName, int lineno, int charno) { [EOL]     return new NamedType(this, reference, sourceName, lineno, charno); [EOL] } <line_num>: 1471,1475
public void identifyNonNullableName(String name) { [EOL]     Preconditions.checkNotNull(name); [EOL]     nonNullableTypeNames.add(name); [EOL] } <line_num>: 1480,1483
public JSType createFromTypeNodes(Node n, String sourceName, StaticScope<JSType> scope) { [EOL]     if (resolveMode == ResolveMode.LAZY_EXPRESSIONS) { [EOL]         boolean hasNames = hasTypeName(n); [EOL]         if (hasNames) { [EOL]             return new UnresolvedTypeExpression(this, n, sourceName); [EOL]         } [EOL]     } [EOL]     return createFromTypeNodesInternal(n, sourceName, scope); [EOL] } <line_num>: 1491,1502
private boolean hasTypeName(Node n) { [EOL]     if (n.getType() == Token.STRING) { [EOL]         return true; [EOL]     } [EOL]     for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { [EOL]         if (hasTypeName(child)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1504,1517
private JSType createFromTypeNodesInternal(Node n, String sourceName, StaticScope<JSType> scope) { [EOL]     switch(n.getType()) { [EOL]         case Token.LC: [EOL]             return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope); [EOL]         case Token.BANG: [EOL]             return createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope).restrictByNotNullOrUndefined(); [EOL]         case Token.QMARK: [EOL]             Node firstChild = n.getFirstChild(); [EOL]             if (firstChild == null) { [EOL]                 return getNativeType(UNKNOWN_TYPE); [EOL]             } [EOL]             return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild, sourceName, scope)); [EOL]         case Token.EQUALS: [EOL]             return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope)); [EOL]         case Token.ELLIPSIS: [EOL]             return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope)); [EOL]         case Token.STAR: [EOL]             return getNativeType(ALL_TYPE); [EOL]         case Token.LB: [EOL]             return getNativeType(ARRAY_TYPE); [EOL]         case Token.PIPE: [EOL]             UnionTypeBuilder builder = new UnionTypeBuilder(this); [EOL]             for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { [EOL]                 builder.addAlternate(createFromTypeNodesInternal(child, sourceName, scope)); [EOL]             } [EOL]             return builder.build(); [EOL]         case Token.EMPTY: [EOL]             return getNativeType(UNKNOWN_TYPE); [EOL]         case Token.VOID: [EOL]             return getNativeType(VOID_TYPE); [EOL]         case Token.STRING: [EOL]             JSType namedType = getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno()); [EOL]             if (resolveMode != ResolveMode.LAZY_NAMES) { [EOL]                 namedType = namedType.resolveInternal(reporter, scope); [EOL]             } [EOL]             if ((namedType instanceof ObjectType) && !(nonNullableTypeNames.contains(n.getString()))) { [EOL]                 Node typeList = n.getFirstChild(); [EOL]                 if (typeList != null && ("Array".equals(n.getString()) || "Object".equals(n.getString()))) { [EOL]                     JSType parameterType = createFromTypeNodesInternal(typeList.getLastChild(), sourceName, scope); [EOL]                     namedType = new ParameterizedType(this, (ObjectType) namedType, parameterType); [EOL]                     if (typeList.hasMoreThanOneChild()) { [EOL]                         JSType indexType = createFromTypeNodesInternal(typeList.getFirstChild(), sourceName, scope); [EOL]                         namedType = new IndexedType(this, (ObjectType) namedType, indexType); [EOL]                     } [EOL]                 } [EOL]                 return createDefaultObjectUnion(namedType); [EOL]             } else { [EOL]                 return namedType; [EOL]             } [EOL]         case Token.FUNCTION: [EOL]             ObjectType thisType = null; [EOL]             boolean isConstructor = false; [EOL]             Node current = n.getFirstChild(); [EOL]             if (current.getType() == Token.THIS || current.getType() == Token.NEW) { [EOL]                 Node contextNode = current.getFirstChild(); [EOL]                 thisType = ObjectType.cast(createFromTypeNodesInternal(contextNode, sourceName, scope).restrictByNotNullOrUndefined()); [EOL]                 if (thisType == null) { [EOL]                     reporter.warning(ScriptRuntime.getMessage0(current.getType() == Token.THIS ? "msg.jsdoc.function.thisnotobject" : "msg.jsdoc.function.newnotobject"), sourceName, contextNode.getLineno(), contextNode.getCharno()); [EOL]                 } [EOL]                 isConstructor = current.getType() == Token.NEW; [EOL]                 current = current.getNext(); [EOL]             } [EOL]             FunctionParamBuilder paramBuilder = new FunctionParamBuilder(this); [EOL]             if (current.getType() == Token.PARAM_LIST) { [EOL]                 Node args = current.getFirstChild(); [EOL]                 for (Node arg = current.getFirstChild(); arg != null; arg = arg.getNext()) { [EOL]                     if (arg.getType() == Token.ELLIPSIS) { [EOL]                         if (arg.getChildCount() == 0) { [EOL]                             paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE)); [EOL]                         } else { [EOL]                             paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(), sourceName, scope)); [EOL]                         } [EOL]                     } else { [EOL]                         JSType type = createFromTypeNodesInternal(arg, sourceName, scope); [EOL]                         if (arg.getType() == Token.EQUALS) { [EOL]                             boolean addSuccess = paramBuilder.addOptionalParams(type); [EOL]                             if (!addSuccess) { [EOL]                                 reporter.warning(ScriptRuntime.getMessage0("msg.jsdoc.function.varargs"), sourceName, arg.getLineno(), arg.getCharno()); [EOL]                             } [EOL]                         } else { [EOL]                             paramBuilder.addRequiredParams(type); [EOL]                         } [EOL]                     } [EOL]                 } [EOL]                 current = current.getNext(); [EOL]             } [EOL]             JSType returnType = createFromTypeNodesInternal(current, sourceName, scope); [EOL]             return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).setIsConstructor(isConstructor).build(); [EOL]     } [EOL]     throw new IllegalStateException("Unexpected node in type expression: " + n.toString()); [EOL] } <line_num>: 1520,1674
private JSType createRecordTypeFromNodes(Node n, String sourceName, StaticScope<JSType> scope) { [EOL]     RecordTypeBuilder builder = new RecordTypeBuilder(this); [EOL]     for (Node fieldTypeNode = n.getFirstChild(); fieldTypeNode != null; fieldTypeNode = fieldTypeNode.getNext()) { [EOL]         Node fieldNameNode = fieldTypeNode; [EOL]         boolean hasType = false; [EOL]         if (fieldTypeNode.getType() == Token.COLON) { [EOL]             fieldNameNode = fieldTypeNode.getFirstChild(); [EOL]             hasType = true; [EOL]         } [EOL]         String fieldName = fieldNameNode.getString(); [EOL]         if (fieldName.startsWith("'") || fieldName.startsWith("\"")) { [EOL]             fieldName = fieldName.substring(1, fieldName.length() - 1); [EOL]         } [EOL]         JSType fieldType = null; [EOL]         if (hasType) { [EOL]             fieldType = createFromTypeNodesInternal(fieldTypeNode.getLastChild(), sourceName, scope); [EOL]         } else { [EOL]             fieldType = getNativeType(JSTypeNative.UNKNOWN_TYPE); [EOL]         } [EOL]         if (builder.addProperty(fieldName, fieldType, fieldNameNode) == null) { [EOL]             reporter.warning("Duplicate record field " + fieldName, sourceName, n.getLineno(), fieldNameNode.getCharno()); [EOL]         } [EOL]     } [EOL]     return builder.build(); [EOL] } <line_num>: 1682,1733
public void setTemplateTypeNames(List<String> names) { [EOL]     Preconditions.checkNotNull(names); [EOL]     for (String name : names) { [EOL]         templateTypes.put(name, new TemplateType(this, name)); [EOL]     } [EOL] } <line_num>: 1738,1743
public void clearTemplateTypeNames() { [EOL]     templateTypes.clear(); [EOL] } <line_num>: 1748,1750
