NamedType(JSTypeRegistry registry, String reference, String sourceName, int lineno, int charno) { [EOL]     super(registry, registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE)); [EOL]     Preconditions.checkNotNull(reference); [EOL]     this.reference = reference; [EOL]     this.sourceName = sourceName; [EOL]     this.lineno = lineno; [EOL]     this.charno = charno; [EOL] } <line_num>: 103,112
private PropertyContinuation(String propertyName, JSType type, boolean inferred, Node propertyNode) { [EOL]     this.propertyName = propertyName; [EOL]     this.type = type; [EOL]     this.inferred = inferred; [EOL]     this.propertyNode = propertyNode; [EOL] } <line_num>: 392,401
@Override [EOL] boolean defineProperty(String propertyName, JSType type, boolean inferred, Node propertyNode) { [EOL]     if (!isResolved()) { [EOL]         if (propertyContinuations == null) { [EOL]             propertyContinuations = Lists.newArrayList(); [EOL]         } [EOL]         propertyContinuations.add(new PropertyContinuation(propertyName, type, inferred, propertyNode)); [EOL]         return true; [EOL]     } else { [EOL]         return super.defineProperty(propertyName, type, inferred, propertyNode); [EOL]     } [EOL] } <line_num>: 114,131
private void finishPropertyContinuations() { [EOL]     ObjectType referencedObjType = getReferencedObjTypeInternal(); [EOL]     if (referencedObjType != null && !referencedObjType.isUnknownType()) { [EOL]         if (propertyContinuations != null) { [EOL]             for (PropertyContinuation c : propertyContinuations) { [EOL]                 c.commit(this); [EOL]             } [EOL]         } [EOL]     } [EOL]     propertyContinuations = null; [EOL] } <line_num>: 133,143
public JSType getReferencedType() { [EOL]     return getReferencedTypeInternal(); [EOL] } <line_num>: 146,148
@Override [EOL] public String getReferenceName() { [EOL]     return reference; [EOL] } <line_num>: 150,153
@Override [EOL] String toStringHelper(boolean forAnnotations) { [EOL]     return reference; [EOL] } <line_num>: 155,158
@Override [EOL] public boolean hasReferenceName() { [EOL]     return true; [EOL] } <line_num>: 160,163
@Override [EOL] boolean isNamedType() { [EOL]     return true; [EOL] } <line_num>: 165,168
@Override [EOL] public boolean isNominalType() { [EOL]     return true; [EOL] } <line_num>: 170,173
@Override [EOL] public int hashCode() { [EOL]     return reference.hashCode(); [EOL] } <line_num>: 175,178
@Override [EOL] JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) { [EOL]     boolean resolved = resolveViaRegistry(t, enclosing); [EOL]     if (detectInheritanceCycle()) { [EOL]         handleTypeCycle(t); [EOL]     } [EOL]     if (resolved) { [EOL]         super.resolveInternal(t, enclosing); [EOL]         finishPropertyContinuations(); [EOL]         return registry.isLastGeneration() ? getReferencedType() : this; [EOL]     } [EOL]     resolveViaProperties(t, enclosing); [EOL]     if (detectInheritanceCycle()) { [EOL]         handleTypeCycle(t); [EOL]     } [EOL]     super.resolveInternal(t, enclosing); [EOL]     if (isResolved()) { [EOL]         finishPropertyContinuations(); [EOL]     } [EOL]     return registry.isLastGeneration() ? getReferencedType() : this; [EOL] } <line_num>: 183,212
private boolean resolveViaRegistry(ErrorReporter t, StaticScope<JSType> enclosing) { [EOL]     JSType type = registry.getType(reference); [EOL]     if (type != null) { [EOL]         setReferencedAndResolvedType(type, t, enclosing); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 218,226
private void resolveViaProperties(ErrorReporter t, StaticScope<JSType> enclosing) { [EOL]     JSType value = lookupViaProperties(t, enclosing); [EOL]     if (value != null && value.isFunctionType() && (value.isConstructor() || value.isInterface())) { [EOL]         FunctionType functionType = value.toMaybeFunctionType(); [EOL]         setReferencedAndResolvedType(functionType.getInstanceType(), t, enclosing); [EOL]     } else if (value != null && value.isNoObjectType()) { [EOL]         setReferencedAndResolvedType(registry.getNativeFunctionType(JSTypeNative.NO_OBJECT_TYPE).getInstanceType(), t, enclosing); [EOL]     } else if (value instanceof EnumType) { [EOL]         setReferencedAndResolvedType(((EnumType) value).getElementsType(), t, enclosing); [EOL]     } else { [EOL]         handleUnresolvedType(t, value == null || value.isUnknownType()); [EOL]     } [EOL] } <line_num>: 233,258
private JSType lookupViaProperties(ErrorReporter t, StaticScope<JSType> enclosing) { [EOL]     String[] componentNames = reference.split("\\.", -1); [EOL]     if (componentNames[0].length() == 0) { [EOL]         return null; [EOL]     } [EOL]     StaticSlot<JSType> slot = enclosing.getSlot(componentNames[0]); [EOL]     if (slot == null) { [EOL]         return null; [EOL]     } [EOL]     JSType slotType = slot.getType(); [EOL]     if (slotType == null || slotType.isAllType() || slotType.isNoType()) { [EOL]         return null; [EOL]     } [EOL]     JSType value = getTypedefType(t, slot, componentNames[0]); [EOL]     if (value == null) { [EOL]         return null; [EOL]     } [EOL]     for (int i = 1; i < componentNames.length; i++) { [EOL]         ObjectType parentClass = ObjectType.cast(value); [EOL]         if (parentClass == null) { [EOL]             return null; [EOL]         } [EOL]         if (componentNames[i].length() == 0) { [EOL]             return null; [EOL]         } [EOL]         value = parentClass.getPropertyType(componentNames[i]); [EOL]     } [EOL]     return value; [EOL] } <line_num>: 266,300
private void setReferencedAndResolvedType(JSType type, ErrorReporter t, StaticScope<JSType> enclosing) { [EOL]     if (validator != null) { [EOL]         validator.apply(type); [EOL]     } [EOL]     setReferencedType(type); [EOL]     checkEnumElementCycle(t); [EOL]     checkProtoCycle(t); [EOL]     setResolvedTypeInternal(getReferencedType()); [EOL] } <line_num>: 302,311
private void handleTypeCycle(ErrorReporter t) { [EOL]     setReferencedType(registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE)); [EOL]     t.warning("Cycle detected in inheritance chain of type " + reference, sourceName, lineno, charno); [EOL]     setResolvedTypeInternal(getReferencedType()); [EOL] } <line_num>: 313,319
private void checkEnumElementCycle(ErrorReporter t) { [EOL]     JSType referencedType = getReferencedType(); [EOL]     if (referencedType instanceof EnumElementType && ((EnumElementType) referencedType).getPrimitiveType() == this) { [EOL]         handleTypeCycle(t); [EOL]     } [EOL] } <line_num>: 321,327
private void checkProtoCycle(ErrorReporter t) { [EOL]     JSType referencedType = getReferencedType(); [EOL]     if (referencedType == this) { [EOL]         handleTypeCycle(t); [EOL]     } [EOL] } <line_num>: 329,334
private void handleUnresolvedType(ErrorReporter t, boolean ignoreForwardReferencedTypes) { [EOL]     if (registry.isLastGeneration()) { [EOL]         boolean isForwardDeclared = ignoreForwardReferencedTypes && registry.isForwardDeclaredType(reference); [EOL]         if (!isForwardDeclared && registry.isLastGeneration()) { [EOL]             t.warning("Bad type annotation. Unknown type " + reference, sourceName, lineno, charno); [EOL]         } else { [EOL]             setReferencedType(registry.getNativeObjectType(JSTypeNative.NO_RESOLVED_TYPE)); [EOL]             if (registry.isLastGeneration() && validator != null) { [EOL]                 validator.apply(getReferencedType()); [EOL]             } [EOL]         } [EOL]         setResolvedTypeInternal(getReferencedType()); [EOL]     } else { [EOL]         setResolvedTypeInternal(this); [EOL]     } [EOL] } <line_num>: 338,361
JSType getTypedefType(ErrorReporter t, StaticSlot<JSType> slot, String name) { [EOL]     JSType type = slot.getType(); [EOL]     if (type != null) { [EOL]         return type; [EOL]     } [EOL]     handleUnresolvedType(t, true); [EOL]     return null; [EOL] } <line_num>: 363,370
@Override [EOL] public boolean setValidator(Predicate<JSType> validator) { [EOL]     if (this.isResolved()) { [EOL]         return super.setValidator(validator); [EOL]     } else { [EOL]         this.validator = validator; [EOL]         return true; [EOL]     } [EOL] } <line_num>: 372,383
void commit(ObjectType target) { [EOL]     target.defineProperty(propertyName, type, inferred, propertyNode); [EOL] } <line_num>: 403,406
