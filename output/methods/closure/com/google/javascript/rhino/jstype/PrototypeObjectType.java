PrototypeObjectType(JSTypeRegistry registry, String className, ObjectType implicitPrototype) { [EOL]     this(registry, className, implicitPrototype, false, null, null); [EOL] } <line_num>: 103,106
PrototypeObjectType(JSTypeRegistry registry, String className, ObjectType implicitPrototype, boolean nativeType, ImmutableList<String> templateKeys, ImmutableList<JSType> templatizedTypes) { [EOL]     super(registry, templateKeys, templatizedTypes); [EOL]     this.properties = new PropertyMap(); [EOL]     this.properties.setParentSource(this); [EOL]     this.className = className; [EOL]     this.nativeType = nativeType; [EOL]     if (nativeType || implicitPrototype != null) { [EOL]         setImplicitPrototype(implicitPrototype); [EOL]     } else { [EOL]         setImplicitPrototype(registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE)); [EOL]     } [EOL] } <line_num>: 112,128
@Override [EOL] PropertyMap getPropertyMap() { [EOL]     return properties; [EOL] } <line_num>: 130,133
@Override [EOL] boolean defineProperty(String name, JSType type, boolean inferred, Node propertyNode) { [EOL]     if (hasOwnDeclaredProperty(name)) { [EOL]         return false; [EOL]     } [EOL]     Property newProp = new Property(name, type, inferred, propertyNode); [EOL]     properties.putProperty(name, newProp); [EOL]     return true; [EOL] } <line_num>: 135,145
@Override [EOL] public boolean removeProperty(String name) { [EOL]     return properties.removeProperty(name); [EOL] } <line_num>: 147,150
@Override [EOL] public void setPropertyJSDocInfo(String propertyName, JSDocInfo info) { [EOL]     if (info != null) { [EOL]         if (properties.getOwnProperty(propertyName) == null) { [EOL]             defineInferredProperty(propertyName, getPropertyType(propertyName), null); [EOL]         } [EOL]         Property property = properties.getOwnProperty(propertyName); [EOL]         if (property != null) { [EOL]             property.setJSDocInfo(info); [EOL]         } [EOL]     } [EOL] } <line_num>: 152,170
@Override [EOL] public boolean matchesNumberContext() { [EOL]     return isNumberObjectType() || isDateType() || isBooleanObjectType() || isStringObjectType() || hasOverridenNativeProperty("valueOf"); [EOL] } <line_num>: 172,176
@Override [EOL] public boolean matchesStringContext() { [EOL]     return isTheObjectType() || isStringObjectType() || isDateType() || isRegexpType() || isArrayType() || isNumberObjectType() || isBooleanObjectType() || hasOverridenNativeProperty("toString"); [EOL] } <line_num>: 178,183
private boolean hasOverridenNativeProperty(String propertyName) { [EOL]     if (isNativeObjectType()) { [EOL]         return false; [EOL]     } [EOL]     JSType propertyType = getPropertyType(propertyName); [EOL]     ObjectType nativeType = isFunctionType() ? registry.getNativeObjectType(JSTypeNative.FUNCTION_PROTOTYPE) : registry.getNativeObjectType(JSTypeNative.OBJECT_PROTOTYPE); [EOL]     JSType nativePropertyType = nativeType.getPropertyType(propertyName); [EOL]     return propertyType != nativePropertyType; [EOL] } <line_num>: 189,201
@Override [EOL] public JSType unboxesTo() { [EOL]     if (isStringObjectType()) { [EOL]         return getNativeType(JSTypeNative.STRING_TYPE); [EOL]     } else if (isBooleanObjectType()) { [EOL]         return getNativeType(JSTypeNative.BOOLEAN_TYPE); [EOL]     } else if (isNumberObjectType()) { [EOL]         return getNativeType(JSTypeNative.NUMBER_TYPE); [EOL]     } else { [EOL]         return super.unboxesTo(); [EOL]     } [EOL] } <line_num>: 203,214
@Override [EOL] public boolean matchesObjectContext() { [EOL]     return true; [EOL] } <line_num>: 216,219
@Override [EOL] public boolean canBeCalled() { [EOL]     return isRegexpType(); [EOL] } <line_num>: 221,224
@Override [EOL] String toStringHelper(boolean forAnnotations) { [EOL]     if (hasReferenceName()) { [EOL]         return getReferenceName(); [EOL]     } else if (prettyPrint) { [EOL]         prettyPrint = false; [EOL]         Set<String> propertyNames = Sets.newTreeSet(); [EOL]         for (ObjectType current = this; current != null && !current.isNativeObjectType() && propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES; current = current.getImplicitPrototype()) { [EOL]             propertyNames.addAll(current.getOwnPropertyNames()); [EOL]         } [EOL]         StringBuilder sb = new StringBuilder(); [EOL]         sb.append("{"); [EOL]         int i = 0; [EOL]         for (String property : propertyNames) { [EOL]             if (i > 0) { [EOL]                 sb.append(", "); [EOL]             } [EOL]             sb.append(property); [EOL]             sb.append(": "); [EOL]             sb.append(getPropertyType(property).toStringHelper(forAnnotations)); [EOL]             ++i; [EOL]             if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) { [EOL]                 sb.append(", ..."); [EOL]                 break; [EOL]             } [EOL]         } [EOL]         sb.append("}"); [EOL]         prettyPrint = true; [EOL]         return sb.toString(); [EOL]     } else { [EOL]         return forAnnotations ? "?" : "{...}"; [EOL]     } [EOL] } <line_num>: 226,270
void setPrettyPrint(boolean prettyPrint) { [EOL]     this.prettyPrint = prettyPrint; [EOL] } <line_num>: 272,274
boolean isPrettyPrint() { [EOL]     return prettyPrint; [EOL] } <line_num>: 276,278
@Override [EOL] public FunctionType getConstructor() { [EOL]     return null; [EOL] } <line_num>: 280,283
@Override [EOL] public ObjectType getImplicitPrototype() { [EOL]     return implicitPrototypeFallback; [EOL] } <line_num>: 285,288
final void setImplicitPrototype(ObjectType implicitPrototype) { [EOL]     checkState(!hasCachedValues()); [EOL]     this.implicitPrototypeFallback = implicitPrototype; [EOL] } <line_num>: 296,299
@Override [EOL] public String getReferenceName() { [EOL]     if (className != null) { [EOL]         return className; [EOL]     } else if (ownerFunction != null) { [EOL]         return ownerFunction.getReferenceName() + ".prototype"; [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] } <line_num>: 301,310
@Override [EOL] public boolean hasReferenceName() { [EOL]     return className != null || ownerFunction != null; [EOL] } <line_num>: 312,315
@Override [EOL] public boolean isSubtype(JSType that) { [EOL]     if (JSType.isSubtypeHelper(this, that)) { [EOL]         return true; [EOL]     } [EOL]     if (that.isUnionType()) { [EOL]         return false; [EOL]     } [EOL]     if (that.isRecordType()) { [EOL]         return RecordType.isSubtype(this, that.toMaybeRecordType()); [EOL]     } [EOL]     ObjectType thatObj = that.toObjectType(); [EOL]     FunctionType thatCtor = thatObj == null ? null : thatObj.getConstructor(); [EOL]     if (getConstructor() != null && getConstructor().isInterface()) { [EOL]         for (ObjectType thisInterface : getCtorExtendedInterfaces()) { [EOL]             if (thisInterface.isSubtype(that)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } else if (thatCtor != null && thatCtor.isInterface()) { [EOL]         Iterable<ObjectType> thisInterfaces = getCtorImplementedInterfaces(); [EOL]         for (ObjectType thisInterface : thisInterfaces) { [EOL]             if (thisInterface.isSubtype(that)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (isUnknownType() || implicitPrototypeChainIsUnknown()) { [EOL]         return true; [EOL]     } [EOL]     return thatObj != null && isImplicitPrototype(thatObj); [EOL] } <line_num>: 317,364
private boolean implicitPrototypeChainIsUnknown() { [EOL]     ObjectType p = getImplicitPrototype(); [EOL]     while (p != null) { [EOL]         if (p.isUnknownType()) { [EOL]             return true; [EOL]         } [EOL]         p = p.getImplicitPrototype(); [EOL]     } [EOL]     return false; [EOL] } <line_num>: 366,375
@Override [EOL] public boolean hasCachedValues() { [EOL]     return super.hasCachedValues(); [EOL] } <line_num>: 377,380
@Override [EOL] public boolean isNativeObjectType() { [EOL]     return nativeType; [EOL] } <line_num>: 383,386
@Override [EOL] void setOwnerFunction(FunctionType type) { [EOL]     Preconditions.checkState(ownerFunction == null || type == null); [EOL]     ownerFunction = type; [EOL] } <line_num>: 388,392
@Override [EOL] public FunctionType getOwnerFunction() { [EOL]     return ownerFunction; [EOL] } <line_num>: 394,397
@Override [EOL] public Iterable<ObjectType> getCtorImplementedInterfaces() { [EOL]     return isFunctionPrototypeType() ? getOwnerFunction().getImplementedInterfaces() : ImmutableList.<ObjectType>of(); [EOL] } <line_num>: 399,404
@Override [EOL] public Iterable<ObjectType> getCtorExtendedInterfaces() { [EOL]     return isFunctionPrototypeType() ? getOwnerFunction().getExtendedInterfaces() : ImmutableList.<ObjectType>of(); [EOL] } <line_num>: 406,411
@Override [EOL] JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { [EOL]     setResolvedTypeInternal(this); [EOL]     ObjectType implicitPrototype = getImplicitPrototype(); [EOL]     if (implicitPrototype != null) { [EOL]         implicitPrototypeFallback = (ObjectType) implicitPrototype.resolve(t, scope); [EOL]     } [EOL]     for (Property prop : properties.values()) { [EOL]         prop.setType(safeResolve(prop.getType(), t, scope)); [EOL]     } [EOL]     return this; [EOL] } <line_num>: 413,426
@Override [EOL] public void matchConstraint(JSType constraint) { [EOL]     if (hasReferenceName()) { [EOL]         return; [EOL]     } [EOL]     if (constraint.isRecordType()) { [EOL]         matchRecordTypeConstraint(constraint.toObjectType()); [EOL]     } else if (constraint.isUnionType()) { [EOL]         for (JSType alt : constraint.toMaybeUnionType().getAlternates()) { [EOL]             if (alt.isRecordType()) { [EOL]                 matchRecordTypeConstraint(alt.toObjectType()); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 428,453
public void matchRecordTypeConstraint(ObjectType constraintObj) { [EOL]     for (String prop : constraintObj.getOwnPropertyNames()) { [EOL]         JSType propType = constraintObj.getPropertyType(prop); [EOL]         if (!isPropertyTypeDeclared(prop)) { [EOL]             JSType typeToInfer = propType; [EOL]             if (!hasProperty(prop)) { [EOL]                 typeToInfer = getNativeType(JSTypeNative.VOID_TYPE).getLeastSupertype(propType); [EOL]             } [EOL]             defineInferredProperty(prop, typeToInfer, null); [EOL]         } [EOL]     } [EOL] } <line_num>: 455,467
