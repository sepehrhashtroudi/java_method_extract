private IR() { [EOL] } <line_num>: 51,51
public static Node empty() { [EOL]     return new Node(Token.EMPTY); [EOL] } <line_num>: 53,55
public static Node function(Node name, Node params, Node body) { [EOL]     Preconditions.checkState(name.isName()); [EOL]     Preconditions.checkState(params.isParamList()); [EOL]     Preconditions.checkState(body.isBlock()); [EOL]     return new Node(Token.FUNCTION, name, params, body); [EOL] } <line_num>: 57,62
public static Node paramList() { [EOL]     return new Node(Token.PARAM_LIST); [EOL] } <line_num>: 64,66
public static Node paramList(Node param) { [EOL]     Preconditions.checkState(param.isName()); [EOL]     return new Node(Token.PARAM_LIST, param); [EOL] } <line_num>: 68,71
public static Node paramList(Node... params) { [EOL]     Node paramList = paramList(); [EOL]     for (Node param : params) { [EOL]         Preconditions.checkState(param.isName()); [EOL]         paramList.addChildToBack(param); [EOL]     } [EOL]     return paramList; [EOL] } <line_num>: 73,80
public static Node paramList(List<Node> params) { [EOL]     Node paramList = paramList(); [EOL]     for (Node param : params) { [EOL]         Preconditions.checkState(param.isName()); [EOL]         paramList.addChildToBack(param); [EOL]     } [EOL]     return paramList; [EOL] } <line_num>: 82,89
public static Node block() { [EOL]     Node block = new Node(Token.BLOCK); [EOL]     return block; [EOL] } <line_num>: 91,94
public static Node block(Node stmt) { [EOL]     Preconditions.checkState(mayBeStatement(stmt)); [EOL]     Node block = new Node(Token.BLOCK, stmt); [EOL]     return block; [EOL] } <line_num>: 96,100
public static Node block(Node... stmts) { [EOL]     Node block = block(); [EOL]     for (Node stmt : stmts) { [EOL]         Preconditions.checkState(mayBeStatement(stmt)); [EOL]         block.addChildToBack(stmt); [EOL]     } [EOL]     return block; [EOL] } <line_num>: 102,109
public static Node block(List<Node> stmts) { [EOL]     Node paramList = block(); [EOL]     for (Node stmt : stmts) { [EOL]         Preconditions.checkState(mayBeStatement(stmt)); [EOL]         paramList.addChildToBack(stmt); [EOL]     } [EOL]     return paramList; [EOL] } <line_num>: 111,118
private static Node blockUnchecked(Node stmt) { [EOL]     return new Node(Token.BLOCK, stmt); [EOL] } <line_num>: 120,122
public static Node script() { [EOL]     Node block = new Node(Token.SCRIPT); [EOL]     return block; [EOL] } <line_num>: 124,128
public static Node script(Node... stmts) { [EOL]     Node block = script(); [EOL]     for (Node stmt : stmts) { [EOL]         Preconditions.checkState(mayBeStatementNoReturn(stmt)); [EOL]         block.addChildToBack(stmt); [EOL]     } [EOL]     return block; [EOL] } <line_num>: 130,137
public static Node script(List<Node> stmts) { [EOL]     Node paramList = script(); [EOL]     for (Node stmt : stmts) { [EOL]         Preconditions.checkState(mayBeStatementNoReturn(stmt)); [EOL]         paramList.addChildToBack(stmt); [EOL]     } [EOL]     return paramList; [EOL] } <line_num>: 139,146
public static Node var(Node name, Node value) { [EOL]     Preconditions.checkState(name.isName() && !name.hasChildren()); [EOL]     Preconditions.checkState(mayBeExpression(value)); [EOL]     name.addChildToFront(value); [EOL]     return var(name); [EOL] } <line_num>: 148,153
public static Node var(Node name) { [EOL]     Preconditions.checkState(name.isName()); [EOL]     return new Node(Token.VAR, name); [EOL] } <line_num>: 155,158
public static Node returnNode() { [EOL]     return new Node(Token.RETURN); [EOL] } <line_num>: 160,162
public static Node returnNode(Node expr) { [EOL]     Preconditions.checkState(mayBeExpression(expr)); [EOL]     return new Node(Token.RETURN, expr); [EOL] } <line_num>: 164,167
public static Node throwNode(Node expr) { [EOL]     Preconditions.checkState(mayBeExpression(expr)); [EOL]     return new Node(Token.THROW, expr); [EOL] } <line_num>: 169,172
public static Node exprResult(Node expr) { [EOL]     Preconditions.checkState(mayBeExpression(expr)); [EOL]     return new Node(Token.EXPR_RESULT, expr); [EOL] } <line_num>: 174,177
public static Node ifNode(Node cond, Node then) { [EOL]     Preconditions.checkState(mayBeExpression(cond)); [EOL]     Preconditions.checkState(then.isBlock()); [EOL]     return new Node(Token.IF, cond, then); [EOL] } <line_num>: 179,183
public static Node ifNode(Node cond, Node then, Node elseNode) { [EOL]     Preconditions.checkState(mayBeExpression(cond)); [EOL]     Preconditions.checkState(then.isBlock()); [EOL]     Preconditions.checkState(elseNode.isBlock()); [EOL]     return new Node(Token.IF, cond, then, elseNode); [EOL] } <line_num>: 185,190
public static Node doNode(Node body, Node cond) { [EOL]     Preconditions.checkState(body.isBlock()); [EOL]     Preconditions.checkState(mayBeExpression(cond)); [EOL]     return new Node(Token.DO, body, cond); [EOL] } <line_num>: 192,196
public static Node forIn(Node target, Node cond, Node body) { [EOL]     Preconditions.checkState(target.isVar() || mayBeExpression(target)); [EOL]     Preconditions.checkState(mayBeExpression(cond)); [EOL]     Preconditions.checkState(body.isBlock()); [EOL]     return new Node(Token.FOR, target, cond, body); [EOL] } <line_num>: 198,203
public static Node forNode(Node init, Node cond, Node incr, Node body) { [EOL]     Preconditions.checkState(init.isVar() || mayBeExpressionOrEmpty(init)); [EOL]     Preconditions.checkState(mayBeExpressionOrEmpty(cond)); [EOL]     Preconditions.checkState(mayBeExpressionOrEmpty(incr)); [EOL]     Preconditions.checkState(body.isBlock()); [EOL]     return new Node(Token.FOR, init, cond, incr, body); [EOL] } <line_num>: 205,211
public static Node switchNode(Node cond, Node... cases) { [EOL]     Preconditions.checkState(mayBeExpression(cond)); [EOL]     Node switchNode = new Node(Token.SWITCH, cond); [EOL]     for (Node caseNode : cases) { [EOL]         Preconditions.checkState(caseNode.isCase() || caseNode.isDefaultCase()); [EOL]         switchNode.addChildToBack(caseNode); [EOL]     } [EOL]     return switchNode; [EOL] } <line_num>: 213,221
public static Node caseNode(Node expr, Node body) { [EOL]     Preconditions.checkState(mayBeExpression(expr)); [EOL]     Preconditions.checkState(body.isBlock()); [EOL]     body.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true); [EOL]     return new Node(Token.CASE, expr, body); [EOL] } <line_num>: 223,228
public static Node defaultCase(Node body) { [EOL]     Preconditions.checkState(body.isBlock()); [EOL]     body.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true); [EOL]     return new Node(Token.DEFAULT_CASE, body); [EOL] } <line_num>: 230,234
public static Node label(Node name, Node stmt) { [EOL]     Preconditions.checkState(name.isLabelName()); [EOL]     Preconditions.checkState(mayBeStatement(stmt)); [EOL]     Node block = new Node(Token.LABEL, name, stmt); [EOL]     return block; [EOL] } <line_num>: 236,242
public static Node labelName(String name) { [EOL]     Preconditions.checkState(!name.isEmpty()); [EOL]     return Node.newString(Token.LABEL_NAME, name); [EOL] } <line_num>: 244,247
public static Node tryFinally(Node tryBody, Node finallyBody) { [EOL]     Preconditions.checkState(tryBody.isBlock()); [EOL]     Preconditions.checkState(finallyBody.isBlock()); [EOL]     Node catchBody = block().copyInformationFrom(tryBody); [EOL]     return new Node(Token.TRY, tryBody, catchBody, finallyBody); [EOL] } <line_num>: 249,254
public static Node tryCatch(Node tryBody, Node catchNode) { [EOL]     Preconditions.checkState(tryBody.isBlock()); [EOL]     Preconditions.checkState(catchNode.isCatch()); [EOL]     Node catchBody = blockUnchecked(catchNode).copyInformationFrom(catchNode); [EOL]     return new Node(Token.TRY, tryBody, catchBody); [EOL] } <line_num>: 256,261
public static Node tryCatchFinally(Node tryBody, Node catchNode, Node finallyBody) { [EOL]     Preconditions.checkState(finallyBody.isBlock()); [EOL]     Node tryNode = tryCatch(tryBody, catchNode); [EOL]     tryNode.addChildToBack(finallyBody); [EOL]     return tryNode; [EOL] } <line_num>: 263,269
public static Node catchNode(Node expr, Node body) { [EOL]     Preconditions.checkState(expr.isName()); [EOL]     Preconditions.checkState(body.isBlock()); [EOL]     return new Node(Token.CATCH, expr, body); [EOL] } <line_num>: 271,275
public static Node breakNode() { [EOL]     return new Node(Token.BREAK); [EOL] } <line_num>: 277,279
public static Node breakNode(Node name) { [EOL]     Preconditions.checkState(name.isLabelName()); [EOL]     return new Node(Token.BREAK, name); [EOL] } <line_num>: 281,285
public static Node continueNode() { [EOL]     return new Node(Token.CONTINUE); [EOL] } <line_num>: 287,289
public static Node continueNode(Node name) { [EOL]     Preconditions.checkState(name.isLabelName()); [EOL]     return new Node(Token.CONTINUE, name); [EOL] } <line_num>: 291,295
public static Node call(Node target, Node... args) { [EOL]     Node call = new Node(Token.CALL, target); [EOL]     for (Node arg : args) { [EOL]         Preconditions.checkState(mayBeExpression(arg)); [EOL]         call.addChildToBack(arg); [EOL]     } [EOL]     return call; [EOL] } <line_num>: 300,307
public static Node newNode(Node target, Node... args) { [EOL]     Node newcall = new Node(Token.NEW, target); [EOL]     for (Node arg : args) { [EOL]         Preconditions.checkState(mayBeExpression(arg)); [EOL]         newcall.addChildToBack(arg); [EOL]     } [EOL]     return newcall; [EOL] } <line_num>: 309,316
public static Node name(String name) { [EOL]     return Node.newString(Token.NAME, name); [EOL] } <line_num>: 318,320
public static Node getprop(Node target, Node prop) { [EOL]     Preconditions.checkState(mayBeExpression(target)); [EOL]     Preconditions.checkState(prop.isString()); [EOL]     return new Node(Token.GETPROP, target, prop); [EOL] } <line_num>: 322,326
public static Node getelem(Node target, Node elem) { [EOL]     Preconditions.checkState(mayBeExpression(target)); [EOL]     Preconditions.checkState(mayBeExpression(elem)); [EOL]     return new Node(Token.GETELEM, target, elem); [EOL] } <line_num>: 328,332
public static Node assign(Node target, Node expr) { [EOL]     Preconditions.checkState(isAssignmentTarget(target)); [EOL]     Preconditions.checkState(mayBeExpression(expr)); [EOL]     return new Node(Token.ASSIGN, target, expr); [EOL] } <line_num>: 334,338
public static Node hook(Node cond, Node trueval, Node falseval) { [EOL]     Preconditions.checkState(mayBeExpression(cond)); [EOL]     Preconditions.checkState(mayBeExpression(trueval)); [EOL]     Preconditions.checkState(mayBeExpression(falseval)); [EOL]     return new Node(Token.HOOK, cond, trueval, falseval); [EOL] } <line_num>: 340,345
public static Node comma(Node expr1, Node expr2) { [EOL]     return binaryOp(Token.COMMA, expr1, expr2); [EOL] } <line_num>: 347,349
public static Node and(Node expr1, Node expr2) { [EOL]     return binaryOp(Token.AND, expr1, expr2); [EOL] } <line_num>: 351,353
public static Node or(Node expr1, Node expr2) { [EOL]     return binaryOp(Token.OR, expr1, expr2); [EOL] } <line_num>: 355,357
public static Node not(Node expr1) { [EOL]     return unaryOp(Token.NOT, expr1); [EOL] } <line_num>: 359,361
public static Node eq(Node expr1, Node expr2) { [EOL]     return binaryOp(Token.EQ, expr1, expr2); [EOL] } <line_num>: 366,368
public static Node sheq(Node expr1, Node expr2) { [EOL]     return binaryOp(Token.SHEQ, expr1, expr2); [EOL] } <line_num>: 373,375
public static Node voidNode(Node expr1) { [EOL]     return unaryOp(Token.VOID, expr1); [EOL] } <line_num>: 377,379
public static Node neg(Node expr1) { [EOL]     return unaryOp(Token.NEG, expr1); [EOL] } <line_num>: 381,383
public static Node pos(Node expr1) { [EOL]     return unaryOp(Token.POS, expr1); [EOL] } <line_num>: 385,387
public static Node add(Node expr1, Node expr2) { [EOL]     return binaryOp(Token.ADD, expr1, expr2); [EOL] } <line_num>: 389,391
public static Node sub(Node expr1, Node expr2) { [EOL]     return binaryOp(Token.SUB, expr1, expr2); [EOL] } <line_num>: 393,395
public static Node objectlit(Node... propdefs) { [EOL]     Node objectlit = new Node(Token.OBJECTLIT); [EOL]     for (Node propdef : propdefs) { [EOL]         Preconditions.checkState(propdef.isStringKey() || propdef.isGetterDef() || propdef.isSetterDef()); [EOL]         Preconditions.checkState(propdef.hasOneChild()); [EOL]         objectlit.addChildToBack(propdef); [EOL]     } [EOL]     return objectlit; [EOL] } <line_num>: 400,410
public static Node propdef(Node string, Node value) { [EOL]     Preconditions.checkState(string.isStringKey()); [EOL]     Preconditions.checkState(!string.hasChildren()); [EOL]     Preconditions.checkState(mayBeExpression(value)); [EOL]     string.addChildToFront(value); [EOL]     return string; [EOL] } <line_num>: 414,420
public static Node arraylit(Node... exprs) { [EOL]     Node arraylit = new Node(Token.ARRAYLIT); [EOL]     for (Node expr : exprs) { [EOL]         Preconditions.checkState(mayBeExpressionOrEmpty(expr)); [EOL]         arraylit.addChildToBack(expr); [EOL]     } [EOL]     return arraylit; [EOL] } <line_num>: 422,429
public static Node regexp(Node expr) { [EOL]     Preconditions.checkState(expr.isString()); [EOL]     return new Node(Token.REGEXP, expr); [EOL] } <line_num>: 431,434
public static Node regexp(Node expr, Node flags) { [EOL]     Preconditions.checkState(expr.isString()); [EOL]     Preconditions.checkState(flags.isString()); [EOL]     return new Node(Token.REGEXP, expr, flags); [EOL] } <line_num>: 436,440
public static Node string(String s) { [EOL]     return Node.newString(s); [EOL] } <line_num>: 442,444
public static Node stringKey(String s) { [EOL]     return Node.newString(Token.STRING_KEY, s); [EOL] } <line_num>: 446,448
public static Node number(double d) { [EOL]     return Node.newNumber(d); [EOL] } <line_num>: 450,452
public static Node thisNode() { [EOL]     return new Node(Token.THIS); [EOL] } <line_num>: 454,456
public static Node trueNode() { [EOL]     return new Node(Token.TRUE); [EOL] } <line_num>: 458,460
public static Node falseNode() { [EOL]     return new Node(Token.FALSE); [EOL] } <line_num>: 462,464
public static Node nullNode() { [EOL]     return new Node(Token.NULL); [EOL] } <line_num>: 466,468
private static Node binaryOp(int token, Node expr1, Node expr2) { [EOL]     Preconditions.checkState(mayBeExpression(expr1)); [EOL]     Preconditions.checkState(mayBeExpression(expr2)); [EOL]     return new Node(token, expr1, expr2); [EOL] } <line_num>: 472,476
private static Node unaryOp(int token, Node expr) { [EOL]     Preconditions.checkState(mayBeExpression(expr)); [EOL]     return new Node(token, expr); [EOL] } <line_num>: 478,481
private static boolean mayBeExpressionOrEmpty(Node n) { [EOL]     return n.isEmpty() || mayBeExpression(n); [EOL] } <line_num>: 483,485
private static boolean isAssignmentTarget(Node n) { [EOL]     return n.isName() || n.isGetProp() || n.isGetElem(); [EOL] } <line_num>: 487,489
private static boolean mayBeStatementNoReturn(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.EMPTY: [EOL]         case Token.FUNCTION: [EOL]             return true; [EOL]         case Token.BLOCK: [EOL]         case Token.BREAK: [EOL]         case Token.CONST: [EOL]         case Token.CONTINUE: [EOL]         case Token.DEBUGGER: [EOL]         case Token.DO: [EOL]         case Token.EXPR_RESULT: [EOL]         case Token.FOR: [EOL]         case Token.IF: [EOL]         case Token.LABEL: [EOL]         case Token.SWITCH: [EOL]         case Token.THROW: [EOL]         case Token.TRY: [EOL]         case Token.VAR: [EOL]         case Token.WHILE: [EOL]         case Token.WITH: [EOL]             return true; [EOL]         default: [EOL]             return false; [EOL]     } [EOL] } <line_num>: 499,528
private static boolean mayBeStatement(Node n) { [EOL]     if (!mayBeStatementNoReturn(n)) { [EOL]         return n.isReturn(); [EOL]     } [EOL]     return true; [EOL] } <line_num>: 534,539
private static boolean mayBeExpression(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.FUNCTION: [EOL]             return true; [EOL]         case Token.ADD: [EOL]         case Token.AND: [EOL]         case Token.ARRAYLIT: [EOL]         case Token.ASSIGN: [EOL]         case Token.ASSIGN_BITOR: [EOL]         case Token.ASSIGN_BITXOR: [EOL]         case Token.ASSIGN_BITAND: [EOL]         case Token.ASSIGN_LSH: [EOL]         case Token.ASSIGN_RSH: [EOL]         case Token.ASSIGN_URSH: [EOL]         case Token.ASSIGN_ADD: [EOL]         case Token.ASSIGN_SUB: [EOL]         case Token.ASSIGN_MUL: [EOL]         case Token.ASSIGN_DIV: [EOL]         case Token.ASSIGN_MOD: [EOL]         case Token.BITAND: [EOL]         case Token.BITOR: [EOL]         case Token.BITNOT: [EOL]         case Token.BITXOR: [EOL]         case Token.CALL: [EOL]         case Token.COMMA: [EOL]         case Token.DEC: [EOL]         case Token.DELPROP: [EOL]         case Token.DIV: [EOL]         case Token.EQ: [EOL]         case Token.FALSE: [EOL]         case Token.GE: [EOL]         case Token.GETPROP: [EOL]         case Token.GETELEM: [EOL]         case Token.GT: [EOL]         case Token.HOOK: [EOL]         case Token.IN: [EOL]         case Token.INC: [EOL]         case Token.INSTANCEOF: [EOL]         case Token.LE: [EOL]         case Token.LSH: [EOL]         case Token.LT: [EOL]         case Token.MOD: [EOL]         case Token.MUL: [EOL]         case Token.NAME: [EOL]         case Token.NE: [EOL]         case Token.NEG: [EOL]         case Token.NEW: [EOL]         case Token.NOT: [EOL]         case Token.NUMBER: [EOL]         case Token.NULL: [EOL]         case Token.OBJECTLIT: [EOL]         case Token.OR: [EOL]         case Token.POS: [EOL]         case Token.REGEXP: [EOL]         case Token.RSH: [EOL]         case Token.SHEQ: [EOL]         case Token.SHNE: [EOL]         case Token.STRING: [EOL]         case Token.SUB: [EOL]         case Token.THIS: [EOL]         case Token.TYPEOF: [EOL]         case Token.TRUE: [EOL]         case Token.URSH: [EOL]         case Token.VOID: [EOL]             return true; [EOL]         default: [EOL]             return false; [EOL]     } [EOL] } <line_num>: 545,617
