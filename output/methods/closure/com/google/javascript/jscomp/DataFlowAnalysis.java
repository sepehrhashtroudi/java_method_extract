DataFlowAnalysis(ControlFlowGraph<N> targetCfg, JoinOp<L> joinOp) { [EOL]     this.cfg = targetCfg; [EOL]     this.joinOp = joinOp; [EOL]     Comparator<DiGraphNode<N, Branch>> nodeComparator = cfg.getOptionalNodeComparator(isForward()); [EOL]     if (nodeComparator != null) { [EOL]         this.orderedWorkSet = Sets.newTreeSet(nodeComparator); [EOL]     } else { [EOL]         this.orderedWorkSet = Sets.newLinkedHashSet(); [EOL]     } [EOL] } <line_num>: 120,130
private FlowState(L inState, L outState) { [EOL]     Preconditions.checkNotNull(inState); [EOL]     Preconditions.checkNotNull(outState); [EOL]     this.in = inState; [EOL]     this.out = outState; [EOL] } <line_num>: 341,346
MaxIterationsExceededException(String msg) { [EOL]     super(msg); [EOL] } <line_num>: 384,386
BranchedForwardDataFlowAnalysis(ControlFlowGraph<N> targetCfg, JoinOp<L> joinOp) { [EOL]     super(targetCfg, joinOp); [EOL] } <line_num>: 409,412
private BranchedFlowState(L inState, List<L> outState) { [EOL]     Preconditions.checkNotNull(inState); [EOL]     Preconditions.checkNotNull(outState); [EOL]     this.in = inState; [EOL]     this.out = outState; [EOL] } <line_num>: 496,501
final ControlFlowGraph<N> getCfg() { [EOL]     return cfg; [EOL] } <line_num>: 138,140
L getExitLatticeElement() { [EOL]     DiGraphNode<N, Branch> node = getCfg().getImplicitReturn(); [EOL]     FlowState<L> state = node.getAnnotation(); [EOL]     return state.getIn(); [EOL] } <line_num>: 145,149
@SuppressWarnings("unchecked") [EOL] protected L join(L latticeA, L latticeB) { [EOL]     return joinOp.apply(Lists.<L>newArrayList(latticeA, latticeB)); [EOL] } <line_num>: 151,154
abstract boolean isForward(); <line_num>: 162,162
abstract L flowThrough(N node, L input); <line_num>: 171,171
final void analyze() { [EOL]     analyze(MAX_STEPS); [EOL] } <line_num>: 179,181
final void analyze(int maxSteps) { [EOL]     initialize(); [EOL]     int step = 0; [EOL]     while (!orderedWorkSet.isEmpty()) { [EOL]         if (step > maxSteps) { [EOL]             throw new MaxIterationsExceededException("Analysis did not terminate after " + maxSteps + " iterations"); [EOL]         } [EOL]         DiGraphNode<N, Branch> curNode = orderedWorkSet.iterator().next(); [EOL]         orderedWorkSet.remove(curNode); [EOL]         joinInputs(curNode); [EOL]         if (flow(curNode)) { [EOL]             List<DiGraphNode<N, Branch>> nextNodes = isForward() ? cfg.getDirectedSuccNodes(curNode) : cfg.getDirectedPredNodes(curNode); [EOL]             for (DiGraphNode<N, Branch> nextNode : nextNodes) { [EOL]                 if (nextNode != cfg.getImplicitReturn()) { [EOL]                     orderedWorkSet.add(nextNode); [EOL]                 } [EOL]             } [EOL]         } [EOL]         step++; [EOL]     } [EOL]     if (isForward()) { [EOL]         joinInputs(getCfg().getImplicitReturn()); [EOL]     } [EOL] } <line_num>: 201,229
abstract L createInitialEstimateLattice(); <line_num>: 236,236
abstract L createEntryLattice(); <line_num>: 243,243
protected void initialize() { [EOL]     orderedWorkSet.clear(); [EOL]     for (DiGraphNode<N, Branch> node : cfg.getDirectedGraphNodes()) { [EOL]         node.setAnnotation(new FlowState<L>(createInitialEstimateLattice(), createInitialEstimateLattice())); [EOL]         if (node != cfg.getImplicitReturn()) { [EOL]             orderedWorkSet.add(node); [EOL]         } [EOL]     } [EOL] } <line_num>: 248,260
protected boolean flow(DiGraphNode<N, Branch> node) { [EOL]     FlowState<L> state = node.getAnnotation(); [EOL]     if (isForward()) { [EOL]         L outBefore = state.out; [EOL]         state.out = flowThrough(node.getValue(), state.in); [EOL]         return !outBefore.equals(state.out); [EOL]     } else { [EOL]         L inBefore = state.in; [EOL]         state.in = flowThrough(node.getValue(), state.out); [EOL]         return !inBefore.equals(state.in); [EOL]     } [EOL] } <line_num>: 267,278
protected void joinInputs(DiGraphNode<N, Branch> node) { [EOL]     FlowState<L> state = node.getAnnotation(); [EOL]     if (isForward()) { [EOL]         if (cfg.getEntry() == node) { [EOL]             state.setIn(createEntryLattice()); [EOL]         } else { [EOL]             List<DiGraphNode<N, Branch>> inNodes = cfg.getDirectedPredNodes(node); [EOL]             if (inNodes.size() == 1) { [EOL]                 FlowState<L> inNodeState = inNodes.get(0).getAnnotation(); [EOL]                 state.setIn(inNodeState.getOut()); [EOL]             } else if (inNodes.size() > 1) { [EOL]                 List<L> values = new ArrayList<L>(inNodes.size()); [EOL]                 for (DiGraphNode<N, Branch> currentNode : inNodes) { [EOL]                     FlowState<L> currentNodeState = currentNode.getAnnotation(); [EOL]                     values.add(currentNodeState.getOut()); [EOL]                 } [EOL]                 state.setIn(joinOp.apply(values)); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         List<DiGraphNode<N, Branch>> inNodes = cfg.getDirectedSuccNodes(node); [EOL]         if (inNodes.size() == 1) { [EOL]             DiGraphNode<N, Branch> inNode = inNodes.get(0); [EOL]             if (inNode == cfg.getImplicitReturn()) { [EOL]                 state.setOut(createEntryLattice()); [EOL]             } else { [EOL]                 FlowState<L> inNodeState = inNode.getAnnotation(); [EOL]                 state.setOut(inNodeState.getIn()); [EOL]             } [EOL]         } else if (inNodes.size() > 1) { [EOL]             List<L> values = new ArrayList<L>(inNodes.size()); [EOL]             for (DiGraphNode<N, Branch> currentNode : inNodes) { [EOL]                 FlowState<L> currentNodeState = currentNode.getAnnotation(); [EOL]                 values.add(currentNodeState.getIn()); [EOL]             } [EOL]             state.setOut(joinOp.apply(values)); [EOL]         } [EOL]     } [EOL] } <line_num>: 286,324
L getIn() { [EOL]     return in; [EOL] } <line_num>: 348,350
void setIn(L in) { [EOL]     Preconditions.checkNotNull(in); [EOL]     this.in = in; [EOL] } <line_num>: 352,355
L getOut() { [EOL]     return out; [EOL] } <line_num>: 357,359
void setOut(L out) { [EOL]     Preconditions.checkNotNull(out); [EOL]     this.out = out; [EOL] } <line_num>: 361,364
@Override [EOL] public String toString() { [EOL]     return String.format("IN: %s OUT: %s", in, out); [EOL] } <line_num>: 366,369
@Override [EOL] public int hashCode() { [EOL]     return Objects.hashCode(in, out); [EOL] } <line_num>: 371,374
@Override [EOL] protected void initialize() { [EOL]     orderedWorkSet.clear(); [EOL]     for (DiGraphNode<N, Branch> node : getCfg().getDirectedGraphNodes()) { [EOL]         int outEdgeCount = getCfg().getOutEdges(node.getValue()).size(); [EOL]         List<L> outLattices = Lists.newArrayList(); [EOL]         for (int i = 0; i < outEdgeCount; i++) { [EOL]             outLattices.add(createInitialEstimateLattice()); [EOL]         } [EOL]         node.setAnnotation(new BranchedFlowState<L>(createInitialEstimateLattice(), outLattices)); [EOL]         if (node != getCfg().getImplicitReturn()) { [EOL]             orderedWorkSet.add(node); [EOL]         } [EOL]     } [EOL] } <line_num>: 392,407
@Override [EOL] L getExitLatticeElement() { [EOL]     DiGraphNode<N, Branch> node = getCfg().getImplicitReturn(); [EOL]     BranchedFlowState<L> state = node.getAnnotation(); [EOL]     return state.getIn(); [EOL] } <line_num>: 418,423
@Override [EOL] final boolean isForward() { [EOL]     return true; [EOL] } <line_num>: 425,428
abstract List<L> branchedFlowThrough(N node, L input); <line_num>: 441,441
@Override [EOL] protected final boolean flow(DiGraphNode<N, Branch> node) { [EOL]     BranchedFlowState<L> state = node.getAnnotation(); [EOL]     List<L> outBefore = state.out; [EOL]     state.out = branchedFlowThrough(node.getValue(), state.in); [EOL]     Preconditions.checkState(outBefore.size() == state.out.size()); [EOL]     for (int i = 0; i < outBefore.size(); i++) { [EOL]         if (!outBefore.get(i).equals(state.out.get(i))) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 443,455
@Override [EOL] protected void joinInputs(DiGraphNode<N, Branch> node) { [EOL]     BranchedFlowState<L> state = node.getAnnotation(); [EOL]     List<DiGraphNode<N, Branch>> predNodes = getCfg().getDirectedPredNodes(node); [EOL]     List<L> values = new ArrayList<L>(predNodes.size()); [EOL]     for (DiGraphNode<N, Branch> predNode : predNodes) { [EOL]         BranchedFlowState<L> predNodeState = predNode.getAnnotation(); [EOL]         L in = predNodeState.out.get(getCfg().getDirectedSuccNodes(predNode).indexOf(node)); [EOL]         values.add(in); [EOL]     } [EOL]     if (getCfg().getEntry() == node) { [EOL]         state.setIn(createEntryLattice()); [EOL]     } else if (!values.isEmpty()) { [EOL]         state.setIn(joinOp.apply(values)); [EOL]     } [EOL] } <line_num>: 457,477
L getIn() { [EOL]     return in; [EOL] } <line_num>: 503,505
void setIn(L in) { [EOL]     Preconditions.checkNotNull(in); [EOL]     this.in = in; [EOL] } <line_num>: 507,510
List<L> getOut() { [EOL]     return out; [EOL] } <line_num>: 512,514
void setOut(List<L> out) { [EOL]     Preconditions.checkNotNull(out); [EOL]     for (L item : out) { [EOL]         Preconditions.checkNotNull(item); [EOL]     } [EOL]     this.out = out; [EOL] } <line_num>: 516,522
@Override [EOL] public String toString() { [EOL]     return String.format("IN: %s OUT: %s", in, out); [EOL] } <line_num>: 524,527
@Override [EOL] public int hashCode() { [EOL]     return Objects.hashCode(in, out); [EOL] } <line_num>: 529,532
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (jsScope == t.getScope() || !n.isName() || parent.isFunction()) { [EOL]         return; [EOL]     } [EOL]     String name = n.getString(); [EOL]     Var var = t.getScope().getVar(name); [EOL]     if (var != null && var.scope == jsScope) { [EOL]         escaped.add(jsScope.getVar(name)); [EOL]     } [EOL] } <line_num>: 552,563
static void computeEscaped(final Scope jsScope, final Set<Var> escaped, AbstractCompiler compiler) { [EOL]     AbstractPostOrderCallback finder = new AbstractPostOrderCallback() { [EOL]  [EOL]         @Override [EOL]         public void visit(NodeTraversal t, Node n, Node parent) { [EOL]             if (jsScope == t.getScope() || !n.isName() || parent.isFunction()) { [EOL]                 return; [EOL]             } [EOL]             String name = n.getString(); [EOL]             Var var = t.getScope().getVar(name); [EOL]             if (var != null && var.scope == jsScope) { [EOL]                 escaped.add(jsScope.getVar(name)); [EOL]             } [EOL]         } [EOL]     }; [EOL]     NodeTraversal t = new NodeTraversal(compiler, finder); [EOL]     t.traverseAtScope(jsScope); [EOL]     for (Iterator<Var> i = jsScope.getVars(); i.hasNext(); ) { [EOL]         Var var = i.next(); [EOL]         if (var.getParentNode().isCatch() || compiler.getCodingConvention().isExported(var.getName())) { [EOL]             escaped.add(var); [EOL]         } [EOL]     } [EOL] } <line_num>: 548,578
