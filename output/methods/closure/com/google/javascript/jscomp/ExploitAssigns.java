@Override [EOL] Node optimizeSubtree(Node subtree) { [EOL]     for (Node child = subtree.getFirstChild(); child != null; ) { [EOL]         Node next = child.getNext(); [EOL]         if (NodeUtil.isExprAssign(child)) { [EOL]             collapseAssign(child.getFirstChild(), child, subtree); [EOL]         } [EOL]         child = next; [EOL]     } [EOL]     return subtree; [EOL] } <line_num>: 31,41
private void collapseAssign(Node assign, Node expr, Node exprParent) { [EOL]     Node leftValue = assign.getFirstChild(); [EOL]     Node rightValue = leftValue.getNext(); [EOL]     if (isCollapsibleValue(leftValue, true) && collapseAssignEqualTo(expr, exprParent, leftValue)) { [EOL]         reportCodeChange(); [EOL]     } else if (isCollapsibleValue(rightValue, false) && collapseAssignEqualTo(expr, exprParent, rightValue)) { [EOL]         reportCodeChange(); [EOL]     } else if (rightValue.isAssign()) { [EOL]         collapseAssign(rightValue, expr, exprParent); [EOL]     } [EOL] } <line_num>: 46,60
private boolean isCollapsibleValue(Node value, boolean isLValue) { [EOL]     switch(value.getType()) { [EOL]         case Token.GETPROP: [EOL]             return !isLValue || value.getFirstChild().isThis(); [EOL]         case Token.NAME: [EOL]             return true; [EOL]         default: [EOL]             return NodeUtil.isImmutableValue(value); [EOL]     } [EOL] } <line_num>: 76,91
private boolean collapseAssignEqualTo(Node expr, Node exprParent, Node value) { [EOL]     Node assign = expr.getFirstChild(); [EOL]     Node parent = exprParent; [EOL]     Node next = expr.getNext(); [EOL]     while (next != null) { [EOL]         switch(next.getType()) { [EOL]             case Token.AND: [EOL]             case Token.OR: [EOL]             case Token.HOOK: [EOL]             case Token.IF: [EOL]             case Token.RETURN: [EOL]             case Token.EXPR_RESULT: [EOL]                 parent = next; [EOL]                 next = next.getFirstChild(); [EOL]                 break; [EOL]             case Token.VAR: [EOL]                 if (next.getFirstChild().hasChildren()) { [EOL]                     parent = next.getFirstChild(); [EOL]                     next = parent.getFirstChild(); [EOL]                     break; [EOL]                 } [EOL]                 return false; [EOL]             case Token.GETPROP: [EOL]             case Token.NAME: [EOL]                 if (next.isQualifiedName()) { [EOL]                     String nextName = next.getQualifiedName(); [EOL]                     if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) { [EOL]                         if (!isSafeReplacement(next, assign)) { [EOL]                             return false; [EOL]                         } [EOL]                         exprParent.removeChild(expr); [EOL]                         expr.removeChild(assign); [EOL]                         parent.replaceChild(next, assign); [EOL]                         return true; [EOL]                     } [EOL]                 } [EOL]                 return false; [EOL]             case Token.ASSIGN: [EOL]                 Node leftSide = next.getFirstChild(); [EOL]                 if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) { [EOL]                     parent = next; [EOL]                     next = leftSide.getNext(); [EOL]                     break; [EOL]                 } else { [EOL]                     return false; [EOL]                 } [EOL]             default: [EOL]                 if (NodeUtil.isImmutableValue(next) && next.isEquivalentTo(value)) { [EOL]                     exprParent.removeChild(expr); [EOL]                     expr.removeChild(assign); [EOL]                     parent.replaceChild(next, assign); [EOL]                     return true; [EOL]                 } [EOL]                 return false; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 108,199
private boolean isSafeReplacement(Node node, Node replacement) { [EOL]     if (node.isName()) { [EOL]         return true; [EOL]     } [EOL]     Preconditions.checkArgument(node.isGetProp()); [EOL]     Node name = node.getFirstChild(); [EOL]     if (name.isName() && isNameAssignedTo(name.getString(), replacement)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } <line_num>: 206,220
private boolean isNameAssignedTo(String name, Node node) { [EOL]     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) { [EOL]         if (isNameAssignedTo(name, c)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     if (node.isName()) { [EOL]         Node parent = node.getParent(); [EOL]         if (parent.isAssign() && parent.getFirstChild() == node) { [EOL]             if (name.equals(node.getString())) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 226,243
