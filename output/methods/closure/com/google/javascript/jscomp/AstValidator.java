public AstValidator(ViolationHandler handler) { [EOL]     this.violationHandler = handler; [EOL] } <line_num>: 43,45
public AstValidator() { [EOL]     this.violationHandler = new ViolationHandler() { [EOL]  [EOL]         @Override [EOL]         public void handleViolation(String message, Node n) { [EOL]             throw new IllegalStateException(message + " Reference node " + n.toString()); [EOL]         } [EOL]     }; [EOL] } <line_num>: 47,55
void handleViolation(String message, Node n); <line_num>: 38,38
@Override [EOL] public void handleViolation(String message, Node n) { [EOL]     throw new IllegalStateException(message + " Reference node " + n.toString()); [EOL] } <line_num>: 49,53
@Override [EOL] public void process(Node externs, Node root) { [EOL]     if (externs != null) { [EOL]         validateCodeRoot(externs); [EOL]     } [EOL]     if (root != null) { [EOL]         validateCodeRoot(root); [EOL]     } [EOL] } <line_num>: 57,65
public void validateRoot(Node n) { [EOL]     validateNodeType(Token.BLOCK, n); [EOL]     validateIsSynthetic(n); [EOL]     validateChildCount(n, 2); [EOL]     validateCodeRoot(n.getFirstChild()); [EOL]     validateCodeRoot(n.getLastChild()); [EOL] } <line_num>: 67,73
public void validateCodeRoot(Node n) { [EOL]     validateNodeType(Token.BLOCK, n); [EOL]     validateIsSynthetic(n); [EOL]     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { [EOL]         validateScript(c); [EOL]     } [EOL] } <line_num>: 75,81
public void validateScript(Node n) { [EOL]     validateNodeType(Token.SCRIPT, n); [EOL]     validateHasSourceName(n); [EOL]     validateHasInputId(n); [EOL]     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { [EOL]         validateStatement(c); [EOL]     } [EOL] } <line_num>: 83,90
public void validateStatement(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.LABEL: [EOL]             validateLabel(n); [EOL]             return; [EOL]         case Token.BLOCK: [EOL]             validateBlock(n); [EOL]             return; [EOL]         case Token.FUNCTION: [EOL]             validateFunctionStatement(n); [EOL]             return; [EOL]         case Token.WITH: [EOL]             validateWith(n); [EOL]             return; [EOL]         case Token.FOR: [EOL]             validateFor(n); [EOL]             return; [EOL]         case Token.WHILE: [EOL]             validateWhile(n); [EOL]             return; [EOL]         case Token.DO: [EOL]             validateDo(n); [EOL]             return; [EOL]         case Token.SWITCH: [EOL]             validateSwitch(n); [EOL]             return; [EOL]         case Token.IF: [EOL]             validateIf(n); [EOL]             return; [EOL]         case Token.VAR: [EOL]             validateVar(n); [EOL]             return; [EOL]         case Token.EXPR_RESULT: [EOL]             validateExprStmt(n); [EOL]             return; [EOL]         case Token.RETURN: [EOL]             validateReturn(n); [EOL]             return; [EOL]         case Token.THROW: [EOL]             validateThrow(n); [EOL]             return; [EOL]         case Token.TRY: [EOL]             validateTry(n); [EOL]             return; [EOL]         case Token.BREAK: [EOL]             validateBreak(n); [EOL]             return; [EOL]         case Token.CONTINUE: [EOL]             validateContinue(n); [EOL]             return; [EOL]         case Token.EMPTY: [EOL]             validateChildless(n); [EOL]             return; [EOL]         case Token.DEBUGGER: [EOL]             validateChildless(n); [EOL]             return; [EOL]         default: [EOL]             violation("Expected statement but was " + Token.name(n.getType()) + ".", n); [EOL]     } [EOL] } <line_num>: 92,152
public void validateExpression(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.FALSE: [EOL]         case Token.NULL: [EOL]         case Token.THIS: [EOL]         case Token.TRUE: [EOL]             validateChildless(n); [EOL]             return; [EOL]         case Token.DELPROP: [EOL]         case Token.POS: [EOL]         case Token.NEG: [EOL]         case Token.NOT: [EOL]         case Token.INC: [EOL]         case Token.DEC: [EOL]         case Token.TYPEOF: [EOL]         case Token.VOID: [EOL]         case Token.BITNOT: [EOL]         case Token.CAST: [EOL]             validateUnaryOp(n); [EOL]             return; [EOL]         case Token.COMMA: [EOL]         case Token.OR: [EOL]         case Token.AND: [EOL]         case Token.BITOR: [EOL]         case Token.BITXOR: [EOL]         case Token.BITAND: [EOL]         case Token.EQ: [EOL]         case Token.NE: [EOL]         case Token.SHEQ: [EOL]         case Token.SHNE: [EOL]         case Token.LT: [EOL]         case Token.GT: [EOL]         case Token.LE: [EOL]         case Token.GE: [EOL]         case Token.INSTANCEOF: [EOL]         case Token.IN: [EOL]         case Token.LSH: [EOL]         case Token.RSH: [EOL]         case Token.URSH: [EOL]         case Token.SUB: [EOL]         case Token.ADD: [EOL]         case Token.MUL: [EOL]         case Token.MOD: [EOL]         case Token.DIV: [EOL]             validateBinaryOp(n); [EOL]             return; [EOL]         case Token.ASSIGN: [EOL]         case Token.ASSIGN_BITOR: [EOL]         case Token.ASSIGN_BITXOR: [EOL]         case Token.ASSIGN_BITAND: [EOL]         case Token.ASSIGN_LSH: [EOL]         case Token.ASSIGN_RSH: [EOL]         case Token.ASSIGN_URSH: [EOL]         case Token.ASSIGN_ADD: [EOL]         case Token.ASSIGN_SUB: [EOL]         case Token.ASSIGN_MUL: [EOL]         case Token.ASSIGN_DIV: [EOL]         case Token.ASSIGN_MOD: [EOL]             validateAssignmentExpression(n); [EOL]             return; [EOL]         case Token.HOOK: [EOL]             validateTrinaryOp(n); [EOL]             return; [EOL]         case Token.STRING: [EOL]             validateString(n); [EOL]             return; [EOL]         case Token.NUMBER: [EOL]             validateNumber(n); [EOL]             return; [EOL]         case Token.NAME: [EOL]             validateName(n); [EOL]             return; [EOL]         case Token.GETELEM: [EOL]             validateBinaryOp(n); [EOL]             return; [EOL]         case Token.GETPROP: [EOL]             validateGetProp(n); [EOL]             return; [EOL]         case Token.ARRAYLIT: [EOL]             validateArrayLit(n); [EOL]             return; [EOL]         case Token.OBJECTLIT: [EOL]             validateObjectLit(n); [EOL]             return; [EOL]         case Token.REGEXP: [EOL]             validateRegExpLit(n); [EOL]             return; [EOL]         case Token.CALL: [EOL]             validateCall(n); [EOL]             return; [EOL]         case Token.NEW: [EOL]             validateNew(n); [EOL]             return; [EOL]         case Token.FUNCTION: [EOL]             validateFunctionExpression(n); [EOL]             return; [EOL]         default: [EOL]             violation("Expected expression but was " + Token.name(n.getType()), n); [EOL]     } [EOL] } <line_num>: 154,275
private void validateBlock(Node n) { [EOL]     validateNodeType(Token.BLOCK, n); [EOL]     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { [EOL]         validateStatement(c); [EOL]     } [EOL] } <line_num>: 277,282
private void validateSyntheticBlock(Node n) { [EOL]     validateNodeType(Token.BLOCK, n); [EOL]     validateIsSynthetic(n); [EOL]     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { [EOL]         validateStatement(c); [EOL]     } [EOL] } <line_num>: 284,290
private void validateIsSynthetic(Node n) { [EOL]     if (!n.getBooleanProp(Node.SYNTHETIC_BLOCK_PROP)) { [EOL]         violation("Missing 'synthetic block' annotation.", n); [EOL]     } [EOL] } <line_num>: 292,296
private void validateHasSourceName(Node n) { [EOL]     String sourceName = n.getSourceFileName(); [EOL]     if (sourceName == null || sourceName.isEmpty()) { [EOL]         violation("Missing 'source name' annotation.", n); [EOL]     } [EOL] } <line_num>: 298,303
private void validateHasInputId(Node n) { [EOL]     InputId inputId = n.getInputId(); [EOL]     if (inputId == null) { [EOL]         violation("Missing 'input id' annotation.", n); [EOL]     } [EOL] } <line_num>: 305,310
private void validateLabel(Node n) { [EOL]     validateNodeType(Token.LABEL, n); [EOL]     validateChildCount(n, 2); [EOL]     validateLabelName(n.getFirstChild()); [EOL]     validateStatement(n.getLastChild()); [EOL] } <line_num>: 312,317
private void validateLabelName(Node n) { [EOL]     validateNodeType(Token.LABEL_NAME, n); [EOL]     validateNonEmptyString(n); [EOL]     validateChildCount(n, 0); [EOL] } <line_num>: 319,323
private void validateNonEmptyString(Node n) { [EOL]     validateNonNullString(n); [EOL]     if (n.getString().isEmpty()) { [EOL]         violation("Expected non-empty string.", n); [EOL]     } [EOL] } <line_num>: 325,330
private void validateNonNullString(Node n) { [EOL]     if (n.getString() == null) { [EOL]         violation("Expected non-null string.", n); [EOL]     } [EOL] } <line_num>: 332,336
private void validateName(Node n) { [EOL]     validateNodeType(Token.NAME, n); [EOL]     validateNonEmptyString(n); [EOL]     validateChildCount(n, 0); [EOL] } <line_num>: 338,342
private void validateOptionalName(Node n) { [EOL]     validateNodeType(Token.NAME, n); [EOL]     validateNonNullString(n); [EOL]     validateChildCount(n, 0); [EOL] } <line_num>: 344,348
private void validateFunctionStatement(Node n) { [EOL]     validateNodeType(Token.FUNCTION, n); [EOL]     validateChildCount(n, 3); [EOL]     validateName(n.getFirstChild()); [EOL]     validateParameters(n.getChildAtIndex(1)); [EOL]     validateBlock(n.getLastChild()); [EOL] } <line_num>: 350,356
private void validateFunctionExpression(Node n) { [EOL]     validateNodeType(Token.FUNCTION, n); [EOL]     validateChildCount(n, 3); [EOL]     validateOptionalName(n.getFirstChild()); [EOL]     validateParameters(n.getChildAtIndex(1)); [EOL]     validateBlock(n.getLastChild()); [EOL] } <line_num>: 358,364
private void validateParameters(Node n) { [EOL]     validateNodeType(Token.PARAM_LIST, n); [EOL]     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { [EOL]         validateName(c); [EOL]     } [EOL] } <line_num>: 366,371
private void validateCall(Node n) { [EOL]     validateNodeType(Token.CALL, n); [EOL]     validateMinimumChildCount(n, 1); [EOL]     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { [EOL]         validateExpression(c); [EOL]     } [EOL] } <line_num>: 373,379
private void validateNew(Node n) { [EOL]     validateNodeType(Token.NEW, n); [EOL]     validateMinimumChildCount(n, 1); [EOL]     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { [EOL]         validateExpression(c); [EOL]     } [EOL] } <line_num>: 381,387
private void validateVar(Node n) { [EOL]     validateNodeType(Token.VAR, n); [EOL]     this.validateMinimumChildCount(n, 1); [EOL]     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { [EOL]         validateNodeType(Token.NAME, c); [EOL]         validateNonEmptyString(c); [EOL]         validateMaximumChildCount(c, 1); [EOL]         if (c.hasChildren()) { [EOL]             validateExpression(c.getFirstChild()); [EOL]         } [EOL]     } [EOL] } <line_num>: 389,402
private void validateFor(Node n) { [EOL]     validateNodeType(Token.FOR, n); [EOL]     validateMinimumChildCount(n, 3); [EOL]     validateMaximumChildCount(n, 4); [EOL]     if (NodeUtil.isForIn(n)) { [EOL]         validateChildCount(n, 3); [EOL]         validateVarOrAssignmentTarget(n.getFirstChild()); [EOL]         validateExpression(n.getChildAtIndex(1)); [EOL]     } else { [EOL]         validateChildCount(n, 4); [EOL]         validateVarOrOptionalExpression(n.getFirstChild()); [EOL]         validateOptionalExpression(n.getChildAtIndex(1)); [EOL]         validateOptionalExpression(n.getChildAtIndex(2)); [EOL]     } [EOL]     validateBlock(n.getLastChild()); [EOL] } <line_num>: 404,421
private void validateVarOrOptionalExpression(Node n) { [EOL]     if (n.isVar()) { [EOL]         validateVar(n); [EOL]     } else { [EOL]         validateOptionalExpression(n); [EOL]     } [EOL] } <line_num>: 423,429
private void validateVarOrAssignmentTarget(Node n) { [EOL]     if (n.isVar()) { [EOL]         this.validateChildCount(n, 1); [EOL]         validateVar(n); [EOL]     } else { [EOL]         validateAssignmentTarget(n); [EOL]     } [EOL] } <line_num>: 431,439
private void validateWith(Node n) { [EOL]     validateNodeType(Token.WITH, n); [EOL]     validateChildCount(n, 2); [EOL]     validateExpression(n.getFirstChild()); [EOL]     validateBlock(n.getLastChild()); [EOL] } <line_num>: 441,446
private void validateWhile(Node n) { [EOL]     validateNodeType(Token.WHILE, n); [EOL]     validateChildCount(n, 2); [EOL]     validateExpression(n.getFirstChild()); [EOL]     validateBlock(n.getLastChild()); [EOL] } <line_num>: 448,453
private void validateDo(Node n) { [EOL]     validateNodeType(Token.DO, n); [EOL]     validateChildCount(n, 2); [EOL]     validateBlock(n.getFirstChild()); [EOL]     validateExpression(n.getLastChild()); [EOL] } <line_num>: 455,460
private void validateIf(Node n) { [EOL]     validateNodeType(Token.IF, n); [EOL]     validateMinimumChildCount(n, 2); [EOL]     validateMaximumChildCount(n, 3); [EOL]     validateExpression(n.getFirstChild()); [EOL]     validateBlock(n.getChildAtIndex(1)); [EOL]     if (n.getChildCount() == 3) { [EOL]         validateBlock(n.getLastChild()); [EOL]     } [EOL] } <line_num>: 462,471
private void validateExprStmt(Node n) { [EOL]     validateNodeType(Token.EXPR_RESULT, n); [EOL]     validateChildCount(n, 1); [EOL]     validateExpression(n.getFirstChild()); [EOL] } <line_num>: 473,477
private void validateReturn(Node n) { [EOL]     validateNodeType(Token.RETURN, n); [EOL]     validateMaximumChildCount(n, 1); [EOL]     if (n.hasChildren()) { [EOL]         validateExpression(n.getFirstChild()); [EOL]     } [EOL] } <line_num>: 479,485
private void validateThrow(Node n) { [EOL]     validateNodeType(Token.THROW, n); [EOL]     validateChildCount(n, 1); [EOL]     validateExpression(n.getFirstChild()); [EOL] } <line_num>: 487,491
private void validateBreak(Node n) { [EOL]     validateNodeType(Token.BREAK, n); [EOL]     validateMaximumChildCount(n, 1); [EOL]     if (n.hasChildren()) { [EOL]         validateLabelName(n.getFirstChild()); [EOL]     } [EOL] } <line_num>: 493,499
private void validateContinue(Node n) { [EOL]     validateNodeType(Token.CONTINUE, n); [EOL]     validateMaximumChildCount(n, 1); [EOL]     if (n.hasChildren()) { [EOL]         validateLabelName(n.getFirstChild()); [EOL]     } [EOL] } <line_num>: 501,507
private void validateTry(Node n) { [EOL]     validateNodeType(Token.TRY, n); [EOL]     validateMinimumChildCount(n, 2); [EOL]     validateMaximumChildCount(n, 3); [EOL]     validateBlock(n.getFirstChild()); [EOL]     boolean seenCatchOrFinally = false; [EOL]     Node catches = n.getChildAtIndex(1); [EOL]     validateNodeType(Token.BLOCK, catches); [EOL]     validateMaximumChildCount(catches, 1); [EOL]     if (catches.hasChildren()) { [EOL]         validateCatch(catches.getFirstChild()); [EOL]         seenCatchOrFinally = true; [EOL]     } [EOL]     if (n.getChildCount() == 3) { [EOL]         validateBlock(n.getLastChild()); [EOL]         seenCatchOrFinally = true; [EOL]     } [EOL]     if (!seenCatchOrFinally) { [EOL]         violation("Missing catch or finally for try statement.", n); [EOL]     } [EOL] } <line_num>: 509,535
private void validateCatch(Node n) { [EOL]     validateNodeType(Token.CATCH, n); [EOL]     validateChildCount(n, 2); [EOL]     validateName(n.getFirstChild()); [EOL]     validateBlock(n.getLastChild()); [EOL] } <line_num>: 537,542
private void validateSwitch(Node n) { [EOL]     validateNodeType(Token.SWITCH, n); [EOL]     validateMinimumChildCount(n, 1); [EOL]     validateExpression(n.getFirstChild()); [EOL]     int defaults = 0; [EOL]     for (Node c = n.getFirstChild().getNext(); c != null; c = c.getNext()) { [EOL]         validateSwitchMember(n.getLastChild()); [EOL]         if (c.isDefaultCase()) { [EOL]             defaults++; [EOL]         } [EOL]     } [EOL]     if (defaults > 1) { [EOL]         violation("Expected at most 1 'default' in switch but was " + defaults, n); [EOL]     } [EOL] } <line_num>: 544,559
private void validateSwitchMember(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.CASE: [EOL]             validateCase(n); [EOL]             return; [EOL]         case Token.DEFAULT_CASE: [EOL]             validateDefault(n); [EOL]             return; [EOL]         default: [EOL]             violation("Expected switch member but was " + Token.name(n.getType()), n); [EOL]     } [EOL] } <line_num>: 561,573
private void validateDefault(Node n) { [EOL]     validateNodeType(Token.DEFAULT_CASE, n); [EOL]     validateChildCount(n, 1); [EOL]     validateSyntheticBlock(n.getLastChild()); [EOL] } <line_num>: 575,579
private void validateCase(Node n) { [EOL]     validateNodeType(Token.CASE, n); [EOL]     validateChildCount(n, 2); [EOL]     validateExpression(n.getFirstChild()); [EOL]     validateSyntheticBlock(n.getLastChild()); [EOL] } <line_num>: 581,586
private void validateOptionalExpression(Node n) { [EOL]     if (n.isEmpty()) { [EOL]         validateChildless(n); [EOL]     } else { [EOL]         validateExpression(n); [EOL]     } [EOL] } <line_num>: 588,594
private void validateChildless(Node n) { [EOL]     validateChildCount(n, 0); [EOL] } <line_num>: 596,598
private void validateAssignmentExpression(Node n) { [EOL]     validateChildCount(n, 2); [EOL]     validateAssignmentTarget(n.getFirstChild()); [EOL]     validateExpression(n.getLastChild()); [EOL] } <line_num>: 600,604
private void validateAssignmentTarget(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.NAME: [EOL]         case Token.GETELEM: [EOL]         case Token.GETPROP: [EOL]             validateExpression(n); [EOL]             return; [EOL]         default: [EOL]             violation("Expected assignment target expression but was " + Token.name(n.getType()), n); [EOL]     } [EOL] } <line_num>: 606,617
private void validateGetProp(Node n) { [EOL]     validateNodeType(Token.GETPROP, n); [EOL]     validateChildCount(n, 2); [EOL]     validateExpression(n.getFirstChild()); [EOL]     Node prop = n.getLastChild(); [EOL]     validateNodeType(Token.STRING, prop); [EOL]     validateNonEmptyString(prop); [EOL] } <line_num>: 619,626
private void validateRegExpLit(Node n) { [EOL]     validateNodeType(Token.REGEXP, n); [EOL]     validateMinimumChildCount(n, 1); [EOL]     validateMaximumChildCount(n, 2); [EOL]     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { [EOL]         validateString(c); [EOL]     } [EOL] } <line_num>: 628,635
private void validateString(Node n) { [EOL]     validateNodeType(Token.STRING, n); [EOL]     validateChildCount(n, 0); [EOL]     try { [EOL]         n.getString(); [EOL]     } catch (UnsupportedOperationException e) { [EOL]         violation("Invalid STRING node.", n); [EOL]     } [EOL] } <line_num>: 637,646
private void validateNumber(Node n) { [EOL]     validateNodeType(Token.NUMBER, n); [EOL]     validateChildCount(n, 0); [EOL]     try { [EOL]         n.getDouble(); [EOL]     } catch (UnsupportedOperationException e) { [EOL]         violation("Invalid NUMBER node.", n); [EOL]     } [EOL] } <line_num>: 648,657
private void validateArrayLit(Node n) { [EOL]     validateNodeType(Token.ARRAYLIT, n); [EOL]     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { [EOL]         validateOptionalExpression(c); [EOL]     } [EOL] } <line_num>: 659,665
private void validateObjectLit(Node n) { [EOL]     validateNodeType(Token.OBJECTLIT, n); [EOL]     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { [EOL]         validateObjectLitKey(c); [EOL]     } [EOL] } <line_num>: 667,672
private void validateObjectLitKey(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.GETTER_DEF: [EOL]             validateObjectLitGetKey(n); [EOL]             return; [EOL]         case Token.SETTER_DEF: [EOL]             validateObjectLitSetKey(n); [EOL]             return; [EOL]         case Token.STRING_KEY: [EOL]             validateObjectLitStringKey(n); [EOL]             return; [EOL]         default: [EOL]             violation("Expected object literal key expression but was " + Token.name(n.getType()), n); [EOL]     } [EOL] } <line_num>: 674,689
private void validateObjectLitGetKey(Node n) { [EOL]     validateNodeType(Token.GETTER_DEF, n); [EOL]     validateChildCount(n, 1); [EOL]     validateObjectLiteralKeyName(n); [EOL]     Node function = n.getFirstChild(); [EOL]     validateFunctionExpression(function); [EOL]     if (!function.getFirstChild().getString().isEmpty()) { [EOL]         violation("Expected unnamed function expression.", n); [EOL]     } [EOL]     Node functionParams = function.getChildAtIndex(1); [EOL]     if (functionParams.hasChildren()) { [EOL]         violation("get methods must not have parameters.", n); [EOL]     } [EOL] } <line_num>: 691,705
private void validateObjectLitSetKey(Node n) { [EOL]     validateNodeType(Token.SETTER_DEF, n); [EOL]     validateChildCount(n, 1); [EOL]     validateObjectLiteralKeyName(n); [EOL]     Node function = n.getFirstChild(); [EOL]     validateFunctionExpression(function); [EOL]     if (!function.getFirstChild().getString().isEmpty()) { [EOL]         violation("Expected unnamed function expression.", n); [EOL]     } [EOL]     Node functionParams = function.getChildAtIndex(1); [EOL]     if (!functionParams.hasOneChild()) { [EOL]         violation("set methods must have exactly one parameter.", n); [EOL]     } [EOL] } <line_num>: 707,721
private void validateObjectLitStringKey(Node n) { [EOL]     validateNodeType(Token.STRING_KEY, n); [EOL]     validateChildCount(n, 1); [EOL]     validateObjectLiteralKeyName(n); [EOL]     validateExpression(n.getFirstChild()); [EOL] } <line_num>: 723,728
private void validateObjectLiteralKeyName(Node n) { [EOL]     if (n.isQuotedString()) { [EOL]         try { [EOL]             n.getString(); [EOL]         } catch (UnsupportedOperationException e) { [EOL]             violation("getString failed for" + Token.name(n.getType()), n); [EOL]         } [EOL]     } else { [EOL]         validateNonEmptyString(n); [EOL]     } [EOL] } <line_num>: 730,741
private void validateUnaryOp(Node n) { [EOL]     validateChildCount(n, 1); [EOL]     validateExpression(n.getFirstChild()); [EOL] } <line_num>: 743,746
private void validateBinaryOp(Node n) { [EOL]     validateChildCount(n, 2); [EOL]     validateExpression(n.getFirstChild()); [EOL]     validateExpression(n.getLastChild()); [EOL] } <line_num>: 748,752
private void validateTrinaryOp(Node n) { [EOL]     validateChildCount(n, 3); [EOL]     Node first = n.getFirstChild(); [EOL]     validateExpression(first); [EOL]     validateExpression(first.getNext()); [EOL]     validateExpression(n.getLastChild()); [EOL] } <line_num>: 754,760
private void violation(String message, Node n) { [EOL]     violationHandler.handleViolation(message, n); [EOL] } <line_num>: 762,764
private void validateNodeType(int type, Node n) { [EOL]     if (n.getType() != type) { [EOL]         violation("Expected " + Token.name(type) + " but was " + Token.name(n.getType()), n); [EOL]     } [EOL] } <line_num>: 766,772
private void validateChildCount(Node n, int i) { [EOL]     boolean valid = false; [EOL]     if (i == 0) { [EOL]         valid = !n.hasChildren(); [EOL]     } else if (i == 1) { [EOL]         valid = n.hasOneChild(); [EOL]     } else { [EOL]         valid = (n.getChildCount() == i); [EOL]     } [EOL]     if (!valid) { [EOL]         violation("Expected " + i + " children, but was " + n.getChildCount(), n); [EOL]     } [EOL] } <line_num>: 774,788
private void validateMinimumChildCount(Node n, int i) { [EOL]     boolean valid = false; [EOL]     if (i == 1) { [EOL]         valid = n.hasChildren(); [EOL]     } else if (i == 2) { [EOL]         valid = n.hasMoreThanOneChild(); [EOL]     } else { [EOL]         valid = n.getChildCount() >= i; [EOL]     } [EOL]     if (!valid) { [EOL]         violation("Expected at least " + i + " children, but was " + n.getChildCount(), n); [EOL]     } [EOL] } <line_num>: 790,805
private void validateMaximumChildCount(Node n, int i) { [EOL]     boolean valid = false; [EOL]     if (i == 1) { [EOL]         valid = !n.hasMoreThanOneChild(); [EOL]     } else { [EOL]         valid = n.getChildCount() <= i; [EOL]     } [EOL]     if (!valid) { [EOL]         violation("Expected no more than " + i + " children, but was " + n.getChildCount(), n); [EOL]     } [EOL] } <line_num>: 807,819
