RemoveUnusedVars(AbstractCompiler compiler, boolean removeGlobals, boolean preserveFunctionExpressionNames, boolean modifyCallSites) { [EOL]     this.compiler = compiler; [EOL]     this.codingConvention = compiler.getCodingConvention(); [EOL]     this.removeGlobals = removeGlobals; [EOL]     this.preserveFunctionExpressionNames = preserveFunctionExpressionNames; [EOL]     this.modifyCallSites = modifyCallSites; [EOL] } <line_num>: 123,133
CallSiteOptimizer(AbstractCompiler compiler, SimpleDefinitionFinder defFinder) { [EOL]     this.compiler = compiler; [EOL]     this.defFinder = defFinder; [EOL] } <line_num>: 425,430
Continuation(Node node, Scope scope) { [EOL]     this.node = node; [EOL]     this.scope = scope; [EOL] } <line_num>: 881,884
Assign(Node assignNode, Node nameNode, boolean isPropertyAssign) { [EOL]     Preconditions.checkState(NodeUtil.isAssignmentOp(assignNode)); [EOL]     this.assignNode = assignNode; [EOL]     this.nameNode = nameNode; [EOL]     this.isPropertyAssign = isPropertyAssign; [EOL]     this.maybeAliased = NodeUtil.isExpressionResultUsed(assignNode); [EOL]     this.mayHaveSecondarySideEffects = maybeAliased || NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) || NodeUtil.mayHaveSideEffects(assignNode.getLastChild()); [EOL] } <line_num>: 922,933
@Override [EOL] public void process(Node externs, Node root) { [EOL]     Preconditions.checkState(compiler.getLifeCycleStage().isNormalized()); [EOL]     SimpleDefinitionFinder defFinder = null; [EOL]     if (modifyCallSites) { [EOL]         defFinder = new SimpleDefinitionFinder(compiler); [EOL]         defFinder.process(externs, root); [EOL]     } [EOL]     process(externs, root, defFinder); [EOL] } <line_num>: 139,150
@Override [EOL] public void process(Node externs, Node root, SimpleDefinitionFinder defFinder) { [EOL]     if (modifyCallSites) { [EOL]         Preconditions.checkNotNull(defFinder); [EOL]         callSiteOptimizer = new CallSiteOptimizer(compiler, defFinder); [EOL]     } [EOL]     traverseAndRemoveUnusedReferences(root); [EOL]     if (callSiteOptimizer != null) { [EOL]         callSiteOptimizer.applyChanges(); [EOL]     } [EOL] } <line_num>: 152,163
private void traverseAndRemoveUnusedReferences(Node root) { [EOL]     Scope scope = new SyntacticScopeCreator(compiler).createScope(root, null); [EOL]     traverseNode(root, null, scope); [EOL]     if (removeGlobals) { [EOL]         collectMaybeUnreferencedVars(scope); [EOL]     } [EOL]     interpretAssigns(); [EOL]     removeUnreferencedVars(); [EOL]     for (Scope fnScope : allFunctionScopes) { [EOL]         removeUnreferencedFunctionArgs(fnScope); [EOL]     } [EOL] } <line_num>: 168,181
private void traverseNode(Node n, Node parent, Scope scope) { [EOL]     int type = n.getType(); [EOL]     Var var = null; [EOL]     switch(type) { [EOL]         case Token.FUNCTION: [EOL]             if (NodeUtil.isFunctionDeclaration(n)) { [EOL]                 var = scope.getVar(n.getFirstChild().getString()); [EOL]             } [EOL]             if (var != null && isRemovableVar(var)) { [EOL]                 continuations.put(var, new Continuation(n, scope)); [EOL]             } else { [EOL]                 traverseFunction(n, scope); [EOL]             } [EOL]             return; [EOL]         case Token.ASSIGN: [EOL]             Assign maybeAssign = Assign.maybeCreateAssign(n); [EOL]             if (maybeAssign != null) { [EOL]                 var = scope.getVar(maybeAssign.nameNode.getString()); [EOL]                 if (var != null) { [EOL]                     assignsByVar.put(var, maybeAssign); [EOL]                     assignsByNode.put(maybeAssign.nameNode, maybeAssign); [EOL]                     if (isRemovableVar(var) && !maybeAssign.mayHaveSecondarySideEffects) { [EOL]                         continuations.put(var, new Continuation(n, scope)); [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Token.CALL: [EOL]             Var modifiedVar = null; [EOL]             SubclassRelationship subclassRelationship = codingConvention.getClassesDefinedByCall(n); [EOL]             if (subclassRelationship != null) { [EOL]                 modifiedVar = scope.getVar(subclassRelationship.subclassName); [EOL]             } else { [EOL]                 String className = codingConvention.getSingletonGetterClassName(n); [EOL]                 if (className != null) { [EOL]                     modifiedVar = scope.getVar(className); [EOL]                 } [EOL]             } [EOL]             if (modifiedVar != null && modifiedVar.isGlobal() && !referenced.contains(modifiedVar)) { [EOL]                 classDefiningCalls.put(modifiedVar, parent); [EOL]                 continuations.put(modifiedVar, new Continuation(n, scope)); [EOL]                 return; [EOL]             } [EOL]             break; [EOL]         case Token.NAME: [EOL]             var = scope.getVar(n.getString()); [EOL]             if (parent.isVar()) { [EOL]                 Node value = n.getFirstChild(); [EOL]                 if (value != null && var != null && isRemovableVar(var) && !NodeUtil.mayHaveSideEffects(value, compiler)) { [EOL]                     continuations.put(var, new Continuation(n, scope)); [EOL]                     return; [EOL]                 } [EOL]             } else { [EOL]                 if ("arguments".equals(n.getString()) && scope.isLocal()) { [EOL]                     Node lp = scope.getRootNode().getFirstChild().getNext(); [EOL]                     for (Node a = lp.getFirstChild(); a != null; a = a.getNext()) { [EOL]                         markReferencedVar(scope.getVar(a.getString())); [EOL]                     } [EOL]                 } [EOL]                 if (var != null) { [EOL]                     if (isRemovableVar(var)) { [EOL]                         if (!assignsByNode.containsKey(n)) { [EOL]                             markReferencedVar(var); [EOL]                         } [EOL]                     } else { [EOL]                         markReferencedVar(var); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             break; [EOL]     } [EOL]     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { [EOL]         traverseNode(c, n, scope); [EOL]     } [EOL] } <line_num>: 192,305
private boolean isRemovableVar(Var var) { [EOL]     if (!removeGlobals && var.isGlobal()) { [EOL]         return false; [EOL]     } [EOL]     if (referenced.contains(var)) { [EOL]         return false; [EOL]     } [EOL]     if (codingConvention.isExported(var.getName())) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } <line_num>: 307,324
private void traverseFunction(Node n, Scope parentScope) { [EOL]     Preconditions.checkState(n.getChildCount() == 3); [EOL]     Preconditions.checkState(n.isFunction()); [EOL]     final Node body = n.getLastChild(); [EOL]     Preconditions.checkState(body.getNext() == null && body.isBlock()); [EOL]     Scope fnScope = new SyntacticScopeCreator(compiler).createScope(n, parentScope); [EOL]     traverseNode(body, n, fnScope); [EOL]     collectMaybeUnreferencedVars(fnScope); [EOL]     allFunctionScopes.add(fnScope); [EOL] } <line_num>: 334,348
private void collectMaybeUnreferencedVars(Scope scope) { [EOL]     for (Iterator<Var> it = scope.getVars(); it.hasNext(); ) { [EOL]         Var var = it.next(); [EOL]         if (isRemovableVar(var)) { [EOL]             maybeUnreferenced.add(var); [EOL]         } [EOL]     } [EOL] } <line_num>: 354,361
private void removeUnreferencedFunctionArgs(Scope fnScope) { [EOL]     if (!removeGlobals) { [EOL]         return; [EOL]     } [EOL]     Node function = fnScope.getRootNode(); [EOL]     Preconditions.checkState(function.isFunction()); [EOL]     if (NodeUtil.isGetOrSetKey(function.getParent())) { [EOL]         return; [EOL]     } [EOL]     Node argList = getFunctionArgList(function); [EOL]     boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function); [EOL]     if (!modifyCallers) { [EOL]         Node lastArg; [EOL]         while ((lastArg = argList.getLastChild()) != null) { [EOL]             Var var = fnScope.getVar(lastArg.getString()); [EOL]             if (!referenced.contains(var)) { [EOL]                 argList.removeChild(lastArg); [EOL]                 compiler.reportCodeChange(); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         callSiteOptimizer.optimize(fnScope, referenced); [EOL]     } [EOL] } <line_num>: 369,409
private static Node getFunctionArgList(Node function) { [EOL]     return function.getFirstChild().getNext(); [EOL] } <line_num>: 415,417
public void optimize(Scope fnScope, Set<Var> referenced) { [EOL]     Node function = fnScope.getRootNode(); [EOL]     Preconditions.checkState(function.isFunction()); [EOL]     Node argList = getFunctionArgList(function); [EOL]     boolean changeCallSignature = canChangeSignature(function); [EOL]     markUnreferencedFunctionArgs(fnScope, function, referenced, argList.getFirstChild(), 0, changeCallSignature); [EOL] } <line_num>: 432,443
public void applyChanges() { [EOL]     for (Node n : toRemove) { [EOL]         n.getParent().removeChild(n); [EOL]         compiler.reportCodeChange(); [EOL]     } [EOL]     for (Node n : toReplaceWithZero) { [EOL]         n.getParent().replaceChild(n, IR.number(0).srcref(n)); [EOL]         compiler.reportCodeChange(); [EOL]     } [EOL] } <line_num>: 448,457
private boolean markUnreferencedFunctionArgs(Scope scope, Node function, Set<Var> referenced, Node param, int paramIndex, boolean canChangeSignature) { [EOL]     if (param != null) { [EOL]         boolean hasFollowing = markUnreferencedFunctionArgs(scope, function, referenced, param.getNext(), paramIndex + 1, canChangeSignature); [EOL]         Var var = scope.getVar(param.getString()); [EOL]         if (!referenced.contains(var)) { [EOL]             Preconditions.checkNotNull(var); [EOL]             boolean modifyAllCallSites = canChangeSignature || !hasFollowing; [EOL]             if (modifyAllCallSites) { [EOL]                 modifyAllCallSites = canRemoveArgFromCallSites(function, paramIndex); [EOL]             } [EOL]             tryRemoveArgFromCallSites(function, paramIndex, modifyAllCallSites); [EOL]             if (modifyAllCallSites || !hasFollowing) { [EOL]                 toRemove.add(param); [EOL]                 return hasFollowing; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } else { [EOL]         tryRemoveAllFollowingArgs(function, paramIndex - 1); [EOL]         return false; [EOL]     } [EOL] } <line_num>: 472,510
private boolean canRemoveArgFromCallSites(Node function, int argIndex) { [EOL]     Definition definition = getFunctionDefinition(function); [EOL]     for (UseSite site : defFinder.getUseSites(definition)) { [EOL]         if (isModifiableCallSite(site)) { [EOL]             Node arg = getArgumentForCallOrNewOrDotCall(site, argIndex); [EOL]             if (arg != null && NodeUtil.mayHaveSideEffects(arg, compiler)) { [EOL]                 return false; [EOL]             } [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 517,535
private void tryRemoveArgFromCallSites(Node function, int argIndex, boolean canModifyAllSites) { [EOL]     Definition definition = getFunctionDefinition(function); [EOL]     for (UseSite site : defFinder.getUseSites(definition)) { [EOL]         if (isModifiableCallSite(site)) { [EOL]             Node arg = getArgumentForCallOrNewOrDotCall(site, argIndex); [EOL]             if (arg != null) { [EOL]                 Node argParent = arg.getParent(); [EOL]                 if (canModifyAllSites || (arg.getNext() == null && !NodeUtil.mayHaveSideEffects(arg, compiler))) { [EOL]                     toRemove.add(arg); [EOL]                 } else { [EOL]                     if (!NodeUtil.mayHaveSideEffects(arg, compiler) && (!arg.isNumber() || arg.getDouble() != 0)) { [EOL]                         toReplaceWithZero.add(arg); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 541,566
private void tryRemoveAllFollowingArgs(Node function, final int argIndex) { [EOL]     Definition definition = getFunctionDefinition(function); [EOL]     for (UseSite site : defFinder.getUseSites(definition)) { [EOL]         if (!isModifiableCallSite(site)) { [EOL]             continue; [EOL]         } [EOL]         Node arg = getArgumentForCallOrNewOrDotCall(site, argIndex + 1); [EOL]         while (arg != null) { [EOL]             if (!NodeUtil.mayHaveSideEffects(arg)) { [EOL]                 toRemove.add(arg); [EOL]             } [EOL]             arg = arg.getNext(); [EOL]         } [EOL]     } [EOL] } <line_num>: 571,585
private static Node getArgumentForCallOrNewOrDotCall(UseSite site, final int argIndex) { [EOL]     int adjustedArgIndex = argIndex; [EOL]     Node parent = site.node.getParent(); [EOL]     if (NodeUtil.isFunctionObjectCall(parent)) { [EOL]         adjustedArgIndex++; [EOL]     } [EOL]     return NodeUtil.getArgumentForCallOrNew(parent, adjustedArgIndex); [EOL] } <line_num>: 591,599
boolean canModifyCallers(Node function) { [EOL]     if (NodeUtil.isVarArgsFunction(function)) { [EOL]         return false; [EOL]     } [EOL]     DefinitionSite defSite = defFinder.getDefinitionForFunction(function); [EOL]     if (defSite == null) { [EOL]         return false; [EOL]     } [EOL]     Definition definition = defSite.definition; [EOL]     if (!SimpleDefinitionFinder.isSimpleFunctionDeclaration(function)) { [EOL]         return false; [EOL]     } [EOL]     return defFinder.canModifyDefinition(definition); [EOL] } <line_num>: 605,624
private static boolean isModifiableCallSite(UseSite site) { [EOL]     return SimpleDefinitionFinder.isCallOrNewSite(site) && !NodeUtil.isFunctionObjectApply(site.node.getParent()); [EOL] } <line_num>: 630,633
private boolean canChangeSignature(Node function) { [EOL]     Definition definition = getFunctionDefinition(function); [EOL]     CodingConvention convention = compiler.getCodingConvention(); [EOL]     Preconditions.checkState(!definition.isExtern()); [EOL]     Collection<UseSite> useSites = defFinder.getUseSites(definition); [EOL]     for (UseSite site : useSites) { [EOL]         Node parent = site.node.getParent(); [EOL]         if (parent == null) { [EOL]             continue; [EOL]         } [EOL]         if (parent.isCall() && convention.getClassesDefinedByCall(parent) != null) { [EOL]             continue; [EOL]         } [EOL]         if (!SimpleDefinitionFinder.isCallOrNewSite(site)) { [EOL]             if (!(parent.isGetProp() && NodeUtil.isFunctionObjectCall(parent.getParent()))) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (NodeUtil.isFunctionObjectApply(parent)) { [EOL]             return false; [EOL]         } [EOL]         Node nameNode = site.node; [EOL]         Collection<Definition> singleSiteDefinitions = defFinder.getDefinitionsReferencedAt(nameNode); [EOL]         Preconditions.checkState(singleSiteDefinitions.size() == 1); [EOL]         Preconditions.checkState(singleSiteDefinitions.contains(definition)); [EOL]     } [EOL]     return true; [EOL] } <line_num>: 639,687
private Definition getFunctionDefinition(Node function) { [EOL]     DefinitionSite definitionSite = defFinder.getDefinitionForFunction(function); [EOL]     Preconditions.checkNotNull(definitionSite); [EOL]     Definition definition = definitionSite.definition; [EOL]     Preconditions.checkState(!definitionSite.inExterns); [EOL]     Preconditions.checkState(definition.getRValue() == function); [EOL]     return definition; [EOL] } <line_num>: 693,701
private void interpretAssigns() { [EOL]     boolean changes = false; [EOL]     do { [EOL]         changes = false; [EOL]         for (int current = 0; current < maybeUnreferenced.size(); current++) { [EOL]             Var var = maybeUnreferenced.get(current); [EOL]             if (referenced.contains(var)) { [EOL]                 maybeUnreferenced.remove(current); [EOL]                 current--; [EOL]             } else { [EOL]                 boolean assignedToUnknownValue = false; [EOL]                 boolean hasPropertyAssign = false; [EOL]                 if (var.getParentNode().isVar() && !NodeUtil.isForIn(var.getParentNode().getParent())) { [EOL]                     Node value = var.getInitialValue(); [EOL]                     assignedToUnknownValue = value != null && !NodeUtil.isLiteralValue(value, true); [EOL]                 } else { [EOL]                     assignedToUnknownValue = true; [EOL]                 } [EOL]                 boolean maybeEscaped = false; [EOL]                 for (Assign assign : assignsByVar.get(var)) { [EOL]                     if (assign.isPropertyAssign) { [EOL]                         hasPropertyAssign = true; [EOL]                     } else if (!NodeUtil.isLiteralValue(assign.assignNode.getLastChild(), true)) { [EOL]                         assignedToUnknownValue = true; [EOL]                     } [EOL]                     if (assign.maybeAliased) { [EOL]                         maybeEscaped = true; [EOL]                     } [EOL]                 } [EOL]                 if ((assignedToUnknownValue || maybeEscaped) && hasPropertyAssign) { [EOL]                     changes = markReferencedVar(var) || changes; [EOL]                     maybeUnreferenced.remove(current); [EOL]                     current--; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } while (changes); [EOL] } <line_num>: 724,773
private void removeAllAssigns(Var var) { [EOL]     for (Assign assign : assignsByVar.get(var)) { [EOL]         assign.remove(); [EOL]         compiler.reportCodeChange(); [EOL]     } [EOL] } <line_num>: 778,783
private boolean markReferencedVar(Var var) { [EOL]     if (referenced.add(var)) { [EOL]         for (Continuation c : continuations.get(var)) { [EOL]             c.apply(); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 790,798
private void removeUnreferencedVars() { [EOL]     CodingConvention convention = codingConvention; [EOL]     for (Iterator<Var> it = maybeUnreferenced.iterator(); it.hasNext(); ) { [EOL]         Var var = it.next(); [EOL]         for (Node exprCallNode : classDefiningCalls.get(var)) { [EOL]             NodeUtil.removeChild(exprCallNode.getParent(), exprCallNode); [EOL]             compiler.reportCodeChange(); [EOL]         } [EOL]         removeAllAssigns(var); [EOL]         compiler.addToDebugLog("Unreferenced var: " + var.name); [EOL]         Node nameNode = var.nameNode; [EOL]         Node toRemove = nameNode.getParent(); [EOL]         Node parent = toRemove.getParent(); [EOL]         Preconditions.checkState(toRemove.isVar() || toRemove.isFunction() || toRemove.isParamList() && parent.isFunction(), "We should only declare vars and functions and function args"); [EOL]         if (toRemove.isParamList() && parent.isFunction()) { [EOL]         } else if (NodeUtil.isFunctionExpression(toRemove)) { [EOL]             if (!preserveFunctionExpressionNames) { [EOL]                 toRemove.getFirstChild().setString(""); [EOL]                 compiler.reportCodeChange(); [EOL]             } [EOL]         } else if (parent != null && parent.isFor() && parent.getChildCount() < 4) { [EOL]         } else if (toRemove.isVar() && nameNode.hasChildren() && NodeUtil.mayHaveSideEffects(nameNode.getFirstChild(), compiler)) { [EOL]             if (toRemove.getChildCount() == 1) { [EOL]                 parent.replaceChild(toRemove, IR.exprResult(nameNode.removeFirstChild())); [EOL]                 compiler.reportCodeChange(); [EOL]             } [EOL]         } else if (toRemove.isVar() && toRemove.getChildCount() > 1) { [EOL]             toRemove.removeChild(nameNode); [EOL]             compiler.reportCodeChange(); [EOL]         } else if (parent != null) { [EOL]             NodeUtil.removeChild(parent, toRemove); [EOL]             compiler.reportCodeChange(); [EOL]         } [EOL]     } [EOL] } <line_num>: 804,870
void apply() { [EOL]     if (NodeUtil.isFunctionDeclaration(node)) { [EOL]         traverseFunction(node, scope); [EOL]     } else { [EOL]         for (Node child = node.getFirstChild(); child != null; child = child.getNext()) { [EOL]             traverseNode(child, node, scope); [EOL]         } [EOL]     } [EOL] } <line_num>: 886,895
static Assign maybeCreateAssign(Node assignNode) { [EOL]     Preconditions.checkState(NodeUtil.isAssignmentOp(assignNode)); [EOL]     boolean isPropAssign = false; [EOL]     Node current = assignNode.getFirstChild(); [EOL]     if (NodeUtil.isGet(current)) { [EOL]         current = current.getFirstChild(); [EOL]         isPropAssign = true; [EOL]         if (current.isGetProp() && current.getLastChild().getString().equals("prototype")) { [EOL]             current = current.getFirstChild(); [EOL]         } [EOL]     } [EOL]     if (current.isName()) { [EOL]         return new Assign(assignNode, current, isPropAssign); [EOL]     } [EOL]     return null; [EOL] } <line_num>: 939,965
void remove() { [EOL]     Node parent = assignNode.getParent(); [EOL]     if (mayHaveSecondarySideEffects) { [EOL]         Node replacement = assignNode.getLastChild().detachFromParent(); [EOL]         for (Node current = assignNode.getFirstChild(); !current.isName(); current = current.getFirstChild()) { [EOL]             if (current.isGetElem()) { [EOL]                 replacement = IR.comma(current.getLastChild().detachFromParent(), replacement); [EOL]                 replacement.copyInformationFrom(current); [EOL]             } [EOL]         } [EOL]         parent.replaceChild(assignNode, replacement); [EOL]     } else { [EOL]         Node gramps = parent.getParent(); [EOL]         if (parent.isExprResult()) { [EOL]             gramps.removeChild(parent); [EOL]         } else { [EOL]             parent.replaceChild(assignNode, assignNode.getLastChild().detachFromParent()); [EOL]         } [EOL]     } [EOL] } <line_num>: 970,996
