public RemovableAssignment(Node nameNode, Node assignNode, NodeTraversal traversal) { [EOL]     this.node = nameNode; [EOL]     this.parent = assignNode; [EOL]     Node ancestor = assignNode; [EOL]     do { [EOL]         ancestor = ancestor.getParent(); [EOL]         assignAncestors.add(ancestor); [EOL]     } while (ancestor.isAssign() && ancestor.getFirstChild().isQualifiedName()); [EOL]     lastAncestor = ancestor.getParent(); [EOL] } <line_num>: 102,114
FindAssertionCalls() { [EOL]     for (AssertionFunctionSpec spec : compiler.getCodingConvention().getAssertionFunctions()) { [EOL]         assertionNames.add(spec.getFunctionName()); [EOL]     } [EOL] } <line_num>: 162,167
ClosureCodeRemoval(AbstractCompiler compiler, boolean removeAbstractMethods, boolean removeAssertionCalls) { [EOL]     this.compiler = compiler; [EOL]     this.removeAbstractMethods = removeAbstractMethods; [EOL]     this.removeAssertionCalls = removeAssertionCalls; [EOL] } <line_num>: 189,194
public void remove() { [EOL]     Node rhs = node.getNext(); [EOL]     Node last = parent; [EOL]     for (Node ancestor : assignAncestors) { [EOL]         if (ancestor.isExprResult()) { [EOL]             lastAncestor.removeChild(ancestor); [EOL]         } else { [EOL]             rhs.detachFromParent(); [EOL]             ancestor.replaceChild(last, rhs); [EOL]         } [EOL]         last = ancestor; [EOL]     } [EOL]     compiler.reportCodeChange(); [EOL] } <line_num>: 119,132
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (n.isAssign()) { [EOL]         Node nameNode = n.getFirstChild(); [EOL]         Node valueNode = n.getLastChild(); [EOL]         if (nameNode.isQualifiedName() && valueNode.isQualifiedName() && ABSTRACT_METHOD_NAME.equals(valueNode.getQualifiedName())) { [EOL]             abstractMethodAssignmentNodes.add(new RemovableAssignment(n.getFirstChild(), n, t)); [EOL]         } [EOL]     } [EOL] } <line_num>: 139,152
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (n.isCall()) { [EOL]         String fnName = n.getFirstChild().getQualifiedName(); [EOL]         if (assertionNames.contains(fnName)) { [EOL]             assertionCalls.add(n); [EOL]         } [EOL]     } [EOL] } <line_num>: 170,178
@Override [EOL] public void process(Node externs, Node root) { [EOL]     List<Callback> passes = Lists.newArrayList(); [EOL]     if (removeAbstractMethods) { [EOL]         passes.add(new FindAbstractMethods()); [EOL]     } [EOL]     if (removeAssertionCalls) { [EOL]         passes.add(new FindAssertionCalls()); [EOL]     } [EOL]     CombinedCompilerPass.traverse(compiler, root, passes); [EOL]     for (RemovableAssignment assignment : abstractMethodAssignmentNodes) { [EOL]         assignment.remove(); [EOL]     } [EOL]     for (Node call : assertionCalls) { [EOL]         Node parent = call.getParent(); [EOL]         if (parent.isExprResult()) { [EOL]             parent.getParent().removeChild(parent); [EOL]         } else { [EOL]             Node firstArg = call.getFirstChild().getNext(); [EOL]             if (firstArg == null) { [EOL]                 parent.replaceChild(call, NodeUtil.newUndefinedNode(call)); [EOL]             } else { [EOL]                 parent.replaceChild(call, firstArg.detachFromParent()); [EOL]             } [EOL]         } [EOL]         compiler.reportCodeChange(); [EOL]     } [EOL] } <line_num>: 196,228
