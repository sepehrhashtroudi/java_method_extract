ExportTestFunctions(AbstractCompiler compiler, String exportSymbolFunction, String exportPropertyFunction) { [EOL]     Preconditions.checkNotNull(compiler); [EOL]     this.compiler = compiler; [EOL]     this.exportSymbolFunction = exportSymbolFunction; [EOL]     this.exportPropertyFunction = exportPropertyFunction; [EOL] } <line_num>: 45,52
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (parent == null) { [EOL]         return; [EOL]     } [EOL]     if (parent.isScript()) { [EOL]         if (NodeUtil.isFunctionDeclaration(n)) { [EOL]             String functionName = NodeUtil.getFunctionName(n); [EOL]             if (isTestFunction(n, functionName)) { [EOL]                 exportTestFunctionAsSymbol(functionName, n, parent); [EOL]             } [EOL]         } else if (isVarDeclaredFunction(n)) { [EOL]             Node functionNode = n.getFirstChild().getFirstChild(); [EOL]             String functionName = NodeUtil.getFunctionName(functionNode); [EOL]             if (isTestFunction(functionNode, functionName)) { [EOL]                 exportTestFunctionAsSymbol(functionName, n, parent); [EOL]             } [EOL]         } [EOL]     } else if (NodeUtil.isExprAssign(parent) && !n.getLastChild().isAssign()) { [EOL]         Node grandparent = parent.getParent(); [EOL]         if (grandparent != null && grandparent.isScript()) { [EOL]             String functionName = n.getFirstChild().getQualifiedName(); [EOL]             if (isTestFunction(n, functionName)) { [EOL]                 exportTestFunctionAsProperty(functionName, parent, n, grandparent); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 57,90
private boolean isVarDeclaredFunction(Node node) { [EOL]     if (!node.isVar()) { [EOL]         return false; [EOL]     } [EOL]     Node grandchild = node.getFirstChild().getFirstChild(); [EOL]     return grandchild != null && grandchild.isFunction(); [EOL] } <line_num>: 103,109
@Override [EOL] public void process(Node externs, Node root) { [EOL]     NodeTraversal.traverse(compiler, root, new ExportTestFunctionsNodes()); [EOL] } <line_num>: 112,115
private void exportTestFunctionAsSymbol(String testFunctionName, Node node, Node scriptNode) { [EOL]     Node exportCallTarget = NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), exportSymbolFunction, node, testFunctionName); [EOL]     Node call = IR.call(exportCallTarget); [EOL]     if (exportCallTarget.isName()) { [EOL]         call.putBooleanProp(Node.FREE_CALL, true); [EOL]     } [EOL]     call.addChildToBack(IR.string(testFunctionName)); [EOL]     call.addChildToBack(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), testFunctionName, node, testFunctionName)); [EOL]     Node expression = IR.exprResult(call); [EOL]     scriptNode.addChildAfter(expression, node); [EOL]     compiler.reportCodeChange(); [EOL] } <line_num>: 118,137
private void exportTestFunctionAsProperty(String fullyQualifiedFunctionName, Node parent, Node node, Node scriptNode) { [EOL]     String testFunctionName = NodeUtil.getPrototypePropertyName(node.getFirstChild()); [EOL]     String objectName = fullyQualifiedFunctionName.substring(0, fullyQualifiedFunctionName.lastIndexOf('.')); [EOL]     String exportCallStr = String.format("%s(%s, '%s', %s);", exportPropertyFunction, objectName, testFunctionName, fullyQualifiedFunctionName); [EOL]     Node exportCall = this.compiler.parseSyntheticCode(exportCallStr).removeChildren(); [EOL]     exportCall.useSourceInfoFromForTree(scriptNode); [EOL]     scriptNode.addChildAfter(exportCall, parent); [EOL]     compiler.reportCodeChange(); [EOL] } <line_num>: 141,158
private boolean isTestFunction(Node n, String functionName) { [EOL]     return !(functionName == null || !TEST_FUNCTIONS_NAME_PATTERN.matcher(functionName).matches()); [EOL] } <line_num>: 170,173
