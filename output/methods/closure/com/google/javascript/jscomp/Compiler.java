public Compiler() { [EOL]     this((PrintStream) null); [EOL] } <line_num>: 229,231
public Compiler(PrintStream stream) { [EOL]     addChangeHandler(recentChange); [EOL]     outStream = stream; [EOL] } <line_num>: 237,240
public Compiler(ErrorManager errorManager) { [EOL]     this(); [EOL]     setErrorManager(errorManager); [EOL] } <line_num>: 245,248
private IntermediateState() { [EOL] } <line_num>: 2295,2295
@Override [EOL] public Thread newThread(Runnable r) { [EOL]     return new Thread(null, r, "jscompiler", COMPILER_STACK_SIZE); [EOL] } <line_num>: 197,199
public void setErrorManager(ErrorManager errorManager) { [EOL]     Preconditions.checkNotNull(errorManager, "the error manager cannot be null"); [EOL]     this.errorManager = errorManager; [EOL] } <line_num>: 255,259
private MessageFormatter createMessageFormatter() { [EOL]     boolean colorize = options.shouldColorizeErrorOutput(); [EOL]     return options.errorFormat.toFormatter(this, colorize); [EOL] } <line_num>: 265,268
public void initOptions(CompilerOptions options) { [EOL]     this.options = options; [EOL]     if (errorManager == null) { [EOL]         if (outStream == null) { [EOL]             setErrorManager(new LoggerErrorManager(createMessageFormatter(), logger)); [EOL]         } else { [EOL]             PrintStreamErrorManager printer = new PrintStreamErrorManager(createMessageFormatter(), outStream); [EOL]             printer.setSummaryDetailLevel(options.summaryDetailLevel); [EOL]             setErrorManager(printer); [EOL]         } [EOL]     } [EOL]     if (options.enables(DiagnosticGroups.CHECK_TYPES)) { [EOL]         options.checkTypes = true; [EOL]     } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) { [EOL]         options.checkTypes = false; [EOL]     } else if (!options.checkTypes) { [EOL]         options.setWarningLevel(DiagnosticGroup.forType(RhinoErrorReporter.TYPE_PARSE_ERROR), CheckLevel.OFF); [EOL]     } [EOL]     if (options.checkGlobalThisLevel.isOn() && !options.disables(DiagnosticGroups.GLOBAL_THIS)) { [EOL]         options.setWarningLevel(DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel); [EOL]     } [EOL]     if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) { [EOL]         options.setWarningLevel(DiagnosticGroups.ES5_STRICT, CheckLevel.ERROR); [EOL]     } [EOL]     List<WarningsGuard> guards = Lists.newArrayList(); [EOL]     guards.add(new SuppressDocWarningsGuard(getDiagnosticGroups().getRegisteredGroups())); [EOL]     guards.add(options.getWarningsGuard()); [EOL]     ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards); [EOL]     if (!options.checkSymbols && !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) { [EOL]         composedGuards.addGuard(new DiagnosticGroupWarningsGuard(DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF)); [EOL]     } [EOL]     this.warningsGuard = composedGuards; [EOL] } <line_num>: 274,337
@Deprecated [EOL] public void init(JSSourceFile[] externs, JSSourceFile[] inputs, CompilerOptions options) { [EOL]     init(Lists.<JSSourceFile>newArrayList(externs), Lists.<JSSourceFile>newArrayList(inputs), options); [EOL] } <line_num>: 343,348
public <T1 extends SourceFile, T2 extends SourceFile> void init(List<T1> externs, List<T2> inputs, CompilerOptions options) { [EOL]     JSModule module = new JSModule(SINGLETON_MODULE_NAME); [EOL]     for (SourceFile input : inputs) { [EOL]         module.add(input); [EOL]     } [EOL]     initModules(externs, Lists.newArrayList(module), options); [EOL] } <line_num>: 353,363
@Deprecated [EOL] public void init(JSSourceFile[] externs, JSModule[] modules, CompilerOptions options) { [EOL]     initModules(Lists.<SourceFile>newArrayList(externs), Lists.<JSModule>newArrayList(modules), options); [EOL] } <line_num>: 370,375
public <T extends SourceFile> void initModules(List<T> externs, List<JSModule> modules, CompilerOptions options) { [EOL]     initOptions(options); [EOL]     checkFirstModule(modules); [EOL]     fillEmptyModules(modules); [EOL]     this.externs = makeCompilerInput(externs, true); [EOL]     this.modules = modules; [EOL]     if (modules.size() > 1) { [EOL]         try { [EOL]             this.moduleGraph = new JSModuleGraph(modules); [EOL]         } catch (JSModuleGraph.ModuleDependenceException e) { [EOL]             report(JSError.make(MODULE_DEPENDENCY_ERROR, e.getModule().getName(), e.getDependentModule().getName())); [EOL]             return; [EOL]         } [EOL]     } else { [EOL]         this.moduleGraph = null; [EOL]     } [EOL]     this.inputs = getAllInputsFromModules(modules); [EOL]     initBasedOnOptions(); [EOL]     initInputsByIdMap(); [EOL] } <line_num>: 381,411
private void initBasedOnOptions() { [EOL]     if (options.sourceMapOutputPath != null) { [EOL]         sourceMap = options.sourceMapFormat.getInstance(); [EOL]         sourceMap.setPrefixMappings(options.sourceMapLocationMappings); [EOL]     } [EOL] } <line_num>: 416,422
private <T extends SourceFile> List<CompilerInput> makeCompilerInput(List<T> files, boolean isExtern) { [EOL]     List<CompilerInput> inputs = Lists.newArrayList(); [EOL]     for (T file : files) { [EOL]         inputs.add(new CompilerInput(file, isExtern)); [EOL]     } [EOL]     return inputs; [EOL] } <line_num>: 424,431
private void checkFirstModule(List<JSModule> modules) { [EOL]     if (modules.isEmpty()) { [EOL]         report(JSError.make(EMPTY_MODULE_LIST_ERROR)); [EOL]     } else if (modules.get(0).getInputs().isEmpty() && modules.size() > 1) { [EOL]         report(JSError.make(EMPTY_ROOT_MODULE_ERROR, modules.get(0).getName())); [EOL]     } [EOL] } <line_num>: 445,453
static String createFillFileName(String moduleName) { [EOL]     return "[" + moduleName + "]"; [EOL] } <line_num>: 459,461
private static void fillEmptyModules(List<JSModule> modules) { [EOL]     for (JSModule module : modules) { [EOL]         if (module.getInputs().isEmpty()) { [EOL]             module.add(SourceFile.fromCode(createFillFileName(module.getName()), "")); [EOL]         } [EOL]     } [EOL] } <line_num>: 467,474
public void rebuildInputsFromModules() { [EOL]     inputs = getAllInputsFromModules(modules); [EOL]     initInputsByIdMap(); [EOL] } <line_num>: 481,484
private static List<CompilerInput> getAllInputsFromModules(List<JSModule> modules) { [EOL]     List<CompilerInput> inputs = Lists.newArrayList(); [EOL]     Map<String, JSModule> inputMap = Maps.newHashMap(); [EOL]     for (JSModule module : modules) { [EOL]         for (CompilerInput input : module.getInputs()) { [EOL]             String inputName = input.getName(); [EOL]             inputs.add(input); [EOL]             inputMap.put(inputName, module); [EOL]         } [EOL]     } [EOL]     return inputs; [EOL] } <line_num>: 490,506
void initInputsByIdMap() { [EOL]     inputsById = new HashMap<InputId, CompilerInput>(); [EOL]     for (CompilerInput input : externs) { [EOL]         InputId id = input.getInputId(); [EOL]         CompilerInput previous = putCompilerInput(id, input); [EOL]         if (previous != null) { [EOL]             report(JSError.make(DUPLICATE_EXTERN_INPUT, input.getName())); [EOL]         } [EOL]     } [EOL]     for (CompilerInput input : inputs) { [EOL]         InputId id = input.getInputId(); [EOL]         CompilerInput previous = putCompilerInput(id, input); [EOL]         if (previous != null) { [EOL]             report(JSError.make(DUPLICATE_INPUT, input.getName())); [EOL]         } [EOL]     } [EOL] } <line_num>: 518,534
public Result compile(SourceFile extern, SourceFile input, CompilerOptions options) { [EOL]     return compile(Lists.newArrayList(extern), Lists.newArrayList(input), options); [EOL] } <line_num>: 536,539
@Deprecated [EOL] public Result compile(SourceFile extern, JSSourceFile[] input, CompilerOptions options) { [EOL]     return compile(Lists.newArrayList(extern), Lists.newArrayList(input), options); [EOL] } <line_num>: 544,548
@Deprecated [EOL] public Result compile(JSSourceFile extern, JSModule[] modules, CompilerOptions options) { [EOL]     return compileModules(Lists.newArrayList(extern), Lists.newArrayList(modules), options); [EOL] } <line_num>: 554,559
@Deprecated [EOL] public Result compile(JSSourceFile[] externs, JSSourceFile[] inputs, CompilerOptions options) { [EOL]     return compile(Lists.<SourceFile>newArrayList(externs), Lists.<SourceFile>newArrayList(inputs), options); [EOL] } <line_num>: 566,573
public <T1 extends SourceFile, T2 extends SourceFile> Result compile(List<T1> externs, List<T2> inputs, CompilerOptions options) { [EOL]     Preconditions.checkState(jsRoot == null); [EOL]     try { [EOL]         init(externs, inputs, options); [EOL]         if (hasErrors()) { [EOL]             return getResult(); [EOL]         } [EOL]         return compile(); [EOL]     } finally { [EOL]         Tracer t = newTracer("generateReport"); [EOL]         errorManager.generateReport(); [EOL]         stopTracer(t, "generateReport"); [EOL]     } [EOL] } <line_num>: 578,594
@Deprecated [EOL] public Result compile(JSSourceFile[] externs, JSModule[] modules, CompilerOptions options) { [EOL]     return compileModules(Lists.<SourceFile>newArrayList(externs), Lists.<JSModule>newArrayList(modules), options); [EOL] } <line_num>: 601,608
public <T extends SourceFile> Result compileModules(List<T> externs, List<JSModule> modules, CompilerOptions options) { [EOL]     Preconditions.checkState(jsRoot == null); [EOL]     try { [EOL]         initModules(externs, modules, options); [EOL]         if (hasErrors()) { [EOL]             return getResult(); [EOL]         } [EOL]         return compile(); [EOL]     } finally { [EOL]         Tracer t = newTracer("generateReport"); [EOL]         errorManager.generateReport(); [EOL]         stopTracer(t, "generateReport"); [EOL]     } [EOL] } <line_num>: 613,629
@Override [EOL] public Result call() throws Exception { [EOL]     compileInternal(); [EOL]     return getResult(); [EOL] } <line_num>: 633,637
private Result compile() { [EOL]     return runInCompilerThread(new Callable<Result>() { [EOL]  [EOL]         @Override [EOL]         public Result call() throws Exception { [EOL]             compileInternal(); [EOL]             return getResult(); [EOL]         } [EOL]     }); [EOL] } <line_num>: 631,639
public void disableThreads() { [EOL]     useThreads = false; [EOL] } <line_num>: 645,647
@Override [EOL] public T call() { [EOL]     try { [EOL]         compilerThread = Thread.currentThread(); [EOL]         if (dumpTraceReport) { [EOL]             Tracer.initCurrentThreadTrace(); [EOL]         } [EOL]         return callable.call(); [EOL]     } catch (Throwable e) { [EOL]         exception[0] = e; [EOL]     } finally { [EOL]         compilerThread = null; [EOL]         if (dumpTraceReport) { [EOL]             Tracer.logAndClearCurrentThreadTrace(); [EOL]             tracker.outputTracerReport(outStream == null ? System.out : outStream); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 655,674
@SuppressWarnings("unchecked") [EOL] <T> T runInCompilerThread(final Callable<T> callable) { [EOL]     final boolean dumpTraceReport = options != null && options.tracer.isOn(); [EOL]     T result = null; [EOL]     final Throwable[] exception = new Throwable[1]; [EOL]     Callable<T> bootCompilerThread = new Callable<T>() { [EOL]  [EOL]         @Override [EOL]         public T call() { [EOL]             try { [EOL]                 compilerThread = Thread.currentThread(); [EOL]                 if (dumpTraceReport) { [EOL]                     Tracer.initCurrentThreadTrace(); [EOL]                 } [EOL]                 return callable.call(); [EOL]             } catch (Throwable e) { [EOL]                 exception[0] = e; [EOL]             } finally { [EOL]                 compilerThread = null; [EOL]                 if (dumpTraceReport) { [EOL]                     Tracer.logAndClearCurrentThreadTrace(); [EOL]                     tracker.outputTracerReport(outStream == null ? System.out : outStream); [EOL]                 } [EOL]             } [EOL]             return null; [EOL]         } [EOL]     }; [EOL]     Preconditions.checkState(compilerThread == null || compilerThread == Thread.currentThread(), "Please do not share the Compiler across threads"); [EOL]     if (useThreads && compilerThread == null) { [EOL]         try { [EOL]             result = compilerExecutor.submit(bootCompilerThread).get(); [EOL]         } catch (InterruptedException e) { [EOL]             throw Throwables.propagate(e); [EOL]         } catch (ExecutionException e) { [EOL]             throw Throwables.propagate(e); [EOL]         } [EOL]     } else { [EOL]         try { [EOL]             result = callable.call(); [EOL]         } catch (Exception e) { [EOL]             exception[0] = e; [EOL]         } [EOL]     } [EOL]     if (exception[0] != null) { [EOL]         throw new RuntimeException(exception[0]); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 649,704
private void compileInternal() { [EOL]     setProgress(0.0, null); [EOL]     parse(); [EOL]     setProgress(0.15, "parse"); [EOL]     if (hasErrors()) { [EOL]         return; [EOL]     } [EOL]     if (!precheck()) { [EOL]         return; [EOL]     } [EOL]     if (options.nameAnonymousFunctionsOnly) { [EOL]         check(); [EOL]         return; [EOL]     } [EOL]     if (!options.skipAllPasses) { [EOL]         check(); [EOL]         if (hasErrors()) { [EOL]             return; [EOL]         } [EOL]         if (options.isExternExportsEnabled() || options.externExportsPath != null) { [EOL]             externExports(); [EOL]         } [EOL]         if (!options.ideMode) { [EOL]             optimize(); [EOL]         } [EOL]     } [EOL]     if (options.recordFunctionInformation) { [EOL]         recordFunctionInformation(); [EOL]     } [EOL]     if (options.devMode == DevMode.START_AND_END) { [EOL]         runSanityCheck(); [EOL]     } [EOL]     setProgress(1.0, "recordFunctionInformation"); [EOL] } <line_num>: 706,751
public void parse() { [EOL]     parseInputs(); [EOL] } <line_num>: 753,755
PassConfig getPassConfig() { [EOL]     if (passes == null) { [EOL]         passes = createPassConfigInternal(); [EOL]     } [EOL]     return passes; [EOL] } <line_num>: 757,762
PassConfig createPassConfigInternal() { [EOL]     return new DefaultPassConfig(options); [EOL] } <line_num>: 768,770
public void setPassConfig(PassConfig passes) { [EOL]     Preconditions.checkNotNull(passes); [EOL]     if (this.passes != null) { [EOL]         throw new IllegalStateException("this.passes has already been assigned"); [EOL]     } [EOL]     this.passes = passes; [EOL] } <line_num>: 777,789
boolean precheck() { [EOL]     return true; [EOL] } <line_num>: 797,799
public void check() { [EOL]     runCustomPasses(CustomPassExecutionTime.BEFORE_CHECKS); [EOL]     PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker, new PhaseOptimizer.ProgressRange(getProgress(), 1.0)); [EOL]     if (options.devMode == DevMode.EVERY_PASS) { [EOL]         phaseOptimizer.setSanityCheck(sanityCheck); [EOL]     } [EOL]     phaseOptimizer.consume(getPassConfig().getChecks()); [EOL]     phaseOptimizer.process(externsRoot, jsRoot); [EOL]     if (hasErrors()) { [EOL]         return; [EOL]     } [EOL]     if (options.nameAnonymousFunctionsOnly) { [EOL]         return; [EOL]     } [EOL]     if (options.removeTryCatchFinally) { [EOL]         removeTryCatchFinally(); [EOL]     } [EOL]     if (options.getTweakProcessing().shouldStrip() || !options.stripTypes.isEmpty() || !options.stripNameSuffixes.isEmpty() || !options.stripTypePrefixes.isEmpty() || !options.stripNamePrefixes.isEmpty()) { [EOL]         stripCode(options.stripTypes, options.stripNameSuffixes, options.stripTypePrefixes, options.stripNamePrefixes); [EOL]     } [EOL]     runCustomPasses(CustomPassExecutionTime.BEFORE_OPTIMIZATIONS); [EOL] } <line_num>: 801,836
private void externExports() { [EOL]     logger.fine("Creating extern file for exports"); [EOL]     startPass("externExports"); [EOL]     ExternExportsPass pass = new ExternExportsPass(this); [EOL]     process(pass); [EOL]     externExports = pass.getGeneratedExterns(); [EOL]     endPass(); [EOL] } <line_num>: 838,848
@Override [EOL] void process(CompilerPass p) { [EOL]     p.process(externsRoot, jsRoot); [EOL] } <line_num>: 850,853
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new SanityCheck(compiler); [EOL] } <line_num>: 857,860
private void maybeSanityCheck() { [EOL]     if (options.devMode == DevMode.EVERY_PASS) { [EOL]         runSanityCheck(); [EOL]     } [EOL] } <line_num>: 863,867
private void runSanityCheck() { [EOL]     sanityCheck.create(this).process(externsRoot, jsRoot); [EOL] } <line_num>: 869,871
void removeTryCatchFinally() { [EOL]     logger.fine("Remove try/catch/finally"); [EOL]     startPass("removeTryCatchFinally"); [EOL]     RemoveTryCatch r = new RemoveTryCatch(this); [EOL]     process(r); [EOL]     endPass(); [EOL] } <line_num>: 876,882
void stripCode(Set<String> stripTypes, Set<String> stripNameSuffixes, Set<String> stripTypePrefixes, Set<String> stripNamePrefixes) { [EOL]     logger.fine("Strip code"); [EOL]     startPass("stripCode"); [EOL]     StripCode r = new StripCode(this, stripTypes, stripNameSuffixes, stripTypePrefixes, stripNamePrefixes); [EOL]     if (options.getTweakProcessing().shouldStrip()) { [EOL]         r.enableTweakStripping(); [EOL]     } [EOL]     process(r); [EOL]     endPass(); [EOL] } <line_num>: 888,899
private void runCustomPasses(CustomPassExecutionTime executionTime) { [EOL]     if (options.customPasses != null) { [EOL]         Tracer t = newTracer("runCustomPasses"); [EOL]         try { [EOL]             for (CompilerPass p : options.customPasses.get(executionTime)) { [EOL]                 process(p); [EOL]             } [EOL]         } finally { [EOL]             stopTracer(t, "runCustomPasses"); [EOL]         } [EOL]     } [EOL] } <line_num>: 904,915
void startPass(String passName) { [EOL]     Preconditions.checkState(currentTracer == null); [EOL]     currentPassName = passName; [EOL]     currentTracer = newTracer(passName); [EOL] } <line_num>: 923,927
void endPass() { [EOL]     Preconditions.checkState(currentTracer != null, "Tracer should not be null at the end of a pass."); [EOL]     stopTracer(currentTracer, currentPassName); [EOL]     String passToCheck = currentPassName; [EOL]     currentPassName = null; [EOL]     currentTracer = null; [EOL]     maybeSanityCheck(); [EOL] } <line_num>: 932,941
Tracer newTracer(String passName) { [EOL]     String comment = passName + (recentChange.hasCodeChanged() ? " on recently changed AST" : ""); [EOL]     if (options.tracer.isOn()) { [EOL]         tracker.recordPassStart(passName); [EOL]     } [EOL]     return new Tracer("Compiler", comment); [EOL] } <line_num>: 946,953
void stopTracer(Tracer t, String passName) { [EOL]     long result = t.stop(); [EOL]     if (options.tracer.isOn()) { [EOL]         tracker.recordPassStop(passName, result); [EOL]     } [EOL] } <line_num>: 955,960
public Result getResult() { [EOL]     PassConfig.State state = getPassConfig().getIntermediateState(); [EOL]     return new Result(getErrors(), getWarnings(), debugLog.toString(), state.variableMap, state.propertyMap, state.anonymousFunctionNameMap, state.stringMap, functionInformationMap, sourceMap, externExports, state.cssNames, state.idGeneratorMap); [EOL] } <line_num>: 965,971
public JSError[] getMessages() { [EOL]     return getErrors(); [EOL] } <line_num>: 976,978
public JSError[] getErrors() { [EOL]     return errorManager.getErrors(); [EOL] } <line_num>: 983,985
public JSError[] getWarnings() { [EOL]     return errorManager.getWarnings(); [EOL] } <line_num>: 990,992
@Override [EOL] public Node getRoot() { [EOL]     return externAndJsRoot; [EOL] } <line_num>: 994,997
private int nextUniqueNameId() { [EOL]     return uniqueNameId++; [EOL] } <line_num>: 1002,1004
@VisibleForTesting [EOL] void resetUniqueNameId() { [EOL]     uniqueNameId = 0; [EOL] } <line_num>: 1009,1012
@Override [EOL] public String get() { [EOL]     return String.valueOf(self.nextUniqueNameId()); [EOL] } <line_num>: 1018,1021
@Override [EOL] Supplier<String> getUniqueNameIdSupplier() { [EOL]     final Compiler self = this; [EOL]     return new Supplier<String>() { [EOL]  [EOL]         @Override [EOL]         public String get() { [EOL]             return String.valueOf(self.nextUniqueNameId()); [EOL]         } [EOL]     }; [EOL] } <line_num>: 1014,1023
@Override [EOL] boolean areNodesEqualForInlining(Node n1, Node n2) { [EOL]     if (options.ambiguateProperties || options.disambiguateProperties) { [EOL]         return n1.isEquivalentToTyped(n2); [EOL]     } else { [EOL]         return n1.isEquivalentTo(n2); [EOL]     } [EOL] } <line_num>: 1025,1035
@Override [EOL] public CompilerInput getInput(InputId id) { [EOL]     return inputsById.get(id); [EOL] } <line_num>: 1044,1047
protected void removeExternInput(InputId id) { [EOL]     CompilerInput input = getInput(id); [EOL]     if (input == null) { [EOL]         return; [EOL]     } [EOL]     Preconditions.checkState(input.isExtern(), "Not an extern input: %s", input.getName()); [EOL]     inputsById.remove(id); [EOL]     externs.remove(input); [EOL]     Node root = input.getAstRoot(this); [EOL]     if (root != null) { [EOL]         root.detachFromParent(); [EOL]     } [EOL] } <line_num>: 1053,1065
@Override [EOL] public CompilerInput newExternInput(String name) { [EOL]     SourceAst ast = new SyntheticAst(name); [EOL]     if (inputsById.containsKey(ast.getInputId())) { [EOL]         throw new IllegalArgumentException("Conflicting externs name: " + name); [EOL]     } [EOL]     CompilerInput input = new CompilerInput(ast, true); [EOL]     putCompilerInput(input.getInputId(), input); [EOL]     externsRoot.addChildToFront(ast.getAstRoot(this)); [EOL]     externs.add(0, input); [EOL]     return input; [EOL] } <line_num>: 1067,1078
private CompilerInput putCompilerInput(InputId id, CompilerInput input) { [EOL]     input.setCompiler(this); [EOL]     return inputsById.put(id, input); [EOL] } <line_num>: 1080,1083
void addIncrementalSourceAst(JsAst ast) { [EOL]     InputId id = ast.getInputId(); [EOL]     Preconditions.checkState(getInput(id) == null, "Duplicate input %s", id.getIdName()); [EOL]     putCompilerInput(id, new CompilerInput(ast)); [EOL] } <line_num>: 1086,1090
boolean replaceIncrementalSourceAst(JsAst ast) { [EOL]     CompilerInput oldInput = getInput(ast.getInputId()); [EOL]     Preconditions.checkNotNull(oldInput, "No input to replace: %s", ast.getInputId().getIdName()); [EOL]     Node newRoot = ast.getAstRoot(this); [EOL]     if (newRoot == null) { [EOL]         return false; [EOL]     } [EOL]     Node oldRoot = oldInput.getAstRoot(this); [EOL]     if (oldRoot != null) { [EOL]         oldRoot.getParent().replaceChild(oldRoot, newRoot); [EOL]     } else { [EOL]         getRoot().getLastChild().addChildToBack(newRoot); [EOL]     } [EOL]     CompilerInput newInput = new CompilerInput(ast); [EOL]     putCompilerInput(ast.getInputId(), newInput); [EOL]     JSModule module = oldInput.getModule(); [EOL]     if (module != null) { [EOL]         module.addAfter(newInput, oldInput); [EOL]         module.remove(oldInput); [EOL]     } [EOL]     Preconditions.checkState(newInput.getInputId().equals(oldInput.getInputId())); [EOL]     InputId inputIdOnAst = newInput.getAstRoot(this).getInputId(); [EOL]     Preconditions.checkState(newInput.getInputId().equals(inputIdOnAst)); [EOL]     inputs.remove(oldInput); [EOL]     return true; [EOL] } <line_num>: 1101,1133
boolean addNewSourceAst(JsAst ast) { [EOL]     CompilerInput oldInput = getInput(ast.getInputId()); [EOL]     if (oldInput != null) { [EOL]         throw new IllegalStateException("Input already exists: " + ast.getInputId().getIdName()); [EOL]     } [EOL]     Node newRoot = ast.getAstRoot(this); [EOL]     if (newRoot == null) { [EOL]         return false; [EOL]     } [EOL]     getRoot().getLastChild().addChildToBack(newRoot); [EOL]     CompilerInput newInput = new CompilerInput(ast); [EOL]     if (moduleGraph == null && !modules.isEmpty()) { [EOL]         modules.get(0).add(newInput); [EOL]     } [EOL]     putCompilerInput(ast.getInputId(), newInput); [EOL]     return true; [EOL] } <line_num>: 1145,1169
@Override [EOL] JSModuleGraph getModuleGraph() { [EOL]     return moduleGraph; [EOL] } <line_num>: 1171,1174
JSModuleGraph getDegenerateModuleGraph() { [EOL]     return moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph; [EOL] } <line_num>: 1180,1182
@Override [EOL] public JSTypeRegistry getTypeRegistry() { [EOL]     if (typeRegistry == null) { [EOL]         typeRegistry = new JSTypeRegistry(oldErrorReporter, options.looseTypes); [EOL]     } [EOL]     return typeRegistry; [EOL] } <line_num>: 1184,1190
@Override [EOL] public MemoizedScopeCreator getTypedScopeCreator() { [EOL]     return getPassConfig().getTypedScopeCreator(); [EOL] } <line_num>: 1192,1195
@SuppressWarnings("unchecked") [EOL] DefaultPassConfig ensureDefaultPassConfig() { [EOL]     PassConfig passes = getPassConfig().getBasePassConfig(); [EOL]     Preconditions.checkState(passes instanceof DefaultPassConfig, "PassConfigs must eventually delegate to the DefaultPassConfig"); [EOL]     return (DefaultPassConfig) passes; [EOL] } <line_num>: 1197,1203
public SymbolTable buildKnownSymbolTable() { [EOL]     SymbolTable symbolTable = new SymbolTable(getTypeRegistry()); [EOL]     MemoizedScopeCreator typedScopeCreator = getTypedScopeCreator(); [EOL]     if (typedScopeCreator != null) { [EOL]         symbolTable.addScopes(typedScopeCreator.getAllMemoizedScopes()); [EOL]         symbolTable.addSymbolsFrom(typedScopeCreator); [EOL]     } else { [EOL]         symbolTable.findScopes(this, externsRoot, jsRoot); [EOL]     } [EOL]     GlobalNamespace globalNamespace = ensureDefaultPassConfig().getGlobalNamespace(); [EOL]     if (globalNamespace != null) { [EOL]         symbolTable.addSymbolsFrom(globalNamespace); [EOL]     } [EOL]     ReferenceCollectingCallback refCollector = new ReferenceCollectingCallback(this, ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR); [EOL]     NodeTraversal.traverse(this, getRoot(), refCollector); [EOL]     symbolTable.addSymbolsFrom(refCollector); [EOL]     PreprocessorSymbolTable preprocessorSymbolTable = ensureDefaultPassConfig().getPreprocessorSymbolTable(); [EOL]     if (preprocessorSymbolTable != null) { [EOL]         symbolTable.addSymbolsFrom(preprocessorSymbolTable); [EOL]     } [EOL]     symbolTable.fillNamespaceReferences(); [EOL]     symbolTable.fillPropertyScopes(); [EOL]     symbolTable.fillThisReferences(this, externsRoot, jsRoot); [EOL]     symbolTable.fillPropertySymbols(this, externsRoot, jsRoot); [EOL]     symbolTable.fillJSDocInfo(this, externsRoot, jsRoot); [EOL]     return symbolTable; [EOL] } <line_num>: 1205,1241
@Override [EOL] public Scope getTopScope() { [EOL]     return getPassConfig().getTopScope(); [EOL] } <line_num>: 1243,1246
@Override [EOL] public ReverseAbstractInterpreter getReverseAbstractInterpreter() { [EOL]     if (abstractInterpreter == null) { [EOL]         ChainableReverseAbstractInterpreter interpreter = new SemanticReverseAbstractInterpreter(getCodingConvention(), getTypeRegistry()); [EOL]         if (options.closurePass) { [EOL]             interpreter = new ClosureReverseAbstractInterpreter(getCodingConvention(), getTypeRegistry()).append(interpreter).getFirst(); [EOL]         } [EOL]         abstractInterpreter = interpreter; [EOL]     } [EOL]     return abstractInterpreter; [EOL] } <line_num>: 1248,1262
@Override [EOL] TypeValidator getTypeValidator() { [EOL]     if (typeValidator == null) { [EOL]         typeValidator = new TypeValidator(this); [EOL]     } [EOL]     return typeValidator; [EOL] } <line_num>: 1264,1270
Node parseInputs() { [EOL]     boolean devMode = options.devMode != DevMode.OFF; [EOL]     if (externsRoot != null) { [EOL]         externsRoot.detachChildren(); [EOL]     } [EOL]     if (jsRoot != null) { [EOL]         jsRoot.detachChildren(); [EOL]     } [EOL]     jsRoot = IR.block(); [EOL]     jsRoot.setIsSyntheticBlock(true); [EOL]     externsRoot = IR.block(); [EOL]     externsRoot.setIsSyntheticBlock(true); [EOL]     externAndJsRoot = IR.block(externsRoot, jsRoot); [EOL]     externAndJsRoot.setIsSyntheticBlock(true); [EOL]     if (options.tracer.isOn()) { [EOL]         tracker = new PerformanceTracker(jsRoot, options.tracer); [EOL]         addChangeHandler(tracker.getCodeChangeHandler()); [EOL]     } [EOL]     Tracer tracer = newTracer("parseInputs"); [EOL]     try { [EOL]         for (CompilerInput input : externs) { [EOL]             Node n = input.getAstRoot(this); [EOL]             if (hasErrors()) { [EOL]                 return null; [EOL]             } [EOL]             externsRoot.addChildToBack(n); [EOL]         } [EOL]         if (options.transformAMDToCJSModules || options.processCommonJSModules) { [EOL]             processAMDAndCommonJSModules(); [EOL]         } [EOL]         hoistExterns(externsRoot); [EOL]         boolean staleInputs = false; [EOL]         if (options.dependencyOptions.needsManagement()) { [EOL]             for (CompilerInput input : inputs) { [EOL]                 for (String provide : input.getProvides()) { [EOL]                     getTypeRegistry().forwardDeclareType(provide); [EOL]                 } [EOL]             } [EOL]             try { [EOL]                 inputs = (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(options.dependencyOptions, inputs); [EOL]                 staleInputs = true; [EOL]             } catch (CircularDependencyException e) { [EOL]                 report(JSError.make(JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage())); [EOL]                 if (hasErrors()) { [EOL]                     return null; [EOL]                 } [EOL]             } catch (MissingProvideException e) { [EOL]                 report(JSError.make(MISSING_ENTRY_ERROR, e.getMessage())); [EOL]                 if (hasErrors()) { [EOL]                     return null; [EOL]                 } [EOL]             } [EOL]         } [EOL]         hoistNoCompileFiles(); [EOL]         if (staleInputs) { [EOL]             repartitionInputs(); [EOL]         } [EOL]         for (CompilerInput input : inputs) { [EOL]             Node n = input.getAstRoot(this); [EOL]             if (n == null) { [EOL]                 continue; [EOL]             } [EOL]             if (devMode) { [EOL]                 runSanityCheck(); [EOL]                 if (hasErrors()) { [EOL]                     return null; [EOL]                 } [EOL]             } [EOL]             if (options.sourceMapOutputPath != null || options.nameReferenceReportPath != null) { [EOL]                 SourceInformationAnnotator sia = new SourceInformationAnnotator(input.getName(), options.devMode != DevMode.OFF); [EOL]                 NodeTraversal.traverse(this, n, sia); [EOL]             } [EOL]             jsRoot.addChildToBack(n); [EOL]         } [EOL]         if (hasErrors()) { [EOL]             return null; [EOL]         } [EOL]         return externAndJsRoot; [EOL]     } finally { [EOL]         stopTracer(tracer, "parseInputs"); [EOL]     } [EOL] } <line_num>: 1282,1404
private void hoistExterns(Node externsRoot) { [EOL]     boolean staleInputs = false; [EOL]     for (CompilerInput input : inputs) { [EOL]         if (options.dependencyOptions.needsManagement()) { [EOL]             if (!input.getProvides().isEmpty() || !input.getRequires().isEmpty()) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         Node n = input.getAstRoot(this); [EOL]         if (n == null) { [EOL]             continue; [EOL]         } [EOL]         JSDocInfo info = n.getJSDocInfo(); [EOL]         if (info != null && info.isExterns()) { [EOL]             externsRoot.addChildToBack(n); [EOL]             input.setIsExtern(true); [EOL]             input.getModule().remove(input); [EOL]             externs.add(input); [EOL]             staleInputs = true; [EOL]         } [EOL]     } [EOL]     if (staleInputs) { [EOL]         repartitionInputs(); [EOL]     } [EOL] } <line_num>: 1409,1445
private void hoistNoCompileFiles() { [EOL]     boolean staleInputs = false; [EOL]     for (CompilerInput input : inputs) { [EOL]         Node n = input.getAstRoot(this); [EOL]         if (n == null) { [EOL]             continue; [EOL]         } [EOL]         JSDocInfo info = n.getJSDocInfo(); [EOL]         if (info != null && info.isNoCompile()) { [EOL]             input.getModule().remove(input); [EOL]             staleInputs = true; [EOL]         } [EOL]     } [EOL]     if (staleInputs) { [EOL]         repartitionInputs(); [EOL]     } [EOL] } <line_num>: 1450,1470
private void repartitionInputs() { [EOL]     fillEmptyModules(modules); [EOL]     rebuildInputsFromModules(); [EOL] } <line_num>: 1472,1475
void processAMDAndCommonJSModules() { [EOL]     Map<String, JSModule> modulesByName = Maps.newLinkedHashMap(); [EOL]     Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap(); [EOL]     for (CompilerInput input : inputs) { [EOL]         input.setCompiler(this); [EOL]         Node root = input.getAstRoot(this); [EOL]         if (root == null) { [EOL]             continue; [EOL]         } [EOL]         if (options.transformAMDToCJSModules) { [EOL]             new TransformAMDToCJSModule(this).process(null, root); [EOL]         } [EOL]         if (options.processCommonJSModules) { [EOL]             ProcessCommonJSModules cjs = new ProcessCommonJSModules(this, options.commonJSModulePathPrefix); [EOL]             cjs.process(null, root); [EOL]             JSModule m = cjs.getModule(); [EOL]             if (m != null) { [EOL]                 modulesByName.put(m.getName(), m); [EOL]                 modulesByInput.put(input, m); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (options.processCommonJSModules) { [EOL]         List<JSModule> modules = Lists.newArrayList(modulesByName.values()); [EOL]         if (!modules.isEmpty()) { [EOL]             this.modules = modules; [EOL]             this.moduleGraph = new JSModuleGraph(this.modules); [EOL]         } [EOL]         for (JSModule module : modules) { [EOL]             for (CompilerInput input : module.getInputs()) { [EOL]                 for (String require : input.getRequires()) { [EOL]                     JSModule dependency = modulesByName.get(require); [EOL]                     if (dependency == null) { [EOL]                         report(JSError.make(MISSING_ENTRY_ERROR, require)); [EOL]                     } else { [EOL]                         module.addDependency(dependency); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         try { [EOL]             modules = Lists.newArrayList(); [EOL]             for (CompilerInput input : this.moduleGraph.manageDependencies(options.dependencyOptions, inputs)) { [EOL]                 modules.add(modulesByInput.get(input)); [EOL]             } [EOL]             JSModule root = new JSModule("root"); [EOL]             for (JSModule m : modules) { [EOL]                 m.addDependency(root); [EOL]             } [EOL]             modules.add(0, root); [EOL]             SortedDependencies<JSModule> sorter = new SortedDependencies<JSModule>(modules); [EOL]             modules = sorter.getDependenciesOf(modules, true); [EOL]             this.modules = modules; [EOL]             this.moduleGraph = new JSModuleGraph(modules); [EOL]         } catch (Exception e) { [EOL]             Throwables.propagate(e); [EOL]         } [EOL]     } [EOL] } <line_num>: 1482,1548
public Node parse(SourceFile file) { [EOL]     initCompilerOptionsIfTesting(); [EOL]     addToDebugLog("Parsing: " + file.getName()); [EOL]     return new JsAst(file).getAstRoot(this); [EOL] } <line_num>: 1550,1554
@Override [EOL] Node parseSyntheticCode(String js) { [EOL]     CompilerInput input = new CompilerInput(SourceFile.fromCode(" [synthetic:" + (++syntheticCodeId) + "] ", js)); [EOL]     putCompilerInput(input.getInputId(), input); [EOL]     return input.getAstRoot(this); [EOL] } <line_num>: 1558,1564
protected CompilerOptions newCompilerOptions() { [EOL]     return new CompilerOptions(); [EOL] } <line_num>: 1569,1571
void initCompilerOptionsIfTesting() { [EOL]     if (options == null) { [EOL]         initOptions(newCompilerOptions()); [EOL]     } [EOL] } <line_num>: 1573,1579
@Override [EOL] Node parseSyntheticCode(String fileName, String js) { [EOL]     initCompilerOptionsIfTesting(); [EOL]     return parse(SourceFile.fromCode(fileName, js)); [EOL] } <line_num>: 1581,1585
@Override [EOL] Node parseTestCode(String js) { [EOL]     initCompilerOptionsIfTesting(); [EOL]     CompilerInput input = new CompilerInput(SourceFile.fromCode("[testcode]", js)); [EOL]     if (inputsById == null) { [EOL]         inputsById = Maps.newHashMap(); [EOL]     } [EOL]     putCompilerInput(input.getInputId(), input); [EOL]     return input.getAstRoot(this); [EOL] } <line_num>: 1587,1597
@Override [EOL] ErrorReporter getDefaultErrorReporter() { [EOL]     return defaultErrorReporter; [EOL] } <line_num>: 1599,1602
@Override [EOL] public String call() throws Exception { [EOL]     Tracer tracer = newTracer("toSource"); [EOL]     try { [EOL]         CodeBuilder cb = new CodeBuilder(); [EOL]         if (jsRoot != null) { [EOL]             int i = 0; [EOL]             for (Node scriptNode = jsRoot.getFirstChild(); scriptNode != null; scriptNode = scriptNode.getNext()) { [EOL]                 toSource(cb, i++, scriptNode); [EOL]             } [EOL]         } [EOL]         return cb.toString(); [EOL]     } finally { [EOL]         stopTracer(tracer, "toSource"); [EOL]     } [EOL] } <line_num>: 1613,1630
public String toSource() { [EOL]     return runInCompilerThread(new Callable<String>() { [EOL]  [EOL]         @Override [EOL]         public String call() throws Exception { [EOL]             Tracer tracer = newTracer("toSource"); [EOL]             try { [EOL]                 CodeBuilder cb = new CodeBuilder(); [EOL]                 if (jsRoot != null) { [EOL]                     int i = 0; [EOL]                     for (Node scriptNode = jsRoot.getFirstChild(); scriptNode != null; scriptNode = scriptNode.getNext()) { [EOL]                         toSource(cb, i++, scriptNode); [EOL]                     } [EOL]                 } [EOL]                 return cb.toString(); [EOL]             } finally { [EOL]                 stopTracer(tracer, "toSource"); [EOL]             } [EOL]         } [EOL]     }); [EOL] } <line_num>: 1611,1632
@Override [EOL] public String[] call() throws Exception { [EOL]     Tracer tracer = newTracer("toSourceArray"); [EOL]     try { [EOL]         int numInputs = inputs.size(); [EOL]         String[] sources = new String[numInputs]; [EOL]         CodeBuilder cb = new CodeBuilder(); [EOL]         for (int i = 0; i < numInputs; i++) { [EOL]             Node scriptNode = inputs.get(i).getAstRoot(Compiler.this); [EOL]             cb.reset(); [EOL]             toSource(cb, i, scriptNode); [EOL]             sources[i] = cb.toString(); [EOL]         } [EOL]         return sources; [EOL]     } finally { [EOL]         stopTracer(tracer, "toSourceArray"); [EOL]     } [EOL] } <line_num>: 1639,1656
public String[] toSourceArray() { [EOL]     return runInCompilerThread(new Callable<String[]>() { [EOL]  [EOL]         @Override [EOL]         public String[] call() throws Exception { [EOL]             Tracer tracer = newTracer("toSourceArray"); [EOL]             try { [EOL]                 int numInputs = inputs.size(); [EOL]                 String[] sources = new String[numInputs]; [EOL]                 CodeBuilder cb = new CodeBuilder(); [EOL]                 for (int i = 0; i < numInputs; i++) { [EOL]                     Node scriptNode = inputs.get(i).getAstRoot(Compiler.this); [EOL]                     cb.reset(); [EOL]                     toSource(cb, i, scriptNode); [EOL]                     sources[i] = cb.toString(); [EOL]                 } [EOL]                 return sources; [EOL]             } finally { [EOL]                 stopTracer(tracer, "toSourceArray"); [EOL]             } [EOL]         } [EOL]     }); [EOL] } <line_num>: 1637,1658
@Override [EOL] public String call() throws Exception { [EOL]     List<CompilerInput> inputs = module.getInputs(); [EOL]     int numInputs = inputs.size(); [EOL]     if (numInputs == 0) { [EOL]         return ""; [EOL]     } [EOL]     CodeBuilder cb = new CodeBuilder(); [EOL]     for (int i = 0; i < numInputs; i++) { [EOL]         Node scriptNode = inputs.get(i).getAstRoot(Compiler.this); [EOL]         if (scriptNode == null) { [EOL]             throw new IllegalArgumentException("Bad module: " + module.getName()); [EOL]         } [EOL]         toSource(cb, i, scriptNode); [EOL]     } [EOL]     return cb.toString(); [EOL] } <line_num>: 1665,1682
public String toSource(final JSModule module) { [EOL]     return runInCompilerThread(new Callable<String>() { [EOL]  [EOL]         @Override [EOL]         public String call() throws Exception { [EOL]             List<CompilerInput> inputs = module.getInputs(); [EOL]             int numInputs = inputs.size(); [EOL]             if (numInputs == 0) { [EOL]                 return ""; [EOL]             } [EOL]             CodeBuilder cb = new CodeBuilder(); [EOL]             for (int i = 0; i < numInputs; i++) { [EOL]                 Node scriptNode = inputs.get(i).getAstRoot(Compiler.this); [EOL]                 if (scriptNode == null) { [EOL]                     throw new IllegalArgumentException("Bad module: " + module.getName()); [EOL]                 } [EOL]                 toSource(cb, i, scriptNode); [EOL]             } [EOL]             return cb.toString(); [EOL]         } [EOL]     }); [EOL] } <line_num>: 1663,1684
@Override [EOL] public String[] call() throws Exception { [EOL]     List<CompilerInput> inputs = module.getInputs(); [EOL]     int numInputs = inputs.size(); [EOL]     if (numInputs == 0) { [EOL]         return new String[0]; [EOL]     } [EOL]     String[] sources = new String[numInputs]; [EOL]     CodeBuilder cb = new CodeBuilder(); [EOL]     for (int i = 0; i < numInputs; i++) { [EOL]         Node scriptNode = inputs.get(i).getAstRoot(Compiler.this); [EOL]         if (scriptNode == null) { [EOL]             throw new IllegalArgumentException("Bad module input: " + inputs.get(i).getName()); [EOL]         } [EOL]         cb.reset(); [EOL]         toSource(cb, i, scriptNode); [EOL]         sources[i] = cb.toString(); [EOL]     } [EOL]     return sources; [EOL] } <line_num>: 1692,1714
public String[] toSourceArray(final JSModule module) { [EOL]     return runInCompilerThread(new Callable<String[]>() { [EOL]  [EOL]         @Override [EOL]         public String[] call() throws Exception { [EOL]             List<CompilerInput> inputs = module.getInputs(); [EOL]             int numInputs = inputs.size(); [EOL]             if (numInputs == 0) { [EOL]                 return new String[0]; [EOL]             } [EOL]             String[] sources = new String[numInputs]; [EOL]             CodeBuilder cb = new CodeBuilder(); [EOL]             for (int i = 0; i < numInputs; i++) { [EOL]                 Node scriptNode = inputs.get(i).getAstRoot(Compiler.this); [EOL]                 if (scriptNode == null) { [EOL]                     throw new IllegalArgumentException("Bad module input: " + inputs.get(i).getName()); [EOL]                 } [EOL]                 cb.reset(); [EOL]                 toSource(cb, i, scriptNode); [EOL]                 sources[i] = cb.toString(); [EOL]             } [EOL]             return sources; [EOL]         } [EOL]     }); [EOL] } <line_num>: 1690,1716
@Override [EOL] public Void call() throws Exception { [EOL]     if (options.printInputDelimiter) { [EOL]         if ((cb.getLength() > 0) && !cb.endsWith("\n")) { [EOL]             cb.append("\n"); [EOL]         } [EOL]         Preconditions.checkState(root.isScript()); [EOL]         String delimiter = options.inputDelimiter; [EOL]         String inputName = root.getInputId().getIdName(); [EOL]         String sourceName = root.getSourceFileName(); [EOL]         Preconditions.checkState(sourceName != null); [EOL]         Preconditions.checkState(!sourceName.isEmpty()); [EOL]         delimiter = delimiter.replaceAll("%name%", Matcher.quoteReplacement(inputName)).replaceAll("%num%", String.valueOf(inputSeqNum)); [EOL]         cb.append(delimiter).append("\n"); [EOL]     } [EOL]     if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) { [EOL]         cb.append("/*\n").append(root.getJSDocInfo().getLicense()).append("*/\n"); [EOL]     } [EOL]     if (options.sourceMapOutputPath != null) { [EOL]         sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex()); [EOL]     } [EOL]     String code = toSource(root, sourceMap, inputSeqNum == 0); [EOL]     if (!code.isEmpty()) { [EOL]         cb.append(code); [EOL]         int length = code.length(); [EOL]         char lastChar = code.charAt(length - 1); [EOL]         char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\0'; [EOL]         boolean hasSemiColon = lastChar == ';' || (lastChar == '\n' && secondLastChar == ';'); [EOL]         if (!hasSemiColon) { [EOL]             cb.append(";"); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 1729,1785
public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) { [EOL]     runInCompilerThread(new Callable<Void>() { [EOL]  [EOL]         @Override [EOL]         public Void call() throws Exception { [EOL]             if (options.printInputDelimiter) { [EOL]                 if ((cb.getLength() > 0) && !cb.endsWith("\n")) { [EOL]                     cb.append("\n"); [EOL]                 } [EOL]                 Preconditions.checkState(root.isScript()); [EOL]                 String delimiter = options.inputDelimiter; [EOL]                 String inputName = root.getInputId().getIdName(); [EOL]                 String sourceName = root.getSourceFileName(); [EOL]                 Preconditions.checkState(sourceName != null); [EOL]                 Preconditions.checkState(!sourceName.isEmpty()); [EOL]                 delimiter = delimiter.replaceAll("%name%", Matcher.quoteReplacement(inputName)).replaceAll("%num%", String.valueOf(inputSeqNum)); [EOL]                 cb.append(delimiter).append("\n"); [EOL]             } [EOL]             if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) { [EOL]                 cb.append("/*\n").append(root.getJSDocInfo().getLicense()).append("*/\n"); [EOL]             } [EOL]             if (options.sourceMapOutputPath != null) { [EOL]                 sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex()); [EOL]             } [EOL]             String code = toSource(root, sourceMap, inputSeqNum == 0); [EOL]             if (!code.isEmpty()) { [EOL]                 cb.append(code); [EOL]                 int length = code.length(); [EOL]                 char lastChar = code.charAt(length - 1); [EOL]                 char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\0'; [EOL]                 boolean hasSemiColon = lastChar == ';' || (lastChar == '\n' && secondLastChar == ';'); [EOL]                 if (!hasSemiColon) { [EOL]                     cb.append(";"); [EOL]                 } [EOL]             } [EOL]             return null; [EOL]         } [EOL]     }); [EOL] } <line_num>: 1725,1787
@Override [EOL] String toSource(Node n) { [EOL]     initCompilerOptionsIfTesting(); [EOL]     return toSource(n, null, true); [EOL] } <line_num>: 1793,1797
private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) { [EOL]     CodePrinter.Builder builder = new CodePrinter.Builder(n); [EOL]     builder.setCompilerOptions(options); [EOL]     builder.setSourceMap(sourceMap); [EOL]     builder.setTagAsStrict(firstOutput && options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT); [EOL]     return builder.build(); [EOL] } <line_num>: 1802,1809
void reset() { [EOL]     sb.setLength(0); [EOL] } <line_num>: 1821,1823
CodeBuilder append(String str) { [EOL]     sb.append(str); [EOL]     int index = -1; [EOL]     int lastIndex = index; [EOL]     while ((index = str.indexOf('\n', index + 1)) >= 0) { [EOL]         ++lineCount; [EOL]         lastIndex = index; [EOL]     } [EOL]     if (lastIndex == -1) { [EOL]         colCount += str.length(); [EOL]     } else { [EOL]         colCount = str.length() - (lastIndex + 1); [EOL]     } [EOL]     return this; [EOL] } <line_num>: 1826,1845
@Override [EOL] public String toString() { [EOL]     return sb.toString(); [EOL] } <line_num>: 1848,1851
public int getLength() { [EOL]     return sb.length(); [EOL] } <line_num>: 1854,1856
int getLineIndex() { [EOL]     return lineCount; [EOL] } <line_num>: 1859,1861
int getColumnIndex() { [EOL]     return colCount; [EOL] } <line_num>: 1864,1866
boolean endsWith(String suffix) { [EOL]     return (sb.length() > suffix.length()) && suffix.equals(sb.substring(sb.length() - suffix.length())); [EOL] } <line_num>: 1869,1872
public void optimize() { [EOL]     normalize(); [EOL]     PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker, null); [EOL]     if (options.devMode == DevMode.EVERY_PASS) { [EOL]         phaseOptimizer.setSanityCheck(sanityCheck); [EOL]     } [EOL]     phaseOptimizer.consume(getPassConfig().getOptimizations()); [EOL]     phaseOptimizer.process(externsRoot, jsRoot); [EOL] } <line_num>: 1879,1893
@Override [EOL] void setCssRenamingMap(CssRenamingMap map) { [EOL]     options.cssRenamingMap = map; [EOL] } <line_num>: 1895,1898
@Override [EOL] CssRenamingMap getCssRenamingMap() { [EOL]     return options.cssRenamingMap; [EOL] } <line_num>: 1900,1903
public void processDefines() { [EOL]     (new DefaultPassConfig(options)).processDefines.create(this).process(externsRoot, jsRoot); [EOL] } <line_num>: 1912,1915
boolean isInliningForbidden() { [EOL]     return options.propertyRenaming == PropertyRenamingPolicy.HEURISTIC || options.propertyRenaming == PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC; [EOL] } <line_num>: 1917,1921
ControlFlowGraph<Node> computeCFG() { [EOL]     logger.fine("Computing Control Flow Graph"); [EOL]     Tracer tracer = newTracer("computeCFG"); [EOL]     ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false); [EOL]     process(cfa); [EOL]     stopTracer(tracer, "computeCFG"); [EOL]     return cfa.getCfg(); [EOL] } <line_num>: 1924,1931
public void normalize() { [EOL]     logger.fine("Normalizing"); [EOL]     startPass("normalize"); [EOL]     process(new Normalize(this, false)); [EOL]     endPass(); [EOL] } <line_num>: 1933,1938
@Override [EOL] void prepareAst(Node root) { [EOL]     CompilerPass pass = new PrepareAst(this); [EOL]     pass.process(null, root); [EOL] } <line_num>: 1940,1944
void recordFunctionInformation() { [EOL]     logger.fine("Recording function information"); [EOL]     startPass("recordFunctionInformation"); [EOL]     RecordFunctionInformation recordFunctionInfoPass = new RecordFunctionInformation(this, getPassConfig().getIntermediateState().functionNames); [EOL]     process(recordFunctionInfoPass); [EOL]     functionInformationMap = recordFunctionInfoPass.getMap(); [EOL]     endPass(); [EOL] } <line_num>: 1946,1955
@Override [EOL] void addChangeHandler(CodeChangeHandler handler) { [EOL]     codeChangeHandlers.add(handler); [EOL] } <line_num>: 1967,1970
@Override [EOL] void removeChangeHandler(CodeChangeHandler handler) { [EOL]     codeChangeHandlers.remove(handler); [EOL] } <line_num>: 1972,1975
@Override [EOL] public void reportCodeChange() { [EOL]     for (CodeChangeHandler handler : codeChangeHandlers) { [EOL]         handler.reportChange(); [EOL]     } [EOL] } <line_num>: 1982,1987
@Override [EOL] public CodingConvention getCodingConvention() { [EOL]     CodingConvention convention = options.getCodingConvention(); [EOL]     convention = convention != null ? convention : defaultCodingConvention; [EOL]     return convention; [EOL] } <line_num>: 1989,1994
@Override [EOL] public boolean isIdeMode() { [EOL]     return options.ideMode; [EOL] } <line_num>: 1996,1999
@Override [EOL] public boolean acceptEcmaScript5() { [EOL]     switch(options.getLanguageIn()) { [EOL]         case ECMASCRIPT5: [EOL]         case ECMASCRIPT5_STRICT: [EOL]             return true; [EOL]         case ECMASCRIPT3: [EOL]             return false; [EOL]     } [EOL]     throw new IllegalStateException("unexpected language mode"); [EOL] } <line_num>: 2001,2011
public LanguageMode languageMode() { [EOL]     return options.getLanguageIn(); [EOL] } <line_num>: 2013,2015
@Override [EOL] public boolean acceptConstKeyword() { [EOL]     return options.acceptConstKeyword; [EOL] } <line_num>: 2017,2020
@Override [EOL] Config getParserConfig() { [EOL]     if (parserConfig == null) { [EOL]         Config.LanguageMode mode; [EOL]         switch(options.getLanguageIn()) { [EOL]             case ECMASCRIPT3: [EOL]                 mode = Config.LanguageMode.ECMASCRIPT3; [EOL]                 break; [EOL]             case ECMASCRIPT5: [EOL]                 mode = Config.LanguageMode.ECMASCRIPT5; [EOL]                 break; [EOL]             case ECMASCRIPT5_STRICT: [EOL]                 mode = Config.LanguageMode.ECMASCRIPT5_STRICT; [EOL]                 break; [EOL]             default: [EOL]                 throw new IllegalStateException("unexpected language mode"); [EOL]         } [EOL]         parserConfig = ParserRunner.createConfig(isIdeMode(), mode, acceptConstKeyword(), options.extraAnnotationNames); [EOL]     } [EOL]     return parserConfig; [EOL] } <line_num>: 2022,2047
@Override [EOL] public boolean isTypeCheckingEnabled() { [EOL]     return options.checkTypes; [EOL] } <line_num>: 2049,2052
protected DiagnosticGroups getDiagnosticGroups() { [EOL]     return new DiagnosticGroups(); [EOL] } <line_num>: 2063,2065
@Override [EOL] public void report(JSError error) { [EOL]     CheckLevel level = error.getDefaultLevel(); [EOL]     if (warningsGuard != null) { [EOL]         CheckLevel newLevel = warningsGuard.level(error); [EOL]         if (newLevel != null) { [EOL]             level = newLevel; [EOL]         } [EOL]     } [EOL]     if (level.isOn()) { [EOL]         if (getOptions().errorHandler != null) { [EOL]             getOptions().errorHandler.report(level, error); [EOL]         } [EOL]         errorManager.report(level, error); [EOL]     } [EOL] } <line_num>: 2067,2083
@Override [EOL] public CheckLevel getErrorLevel(JSError error) { [EOL]     Preconditions.checkNotNull(options); [EOL]     return warningsGuard.level(error); [EOL] } <line_num>: 2085,2089
@Override [EOL] void throwInternalError(String message, Exception cause) { [EOL]     String finalMessage = "INTERNAL COMPILER ERROR.\n" + "Please report this problem.\n" + message; [EOL]     RuntimeException e = new RuntimeException(finalMessage, cause); [EOL]     if (cause != null) { [EOL]         e.setStackTrace(cause.getStackTrace()); [EOL]     } [EOL]     throw e; [EOL] } <line_num>: 2094,2105
public int getErrorCount() { [EOL]     return errorManager.getErrorCount(); [EOL] } <line_num>: 2111,2113
public int getWarningCount() { [EOL]     return errorManager.getWarningCount(); [EOL] } <line_num>: 2118,2120
@Override [EOL] boolean hasHaltingErrors() { [EOL]     return !isIdeMode() && getErrorCount() > 0; [EOL] } <line_num>: 2122,2125
public boolean hasErrors() { [EOL]     return hasHaltingErrors(); [EOL] } <line_num>: 2136,2138
@Override [EOL] void addToDebugLog(String str) { [EOL]     debugLog.append(str); [EOL]     debugLog.append('\n'); [EOL]     logger.fine(str); [EOL] } <line_num>: 2141,2146
@Override [EOL] SourceFile getSourceFileByName(String sourceName) { [EOL]     if (sourceName != null) { [EOL]         CompilerInput input = inputsById.get(new InputId(sourceName)); [EOL]         if (input != null) { [EOL]             return input.getSourceFile(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 2148,2159
@Override [EOL] public String getSourceLine(String sourceName, int lineNumber) { [EOL]     if (lineNumber < 1) { [EOL]         return null; [EOL]     } [EOL]     SourceFile input = getSourceFileByName(sourceName); [EOL]     if (input != null) { [EOL]         return input.getLine(lineNumber); [EOL]     } [EOL]     return null; [EOL] } <line_num>: 2161,2171
@Override [EOL] public Region getSourceRegion(String sourceName, int lineNumber) { [EOL]     if (lineNumber < 1) { [EOL]         return null; [EOL]     } [EOL]     SourceFile input = getSourceFileByName(sourceName); [EOL]     if (input != null) { [EOL]         return input.getRegion(lineNumber); [EOL]     } [EOL]     return null; [EOL] } <line_num>: 2173,2183
@Override [EOL] Node getNodeForCodeInsertion(JSModule module) { [EOL]     if (module == null) { [EOL]         if (inputs.isEmpty()) { [EOL]             throw new IllegalStateException("No inputs"); [EOL]         } [EOL]         return inputs.get(0).getAstRoot(this); [EOL]     } [EOL]     List<CompilerInput> moduleInputs = module.getInputs(); [EOL]     if (moduleInputs.size() > 0) { [EOL]         return moduleInputs.get(0).getAstRoot(this); [EOL]     } [EOL]     throw new IllegalStateException("Root module has no inputs"); [EOL] } <line_num>: 2189,2204
public SourceMap getSourceMap() { [EOL]     return sourceMap; [EOL] } <line_num>: 2206,2208
VariableMap getVariableMap() { [EOL]     return getPassConfig().getIntermediateState().variableMap; [EOL] } <line_num>: 2210,2212
VariableMap getPropertyMap() { [EOL]     return getPassConfig().getIntermediateState().propertyMap; [EOL] } <line_num>: 2214,2216
CompilerOptions getOptions() { [EOL]     return options; [EOL] } <line_num>: 2218,2220
FunctionInformationMap getFunctionalInformationMap() { [EOL]     return functionInformationMap; [EOL] } <line_num>: 2222,2224
public static void setLoggingLevel(Level level) { [EOL]     logger.setLevel(level); [EOL] } <line_num>: 2229,2231
public String getAstDotGraph() throws IOException { [EOL]     if (jsRoot != null) { [EOL]         ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false); [EOL]         cfa.process(null, jsRoot); [EOL]         return DotFormatter.toDot(jsRoot, cfa.getCfg()); [EOL]     } else { [EOL]         return ""; [EOL]     } [EOL] } <line_num>: 2234,2242
@Override [EOL] public ErrorManager getErrorManager() { [EOL]     if (options == null) { [EOL]         initOptions(newCompilerOptions()); [EOL]     } [EOL]     return errorManager; [EOL] } <line_num>: 2244,2250
@Override [EOL] List<CompilerInput> getInputsInOrder() { [EOL]     return Collections.<CompilerInput>unmodifiableList(inputs); [EOL] } <line_num>: 2252,2255
public Map<InputId, CompilerInput> getInputsById() { [EOL]     return Collections.unmodifiableMap(inputsById); [EOL] } <line_num>: 2260,2262
List<CompilerInput> getExternsInOrder() { [EOL]     return Collections.<CompilerInput>unmodifiableList(externs); [EOL] } <line_num>: 2267,2269
public IntermediateState getState() { [EOL]     IntermediateState state = new IntermediateState(); [EOL]     state.externsRoot = externsRoot; [EOL]     state.jsRoot = jsRoot; [EOL]     state.externs = externs; [EOL]     state.inputs = inputs; [EOL]     state.modules = modules; [EOL]     state.passConfigState = getPassConfig().getIntermediateState(); [EOL]     state.typeRegistry = typeRegistry; [EOL]     state.lifeCycleStage = getLifeCycleStage(); [EOL]     state.injectedLibraries = Maps.newLinkedHashMap(injectedLibraries); [EOL]     return state; [EOL] } <line_num>: 2301,2314
public void setState(IntermediateState state) { [EOL]     externsRoot = state.externsRoot; [EOL]     jsRoot = state.jsRoot; [EOL]     externs = state.externs; [EOL]     inputs = state.inputs; [EOL]     modules = state.modules; [EOL]     passes = createPassConfigInternal(); [EOL]     getPassConfig().setIntermediateState(state.passConfigState); [EOL]     typeRegistry = state.typeRegistry; [EOL]     setLifeCycleStage(state.lifeCycleStage); [EOL]     injectedLibraries.clear(); [EOL]     injectedLibraries.putAll(state.injectedLibraries); [EOL] } <line_num>: 2320,2333
@VisibleForTesting [EOL] List<CompilerInput> getInputsForTesting() { [EOL]     return inputs; [EOL] } <line_num>: 2335,2338
@VisibleForTesting [EOL] List<CompilerInput> getExternsForTesting() { [EOL]     return externs; [EOL] } <line_num>: 2340,2343
@Override [EOL] boolean hasRegExpGlobalReferences() { [EOL]     return hasRegExpGlobalReferences; [EOL] } <line_num>: 2345,2348
@Override [EOL] void setHasRegExpGlobalReferences(boolean references) { [EOL]     hasRegExpGlobalReferences = references; [EOL] } <line_num>: 2350,2353
@Override [EOL] void updateGlobalVarReferences(Map<Var, ReferenceCollection> refMapPatch, Node collectionRoot) { [EOL]     Preconditions.checkState(collectionRoot.isScript() || collectionRoot.isBlock()); [EOL]     if (globalRefMap == null) { [EOL]         globalRefMap = new GlobalVarReferenceMap(getInputsInOrder(), getExternsInOrder()); [EOL]     } [EOL]     globalRefMap.updateGlobalVarReferences(refMapPatch, collectionRoot); [EOL] } <line_num>: 2355,2365
@Override [EOL] GlobalVarReferenceMap getGlobalVarReferences() { [EOL]     return globalRefMap; [EOL] } <line_num>: 2367,2370
@Override [EOL] CompilerInput getSynthesizedExternsInput() { [EOL]     if (synthesizedExternsInput == null) { [EOL]         synthesizedExternsInput = newExternInput(SYNTHETIC_EXTERNS); [EOL]     } [EOL]     return synthesizedExternsInput; [EOL] } <line_num>: 2372,2378
@Override [EOL] public double getProgress() { [EOL]     return progress; [EOL] } <line_num>: 2380,2383
@Override [EOL] String getLastPassName() { [EOL]     return lastPassName; [EOL] } <line_num>: 2385,2388
@Override [EOL] void setProgress(double newProgress, String passName) { [EOL]     this.lastPassName = passName; [EOL]     if (newProgress > 1.0) { [EOL]         progress = 1.0; [EOL]     } else { [EOL]         progress = newProgress; [EOL]     } [EOL] } <line_num>: 2390,2398
public void replaceScript(JsAst ast) { [EOL]     CompilerInput input = this.getInput(ast.getInputId()); [EOL]     if (!replaceIncrementalSourceAst(ast)) { [EOL]         return; [EOL]     } [EOL]     Node originalRoot = input.getAstRoot(this); [EOL]     processNewScript(ast, originalRoot); [EOL] } <line_num>: 2407,2415
public void addNewScript(JsAst ast) { [EOL]     if (!addNewSourceAst(ast)) { [EOL]         return; [EOL]     } [EOL]     Node emptyScript = new Node(Token.SCRIPT); [EOL]     InputId inputId = ast.getInputId(); [EOL]     emptyScript.setInputId(inputId); [EOL]     emptyScript.setStaticSourceFile(SourceFile.fromCode(inputId.getIdName(), "")); [EOL]     processNewScript(ast, emptyScript); [EOL] } <line_num>: 2424,2435
private void processNewScript(JsAst ast, Node originalRoot) { [EOL]     Node js = ast.getAstRoot(this); [EOL]     Preconditions.checkNotNull(js); [EOL]     runHotSwap(originalRoot, js, this.getCleanupPassConfig()); [EOL]     runHotSwapPass(null, null, ensureDefaultPassConfig().garbageCollectChecks); [EOL]     this.getTypeRegistry().clearNamedTypes(); [EOL]     this.removeSyntheticVarsInput(); [EOL]     runHotSwap(originalRoot, js, this.ensureDefaultPassConfig()); [EOL] } <line_num>: 2437,2450
private void runHotSwap(Node originalRoot, Node js, PassConfig passConfig) { [EOL]     for (PassFactory passFactory : passConfig.getChecks()) { [EOL]         runHotSwapPass(originalRoot, js, passFactory); [EOL]     } [EOL] } <line_num>: 2455,2460
private void runHotSwapPass(Node originalRoot, Node js, PassFactory passFactory) { [EOL]     HotSwapCompilerPass pass = passFactory.getHotSwapPass(this); [EOL]     if (pass != null) { [EOL]         logger.info("Performing HotSwap for pass " + passFactory.getName()); [EOL]         pass.hotSwapScript(js, originalRoot); [EOL]     } [EOL] } <line_num>: 2462,2469
private PassConfig getCleanupPassConfig() { [EOL]     return new CleanupPasses(getOptions()); [EOL] } <line_num>: 2471,2473
private void removeSyntheticVarsInput() { [EOL]     String sourceName = Compiler.SYNTHETIC_EXTERNS; [EOL]     removeExternInput(new InputId(sourceName)); [EOL] } <line_num>: 2475,2478
@Override [EOL] Node ensureLibraryInjected(String resourceName) { [EOL]     if (injectedLibraries.containsKey(resourceName)) { [EOL]         return null; [EOL]     } [EOL]     boolean isBase = "base".equals(resourceName); [EOL]     if (!isBase) { [EOL]         ensureLibraryInjected("base"); [EOL]     } [EOL]     Node firstChild = loadLibraryCode(resourceName).removeChildren(); [EOL]     Node lastChild = firstChild.getLastSibling(); [EOL]     Node parent = getNodeForCodeInsertion(null); [EOL]     if (isBase) { [EOL]         parent.addChildrenToFront(firstChild); [EOL]     } else { [EOL]         parent.addChildrenAfter(firstChild, injectedLibraries.get("base")); [EOL]     } [EOL]     reportCodeChange(); [EOL]     injectedLibraries.put(resourceName, lastChild); [EOL]     return lastChild; [EOL] } <line_num>: 2480,2506
@VisibleForTesting [EOL] Node loadLibraryCode(String resourceName) { [EOL]     String originalCode; [EOL]     try { [EOL]         originalCode = CharStreams.toString(new InputStreamReader(Compiler.class.getResourceAsStream(String.format("js/%s.js", resourceName)), Charsets.UTF_8)); [EOL]     } catch (IOException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL]     return Normalize.parseAndNormalizeSyntheticCode(this, originalCode, String.format("jscomp_%s_", resourceName)); [EOL] } <line_num>: 2509,2524
public static String getReleaseVersion() { [EOL]     ResourceBundle config = ResourceBundle.getBundle(CONFIG_RESOURCE); [EOL]     return config.getString("compiler.version"); [EOL] } <line_num>: 2527,2530
public static String getReleaseDate() { [EOL]     ResourceBundle config = ResourceBundle.getBundle(CONFIG_RESOURCE); [EOL]     return config.getString("compiler.date"); [EOL] } <line_num>: 2533,2536
@Override [EOL] public void setOldParseTree(String sourceName, AstRoot oldAst) { [EOL] } <line_num>: 2541,2543
@Override [EOL] public AstRoot getOldParseTreeByName(String sourceName) { [EOL]     return null; [EOL] } <line_num>: 2548,2551
