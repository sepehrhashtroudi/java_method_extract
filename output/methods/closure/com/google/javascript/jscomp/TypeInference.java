TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg, ReverseAbstractInterpreter reverseInterpreter, Scope functionScope, Map<String, AssertionFunctionSpec> assertionFunctionsMap) { [EOL]     super(cfg, new LinkedFlowScope.FlowScopeJoinOp()); [EOL]     this.compiler = compiler; [EOL]     this.registry = compiler.getTypeRegistry(); [EOL]     this.reverseInterpreter = reverseInterpreter; [EOL]     this.unknownType = registry.getNativeObjectType(UNKNOWN_TYPE); [EOL]     this.syntacticScope = functionScope; [EOL]     inferArguments(functionScope); [EOL]     this.functionScope = LinkedFlowScope.createEntryLattice(functionScope); [EOL]     this.assertionFunctionsMap = assertionFunctionsMap; [EOL]     Iterator<Var> varIt = functionScope.getDeclarativelyUnboundVarsWithoutTypes(); [EOL]     while (varIt.hasNext()) { [EOL]         Var var = varIt.next(); [EOL]         if (isUnflowable(var)) { [EOL]             continue; [EOL]         } [EOL]         this.functionScope.inferSlotType(var.getName(), getNativeType(VOID_TYPE)); [EOL]     } [EOL]     this.bottomScope = LinkedFlowScope.createEntryLattice(Scope.createLatticeBottom(functionScope.getRootNode())); [EOL] } <line_num>: 84,116
TemplateTypeReplacer(JSTypeRegistry registry, Map<TemplateType, JSType> replacements) { [EOL]     super(registry); [EOL]     this.registry = registry; [EOL]     this.replacements = replacements; [EOL] } <line_num>: 1157,1162
BooleanOutcomePair(BooleanLiteralSet toBooleanOutcomes, BooleanLiteralSet booleanValues, FlowScope leftScope, FlowScope rightScope) { [EOL]     this.toBooleanOutcomes = toBooleanOutcomes; [EOL]     this.booleanValues = booleanValues; [EOL]     this.leftScope = leftScope; [EOL]     this.rightScope = rightScope; [EOL] } <line_num>: 1490,1497
private void inferArguments(Scope functionScope) { [EOL]     Node functionNode = functionScope.getRootNode(); [EOL]     Node astParameters = functionNode.getFirstChild().getNext(); [EOL]     Node iifeArgumentNode = null; [EOL]     if (NodeUtil.isCallOrNewTarget(functionNode)) { [EOL]         iifeArgumentNode = functionNode.getNext(); [EOL]     } [EOL]     FunctionType functionType = JSType.toMaybeFunctionType(functionNode.getJSType()); [EOL]     if (functionType != null) { [EOL]         Node parameterTypes = functionType.getParametersNode(); [EOL]         if (parameterTypes != null) { [EOL]             Node parameterTypeNode = parameterTypes.getFirstChild(); [EOL]             for (Node astParameter : astParameters.children()) { [EOL]                 Var var = functionScope.getVar(astParameter.getString()); [EOL]                 Preconditions.checkNotNull(var); [EOL]                 if (var.isTypeInferred() && var.getType() == unknownType) { [EOL]                     JSType newType = null; [EOL]                     if (iifeArgumentNode != null) { [EOL]                         newType = iifeArgumentNode.getJSType(); [EOL]                     } else if (parameterTypeNode != null) { [EOL]                         newType = parameterTypeNode.getJSType(); [EOL]                     } [EOL]                     if (newType != null) { [EOL]                         var.setType(newType); [EOL]                         astParameter.setJSType(newType); [EOL]                     } [EOL]                 } [EOL]                 if (parameterTypeNode != null) { [EOL]                     parameterTypeNode = parameterTypeNode.getNext(); [EOL]                 } [EOL]                 if (iifeArgumentNode != null) { [EOL]                     iifeArgumentNode = iifeArgumentNode.getNext(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 121,164
@Override [EOL] FlowScope createInitialEstimateLattice() { [EOL]     return bottomScope; [EOL] } <line_num>: 166,169
@Override [EOL] FlowScope createEntryLattice() { [EOL]     return functionScope; [EOL] } <line_num>: 171,174
@Override [EOL] FlowScope flowThrough(Node n, FlowScope input) { [EOL]     if (input == bottomScope) { [EOL]         return input; [EOL]     } [EOL]     FlowScope output = input.createChildFlowScope(); [EOL]     output = traverse(n, output); [EOL]     return output; [EOL] } <line_num>: 176,187
@Override [EOL] @SuppressWarnings({ "fallthrough", "incomplete-switch" }) [EOL] List<FlowScope> branchedFlowThrough(Node source, FlowScope input) { [EOL]     FlowScope output = flowThrough(source, input); [EOL]     Node condition = null; [EOL]     FlowScope conditionFlowScope = null; [EOL]     BooleanOutcomePair conditionOutcomes = null; [EOL]     List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source); [EOL]     List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size()); [EOL]     for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) { [EOL]         Branch branch = branchEdge.getValue(); [EOL]         FlowScope newScope = output; [EOL]         switch(branch) { [EOL]             case ON_TRUE: [EOL]                 if (NodeUtil.isForIn(source)) { [EOL]                     Node item = source.getFirstChild(); [EOL]                     Node obj = item.getNext(); [EOL]                     FlowScope informed = traverse(obj, output.createChildFlowScope()); [EOL]                     if (item.isVar()) { [EOL]                         item = item.getFirstChild(); [EOL]                     } [EOL]                     if (item.isName()) { [EOL]                         JSType iterKeyType = getNativeType(STRING_TYPE); [EOL]                         ObjectType objType = getJSType(obj).dereference(); [EOL]                         JSType objIndexType = objType == null ? null : objType.getIndexType(); [EOL]                         if (objIndexType != null && !objIndexType.isUnknownType()) { [EOL]                             JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType); [EOL]                             if (!narrowedKeyType.isEmptyType()) { [EOL]                                 iterKeyType = narrowedKeyType; [EOL]                             } [EOL]                         } [EOL]                         redeclareSimpleVar(informed, item, iterKeyType); [EOL]                     } [EOL]                     newScope = informed; [EOL]                     break; [EOL]                 } [EOL]             case ON_FALSE: [EOL]                 if (condition == null) { [EOL]                     condition = NodeUtil.getConditionExpression(source); [EOL]                     if (condition == null && source.isCase()) { [EOL]                         condition = source; [EOL]                         if (conditionFlowScope == null) { [EOL]                             conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope()); [EOL]                         } [EOL]                     } [EOL]                 } [EOL]                 if (condition != null) { [EOL]                     if (condition.isAnd() || condition.isOr()) { [EOL]                         if (conditionOutcomes == null) { [EOL]                             conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope()); [EOL]                         } [EOL]                         newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE); [EOL]                     } else { [EOL]                         if (conditionFlowScope == null) { [EOL]                             conditionFlowScope = traverse(condition, output.createChildFlowScope()); [EOL]                         } [EOL]                         newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         result.add(newScope.optimize()); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 189,301
private FlowScope traverse(Node n, FlowScope scope) { [EOL]     switch(n.getType()) { [EOL]         case Token.ASSIGN: [EOL]             scope = traverseAssign(n, scope); [EOL]             break; [EOL]         case Token.NAME: [EOL]             scope = traverseName(n, scope); [EOL]             break; [EOL]         case Token.GETPROP: [EOL]             scope = traverseGetProp(n, scope); [EOL]             break; [EOL]         case Token.AND: [EOL]             scope = traverseAnd(n, scope).getJoinedFlowScope().createChildFlowScope(); [EOL]             break; [EOL]         case Token.OR: [EOL]             scope = traverseOr(n, scope).getJoinedFlowScope().createChildFlowScope(); [EOL]             break; [EOL]         case Token.HOOK: [EOL]             scope = traverseHook(n, scope); [EOL]             break; [EOL]         case Token.OBJECTLIT: [EOL]             scope = traverseObjectLiteral(n, scope); [EOL]             break; [EOL]         case Token.CALL: [EOL]             scope = traverseCall(n, scope); [EOL]             break; [EOL]         case Token.NEW: [EOL]             scope = traverseNew(n, scope); [EOL]             break; [EOL]         case Token.ASSIGN_ADD: [EOL]         case Token.ADD: [EOL]             scope = traverseAdd(n, scope); [EOL]             break; [EOL]         case Token.POS: [EOL]         case Token.NEG: [EOL]             scope = traverse(n.getFirstChild(), scope); [EOL]             n.setJSType(getNativeType(NUMBER_TYPE)); [EOL]             break; [EOL]         case Token.ARRAYLIT: [EOL]             scope = traverseArrayLiteral(n, scope); [EOL]             break; [EOL]         case Token.THIS: [EOL]             n.setJSType(scope.getTypeOfThis()); [EOL]             break; [EOL]         case Token.ASSIGN_LSH: [EOL]         case Token.ASSIGN_RSH: [EOL]         case Token.LSH: [EOL]         case Token.RSH: [EOL]         case Token.ASSIGN_URSH: [EOL]         case Token.URSH: [EOL]         case Token.ASSIGN_DIV: [EOL]         case Token.ASSIGN_MOD: [EOL]         case Token.ASSIGN_BITAND: [EOL]         case Token.ASSIGN_BITXOR: [EOL]         case Token.ASSIGN_BITOR: [EOL]         case Token.ASSIGN_MUL: [EOL]         case Token.ASSIGN_SUB: [EOL]         case Token.DIV: [EOL]         case Token.MOD: [EOL]         case Token.BITAND: [EOL]         case Token.BITXOR: [EOL]         case Token.BITOR: [EOL]         case Token.MUL: [EOL]         case Token.SUB: [EOL]         case Token.DEC: [EOL]         case Token.INC: [EOL]         case Token.BITNOT: [EOL]             scope = traverseChildren(n, scope); [EOL]             n.setJSType(getNativeType(NUMBER_TYPE)); [EOL]             break; [EOL]         case Token.PARAM_LIST: [EOL]             scope = traverse(n.getFirstChild(), scope); [EOL]             n.setJSType(getJSType(n.getFirstChild())); [EOL]             break; [EOL]         case Token.COMMA: [EOL]             scope = traverseChildren(n, scope); [EOL]             n.setJSType(getJSType(n.getLastChild())); [EOL]             break; [EOL]         case Token.TYPEOF: [EOL]             scope = traverseChildren(n, scope); [EOL]             n.setJSType(getNativeType(STRING_TYPE)); [EOL]             break; [EOL]         case Token.DELPROP: [EOL]         case Token.LT: [EOL]         case Token.LE: [EOL]         case Token.GT: [EOL]         case Token.GE: [EOL]         case Token.NOT: [EOL]         case Token.EQ: [EOL]         case Token.NE: [EOL]         case Token.SHEQ: [EOL]         case Token.SHNE: [EOL]         case Token.INSTANCEOF: [EOL]         case Token.IN: [EOL]             scope = traverseChildren(n, scope); [EOL]             n.setJSType(getNativeType(BOOLEAN_TYPE)); [EOL]             break; [EOL]         case Token.GETELEM: [EOL]             scope = traverseGetElem(n, scope); [EOL]             break; [EOL]         case Token.EXPR_RESULT: [EOL]             scope = traverseChildren(n, scope); [EOL]             if (n.getFirstChild().isGetProp()) { [EOL]                 ensurePropertyDeclared(n.getFirstChild()); [EOL]             } [EOL]             break; [EOL]         case Token.SWITCH: [EOL]             scope = traverse(n.getFirstChild(), scope); [EOL]             break; [EOL]         case Token.RETURN: [EOL]             scope = traverseReturn(n, scope); [EOL]             break; [EOL]         case Token.VAR: [EOL]         case Token.THROW: [EOL]             scope = traverseChildren(n, scope); [EOL]             break; [EOL]         case Token.CATCH: [EOL]             scope = traverseCatch(n, scope); [EOL]             break; [EOL]         case Token.CAST: [EOL]             scope = traverseChildren(n, scope); [EOL]             break; [EOL]     } [EOL]     if (!n.isFunction()) { [EOL]         JSDocInfo info = n.getJSDocInfo(); [EOL]         if (info != null && info.hasType()) { [EOL]             JSType castType = info.getType().evaluate(syntacticScope, registry); [EOL]             if (n.isQualifiedName() && n.getParent().isExprResult()) { [EOL]                 updateScopeForTypeChange(scope, n, n.getJSType(), castType); [EOL]             } [EOL]             n.setJSType(castType); [EOL]         } [EOL]     } [EOL]     return scope; [EOL] } <line_num>: 303,472
private FlowScope traverseReturn(Node n, FlowScope scope) { [EOL]     scope = traverseChildren(n, scope); [EOL]     Node retValue = n.getFirstChild(); [EOL]     if (retValue != null) { [EOL]         JSType type = functionScope.getRootNode().getJSType(); [EOL]         if (type != null) { [EOL]             FunctionType fnType = type.toMaybeFunctionType(); [EOL]             if (fnType != null) { [EOL]                 inferPropertyTypesToMatchConstraint(retValue.getJSType(), fnType.getReturnType()); [EOL]             } [EOL]         } [EOL]     } [EOL]     return scope; [EOL] } <line_num>: 477,492
private FlowScope traverseCatch(Node catchNode, FlowScope scope) { [EOL]     Node name = catchNode.getFirstChild(); [EOL]     String varName = name.getString(); [EOL]     JSType type; [EOL]     JSDocInfo info = name.getJSDocInfo(); [EOL]     if (info != null && info.hasType()) { [EOL]         type = info.getType().evaluate(syntacticScope, registry); [EOL]     } else { [EOL]         type = getNativeType(JSTypeNative.UNKNOWN_TYPE); [EOL]     } [EOL]     redeclareSimpleVar(scope, name, type); [EOL]     name.setJSType(type); [EOL]     return scope; [EOL] } <line_num>: 498,513
private FlowScope traverseAssign(Node n, FlowScope scope) { [EOL]     Node left = n.getFirstChild(); [EOL]     Node right = n.getLastChild(); [EOL]     scope = traverseChildren(n, scope); [EOL]     JSType leftType = left.getJSType(); [EOL]     JSType rightType = getJSType(right); [EOL]     n.setJSType(rightType); [EOL]     updateScopeForTypeChange(scope, left, leftType, rightType); [EOL]     return scope; [EOL] } <line_num>: 515,526
private void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) { [EOL]     Preconditions.checkNotNull(resultType); [EOL]     switch(left.getType()) { [EOL]         case Token.NAME: [EOL]             String varName = left.getString(); [EOL]             Var var = syntacticScope.getVar(varName); [EOL]             boolean isVarDeclaration = left.hasChildren(); [EOL]             if (!isVarDeclaration || var == null || var.isTypeInferred()) { [EOL]                 redeclareSimpleVar(scope, left, resultType); [EOL]             } [EOL]             left.setJSType(isVarDeclaration || leftType == null ? resultType : null); [EOL]             if (var != null && var.isTypeInferred()) { [EOL]                 JSType oldType = var.getType(); [EOL]                 var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType)); [EOL]             } [EOL]             break; [EOL]         case Token.GETPROP: [EOL]             String qualifiedName = left.getQualifiedName(); [EOL]             if (qualifiedName != null) { [EOL]                 scope.inferQualifiedSlot(left, qualifiedName, leftType == null ? unknownType : leftType, resultType); [EOL]             } [EOL]             left.setJSType(resultType); [EOL]             ensurePropertyDefined(left, resultType); [EOL]             break; [EOL]     } [EOL] } <line_num>: 532,575
private void ensurePropertyDefined(Node getprop, JSType rightType) { [EOL]     String propName = getprop.getLastChild().getString(); [EOL]     Node obj = getprop.getFirstChild(); [EOL]     JSType nodeType = getJSType(obj); [EOL]     ObjectType objectType = ObjectType.cast(nodeType.restrictByNotNullOrUndefined()); [EOL]     if (objectType == null) { [EOL]         registry.registerPropertyOnType(propName, nodeType); [EOL]     } else { [EOL]         if (nodeType.isStruct() && !objectType.hasProperty(propName)) { [EOL]             if (!(obj.isThis() && getJSType(syntacticScope.getRootNode()).isConstructor())) { [EOL]                 return; [EOL]             } [EOL]         } [EOL]         if (ensurePropertyDeclaredHelper(getprop, objectType)) { [EOL]             return; [EOL]         } [EOL]         if (!objectType.isPropertyTypeDeclared(propName)) { [EOL]             if (objectType.hasProperty(propName) || !objectType.isInstanceType()) { [EOL]                 if ("prototype".equals(propName)) { [EOL]                     objectType.defineDeclaredProperty(propName, rightType, getprop); [EOL]                 } else { [EOL]                     objectType.defineInferredProperty(propName, rightType, getprop); [EOL]                 } [EOL]             } else if (obj.isThis() && getJSType(syntacticScope.getRootNode()).isConstructor()) { [EOL]                 objectType.defineInferredProperty(propName, rightType, getprop); [EOL]             } else { [EOL]                 registry.registerPropertyOnType(propName, objectType); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 580,628
private void ensurePropertyDeclared(Node getprop) { [EOL]     ObjectType ownerType = ObjectType.cast(getJSType(getprop.getFirstChild()).restrictByNotNullOrUndefined()); [EOL]     if (ownerType != null) { [EOL]         ensurePropertyDeclaredHelper(getprop, ownerType); [EOL]     } [EOL] } <line_num>: 637,643
private boolean ensurePropertyDeclaredHelper(Node getprop, ObjectType objectType) { [EOL]     String propName = getprop.getLastChild().getString(); [EOL]     String qName = getprop.getQualifiedName(); [EOL]     if (qName != null) { [EOL]         Var var = syntacticScope.getVar(qName); [EOL]         if (var != null && !var.isTypeInferred()) { [EOL]             if (propName.equals("prototype") || (!objectType.hasOwnProperty(propName) && (!objectType.isInstanceType() || (var.isExtern() && !objectType.isNativeObjectType())))) { [EOL]                 return objectType.defineDeclaredProperty(propName, var.getType(), getprop); [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 649,668
private FlowScope traverseName(Node n, FlowScope scope) { [EOL]     String varName = n.getString(); [EOL]     Node value = n.getFirstChild(); [EOL]     JSType type = n.getJSType(); [EOL]     if (value != null) { [EOL]         scope = traverse(value, scope); [EOL]         updateScopeForTypeChange(scope, n, n.getJSType(), getJSType(value)); [EOL]         return scope; [EOL]     } else { [EOL]         StaticSlot<JSType> var = scope.getSlot(varName); [EOL]         if (var != null) { [EOL]             boolean isInferred = var.isTypeInferred(); [EOL]             boolean unflowable = isInferred && isUnflowable(syntacticScope.getVar(varName)); [EOL]             boolean nonLocalInferredSlot = false; [EOL]             if (isInferred && syntacticScope.isLocal()) { [EOL]                 Var maybeOuterVar = syntacticScope.getParent().getVar(varName); [EOL]                 if (var == maybeOuterVar && !maybeOuterVar.isMarkedAssignedExactlyOnce()) { [EOL]                     nonLocalInferredSlot = true; [EOL]                 } [EOL]             } [EOL]             if (!unflowable && !nonLocalInferredSlot) { [EOL]                 type = var.getType(); [EOL]                 if (type == null) { [EOL]                     type = unknownType; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     n.setJSType(type); [EOL]     return scope; [EOL] } <line_num>: 670,723
private FlowScope traverseArrayLiteral(Node n, FlowScope scope) { [EOL]     scope = traverseChildren(n, scope); [EOL]     n.setJSType(getNativeType(ARRAY_TYPE)); [EOL]     return scope; [EOL] } <line_num>: 726,730
private FlowScope traverseObjectLiteral(Node n, FlowScope scope) { [EOL]     JSType type = n.getJSType(); [EOL]     Preconditions.checkNotNull(type); [EOL]     for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { [EOL]         scope = traverse(name.getFirstChild(), scope); [EOL]     } [EOL]     ObjectType objectType = ObjectType.cast(type); [EOL]     if (objectType == null) { [EOL]         return scope; [EOL]     } [EOL]     boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null; [EOL]     if (objectType.hasReferenceName() && !hasLendsName) { [EOL]         return scope; [EOL]     } [EOL]     String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n)); [EOL]     for (Node name = n.getFirstChild(); name != null; name = name.getNext()) { [EOL]         Node value = name.getFirstChild(); [EOL]         String memberName = NodeUtil.getObjectLitKeyName(name); [EOL]         if (memberName != null) { [EOL]             JSType rawValueType = name.getFirstChild().getJSType(); [EOL]             JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType); [EOL]             if (valueType == null) { [EOL]                 valueType = unknownType; [EOL]             } [EOL]             objectType.defineInferredProperty(memberName, valueType, name); [EOL]             if (qObjName != null && name.isStringKey()) { [EOL]                 String qKeyName = qObjName + "." + memberName; [EOL]                 Var var = syntacticScope.getVar(qKeyName); [EOL]                 JSType oldType = var == null ? null : var.getType(); [EOL]                 if (var != null && var.isTypeInferred()) { [EOL]                     var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType)); [EOL]                 } [EOL]                 scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType); [EOL]             } [EOL]         } else { [EOL]             n.setJSType(unknownType); [EOL]         } [EOL]     } [EOL]     return scope; [EOL] } <line_num>: 732,791
private FlowScope traverseAdd(Node n, FlowScope scope) { [EOL]     Node left = n.getFirstChild(); [EOL]     Node right = left.getNext(); [EOL]     scope = traverseChildren(n, scope); [EOL]     JSType leftType = left.getJSType(); [EOL]     JSType rightType = right.getJSType(); [EOL]     JSType type = unknownType; [EOL]     if (leftType != null && rightType != null) { [EOL]         boolean leftIsUnknown = leftType.isUnknownType(); [EOL]         boolean rightIsUnknown = rightType.isUnknownType(); [EOL]         if (leftIsUnknown && rightIsUnknown) { [EOL]             type = unknownType; [EOL]         } else if ((!leftIsUnknown && leftType.isString()) || (!rightIsUnknown && rightType.isString())) { [EOL]             type = getNativeType(STRING_TYPE); [EOL]         } else if (leftIsUnknown || rightIsUnknown) { [EOL]             type = unknownType; [EOL]         } else if (isAddedAsNumber(leftType) && isAddedAsNumber(rightType)) { [EOL]             type = getNativeType(NUMBER_TYPE); [EOL]         } else { [EOL]             type = registry.createUnionType(STRING_TYPE, NUMBER_TYPE); [EOL]         } [EOL]     } [EOL]     n.setJSType(type); [EOL]     if (n.isAssignAdd()) { [EOL]         updateScopeForTypeChange(scope, left, leftType, type); [EOL]     } [EOL]     return scope; [EOL] } <line_num>: 793,825
private boolean isAddedAsNumber(JSType type) { [EOL]     return type.isSubtype(registry.createUnionType(VOID_TYPE, NULL_TYPE, NUMBER_VALUE_OR_OBJECT_TYPE, BOOLEAN_TYPE, BOOLEAN_OBJECT_TYPE)); [EOL] } <line_num>: 827,830
private FlowScope traverseHook(Node n, FlowScope scope) { [EOL]     Node condition = n.getFirstChild(); [EOL]     Node trueNode = condition.getNext(); [EOL]     Node falseNode = n.getLastChild(); [EOL]     scope = traverse(condition, scope); [EOL]     FlowScope trueScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, scope, true); [EOL]     FlowScope falseScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, scope, false); [EOL]     traverse(trueNode, trueScope.createChildFlowScope()); [EOL]     traverse(falseNode, falseScope.createChildFlowScope()); [EOL]     JSType trueType = trueNode.getJSType(); [EOL]     JSType falseType = falseNode.getJSType(); [EOL]     if (trueType != null && falseType != null) { [EOL]         n.setJSType(trueType.getLeastSupertype(falseType)); [EOL]     } else { [EOL]         n.setJSType(null); [EOL]     } [EOL]     return scope.createChildFlowScope(); [EOL] } <line_num>: 832,864
private FlowScope traverseCall(Node n, FlowScope scope) { [EOL]     scope = traverseChildren(n, scope); [EOL]     Node left = n.getFirstChild(); [EOL]     JSType functionType = getJSType(left).restrictByNotNullOrUndefined(); [EOL]     if (functionType.isFunctionType()) { [EOL]         FunctionType fnType = functionType.toMaybeFunctionType(); [EOL]         n.setJSType(fnType.getReturnType()); [EOL]         backwardsInferenceFromCallSite(n, fnType); [EOL]     } else if (functionType.isEquivalentTo(getNativeType(CHECKED_UNKNOWN_TYPE))) { [EOL]         n.setJSType(getNativeType(CHECKED_UNKNOWN_TYPE)); [EOL]     } [EOL]     scope = tightenTypesAfterAssertions(scope, n); [EOL]     return scope; [EOL] } <line_num>: 866,882
private FlowScope tightenTypesAfterAssertions(FlowScope scope, Node callNode) { [EOL]     Node left = callNode.getFirstChild(); [EOL]     Node firstParam = left.getNext(); [EOL]     AssertionFunctionSpec assertionFunctionSpec = assertionFunctionsMap.get(left.getQualifiedName()); [EOL]     if (assertionFunctionSpec == null || firstParam == null) { [EOL]         return scope; [EOL]     } [EOL]     Node assertedNode = assertionFunctionSpec.getAssertedParam(firstParam); [EOL]     if (assertedNode == null) { [EOL]         return scope; [EOL]     } [EOL]     JSType assertedType = assertionFunctionSpec.getAssertedType(callNode, registry); [EOL]     String assertedNodeName = assertedNode.getQualifiedName(); [EOL]     JSType narrowed; [EOL]     if (assertedType == null) { [EOL]         scope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(assertedNode, scope, true); [EOL]         narrowed = getJSType(assertedNode).restrictByNotNullOrUndefined(); [EOL]     } else { [EOL]         JSType type = getJSType(assertedNode); [EOL]         narrowed = type.getGreatestSubtype(assertedType); [EOL]         if (assertedNodeName != null && type.differsFrom(narrowed)) { [EOL]             scope = narrowScope(scope, assertedNode, narrowed); [EOL]         } [EOL]     } [EOL]     callNode.setJSType(narrowed); [EOL]     return scope; [EOL] } <line_num>: 884,920
private FlowScope narrowScope(FlowScope scope, Node node, JSType narrowed) { [EOL]     if (node.isThis()) { [EOL]         return scope; [EOL]     } [EOL]     scope = scope.createChildFlowScope(); [EOL]     if (node.isGetProp()) { [EOL]         scope.inferQualifiedSlot(node, node.getQualifiedName(), getJSType(node), narrowed); [EOL]     } else { [EOL]         redeclareSimpleVar(scope, node, narrowed); [EOL]     } [EOL]     return scope; [EOL] } <line_num>: 922,936
private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) { [EOL]     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType); [EOL]     if (updatedFnType) { [EOL]         fnType = n.getFirstChild().getJSType().toMaybeFunctionType(); [EOL]     } [EOL]     updateTypeOfParameters(n, fnType); [EOL]     updateBind(n, fnType); [EOL] } <line_num>: 963,970
private void updateBind(Node n, FunctionType fnType) { [EOL]     CodingConvention.Bind bind = compiler.getCodingConvention().describeFunctionBind(n, true); [EOL]     if (bind == null) { [EOL]         return; [EOL]     } [EOL]     FunctionType callTargetFn = getJSType(bind.target).restrictByNotNullOrUndefined().toMaybeFunctionType(); [EOL]     if (callTargetFn == null) { [EOL]         return; [EOL]     } [EOL]     n.setJSType(callTargetFn.getBindReturnType(bind.getBoundParameterCount() + 1)); [EOL] } <line_num>: 976,993
private void updateTypeOfParameters(Node n, FunctionType fnType) { [EOL]     int i = 0; [EOL]     int childCount = n.getChildCount(); [EOL]     for (Node iParameter : fnType.getParameters()) { [EOL]         if (i + 1 >= childCount) { [EOL]             return; [EOL]         } [EOL]         JSType iParameterType = getJSType(iParameter); [EOL]         Node iArgument = n.getChildAtIndex(i + 1); [EOL]         JSType iArgumentType = getJSType(iArgument); [EOL]         inferPropertyTypesToMatchConstraint(iArgumentType, iParameterType); [EOL]         JSType restrictedParameter = iParameterType.restrictByNotNullOrUndefined().toMaybeFunctionType(); [EOL]         if (restrictedParameter != null) { [EOL]             if (iArgument.isFunction() && iArgumentType.isFunctionType() && iArgument.getJSDocInfo() == null) { [EOL]                 iArgument.setJSType(restrictedParameter); [EOL]             } [EOL]         } [EOL]         i++; [EOL]     } [EOL] } <line_num>: 999,1028
private Map<TemplateType, JSType> inferTemplateTypesFromParameters(FunctionType fnType, Node call) { [EOL]     if (fnType.getTemplateKeys().isEmpty()) { [EOL]         return Collections.emptyMap(); [EOL]     } [EOL]     Map<TemplateType, JSType> resolvedTypes = Maps.newIdentityHashMap(); [EOL]     Node callTarget = call.getFirstChild(); [EOL]     if (NodeUtil.isGet(callTarget)) { [EOL]         Node obj = callTarget.getFirstChild(); [EOL]         maybeResolveTemplatedType(fnType.getTypeOfThis(), getJSType(obj), resolvedTypes); [EOL]     } [EOL]     if (call.hasMoreThanOneChild()) { [EOL]         maybeResolveTemplateTypeFromNodes(fnType.getParameters(), call.getChildAtIndex(1).siblings(), resolvedTypes); [EOL]     } [EOL]     return resolvedTypes; [EOL] } <line_num>: 1030,1054
private void maybeResolveTemplatedType(JSType paramType, JSType argType, Map<TemplateType, JSType> resolvedTypes) { [EOL]     if (paramType.isTemplateType()) { [EOL]         resolvedTemplateType(resolvedTypes, paramType.toMaybeTemplateType(), argType); [EOL]     } else if (paramType.isUnionType()) { [EOL]         UnionType unionType = paramType.toMaybeUnionType(); [EOL]         for (JSType alernative : unionType.getAlternates()) { [EOL]             maybeResolveTemplatedType(alernative, argType, resolvedTypes); [EOL]         } [EOL]     } else if (paramType.isFunctionType()) { [EOL]         FunctionType paramFunctionType = paramType.toMaybeFunctionType(); [EOL]         FunctionType argFunctionType = argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType(); [EOL]         if (argFunctionType != null && argFunctionType.isSubtype(paramType)) { [EOL]             maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(), argFunctionType.getTypeOfThis(), resolvedTypes); [EOL]             maybeResolveTemplatedType(paramFunctionType.getReturnType(), argFunctionType.getReturnType(), resolvedTypes); [EOL]             maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(), argFunctionType.getParameters(), resolvedTypes); [EOL]         } [EOL]     } else if (paramType.isParameterizedType()) { [EOL]         ParameterizedType paramObjectType = paramType.toMaybeParameterizedType(); [EOL]         JSType typeParameter = paramObjectType.getParameterType(); [EOL]         Preconditions.checkNotNull(typeParameter); [EOL]         if (typeParameter != null) { [EOL]             ObjectType argObjectType = argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeParameterizedType(); [EOL]             if (argObjectType != null && argObjectType.isSubtype(paramType)) { [EOL]                 JSType argTypeParameter = argObjectType.getParameterType(); [EOL]                 Preconditions.checkNotNull(argTypeParameter); [EOL]                 maybeResolveTemplatedType(typeParameter, argTypeParameter, resolvedTypes); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 1056,1108
private void maybeResolveTemplateTypeFromNodes(Iterable<Node> declParams, Iterable<Node> callParams, Map<TemplateType, JSType> resolvedTypes) { [EOL]     maybeResolveTemplateTypeFromNodes(declParams.iterator(), callParams.iterator(), resolvedTypes); [EOL] } <line_num>: 1110,1116
private void maybeResolveTemplateTypeFromNodes(Iterator<Node> declParams, Iterator<Node> callParams, Map<TemplateType, JSType> resolvedTypes) { [EOL]     while (declParams.hasNext() && callParams.hasNext()) { [EOL]         Node declParam = declParams.next(); [EOL]         maybeResolveTemplatedType(getJSType(declParam), getJSType(callParams.next()), resolvedTypes); [EOL]         if (declParam.isVarArgs()) { [EOL]             while (callParams.hasNext()) { [EOL]                 maybeResolveTemplatedType(getJSType(declParam), getJSType(callParams.next()), resolvedTypes); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 1118,1137
private void resolvedTemplateType(Map<TemplateType, JSType> map, TemplateType template, JSType resolved) { [EOL]     JSType previous = map.get(template); [EOL]     if (!resolved.isUnknownType()) { [EOL]         if (previous == null) { [EOL]             map.put(template, resolved); [EOL]         } else { [EOL]             JSType join = previous.getLeastSupertype(resolved); [EOL]             map.put(template, join); [EOL]         } [EOL]     } [EOL] } <line_num>: 1139,1150
@Override [EOL] public JSType caseTemplateType(TemplateType type) { [EOL]     madeChanges = true; [EOL]     JSType replacement = replacements.get(type); [EOL]     return replacement != null ? replacement : registry.getNativeType(UNKNOWN_TYPE); [EOL] } <line_num>: 1164,1170
private boolean inferTemplatedTypesForCall(Node n, FunctionType fnType) { [EOL]     if (fnType.getTemplateKeys().isEmpty()) { [EOL]         return false; [EOL]     } [EOL]     Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n); [EOL]     TemplateTypeReplacer replacer = new TemplateTypeReplacer(registry, inferred); [EOL]     Node callTarget = n.getFirstChild(); [EOL]     FunctionType replacementFnType = fnType.visit(replacer).toMaybeFunctionType(); [EOL]     Preconditions.checkNotNull(replacementFnType); [EOL]     callTarget.setJSType(replacementFnType); [EOL]     n.setJSType(replacementFnType.getReturnType()); [EOL]     return replacer.madeChanges; [EOL] } <line_num>: 1178,1202
private FlowScope traverseNew(Node n, FlowScope scope) { [EOL]     scope = traverseChildren(n, scope); [EOL]     Node constructor = n.getFirstChild(); [EOL]     JSType constructorType = constructor.getJSType(); [EOL]     JSType type = null; [EOL]     if (constructorType != null) { [EOL]         constructorType = constructorType.restrictByNotNullOrUndefined(); [EOL]         if (constructorType.isUnknownType()) { [EOL]             type = unknownType; [EOL]         } else { [EOL]             FunctionType ct = constructorType.toMaybeFunctionType(); [EOL]             if (ct == null && constructorType instanceof FunctionType) { [EOL]                 ct = (FunctionType) constructorType; [EOL]             } [EOL]             if (ct != null && ct.isConstructor()) { [EOL]                 type = ct.getInstanceType(); [EOL]                 backwardsInferenceFromCallSite(n, ct); [EOL]             } [EOL]         } [EOL]     } [EOL]     n.setJSType(type); [EOL]     return scope; [EOL] } <line_num>: 1204,1230
private BooleanOutcomePair traverseAnd(Node n, FlowScope scope) { [EOL]     return traverseShortCircuitingBinOp(n, scope, true); [EOL] } <line_num>: 1232,1234
private FlowScope traverseChildren(Node n, FlowScope scope) { [EOL]     for (Node el = n.getFirstChild(); el != null; el = el.getNext()) { [EOL]         scope = traverse(el, scope); [EOL]     } [EOL]     return scope; [EOL] } <line_num>: 1236,1241
private FlowScope traverseGetElem(Node n, FlowScope scope) { [EOL]     scope = traverseChildren(n, scope); [EOL]     ObjectType objType = ObjectType.cast(getJSType(n.getFirstChild()).restrictByNotNullOrUndefined()); [EOL]     if (objType != null) { [EOL]         JSType type = objType.getParameterType(); [EOL]         if (type != null) { [EOL]             n.setJSType(type); [EOL]         } [EOL]     } [EOL]     return dereferencePointer(n.getFirstChild(), scope); [EOL] } <line_num>: 1243,1254
private FlowScope traverseGetProp(Node n, FlowScope scope) { [EOL]     Node objNode = n.getFirstChild(); [EOL]     Node property = n.getLastChild(); [EOL]     scope = traverseChildren(n, scope); [EOL]     n.setJSType(getPropertyType(objNode.getJSType(), property.getString(), n, scope)); [EOL]     return dereferencePointer(n.getFirstChild(), scope); [EOL] } <line_num>: 1256,1265
private void inferPropertyTypesToMatchConstraint(JSType type, JSType constraint) { [EOL]     if (type == null || constraint == null) { [EOL]         return; [EOL]     } [EOL]     type.matchConstraint(constraint); [EOL] } <line_num>: 1281,1288
private FlowScope dereferencePointer(Node n, FlowScope scope) { [EOL]     if (n.isQualifiedName()) { [EOL]         JSType type = getJSType(n); [EOL]         JSType narrowed = type.restrictByNotNullOrUndefined(); [EOL]         if (type != narrowed) { [EOL]             scope = narrowScope(scope, n, narrowed); [EOL]         } [EOL]     } [EOL]     return scope; [EOL] } <line_num>: 1294,1303
private JSType getPropertyType(JSType objType, String propName, Node n, FlowScope scope) { [EOL]     JSType propertyType = null; [EOL]     boolean isLocallyInferred = false; [EOL]     String qualifiedName = n.getQualifiedName(); [EOL]     StaticSlot<JSType> var = scope.getSlot(qualifiedName); [EOL]     if (var != null) { [EOL]         JSType varType = var.getType(); [EOL]         if (varType != null) { [EOL]             boolean isDeclared = !var.isTypeInferred(); [EOL]             isLocallyInferred = (var != syntacticScope.getSlot(qualifiedName)); [EOL]             if (isDeclared || isLocallyInferred) { [EOL]                 propertyType = varType; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (propertyType == null && objType != null) { [EOL]         JSType foundType = objType.findPropertyType(propName); [EOL]         if (foundType != null) { [EOL]             propertyType = foundType; [EOL]         } [EOL]     } [EOL]     if ((propertyType == null || propertyType.isUnknownType()) && qualifiedName != null) { [EOL]         ObjectType regType = ObjectType.cast(registry.getType(qualifiedName)); [EOL]         if (regType != null) { [EOL]             propertyType = regType.getConstructor(); [EOL]         } [EOL]     } [EOL]     if (propertyType == null) { [EOL]         return unknownType; [EOL]     } else if (propertyType.isEquivalentTo(unknownType) && isLocallyInferred) { [EOL]         return getNativeType(CHECKED_UNKNOWN_TYPE); [EOL]     } else { [EOL]         return propertyType; [EOL]     } [EOL] } <line_num>: 1305,1355
private BooleanOutcomePair traverseOr(Node n, FlowScope scope) { [EOL]     return traverseShortCircuitingBinOp(n, scope, false); [EOL] } <line_num>: 1357,1359
private BooleanOutcomePair traverseShortCircuitingBinOp(Node n, FlowScope scope, boolean condition) { [EOL]     Node left = n.getFirstChild(); [EOL]     Node right = n.getLastChild(); [EOL]     BooleanOutcomePair leftLiterals = traverseWithinShortCircuitingBinOp(left, scope.createChildFlowScope()); [EOL]     JSType leftType = left.getJSType(); [EOL]     FlowScope rightScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(left, leftLiterals.getOutcomeFlowScope(left.getType(), condition), condition); [EOL]     BooleanOutcomePair rightLiterals = traverseWithinShortCircuitingBinOp(right, rightScope.createChildFlowScope()); [EOL]     JSType rightType = right.getJSType(); [EOL]     JSType type; [EOL]     BooleanOutcomePair literals; [EOL]     if (leftType != null && rightType != null) { [EOL]         leftType = leftType.getRestrictedTypeGivenToBooleanOutcome(!condition); [EOL]         if (leftLiterals.toBooleanOutcomes == BooleanLiteralSet.get(!condition)) { [EOL]             type = leftType; [EOL]             literals = leftLiterals; [EOL]         } else { [EOL]             type = leftType.getLeastSupertype(rightType); [EOL]             literals = getBooleanOutcomePair(leftLiterals, rightLiterals, condition); [EOL]         } [EOL]         if (literals.booleanValues == BooleanLiteralSet.EMPTY && getNativeType(BOOLEAN_TYPE).isSubtype(type)) { [EOL]             if (type.isUnionType()) { [EOL]                 type = type.toMaybeUnionType().getRestrictedUnion(getNativeType(BOOLEAN_TYPE)); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         type = null; [EOL]         literals = new BooleanOutcomePair(BooleanLiteralSet.BOTH, BooleanLiteralSet.BOTH, leftLiterals.getJoinedFlowScope(), rightLiterals.getJoinedFlowScope()); [EOL]     } [EOL]     n.setJSType(type); [EOL]     return literals; [EOL] } <line_num>: 1361,1423
private BooleanOutcomePair traverseWithinShortCircuitingBinOp(Node n, FlowScope scope) { [EOL]     switch(n.getType()) { [EOL]         case Token.AND: [EOL]             return traverseAnd(n, scope); [EOL]         case Token.OR: [EOL]             return traverseOr(n, scope); [EOL]         default: [EOL]             scope = traverse(n, scope); [EOL]             return newBooleanOutcomePair(n.getJSType(), scope); [EOL]     } [EOL] } <line_num>: 1425,1438
BooleanOutcomePair getBooleanOutcomePair(BooleanOutcomePair left, BooleanOutcomePair right, boolean condition) { [EOL]     return new BooleanOutcomePair(getBooleanOutcomes(left.toBooleanOutcomes, right.toBooleanOutcomes, condition), getBooleanOutcomes(left.booleanValues, right.booleanValues, condition), left.getJoinedFlowScope(), right.getJoinedFlowScope()); [EOL] } <line_num>: 1445,1452
static BooleanLiteralSet getBooleanOutcomes(BooleanLiteralSet left, BooleanLiteralSet right, boolean condition) { [EOL]     return right.union(left.intersection(BooleanLiteralSet.get(!condition))); [EOL] } <line_num>: 1466,1469
FlowScope getJoinedFlowScope() { [EOL]     if (joinedScope == null) { [EOL]         if (leftScope == rightScope) { [EOL]             joinedScope = rightScope; [EOL]         } else { [EOL]             joinedScope = join(leftScope, rightScope); [EOL]         } [EOL]     } [EOL]     return joinedScope; [EOL] } <line_num>: 1503,1512
FlowScope getOutcomeFlowScope(int nodeType, boolean outcome) { [EOL]     if (nodeType == Token.AND && outcome || nodeType == Token.OR && !outcome) { [EOL]         return rightScope; [EOL]     } else { [EOL]         return getJoinedFlowScope(); [EOL]     } [EOL] } <line_num>: 1518,1526
private BooleanOutcomePair newBooleanOutcomePair(JSType jsType, FlowScope flowScope) { [EOL]     if (jsType == null) { [EOL]         return new BooleanOutcomePair(BooleanLiteralSet.BOTH, BooleanLiteralSet.BOTH, flowScope, flowScope); [EOL]     } [EOL]     return new BooleanOutcomePair(jsType.getPossibleToBooleanOutcomes(), registry.getNativeType(BOOLEAN_TYPE).isSubtype(jsType) ? BooleanLiteralSet.BOTH : BooleanLiteralSet.EMPTY, flowScope, flowScope); [EOL] } <line_num>: 1529,1539
private void redeclareSimpleVar(FlowScope scope, Node nameNode, JSType varType) { [EOL]     Preconditions.checkState(nameNode.isName()); [EOL]     String varName = nameNode.getString(); [EOL]     if (varType == null) { [EOL]         varType = getNativeType(JSTypeNative.UNKNOWN_TYPE); [EOL]     } [EOL]     if (isUnflowable(syntacticScope.getVar(varName))) { [EOL]         return; [EOL]     } [EOL]     scope.inferSlotType(varName, varType); [EOL] } <line_num>: 1541,1552
private boolean isUnflowable(Var v) { [EOL]     return v != null && v.isLocal() && v.isMarkedEscaped() && v.getScope() == syntacticScope; [EOL] } <line_num>: 1554,1558
private JSType getJSType(Node n) { [EOL]     JSType jsType = n.getJSType(); [EOL]     if (jsType == null) { [EOL]         return unknownType; [EOL]     } else { [EOL]         return jsType; [EOL]     } [EOL] } <line_num>: 1564,1575
private JSType getNativeType(JSTypeNative typeId) { [EOL]     return registry.getNativeType(typeId); [EOL] } <line_num>: 1577,1579
