TypeInferencePass(AbstractCompiler compiler, ReverseAbstractInterpreter reverseInterpreter, Scope topScope, MemoizedScopeCreator scopeCreator) { [EOL]     this.compiler = compiler; [EOL]     this.reverseInterpreter = reverseInterpreter; [EOL]     this.topScope = topScope; [EOL]     this.scopeCreator = scopeCreator; [EOL]     assertionFunctionsMap = Maps.newHashMap(); [EOL]     for (AssertionFunctionSpec assertionFucntion : compiler.getCodingConvention().getAssertionFunctions()) { [EOL]         assertionFunctionsMap.put(assertionFucntion.getFunctionName(), assertionFucntion); [EOL]     } [EOL] } <line_num>: 44,58
@Override [EOL] public void process(Node externsRoot, Node jsRoot) { [EOL]     Node externsAndJs = jsRoot.getParent(); [EOL]     Preconditions.checkState(externsAndJs != null); [EOL]     Preconditions.checkState(externsRoot == null || externsAndJs.hasChild(externsRoot)); [EOL]     inferAllScopes(externsAndJs); [EOL] } <line_num>: 66,74
void inferAllScopes(Node node) { [EOL]     (new NodeTraversal(compiler, new FirstScopeBuildingCallback(), scopeCreator)).traverseWithScope(node, topScope); [EOL]     (new NodeTraversal(compiler, new SecondScopeBuildingCallback(), scopeCreator)).traverseWithScope(node, topScope); [EOL] } <line_num>: 77,107
void inferScope(Node n, Scope scope) { [EOL]     TypeInference typeInference = new TypeInference(compiler, computeCfg(n), reverseInterpreter, scope, assertionFunctionsMap); [EOL]     try { [EOL]         typeInference.analyze(); [EOL]         compiler.getTypeRegistry().resolveTypesInScope(scope); [EOL]     } catch (DataFlowAnalysis.MaxIterationsExceededException e) { [EOL]         compiler.report(JSError.make(n.getSourceFileName(), n, DATAFLOW_ERROR)); [EOL]     } [EOL] } <line_num>: 109,123
@Override [EOL] public void enterScope(NodeTraversal t) { [EOL]     t.getScope(); [EOL] } <line_num>: 126,129
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL] } <line_num>: 131,134
@Override [EOL] public void enterScope(NodeTraversal t) { [EOL]     inferScope(t.getCurrentNode(), t.getScope()); [EOL] } <line_num>: 138,144
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL] } <line_num>: 146,149
private ControlFlowGraph<Node> computeCfg(Node n) { [EOL]     ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, false); [EOL]     cfa.process(null, n); [EOL]     return cfa.getCfg(); [EOL] } <line_num>: 152,156
