public VariableReferenceCheck(AbstractCompiler compiler, CheckLevel checkLevel) { [EOL]     this.compiler = compiler; [EOL]     this.checkLevel = checkLevel; [EOL] } <line_num>: 59,63
@Override [EOL] public void process(Node externs, Node root) { [EOL]     ReferenceCollectingCallback callback = new ReferenceCollectingCallback(compiler, new ReferenceCheckingBehavior()); [EOL]     callback.process(externs, root); [EOL] } <line_num>: 65,70
@Override [EOL] public void hotSwapScript(Node scriptRoot, Node originalRoot) { [EOL]     ReferenceCollectingCallback callback = new ReferenceCollectingCallback(compiler, new ReferenceCheckingBehavior()); [EOL]     callback.hotSwapScript(scriptRoot, originalRoot); [EOL] } <line_num>: 72,77
@Override [EOL] public void afterExitScope(NodeTraversal t, ReferenceMap referenceMap) { [EOL]     for (Iterator<Var> it = t.getScope().getVars(); it.hasNext(); ) { [EOL]         Var v = it.next(); [EOL]         checkVar(t, v, referenceMap.getReferences(v).references); [EOL]     } [EOL] } <line_num>: 85,96
private void checkVar(NodeTraversal t, Var v, List<Reference> references) { [EOL]     blocksWithDeclarations.clear(); [EOL]     boolean isDeclaredInScope = false; [EOL]     boolean isUnhoistedNamedFunction = false; [EOL]     Reference hoistedFn = null; [EOL]     for (Reference reference : references) { [EOL]         if (reference.isHoistedFunction()) { [EOL]             blocksWithDeclarations.add(reference.getBasicBlock()); [EOL]             isDeclaredInScope = true; [EOL]             hoistedFn = reference; [EOL]             break; [EOL]         } else if (NodeUtil.isFunctionDeclaration(reference.getNode().getParent())) { [EOL]             isUnhoistedNamedFunction = true; [EOL]         } [EOL]     } [EOL]     for (Reference reference : references) { [EOL]         if (reference == hoistedFn) { [EOL]             continue; [EOL]         } [EOL]         BasicBlock basicBlock = reference.getBasicBlock(); [EOL]         boolean isDeclaration = reference.isDeclaration(); [EOL]         boolean allowDupe = SyntacticScopeCreator.hasDuplicateDeclarationSuppression(reference.getNode(), v); [EOL]         if (isDeclaration && !allowDupe) { [EOL]             for (BasicBlock declaredBlock : blocksWithDeclarations) { [EOL]                 if (declaredBlock.provablyExecutesBefore(basicBlock)) { [EOL]                     String filename = NodeUtil.getSourceName(reference.getNode()); [EOL]                     compiler.report(JSError.make(filename, reference.getNode(), checkLevel, REDECLARED_VARIABLE, v.name)); [EOL]                     break; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (isUnhoistedNamedFunction && !isDeclaration && isDeclaredInScope) { [EOL]             for (BasicBlock declaredBlock : blocksWithDeclarations) { [EOL]                 if (!declaredBlock.provablyExecutesBefore(basicBlock)) { [EOL]                     String filename = NodeUtil.getSourceName(reference.getNode()); [EOL]                     compiler.report(JSError.make(filename, reference.getNode(), AMBIGUOUS_FUNCTION_DECL, v.name)); [EOL]                     break; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (!isDeclaration && !isDeclaredInScope) { [EOL]             if (!reference.getNode().isFromExterns()) { [EOL]                 Node grandparent = reference.getGrandparent(); [EOL]                 if (grandparent.isName() && grandparent.getString() == v.name) { [EOL]                     continue; [EOL]                 } [EOL]                 if (reference.getScope() == v.scope) { [EOL]                     String filename = NodeUtil.getSourceName(reference.getNode()); [EOL]                     compiler.report(JSError.make(filename, reference.getNode(), checkLevel, UNDECLARED_REFERENCE, v.name)); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (isDeclaration) { [EOL]             blocksWithDeclarations.add(basicBlock); [EOL]             isDeclaredInScope = true; [EOL]         } [EOL]     } [EOL] } <line_num>: 104,197
