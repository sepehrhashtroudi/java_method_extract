InlineSimpleMethods(AbstractCompiler compiler) { [EOL]     super(compiler); [EOL] } <line_num>: 57,59
@Override [EOL] void visit(NodeTraversal t, Node callNode, Node parent, String callName) { [EOL]     if (externMethods.contains(callName) || nonMethodProperties.contains(callName)) { [EOL]         return; [EOL]     } [EOL]     Collection<Node> definitions = methodDefinitions.get(callName); [EOL]     if (definitions == null || definitions.size() == 0) { [EOL]         return; [EOL]     } [EOL]     Node firstDefinition = definitions.iterator().next(); [EOL]     if (definitions.size() == 1 || allDefinitionsEquivalent(definitions)) { [EOL]         if (!argsMayHaveSideEffects(callNode)) { [EOL]             Node returned = returnedExpression(firstDefinition); [EOL]             if (returned != null) { [EOL]                 if (isPropertyTree(returned)) { [EOL]                     logger.fine("Inlining property accessor: " + callName); [EOL]                     inlinePropertyReturn(parent, callNode, returned); [EOL]                 } else if (NodeUtil.isLiteralValue(returned, false) && !NodeUtil.mayHaveSideEffects(callNode.getFirstChild(), compiler)) { [EOL]                     logger.fine("Inlining constant accessor: " + callName); [EOL]                     inlineConstReturn(parent, callNode, returned); [EOL]                 } [EOL]             } else if (isEmptyMethod(firstDefinition) && !NodeUtil.mayHaveSideEffects(callNode.getFirstChild(), compiler)) { [EOL]                 logger.fine("Inlining empty method: " + callName); [EOL]                 inlineEmptyMethod(t, parent, callNode); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         logger.fine("Method '" + callName + "' has conflicting definitions."); [EOL]     } [EOL] } <line_num>: 67,109
@Override [EOL] Callback getActingCallback() { [EOL]     return new InlineTrivialAccessors(); [EOL] } <line_num>: 112,115
private static boolean isPropertyTree(Node expectedGetprop) { [EOL]     if (!expectedGetprop.isGetProp()) { [EOL]         return false; [EOL]     } [EOL]     Node leftChild = expectedGetprop.getFirstChild(); [EOL]     if (!leftChild.isThis() && !isPropertyTree(leftChild)) { [EOL]         return false; [EOL]     } [EOL]     Node retVal = leftChild.getNext(); [EOL]     if (NodeUtil.getStringValue(retVal) == null) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } <line_num>: 122,138
private static void replaceThis(Node expectedGetprop, Node replacement) { [EOL]     Node leftChild = expectedGetprop.getFirstChild(); [EOL]     if (leftChild.isThis()) { [EOL]         expectedGetprop.replaceChild(leftChild, replacement); [EOL]     } else { [EOL]         replaceThis(leftChild, replacement); [EOL]     } [EOL] } <line_num>: 144,151
private static Node returnedExpression(Node fn) { [EOL]     Node expectedBlock = getMethodBlock(fn); [EOL]     if (!expectedBlock.hasOneChild()) { [EOL]         return null; [EOL]     } [EOL]     Node expectedReturn = expectedBlock.getFirstChild(); [EOL]     if (!expectedReturn.isReturn()) { [EOL]         return null; [EOL]     } [EOL]     if (!expectedReturn.hasOneChild()) { [EOL]         return null; [EOL]     } [EOL]     return expectedReturn.getLastChild(); [EOL] } <line_num>: 157,173
private static boolean isEmptyMethod(Node fn) { [EOL]     Node expectedBlock = getMethodBlock(fn); [EOL]     return expectedBlock == null ? false : NodeUtil.isEmptyBlock(expectedBlock); [EOL] } <line_num>: 181,185
private static Node getMethodBlock(Node fn) { [EOL]     if (fn.getChildCount() != 3) { [EOL]         return null; [EOL]     } [EOL]     Node expectedBlock = fn.getLastChild(); [EOL]     return expectedBlock.isBlock() ? expectedBlock : null; [EOL] } <line_num>: 193,201
private boolean allDefinitionsEquivalent(Collection<Node> definitions) { [EOL]     List<Node> list = Lists.newArrayList(); [EOL]     list.addAll(definitions); [EOL]     Node node0 = list.get(0); [EOL]     for (int i = 1; i < list.size(); i++) { [EOL]         if (!compiler.areNodesEqualForInlining(list.get(i), node0)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 206,217
private void inlinePropertyReturn(Node parent, Node call, Node returnedValue) { [EOL]     Node getProp = returnedValue.cloneTree(); [EOL]     replaceThis(getProp, call.getFirstChild().removeFirstChild()); [EOL]     parent.replaceChild(call, getProp); [EOL]     compiler.reportCodeChange(); [EOL] } <line_num>: 229,235
private void inlineConstReturn(Node parent, Node call, Node returnedValue) { [EOL]     Node retValue = returnedValue.cloneTree(); [EOL]     parent.replaceChild(call, retValue); [EOL]     compiler.reportCodeChange(); [EOL] } <line_num>: 242,247
private void inlineEmptyMethod(NodeTraversal t, Node parent, Node call) { [EOL]     if (NodeUtil.isExprCall(parent)) { [EOL]         parent.getParent().replaceChild(parent, IR.empty()); [EOL]     } else { [EOL]         Node srcLocation = call; [EOL]         parent.replaceChild(call, NodeUtil.newUndefinedNode(srcLocation)); [EOL]     } [EOL]     compiler.reportCodeChange(); [EOL] } <line_num>: 252,262
private boolean argsMayHaveSideEffects(Node call) { [EOL]     for (Node currentChild = call.getFirstChild().getNext(); currentChild != null; currentChild = currentChild.getNext()) { [EOL]         if (NodeUtil.mayHaveSideEffects(currentChild, compiler)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 268,278
@Override [EOL] public void addSignature(String functionName, Node functionNode, String sourceFile) { [EOL] } <line_num>: 285,288
@Override [EOL] public void removeSignature(String functionName) { [EOL] } <line_num>: 290,292
@Override [EOL] public void reset() { [EOL] } <line_num>: 294,296
@Override [EOL] SignatureStore getSignatureStore() { [EOL]     return DUMMY_SIGNATURE_STORE; [EOL] } <line_num>: 299,302
