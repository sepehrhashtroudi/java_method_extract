PeepholeReplaceKnownMethods(boolean late) { [EOL]     this.late = late; [EOL] } <line_num>: 42,44
@Override [EOL] Node optimizeSubtree(Node subtree) { [EOL]     if (subtree.isCall()) { [EOL]         return tryFoldKnownMethods(subtree); [EOL]     } [EOL]     return subtree; [EOL] } <line_num>: 46,52
private Node tryFoldKnownMethods(Node subtree) { [EOL]     subtree = tryFoldArrayJoin(subtree); [EOL]     if (subtree.isCall()) { [EOL]         Node callTarget = subtree.getFirstChild(); [EOL]         if (callTarget == null) { [EOL]             return subtree; [EOL]         } [EOL]         if (NodeUtil.isGet(callTarget)) { [EOL]             subtree = tryFoldKnownStringMethods(subtree); [EOL]         } else { [EOL]             subtree = tryFoldKnownNumericMethods(subtree); [EOL]         } [EOL]     } [EOL]     return subtree; [EOL] } <line_num>: 54,75
private Node tryFoldKnownStringMethods(Node subtree) { [EOL]     Preconditions.checkArgument(subtree.isCall()); [EOL]     Node callTarget = subtree.getFirstChild(); [EOL]     if (callTarget == null) { [EOL]         return subtree; [EOL]     } [EOL]     if (!NodeUtil.isGet(callTarget)) { [EOL]         return subtree; [EOL]     } [EOL]     Node stringNode = callTarget.getFirstChild(); [EOL]     Node functionName = stringNode.getNext(); [EOL]     if ((!stringNode.isString()) || (!functionName.isString())) { [EOL]         return subtree; [EOL]     } [EOL]     String functionNameString = functionName.getString(); [EOL]     Node firstArg = callTarget.getNext(); [EOL]     if (functionNameString.equals("split")) { [EOL]         subtree = tryFoldStringSplit(subtree, stringNode, firstArg); [EOL]     } else if (firstArg == null) { [EOL]         if (functionNameString.equals("toLowerCase")) { [EOL]             subtree = tryFoldStringToLowerCase(subtree, stringNode); [EOL]         } else if (functionNameString.equals("toUpperCase")) { [EOL]             subtree = tryFoldStringToUpperCase(subtree, stringNode); [EOL]         } [EOL]         return subtree; [EOL]     } else if (NodeUtil.isImmutableValue(firstArg)) { [EOL]         if (functionNameString.equals("indexOf") || functionNameString.equals("lastIndexOf")) { [EOL]             subtree = tryFoldStringIndexOf(subtree, functionNameString, stringNode, firstArg); [EOL]         } else if (functionNameString.equals("substr")) { [EOL]             subtree = tryFoldStringSubstr(subtree, stringNode, firstArg); [EOL]         } else if (functionNameString.equals("substring")) { [EOL]             subtree = tryFoldStringSubstring(subtree, stringNode, firstArg); [EOL]         } else if (functionNameString.equals("charAt")) { [EOL]             subtree = tryFoldStringCharAt(subtree, stringNode, firstArg); [EOL]         } else if (functionNameString.equals("charCodeAt")) { [EOL]             subtree = tryFoldStringCharCodeAt(subtree, stringNode, firstArg); [EOL]         } [EOL]     } [EOL]     return subtree; [EOL] } <line_num>: 81,131
private Node tryFoldKnownNumericMethods(Node subtree) { [EOL]     Preconditions.checkArgument(subtree.isCall()); [EOL]     if (isASTNormalized()) { [EOL]         Node callTarget = subtree.getFirstChild(); [EOL]         if (!callTarget.isName()) { [EOL]             return subtree; [EOL]         } [EOL]         String functionNameString = callTarget.getString(); [EOL]         Node firstArgument = callTarget.getNext(); [EOL]         if ((firstArgument != null) && (firstArgument.isString() || firstArgument.isNumber())) { [EOL]             if (functionNameString.equals("parseInt") || functionNameString.equals("parseFloat")) { [EOL]                 subtree = tryFoldParseNumber(subtree, functionNameString, firstArgument); [EOL]             } [EOL]         } [EOL]     } [EOL]     return subtree; [EOL] } <line_num>: 137,162
private Node tryFoldStringToLowerCase(Node subtree, Node stringNode) { [EOL]     String lowered = stringNode.getString().toLowerCase(ROOT_LOCALE); [EOL]     Node replacement = IR.string(lowered); [EOL]     subtree.getParent().replaceChild(subtree, replacement); [EOL]     reportCodeChange(); [EOL]     return replacement; [EOL] } <line_num>: 167,174
private Node tryFoldStringToUpperCase(Node subtree, Node stringNode) { [EOL]     String upped = stringNode.getString().toUpperCase(ROOT_LOCALE); [EOL]     Node replacement = IR.string(upped); [EOL]     subtree.getParent().replaceChild(subtree, replacement); [EOL]     reportCodeChange(); [EOL]     return replacement; [EOL] } <line_num>: 179,186
private String normalizeNumericString(String input) { [EOL]     if (input == null || input.length() == 0) { [EOL]         return input; [EOL]     } [EOL]     int startIndex = 0, endIndex = input.length() - 1; [EOL]     while (startIndex < input.length() && input.charAt(startIndex) == '0' && input.charAt(startIndex) != '.') { [EOL]         startIndex++; [EOL]     } [EOL]     if (input.indexOf('.') >= 0) { [EOL]         while (endIndex >= 0 && input.charAt(endIndex) == '0') { [EOL]             endIndex--; [EOL]         } [EOL]         if (input.charAt(endIndex) == '.') { [EOL]             endIndex--; [EOL]         } [EOL]     } [EOL]     if (startIndex >= endIndex) { [EOL]         return input; [EOL]     } [EOL]     return input.substring(startIndex, endIndex + 1); [EOL] } <line_num>: 192,219
private Node tryFoldParseNumber(Node n, String functionName, Node firstArg) { [EOL]     Preconditions.checkArgument(n.isCall()); [EOL]     boolean isParseInt = functionName.equals("parseInt"); [EOL]     Node secondArg = firstArg.getNext(); [EOL]     int radix = 0; [EOL]     if (secondArg != null) { [EOL]         if (!isParseInt) { [EOL]             return n; [EOL]         } [EOL]         if (secondArg.getNext() != null || !secondArg.isNumber()) { [EOL]             return n; [EOL]         } else { [EOL]             double tmpRadix = secondArg.getDouble(); [EOL]             if (tmpRadix != (int) tmpRadix) [EOL]                 return n; [EOL]             radix = (int) tmpRadix; [EOL]             if (radix < 0 || radix == 1 || radix > 36) { [EOL]                 return n; [EOL]             } [EOL]         } [EOL]     } [EOL]     String stringVal = null; [EOL]     Double checkVal; [EOL]     if (firstArg.isNumber()) { [EOL]         checkVal = NodeUtil.getNumberValue(firstArg); [EOL]         if (!(radix == 0 || radix == 10) && isParseInt) { [EOL]             stringVal = String.valueOf(checkVal.intValue()); [EOL]         } else { [EOL]             Node numericNode; [EOL]             if (isParseInt) { [EOL]                 numericNode = IR.number(checkVal.intValue()); [EOL]             } else { [EOL]                 numericNode = IR.number(checkVal); [EOL]             } [EOL]             n.getParent().replaceChild(n, numericNode); [EOL]             reportCodeChange(); [EOL]             return numericNode; [EOL]         } [EOL]     } else { [EOL]         stringVal = NodeUtil.getStringValue(firstArg); [EOL]         if (stringVal == null) { [EOL]             return n; [EOL]         } [EOL]         checkVal = NodeUtil.getStringNumberValue(stringVal); [EOL]         if (checkVal == null) { [EOL]             return n; [EOL]         } [EOL]         stringVal = NodeUtil.trimJsWhiteSpace(stringVal); [EOL]         if (stringVal.length() == 0) { [EOL]             return n; [EOL]         } [EOL]     } [EOL]     Node newNode; [EOL]     if (stringVal.equals("0")) { [EOL]         newNode = IR.number(0); [EOL]     } else if (isParseInt) { [EOL]         if (radix == 0 || radix == 16) { [EOL]             if (stringVal.length() > 1 && stringVal.substring(0, 2).equalsIgnoreCase("0x")) { [EOL]                 radix = 16; [EOL]                 stringVal = stringVal.substring(2); [EOL]             } else if (radix == 0) { [EOL]                 if (!isEcmaScript5OrGreater() && stringVal.substring(0, 1).equals("0")) { [EOL]                     return n; [EOL]                 } [EOL]                 radix = 10; [EOL]             } [EOL]         } [EOL]         int newVal = 0; [EOL]         try { [EOL]             newVal = Integer.parseInt(stringVal, radix); [EOL]         } catch (NumberFormatException e) { [EOL]             return n; [EOL]         } [EOL]         newNode = IR.number(newVal); [EOL]     } else { [EOL]         String normalizedNewVal = "0"; [EOL]         try { [EOL]             double newVal = Double.parseDouble(stringVal); [EOL]             newNode = IR.number(newVal); [EOL]             normalizedNewVal = normalizeNumericString(String.valueOf(newVal)); [EOL]         } catch (NumberFormatException e) { [EOL]             return n; [EOL]         } [EOL]         if (!normalizeNumericString(stringVal).equals(normalizedNewVal)) { [EOL]             return n; [EOL]         } [EOL]     } [EOL]     n.getParent().replaceChild(n, newNode); [EOL]     reportCodeChange(); [EOL]     return newNode; [EOL] } <line_num>: 227,351
private Node tryFoldStringIndexOf(Node n, String functionName, Node lstringNode, Node firstArg) { [EOL]     Preconditions.checkArgument(n.isCall()); [EOL]     Preconditions.checkArgument(lstringNode.isString()); [EOL]     String lstring = NodeUtil.getStringValue(lstringNode); [EOL]     boolean isIndexOf = functionName.equals("indexOf"); [EOL]     Node secondArg = firstArg.getNext(); [EOL]     String searchValue = NodeUtil.getStringValue(firstArg); [EOL]     if (searchValue == null) { [EOL]         return n; [EOL]     } [EOL]     int fromIndex = isIndexOf ? 0 : lstring.length(); [EOL]     if (secondArg != null) { [EOL]         if (secondArg.getNext() != null || !secondArg.isNumber()) { [EOL]             return n; [EOL]         } else { [EOL]             fromIndex = (int) secondArg.getDouble(); [EOL]         } [EOL]     } [EOL]     int indexVal = isIndexOf ? lstring.indexOf(searchValue, fromIndex) : lstring.lastIndexOf(searchValue, fromIndex); [EOL]     Node newNode = IR.number(indexVal); [EOL]     n.getParent().replaceChild(n, newNode); [EOL]     reportCodeChange(); [EOL]     return newNode; [EOL] } <line_num>: 358,388
private Node tryFoldArrayJoin(Node n) { [EOL]     Node callTarget = n.getFirstChild(); [EOL]     if (callTarget == null || !callTarget.isGetProp()) { [EOL]         return n; [EOL]     } [EOL]     Node right = callTarget.getNext(); [EOL]     if (right != null) { [EOL]         if (right.getNext() != null || !NodeUtil.isImmutableValue(right)) { [EOL]             return n; [EOL]         } [EOL]     } [EOL]     Node arrayNode = callTarget.getFirstChild(); [EOL]     Node functionName = arrayNode.getNext(); [EOL]     if (!arrayNode.isArrayLit() || !functionName.getString().equals("join")) { [EOL]         return n; [EOL]     } [EOL]     if (right != null && right.isString() && ",".equals(right.getString())) { [EOL]         n.removeChild(right); [EOL]         reportCodeChange(); [EOL]     } [EOL]     String joinString = (right == null) ? "," : NodeUtil.getStringValue(right); [EOL]     List<Node> arrayFoldedChildren = Lists.newLinkedList(); [EOL]     StringBuilder sb = null; [EOL]     int foldedSize = 0; [EOL]     Node prev = null; [EOL]     Node elem = arrayNode.getFirstChild(); [EOL]     while (elem != null) { [EOL]         if (NodeUtil.isImmutableValue(elem) || elem.isEmpty()) { [EOL]             if (sb == null) { [EOL]                 sb = new StringBuilder(); [EOL]             } else { [EOL]                 sb.append(joinString); [EOL]             } [EOL]             sb.append(NodeUtil.getArrayElementStringValue(elem)); [EOL]         } else { [EOL]             if (sb != null) { [EOL]                 Preconditions.checkNotNull(prev); [EOL]                 foldedSize += sb.length() + 2; [EOL]                 arrayFoldedChildren.add(IR.string(sb.toString()).copyInformationFrom(prev)); [EOL]                 sb = null; [EOL]             } [EOL]             foldedSize += InlineCostEstimator.getCost(elem); [EOL]             arrayFoldedChildren.add(elem); [EOL]         } [EOL]         prev = elem; [EOL]         elem = elem.getNext(); [EOL]     } [EOL]     if (sb != null) { [EOL]         Preconditions.checkNotNull(prev); [EOL]         foldedSize += sb.length() + 2; [EOL]         arrayFoldedChildren.add(IR.string(sb.toString()).copyInformationFrom(prev)); [EOL]     } [EOL]     foldedSize += arrayFoldedChildren.size() - 1; [EOL]     int originalSize = InlineCostEstimator.getCost(n); [EOL]     switch(arrayFoldedChildren.size()) { [EOL]         case 0: [EOL]             Node emptyStringNode = IR.string(""); [EOL]             n.getParent().replaceChild(n, emptyStringNode); [EOL]             reportCodeChange(); [EOL]             return emptyStringNode; [EOL]         case 1: [EOL]             Node foldedStringNode = arrayFoldedChildren.remove(0); [EOL]             if (foldedSize > originalSize) { [EOL]                 return n; [EOL]             } [EOL]             arrayNode.detachChildren(); [EOL]             if (!foldedStringNode.isString()) { [EOL]                 Node replacement = IR.add(IR.string("").srcref(n), foldedStringNode); [EOL]                 foldedStringNode = replacement; [EOL]             } [EOL]             n.getParent().replaceChild(n, foldedStringNode); [EOL]             reportCodeChange(); [EOL]             return foldedStringNode; [EOL]         default: [EOL]             if (arrayFoldedChildren.size() == arrayNode.getChildCount()) { [EOL]                 return n; [EOL]             } [EOL]             int kJoinOverhead = "[].join()".length(); [EOL]             foldedSize += kJoinOverhead; [EOL]             foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0; [EOL]             if (foldedSize > originalSize) { [EOL]                 return n; [EOL]             } [EOL]             arrayNode.detachChildren(); [EOL]             for (Node node : arrayFoldedChildren) { [EOL]                 arrayNode.addChildToBack(node); [EOL]             } [EOL]             reportCodeChange(); [EOL]             break; [EOL]     } [EOL]     return n; [EOL] } <line_num>: 393,507
private Node tryFoldStringSubstr(Node n, Node stringNode, Node arg1) { [EOL]     Preconditions.checkArgument(n.isCall()); [EOL]     Preconditions.checkArgument(stringNode.isString()); [EOL]     int start, length; [EOL]     String stringAsString = stringNode.getString(); [EOL]     if (arg1 != null && arg1.isNumber()) { [EOL]         start = (int) arg1.getDouble(); [EOL]     } else { [EOL]         return n; [EOL]     } [EOL]     Node arg2 = arg1.getNext(); [EOL]     if (arg2 != null) { [EOL]         if (arg2.isNumber()) { [EOL]             length = (int) arg2.getDouble(); [EOL]         } else { [EOL]             return n; [EOL]         } [EOL]         if (arg2.getNext() != null) { [EOL]             return n; [EOL]         } [EOL]     } else { [EOL]         length = stringAsString.length() - start; [EOL]     } [EOL]     if ((start + length) > stringAsString.length() || (length < 0) || (start < 0)) { [EOL]         return n; [EOL]     } [EOL]     String result = stringAsString.substring(start, start + length); [EOL]     Node resultNode = IR.string(result); [EOL]     Node parent = n.getParent(); [EOL]     parent.replaceChild(n, resultNode); [EOL]     reportCodeChange(); [EOL]     return resultNode; [EOL] } <line_num>: 512,561
private Node tryFoldStringSubstring(Node n, Node stringNode, Node arg1) { [EOL]     Preconditions.checkArgument(n.isCall()); [EOL]     Preconditions.checkArgument(stringNode.isString()); [EOL]     int start, end; [EOL]     String stringAsString = stringNode.getString(); [EOL]     if (arg1 != null && arg1.isNumber()) { [EOL]         start = (int) arg1.getDouble(); [EOL]     } else { [EOL]         return n; [EOL]     } [EOL]     Node arg2 = arg1.getNext(); [EOL]     if (arg2 != null) { [EOL]         if (arg2.isNumber()) { [EOL]             end = (int) arg2.getDouble(); [EOL]         } else { [EOL]             return n; [EOL]         } [EOL]         if (arg2.getNext() != null) { [EOL]             return n; [EOL]         } [EOL]     } else { [EOL]         end = stringAsString.length(); [EOL]     } [EOL]     if ((end > stringAsString.length()) || (start > stringAsString.length()) || (end < 0) || (start < 0)) { [EOL]         return n; [EOL]     } [EOL]     String result = stringAsString.substring(start, end); [EOL]     Node resultNode = IR.string(result); [EOL]     Node parent = n.getParent(); [EOL]     parent.replaceChild(n, resultNode); [EOL]     reportCodeChange(); [EOL]     return resultNode; [EOL] } <line_num>: 566,614
private Node tryFoldStringCharAt(Node n, Node stringNode, Node arg1) { [EOL]     Preconditions.checkArgument(n.isCall()); [EOL]     Preconditions.checkArgument(stringNode.isString()); [EOL]     int index; [EOL]     String stringAsString = stringNode.getString(); [EOL]     if (arg1 != null && arg1.isNumber() && arg1.getNext() == null) { [EOL]         index = (int) arg1.getDouble(); [EOL]     } else { [EOL]         return n; [EOL]     } [EOL]     if (index < 0 || stringAsString.length() <= index) { [EOL]         return n; [EOL]     } [EOL]     Node resultNode = IR.string(stringAsString.substring(index, index + 1)); [EOL]     Node parent = n.getParent(); [EOL]     parent.replaceChild(n, resultNode); [EOL]     reportCodeChange(); [EOL]     return resultNode; [EOL] } <line_num>: 619,645
private Node tryFoldStringCharCodeAt(Node n, Node stringNode, Node arg1) { [EOL]     Preconditions.checkArgument(n.isCall()); [EOL]     Preconditions.checkArgument(stringNode.isString()); [EOL]     int index; [EOL]     String stringAsString = stringNode.getString(); [EOL]     if (arg1 != null && arg1.isNumber() && arg1.getNext() == null) { [EOL]         index = (int) arg1.getDouble(); [EOL]     } else { [EOL]         return n; [EOL]     } [EOL]     if (index < 0 || stringAsString.length() <= index) { [EOL]         return n; [EOL]     } [EOL]     Node resultNode = IR.number(stringAsString.charAt(index)); [EOL]     Node parent = n.getParent(); [EOL]     parent.replaceChild(n, resultNode); [EOL]     reportCodeChange(); [EOL]     return resultNode; [EOL] } <line_num>: 650,675
private int jsSplitMatch(String stringValue, int startIndex, String separator) { [EOL]     if (startIndex + separator.length() > stringValue.length()) { [EOL]         return -1; [EOL]     } [EOL]     int matchIndex = stringValue.indexOf(separator, startIndex); [EOL]     if (matchIndex < 0) { [EOL]         return -1; [EOL]     } [EOL]     return matchIndex; [EOL] } <line_num>: 681,695
private String[] jsSplit(String stringValue, String separator, int limit) { [EOL]     Preconditions.checkArgument(limit >= 0); [EOL]     Preconditions.checkArgument(stringValue != null); [EOL]     if (limit == 0) { [EOL]         return new String[0]; [EOL]     } [EOL]     if (separator == null) { [EOL]         return new String[] { stringValue }; [EOL]     } [EOL]     List<String> splitStrings = Lists.newArrayList(); [EOL]     if (separator.length() == 0) { [EOL]         for (int i = 0; i < stringValue.length() && i < limit; i++) { [EOL]             splitStrings.add(stringValue.substring(i, i + 1)); [EOL]         } [EOL]     } else { [EOL]         int startIndex = 0, matchIndex; [EOL]         while ((matchIndex = jsSplitMatch(stringValue, startIndex, separator)) >= 0 && splitStrings.size() < limit) { [EOL]             splitStrings.add(stringValue.substring(startIndex, matchIndex)); [EOL]             startIndex = matchIndex + separator.length(); [EOL]         } [EOL]         if (splitStrings.size() < limit) { [EOL]             if (startIndex < stringValue.length()) { [EOL]                 splitStrings.add(stringValue.substring(startIndex)); [EOL]             } else { [EOL]                 splitStrings.add(""); [EOL]             } [EOL]         } [EOL]     } [EOL]     return splitStrings.toArray(new String[splitStrings.size()]); [EOL] } <line_num>: 700,743
private Node tryFoldStringSplit(Node n, Node stringNode, Node arg1) { [EOL]     if (late) { [EOL]         return n; [EOL]     } [EOL]     Preconditions.checkArgument(n.isCall()); [EOL]     Preconditions.checkArgument(stringNode.isString()); [EOL]     String separator = null; [EOL]     String stringValue = stringNode.getString(); [EOL]     int limit = stringValue.length() + 1; [EOL]     if (arg1 != null) { [EOL]         if (arg1.isString()) { [EOL]             separator = arg1.getString(); [EOL]         } else if (!arg1.isNull()) { [EOL]             return n; [EOL]         } [EOL]         Node arg2 = arg1.getNext(); [EOL]         if (arg2 != null) { [EOL]             if (arg2.isNumber()) { [EOL]                 limit = Math.min((int) arg2.getDouble(), limit); [EOL]                 if (limit < 0) { [EOL]                     return n; [EOL]                 } [EOL]             } else { [EOL]                 return n; [EOL]             } [EOL]         } [EOL]     } [EOL]     String[] stringArray = jsSplit(stringValue, separator, limit); [EOL]     Node arrayOfStrings = IR.arraylit(); [EOL]     for (int i = 0; i < stringArray.length; i++) { [EOL]         arrayOfStrings.addChildToBack(IR.string(stringArray[i]).srcref(stringNode)); [EOL]     } [EOL]     Node parent = n.getParent(); [EOL]     parent.replaceChild(n, arrayOfStrings); [EOL]     reportCodeChange(); [EOL]     return arrayOfStrings; [EOL] } <line_num>: 748,794
