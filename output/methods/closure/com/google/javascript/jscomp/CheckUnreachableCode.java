CheckUnreachableCode(AbstractCompiler compiler, CheckLevel level) { [EOL]     this.compiler = compiler; [EOL]     this.level = level; [EOL] } <line_num>: 41,44
@Override [EOL] public void enterScope(NodeTraversal t) { [EOL]     initScope(t.getControlFlowGraph()); [EOL] } <line_num>: 46,49
@Override [EOL] public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { [EOL]     GraphNode<Node, Branch> gNode = t.getControlFlowGraph().getNode(n); [EOL]     if (gNode != null && gNode.getAnnotation() != GraphReachability.REACHABLE) { [EOL]         if (n.getLineno() != -1 && !n.isEmpty() && !n.isBreak()) { [EOL]             compiler.report(t.makeError(n, level, UNREACHABLE_CODE)); [EOL]             new GraphReachability<Node, ControlFlowGraph.Branch>(t.getControlFlowGraph()).recompute(n); [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 51,74
private void initScope(ControlFlowGraph<Node> controlFlowGraph) { [EOL]     new GraphReachability<Node, ControlFlowGraph.Branch>(controlFlowGraph, new ReachablePredicate()).compute(controlFlowGraph.getEntry().getValue()); [EOL] } <line_num>: 76,80
@Override [EOL] public void exitScope(NodeTraversal t) { [EOL] } <line_num>: 82,84
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL] } <line_num>: 86,88
@Override [EOL] public boolean apply(EdgeTuple<Node, Branch> input) { [EOL]     Branch branch = input.edge; [EOL]     if (!branch.isConditional()) { [EOL]         return true; [EOL]     } [EOL]     Node predecessor = input.sourceNode; [EOL]     Node condition = NodeUtil.getConditionExpression(predecessor); [EOL]     if (condition != null) { [EOL]         TernaryValue val = NodeUtil.getImpureBooleanValue(condition); [EOL]         if (val != TernaryValue.UNKNOWN) { [EOL]             return val.toBoolean(true) == (branch == Branch.ON_TRUE); [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 93,111
