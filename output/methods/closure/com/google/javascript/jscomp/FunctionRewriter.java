FunctionRewriter(AbstractCompiler compiler) { [EOL]     this.compiler = compiler; [EOL] } <line_num>: 53,55
Reduction(Node parent, Node oldChild, Node newChild) { [EOL]     this.parent = parent; [EOL]     this.oldChild = oldChild; [EOL]     this.newChild = newChild; [EOL] } <line_num>: 130,134
ReductionGatherer(List<Reducer> reducers, Multimap<Reducer, Reduction> reductions) { [EOL]     this.reducers = reducers; [EOL]     this.reductions = reductions; [EOL] } <line_num>: 167,171
@Override [EOL] public void process(Node externs, Node root) { [EOL]     List<Reducer> reducers = ImmutableList.of(new ReturnConstantReducer(), new GetterReducer(), new SetterReducer(), new EmptyFunctionReducer(), new IdentityReducer()); [EOL]     Multimap<Reducer, Reduction> reductionMap = HashMultimap.create(); [EOL]     NodeTraversal.traverse(compiler, root, new ReductionGatherer(reducers, reductionMap)); [EOL]     for (Reducer reducer : reducers) { [EOL]         Collection<Reduction> reductions = reductionMap.get(reducer); [EOL]         if (reductions.isEmpty()) { [EOL]             continue; [EOL]         } [EOL]         Node helperCode = parseHelperCode(reducer); [EOL]         if (helperCode == null) { [EOL]             continue; [EOL]         } [EOL]         int helperCodeCost = InlineCostEstimator.getCost(helperCode); [EOL]         int savings = 0; [EOL]         for (Reduction reduction : reductions) { [EOL]             savings += reduction.estimateSavings(); [EOL]         } [EOL]         if (savings > (helperCodeCost + SAVINGS_THRESHOLD)) { [EOL]             for (Reduction reduction : reductions) { [EOL]                 reduction.apply(); [EOL]             } [EOL]             Node addingRoot = compiler.getNodeForCodeInsertion(null); [EOL]             addingRoot.addChildrenToFront(helperCode); [EOL]             compiler.reportCodeChange(); [EOL]         } [EOL]     } [EOL] } <line_num>: 57,104
public Node parseHelperCode(Reducer reducer) { [EOL]     Node root = compiler.parseSyntheticCode(reducer.getClass().toString() + ":helper", reducer.getHelperSource()); [EOL]     return (root != null) ? root.removeFirstChild() : null; [EOL] } <line_num>: 111,115
private static boolean isReduceableFunctionExpression(Node n) { [EOL]     return NodeUtil.isFunctionExpression(n) && !NodeUtil.isGetOrSetKey(n.getParent()); [EOL] } <line_num>: 117,120
void apply() { [EOL]     parent.replaceChild(oldChild, newChild); [EOL]     compiler.reportCodeChange(); [EOL] } <line_num>: 139,142
int estimateSavings() { [EOL]     return InlineCostEstimator.getCost(oldChild) - InlineCostEstimator.getCost(newChild); [EOL] } <line_num>: 147,150
@Override [EOL] public boolean shouldTraverse(NodeTraversal raversal, Node node, Node parent) { [EOL]     for (Reducer reducer : reducers) { [EOL]         Node replacement = reducer.reduce(node); [EOL]         if (replacement != node) { [EOL]             reductions.put(reducer, new Reduction(parent, node, replacement)); [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 173,185
@Override [EOL] public void visit(NodeTraversal traversal, Node node, Node parent) { [EOL] } <line_num>: 188,190
abstract String getHelperSource(); <line_num>: 200,200
abstract Node reduce(Node node); <line_num>: 206,206
protected final Node buildCallNode(String methodName, Node argumentNode, Node srcref) { [EOL]     Node call = IR.call(IR.name(methodName)).srcref(srcref); [EOL]     call.putBooleanProp(Node.FREE_CALL, true); [EOL]     if (argumentNode != null) { [EOL]         call.addChildToBack(argumentNode.cloneTree()); [EOL]     } [EOL]     return call; [EOL] } <line_num>: 215,223
@Override [EOL] public String getHelperSource() { [EOL]     return HELPER_SOURCE; [EOL] } <line_num>: 242,245
@Override [EOL] public Node reduce(Node node) { [EOL]     if (NodeUtil.isEmptyFunctionExpression(node)) { [EOL]         return buildCallNode(FACTORY_METHOD_NAME, null, node); [EOL]     } else { [EOL]         return node; [EOL]     } [EOL] } <line_num>: 247,254
protected final Node maybeGetSingleReturnRValue(Node functionNode) { [EOL]     Node body = functionNode.getLastChild(); [EOL]     if (!body.hasOneChild()) { [EOL]         return null; [EOL]     } [EOL]     Node statement = body.getFirstChild(); [EOL]     if (statement.isReturn()) { [EOL]         return statement.getFirstChild(); [EOL]     } [EOL]     return null; [EOL] } <line_num>: 267,278
@Override [EOL] public String getHelperSource() { [EOL]     return HELPER_SOURCE; [EOL] } <line_num>: 298,301
@Override [EOL] public Node reduce(Node node) { [EOL]     if (!isReduceableFunctionExpression(node)) { [EOL]         return node; [EOL]     } [EOL]     if (isIdentityFunction(node)) { [EOL]         return buildCallNode(FACTORY_METHOD_NAME, null, node); [EOL]     } else { [EOL]         return node; [EOL]     } [EOL] } <line_num>: 303,314
private boolean isIdentityFunction(Node functionNode) { [EOL]     Node argList = functionNode.getFirstChild().getNext(); [EOL]     Node paramNode = argList.getFirstChild(); [EOL]     if (paramNode == null) { [EOL]         return false; [EOL]     } [EOL]     Node value = maybeGetSingleReturnRValue(functionNode); [EOL]     if (value != null && value.isName() && value.getString().equals(paramNode.getString())) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 322,336
@Override [EOL] public String getHelperSource() { [EOL]     return HELPER_SOURCE; [EOL] } <line_num>: 357,360
@Override [EOL] public Node reduce(Node node) { [EOL]     if (!isReduceableFunctionExpression(node)) { [EOL]         return node; [EOL]     } [EOL]     Node valueNode = getValueNode(node); [EOL]     if (valueNode != null) { [EOL]         return buildCallNode(FACTORY_METHOD_NAME, valueNode, node); [EOL]     } else { [EOL]         return node; [EOL]     } [EOL] } <line_num>: 362,374
private Node getValueNode(Node functionNode) { [EOL]     Node value = maybeGetSingleReturnRValue(functionNode); [EOL]     if (value != null && NodeUtil.isImmutableValue(value)) { [EOL]         return value; [EOL]     } [EOL]     return null; [EOL] } <line_num>: 383,390
@Override [EOL] public String getHelperSource() { [EOL]     return HELPER_SOURCE; [EOL] } <line_num>: 410,413
@Override [EOL] public Node reduce(Node node) { [EOL]     if (!isReduceableFunctionExpression(node)) { [EOL]         return node; [EOL]     } [EOL]     Node propName = getGetPropertyName(node); [EOL]     if (propName != null) { [EOL]         if (!propName.isString()) { [EOL]             throw new IllegalStateException("Expected STRING, got " + Token.name(propName.getType())); [EOL]         } [EOL]         return buildCallNode(FACTORY_METHOD_NAME, propName, node); [EOL]     } else { [EOL]         return node; [EOL]     } [EOL] } <line_num>: 415,432
private Node getGetPropertyName(Node functionNode) { [EOL]     Node value = maybeGetSingleReturnRValue(functionNode); [EOL]     if (value != null && value.isGetProp() && value.getFirstChild().isThis()) { [EOL]         return value.getLastChild(); [EOL]     } [EOL]     return null; [EOL] } <line_num>: 441,449
@Override [EOL] public String getHelperSource() { [EOL]     return HELPER_SOURCE; [EOL] } <line_num>: 471,474
@Override [EOL] public Node reduce(Node node) { [EOL]     if (!isReduceableFunctionExpression(node)) { [EOL]         return node; [EOL]     } [EOL]     Node propName = getSetPropertyName(node); [EOL]     if (propName != null) { [EOL]         if (!propName.isString()) { [EOL]             throw new IllegalStateException("Expected STRING, got " + Token.name(propName.getType())); [EOL]         } [EOL]         return buildCallNode(FACTORY_METHOD_NAME, propName, node); [EOL]     } else { [EOL]         return node; [EOL]     } [EOL] } <line_num>: 476,493
private Node getSetPropertyName(Node functionNode) { [EOL]     Node body = functionNode.getLastChild(); [EOL]     if (!body.hasOneChild()) { [EOL]         return null; [EOL]     } [EOL]     Node argList = functionNode.getFirstChild().getNext(); [EOL]     Node paramNode = argList.getFirstChild(); [EOL]     if (paramNode == null) { [EOL]         return null; [EOL]     } [EOL]     Node statement = body.getFirstChild(); [EOL]     if (!NodeUtil.isExprAssign(statement)) { [EOL]         return null; [EOL]     } [EOL]     Node assign = statement.getFirstChild(); [EOL]     Node lhs = assign.getFirstChild(); [EOL]     if (lhs.isGetProp() && lhs.getFirstChild().isThis()) { [EOL]         Node rhs = assign.getLastChild(); [EOL]         if (rhs.isName() && rhs.getString().equals(paramNode.getString())) { [EOL]             Node propertyName = lhs.getLastChild(); [EOL]             return propertyName; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 502,530
