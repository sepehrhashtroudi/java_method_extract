PeepholeFoldConstants(boolean late) { [EOL]     this.late = late; [EOL] } <line_num>: 74,76
@Override [EOL] Node optimizeSubtree(Node subtree) { [EOL]     switch(subtree.getType()) { [EOL]         case Token.NEW: [EOL]             return tryFoldCtorCall(subtree); [EOL]         case Token.TYPEOF: [EOL]             return tryFoldTypeof(subtree); [EOL]         case Token.NOT: [EOL]         case Token.POS: [EOL]         case Token.NEG: [EOL]         case Token.BITNOT: [EOL]             tryReduceOperandsForOp(subtree); [EOL]             return tryFoldUnaryOperator(subtree); [EOL]         case Token.VOID: [EOL]             return tryReduceVoid(subtree); [EOL]         default: [EOL]             tryReduceOperandsForOp(subtree); [EOL]             return tryFoldBinaryOperator(subtree); [EOL]     } [EOL] } <line_num>: 78,101
private Node tryFoldBinaryOperator(Node subtree) { [EOL]     Node left = subtree.getFirstChild(); [EOL]     if (left == null) { [EOL]         return subtree; [EOL]     } [EOL]     Node right = left.getNext(); [EOL]     if (right == null) { [EOL]         return subtree; [EOL]     } [EOL]     switch(subtree.getType()) { [EOL]         case Token.GETPROP: [EOL]             return tryFoldGetProp(subtree, left, right); [EOL]         case Token.GETELEM: [EOL]             return tryFoldGetElem(subtree, left, right); [EOL]         case Token.INSTANCEOF: [EOL]             return tryFoldInstanceof(subtree, left, right); [EOL]         case Token.AND: [EOL]         case Token.OR: [EOL]             return tryFoldAndOr(subtree, left, right); [EOL]         case Token.LSH: [EOL]         case Token.RSH: [EOL]         case Token.URSH: [EOL]             return tryFoldShift(subtree, left, right); [EOL]         case Token.ASSIGN: [EOL]             return tryFoldAssign(subtree, left, right); [EOL]         case Token.ASSIGN_BITOR: [EOL]         case Token.ASSIGN_BITXOR: [EOL]         case Token.ASSIGN_BITAND: [EOL]         case Token.ASSIGN_LSH: [EOL]         case Token.ASSIGN_RSH: [EOL]         case Token.ASSIGN_URSH: [EOL]         case Token.ASSIGN_ADD: [EOL]         case Token.ASSIGN_SUB: [EOL]         case Token.ASSIGN_MUL: [EOL]         case Token.ASSIGN_DIV: [EOL]         case Token.ASSIGN_MOD: [EOL]             return tryUnfoldAssignOp(subtree, left, right); [EOL]         case Token.ADD: [EOL]             return tryFoldAdd(subtree, left, right); [EOL]         case Token.SUB: [EOL]         case Token.DIV: [EOL]         case Token.MOD: [EOL]             return tryFoldArithmeticOp(subtree, left, right); [EOL]         case Token.MUL: [EOL]         case Token.BITAND: [EOL]         case Token.BITOR: [EOL]         case Token.BITXOR: [EOL]             Node result = tryFoldArithmeticOp(subtree, left, right); [EOL]             if (result != subtree) { [EOL]                 return result; [EOL]             } [EOL]             return tryFoldLeftChildOp(subtree, left, right); [EOL]         case Token.LT: [EOL]         case Token.GT: [EOL]         case Token.LE: [EOL]         case Token.GE: [EOL]         case Token.EQ: [EOL]         case Token.NE: [EOL]         case Token.SHEQ: [EOL]         case Token.SHNE: [EOL]             return tryFoldComparison(subtree, left, right); [EOL]         default: [EOL]             return subtree; [EOL]     } [EOL] } <line_num>: 103,183
private Node tryReduceVoid(Node n) { [EOL]     Node child = n.getFirstChild(); [EOL]     if (!child.isNumber() || child.getDouble() != 0.0) { [EOL]         if (!mayHaveSideEffects(n)) { [EOL]             n.replaceChild(child, IR.number(0)); [EOL]             reportCodeChange(); [EOL]         } [EOL]     } [EOL]     return n; [EOL] } <line_num>: 185,194
private void tryReduceOperandsForOp(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.ADD: [EOL]             Node left = n.getFirstChild(); [EOL]             Node right = n.getLastChild(); [EOL]             if (!NodeUtil.mayBeString(left) && !NodeUtil.mayBeString(right)) { [EOL]                 tryConvertOperandsToNumber(n); [EOL]             } [EOL]             break; [EOL]         case Token.ASSIGN_BITOR: [EOL]         case Token.ASSIGN_BITXOR: [EOL]         case Token.ASSIGN_BITAND: [EOL]         case Token.ASSIGN_LSH: [EOL]         case Token.ASSIGN_RSH: [EOL]         case Token.ASSIGN_URSH: [EOL]         case Token.ASSIGN_SUB: [EOL]         case Token.ASSIGN_MUL: [EOL]         case Token.ASSIGN_MOD: [EOL]         case Token.ASSIGN_DIV: [EOL]             tryConvertToNumber(n.getLastChild()); [EOL]             break; [EOL]         case Token.BITNOT: [EOL]         case Token.BITOR: [EOL]         case Token.BITXOR: [EOL]         case Token.BITAND: [EOL]         case Token.LSH: [EOL]         case Token.RSH: [EOL]         case Token.URSH: [EOL]         case Token.SUB: [EOL]         case Token.MUL: [EOL]         case Token.MOD: [EOL]         case Token.DIV: [EOL]         case Token.POS: [EOL]         case Token.NEG: [EOL]             tryConvertOperandsToNumber(n); [EOL]             break; [EOL]     } [EOL] } <line_num>: 196,234
private void tryConvertOperandsToNumber(Node n) { [EOL]     Node next; [EOL]     for (Node c = n.getFirstChild(); c != null; c = next) { [EOL]         next = c.getNext(); [EOL]         tryConvertToNumber(c); [EOL]     } [EOL] } <line_num>: 236,242
private void tryConvertToNumber(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.NUMBER: [EOL]             return; [EOL]         case Token.AND: [EOL]         case Token.OR: [EOL]         case Token.COMMA: [EOL]             tryConvertToNumber(n.getLastChild()); [EOL]             return; [EOL]         case Token.HOOK: [EOL]             tryConvertToNumber(n.getChildAtIndex(1)); [EOL]             tryConvertToNumber(n.getLastChild()); [EOL]             return; [EOL]         case Token.NAME: [EOL]             if (!NodeUtil.isUndefined(n)) { [EOL]                 return; [EOL]             } [EOL]             break; [EOL]     } [EOL]     Double result = NodeUtil.getNumberValue(n); [EOL]     if (result == null) { [EOL]         return; [EOL]     } [EOL]     double value = result; [EOL]     Node replacement = NodeUtil.numberNode(value, n); [EOL]     if (replacement.isEquivalentTo(n)) { [EOL]         return; [EOL]     } [EOL]     n.getParent().replaceChild(n, replacement); [EOL]     reportCodeChange(); [EOL] } <line_num>: 244,279
private Node tryFoldTypeof(Node originalTypeofNode) { [EOL]     Preconditions.checkArgument(originalTypeofNode.isTypeOf()); [EOL]     Node argumentNode = originalTypeofNode.getFirstChild(); [EOL]     if (argumentNode == null || !NodeUtil.isLiteralValue(argumentNode, true)) { [EOL]         return originalTypeofNode; [EOL]     } [EOL]     String typeNameString = null; [EOL]     switch(argumentNode.getType()) { [EOL]         case Token.FUNCTION: [EOL]             typeNameString = "function"; [EOL]             break; [EOL]         case Token.STRING: [EOL]             typeNameString = "string"; [EOL]             break; [EOL]         case Token.NUMBER: [EOL]             typeNameString = "number"; [EOL]             break; [EOL]         case Token.TRUE: [EOL]         case Token.FALSE: [EOL]             typeNameString = "boolean"; [EOL]             break; [EOL]         case Token.NULL: [EOL]         case Token.OBJECTLIT: [EOL]         case Token.ARRAYLIT: [EOL]             typeNameString = "object"; [EOL]             break; [EOL]         case Token.VOID: [EOL]             typeNameString = "undefined"; [EOL]             break; [EOL]         case Token.NAME: [EOL]             if ("undefined".equals(argumentNode.getString())) { [EOL]                 typeNameString = "undefined"; [EOL]             } [EOL]             break; [EOL]     } [EOL]     if (typeNameString != null) { [EOL]         Node newNode = IR.string(typeNameString); [EOL]         originalTypeofNode.getParent().replaceChild(originalTypeofNode, newNode); [EOL]         reportCodeChange(); [EOL]         return newNode; [EOL]     } [EOL]     return originalTypeofNode; [EOL] } <line_num>: 286,336
private Node tryFoldUnaryOperator(Node n) { [EOL]     Preconditions.checkState(n.hasOneChild()); [EOL]     Node left = n.getFirstChild(); [EOL]     Node parent = n.getParent(); [EOL]     if (left == null) { [EOL]         return n; [EOL]     } [EOL]     TernaryValue leftVal = NodeUtil.getPureBooleanValue(left); [EOL]     if (leftVal == TernaryValue.UNKNOWN) { [EOL]         return n; [EOL]     } [EOL]     switch(n.getType()) { [EOL]         case Token.NOT: [EOL]             if (late && left.isNumber()) { [EOL]                 double numValue = left.getDouble(); [EOL]                 if (numValue == 0 || numValue == 1) { [EOL]                     return n; [EOL]                 } [EOL]             } [EOL]             Node replacementNode = NodeUtil.booleanNode(!leftVal.toBoolean(true)); [EOL]             parent.replaceChild(n, replacementNode); [EOL]             reportCodeChange(); [EOL]             return replacementNode; [EOL]         case Token.POS: [EOL]             if (NodeUtil.isNumericResult(left)) { [EOL]                 parent.replaceChild(n, left.detachFromParent()); [EOL]                 reportCodeChange(); [EOL]                 return left; [EOL]             } [EOL]             return n; [EOL]         case Token.NEG: [EOL]             if (left.isName()) { [EOL]                 if (left.getString().equals("Infinity")) { [EOL]                     return n; [EOL]                 } else if (left.getString().equals("NaN")) { [EOL]                     n.removeChild(left); [EOL]                     parent.replaceChild(n, left); [EOL]                     reportCodeChange(); [EOL]                     return left; [EOL]                 } [EOL]             } [EOL]             if (left.isNumber()) { [EOL]                 double negNum = -left.getDouble(); [EOL]                 Node negNumNode = IR.number(negNum); [EOL]                 parent.replaceChild(n, negNumNode); [EOL]                 reportCodeChange(); [EOL]                 return negNumNode; [EOL]             } else { [EOL]                 report(NEGATING_A_NON_NUMBER_ERROR, left); [EOL]                 return n; [EOL]             } [EOL]         case Token.BITNOT: [EOL]             try { [EOL]                 double val = left.getDouble(); [EOL]                 if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) { [EOL]                     int intVal = (int) val; [EOL]                     if (intVal == val) { [EOL]                         Node notIntValNode = IR.number(~intVal); [EOL]                         parent.replaceChild(n, notIntValNode); [EOL]                         reportCodeChange(); [EOL]                         return notIntValNode; [EOL]                     } else { [EOL]                         report(FRACTIONAL_BITWISE_OPERAND, left); [EOL]                         return n; [EOL]                     } [EOL]                 } else { [EOL]                     report(BITWISE_OPERAND_OUT_OF_RANGE, left); [EOL]                     return n; [EOL]                 } [EOL]             } catch (UnsupportedOperationException ex) { [EOL]                 report(NEGATING_A_NON_NUMBER_ERROR, left); [EOL]                 return n; [EOL]             } [EOL]         default: [EOL]             return n; [EOL]     } [EOL] } <line_num>: 338,428
private Node tryFoldInstanceof(Node n, Node left, Node right) { [EOL]     Preconditions.checkArgument(n.isInstanceOf()); [EOL]     if (NodeUtil.isLiteralValue(left, true) && !mayHaveSideEffects(right)) { [EOL]         Node replacementNode = null; [EOL]         if (NodeUtil.isImmutableValue(left)) { [EOL]             replacementNode = IR.falseNode(); [EOL]         } else if (right.isName() && "Object".equals(right.getString())) { [EOL]             replacementNode = IR.trueNode(); [EOL]         } [EOL]         if (replacementNode != null) { [EOL]             n.getParent().replaceChild(n, replacementNode); [EOL]             reportCodeChange(); [EOL]             return replacementNode; [EOL]         } [EOL]     } [EOL]     return n; [EOL] } <line_num>: 434,460
private Node tryFoldAssign(Node n, Node left, Node right) { [EOL]     Preconditions.checkArgument(n.isAssign()); [EOL]     if (!late) { [EOL]         return n; [EOL]     } [EOL]     if (!right.hasChildren() || right.getFirstChild().getNext() != right.getLastChild()) { [EOL]         return n; [EOL]     } [EOL]     if (mayHaveSideEffects(left)) { [EOL]         return n; [EOL]     } [EOL]     Node newRight; [EOL]     if (areNodesEqualForInlining(left, right.getFirstChild())) { [EOL]         newRight = right.getLastChild(); [EOL]     } else if (NodeUtil.isCommutative(right.getType()) && areNodesEqualForInlining(left, right.getLastChild())) { [EOL]         newRight = right.getFirstChild(); [EOL]     } else { [EOL]         return n; [EOL]     } [EOL]     int newType = -1; [EOL]     switch(right.getType()) { [EOL]         case Token.ADD: [EOL]             newType = Token.ASSIGN_ADD; [EOL]             break; [EOL]         case Token.BITAND: [EOL]             newType = Token.ASSIGN_BITAND; [EOL]             break; [EOL]         case Token.BITOR: [EOL]             newType = Token.ASSIGN_BITOR; [EOL]             break; [EOL]         case Token.BITXOR: [EOL]             newType = Token.ASSIGN_BITXOR; [EOL]             break; [EOL]         case Token.DIV: [EOL]             newType = Token.ASSIGN_DIV; [EOL]             break; [EOL]         case Token.LSH: [EOL]             newType = Token.ASSIGN_LSH; [EOL]             break; [EOL]         case Token.MOD: [EOL]             newType = Token.ASSIGN_MOD; [EOL]             break; [EOL]         case Token.MUL: [EOL]             newType = Token.ASSIGN_MUL; [EOL]             break; [EOL]         case Token.RSH: [EOL]             newType = Token.ASSIGN_RSH; [EOL]             break; [EOL]         case Token.SUB: [EOL]             newType = Token.ASSIGN_SUB; [EOL]             break; [EOL]         case Token.URSH: [EOL]             newType = Token.ASSIGN_URSH; [EOL]             break; [EOL]         default: [EOL]             return n; [EOL]     } [EOL]     Node newNode = new Node(newType, left.detachFromParent(), newRight.detachFromParent()); [EOL]     n.getParent().replaceChild(n, newNode); [EOL]     reportCodeChange(); [EOL]     return newNode; [EOL] } <line_num>: 462,536
private Node tryUnfoldAssignOp(Node n, Node left, Node right) { [EOL]     if (late) { [EOL]         return n; [EOL]     } [EOL]     if (!n.hasChildren() || n.getFirstChild().getNext() != n.getLastChild()) { [EOL]         return n; [EOL]     } [EOL]     if (mayHaveSideEffects(left)) { [EOL]         return n; [EOL]     } [EOL]     int op = NodeUtil.getOpFromAssignmentOp(n); [EOL]     Node replacement = IR.assign(left.detachFromParent(), new Node(op, left.cloneTree(), right.detachFromParent()).srcref(n)); [EOL]     n.getParent().replaceChild(n, replacement); [EOL]     reportCodeChange(); [EOL]     return replacement; [EOL] } <line_num>: 538,561
private Node tryFoldAndOr(Node n, Node left, Node right) { [EOL]     Node parent = n.getParent(); [EOL]     Node result = null; [EOL]     int type = n.getType(); [EOL]     TernaryValue leftVal = NodeUtil.getImpureBooleanValue(left); [EOL]     if (leftVal != TernaryValue.UNKNOWN) { [EOL]         boolean lval = leftVal.toBoolean(true); [EOL]         if (lval && type == Token.OR || !lval && type == Token.AND) { [EOL]             result = left; [EOL]         } else if (!mayHaveSideEffects(left)) { [EOL]             result = right; [EOL]         } [EOL]     } [EOL]     if (result != null) { [EOL]         n.removeChild(result); [EOL]         parent.replaceChild(n, result); [EOL]         reportCodeChange(); [EOL]         return result; [EOL]     } else { [EOL]         return n; [EOL]     } [EOL] } <line_num>: 566,604
private Node tryFoldChildAddString(Node n, Node left, Node right) { [EOL]     if (NodeUtil.isLiteralValue(right, false) && left.isAdd()) { [EOL]         Node ll = left.getFirstChild(); [EOL]         Node lr = ll.getNext(); [EOL]         if (lr.isString()) { [EOL]             String leftString = NodeUtil.getStringValue(lr); [EOL]             String rightString = NodeUtil.getStringValue(right); [EOL]             if (leftString != null && rightString != null) { [EOL]                 left.removeChild(ll); [EOL]                 String result = leftString + rightString; [EOL]                 n.replaceChild(left, ll); [EOL]                 n.replaceChild(right, IR.string(result)); [EOL]                 reportCodeChange(); [EOL]                 return n; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (NodeUtil.isLiteralValue(left, false) && right.isAdd()) { [EOL]         Node rl = right.getFirstChild(); [EOL]         Node rr = right.getLastChild(); [EOL]         if (rl.isString()) { [EOL]             String leftString = NodeUtil.getStringValue(left); [EOL]             String rightString = NodeUtil.getStringValue(rl); [EOL]             if (leftString != null && rightString != null) { [EOL]                 right.removeChild(rr); [EOL]                 String result = leftString + rightString; [EOL]                 n.replaceChild(right, rr); [EOL]                 n.replaceChild(left, IR.string(result)); [EOL]                 reportCodeChange(); [EOL]                 return n; [EOL]             } [EOL]         } [EOL]     } [EOL]     return n; [EOL] } <line_num>: 615,664
private Node tryFoldAddConstantString(Node n, Node left, Node right) { [EOL]     if (left.isString() || right.isString()) { [EOL]         String leftString = NodeUtil.getStringValue(left); [EOL]         String rightString = NodeUtil.getStringValue(right); [EOL]         if (leftString != null && rightString != null) { [EOL]             Node newStringNode = IR.string(leftString + rightString); [EOL]             n.getParent().replaceChild(n, newStringNode); [EOL]             reportCodeChange(); [EOL]             return newStringNode; [EOL]         } [EOL]     } [EOL]     return n; [EOL] } <line_num>: 669,686
private Node tryFoldArithmeticOp(Node n, Node left, Node right) { [EOL]     Node result = performArithmeticOp(n.getType(), left, right); [EOL]     if (result != null) { [EOL]         result.copyInformationFromForTree(n); [EOL]         n.getParent().replaceChild(n, result); [EOL]         reportCodeChange(); [EOL]         return result; [EOL]     } [EOL]     return n; [EOL] } <line_num>: 691,700
private Node performArithmeticOp(int opType, Node left, Node right) { [EOL]     if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) { [EOL]         return null; [EOL]     } [EOL]     double result; [EOL]     Double lValObj = NodeUtil.getNumberValue(left); [EOL]     if (lValObj == null) { [EOL]         return null; [EOL]     } [EOL]     Double rValObj = NodeUtil.getNumberValue(right); [EOL]     if (rValObj == null) { [EOL]         return null; [EOL]     } [EOL]     double lval = lValObj; [EOL]     double rval = rValObj; [EOL]     switch(opType) { [EOL]         case Token.BITAND: [EOL]             result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval); [EOL]             break; [EOL]         case Token.BITOR: [EOL]             result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval); [EOL]             break; [EOL]         case Token.BITXOR: [EOL]             result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval); [EOL]             break; [EOL]         case Token.ADD: [EOL]             result = lval + rval; [EOL]             break; [EOL]         case Token.SUB: [EOL]             result = lval - rval; [EOL]             break; [EOL]         case Token.MUL: [EOL]             result = lval * rval; [EOL]             break; [EOL]         case Token.MOD: [EOL]             if (rval == 0) { [EOL]                 return null; [EOL]             } [EOL]             result = lval % rval; [EOL]             break; [EOL]         case Token.DIV: [EOL]             if (rval == 0) { [EOL]                 return null; [EOL]             } [EOL]             result = lval / rval; [EOL]             break; [EOL]         default: [EOL]             throw new Error("Unexpected arithmetic operator"); [EOL]     } [EOL]     if ((String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 && Math.abs(result) <= MAX_FOLD_NUMBER) || Double.isNaN(result) || result == Double.POSITIVE_INFINITY || result == Double.NEGATIVE_INFINITY) { [EOL]         return NodeUtil.numberNode(result, null); [EOL]     } [EOL]     return null; [EOL] } <line_num>: 705,780
private Node tryFoldLeftChildOp(Node n, Node left, Node right) { [EOL]     int opType = n.getType(); [EOL]     Preconditions.checkState((NodeUtil.isAssociative(opType) && NodeUtil.isCommutative(opType)) || n.isAdd()); [EOL]     Preconditions.checkState(!n.isAdd() || !NodeUtil.mayBeString(n)); [EOL]     Double rightValObj = NodeUtil.getNumberValue(right); [EOL]     if (rightValObj != null && left.getType() == opType) { [EOL]         Preconditions.checkState(left.getChildCount() == 2); [EOL]         Node ll = left.getFirstChild(); [EOL]         Node lr = ll.getNext(); [EOL]         Node valueToCombine = ll; [EOL]         Node replacement = performArithmeticOp(opType, valueToCombine, right); [EOL]         if (replacement == null) { [EOL]             valueToCombine = lr; [EOL]             replacement = performArithmeticOp(opType, valueToCombine, right); [EOL]         } [EOL]         if (replacement != null) { [EOL]             left.removeChild(valueToCombine); [EOL]             n.replaceChild(left, left.removeFirstChild()); [EOL]             replacement.copyInformationFromForTree(right); [EOL]             n.replaceChild(right, replacement); [EOL]             reportCodeChange(); [EOL]         } [EOL]     } [EOL]     return n; [EOL] } <line_num>: 791,829
private Node tryFoldAdd(Node node, Node left, Node right) { [EOL]     Preconditions.checkArgument(node.isAdd()); [EOL]     if (NodeUtil.mayBeString(node, true)) { [EOL]         if (NodeUtil.isLiteralValue(left, false) && NodeUtil.isLiteralValue(right, false)) { [EOL]             return tryFoldAddConstantString(node, left, right); [EOL]         } else { [EOL]             return tryFoldChildAddString(node, left, right); [EOL]         } [EOL]     } else { [EOL]         Node result = tryFoldArithmeticOp(node, left, right); [EOL]         if (result != node) { [EOL]             return result; [EOL]         } [EOL]         return tryFoldLeftChildOp(node, left, right); [EOL]     } [EOL] } <line_num>: 831,851
private Node tryFoldShift(Node n, Node left, Node right) { [EOL]     if (left.isNumber() && right.isNumber()) { [EOL]         double result; [EOL]         double lval = left.getDouble(); [EOL]         double rval = right.getDouble(); [EOL]         if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) { [EOL]             report(BITWISE_OPERAND_OUT_OF_RANGE, left); [EOL]             return n; [EOL]         } [EOL]         if (!(rval >= 0 && rval < 32)) { [EOL]             report(SHIFT_AMOUNT_OUT_OF_BOUNDS, right); [EOL]             return n; [EOL]         } [EOL]         int lvalInt = (int) lval; [EOL]         if (lvalInt != lval) { [EOL]             report(FRACTIONAL_BITWISE_OPERAND, left); [EOL]             return n; [EOL]         } [EOL]         int rvalInt = (int) rval; [EOL]         if (rvalInt != rval) { [EOL]             report(FRACTIONAL_BITWISE_OPERAND, right); [EOL]             return n; [EOL]         } [EOL]         switch(n.getType()) { [EOL]             case Token.LSH: [EOL]                 result = lvalInt << rvalInt; [EOL]                 break; [EOL]             case Token.RSH: [EOL]                 result = lvalInt >> rvalInt; [EOL]                 break; [EOL]             case Token.URSH: [EOL]                 long lvalLong = lvalInt & 0xffffffffL; [EOL]                 result = lvalLong >>> rvalInt; [EOL]                 break; [EOL]             default: [EOL]                 throw new AssertionError("Unknown shift operator: " + Token.name(n.getType())); [EOL]         } [EOL]         Node newNumber = IR.number(result); [EOL]         n.getParent().replaceChild(n, newNumber); [EOL]         reportCodeChange(); [EOL]         return newNumber; [EOL]     } [EOL]     return n; [EOL] } <line_num>: 856,918
@SuppressWarnings("fallthrough") [EOL] private Node tryFoldComparison(Node n, Node left, Node right) { [EOL]     TernaryValue result = evaluateComparison(n.getType(), left, right); [EOL]     if (result == TernaryValue.UNKNOWN) { [EOL]         return n; [EOL]     } [EOL]     Node newNode = NodeUtil.booleanNode(result.toBoolean(true)); [EOL]     n.getParent().replaceChild(n, newNode); [EOL]     reportCodeChange(); [EOL]     return newNode; [EOL] } <line_num>: 923,935
static TernaryValue evaluateComparison(int op, Node left, Node right) { [EOL]     boolean leftLiteral = NodeUtil.isLiteralValue(left, true); [EOL]     boolean rightLiteral = NodeUtil.isLiteralValue(right, true); [EOL]     if (!leftLiteral || !rightLiteral) { [EOL]         if (op != Token.GT && op != Token.LT) { [EOL]             return TernaryValue.UNKNOWN; [EOL]         } [EOL]     } [EOL]     boolean undefinedRight = NodeUtil.isUndefined(right) && rightLiteral; [EOL]     boolean nullRight = right.isNull(); [EOL]     int lhType = getNormalizedNodeType(left); [EOL]     int rhType = getNormalizedNodeType(right); [EOL]     switch(lhType) { [EOL]         case Token.VOID: [EOL]             if (!leftLiteral) { [EOL]                 return TernaryValue.UNKNOWN; [EOL]             } else if (!rightLiteral) { [EOL]                 return TernaryValue.UNKNOWN; [EOL]             } else { [EOL]                 return TernaryValue.forBoolean(compareToUndefined(right, op)); [EOL]             } [EOL]         case Token.NULL: [EOL]             if (rightLiteral && isEqualityOp(op)) { [EOL]                 return TernaryValue.forBoolean(compareToNull(right, op)); [EOL]             } [EOL]         case Token.TRUE: [EOL]         case Token.FALSE: [EOL]             if (undefinedRight) { [EOL]                 return TernaryValue.forBoolean(compareToUndefined(left, op)); [EOL]             } [EOL]             if (rhType != Token.TRUE && rhType != Token.FALSE && rhType != Token.NULL) { [EOL]                 return TernaryValue.UNKNOWN; [EOL]             } [EOL]             switch(op) { [EOL]                 case Token.SHEQ: [EOL]                 case Token.EQ: [EOL]                     return TernaryValue.forBoolean(lhType == rhType); [EOL]                 case Token.SHNE: [EOL]                 case Token.NE: [EOL]                     return TernaryValue.forBoolean(lhType != rhType); [EOL]                 case Token.GE: [EOL]                 case Token.LE: [EOL]                 case Token.GT: [EOL]                 case Token.LT: [EOL]                     return compareAsNumbers(op, left, right); [EOL]             } [EOL]             return TernaryValue.UNKNOWN; [EOL]         case Token.THIS: [EOL]             if (!right.isThis()) { [EOL]                 return TernaryValue.UNKNOWN; [EOL]             } [EOL]             switch(op) { [EOL]                 case Token.SHEQ: [EOL]                 case Token.EQ: [EOL]                     return TernaryValue.TRUE; [EOL]                 case Token.SHNE: [EOL]                 case Token.NE: [EOL]                     return TernaryValue.FALSE; [EOL]             } [EOL]             return TernaryValue.UNKNOWN; [EOL]         case Token.STRING: [EOL]             if (undefinedRight) { [EOL]                 return TernaryValue.forBoolean(compareToUndefined(left, op)); [EOL]             } [EOL]             if (nullRight && isEqualityOp(op)) { [EOL]                 return TernaryValue.forBoolean(compareToNull(left, op)); [EOL]             } [EOL]             if (Token.STRING != right.getType()) { [EOL]                 return TernaryValue.UNKNOWN; [EOL]             } [EOL]             switch(op) { [EOL]                 case Token.SHEQ: [EOL]                 case Token.EQ: [EOL]                     return areStringsEqual(left.getString(), right.getString()); [EOL]                 case Token.SHNE: [EOL]                 case Token.NE: [EOL]                     return areStringsEqual(left.getString(), right.getString()).not(); [EOL]             } [EOL]             return TernaryValue.UNKNOWN; [EOL]         case Token.NUMBER: [EOL]             if (undefinedRight) { [EOL]                 return TernaryValue.forBoolean(compareToUndefined(left, op)); [EOL]             } [EOL]             if (nullRight && isEqualityOp(op)) { [EOL]                 return TernaryValue.forBoolean(compareToNull(left, op)); [EOL]             } [EOL]             if (Token.NUMBER != right.getType()) { [EOL]                 return TernaryValue.UNKNOWN; [EOL]             } [EOL]             return compareAsNumbers(op, left, right); [EOL]         case Token.NAME: [EOL]             if (leftLiteral && undefinedRight) { [EOL]                 return TernaryValue.forBoolean(compareToUndefined(left, op)); [EOL]             } [EOL]             if (rightLiteral) { [EOL]                 boolean undefinedLeft = (left.getString().equals("undefined")); [EOL]                 if (undefinedLeft) { [EOL]                     return TernaryValue.forBoolean(compareToUndefined(right, op)); [EOL]                 } [EOL]                 if (leftLiteral && nullRight && isEqualityOp(op)) { [EOL]                     return TernaryValue.forBoolean(compareToNull(left, op)); [EOL]                 } [EOL]             } [EOL]             if (Token.NAME != right.getType()) { [EOL]                 return TernaryValue.UNKNOWN; [EOL]             } [EOL]             String ln = left.getString(); [EOL]             String rn = right.getString(); [EOL]             if (!ln.equals(rn)) { [EOL]                 return TernaryValue.UNKNOWN; [EOL]             } [EOL]             switch(op) { [EOL]                 case Token.LT: [EOL]                 case Token.GT: [EOL]                     return TernaryValue.FALSE; [EOL]             } [EOL]             return TernaryValue.UNKNOWN; [EOL]         case Token.NEG: [EOL]             if (leftLiteral) { [EOL]                 if (undefinedRight) { [EOL]                     return TernaryValue.forBoolean(compareToUndefined(left, op)); [EOL]                 } [EOL]                 if (nullRight && isEqualityOp(op)) { [EOL]                     return TernaryValue.forBoolean(compareToNull(left, op)); [EOL]                 } [EOL]             } [EOL]             return TernaryValue.UNKNOWN; [EOL]         case Token.ARRAYLIT: [EOL]         case Token.OBJECTLIT: [EOL]         case Token.REGEXP: [EOL]         case Token.FUNCTION: [EOL]             if (leftLiteral) { [EOL]                 if (undefinedRight) { [EOL]                     return TernaryValue.forBoolean(compareToUndefined(left, op)); [EOL]                 } [EOL]                 if (nullRight && isEqualityOp(op)) { [EOL]                     return TernaryValue.forBoolean(compareToNull(left, op)); [EOL]                 } [EOL]             } [EOL]             return TernaryValue.UNKNOWN; [EOL]         default: [EOL]             return TernaryValue.UNKNOWN; [EOL]     } [EOL] } <line_num>: 937,1114
private static TernaryValue areStringsEqual(String a, String b) { [EOL]     if (a.indexOf('\u000B') != -1 || b.indexOf('\u000B') != -1) { [EOL]         return TernaryValue.UNKNOWN; [EOL]     } else { [EOL]         return a.equals(b) ? TernaryValue.TRUE : TernaryValue.FALSE; [EOL]     } [EOL] } <line_num>: 1117,1126
private static int getNormalizedNodeType(Node n) { [EOL]     int type = n.getType(); [EOL]     if (type == Token.NOT) { [EOL]         TernaryValue value = NodeUtil.getPureBooleanValue(n); [EOL]         switch(value) { [EOL]             case TRUE: [EOL]                 return Token.TRUE; [EOL]             case FALSE: [EOL]                 return Token.FALSE; [EOL]             case UNKNOWN: [EOL]                 return type; [EOL]         } [EOL]     } [EOL]     return type; [EOL] } <line_num>: 1131,1145
private static TernaryValue compareAsNumbers(int op, Node left, Node right) { [EOL]     Double leftValue = NodeUtil.getNumberValue(left); [EOL]     if (leftValue == null) { [EOL]         return TernaryValue.UNKNOWN; [EOL]     } [EOL]     Double rightValue = NodeUtil.getNumberValue(right); [EOL]     if (rightValue == null) { [EOL]         return TernaryValue.UNKNOWN; [EOL]     } [EOL]     double lv = leftValue; [EOL]     double rv = rightValue; [EOL]     switch(op) { [EOL]         case Token.SHEQ: [EOL]         case Token.EQ: [EOL]             Preconditions.checkState(left.isNumber() && right.isNumber()); [EOL]             return TernaryValue.forBoolean(lv == rv); [EOL]         case Token.SHNE: [EOL]         case Token.NE: [EOL]             Preconditions.checkState(left.isNumber() && right.isNumber()); [EOL]             return TernaryValue.forBoolean(lv != rv); [EOL]         case Token.LE: [EOL]             return TernaryValue.forBoolean(lv <= rv); [EOL]         case Token.LT: [EOL]             return TernaryValue.forBoolean(lv < rv); [EOL]         case Token.GE: [EOL]             return TernaryValue.forBoolean(lv >= rv); [EOL]         case Token.GT: [EOL]             return TernaryValue.forBoolean(lv > rv); [EOL]         default: [EOL]             return TernaryValue.UNKNOWN; [EOL]     } [EOL] } <line_num>: 1151,1186
private static boolean compareToUndefined(Node value, int op) { [EOL]     Preconditions.checkState(NodeUtil.isLiteralValue(value, true)); [EOL]     boolean valueUndefined = NodeUtil.isUndefined(value); [EOL]     boolean valueNull = (Token.NULL == value.getType()); [EOL]     boolean equivalent = valueUndefined || valueNull; [EOL]     switch(op) { [EOL]         case Token.EQ: [EOL]             return equivalent; [EOL]         case Token.NE: [EOL]             return !equivalent; [EOL]         case Token.SHEQ: [EOL]             return valueUndefined; [EOL]         case Token.SHNE: [EOL]             return !valueUndefined; [EOL]         case Token.LT: [EOL]         case Token.GT: [EOL]         case Token.LE: [EOL]         case Token.GE: [EOL]             return false; [EOL]         default: [EOL]             throw new IllegalStateException("unexpected."); [EOL]     } [EOL] } <line_num>: 1193,1216
private static boolean isEqualityOp(int op) { [EOL]     switch(op) { [EOL]         case Token.EQ: [EOL]         case Token.NE: [EOL]         case Token.SHEQ: [EOL]         case Token.SHNE: [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1218,1227
private static boolean compareToNull(Node value, int op) { [EOL]     boolean valueUndefined = NodeUtil.isUndefined(value); [EOL]     boolean valueNull = (Token.NULL == value.getType()); [EOL]     boolean equivalent = valueUndefined || valueNull; [EOL]     switch(op) { [EOL]         case Token.EQ: [EOL]             return equivalent; [EOL]         case Token.NE: [EOL]             return !equivalent; [EOL]         case Token.SHEQ: [EOL]             return valueNull; [EOL]         case Token.SHNE: [EOL]             return !valueNull; [EOL]         default: [EOL]             throw new IllegalStateException("unexpected."); [EOL]     } [EOL] } <line_num>: 1234,1251
private Node tryFoldCtorCall(Node n) { [EOL]     Preconditions.checkArgument(n.isNew()); [EOL]     if (inForcedStringContext(n)) { [EOL]         return tryFoldInForcedStringContext(n); [EOL]     } [EOL]     return n; [EOL] } <line_num>: 1257,1265
private boolean inForcedStringContext(Node n) { [EOL]     if (n.getParent().isGetElem() && n.getParent().getLastChild() == n) { [EOL]         return true; [EOL]     } [EOL]     if (n.getParent().isAdd()) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1268,1279
private Node tryFoldInForcedStringContext(Node n) { [EOL]     Preconditions.checkArgument(n.isNew()); [EOL]     Node objectType = n.getFirstChild(); [EOL]     if (!objectType.isName()) { [EOL]         return n; [EOL]     } [EOL]     if (objectType.getString().equals("String")) { [EOL]         Node value = objectType.getNext(); [EOL]         String stringValue = null; [EOL]         if (value == null) { [EOL]             stringValue = ""; [EOL]         } else { [EOL]             if (!NodeUtil.isImmutableValue(value)) { [EOL]                 return n; [EOL]             } [EOL]             stringValue = NodeUtil.getStringValue(value); [EOL]         } [EOL]         if (stringValue == null) { [EOL]             return n; [EOL]         } [EOL]         Node parent = n.getParent(); [EOL]         Node newString = IR.string(stringValue); [EOL]         parent.replaceChild(n, newString); [EOL]         newString.copyInformationFrom(parent); [EOL]         reportCodeChange(); [EOL]         return newString; [EOL]     } [EOL]     return n; [EOL] } <line_num>: 1281,1317
private Node tryFoldGetElem(Node n, Node left, Node right) { [EOL]     Preconditions.checkArgument(n.isGetElem()); [EOL]     if (left.isObjectLit()) { [EOL]         return tryFoldObjectPropAccess(n, left, right); [EOL]     } [EOL]     if (left.isArrayLit()) { [EOL]         return tryFoldArrayAccess(n, left, right); [EOL]     } [EOL]     return n; [EOL] } <line_num>: 1322,1333
private Node tryFoldGetProp(Node n, Node left, Node right) { [EOL]     Preconditions.checkArgument(n.isGetProp()); [EOL]     if (left.isObjectLit()) { [EOL]         return tryFoldObjectPropAccess(n, left, right); [EOL]     } [EOL]     if (right.isString() && right.getString().equals("length")) { [EOL]         int knownLength = -1; [EOL]         switch(left.getType()) { [EOL]             case Token.ARRAYLIT: [EOL]                 if (mayHaveSideEffects(left)) { [EOL]                     return n; [EOL]                 } [EOL]                 knownLength = left.getChildCount(); [EOL]                 break; [EOL]             case Token.STRING: [EOL]                 knownLength = left.getString().length(); [EOL]                 break; [EOL]             default: [EOL]                 return n; [EOL]         } [EOL]         Preconditions.checkState(knownLength != -1); [EOL]         Node lengthNode = IR.number(knownLength); [EOL]         n.getParent().replaceChild(n, lengthNode); [EOL]         reportCodeChange(); [EOL]         return lengthNode; [EOL]     } [EOL]     return n; [EOL] } <line_num>: 1338,1373
private boolean isAssignmentTarget(Node n) { [EOL]     Node parent = n.getParent(); [EOL]     if ((NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) || parent.isInc() || parent.isDec()) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1375,1386
private Node tryFoldArrayAccess(Node n, Node left, Node right) { [EOL]     Node parent = n.getParent(); [EOL]     if (isAssignmentTarget(n)) { [EOL]         return n; [EOL]     } [EOL]     if (!right.isNumber()) { [EOL]         return n; [EOL]     } [EOL]     double index = right.getDouble(); [EOL]     int intIndex = (int) index; [EOL]     if (intIndex != index) { [EOL]         report(INVALID_GETELEM_INDEX_ERROR, right); [EOL]         return n; [EOL]     } [EOL]     if (intIndex < 0) { [EOL]         report(INDEX_OUT_OF_BOUNDS_ERROR, right); [EOL]         return n; [EOL]     } [EOL]     Node current = left.getFirstChild(); [EOL]     Node elem = null; [EOL]     for (int i = 0; current != null; i++) { [EOL]         if (i != intIndex) { [EOL]             if (mayHaveSideEffects(current)) { [EOL]                 return n; [EOL]             } [EOL]         } else { [EOL]             elem = current; [EOL]         } [EOL]         current = current.getNext(); [EOL]     } [EOL]     if (elem == null) { [EOL]         report(INDEX_OUT_OF_BOUNDS_ERROR, right); [EOL]         return n; [EOL]     } [EOL]     if (elem.isEmpty()) { [EOL]         elem = NodeUtil.newUndefinedNode(elem); [EOL]     } else { [EOL]         left.removeChild(elem); [EOL]     } [EOL]     n.getParent().replaceChild(n, elem); [EOL]     reportCodeChange(); [EOL]     return elem; [EOL] } <line_num>: 1388,1444
private Node tryFoldObjectPropAccess(Node n, Node left, Node right) { [EOL]     Preconditions.checkArgument(NodeUtil.isGet(n)); [EOL]     if (!left.isObjectLit() || !right.isString()) { [EOL]         return n; [EOL]     } [EOL]     if (isAssignmentTarget(n)) { [EOL]         return n; [EOL]     } [EOL]     Node key = null; [EOL]     Node value = null; [EOL]     for (Node c = left.getFirstChild(); c != null; c = c.getNext()) { [EOL]         if (c.getString().equals(right.getString())) { [EOL]             switch(c.getType()) { [EOL]                 case Token.SETTER_DEF: [EOL]                     continue; [EOL]                 case Token.GETTER_DEF: [EOL]                 case Token.STRING_KEY: [EOL]                     if (value != null && mayHaveSideEffects(value)) { [EOL]                         return n; [EOL]                     } [EOL]                     key = c; [EOL]                     value = key.getFirstChild(); [EOL]                     break; [EOL]                 default: [EOL]                     throw new IllegalStateException(); [EOL]             } [EOL]         } else if (mayHaveSideEffects(c.getFirstChild())) { [EOL]             return n; [EOL]         } [EOL]     } [EOL]     if (value == null) { [EOL]         return n; [EOL]     } [EOL]     if (value.isFunction() && NodeUtil.referencesThis(value)) { [EOL]         return n; [EOL]     } [EOL]     Node replacement = value.detachFromParent(); [EOL]     if (key.isGetterDef()) { [EOL]         replacement = IR.call(replacement); [EOL]         replacement.putBooleanProp(Node.FREE_CALL, true); [EOL]     } [EOL]     n.getParent().replaceChild(n, replacement); [EOL]     reportCodeChange(); [EOL]     return n; [EOL] } <line_num>: 1446,1507
