public AbstractNodeTypePruningCallback(Set<Integer> nodeTypes) { [EOL]     this(nodeTypes, true); [EOL] } <line_num>: 196,198
public AbstractNodeTypePruningCallback(Set<Integer> nodeTypes, boolean include) { [EOL]     this.nodeTypes = nodeTypes; [EOL]     this.include = include; [EOL] } <line_num>: 205,209
public NodeTraversal(AbstractCompiler compiler, Callback cb) { [EOL]     this(compiler, cb, new SyntacticScopeCreator(compiler)); [EOL] } <line_num>: 221,223
public NodeTraversal(AbstractCompiler compiler, Callback cb, ScopeCreator scopeCreator) { [EOL]     this.callback = cb; [EOL]     if (cb instanceof ScopedCallback) { [EOL]         this.scopeCallback = (ScopedCallback) cb; [EOL]     } [EOL]     this.compiler = compiler; [EOL]     this.inputId = null; [EOL]     this.sourceName = ""; [EOL]     this.scopeCreator = scopeCreator; [EOL] } <line_num>: 229,239
boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent); <line_num>: 96,96
void visit(NodeTraversal t, Node n, Node parent); <line_num>: 105,105
void enterScope(NodeTraversal t); <line_num>: 117,117
void exitScope(NodeTraversal t); <line_num>: 123,123
@Override [EOL] public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) { [EOL]     return true; [EOL] } <line_num>: 130,134
@Override [EOL] public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) { [EOL]     return true; [EOL] } <line_num>: 142,146
@Override [EOL] public void enterScope(NodeTraversal t) { [EOL] } <line_num>: 148,149
@Override [EOL] public void exitScope(NodeTraversal t) { [EOL] } <line_num>: 151,152
@Override [EOL] public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) { [EOL]     return parent == null || !parent.isFunction() || n == parent.getFirstChild(); [EOL] } <line_num>: 160,167
@Override [EOL] public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) { [EOL]     return parent == null || NodeUtil.isControlStructure(parent) || NodeUtil.isStatementBlock(parent); [EOL] } <line_num>: 176,181
@Override [EOL] public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) { [EOL]     return include == nodeTypes.contains(n.getType()); [EOL] } <line_num>: 211,215
private void throwUnexpectedException(Exception unexpectedException) { [EOL]     String message = unexpectedException.getMessage(); [EOL]     if (inputId != null) { [EOL]         message = unexpectedException.getMessage() + "\n" + formatNodeContext("Node", curNode) + (curNode == null ? "" : formatNodeContext("Parent", curNode.getParent())); [EOL]     } [EOL]     compiler.throwInternalError(message, unexpectedException); [EOL] } <line_num>: 241,258
private String formatNodeContext(String label, Node n) { [EOL]     if (n == null) { [EOL]         return "  " + label + ": NULL"; [EOL]     } [EOL]     return "  " + label + "(" + n.toString(false, false, false) + "): " + formatNodePosition(n); [EOL] } <line_num>: 260,266
public void traverse(Node root) { [EOL]     try { [EOL]         inputId = NodeUtil.getInputId(root); [EOL]         sourceName = ""; [EOL]         curNode = root; [EOL]         pushScope(root); [EOL]         traverseBranch(root, null); [EOL]         popScope(); [EOL]     } catch (Exception unexpectedException) { [EOL]         throwUnexpectedException(unexpectedException); [EOL]     } [EOL] } <line_num>: 271,282
public void traverseRoots(Node... roots) { [EOL]     traverseRoots(Lists.newArrayList(roots)); [EOL] } <line_num>: 284,286
public void traverseRoots(List<Node> roots) { [EOL]     if (roots.isEmpty()) { [EOL]         return; [EOL]     } [EOL]     try { [EOL]         Node scopeRoot = roots.get(0).getParent(); [EOL]         Preconditions.checkState(scopeRoot != null); [EOL]         inputId = NodeUtil.getInputId(scopeRoot); [EOL]         sourceName = ""; [EOL]         curNode = scopeRoot; [EOL]         pushScope(scopeRoot); [EOL]         for (Node root : roots) { [EOL]             Preconditions.checkState(root.getParent() == scopeRoot); [EOL]             traverseBranch(root, scopeRoot); [EOL]         } [EOL]         popScope(); [EOL]     } catch (Exception unexpectedException) { [EOL]         throwUnexpectedException(unexpectedException); [EOL]     } [EOL] } <line_num>: 288,311
private String formatNodePosition(Node n) { [EOL]     String sourceFileName = getBestSourceFileName(n); [EOL]     if (sourceFileName == null) { [EOL]         return MISSING_SOURCE + "\n"; [EOL]     } [EOL]     int lineNumber = n.getLineno(); [EOL]     int columnNumber = n.getCharno(); [EOL]     String src = compiler.getSourceLine(sourceFileName, lineNumber); [EOL]     if (src == null) { [EOL]         src = MISSING_SOURCE; [EOL]     } [EOL]     return sourceFileName + ":" + lineNumber + ":" + columnNumber + "\n" + src + "\n"; [EOL] } <line_num>: 315,329
void traverseWithScope(Node root, Scope s) { [EOL]     Preconditions.checkState(s.isGlobal()); [EOL]     inputId = null; [EOL]     sourceName = ""; [EOL]     curNode = root; [EOL]     pushScope(s); [EOL]     traverseBranch(root, null); [EOL]     popScope(); [EOL] } <line_num>: 336,345
void traverseAtScope(Scope s) { [EOL]     Node n = s.getRootNode(); [EOL]     if (n.isFunction()) { [EOL]         if (inputId == null) { [EOL]             inputId = NodeUtil.getInputId(n); [EOL]         } [EOL]         sourceName = getSourceName(n); [EOL]         curNode = n; [EOL]         pushScope(s); [EOL]         Node args = n.getFirstChild().getNext(); [EOL]         Node body = args.getNext(); [EOL]         traverseBranch(args, n); [EOL]         traverseBranch(body, n); [EOL]         popScope(); [EOL]     } else { [EOL]         traverseWithScope(n, s); [EOL]     } [EOL] } <line_num>: 351,372
protected void traverseInnerNode(Node node, Node parent, Scope refinedScope) { [EOL]     Preconditions.checkNotNull(parent); [EOL]     if (refinedScope != null && getScope() != refinedScope) { [EOL]         curNode = node; [EOL]         pushScope(refinedScope); [EOL]         traverseBranch(node, parent); [EOL]         popScope(); [EOL]     } else { [EOL]         traverseBranch(node, parent); [EOL]     } [EOL] } <line_num>: 384,394
public Compiler getCompiler() { [EOL]     return (Compiler) compiler; [EOL] } <line_num>: 399,403
public int getLineNumber() { [EOL]     Node cur = curNode; [EOL]     while (cur != null) { [EOL]         int line = cur.getLineno(); [EOL]         if (line >= 0) { [EOL]             return line; [EOL]         } [EOL]         cur = cur.getParent(); [EOL]     } [EOL]     return 0; [EOL] } <line_num>: 409,419
public String getSourceName() { [EOL]     return sourceName; [EOL] } <line_num>: 426,428
public CompilerInput getInput() { [EOL]     return compiler.getInput(inputId); [EOL] } <line_num>: 433,435
public JSModule getModule() { [EOL]     CompilerInput input = getInput(); [EOL]     return input == null ? null : input.getModule(); [EOL] } <line_num>: 440,443
public Node getCurrentNode() { [EOL]     return curNode; [EOL] } <line_num>: 446,448
public static void traverse(AbstractCompiler compiler, Node root, Callback cb) { [EOL]     NodeTraversal t = new NodeTraversal(compiler, cb); [EOL]     t.traverse(root); [EOL] } <line_num>: 453,457
public static void traverseRoots(AbstractCompiler compiler, List<Node> roots, Callback cb) { [EOL]     NodeTraversal t = new NodeTraversal(compiler, cb); [EOL]     t.traverseRoots(roots); [EOL] } <line_num>: 462,466
public static void traverseRoots(AbstractCompiler compiler, Callback cb, Node... roots) { [EOL]     NodeTraversal t = new NodeTraversal(compiler, cb); [EOL]     t.traverseRoots(roots); [EOL] } <line_num>: 468,472
@SuppressWarnings("fallthrough") [EOL] private void traverseBranch(Node n, Node parent) { [EOL]     int type = n.getType(); [EOL]     if (type == Token.SCRIPT) { [EOL]         inputId = n.getInputId(); [EOL]         sourceName = getSourceName(n); [EOL]     } [EOL]     curNode = n; [EOL]     if (!callback.shouldTraverse(this, n, parent)) [EOL]         return; [EOL]     switch(type) { [EOL]         case Token.FUNCTION: [EOL]             traverseFunction(n, parent); [EOL]             break; [EOL]         default: [EOL]             for (Node child = n.getFirstChild(); child != null; ) { [EOL]                 Node next = child.getNext(); [EOL]                 traverseBranch(child, n); [EOL]                 child = next; [EOL]             } [EOL]             break; [EOL]     } [EOL]     curNode = n; [EOL]     callback.visit(this, n, parent); [EOL] } <line_num>: 477,506
private void traverseFunction(Node n, Node parent) { [EOL]     Preconditions.checkState(n.getChildCount() == 3); [EOL]     Preconditions.checkState(n.isFunction()); [EOL]     final Node fnName = n.getFirstChild(); [EOL]     boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n); [EOL]     if (!isFunctionExpression) { [EOL]         traverseBranch(fnName, n); [EOL]     } [EOL]     curNode = n; [EOL]     pushScope(n); [EOL]     if (isFunctionExpression) { [EOL]         traverseBranch(fnName, n); [EOL]     } [EOL]     final Node args = fnName.getNext(); [EOL]     final Node body = args.getNext(); [EOL]     traverseBranch(args, n); [EOL]     Preconditions.checkState(body.getNext() == null && body.isBlock(), body); [EOL]     traverseBranch(body, n); [EOL]     popScope(); [EOL] } <line_num>: 511,546
@SuppressWarnings("unchecked") [EOL] public Node getEnclosingFunction() { [EOL]     if (scopes.size() + scopeRoots.size() < 2) { [EOL]         return null; [EOL]     } else { [EOL]         if (scopeRoots.isEmpty()) { [EOL]             return scopes.peek().getRootNode(); [EOL]         } else { [EOL]             return scopeRoots.peek(); [EOL]         } [EOL]     } [EOL] } <line_num>: 549,560
private void pushScope(Node node) { [EOL]     Preconditions.checkState(curNode != null); [EOL]     scopeRoots.push(node); [EOL]     cfgs.push(null); [EOL]     if (scopeCallback != null) { [EOL]         scopeCallback.enterScope(this); [EOL]     } [EOL] } <line_num>: 563,570
private void pushScope(Scope s) { [EOL]     Preconditions.checkState(curNode != null); [EOL]     scopes.push(s); [EOL]     cfgs.push(null); [EOL]     if (scopeCallback != null) { [EOL]         scopeCallback.enterScope(this); [EOL]     } [EOL] } <line_num>: 573,580
private void popScope() { [EOL]     if (scopeCallback != null) { [EOL]         scopeCallback.exitScope(this); [EOL]     } [EOL]     if (scopeRoots.isEmpty()) { [EOL]         scopes.pop(); [EOL]     } else { [EOL]         scopeRoots.pop(); [EOL]     } [EOL]     cfgs.pop(); [EOL] } <line_num>: 583,593
public Scope getScope() { [EOL]     Scope scope = scopes.isEmpty() ? null : scopes.peek(); [EOL]     if (scopeRoots.isEmpty()) { [EOL]         return scope; [EOL]     } [EOL]     Iterator<Node> it = scopeRoots.descendingIterator(); [EOL]     while (it.hasNext()) { [EOL]         scope = scopeCreator.createScope(it.next(), scope); [EOL]         scopes.push(scope); [EOL]     } [EOL]     scopeRoots.clear(); [EOL]     return scope; [EOL] } <line_num>: 596,610
public ControlFlowGraph<Node> getControlFlowGraph() { [EOL]     if (cfgs.peek() == null) { [EOL]         ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true); [EOL]         cfa.process(null, getScopeRoot()); [EOL]         cfgs.pop(); [EOL]         cfgs.push(cfa.getCfg()); [EOL]     } [EOL]     return cfgs.peek(); [EOL] } <line_num>: 613,621
public Node getScopeRoot() { [EOL]     if (scopeRoots.isEmpty()) { [EOL]         return scopes.peek().getRootNode(); [EOL]     } else { [EOL]         return scopeRoots.peek(); [EOL]     } [EOL] } <line_num>: 624,630
boolean inGlobalScope() { [EOL]     return getScopeDepth() <= 1; [EOL] } <line_num>: 635,637
int getScopeDepth() { [EOL]     return scopes.size() + scopeRoots.size(); [EOL] } <line_num>: 639,641
public boolean hasScope() { [EOL]     return !(scopes.isEmpty() && scopeRoots.isEmpty()); [EOL] } <line_num>: 643,645
public void report(Node n, DiagnosticType diagnosticType, String... arguments) { [EOL]     JSError error = JSError.make(getBestSourceFileName(n), n, diagnosticType, arguments); [EOL]     compiler.report(error); [EOL] } <line_num>: 648,653
private static String getSourceName(Node n) { [EOL]     String name = n.getSourceFileName(); [EOL]     return name == null ? "" : name; [EOL] } <line_num>: 655,658
InputId getInputId() { [EOL]     return inputId; [EOL] } <line_num>: 660,662
public JSError makeError(Node n, CheckLevel level, DiagnosticType type, String... arguments) { [EOL]     return JSError.make(getBestSourceFileName(n), n, level, type, arguments); [EOL] } <line_num>: 671,674
public JSError makeError(Node n, DiagnosticType type, String... arguments) { [EOL]     return JSError.make(getBestSourceFileName(n), n, type, arguments); [EOL] } <line_num>: 683,685
private String getBestSourceFileName(Node n) { [EOL]     return n == null ? sourceName : n.getSourceFileName(); [EOL] } <line_num>: 687,689
