UnreachableCodeElimination(AbstractCompiler compiler, boolean removeNoOpStatements) { [EOL]     this.compiler = compiler; [EOL]     this.removeNoOpStatements = removeNoOpStatements; [EOL] } <line_num>: 54,58
private EliminationPass(ControlFlowGraph<Node> cfg) { [EOL]     this.cfg = cfg; [EOL] } <line_num>: 87,89
@Override [EOL] public void exitScope(NodeTraversal t) { [EOL]     Scope scope = t.getScope(); [EOL]     ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, false); [EOL]     cfa.process(null, scope.getRootNode()); [EOL]     ControlFlowGraph<Node> cfg = cfa.getCfg(); [EOL]     new GraphReachability<Node, ControlFlowGraph.Branch>(cfg).compute(cfg.getEntry().getValue()); [EOL]     Node root = scope.getRootNode(); [EOL]     if (scope.isLocal()) { [EOL]         root = root.getLastChild(); [EOL]     } [EOL]     NodeTraversal.traverse(compiler, root, new EliminationPass(cfg)); [EOL] } <line_num>: 60,78
@Override [EOL] public void process(Node externs, Node root) { [EOL]     NodeTraversal.traverse(compiler, root, this); [EOL] } <line_num>: 80,83
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (parent == null) { [EOL]         return; [EOL]     } [EOL]     if (n.isFunction() || n.isScript()) { [EOL]         return; [EOL]     } [EOL]     DiGraphNode<Node, Branch> gNode = cfg.getDirectedGraphNode(n); [EOL]     if (gNode == null) { [EOL]         return; [EOL]     } [EOL]     if (gNode.getAnnotation() != GraphReachability.REACHABLE || (removeNoOpStatements && !NodeUtil.mayHaveSideEffects(n, compiler))) { [EOL]         removeDeadExprStatementSafely(n); [EOL]         return; [EOL]     } [EOL]     tryRemoveUnconditionalBranching(n); [EOL] } <line_num>: 91,111
@SuppressWarnings("fallthrough") [EOL] private Node tryRemoveUnconditionalBranching(Node n) { [EOL]     if (n == null) { [EOL]         return n; [EOL]     } [EOL]     DiGraphNode<Node, Branch> gNode = cfg.getDirectedGraphNode(n); [EOL]     if (gNode == null) { [EOL]         return n; [EOL]     } [EOL]     switch(n.getType()) { [EOL]         case Token.RETURN: [EOL]             if (n.hasChildren()) { [EOL]                 break; [EOL]             } [EOL]         case Token.BREAK: [EOL]         case Token.CONTINUE: [EOL]             List<DiGraphEdge<Node, Branch>> outEdges = gNode.getOutEdges(); [EOL]             if (outEdges.size() == 1 && (n.getNext() == null || n.getNext().isFunction())) { [EOL]                 Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND); [EOL]                 Node fallThrough = computeFollowing(n); [EOL]                 Node nextCfgNode = outEdges.get(0).getDestination().getValue(); [EOL]                 if (nextCfgNode == fallThrough) { [EOL]                     removeDeadExprStatementSafely(n); [EOL]                     return fallThrough; [EOL]                 } [EOL]             } [EOL]     } [EOL]     return n; [EOL] } <line_num>: 131,180
private Node computeFollowing(Node n) { [EOL]     Node next = ControlFlowAnalysis.computeFollowNode(n); [EOL]     while (next != null && next.isBlock()) { [EOL]         if (next.hasChildren()) { [EOL]             next = next.getFirstChild(); [EOL]         } else { [EOL]             next = computeFollowing(next); [EOL]         } [EOL]     } [EOL]     return next; [EOL] } <line_num>: 182,192
private void removeDeadExprStatementSafely(Node n) { [EOL]     Node parent = n.getParent(); [EOL]     if (n.isEmpty() || (n.isBlock() && !n.hasChildren())) { [EOL]         return; [EOL]     } [EOL]     if (NodeUtil.isForIn(parent)) { [EOL]         return; [EOL]     } [EOL]     switch(n.getType()) { [EOL]         case Token.DO: [EOL]             return; [EOL]         case Token.BLOCK: [EOL]             if (parent.isTry()) { [EOL]                 if (NodeUtil.isTryCatchNodeContainer(n)) { [EOL]                     return; [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Token.CATCH: [EOL]             Node tryNode = parent.getParent(); [EOL]             NodeUtil.maybeAddFinally(tryNode); [EOL]             break; [EOL]     } [EOL]     if (n.isVar() && !n.getFirstChild().hasChildren()) { [EOL]         return; [EOL]     } [EOL]     NodeUtil.redeclareVarsInsideBranch(n); [EOL]     compiler.reportCodeChange(); [EOL]     if (logger.isLoggable(Level.FINE)) { [EOL]         logger.fine("Removing " + n.toString()); [EOL]     } [EOL]     NodeUtil.removeChild(n.getParent(), n); [EOL] } <line_num>: 194,252
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL] } <line_num>: 255,256
@Override [EOL] public void enterScope(NodeTraversal t) { [EOL] } <line_num>: 258,259
