Tracer(@Nullable String type, @Nullable String comment) { [EOL]     this.type = type; [EOL]     this.comment = comment == null ? "" : comment; [EOL]     startTimeMs = clock.currentTimeMillis(); [EOL]     startThread = Thread.currentThread(); [EOL]     if (!extraTracingStatistics.isEmpty()) { [EOL]         int size = extraTracingStatistics.size(); [EOL]         extraTracingValues = new long[size]; [EOL]         int i = 0; [EOL]         for (TracingStatistic tracingStatistic : extraTracingStatistics) { [EOL]             extraTracingValues[i] = tracingStatistic.start(startThread); [EOL]             i++; [EOL]         } [EOL]     } [EOL]     ThreadTrace trace = getThreadTrace(); [EOL]     if (!trace.isInitialized()) { [EOL]         return; [EOL]     } [EOL]     if (trace.events.size() >= MAX_TRACE_SIZE) { [EOL]         logger.log(Level.WARNING, "Giant thread trace. Too many Tracers created. " + "Clearing to avoid memory leak.", new Throwable(trace.toString())); [EOL]         trace.truncateEvents(); [EOL]     } [EOL]     if (trace.outstandingEvents.size() >= MAX_TRACE_SIZE) { [EOL]         logger.log(Level.WARNING, "Too many outstanding Tracers. Tracer.stop() is missing " + "or Tracer.stop() is not wrapped in a " + "try/finally block. " + "Clearing to avoid memory leak.", new Throwable(trace.toString())); [EOL]         trace.truncateOutstandingEvents(); [EOL]     } [EOL]     trace.startEvent(this); [EOL] } <line_num>: 235,278
Tracer(String comment) { [EOL]     this(null, comment); [EOL] } <line_num>: 285,287
Event(boolean start, Tracer t) { [EOL]     isStart = start; [EOL]     tracer = t; [EOL] } <line_num>: 647,650
long currentTimeMillis(); <line_num>: 214,214
@Override [EOL] public long currentTimeMillis() { [EOL]     return System.currentTimeMillis(); [EOL] } <line_num>: 222,225
static Tracer shortName(Object object, String comment) { [EOL]     if (object == null) { [EOL]         return new Tracer(comment); [EOL]     } [EOL]     return new Tracer(object.getClass().getSimpleName(), comment); [EOL] } <line_num>: 295,300
private static String longToPaddedString(long v, int digits_column_width) { [EOL]     int digit_width = numDigits(v); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     appendSpaces(sb, digits_column_width - digit_width); [EOL]     sb.append(v); [EOL]     return sb.toString(); [EOL] } <line_num>: 308,314
private static int numDigits(long n) { [EOL]     int i = 0; [EOL]     do { [EOL]         i++; [EOL]         n = n / 10; [EOL]     } while (n > 0); [EOL]     return i; [EOL] } <line_num>: 322,329
@VisibleForTesting [EOL] static void appendSpaces(StringBuilder sb, int numSpaces) { [EOL]     if (numSpaces > 16) { [EOL]         logger.warning("Tracer.appendSpaces called with large numSpaces"); [EOL]         numSpaces = 16; [EOL]     } [EOL]     while (numSpaces >= 5) { [EOL]         sb.append("     "); [EOL]         numSpaces -= 5; [EOL]     } [EOL]     switch(numSpaces) { [EOL]         case 1: [EOL]             sb.append(" "); [EOL]             break; [EOL]         case 2: [EOL]             sb.append("  "); [EOL]             break; [EOL]         case 3: [EOL]             sb.append("   "); [EOL]             break; [EOL]         case 4: [EOL]             sb.append("    "); [EOL]             break; [EOL]     } [EOL] } <line_num>: 336,363
static int addTracingStatistic(TracingStatistic tracingStatistic) { [EOL]     if (tracingStatistic.enable()) { [EOL]         extraTracingStatistics.add(tracingStatistic); [EOL]         return extraTracingStatistics.lastIndexOf(tracingStatistic); [EOL]     } else { [EOL]         return -1; [EOL]     } [EOL] } <line_num>: 372,384
@VisibleForTesting [EOL] static void clearTracingStatisticsTestingOnly() { [EOL]     extraTracingStatistics.clear(); [EOL] } <line_num>: 393,396
long stop(int silence_threshold) { [EOL]     Preconditions.checkState(Thread.currentThread() == startThread); [EOL]     ThreadTrace trace = getThreadTrace(); [EOL]     if (!trace.isInitialized()) { [EOL]         return 0; [EOL]     } [EOL]     stopTimeMs = clock.currentTimeMillis(); [EOL]     if (extraTracingValues != null) { [EOL]         for (int i = 0; i < extraTracingValues.length; i++) { [EOL]             long value = extraTracingStatistics.get(i).stop(startThread); [EOL]             extraTracingValues[i] = value - extraTracingValues[i]; [EOL]         } [EOL]     } [EOL]     if (!trace.isInitialized()) { [EOL]         return 0; [EOL]     } [EOL]     trace.endEvent(this, silence_threshold); [EOL]     return stopTimeMs - startTimeMs; [EOL] } <line_num>: 407,434
long stop() { [EOL]     return stop(-1); [EOL] } <line_num>: 440,442
@Override [EOL] public String toString() { [EOL]     if (type == null) { [EOL]         return comment; [EOL]     } else { [EOL]         return "[" + type + "] " + comment; [EOL]     } [EOL] } <line_num>: 444,450
static void setDefaultSilenceThreshold(int threshold) { [EOL]     getThreadTrace().defaultSilenceThreshold = threshold; [EOL] } <line_num>: 452,454
static void initCurrentThreadTrace() { [EOL]     ThreadTrace events = getThreadTrace(); [EOL]     if (!events.isEmpty()) { [EOL]         logger.log(Level.WARNING, "Non-empty timer log:\n" + events, new Throwable()); [EOL]         clearThreadTrace(); [EOL]         events = getThreadTrace(); [EOL]     } [EOL]     events.init(); [EOL] } <line_num>: 461,475
static void initCurrentThreadTrace(int default_silence_threshold) { [EOL]     initCurrentThreadTrace(); [EOL]     setDefaultSilenceThreshold(default_silence_threshold); [EOL] } <line_num>: 477,480
static String getCurrentThreadTraceReport() { [EOL]     return getThreadTrace().toString(); [EOL] } <line_num>: 487,489
static void logCurrentThreadTrace() { [EOL]     ThreadTrace trace = getThreadTrace(); [EOL]     if (!trace.isInitialized()) { [EOL]         logger.log(Level.WARNING, "Tracer log requested for this thread but was not " + "initialized using Tracer.initCurrentThreadTrace().", new Throwable()); [EOL]         return; [EOL]     } [EOL]     if (!trace.isEmpty()) { [EOL]         logger.log(Level.WARNING, "timers:\n{0}", getCurrentThreadTraceReport()); [EOL]     } [EOL] } <line_num>: 494,513
static void clearCurrentThreadTrace() { [EOL]     clearThreadTrace(); [EOL] } <line_num>: 518,520
static void logAndClearCurrentThreadTrace() { [EOL]     logCurrentThreadTrace(); [EOL]     clearThreadTrace(); [EOL] } <line_num>: 525,528
static void setPrettyPrint(boolean enabled) { [EOL]     defaultPrettyPrint = enabled; [EOL] } <line_num>: 535,537
int getCount() { [EOL]     return count; [EOL] } <line_num>: 550,550
int getSilentCount() { [EOL]     return silent; [EOL] } <line_num>: 556,556
int getTotalTime() { [EOL]     return clockTime; [EOL] } <line_num>: 562,562
@VisibleForTesting [EOL] int getExtraInfo(int index) { [EOL]     return index >= extraInfo.length ? 0 : extraInfo[index]; [EOL] } <line_num>: 565,568
static synchronized void enableTypeMaps() { [EOL]     if (typeToCountMap == null) { [EOL]         typeToCountMap = new AtomicTracerStatMap(); [EOL]         typeToSilentMap = new AtomicTracerStatMap(); [EOL]         typeToTimeMap = new AtomicTracerStatMap(); [EOL]     } [EOL] } <line_num>: 592,598
@Nullable [EOL] static Map<String, Long> getTypeToCountMap() { [EOL]     return typeToCountMap != null ? typeToCountMap.getMap() : null; [EOL] } <line_num>: 605,607
@Nullable [EOL] static Map<String, Long> getTypeToSilentMap() { [EOL]     return typeToSilentMap != null ? typeToSilentMap.getMap() : null; [EOL] } <line_num>: 614,616
@Nullable [EOL] static Map<String, Long> getTypeToTimeMap() { [EOL]     return typeToTimeMap != null ? typeToTimeMap.getMap() : null; [EOL] } <line_num>: 623,625
static Stat getStatsForType(String type) { [EOL]     Stat stat = getThreadTrace().stats.get(type); [EOL]     return stat != null ? stat : ZERO_STAT; [EOL] } <line_num>: 628,631
private static String formatTime(long time) { [EOL]     int sec = (int) ((time / 1000) % 60); [EOL]     int ms = (int) (time % 1000); [EOL]     return String.format("%02d.%03d", sec, ms); [EOL] } <line_num>: 636,640
long eventTime() { [EOL]     return isStart ? tracer.startTimeMs : tracer.stopTimeMs; [EOL] } <line_num>: 652,654
String toString(long prevEventTime, String indent, int digitsColWidth) { [EOL]     StringBuilder sb = new StringBuilder(120); [EOL]     if (prevEventTime == -1) { [EOL]         appendSpaces(sb, digitsColWidth); [EOL]     } else { [EOL]         sb.append(longToPaddedString(eventTime() - prevEventTime, digitsColWidth)); [EOL]     } [EOL]     sb.append(' '); [EOL]     sb.append(formatTime(eventTime())); [EOL]     if (isStart) { [EOL]         sb.append(" Start "); [EOL]         appendSpaces(sb, digitsColWidth); [EOL]         sb.append("   "); [EOL]     } else { [EOL]         sb.append(" Done "); [EOL]         long delta = tracer.stopTimeMs - tracer.startTimeMs; [EOL]         sb.append(longToPaddedString(delta, digitsColWidth)); [EOL]         sb.append(" ms "); [EOL]         if (tracer.extraTracingValues != null) { [EOL]             for (int i = 0; i < tracer.extraTracingValues.length; i++) { [EOL]                 delta = tracer.extraTracingValues[i]; [EOL]                 sb.append(String.format("%4d", delta)); [EOL]                 sb.append(extraTracingStatistics.get(i).getUnits()); [EOL]                 sb.append(";  "); [EOL]             } [EOL]         } [EOL]     } [EOL]     sb.append(indent); [EOL]     sb.append(tracer.toString()); [EOL]     return sb.toString(); [EOL] } <line_num>: 665,698
void init() { [EOL]     isInitialized = true; [EOL] } <line_num>: 740,742
boolean isInitialized() { [EOL]     return isInitialized; [EOL] } <line_num>: 745,747
void startEvent(Tracer t) { [EOL]     events.add(new Event(true, t)); [EOL]     boolean notAlreadyOutstanding = outstandingEvents.add(t); [EOL]     Preconditions.checkState(notAlreadyOutstanding); [EOL] } <line_num>: 753,757
void endEvent(Tracer t, int silenceThreshold) { [EOL]     boolean wasOutstanding = outstandingEvents.remove(t); [EOL]     if (!wasOutstanding) { [EOL]         if (isOutstandingEventsTruncated) { [EOL]             logger.log(Level.WARNING, "event not found, probably because the event stack " + "overflowed and was truncated", new Throwable()); [EOL]         } else { [EOL]             throw new IllegalStateException(); [EOL]         } [EOL]     } [EOL]     long elapsed = t.stopTimeMs - t.startTimeMs; [EOL]     if (silenceThreshold == -1) { [EOL]         silenceThreshold = defaultSilenceThreshold; [EOL]     } [EOL]     if (elapsed < silenceThreshold) { [EOL]         boolean removed = false; [EOL]         for (int i = 0; i < events.size(); i++) { [EOL]             Event e = events.get(i); [EOL]             if (e.tracer == t) { [EOL]                 Preconditions.checkState(e.isStart); [EOL]                 events.remove(i); [EOL]                 removed = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         Preconditions.checkState(removed || isEventsTruncated); [EOL]     } else { [EOL]         events.add(new Event(false, t)); [EOL]     } [EOL]     if (t.type != null) { [EOL]         Stat stat = stats.get(t.type); [EOL]         if (stat == null) { [EOL]             stat = new Stat(); [EOL]             if (!extraTracingStatistics.isEmpty()) { [EOL]                 stat.extraInfo = new int[extraTracingStatistics.size()]; [EOL]             } [EOL]             stats.put(t.type, stat); [EOL]         } [EOL]         stat.count++; [EOL]         if (typeToCountMap != null) { [EOL]             typeToCountMap.incrementBy(t.type, 1); [EOL]         } [EOL]         stat.clockTime += elapsed; [EOL]         if (typeToTimeMap != null) { [EOL]             typeToTimeMap.incrementBy(t.type, elapsed); [EOL]         } [EOL]         if (stat.extraInfo != null && t.extraTracingValues != null) { [EOL]             int overlapLength = Math.min(stat.extraInfo.length, t.extraTracingValues.length); [EOL]             for (int i = 0; i < overlapLength; i++) { [EOL]                 stat.extraInfo[i] += t.extraTracingValues[i]; [EOL]                 AtomicTracerStatMap map = extraTracingStatistics.get(i).getTracingStat(); [EOL]                 if (map != null) { [EOL]                     map.incrementBy(t.type, t.extraTracingValues[i]); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (elapsed < silenceThreshold) { [EOL]             stat.silent++; [EOL]             if (typeToSilentMap != null) { [EOL]                 typeToSilentMap.incrementBy(t.type, 1); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 762,846
boolean isEmpty() { [EOL]     return events.size() == 0 && outstandingEvents.size() == 0; [EOL] } <line_num>: 848,850
void truncateOutstandingEvents() { [EOL]     isOutstandingEventsTruncated = true; [EOL]     outstandingEvents.clear(); [EOL] } <line_num>: 852,855
void truncateEvents() { [EOL]     isEventsTruncated = true; [EOL]     events.clear(); [EOL] } <line_num>: 857,860
@SuppressWarnings("nullness") [EOL] @Override [EOL] public String toString() { [EOL]     int numDigits = getMaxDigits(); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     long etime = -1; [EOL]     LinkedList<String> indent = prettyPrint ? new LinkedList<String>() : null; [EOL]     for (Event e : events) { [EOL]         if (prettyPrint && !e.isStart && !indent.isEmpty()) { [EOL]             indent.pop(); [EOL]         } [EOL]         sb.append(" "); [EOL]         if (prettyPrint) { [EOL]             sb.append(e.toString(etime, Joiner.on("").join(indent), numDigits)); [EOL]         } else { [EOL]             sb.append(e.toString(etime, "", 4)); [EOL]         } [EOL]         etime = e.eventTime(); [EOL]         sb.append('\n'); [EOL]         if (prettyPrint && e.isStart) { [EOL]             indent.push("|  "); [EOL]         } [EOL]     } [EOL]     if (outstandingEvents.size() != 0) { [EOL]         long now = clock.currentTimeMillis(); [EOL]         sb.append(" Unstopped timers:\n"); [EOL]         for (Tracer t : outstandingEvents) { [EOL]             sb.append("  ").append(t).append(" (").append(now - t.startTimeMs).append(" ms, started at ").append(formatTime(t.startTimeMs)).append(")\n"); [EOL]         } [EOL]     } [EOL]     for (String key : stats.keySet()) { [EOL]         Stat stat = stats.get(key); [EOL]         if (stat.count > 1) { [EOL]             sb.append(" TOTAL ").append(key).append(" ").append(stat.count).append(" (").append(stat.clockTime).append(" ms"); [EOL]             if (stat.extraInfo != null) { [EOL]                 for (int i = 0; i < stat.extraInfo.length; i++) { [EOL]                     sb.append("; "); [EOL]                     sb.append(stat.extraInfo[i]).append(' ').append(extraTracingStatistics.get(i).getUnits()); [EOL]                 } [EOL]             } [EOL]             sb.append(")\n"); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } <line_num>: 864,925
private int getMaxDigits() { [EOL]     long etime = -1; [EOL]     long max_time = 0; [EOL]     for (Event e : events) { [EOL]         if (etime != -1) { [EOL]             long time = e.eventTime() - etime; [EOL]             max_time = Math.max(max_time, time); [EOL]         } [EOL]         if (!e.isStart) { [EOL]             long time = e.tracer.stopTimeMs - e.tracer.startTimeMs; [EOL]             max_time = Math.max(max_time, time); [EOL]         } [EOL]         etime = e.eventTime(); [EOL]     } [EOL]     return Math.max(3, numDigits(max_time)); [EOL] } <line_num>: 932,948
static ThreadTrace getThreadTrace() { [EOL]     ThreadTrace t = traces.get(); [EOL]     if (t == null) { [EOL]         t = new ThreadTrace(); [EOL]         t.prettyPrint = defaultPrettyPrint; [EOL]         traces.set(t); [EOL]     } [EOL]     return t; [EOL] } <line_num>: 958,966
static void clearThreadTrace() { [EOL]     traces.remove(); [EOL] } <line_num>: 969,971
long start(Thread thread); <line_num>: 990,990
long stop(Thread thread); <line_num>: 1001,1001
boolean enable(); <line_num>: 1011,1011
AtomicTracerStatMap getTracingStat(); <line_num>: 1017,1017
String getUnits(); <line_num>: 1024,1024
@SuppressWarnings("nullness") [EOL] void incrementBy(String key, long delta) { [EOL]     Long oldValue = map.get(key); [EOL]     if (oldValue == null) { [EOL]         oldValue = map.putIfAbsent(key, delta); [EOL]         if (oldValue == null) { [EOL]             return; [EOL]         } else { [EOL]         } [EOL]     } [EOL]     while (true) { [EOL]         if (map.replace(key, oldValue, oldValue + delta)) { [EOL]             break; [EOL]         } [EOL]         oldValue = map.get(key); [EOL]     } [EOL] } <line_num>: 1044,1069
Map<String, Long> getMap() { [EOL]     return map; [EOL] } <line_num>: 1074,1076
