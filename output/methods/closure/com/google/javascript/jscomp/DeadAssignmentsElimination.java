public DeadAssignmentsElimination(AbstractCompiler compiler) { [EOL]     this.compiler = compiler; [EOL] } <line_num>: 59,61
@Override [EOL] public boolean apply(Node n) { [EOL]     return (NodeUtil.isAssignmentOp(n) && n.getFirstChild().isName()) || n.isInc() || n.isDec(); [EOL] } <line_num>: 51,56
@Override [EOL] public void process(Node externs, Node root) { [EOL]     Preconditions.checkNotNull(externs); [EOL]     Preconditions.checkNotNull(root); [EOL]     NodeTraversal.traverse(compiler, root, this); [EOL] } <line_num>: 63,68
@Override [EOL] public void enterScope(NodeTraversal t) { [EOL]     Scope scope = t.getScope(); [EOL]     if (scope.isGlobal()) { [EOL]         return; [EOL]     } [EOL]     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) { [EOL]         return; [EOL]     } [EOL]     Node fnBlock = t.getScopeRoot().getLastChild(); [EOL]     if (NodeUtil.containsFunction(fnBlock)) { [EOL]         return; [EOL]     } [EOL]     if (!NodeUtil.has(fnBlock, matchRemovableAssigns, Predicates.<Node>alwaysTrue())) { [EOL]         return; [EOL]     } [EOL]     ControlFlowGraph<Node> cfg = t.getControlFlowGraph(); [EOL]     liveness = new LiveVariablesAnalysis(cfg, scope, compiler); [EOL]     liveness.analyze(); [EOL]     tryRemoveDeadAssignments(t, cfg); [EOL] } <line_num>: 70,105
@Override [EOL] public void exitScope(NodeTraversal t) { [EOL] } <line_num>: 107,109
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL] } <line_num>: 111,113
private void tryRemoveDeadAssignments(NodeTraversal t, ControlFlowGraph<Node> cfg) { [EOL]     Iterable<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes(); [EOL]     for (DiGraphNode<Node, Branch> cfgNode : nodes) { [EOL]         FlowState<LiveVariableLattice> state = cfgNode.getAnnotation(); [EOL]         Node n = cfgNode.getValue(); [EOL]         if (n == null) { [EOL]             continue; [EOL]         } [EOL]         switch(n.getType()) { [EOL]             case Token.IF: [EOL]             case Token.WHILE: [EOL]             case Token.DO: [EOL]                 tryRemoveAssignment(t, NodeUtil.getConditionExpression(n), state); [EOL]                 continue; [EOL]             case Token.FOR: [EOL]                 if (!NodeUtil.isForIn(n)) { [EOL]                     tryRemoveAssignment(t, NodeUtil.getConditionExpression(n), state); [EOL]                 } [EOL]                 continue; [EOL]             case Token.SWITCH: [EOL]             case Token.CASE: [EOL]             case Token.RETURN: [EOL]                 if (n.hasChildren()) { [EOL]                     tryRemoveAssignment(t, n.getFirstChild(), state); [EOL]                 } [EOL]                 continue; [EOL]         } [EOL]         tryRemoveAssignment(t, n, state); [EOL]     } [EOL] } <line_num>: 123,158
private void tryRemoveAssignment(NodeTraversal t, Node n, FlowState<LiveVariableLattice> state) { [EOL]     tryRemoveAssignment(t, n, n, state); [EOL] } <line_num>: 160,163
private void tryRemoveAssignment(NodeTraversal t, Node n, Node exprRoot, FlowState<LiveVariableLattice> state) { [EOL]     Node parent = n.getParent(); [EOL]     if (NodeUtil.isAssignmentOp(n) || n.isInc() || n.isDec()) { [EOL]         Node lhs = n.getFirstChild(); [EOL]         Node rhs = lhs.getNext(); [EOL]         if (rhs != null) { [EOL]             tryRemoveAssignment(t, rhs, exprRoot, state); [EOL]             rhs = lhs.getNext(); [EOL]         } [EOL]         Scope scope = t.getScope(); [EOL]         if (!lhs.isName()) { [EOL]             return; [EOL]         } [EOL]         String name = lhs.getString(); [EOL]         if (!scope.isDeclared(name, false)) { [EOL]             return; [EOL]         } [EOL]         Var var = scope.getVar(name); [EOL]         if (liveness.getEscapedLocals().contains(var)) { [EOL]             return; [EOL]         } [EOL]         if (rhs != null && rhs.isName() && rhs.getString().equals(var.name) && n.isAssign()) { [EOL]             n.removeChild(rhs); [EOL]             n.getParent().replaceChild(n, rhs); [EOL]             compiler.reportCodeChange(); [EOL]             return; [EOL]         } [EOL]         if (state.getOut().isLive(var)) { [EOL]             return; [EOL]         } [EOL]         if (state.getIn().isLive(var) && isVariableStillLiveWithinExpression(n, exprRoot, var.name)) { [EOL]             return; [EOL]         } [EOL]         if (n.isAssign()) { [EOL]             n.removeChild(rhs); [EOL]             n.getParent().replaceChild(n, rhs); [EOL]         } else if (NodeUtil.isAssignmentOp(n)) { [EOL]             n.removeChild(rhs); [EOL]             n.removeChild(lhs); [EOL]             Node op = new Node(NodeUtil.getOpFromAssignmentOp(n), lhs, rhs); [EOL]             parent.replaceChild(n, op); [EOL]         } else if (n.isInc() || n.isDec()) { [EOL]             if (parent.isExprResult()) { [EOL]                 parent.replaceChild(n, IR.voidNode(IR.number(0).srcref(n))); [EOL]             } else if (n.isComma() && n != parent.getLastChild()) { [EOL]                 parent.removeChild(n); [EOL]             } else if (parent.isFor() && !NodeUtil.isForIn(parent) && NodeUtil.getConditionExpression(parent) != n) { [EOL]                 parent.replaceChild(n, IR.empty()); [EOL]             } else { [EOL]                 return; [EOL]             } [EOL]         } else { [EOL]             Preconditions.checkState(false, "Unknown statement"); [EOL]         } [EOL]         compiler.reportCodeChange(); [EOL]         return; [EOL]     } else { [EOL]         for (Node c = n.getFirstChild(); c != null; ) { [EOL]             Node next = c.getNext(); [EOL]             if (!ControlFlowGraph.isEnteringNewCfgNode(c)) { [EOL]                 tryRemoveAssignment(t, c, exprRoot, state); [EOL]             } [EOL]             c = next; [EOL]         } [EOL]         return; [EOL]     } [EOL] } <line_num>: 175,279
private boolean isVariableStillLiveWithinExpression(Node n, Node exprRoot, String variable) { [EOL]     while (n != exprRoot) { [EOL]         VariableLiveness state = VariableLiveness.MAYBE_LIVE; [EOL]         switch(n.getParent().getType()) { [EOL]             case Token.OR: [EOL]             case Token.AND: [EOL]                 if (n.getNext() != null) { [EOL]                     state = isVariableReadBeforeKill(n.getNext(), variable); [EOL]                     if (state == VariableLiveness.KILL) { [EOL]                         state = VariableLiveness.MAYBE_LIVE; [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case Token.HOOK: [EOL]                 if (n.getNext() != null && n.getNext().getNext() != null) { [EOL]                     state = checkHookBranchReadBeforeKill(n.getNext(), n.getNext().getNext(), variable); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 for (Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) { [EOL]                     state = isVariableReadBeforeKill(sibling, variable); [EOL]                     if (state != VariableLiveness.MAYBE_LIVE) { [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]         } [EOL]         if (state == VariableLiveness.READ) { [EOL]             return true; [EOL]         } else if (state == VariableLiveness.KILL) { [EOL]             return false; [EOL]         } [EOL]         n = n.getParent(); [EOL]     } [EOL]     return false; [EOL] } <line_num>: 296,344
private VariableLiveness isVariableReadBeforeKill(Node n, String variable) { [EOL]     if (ControlFlowGraph.isEnteringNewCfgNode(n)) { [EOL]         return VariableLiveness.MAYBE_LIVE; [EOL]     } [EOL]     if (n.isName() && variable.equals(n.getString())) { [EOL]         if (NodeUtil.isVarOrSimpleAssignLhs(n, n.getParent())) { [EOL]             Preconditions.checkState(n.getParent().isAssign()); [EOL]             Node rhs = n.getNext(); [EOL]             VariableLiveness state = isVariableReadBeforeKill(rhs, variable); [EOL]             if (state == VariableLiveness.READ) { [EOL]                 return state; [EOL]             } [EOL]             return VariableLiveness.KILL; [EOL]         } else { [EOL]             return VariableLiveness.READ; [EOL]         } [EOL]     } [EOL]     switch(n.getType()) { [EOL]         case Token.OR: [EOL]         case Token.AND: [EOL]             VariableLiveness v1 = isVariableReadBeforeKill(n.getFirstChild(), variable); [EOL]             VariableLiveness v2 = isVariableReadBeforeKill(n.getLastChild(), variable); [EOL]             if (v1 != VariableLiveness.MAYBE_LIVE) { [EOL]                 return v1; [EOL]             } else if (v2 == VariableLiveness.READ) { [EOL]                 return VariableLiveness.READ; [EOL]             } else { [EOL]                 return VariableLiveness.MAYBE_LIVE; [EOL]             } [EOL]         case Token.HOOK: [EOL]             VariableLiveness first = isVariableReadBeforeKill(n.getFirstChild(), variable); [EOL]             if (first != VariableLiveness.MAYBE_LIVE) { [EOL]                 return first; [EOL]             } [EOL]             return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); [EOL]         default: [EOL]             for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { [EOL]                 VariableLiveness state = isVariableReadBeforeKill(child, variable); [EOL]                 if (state != VariableLiveness.MAYBE_LIVE) { [EOL]                     return state; [EOL]                 } [EOL]             } [EOL]     } [EOL]     return VariableLiveness.MAYBE_LIVE; [EOL] } <line_num>: 358,419
private VariableLiveness checkHookBranchReadBeforeKill(Node trueCase, Node falseCase, String variable) { [EOL]     VariableLiveness v1 = isVariableReadBeforeKill(trueCase, variable); [EOL]     VariableLiveness v2 = isVariableReadBeforeKill(falseCase, variable); [EOL]     if (v1 == VariableLiveness.READ || v2 == VariableLiveness.READ) { [EOL]         return VariableLiveness.READ; [EOL]     } else if (v1 == VariableLiveness.KILL && v2 == VariableLiveness.KILL) { [EOL]         return VariableLiveness.KILL; [EOL]     } else { [EOL]         return VariableLiveness.MAYBE_LIVE; [EOL]     } [EOL] } <line_num>: 421,437
