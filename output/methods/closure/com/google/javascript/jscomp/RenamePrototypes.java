Property(String name) { [EOL]     this.oldName = name; [EOL]     this.newName = null; [EOL]     this.prototypeCount = 0; [EOL]     this.objLitCount = 0; [EOL]     this.refCount = 0; [EOL] } <line_num>: 80,86
RenamePrototypes(AbstractCompiler compiler, boolean aggressiveRenaming, @Nullable char[] reservedCharacters, @Nullable VariableMap prevUsedRenameMap) { [EOL]     this.compiler = compiler; [EOL]     this.aggressiveRenaming = aggressiveRenaming; [EOL]     this.reservedCharacters = reservedCharacters; [EOL]     this.prevUsedRenameMap = prevUsedRenameMap; [EOL] } <line_num>: 190,197
int count() { [EOL]     return prototypeCount + objLitCount + refCount; [EOL] } <line_num>: 88,90
boolean canRename() { [EOL]     if (this.prototypeCount > 0 && this.objLitCount == 0) { [EOL]         return canRenamePrototypeProperty(); [EOL]     } [EOL]     if (this.objLitCount > 0 && this.prototypeCount == 0) { [EOL]         return canRenameObjLitProperty(); [EOL]     } [EOL]     return canRenamePrototypeProperty() && canRenameObjLitProperty(); [EOL] } <line_num>: 92,104
private boolean canRenamePrototypeProperty() { [EOL]     if (compiler.getCodingConvention().isExported(oldName)) { [EOL]         return false; [EOL]     } [EOL]     if (compiler.getCodingConvention().isPrivate(oldName)) { [EOL]         return true; [EOL]     } [EOL]     if (aggressiveRenaming) { [EOL]         return true; [EOL]     } [EOL]     for (int i = 0, n = oldName.length(); i < n; i++) { [EOL]         char ch = oldName.charAt(i); [EOL]         if (Character.isUpperCase(ch) || !Character.isLetter(ch)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 106,129
private boolean canRenameObjLitProperty() { [EOL]     if (compiler.getCodingConvention().isExported(oldName)) { [EOL]         return false; [EOL]     } [EOL]     if (compiler.getCodingConvention().isPrivate(oldName)) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 131,145
@Override [EOL] public int compare(Property a1, Property a2) { [EOL]     int n1 = a1.count(); [EOL]     int n2 = a2.count(); [EOL]     if (n1 != n2) { [EOL]         return n2 - n1; [EOL]     } [EOL]     return a1.oldName.compareTo(a2.oldName); [EOL] } <line_num>: 154,162
@Override [EOL] public void process(Node externs, Node root) { [EOL]     Preconditions.checkState(compiler.getLifeCycleStage().isNormalized()); [EOL]     NodeTraversal.traverse(compiler, externs, new ProcessExternedProperties()); [EOL]     NodeTraversal.traverse(compiler, root, new ProcessProperties()); [EOL]     SortedSet<Property> propsByFrequency = new TreeSet<Property>(FREQUENCY_COMPARATOR); [EOL]     for (Iterator<Map.Entry<String, Property>> it = properties.entrySet().iterator(); it.hasNext(); ) { [EOL]         Property a = it.next().getValue(); [EOL]         if (a.canRename() && !reservedNames.contains(a.oldName)) { [EOL]             propsByFrequency.add(a); [EOL]         } else { [EOL]             it.remove(); [EOL]             reservedNames.add(a.oldName); [EOL]         } [EOL]     } [EOL]     if (prevUsedRenameMap != null) { [EOL]         reusePrototypeNames(propsByFrequency); [EOL]     } [EOL]     NameGenerator nameGen = new NameGenerator(reservedNames, "", reservedCharacters); [EOL]     StringBuilder debug = new StringBuilder(); [EOL]     for (Property a : propsByFrequency) { [EOL]         if (a.newName == null) { [EOL]             a.newName = nameGen.generateNextName(); [EOL]             reservedNames.add(a.newName); [EOL]         } [EOL]         debug.append(a.oldName).append(" => ").append(a.newName).append('\n'); [EOL]     } [EOL]     compiler.addToDebugLog("JS property assignments:\n" + debug); [EOL]     boolean changed = false; [EOL]     for (Node n : stringNodes) { [EOL]         String oldName = n.getString(); [EOL]         Property a = properties.get(oldName); [EOL]         if (a != null && a.newName != null) { [EOL]             n.setString(a.newName); [EOL]             changed = changed || !a.newName.equals(oldName); [EOL]         } [EOL]     } [EOL]     if (changed) { [EOL]         compiler.reportCodeChange(); [EOL]     } [EOL]     compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED_OBFUSCATED); [EOL] } <line_num>: 205,267
private void reusePrototypeNames(Set<Property> properties) { [EOL]     for (Property prop : properties) { [EOL]         String prevName = prevUsedRenameMap.lookupNewName(prop.oldName); [EOL]         if (prevName != null) { [EOL]             if (reservedNames.contains(prevName)) { [EOL]                 continue; [EOL]             } [EOL]             prop.newName = prevName; [EOL]             reservedNames.add(prevName); [EOL]         } [EOL]     } [EOL] } <line_num>: 275,287
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     switch(n.getType()) { [EOL]         case Token.GETPROP: [EOL]         case Token.GETELEM: [EOL]             Node dest = n.getFirstChild().getNext(); [EOL]             if (dest.isString()) { [EOL]                 reservedNames.add(dest.getString()); [EOL]             } [EOL]     } [EOL] } <line_num>: 295,305
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     switch(n.getType()) { [EOL]         case Token.GETPROP: [EOL]         case Token.GETELEM: [EOL]             Node dest = n.getFirstChild().getNext(); [EOL]             if (dest.isString()) { [EOL]                 String s = dest.getString(); [EOL]                 if (s.equals("prototype")) { [EOL]                     processPrototypeParent(parent, t.getInput()); [EOL]                 } else { [EOL]                     markPropertyAccessCandidate(dest, t.getInput()); [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Token.OBJECTLIT: [EOL]             if (!prototypeObjLits.contains(n)) { [EOL]                 for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { [EOL]                     if (TokenStream.isJSIdentifier(child.getString())) { [EOL]                         markObjLitPropertyCandidate(child, t.getInput()); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             break; [EOL]     } [EOL] } <line_num>: 317,348
private void processPrototypeParent(Node n, CompilerInput input) { [EOL]     switch(n.getType()) { [EOL]         case Token.GETPROP: [EOL]         case Token.GETELEM: [EOL]             Node dest = n.getFirstChild().getNext(); [EOL]             if (dest.isString()) { [EOL]                 markPrototypePropertyCandidate(dest, input); [EOL]             } [EOL]             break; [EOL]         case Token.ASSIGN: [EOL]         case Token.CALL: [EOL]             Node map; [EOL]             if (n.isAssign()) { [EOL]                 map = n.getFirstChild().getNext(); [EOL]             } else { [EOL]                 map = n.getLastChild(); [EOL]             } [EOL]             if (map.isObjectLit()) { [EOL]                 prototypeObjLits.add(map); [EOL]                 for (Node key = map.getFirstChild(); key != null; key = key.getNext()) { [EOL]                     if (TokenStream.isJSIdentifier(key.getString())) { [EOL]                         markPrototypePropertyCandidate(key, input); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             break; [EOL]     } [EOL] } <line_num>: 355,390
private void markPrototypePropertyCandidate(Node n, CompilerInput input) { [EOL]     stringNodes.add(n); [EOL]     getProperty(n.getString()).prototypeCount++; [EOL] } <line_num>: 399,402
private void markObjLitPropertyCandidate(Node n, CompilerInput input) { [EOL]     stringNodes.add(n); [EOL]     getProperty(n.getString()).objLitCount++; [EOL] } <line_num>: 411,414
private void markPropertyAccessCandidate(Node n, CompilerInput input) { [EOL]     stringNodes.add(n); [EOL]     getProperty(n.getString()).refCount++; [EOL] } <line_num>: 423,426
private Property getProperty(String name) { [EOL]     Property prop = properties.get(name); [EOL]     if (prop == null) { [EOL]         prop = new Property(name); [EOL]         properties.put(name, prop); [EOL]     } [EOL]     return prop; [EOL] } <line_num>: 432,439
VariableMap getPropertyMap() { [EOL]     ImmutableMap.Builder<String, String> map = ImmutableMap.builder(); [EOL]     for (Property p : properties.values()) { [EOL]         if (p.newName != null) { [EOL]             map.put(p.oldName, p.newName); [EOL]         } [EOL]     } [EOL]     return new VariableMap(map.build()); [EOL] } <line_num>: 447,455
