public PureFunctionIdentifier(AbstractCompiler compiler, DefinitionProvider definitionProvider) { [EOL]     this.compiler = compiler; [EOL]     this.definitionProvider = definitionProvider; [EOL]     this.functionSideEffectMap = Maps.newHashMap(); [EOL]     this.allFunctionCalls = Lists.newArrayList(); [EOL]     this.externs = null; [EOL]     this.root = null; [EOL] } <line_num>: 89,97
FunctionAnalyzer(boolean inExterns) { [EOL]     this.inExterns = inExterns; [EOL] } <line_num>: 375,377
FunctionInformation(boolean extern) { [EOL]     this.extern = extern; [EOL]     checkInvariant(); [EOL] } <line_num>: 899,902
Driver(AbstractCompiler compiler, String reportPath, boolean useNameReferenceGraph) { [EOL]     this.compiler = compiler; [EOL]     this.reportPath = reportPath; [EOL]     this.useNameReferenceGraph = useNameReferenceGraph; [EOL] } <line_num>: 1087,1092
@Override [EOL] public void process(Node externsAst, Node srcAst) { [EOL]     if (externs != null || root != null) { [EOL]         throw new IllegalStateException("It is illegal to call PureFunctionIdentifier.process " + "twice the same instance.  Please use a new " + "PureFunctionIdentifier instance each time."); [EOL]     } [EOL]     externs = externsAst; [EOL]     root = srcAst; [EOL]     NodeTraversal.traverse(compiler, externs, new FunctionAnalyzer(true)); [EOL]     NodeTraversal.traverse(compiler, root, new FunctionAnalyzer(false)); [EOL]     propagateSideEffects(); [EOL]     markPureFunctionCalls(); [EOL] } <line_num>: 99,117
String getDebugReport() { [EOL]     Preconditions.checkNotNull(externs); [EOL]     Preconditions.checkNotNull(root); [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     FunctionNames functionNames = new FunctionNames(compiler); [EOL]     functionNames.process(null, externs); [EOL]     functionNames.process(null, root); [EOL]     sb.append("Pure functions:\n"); [EOL]     for (Map.Entry<Node, FunctionInformation> entry : functionSideEffectMap.entrySet()) { [EOL]         Node function = entry.getKey(); [EOL]         FunctionInformation functionInfo = entry.getValue(); [EOL]         boolean isPure = functionInfo.mayBePure() && !functionInfo.mayHaveSideEffects(); [EOL]         if (isPure) { [EOL]             sb.append("  " + functionNames.getFunctionName(function) + "\n"); [EOL]         } [EOL]     } [EOL]     sb.append("\n"); [EOL]     for (Map.Entry<Node, FunctionInformation> entry : functionSideEffectMap.entrySet()) { [EOL]         Node function = entry.getKey(); [EOL]         FunctionInformation functionInfo = entry.getValue(); [EOL]         Set<String> depFunctionNames = Sets.newHashSet(); [EOL]         for (Node callSite : functionInfo.getCallsInFunctionBody()) { [EOL]             Collection<Definition> defs = getCallableDefinitions(definitionProvider, callSite.getFirstChild()); [EOL]             if (defs == null) { [EOL]                 depFunctionNames.add("<null def list>"); [EOL]                 continue; [EOL]             } [EOL]             for (Definition def : defs) { [EOL]                 depFunctionNames.add(functionNames.getFunctionName(def.getRValue())); [EOL]             } [EOL]         } [EOL]         sb.append(functionNames.getFunctionName(function) + " " + functionInfo.toString() + " Calls: " + depFunctionNames + "\n"); [EOL]     } [EOL]     return sb.toString(); [EOL] } <line_num>: 124,176
private static Collection<Definition> getCallableDefinitions(DefinitionProvider definitionProvider, Node name) { [EOL]     if (name.isGetProp() || name.isName()) { [EOL]         List<Definition> result = Lists.newArrayList(); [EOL]         Collection<Definition> decls = definitionProvider.getDefinitionsReferencedAt(name); [EOL]         if (decls == null) { [EOL]             return null; [EOL]         } [EOL]         for (Definition current : decls) { [EOL]             Node rValue = current.getRValue(); [EOL]             if ((rValue != null) && rValue.isFunction()) { [EOL]                 result.add(current); [EOL]             } else { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } else if (name.isOr() || name.isHook()) { [EOL]         Node firstVal; [EOL]         if (name.isHook()) { [EOL]             firstVal = name.getFirstChild().getNext(); [EOL]         } else { [EOL]             firstVal = name.getFirstChild(); [EOL]         } [EOL]         Collection<Definition> defs1 = getCallableDefinitions(definitionProvider, firstVal); [EOL]         Collection<Definition> defs2 = getCallableDefinitions(definitionProvider, firstVal.getNext()); [EOL]         if (defs1 != null && defs2 != null) { [EOL]             defs1.addAll(defs2); [EOL]             return defs1; [EOL]         } else { [EOL]             return null; [EOL]         } [EOL]     } else if (NodeUtil.isFunctionExpression(name)) { [EOL]         return Lists.newArrayList((Definition) new DefinitionsRemover.FunctionExpressionDefinition(name, false)); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] } <line_num>: 189,244
private void propagateSideEffects() { [EOL]     DiGraph<FunctionInformation, Node> sideEffectGraph = LinkedDirectedGraph.createWithoutAnnotations(); [EOL]     for (FunctionInformation functionInfo : functionSideEffectMap.values()) { [EOL]         sideEffectGraph.createNode(functionInfo); [EOL]     } [EOL]     for (FunctionInformation functionInfo : functionSideEffectMap.values()) { [EOL]         if (!functionInfo.mayHaveSideEffects()) { [EOL]             continue; [EOL]         } [EOL]         for (Node callSite : functionInfo.getCallsInFunctionBody()) { [EOL]             Node callee = callSite.getFirstChild(); [EOL]             Collection<Definition> defs = getCallableDefinitions(definitionProvider, callee); [EOL]             if (defs == null) { [EOL]                 functionInfo.setTaintsUnknown(); [EOL]                 break; [EOL]             } [EOL]             for (Definition def : defs) { [EOL]                 Node defValue = def.getRValue(); [EOL]                 FunctionInformation dep = functionSideEffectMap.get(defValue); [EOL]                 Preconditions.checkNotNull(dep); [EOL]                 sideEffectGraph.connect(dep, callSite, functionInfo); [EOL]             } [EOL]         } [EOL]     } [EOL]     FixedPointGraphTraversal.newTraversal(new SideEffectPropagationCallback()).computeFixedPoint(sideEffectGraph); [EOL]     for (FunctionInformation functionInfo : functionSideEffectMap.values()) { [EOL]         if (functionInfo.mayBePure()) { [EOL]             functionInfo.setIsPure(); [EOL]         } [EOL]     } [EOL] } <line_num>: 252,302
private void markPureFunctionCalls() { [EOL]     for (Node callNode : allFunctionCalls) { [EOL]         Node name = callNode.getFirstChild(); [EOL]         Collection<Definition> defs = getCallableDefinitions(definitionProvider, name); [EOL]         Node.SideEffectFlags flags = new Node.SideEffectFlags(); [EOL]         if (defs == null) { [EOL]             flags.setMutatesGlobalState(); [EOL]             flags.setThrows(); [EOL]             flags.setReturnsTainted(); [EOL]         } else { [EOL]             flags.clearAllFlags(); [EOL]             for (Definition def : defs) { [EOL]                 FunctionInformation functionInfo = functionSideEffectMap.get(def.getRValue()); [EOL]                 Preconditions.checkNotNull(functionInfo); [EOL]                 if (functionInfo.mutatesGlobalState()) { [EOL]                     flags.setMutatesGlobalState(); [EOL]                 } [EOL]                 if (functionInfo.functionThrows) { [EOL]                     flags.setThrows(); [EOL]                 } [EOL]                 if (!callNode.isNew()) { [EOL]                     if (functionInfo.taintsThis) { [EOL]                         flags.setMutatesThis(); [EOL]                     } [EOL]                 } [EOL]                 if (functionInfo.taintsReturn) { [EOL]                     flags.setReturnsTainted(); [EOL]                 } [EOL]                 if (flags.areAllFlagsSet()) { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (callNode.isCall()) { [EOL]             Preconditions.checkState(compiler != null); [EOL]             if (!NodeUtil.functionCallHasSideEffects(callNode, compiler)) { [EOL]                 flags.clearSideEffectFlags(); [EOL]             } [EOL]         } else if (callNode.isNew()) { [EOL]             if (!NodeUtil.constructorCallHasSideEffects(callNode)) { [EOL]                 flags.clearSideEffectFlags(); [EOL]             } [EOL]         } [EOL]         callNode.setSideEffectFlags(flags.valueOf()); [EOL]     } [EOL] } <line_num>: 307,365
@Override [EOL] public boolean shouldTraverse(NodeTraversal traversal, Node node, Node parent) { [EOL]     if (node.isFunction()) { [EOL]         Node gramp = parent.getParent(); [EOL]         visitFunction(traversal, node, parent, gramp); [EOL]     } [EOL]     return true; [EOL] } <line_num>: 379,394
@Override [EOL] public void visit(NodeTraversal traversal, Node node, Node parent) { [EOL]     if (inExterns) { [EOL]         return; [EOL]     } [EOL]     if (!NodeUtil.nodeTypeMayHaveSideEffects(node) && !node.isReturn()) { [EOL]         return; [EOL]     } [EOL]     if (node.isCall() || node.isNew()) { [EOL]         allFunctionCalls.add(node); [EOL]     } [EOL]     Node enclosingFunction = traversal.getEnclosingFunction(); [EOL]     if (enclosingFunction != null) { [EOL]         FunctionInformation sideEffectInfo = functionSideEffectMap.get(enclosingFunction); [EOL]         Preconditions.checkNotNull(sideEffectInfo); [EOL]         if (NodeUtil.isAssignmentOp(node)) { [EOL]             visitAssignmentOrUnaryOperator(sideEffectInfo, traversal.getScope(), node, node.getFirstChild(), node.getLastChild()); [EOL]         } else { [EOL]             switch(node.getType()) { [EOL]                 case Token.CALL: [EOL]                 case Token.NEW: [EOL]                     visitCall(sideEffectInfo, node); [EOL]                     break; [EOL]                 case Token.DELPROP: [EOL]                 case Token.DEC: [EOL]                 case Token.INC: [EOL]                     visitAssignmentOrUnaryOperator(sideEffectInfo, traversal.getScope(), node, node.getFirstChild(), null); [EOL]                     break; [EOL]                 case Token.NAME: [EOL]                     Preconditions.checkArgument(NodeUtil.isVarDeclaration(node)); [EOL]                     Node value = node.getFirstChild(); [EOL]                     if (value != null && !NodeUtil.evaluatesToLocalValue(value)) { [EOL]                         Scope scope = traversal.getScope(); [EOL]                         Var var = scope.getVar(node.getString()); [EOL]                         sideEffectInfo.blacklistLocal(var); [EOL]                     } [EOL]                     break; [EOL]                 case Token.THROW: [EOL]                     visitThrow(sideEffectInfo); [EOL]                     break; [EOL]                 case Token.RETURN: [EOL]                     if (node.hasChildren() && !NodeUtil.evaluatesToLocalValue(node.getFirstChild())) { [EOL]                         sideEffectInfo.setTaintsReturn(); [EOL]                     } [EOL]                     break; [EOL]                 default: [EOL]                     throw new IllegalArgumentException("Unhandled side effect node type " + Token.name(node.getType())); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 396,467
@Override [EOL] public void enterScope(NodeTraversal t) { [EOL] } <line_num>: 469,472
@Override [EOL] public void exitScope(NodeTraversal t) { [EOL]     if (t.inGlobalScope()) { [EOL]         return; [EOL]     } [EOL]     FunctionInformation sideEffectInfo = functionSideEffectMap.get(t.getScopeRoot()); [EOL]     if (sideEffectInfo.mutatesGlobalState()) { [EOL]         sideEffectInfo.resetLocalVars(); [EOL]         return; [EOL]     } [EOL]     for (Iterator<Var> i = t.getScope().getVars(); i.hasNext(); ) { [EOL]         Var v = i.next(); [EOL]         boolean localVar = false; [EOL]         if (v.getParentNode().isVar()) { [EOL]             sideEffectInfo.knownLocals.add(v.getName()); [EOL]             localVar = true; [EOL]         } [EOL]         if (!localVar || sideEffectInfo.blacklisted.contains(v)) { [EOL]             if (sideEffectInfo.taintedLocals.contains(v)) { [EOL]                 sideEffectInfo.setTaintsUnknown(); [EOL]                 sideEffectInfo.resetLocalVars(); [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     sideEffectInfo.taintedLocals = null; [EOL]     sideEffectInfo.blacklisted = null; [EOL] } <line_num>: 474,513
private void visitAssignmentOrUnaryOperator(FunctionInformation sideEffectInfo, Scope scope, Node op, Node lhs, Node rhs) { [EOL]     if (lhs.isName()) { [EOL]         Var var = scope.getVar(lhs.getString()); [EOL]         if (var == null || var.scope != scope) { [EOL]             sideEffectInfo.setTaintsGlobalState(); [EOL]         } else { [EOL]             Preconditions.checkState(NodeUtil.isAssignmentOp(op) || isIncDec(op) || op.isDelProp()); [EOL]             if (rhs != null && op.isAssign() && !NodeUtil.evaluatesToLocalValue(rhs)) { [EOL]                 sideEffectInfo.blacklistLocal(var); [EOL]             } [EOL]         } [EOL]     } else if (NodeUtil.isGet(lhs)) { [EOL]         if (lhs.getFirstChild().isThis()) { [EOL]             sideEffectInfo.setTaintsThis(); [EOL]         } else { [EOL]             Var var = null; [EOL]             Node objectNode = lhs.getFirstChild(); [EOL]             if (objectNode.isName()) { [EOL]                 var = scope.getVar(objectNode.getString()); [EOL]             } [EOL]             if (var == null || var.scope != scope) { [EOL]                 sideEffectInfo.setTaintsUnknown(); [EOL]             } else { [EOL]                 sideEffectInfo.addTaintedLocalObject(var); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         sideEffectInfo.setTaintsUnknown(); [EOL]     } [EOL] } <line_num>: 526,577
private void visitCall(FunctionInformation sideEffectInfo, Node node) { [EOL]     if (node.isCall() && !NodeUtil.functionCallHasSideEffects(node, compiler)) { [EOL]         return; [EOL]     } [EOL]     if (node.isNew() && !NodeUtil.constructorCallHasSideEffects(node)) { [EOL]         return; [EOL]     } [EOL]     sideEffectInfo.appendCall(node); [EOL] } <line_num>: 582,596
private void visitFunction(NodeTraversal traversal, Node node, Node parent, Node gramp) { [EOL]     Preconditions.checkArgument(!functionSideEffectMap.containsKey(node)); [EOL]     FunctionInformation sideEffectInfo = new FunctionInformation(inExterns); [EOL]     functionSideEffectMap.put(node, sideEffectInfo); [EOL]     if (inExterns) { [EOL]         JSType jstype = node.getJSType(); [EOL]         boolean knownLocalResult = false; [EOL]         FunctionType functionType = JSType.toMaybeFunctionType(jstype); [EOL]         if (functionType != null) { [EOL]             JSType jstypeReturn = functionType.getReturnType(); [EOL]             if (isLocalValueType(jstypeReturn, true)) { [EOL]                 knownLocalResult = true; [EOL]             } [EOL]         } [EOL]         if (!knownLocalResult) { [EOL]             sideEffectInfo.setTaintsReturn(); [EOL]         } [EOL]     } [EOL]     JSDocInfo info = getJSDocInfoForFunction(node, parent, gramp); [EOL]     if (info != null) { [EOL]         boolean hasSpecificSideEffects = false; [EOL]         if (hasSideEffectsThisAnnotation(info)) { [EOL]             if (inExterns) { [EOL]                 hasSpecificSideEffects = true; [EOL]                 sideEffectInfo.setTaintsThis(); [EOL]             } else { [EOL]                 traversal.report(node, INVALID_MODIFIES_ANNOTATION); [EOL]             } [EOL]         } [EOL]         if (hasSideEffectsArgumentsAnnotation(info)) { [EOL]             if (inExterns) { [EOL]                 hasSpecificSideEffects = true; [EOL]                 sideEffectInfo.setTaintsArguments(); [EOL]             } else { [EOL]                 traversal.report(node, INVALID_MODIFIES_ANNOTATION); [EOL]             } [EOL]         } [EOL]         if (inExterns && !info.getThrownTypes().isEmpty()) { [EOL]             hasSpecificSideEffects = true; [EOL]             sideEffectInfo.setFunctionThrows(); [EOL]         } [EOL]         if (!hasSpecificSideEffects) { [EOL]             if (hasNoSideEffectsAnnotation(info)) { [EOL]                 if (inExterns) { [EOL]                     sideEffectInfo.setIsPure(); [EOL]                 } else { [EOL]                     traversal.report(node, INVALID_NO_SIDE_EFFECT_ANNOTATION); [EOL]                 } [EOL]             } else if (inExterns) { [EOL]                 sideEffectInfo.setTaintsGlobalState(); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (inExterns) { [EOL]             sideEffectInfo.setTaintsGlobalState(); [EOL]         } [EOL]     } [EOL] } <line_num>: 601,667
private boolean isLocalValueType(JSType jstype, boolean recurse) { [EOL]     Preconditions.checkNotNull(jstype); [EOL]     JSType subtype = jstype.getGreatestSubtype(compiler.getTypeRegistry().getNativeType(JSTypeNative.OBJECT_TYPE)); [EOL]     return subtype.isNoType(); [EOL] } <line_num>: 672,679
private void visitThrow(FunctionInformation sideEffectInfo) { [EOL]     sideEffectInfo.setFunctionThrows(); [EOL] } <line_num>: 684,686
private JSDocInfo getJSDocInfoForFunction(Node node, Node parent, Node gramp) { [EOL]     JSDocInfo info = node.getJSDocInfo(); [EOL]     if (info != null) { [EOL]         return info; [EOL]     } else if (parent.isName()) { [EOL]         return gramp.hasOneChild() ? gramp.getJSDocInfo() : null; [EOL]     } else if (parent.isAssign()) { [EOL]         return parent.getJSDocInfo(); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] } <line_num>: 691,703
private boolean hasNoSideEffectsAnnotation(JSDocInfo docInfo) { [EOL]     Preconditions.checkNotNull(docInfo); [EOL]     return docInfo.isNoSideEffects(); [EOL] } <line_num>: 709,712
private boolean hasSideEffectsThisAnnotation(JSDocInfo docInfo) { [EOL]     Preconditions.checkNotNull(docInfo); [EOL]     return (docInfo.getModifies().contains("this")); [EOL] } <line_num>: 718,721
private boolean hasSideEffectsArgumentsAnnotation(JSDocInfo docInfo) { [EOL]     Preconditions.checkNotNull(docInfo); [EOL]     Set<String> modifies = docInfo.getModifies(); [EOL]     return (modifies.size() > 1 || (modifies.size() == 1 && !modifies.contains("this"))); [EOL] } <line_num>: 727,734
private static boolean isIncDec(Node n) { [EOL]     int type = n.getType(); [EOL]     return (type == Token.INC || type == Token.DEC); [EOL] } <line_num>: 737,740
@Override [EOL] public boolean apply(Node value) { [EOL]     switch(value.getType()) { [EOL]         case Token.ASSIGN: [EOL]             return false; [EOL]         case Token.THIS: [EOL]             return false; [EOL]         case Token.NAME: [EOL]             return false; [EOL]         case Token.GETELEM: [EOL]         case Token.GETPROP: [EOL]             return false; [EOL]         case Token.CALL: [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 749,772
@SuppressWarnings("unused") [EOL] private static boolean isKnownLocalValue(final Node value) { [EOL]     Predicate<Node> taintingPredicate = new Predicate<Node>() { [EOL]  [EOL]         @Override [EOL]         public boolean apply(Node value) { [EOL]             switch(value.getType()) { [EOL]                 case Token.ASSIGN: [EOL]                     return false; [EOL]                 case Token.THIS: [EOL]                     return false; [EOL]                 case Token.NAME: [EOL]                     return false; [EOL]                 case Token.GETELEM: [EOL]                 case Token.GETPROP: [EOL]                     return false; [EOL]                 case Token.CALL: [EOL]                     return false; [EOL]             } [EOL]             return false; [EOL]         } [EOL]     }; [EOL]     return NodeUtil.evaluatesToLocalValue(value, taintingPredicate); [EOL] } <line_num>: 746,776
@Override [EOL] public boolean traverseEdge(FunctionInformation callee, Node callSite, FunctionInformation caller) { [EOL]     Preconditions.checkArgument(callSite.isCall() || callSite.isNew()); [EOL]     boolean changed = false; [EOL]     if (!caller.mutatesGlobalState() && callee.mutatesGlobalState()) { [EOL]         caller.setTaintsGlobalState(); [EOL]         changed = true; [EOL]     } [EOL]     if (!caller.functionThrows() && callee.functionThrows()) { [EOL]         caller.setFunctionThrows(); [EOL]         changed = true; [EOL]     } [EOL]     if (callee.mutatesThis()) { [EOL]         if (!callSite.isNew()) { [EOL]             Node objectNode = getCallThisObject(callSite); [EOL]             if (objectNode != null && objectNode.isName() && !isCallOrApply(callSite)) { [EOL]                 String name = objectNode.getString(); [EOL]                 if (!caller.mutatesGlobalState()) { [EOL]                     caller.setTaintsGlobalState(); [EOL]                     changed = true; [EOL]                 } [EOL]             } else if (objectNode != null && objectNode.isThis()) { [EOL]                 if (!caller.mutatesThis()) { [EOL]                     caller.setTaintsThis(); [EOL]                     changed = true; [EOL]                 } [EOL]             } else if (objectNode != null && NodeUtil.evaluatesToLocalValue(objectNode) && !isCallOrApply(callSite)) { [EOL]             } else if (!caller.mutatesGlobalState()) { [EOL]                 caller.setTaintsGlobalState(); [EOL]                 changed = true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return changed; [EOL] } <line_num>: 783,842
private static Node getCallThisObject(Node callSite) { [EOL]     Node callTarget = callSite.getFirstChild(); [EOL]     if (!NodeUtil.isGet(callTarget)) { [EOL]         return null; [EOL]     } [EOL]     String propString = callTarget.getLastChild().getString(); [EOL]     if (propString.equals("call") || propString.equals("apply")) { [EOL]         return callTarget.getNext(); [EOL]     } else { [EOL]         return callTarget.getFirstChild(); [EOL]     } [EOL] } <line_num>: 854,868
private static boolean isCallOrApply(Node callSite) { [EOL]     Node callTarget = callSite.getFirstChild(); [EOL]     if (NodeUtil.isGet(callTarget)) { [EOL]         String propString = callTarget.getLastChild().getString(); [EOL]         if (propString.equals("call") || propString.equals("apply")) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 870,879
void addTaintedLocalObject(Var var) { [EOL]     taintedLocals.add(var); [EOL] } <line_num>: 907,909
void resetLocalVars() { [EOL]     blacklisted = null; [EOL]     taintedLocals = null; [EOL]     knownLocals = Collections.emptySet(); [EOL] } <line_num>: 911,915
public void blacklistLocal(Var var) { [EOL]     blacklisted.add(var); [EOL] } <line_num>: 920,922
boolean mayBePure() { [EOL]     return !(functionThrows || taintsGlobalState || taintsThis || taintsArguments || taintsUnknown); [EOL] } <line_num>: 927,933
boolean mayHaveSideEffects() { [EOL]     return !pureFunction; [EOL] } <line_num>: 938,940
void setIsPure() { [EOL]     pureFunction = true; [EOL]     checkInvariant(); [EOL] } <line_num>: 945,948
void setTaintsGlobalState() { [EOL]     taintsGlobalState = true; [EOL]     checkInvariant(); [EOL] } <line_num>: 953,956
void setTaintsThis() { [EOL]     taintsThis = true; [EOL]     checkInvariant(); [EOL] } <line_num>: 961,964
void setTaintsArguments() { [EOL]     taintsArguments = true; [EOL]     checkInvariant(); [EOL] } <line_num>: 969,972
void setFunctionThrows() { [EOL]     functionThrows = true; [EOL]     checkInvariant(); [EOL] } <line_num>: 977,980
void setTaintsUnknown() { [EOL]     taintsUnknown = true; [EOL]     checkInvariant(); [EOL] } <line_num>: 986,989
void setTaintsReturn() { [EOL]     taintsReturn = true; [EOL]     checkInvariant(); [EOL] } <line_num>: 994,997
boolean mutatesGlobalState() { [EOL]     return taintsGlobalState || taintsArguments || taintsUnknown; [EOL] } <line_num>: 1003,1006
boolean mutatesThis() { [EOL]     return taintsThis; [EOL] } <line_num>: 1011,1013
boolean functionThrows() { [EOL]     return functionThrows; [EOL] } <line_num>: 1018,1020
private void checkInvariant() { [EOL]     boolean invariant = mayBePure() || mayHaveSideEffects(); [EOL]     if (!invariant) { [EOL]         throw new IllegalStateException("Invariant failed.  " + toString()); [EOL]     } [EOL] } <line_num>: 1026,1031
void appendCall(Node callNode) { [EOL]     callsInFunctionBody.add(callNode); [EOL] } <line_num>: 1036,1038
List<Node> getCallsInFunctionBody() { [EOL]     return callsInFunctionBody; [EOL] } <line_num>: 1043,1045
@Override [EOL] public String toString() { [EOL]     List<String> status = Lists.newArrayList(); [EOL]     if (extern) { [EOL]         status.add("extern"); [EOL]     } [EOL]     if (pureFunction) { [EOL]         status.add("pure"); [EOL]     } [EOL]     if (taintsThis) { [EOL]         status.add("this"); [EOL]     } [EOL]     if (taintsGlobalState) { [EOL]         status.add("global"); [EOL]     } [EOL]     if (functionThrows) { [EOL]         status.add("throw"); [EOL]     } [EOL]     if (taintsUnknown) { [EOL]         status.add("complex"); [EOL]     } [EOL]     return "Side effects: " + status.toString(); [EOL] } <line_num>: 1047,1075
@Override [EOL] public void process(Node externs, Node root) { [EOL]     DefinitionProvider definitionProvider = null; [EOL]     if (useNameReferenceGraph) { [EOL]         NameReferenceGraphConstruction graphBuilder = new NameReferenceGraphConstruction(compiler); [EOL]         graphBuilder.process(externs, root); [EOL]         definitionProvider = graphBuilder.getNameReferenceGraph(); [EOL]     } else { [EOL]         SimpleDefinitionFinder defFinder = new SimpleDefinitionFinder(compiler); [EOL]         defFinder.process(externs, root); [EOL]         definitionProvider = defFinder; [EOL]     } [EOL]     PureFunctionIdentifier pureFunctionIdentifier = new PureFunctionIdentifier(compiler, definitionProvider); [EOL]     pureFunctionIdentifier.process(externs, root); [EOL]     if (reportPath != null) { [EOL]         try { [EOL]             Files.write(pureFunctionIdentifier.getDebugReport(), new File(reportPath), Charsets.UTF_8); [EOL]         } catch (IOException e) { [EOL]             throw new RuntimeException(e); [EOL]         } [EOL]     } [EOL] } <line_num>: 1094,1121
