ProcessClosurePrimitives(AbstractCompiler compiler, @Nullable PreprocessorSymbolTable preprocessorSymbolTable, CheckLevel requiresLevel) { [EOL]     this.compiler = compiler; [EOL]     this.preprocessorSymbolTable = preprocessorSymbolTable; [EOL]     this.moduleGraph = compiler.getModuleGraph(); [EOL]     this.requiresLevel = requiresLevel; [EOL]     providedNames.put(GOOG, new ProvidedName(GOOG, null, null, false)); [EOL] } <line_num>: 123,134
ProvidedName(String namespace, Node node, JSModule module, boolean explicit) { [EOL]     Preconditions.checkArgument(node == null || node.isExprResult()); [EOL]     this.namespace = namespace; [EOL]     this.firstNode = node; [EOL]     this.firstModule = module; [EOL]     addProvide(node, module, explicit); [EOL] } <line_num>: 788,798
UnrecognizedRequire(Node requireNode, String namespace, String inputName) { [EOL]     this.requireNode = requireNode; [EOL]     this.namespace = namespace; [EOL]     this.inputName = inputName; [EOL] } <line_num>: 1118,1122
Set<String> getExportedVariableNames() { [EOL]     return exportedVariables; [EOL] } <line_num>: 136,138
@Override [EOL] public void process(Node externs, Node root) { [EOL]     new NodeTraversal(compiler, this).traverse(root); [EOL]     for (ProvidedName pn : providedNames.values()) { [EOL]         pn.replace(); [EOL]     } [EOL]     if (requiresLevel.isOn()) { [EOL]         for (UnrecognizedRequire r : unrecognizedRequires) { [EOL]             DiagnosticType error; [EOL]             ProvidedName expectedName = providedNames.get(r.namespace); [EOL]             if (expectedName != null && expectedName.firstNode != null) { [EOL]                 error = LATE_PROVIDE_ERROR; [EOL]             } else { [EOL]                 error = MISSING_PROVIDE_ERROR; [EOL]             } [EOL]             compiler.report(JSError.make(r.inputName, r.requireNode, requiresLevel, error, r.namespace)); [EOL]         } [EOL]     } [EOL] } <line_num>: 140,163
@Override [EOL] public void hotSwapScript(Node scriptRoot, Node originalRoot) { [EOL]     this.compiler.process(this); [EOL] } <line_num>: 165,170
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     switch(n.getType()) { [EOL]         case Token.CALL: [EOL]             boolean isExpr = parent.isExprResult(); [EOL]             Node left = n.getFirstChild(); [EOL]             if (left.isGetProp()) { [EOL]                 Node name = left.getFirstChild(); [EOL]                 if (name.isName() && GOOG.equals(name.getString())) { [EOL]                     String methodName = name.getNext().getString(); [EOL]                     if ("base".equals(methodName)) { [EOL]                         processBaseClassCall(t, n); [EOL]                     } else if (!isExpr) { [EOL]                         break; [EOL]                     } else if ("require".equals(methodName)) { [EOL]                         processRequireCall(t, n, parent); [EOL]                     } else if ("provide".equals(methodName)) { [EOL]                         processProvideCall(t, n, parent); [EOL]                     } else if ("exportSymbol".equals(methodName)) { [EOL]                         Node arg = left.getNext(); [EOL]                         if (arg.isString()) { [EOL]                             int dot = arg.getString().indexOf('.'); [EOL]                             if (dot == -1) { [EOL]                                 exportedVariables.add(arg.getString()); [EOL]                             } else { [EOL]                                 exportedVariables.add(arg.getString().substring(0, dot)); [EOL]                             } [EOL]                         } [EOL]                     } else if ("addDependency".equals(methodName)) { [EOL]                         CodingConvention convention = compiler.getCodingConvention(); [EOL]                         List<String> typeDecls = convention.identifyTypeDeclarationCall(n); [EOL]                         if (typeDecls != null) { [EOL]                             for (String typeDecl : typeDecls) { [EOL]                                 compiler.getTypeRegistry().forwardDeclareType(typeDecl); [EOL]                             } [EOL]                         } [EOL]                         parent.replaceChild(n, IR.number(0)); [EOL]                         compiler.reportCodeChange(); [EOL]                     } else if ("setCssNameMapping".equals(methodName)) { [EOL]                         processSetCssNameMapping(t, n, parent); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Token.ASSIGN: [EOL]         case Token.NAME: [EOL]             handleCandidateProvideDefinition(t, n, parent); [EOL]             break; [EOL]         case Token.EXPR_RESULT: [EOL]             handleTypedefDefinition(t, n, parent); [EOL]             break; [EOL]         case Token.FUNCTION: [EOL]             if (t.inGlobalScope() && !NodeUtil.isFunctionExpression(n)) { [EOL]                 String name = n.getFirstChild().getString(); [EOL]                 ProvidedName pn = providedNames.get(name); [EOL]                 if (pn != null) { [EOL]                     compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name)); [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Token.GETPROP: [EOL]             if (n.getFirstChild().isName() && !parent.isCall() && !parent.isAssign() && "goog.base".equals(n.getQualifiedName())) { [EOL]                 reportBadBaseClassUse(t, n, "May only be called directly."); [EOL]             } [EOL]             break; [EOL]     } [EOL] } <line_num>: 172,259
private void processRequireCall(NodeTraversal t, Node n, Node parent) { [EOL]     Node left = n.getFirstChild(); [EOL]     Node arg = left.getNext(); [EOL]     if (verifyArgument(t, left, arg)) { [EOL]         String ns = arg.getString(); [EOL]         ProvidedName provided = providedNames.get(ns); [EOL]         if (provided == null || !provided.isExplicitlyProvided()) { [EOL]             unrecognizedRequires.add(new UnrecognizedRequire(n, ns, t.getSourceName())); [EOL]         } else { [EOL]             JSModule providedModule = provided.explicitModule; [EOL]             Preconditions.checkNotNull(providedModule); [EOL]             JSModule module = t.getModule(); [EOL]             if (moduleGraph != null && module != providedModule && !moduleGraph.dependsOn(module, providedModule)) { [EOL]                 compiler.report(t.makeError(n, XMODULE_REQUIRE_ERROR, ns, providedModule.getName(), module.getName())); [EOL]             } [EOL]         } [EOL]         maybeAddToSymbolTable(left); [EOL]         maybeAddStringNodeToSymbolTable(arg); [EOL]         if (provided != null || requiresLevel.isOn()) { [EOL]             parent.detachFromParent(); [EOL]             compiler.reportCodeChange(); [EOL]         } [EOL]     } [EOL] } <line_num>: 264,304
private void processProvideCall(NodeTraversal t, Node n, Node parent) { [EOL]     Node left = n.getFirstChild(); [EOL]     Node arg = left.getNext(); [EOL]     if (verifyProvide(t, left, arg)) { [EOL]         String ns = arg.getString(); [EOL]         maybeAddToSymbolTable(left); [EOL]         maybeAddStringNodeToSymbolTable(arg); [EOL]         if (providedNames.containsKey(ns)) { [EOL]             ProvidedName previouslyProvided = providedNames.get(ns); [EOL]             if (!previouslyProvided.isExplicitlyProvided()) { [EOL]                 previouslyProvided.addProvide(parent, t.getModule(), true); [EOL]             } else { [EOL]                 compiler.report(t.makeError(n, DUPLICATE_NAMESPACE_ERROR, ns)); [EOL]             } [EOL]         } else { [EOL]             registerAnyProvidedPrefixes(ns, parent, t.getModule()); [EOL]             providedNames.put(ns, new ProvidedName(ns, parent, t.getModule(), true)); [EOL]         } [EOL]     } [EOL] } <line_num>: 309,332
private void handleTypedefDefinition(NodeTraversal t, Node n, Node parent) { [EOL]     JSDocInfo info = n.getFirstChild().getJSDocInfo(); [EOL]     if (t.inGlobalScope() && info != null && info.hasTypedefType()) { [EOL]         String name = n.getFirstChild().getQualifiedName(); [EOL]         if (name != null) { [EOL]             ProvidedName pn = providedNames.get(name); [EOL]             if (pn != null) { [EOL]                 pn.addDefinition(n, t.getModule()); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 338,350
private void handleCandidateProvideDefinition(NodeTraversal t, Node n, Node parent) { [EOL]     if (t.inGlobalScope()) { [EOL]         String name = null; [EOL]         if (n.isName() && parent.isVar()) { [EOL]             name = n.getString(); [EOL]         } else if (n.isAssign() && parent.isExprResult()) { [EOL]             name = n.getFirstChild().getQualifiedName(); [EOL]         } [EOL]         if (name != null) { [EOL]             if (parent.getBooleanProp(Node.IS_NAMESPACE)) { [EOL]                 processProvideFromPreviousPass(t, name, parent); [EOL]             } else { [EOL]                 ProvidedName pn = providedNames.get(name); [EOL]                 if (pn != null) { [EOL]                     pn.addDefinition(parent, t.getModule()); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 355,377
private void processBaseClassCall(NodeTraversal t, Node n) { [EOL]     Node callee = n.getFirstChild(); [EOL]     Node thisArg = callee.getNext(); [EOL]     if (thisArg == null || !thisArg.isThis()) { [EOL]         reportBadBaseClassUse(t, n, "First argument must be 'this'."); [EOL]         return; [EOL]     } [EOL]     Node enclosingFnNameNode = getEnclosingDeclNameNode(t); [EOL]     if (enclosingFnNameNode == null) { [EOL]         reportBadBaseClassUse(t, n, "Could not find enclosing method."); [EOL]         return; [EOL]     } [EOL]     String enclosingQname = enclosingFnNameNode.getQualifiedName(); [EOL]     if (enclosingQname.indexOf(".prototype.") == -1) { [EOL]         Node enclosingParent = enclosingFnNameNode.getParent(); [EOL]         Node maybeInheritsExpr = (enclosingParent.isAssign() ? enclosingParent.getParent() : enclosingParent).getNext(); [EOL]         Node baseClassNode = null; [EOL]         if (maybeInheritsExpr != null && maybeInheritsExpr.isExprResult() && maybeInheritsExpr.getFirstChild().isCall()) { [EOL]             Node callNode = maybeInheritsExpr.getFirstChild(); [EOL]             if ("goog.inherits".equals(callNode.getFirstChild().getQualifiedName()) && callNode.getLastChild().isQualifiedName()) { [EOL]                 baseClassNode = callNode.getLastChild(); [EOL]             } [EOL]         } [EOL]         if (baseClassNode == null) { [EOL]             reportBadBaseClassUse(t, n, "Could not find goog.inherits for base class"); [EOL]             return; [EOL]         } [EOL]         n.replaceChild(callee, NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), String.format("%s.call", baseClassNode.getQualifiedName()), callee, "goog.base")); [EOL]         compiler.reportCodeChange(); [EOL]     } else { [EOL]         Node methodNameNode = thisArg.getNext(); [EOL]         if (methodNameNode == null || !methodNameNode.isString()) { [EOL]             reportBadBaseClassUse(t, n, "Second argument must name a method."); [EOL]             return; [EOL]         } [EOL]         String methodName = methodNameNode.getString(); [EOL]         String ending = ".prototype." + methodName; [EOL]         if (enclosingQname == null || !enclosingQname.endsWith(ending)) { [EOL]             reportBadBaseClassUse(t, n, "Enclosing method does not match " + methodName); [EOL]             return; [EOL]         } [EOL]         Node className = enclosingFnNameNode.getFirstChild().getFirstChild(); [EOL]         n.replaceChild(callee, NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), String.format("%s.superClass_.%s.call", className.getQualifiedName(), methodName), callee, "goog.base")); [EOL]         n.removeChild(methodNameNode); [EOL]         compiler.reportCodeChange(); [EOL]     } [EOL] } <line_num>: 382,485
private Node getEnclosingDeclNameNode(NodeTraversal t) { [EOL]     Node scopeRoot = t.getScopeRoot(); [EOL]     if (NodeUtil.isFunctionDeclaration(scopeRoot)) { [EOL]         return scopeRoot.getFirstChild(); [EOL]     } else { [EOL]         Node parent = scopeRoot.getParent(); [EOL]         if (parent != null) { [EOL]             if (parent.isAssign() || parent.getLastChild() == scopeRoot && parent.getFirstChild().isQualifiedName()) { [EOL]                 return parent.getFirstChild(); [EOL]             } else if (parent.isName()) { [EOL]                 return parent; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 491,512
private void reportBadBaseClassUse(NodeTraversal t, Node n, String extraMessage) { [EOL]     compiler.report(t.makeError(n, BASE_CLASS_ERROR, extraMessage)); [EOL] } <line_num>: 515,518
private void processProvideFromPreviousPass(NodeTraversal t, String name, Node parent) { [EOL]     if (!providedNames.containsKey(name)) { [EOL]         Node expr = new Node(Token.EXPR_RESULT); [EOL]         expr.copyInformationFromForTree(parent); [EOL]         parent.getParent().addChildBefore(expr, parent); [EOL]         compiler.reportCodeChange(); [EOL]         JSModule module = t.getModule(); [EOL]         registerAnyProvidedPrefixes(name, expr, module); [EOL]         ProvidedName provided = new ProvidedName(name, expr, module, true); [EOL]         providedNames.put(name, provided); [EOL]         provided.addDefinition(parent, module); [EOL]     } else { [EOL]         if (isNamespacePlaceholder(parent)) { [EOL]             parent.getParent().removeChild(parent); [EOL]             compiler.reportCodeChange(); [EOL]         } [EOL]     } [EOL] } <line_num>: 525,549
@Override [EOL] public String get(String value) { [EOL]     if (cssNames.containsKey(value)) { [EOL]         return cssNames.get(value); [EOL]     } else { [EOL]         return value; [EOL]     } [EOL] } <line_num>: 630,637
@Override [EOL] public CssRenamingMap.Style getStyle() { [EOL]     return style; [EOL] } <line_num>: 639,642
private void processSetCssNameMapping(NodeTraversal t, Node n, Node parent) { [EOL]     Node left = n.getFirstChild(); [EOL]     Node arg = left.getNext(); [EOL]     if (verifySetCssNameMapping(t, left, arg)) { [EOL]         final Map<String, String> cssNames = Maps.newHashMap(); [EOL]         for (Node key = arg.getFirstChild(); key != null; key = key.getNext()) { [EOL]             Node value = key.getFirstChild(); [EOL]             if (!key.isStringKey() || value == null || !value.isString()) { [EOL]                 compiler.report(t.makeError(n, NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR)); [EOL]                 return; [EOL]             } [EOL]             cssNames.put(key.getString(), value.getString()); [EOL]         } [EOL]         String styleStr = "BY_PART"; [EOL]         if (arg.getNext() != null) { [EOL]             styleStr = arg.getNext().getString(); [EOL]         } [EOL]         final CssRenamingMap.Style style; [EOL]         try { [EOL]             style = CssRenamingMap.Style.valueOf(styleStr); [EOL]         } catch (IllegalArgumentException e) { [EOL]             compiler.report(t.makeError(n, INVALID_STYLE_ERROR, styleStr)); [EOL]             return; [EOL]         } [EOL]         if (style == CssRenamingMap.Style.BY_PART) { [EOL]             List<String> errors = Lists.newArrayList(); [EOL]             for (String key : cssNames.keySet()) { [EOL]                 if (key.contains("-")) { [EOL]                     errors.add(key); [EOL]                 } [EOL]             } [EOL]             if (errors.size() != 0) { [EOL]                 compiler.report(t.makeError(n, INVALID_CSS_RENAMING_MAP, errors.toString())); [EOL]             } [EOL]         } else if (style == CssRenamingMap.Style.BY_WHOLE) { [EOL]             List<String> errors = Lists.newArrayList(); [EOL]             for (Map.Entry<String, String> b : cssNames.entrySet()) { [EOL]                 if (b.getKey().length() > 10) [EOL]                     continue; [EOL]                 for (Map.Entry<String, String> a : cssNames.entrySet()) { [EOL]                     String combined = cssNames.get(a.getKey() + "-" + b.getKey()); [EOL]                     if (combined != null && !combined.equals(a.getValue() + "-" + b.getValue())) { [EOL]                         errors.add("map(" + a.getKey() + "-" + b.getKey() + ") != map(" + a.getKey() + ")-map(" + b.getKey() + ")"); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (errors.size() != 0) { [EOL]                 compiler.report(t.makeError(n, INVALID_CSS_RENAMING_MAP, errors.toString())); [EOL]             } [EOL]         } [EOL]         CssRenamingMap cssRenamingMap = new CssRenamingMap() { [EOL]  [EOL]             @Override [EOL]             public String get(String value) { [EOL]                 if (cssNames.containsKey(value)) { [EOL]                     return cssNames.get(value); [EOL]                 } else { [EOL]                     return value; [EOL]                 } [EOL]             } [EOL]  [EOL]             @Override [EOL]             public CssRenamingMap.Style getStyle() { [EOL]                 return style; [EOL]             } [EOL]         }; [EOL]         compiler.setCssRenamingMap(cssRenamingMap); [EOL]         parent.getParent().removeChild(parent); [EOL]         compiler.reportCodeChange(); [EOL]     } [EOL] } <line_num>: 558,648
private boolean verifyProvide(NodeTraversal t, Node methodName, Node arg) { [EOL]     if (!verifyArgument(t, methodName, arg)) { [EOL]         return false; [EOL]     } [EOL]     for (String part : arg.getString().split("\\.")) { [EOL]         if (!NodeUtil.isValidPropertyName(part)) { [EOL]             compiler.report(t.makeError(arg, INVALID_PROVIDE_ERROR, part)); [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 657,669
private boolean verifyArgument(NodeTraversal t, Node methodName, Node arg) { [EOL]     return verifyArgument(t, methodName, arg, Token.STRING); [EOL] } <line_num>: 677,679
private boolean verifyArgument(NodeTraversal t, Node methodName, Node arg, int desiredType) { [EOL]     DiagnosticType diagnostic = null; [EOL]     if (arg == null) { [EOL]         diagnostic = NULL_ARGUMENT_ERROR; [EOL]     } else if (arg.getType() != desiredType) { [EOL]         diagnostic = INVALID_ARGUMENT_ERROR; [EOL]     } else if (arg.getNext() != null) { [EOL]         diagnostic = TOO_MANY_ARGUMENTS_ERROR; [EOL]     } [EOL]     if (diagnostic != null) { [EOL]         compiler.report(t.makeError(methodName, diagnostic, methodName.getQualifiedName())); [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } <line_num>: 687,704
private boolean verifySetCssNameMapping(NodeTraversal t, Node methodName, Node firstArg) { [EOL]     DiagnosticType diagnostic = null; [EOL]     if (firstArg == null) { [EOL]         diagnostic = NULL_ARGUMENT_ERROR; [EOL]     } else if (!firstArg.isObjectLit()) { [EOL]         diagnostic = EXPECTED_OBJECTLIT_ERROR; [EOL]     } else if (firstArg.getNext() != null) { [EOL]         Node secondArg = firstArg.getNext(); [EOL]         if (!secondArg.isString()) { [EOL]             diagnostic = EXPECTED_STRING_ERROR; [EOL]         } else if (secondArg.getNext() != null) { [EOL]             diagnostic = TOO_MANY_ARGUMENTS_ERROR; [EOL]         } [EOL]     } [EOL]     if (diagnostic != null) { [EOL]         compiler.report(t.makeError(methodName, diagnostic, methodName.getQualifiedName())); [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } <line_num>: 711,733
private void registerAnyProvidedPrefixes(String ns, Node node, JSModule module) { [EOL]     int pos = ns.indexOf('.'); [EOL]     while (pos != -1) { [EOL]         String prefixNs = ns.substring(0, pos); [EOL]         pos = ns.indexOf('.', pos + 1); [EOL]         if (providedNames.containsKey(prefixNs)) { [EOL]             providedNames.get(prefixNs).addProvide(node, module, false); [EOL]         } else { [EOL]             providedNames.put(prefixNs, new ProvidedName(prefixNs, node, module, false)); [EOL]         } [EOL]     } [EOL] } <line_num>: 744,759
void addProvide(Node node, JSModule module, boolean explicit) { [EOL]     if (explicit) { [EOL]         Preconditions.checkState(explicitNode == null); [EOL]         Preconditions.checkArgument(node.isExprResult()); [EOL]         explicitNode = node; [EOL]         explicitModule = module; [EOL]     } [EOL]     updateMinimumModule(module); [EOL] } <line_num>: 803,811
boolean isExplicitlyProvided() { [EOL]     return explicitNode != null; [EOL] } <line_num>: 813,815
void addDefinition(Node node, JSModule module) { [EOL]     Preconditions.checkArgument(node.isExprResult() || node.isFunction() || node.isVar()); [EOL]     Preconditions.checkArgument(explicitNode != node); [EOL]     if ((candidateDefinition == null) || !node.isExprResult()) { [EOL]         candidateDefinition = node; [EOL]         updateMinimumModule(module); [EOL]     } [EOL] } <line_num>: 823,832
private void updateMinimumModule(JSModule newModule) { [EOL]     if (minimumModule == null) { [EOL]         minimumModule = newModule; [EOL]     } else if (moduleGraph != null) { [EOL]         minimumModule = moduleGraph.getDeepestCommonDependencyInclusive(minimumModule, newModule); [EOL]     } else { [EOL]         Preconditions.checkState(newModule == minimumModule, "Missing module graph"); [EOL]     } [EOL] } <line_num>: 834,846
void replace() { [EOL]     if (firstNode == null) { [EOL]         replacementNode = candidateDefinition; [EOL]         return; [EOL]     } [EOL]     if (candidateDefinition != null && explicitNode != null) { [EOL]         explicitNode.detachFromParent(); [EOL]         compiler.reportCodeChange(); [EOL]         replacementNode = candidateDefinition; [EOL]         if (candidateDefinition.isExprResult() && !candidateDefinition.getFirstChild().isQualifiedName()) { [EOL]             candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true); [EOL]             Node assignNode = candidateDefinition.getFirstChild(); [EOL]             Node nameNode = assignNode.getFirstChild(); [EOL]             if (nameNode.isName()) { [EOL]                 Node valueNode = nameNode.getNext(); [EOL]                 assignNode.removeChild(nameNode); [EOL]                 assignNode.removeChild(valueNode); [EOL]                 nameNode.addChildToFront(valueNode); [EOL]                 Node varNode = IR.var(nameNode); [EOL]                 varNode.copyInformationFrom(candidateDefinition); [EOL]                 candidateDefinition.getParent().replaceChild(candidateDefinition, varNode); [EOL]                 nameNode.setJSDocInfo(assignNode.getJSDocInfo()); [EOL]                 compiler.reportCodeChange(); [EOL]                 replacementNode = varNode; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         replacementNode = createDeclarationNode(); [EOL]         if (firstModule == minimumModule) { [EOL]             firstNode.getParent().addChildBefore(replacementNode, firstNode); [EOL]         } else { [EOL]             int indexOfDot = namespace.lastIndexOf('.'); [EOL]             if (indexOfDot == -1) { [EOL]                 compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode); [EOL]             } else { [EOL]                 ProvidedName parentName = providedNames.get(namespace.substring(0, indexOfDot)); [EOL]                 Preconditions.checkNotNull(parentName); [EOL]                 Preconditions.checkNotNull(parentName.replacementNode); [EOL]                 parentName.replacementNode.getParent().addChildAfter(replacementNode, parentName.replacementNode); [EOL]             } [EOL]         } [EOL]         if (explicitNode != null) { [EOL]             explicitNode.detachFromParent(); [EOL]         } [EOL]         compiler.reportCodeChange(); [EOL]     } [EOL] } <line_num>: 855,918
private Node createDeclarationNode() { [EOL]     if (namespace.indexOf('.') == -1) { [EOL]         return makeVarDeclNode(); [EOL]     } else { [EOL]         return makeAssignmentExprNode(); [EOL]     } [EOL] } <line_num>: 924,930
private Node makeVarDeclNode() { [EOL]     Node name = IR.name(namespace); [EOL]     name.addChildToFront(createNamespaceLiteral()); [EOL]     Node decl = IR.var(name); [EOL]     decl.putBooleanProp(Node.IS_NAMESPACE, true); [EOL]     if (compiler.getCodingConvention().isConstant(namespace)) { [EOL]         name.putBooleanProp(Node.IS_CONSTANT_NAME, true); [EOL]     } [EOL]     if (candidateDefinition == null) { [EOL]         name.setJSDocInfo(createConstantJsDoc()); [EOL]     } [EOL]     Preconditions.checkState(isNamespacePlaceholder(decl)); [EOL]     setSourceInfo(decl); [EOL]     return decl; [EOL] } <line_num>: 936,954
private Node createNamespaceLiteral() { [EOL]     Node objlit = IR.objectlit(); [EOL]     objlit.setJSType(compiler.getTypeRegistry().createAnonymousObjectType(null)); [EOL]     return objlit; [EOL] } <line_num>: 961,966
private Node makeAssignmentExprNode() { [EOL]     Node decl = IR.exprResult(IR.assign(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), namespace, firstNode, namespace), createNamespaceLiteral())); [EOL]     decl.putBooleanProp(Node.IS_NAMESPACE, true); [EOL]     if (candidateDefinition == null) { [EOL]         decl.getFirstChild().setJSDocInfo(createConstantJsDoc()); [EOL]     } [EOL]     Preconditions.checkState(isNamespacePlaceholder(decl)); [EOL]     setSourceInfo(decl); [EOL]     return decl; [EOL] } <line_num>: 972,987
private JSDocInfo createConstantJsDoc() { [EOL]     JSDocInfoBuilder builder = new JSDocInfoBuilder(false); [EOL]     builder.recordConstancy(); [EOL]     return builder.build(null); [EOL] } <line_num>: 989,993
private void setSourceInfo(Node newNode) { [EOL]     Node provideStringNode = getProvideStringNode(); [EOL]     int offset = getSourceInfoOffset(provideStringNode); [EOL]     Node sourceInfoNode = provideStringNode == null ? firstNode : provideStringNode; [EOL]     newNode.copyInformationFromForTree(sourceInfoNode); [EOL]     if (offset != 0) { [EOL]         newNode.setSourceEncodedPositionForTree(sourceInfoNode.getSourcePosition() + offset); [EOL]     } [EOL] } <line_num>: 998,1008
private int getSourceInfoOffset(Node provideStringNode) { [EOL]     if (provideStringNode == null) { [EOL]         return 0; [EOL]     } [EOL]     int indexOfLastDot = namespace.lastIndexOf('.'); [EOL]     return 2 + indexOfLastDot; [EOL] } <line_num>: 1013,1025
private Node getProvideStringNode() { [EOL]     return (firstNode.getFirstChild() != null && NodeUtil.isExprCall(firstNode)) ? firstNode.getFirstChild().getLastChild() : null; [EOL] } <line_num>: 1027,1032
private static boolean isNamespacePlaceholder(Node n) { [EOL]     if (!n.getBooleanProp(Node.IS_NAMESPACE)) { [EOL]         return false; [EOL]     } [EOL]     Node value = null; [EOL]     if (n.isExprResult()) { [EOL]         Node assign = n.getFirstChild(); [EOL]         value = assign.getLastChild(); [EOL]     } else if (n.isVar()) { [EOL]         Node name = n.getFirstChild(); [EOL]         value = name.getFirstChild(); [EOL]     } [EOL]     return value != null && value.isObjectLit() && !value.hasChildren(); [EOL] } <line_num>: 1038,1055
private void maybeAddStringNodeToSymbolTable(Node n) { [EOL]     if (preprocessorSymbolTable == null) { [EOL]         return; [EOL]     } [EOL]     String name = n.getString(); [EOL]     Node syntheticRef = NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), name, n, name); [EOL]     final int FOR_QUOTE = 1; [EOL]     final int FOR_DOT = 1; [EOL]     Node current = null; [EOL]     for (current = syntheticRef; current.isGetProp(); current = current.getFirstChild()) { [EOL]         int fullLen = current.getQualifiedName().length(); [EOL]         int namespaceLen = current.getFirstChild().getQualifiedName().length(); [EOL]         current.setSourceEncodedPosition(n.getSourcePosition() + FOR_QUOTE); [EOL]         current.setLength(fullLen); [EOL]         current.getLastChild().setSourceEncodedPosition(n.getSourcePosition() + namespaceLen + FOR_QUOTE + FOR_DOT); [EOL]         current.getLastChild().setLength(current.getLastChild().getString().length()); [EOL]     } [EOL]     current.setSourceEncodedPosition(n.getSourcePosition() + FOR_QUOTE); [EOL]     current.setLength(current.getString().length()); [EOL]     maybeAddToSymbolTable(syntheticRef); [EOL] } <line_num>: 1062,1097
private void maybeAddToSymbolTable(Node n) { [EOL]     if (preprocessorSymbolTable != null) { [EOL]         preprocessorSymbolTable.addReference(n); [EOL]     } [EOL] } <line_num>: 1102,1106
