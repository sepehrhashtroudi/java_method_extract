CheckMissingReturn(AbstractCompiler compiler, CheckLevel level) { [EOL]     this.compiler = compiler; [EOL]     this.level = level; [EOL] } <line_num>: 86,89
@Override [EOL] public boolean apply(Node input) { [EOL]     return input != null && input.isReturn(); [EOL] } <line_num>: 46,51
@Override [EOL] public boolean apply(DiGraphEdge<Node, ControlFlowGraph.Branch> input) { [EOL]     Branch branch = input.getValue(); [EOL]     if (branch == Branch.ON_EX) { [EOL]         return false; [EOL]     } else if (branch.isConditional()) { [EOL]         Node condition = NodeUtil.getConditionExpression(input.getSource().getValue()); [EOL]         if (condition != null) { [EOL]             TernaryValue val = NodeUtil.getImpureBooleanValue(condition); [EOL]             if (val != TernaryValue.UNKNOWN) { [EOL]                 return val.toBoolean(true) == (Branch.ON_TRUE == branch); [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 58,79
@Override [EOL] public void enterScope(NodeTraversal t) { [EOL]     JSType returnType = explicitReturnExpected(t.getScopeRoot()); [EOL]     if (returnType == null) { [EOL]         return; [EOL]     } [EOL]     if (fastAllPathsReturnCheck(t.getControlFlowGraph())) { [EOL]         return; [EOL]     } [EOL]     CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> test = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(t.getControlFlowGraph(), t.getControlFlowGraph().getEntry(), t.getControlFlowGraph().getImplicitReturn(), IS_RETURN, GOES_THROUGH_TRUE_CONDITION_PREDICATE); [EOL]     if (!test.allPathsSatisfyPredicate()) { [EOL]         compiler.report(t.makeError(t.getScopeRoot(), level, MISSING_RETURN_STATEMENT, returnType.toString())); [EOL]     } [EOL] } <line_num>: 91,114
private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg) { [EOL]     for (DiGraphEdge<Node, Branch> s : cfg.getImplicitReturn().getInEdges()) { [EOL]         if (!s.getSource().getValue().isReturn()) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 122,129
@Override [EOL] public void exitScope(NodeTraversal t) { [EOL] } <line_num>: 131,133
@Override [EOL] public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) { [EOL]     return true; [EOL] } <line_num>: 135,139
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL] } <line_num>: 141,143
private JSType explicitReturnExpected(Node scope) { [EOL]     FunctionType scopeType = JSType.toMaybeFunctionType(scope.getJSType()); [EOL]     if (scopeType == null) { [EOL]         return null; [EOL]     } [EOL]     if (isEmptyFunction(scope)) { [EOL]         return null; [EOL]     } [EOL]     JSType returnType = scopeType.getReturnType(); [EOL]     if (returnType == null) { [EOL]         return null; [EOL]     } [EOL]     if (!isVoidOrUnknown(returnType)) { [EOL]         return returnType; [EOL]     } [EOL]     return null; [EOL] } <line_num>: 150,172
private static boolean isEmptyFunction(Node function) { [EOL]     return function.getChildCount() == 3 && !function.getFirstChild().getNext().getNext().hasChildren(); [EOL] } <line_num>: 179,182
private boolean isVoidOrUnknown(JSType returnType) { [EOL]     final JSType voidType = compiler.getTypeRegistry().getNativeType(JSTypeNative.VOID_TYPE); [EOL]     return voidType.isSubtype(returnType); [EOL] } <line_num>: 188,192
