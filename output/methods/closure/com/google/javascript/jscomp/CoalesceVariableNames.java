CoalesceVariableNames(AbstractCompiler compiler, boolean usePseudoNames) { [EOL]     Preconditions.checkState(!compiler.getLifeCycleStage().isNormalized()); [EOL]     this.compiler = compiler; [EOL]     colorings = Lists.newLinkedList(); [EOL]     this.usePseudoNames = usePseudoNames; [EOL] } <line_num>: 78,84
CombinedLiveRangeChecker(LiveRangeChecker callback1, LiveRangeChecker callback2) { [EOL]     this.callback1 = callback1; [EOL]     this.callback2 = callback2; [EOL] } <line_num>: 318,323
public LiveRangeChecker(Var def, Var use) { [EOL]     this.def = def; [EOL]     this.use = use; [EOL] } <line_num>: 389,392
@Override [EOL] public int compare(Var v1, Var v2) { [EOL]     return v1.index - v2.index; [EOL] } <line_num>: 68,71
@Override [EOL] public void process(Node externs, Node root) { [EOL]     NodeTraversal.traverse(compiler, root, this); [EOL] } <line_num>: 86,89
private static boolean shouldOptimizeScope(Scope scope) { [EOL]     if (scope.isGlobal()) { [EOL]         return false; [EOL]     } [EOL]     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < scope.getVarCount()) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } <line_num>: 91,106
@Override [EOL] public void enterScope(NodeTraversal t) { [EOL]     Scope scope = t.getScope(); [EOL]     if (!shouldOptimizeScope(scope)) { [EOL]         return; [EOL]     } [EOL]     ControlFlowGraph<Node> cfg = t.getControlFlowGraph(); [EOL]     LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler); [EOL]     if (scope.getRootNode().getFirstChild().getNext().getChildCount() == 2) { [EOL]         liveness.markAllParametersEscaped(); [EOL]     } [EOL]     liveness.analyze(); [EOL]     UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals()); [EOL]     GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker); [EOL]     coloring.color(); [EOL]     colorings.push(coloring); [EOL] } <line_num>: 108,137
@Override [EOL] public void exitScope(NodeTraversal t) { [EOL]     if (!shouldOptimizeScope(t.getScope())) { [EOL]         return; [EOL]     } [EOL]     colorings.pop(); [EOL] } <line_num>: 139,145
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (colorings.isEmpty() || !n.isName() || parent.isFunction()) { [EOL]         return; [EOL]     } [EOL]     Var var = t.getScope().getVar(n.getString()); [EOL]     GraphNode<Var, ?> vNode = colorings.peek().getGraph().getNode(var); [EOL]     if (vNode == null) { [EOL]         return; [EOL]     } [EOL]     Var coalescedVar = colorings.peek().getPartitionSuperNode(var); [EOL]     if (!usePseudoNames) { [EOL]         if (vNode.getValue().equals(coalescedVar)) { [EOL]             return; [EOL]         } [EOL]         n.setString(coalescedVar.name); [EOL]         compiler.reportCodeChange(); [EOL]         if (parent.isVar()) { [EOL]             removeVarDeclaration(n); [EOL]         } [EOL]     } else { [EOL]         String pseudoName = null; [EOL]         Set<String> allMergedNames = Sets.newTreeSet(); [EOL]         for (Iterator<Var> i = t.getScope().getVars(); i.hasNext(); ) { [EOL]             Var iVar = i.next(); [EOL]             if (colorings.peek().getGraph().getNode(iVar) != null && coalescedVar.equals(colorings.peek().getPartitionSuperNode(iVar))) { [EOL]                 allMergedNames.add(iVar.name); [EOL]             } [EOL]         } [EOL]         if (allMergedNames.size() == 1) { [EOL]             return; [EOL]         } [EOL]         pseudoName = Joiner.on("_").join(allMergedNames); [EOL]         while (t.getScope().isDeclared(pseudoName, true)) { [EOL]             pseudoName += "$"; [EOL]         } [EOL]         n.setString(pseudoName); [EOL]         compiler.reportCodeChange(); [EOL]         if (!vNode.getValue().equals(coalescedVar) && parent.isVar()) { [EOL]             removeVarDeclaration(n); [EOL]         } [EOL]     } [EOL] } <line_num>: 147,210
private UndiGraph<Var, Void> computeVariableNamesInterferenceGraph(NodeTraversal t, ControlFlowGraph<Node> cfg, Set<Var> escaped) { [EOL]     UndiGraph<Var, Void> interferenceGraph = LinkedUndirectedGraph.create(); [EOL]     Scope scope = t.getScope(); [EOL]     for (Iterator<Var> i = scope.getVars(); i.hasNext(); ) { [EOL]         Var v = i.next(); [EOL]         if (!escaped.contains(v)) { [EOL]             if (!v.getParentNode().isFunction()) { [EOL]                 interferenceGraph.createNode(v); [EOL]             } [EOL]         } [EOL]     } [EOL]     for (Iterator<Var> i1 = scope.getVars(); i1.hasNext(); ) { [EOL]         Var v1 = i1.next(); [EOL]         NEXT_VAR_PAIR: for (Iterator<Var> i2 = scope.getVars(); i2.hasNext(); ) { [EOL]             Var v2 = i2.next(); [EOL]             if (v1.index >= v2.index) { [EOL]                 continue; [EOL]             } [EOL]             if (!interferenceGraph.hasNode(v1) || !interferenceGraph.hasNode(v2)) { [EOL]                 continue NEXT_VAR_PAIR; [EOL]             } [EOL]             if (v1.getParentNode().isParamList() && v2.getParentNode().isParamList()) { [EOL]                 interferenceGraph.connectIfNotFound(v1, null, v2); [EOL]                 continue NEXT_VAR_PAIR; [EOL]             } [EOL]             NEXT_CROSS_CFG_NODE: for (DiGraphNode<Node, Branch> cfgNode : cfg.getDirectedGraphNodes()) { [EOL]                 if (cfg.isImplicitReturn(cfgNode)) { [EOL]                     continue NEXT_CROSS_CFG_NODE; [EOL]                 } [EOL]                 FlowState<LiveVariableLattice> state = cfgNode.getAnnotation(); [EOL]                 if ((state.getIn().isLive(v1) && state.getIn().isLive(v2)) || (state.getOut().isLive(v1) && state.getOut().isLive(v2))) { [EOL]                     interferenceGraph.connectIfNotFound(v1, null, v2); [EOL]                     continue NEXT_VAR_PAIR; [EOL]                 } [EOL]             } [EOL]             NEXT_INTRA_CFG_NODE: for (DiGraphNode<Node, Branch> cfgNode : cfg.getDirectedGraphNodes()) { [EOL]                 if (cfg.isImplicitReturn(cfgNode)) { [EOL]                     continue NEXT_INTRA_CFG_NODE; [EOL]                 } [EOL]                 FlowState<LiveVariableLattice> state = cfgNode.getAnnotation(); [EOL]                 boolean v1OutLive = state.getOut().isLive(v1); [EOL]                 boolean v2OutLive = state.getOut().isLive(v2); [EOL]                 CombinedLiveRangeChecker checker = new CombinedLiveRangeChecker(new LiveRangeChecker(v1, v2OutLive ? null : v2), new LiveRangeChecker(v2, v1OutLive ? null : v1)); [EOL]                 NodeTraversal.traverse(compiler, cfgNode.getValue(), checker); [EOL]                 if (checker.connectIfCrossed(interferenceGraph)) { [EOL]                     continue NEXT_VAR_PAIR; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return interferenceGraph; [EOL] } <line_num>: 212,305
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (LiveRangeChecker.shouldVisit(n)) { [EOL]         callback1.visit(t, n, parent); [EOL]         callback2.visit(t, n, parent); [EOL]     } [EOL] } <line_num>: 325,331
boolean connectIfCrossed(UndiGraph<Var, Void> interferenceGraph) { [EOL]     if (callback1.crossed || callback2.crossed) { [EOL]         Var v1 = callback1.getDef(); [EOL]         Var v2 = callback2.getDef(); [EOL]         interferenceGraph.connectIfNotFound(v1, null, v2); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 333,341
private void removeVarDeclaration(Node name) { [EOL]     Node var = name.getParent(); [EOL]     Node parent = var.getParent(); [EOL]     if (NodeUtil.isForIn(parent)) { [EOL]         var.removeChild(name); [EOL]         parent.replaceChild(var, name); [EOL]     } else if (var.hasOneChild()) { [EOL]         if (name.hasChildren()) { [EOL]             Node value = name.removeFirstChild(); [EOL]             var.removeChild(name); [EOL]             Node assign = IR.assign(name, value).srcref(name); [EOL]             if (!parent.isFor()) { [EOL]                 assign = NodeUtil.newExpr(assign); [EOL]             } [EOL]             parent.replaceChild(var, assign); [EOL]         } else { [EOL]             NodeUtil.removeChild(parent, var); [EOL]         } [EOL]     } else { [EOL]         if (!name.hasChildren()) { [EOL]             var.removeChild(name); [EOL]         } [EOL]     } [EOL] } <line_num>: 348,380
Var getDef() { [EOL]     return def; [EOL] } <line_num>: 394,396
public static boolean shouldVisit(Node n) { [EOL]     return (n.isName() || (n.hasChildren() && n.getFirstChild().isName())); [EOL] } <line_num>: 401,404
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (!defFound && isAssignTo(def, n, parent)) { [EOL]         defFound = true; [EOL]     } [EOL]     if (defFound && (use == null || isReadFrom(use, n))) { [EOL]         crossed = true; [EOL]     } [EOL] } <line_num>: 406,415
private static boolean isAssignTo(Var var, Node n, Node parent) { [EOL]     if (n.isName() && var.getName().equals(n.getString()) && parent != null) { [EOL]         if (parent.isParamList()) { [EOL]             return true; [EOL]         } else if (parent.isVar()) { [EOL]             return n.hasChildren(); [EOL]         } [EOL]         return false; [EOL]     } else { [EOL]         Node name = n.getFirstChild(); [EOL]         return name != null && name.isName() && var.getName().equals(name.getString()) && NodeUtil.isAssignmentOp(n); [EOL]     } [EOL] } <line_num>: 417,436
private static boolean isReadFrom(Var var, Node name) { [EOL]     return name != null && name.isName() && var.getName().equals(name.getString()) && !NodeUtil.isVarOrSimpleAssignLhs(name, name.getParent()); [EOL] } <line_num>: 438,442
