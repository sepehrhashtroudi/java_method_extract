@Override [EOL] Node optimizeSubtree(Node subtree) { [EOL]     switch(subtree.getType()) { [EOL]         case Token.TYPEOF: [EOL]             return tryFoldTypeof(subtree); [EOL]         default: [EOL]             return subtree; [EOL]     } [EOL] } <line_num>: 44,52
private Node tryFoldTypeof(Node typeofNode) { [EOL]     Preconditions.checkArgument(typeofNode.isTypeOf()); [EOL]     Preconditions.checkArgument(typeofNode.getFirstChild() != null); [EOL]     Node argumentNode = typeofNode.getFirstChild(); [EOL]     if (!NodeUtil.isLiteralValue(argumentNode, true) && !mayHaveSideEffects(argumentNode)) { [EOL]         JSType argumentType = argumentNode.getJSType(); [EOL]         String typeName = null; [EOL]         if (argumentType != null) { [EOL]             if (argumentType.isObject() || argumentType.isNullType()) { [EOL]                 typeName = "object"; [EOL]             } else if (argumentType.isStringValueType()) { [EOL]                 typeName = "string"; [EOL]             } else if (argumentType.isNumberValueType()) { [EOL]                 typeName = "number"; [EOL]             } else if (argumentType.isBooleanValueType()) { [EOL]                 typeName = "boolean"; [EOL]             } else if (argumentType.isVoidType()) { [EOL]                 typeName = "undefined"; [EOL]             } else if (argumentType.isUnionType()) { [EOL]                 typeName = null; [EOL]             } [EOL]             if (typeName != null) { [EOL]                 Node newNode = IR.string(typeName); [EOL]                 typeofNode.getParent().replaceChild(typeofNode, newNode); [EOL]                 reportCodeChange(); [EOL]                 return newNode; [EOL]             } [EOL]         } [EOL]     } [EOL]     return typeofNode; [EOL] } <line_num>: 74,117
