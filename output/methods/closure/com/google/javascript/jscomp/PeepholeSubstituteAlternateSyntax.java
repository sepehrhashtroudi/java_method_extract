PeepholeSubstituteAlternateSyntax(boolean late) { [EOL]     this.late = late; [EOL] } <line_num>: 71,73
@Override [EOL] public boolean apply(Node input) { [EOL]     return !input.isFunction(); [EOL] } <line_num>: 58,61
@Override [EOL] @SuppressWarnings("fallthrough") [EOL] public Node optimizeSubtree(Node node) { [EOL]     switch(node.getType()) { [EOL]         case Token.RETURN: [EOL]             { [EOL]                 Node result = tryRemoveRedundantExit(node); [EOL]                 if (result != node) { [EOL]                     return result; [EOL]                 } [EOL]                 result = tryReplaceExitWithBreak(node); [EOL]                 if (result != node) { [EOL]                     return result; [EOL]                 } [EOL]                 return tryReduceReturn(node); [EOL]             } [EOL]         case Token.THROW: [EOL]             { [EOL]                 Node result = tryRemoveRedundantExit(node); [EOL]                 if (result != node) { [EOL]                     return result; [EOL]                 } [EOL]                 return tryReplaceExitWithBreak(node); [EOL]             } [EOL]         case Token.NOT: [EOL]             tryMinimizeCondition(node.getFirstChild()); [EOL]             return tryMinimizeNot(node); [EOL]         case Token.IF: [EOL]             tryMinimizeCondition(node.getFirstChild()); [EOL]             return tryMinimizeIf(node); [EOL]         case Token.EXPR_RESULT: [EOL]             tryMinimizeCondition(node.getFirstChild()); [EOL]             return node; [EOL]         case Token.HOOK: [EOL]             tryMinimizeCondition(node.getFirstChild()); [EOL]             return node; [EOL]         case Token.WHILE: [EOL]         case Token.DO: [EOL]             tryMinimizeCondition(NodeUtil.getConditionExpression(node)); [EOL]             return node; [EOL]         case Token.FOR: [EOL]             if (!NodeUtil.isForIn(node)) { [EOL]                 tryJoinForCondition(node); [EOL]                 tryMinimizeCondition(NodeUtil.getConditionExpression(node)); [EOL]             } [EOL]             return node; [EOL]         case Token.TRUE: [EOL]         case Token.FALSE: [EOL]             return reduceTrueFalse(node); [EOL]         case Token.NEW: [EOL]             node = tryFoldStandardConstructors(node); [EOL]             if (!node.isCall()) { [EOL]                 return node; [EOL]             } [EOL]         case Token.CALL: [EOL]             Node result = tryFoldLiteralConstructor(node); [EOL]             if (result == node) { [EOL]                 result = tryFoldSimpleFunctionCall(node); [EOL]                 if (result == node) { [EOL]                     result = tryFoldImmediateCallToBoundFunction(node); [EOL]                 } [EOL]             } [EOL]             return result; [EOL]         case Token.COMMA: [EOL]             return trySplitComma(node); [EOL]         case Token.NAME: [EOL]             return tryReplaceUndefined(node); [EOL]         case Token.BLOCK: [EOL]             return tryReplaceIf(node); [EOL]         case Token.ARRAYLIT: [EOL]             return tryMinimizeArrayLiteral(node); [EOL]         default: [EOL]             return node; [EOL]     } [EOL] } <line_num>: 78,169
private void tryJoinForCondition(Node n) { [EOL]     if (!late) { [EOL]         return; [EOL]     } [EOL]     Node block = n.getLastChild(); [EOL]     Node maybeIf = block.getFirstChild(); [EOL]     if (maybeIf != null && maybeIf.isIf()) { [EOL]         Node maybeBreak = maybeIf.getChildAtIndex(1).getFirstChild(); [EOL]         if (maybeBreak != null && maybeBreak.isBreak() && !maybeBreak.hasChildren()) { [EOL]             if (maybeIf.getChildCount() == 3) { [EOL]                 block.replaceChild(maybeIf, maybeIf.getLastChild().detachFromParent()); [EOL]             } else { [EOL]                 block.removeFirstChild(); [EOL]             } [EOL]             Node ifCondition = maybeIf.removeFirstChild(); [EOL]             Node fixedIfCondition = IR.not(ifCondition).srcref(ifCondition); [EOL]             Node forCondition = NodeUtil.getConditionExpression(n); [EOL]             if (forCondition.isEmpty()) { [EOL]                 n.replaceChild(forCondition, fixedIfCondition); [EOL]             } else { [EOL]                 Node replacement = new Node(Token.AND); [EOL]                 n.replaceChild(forCondition, replacement); [EOL]                 replacement.addChildToBack(forCondition); [EOL]                 replacement.addChildToBack(fixedIfCondition); [EOL]             } [EOL]             reportCodeChange(); [EOL]         } [EOL]     } [EOL] } <line_num>: 171,209
private Node tryFoldSimpleFunctionCall(Node n) { [EOL]     Preconditions.checkState(n.isCall()); [EOL]     Node callTarget = n.getFirstChild(); [EOL]     if (callTarget != null && callTarget.isName() && callTarget.getString().equals("String")) { [EOL]         Node value = callTarget.getNext(); [EOL]         if (value != null && value.getNext() == null && NodeUtil.isImmutableValue(value)) { [EOL]             Node addition = IR.add(IR.string("").srcref(callTarget), value.detachFromParent()); [EOL]             n.getParent().replaceChild(n, addition); [EOL]             reportCodeChange(); [EOL]             return addition; [EOL]         } [EOL]     } [EOL]     return n; [EOL] } <line_num>: 211,234
private Node tryFoldImmediateCallToBoundFunction(Node n) { [EOL]     Preconditions.checkState(n.isCall()); [EOL]     Node callTarget = n.getFirstChild(); [EOL]     Bind bind = getCodingConvention().describeFunctionBind(callTarget, false); [EOL]     if (bind != null) { [EOL]         bind.target.detachFromParent(); [EOL]         n.replaceChild(callTarget, bind.target); [EOL]         callTarget = bind.target; [EOL]         addParameterAfter(bind.parameters, callTarget); [EOL]         if (bind.thisValue != null && !NodeUtil.isUndefined(bind.thisValue)) { [EOL]             Node newCallTarget = IR.getprop(callTarget.cloneTree(), IR.string("call").srcref(callTarget)); [EOL]             n.replaceChild(callTarget, newCallTarget); [EOL]             n.addChildAfter(bind.thisValue.cloneTree(), newCallTarget); [EOL]             n.putBooleanProp(Node.FREE_CALL, false); [EOL]         } else { [EOL]             n.putBooleanProp(Node.FREE_CALL, true); [EOL]         } [EOL]         reportCodeChange(); [EOL]     } [EOL]     return n; [EOL] } <line_num>: 236,265
private void addParameterAfter(Node parameterList, Node after) { [EOL]     if (parameterList != null) { [EOL]         addParameterAfter(parameterList.getNext(), after); [EOL]         after.getParent().addChildAfter(parameterList.cloneTree(), after); [EOL]     } [EOL] } <line_num>: 267,273
private Node trySplitComma(Node n) { [EOL]     if (late) { [EOL]         return n; [EOL]     } [EOL]     Node parent = n.getParent(); [EOL]     Node left = n.getFirstChild(); [EOL]     Node right = n.getLastChild(); [EOL]     if (parent.isExprResult() && !parent.getParent().isLabel()) { [EOL]         n.detachChildren(); [EOL]         parent.replaceChild(n, left); [EOL]         Node newStatement = IR.exprResult(right); [EOL]         newStatement.copyInformationFrom(n); [EOL]         parent.getParent().addChildAfter(newStatement, parent); [EOL]         reportCodeChange(); [EOL]         return left; [EOL]     } else { [EOL]         return n; [EOL]     } [EOL] } <line_num>: 275,301
private Node tryReplaceIf(Node n) { [EOL]     for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { [EOL]         if (child.isIf()) { [EOL]             Node cond = child.getFirstChild(); [EOL]             Node thenBranch = cond.getNext(); [EOL]             Node elseBranch = thenBranch.getNext(); [EOL]             Node nextNode = child.getNext(); [EOL]             if (nextNode != null && elseBranch == null && isReturnBlock(thenBranch) && nextNode.isIf()) { [EOL]                 Node nextCond = nextNode.getFirstChild(); [EOL]                 Node nextThen = nextCond.getNext(); [EOL]                 Node nextElse = nextThen.getNext(); [EOL]                 if (thenBranch.isEquivalentToTyped(nextThen)) { [EOL]                     child.detachFromParent(); [EOL]                     child.detachChildren(); [EOL]                     Node newCond = new Node(Token.OR, cond); [EOL]                     nextNode.replaceChild(nextCond, newCond); [EOL]                     newCond.addChildToBack(nextCond); [EOL]                     reportCodeChange(); [EOL]                 } else if (nextElse != null && thenBranch.isEquivalentToTyped(nextElse)) { [EOL]                     child.detachFromParent(); [EOL]                     child.detachChildren(); [EOL]                     Node newCond = new Node(Token.AND, IR.not(cond).srcref(cond)); [EOL]                     nextNode.replaceChild(nextCond, newCond); [EOL]                     newCond.addChildToBack(nextCond); [EOL]                     reportCodeChange(); [EOL]                 } [EOL]             } else if (nextNode != null && elseBranch == null && isReturnBlock(thenBranch) && isReturnExpression(nextNode)) { [EOL]                 Node thenExpr = null; [EOL]                 if (isReturnExpressBlock(thenBranch)) { [EOL]                     thenExpr = getBlockReturnExpression(thenBranch); [EOL]                     thenExpr.detachFromParent(); [EOL]                 } else { [EOL]                     thenExpr = NodeUtil.newUndefinedNode(child); [EOL]                 } [EOL]                 Node elseExpr = nextNode.getFirstChild(); [EOL]                 cond.detachFromParent(); [EOL]                 elseExpr.detachFromParent(); [EOL]                 Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(child)); [EOL]                 n.replaceChild(child, returnNode); [EOL]                 n.removeChild(nextNode); [EOL]                 reportCodeChange(); [EOL]             } else if (elseBranch != null && statementMustExitParent(thenBranch)) { [EOL]                 child.removeChild(elseBranch); [EOL]                 n.addChildAfter(elseBranch, child); [EOL]                 reportCodeChange(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return n; [EOL] } <line_num>: 306,377
private boolean statementMustExitParent(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.THROW: [EOL]         case Token.RETURN: [EOL]             return true; [EOL]         case Token.BLOCK: [EOL]             if (n.hasChildren()) { [EOL]                 Node child = n.getLastChild(); [EOL]                 return statementMustExitParent(child); [EOL]             } [EOL]             return false; [EOL]         case Token.FUNCTION: [EOL]         default: [EOL]             return false; [EOL]     } [EOL] } <line_num>: 379,395
private Node tryReplaceUndefined(Node n) { [EOL]     if (isASTNormalized() && NodeUtil.isUndefined(n) && !NodeUtil.isLValue(n)) { [EOL]         Node replacement = NodeUtil.newUndefinedNode(n); [EOL]         n.getParent().replaceChild(n, replacement); [EOL]         reportCodeChange(); [EOL]         return replacement; [EOL]     } [EOL]     return n; [EOL] } <line_num>: 400,411
private Node tryReduceReturn(Node n) { [EOL]     Node result = n.getFirstChild(); [EOL]     if (result != null) { [EOL]         switch(result.getType()) { [EOL]             case Token.VOID: [EOL]                 Node operand = result.getFirstChild(); [EOL]                 if (!mayHaveSideEffects(operand)) { [EOL]                     n.removeFirstChild(); [EOL]                     reportCodeChange(); [EOL]                 } [EOL]                 break; [EOL]             case Token.NAME: [EOL]                 String name = result.getString(); [EOL]                 if (name.equals("undefined")) { [EOL]                     n.removeFirstChild(); [EOL]                     reportCodeChange(); [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return n; [EOL] } <line_num>: 418,441
private Node tryReplaceExitWithBreak(Node n) { [EOL]     Node result = n.getFirstChild(); [EOL]     Node breakTarget = n; [EOL]     for (; !ControlFlowAnalysis.isBreakTarget(breakTarget, null); breakTarget = breakTarget.getParent()) { [EOL]         if (breakTarget.isFunction() || breakTarget.isScript()) { [EOL]             return n; [EOL]         } [EOL]     } [EOL]     Node follow = ControlFlowAnalysis.computeFollowNode(breakTarget); [EOL]     Node prefinallyFollows = follow; [EOL]     follow = skipFinallyNodes(follow); [EOL]     if (prefinallyFollows != follow) { [EOL]         if (!isPure(result)) { [EOL]             return n; [EOL]         } [EOL]     } [EOL]     if (follow == null && (n.isThrow() || result != null)) { [EOL]         return n; [EOL]     } [EOL]     if (follow == null || areMatchingExits(n, follow)) { [EOL]         Node replacement = IR.breakNode(); [EOL]         n.getParent().replaceChild(n, replacement); [EOL]         this.reportCodeChange(); [EOL]         return replacement; [EOL]     } [EOL]     return n; [EOL] } <line_num>: 454,505
private Node tryRemoveRedundantExit(Node n) { [EOL]     Node exitExpr = n.getFirstChild(); [EOL]     Node follow = ControlFlowAnalysis.computeFollowNode(n); [EOL]     Node prefinallyFollows = follow; [EOL]     follow = skipFinallyNodes(follow); [EOL]     if (prefinallyFollows != follow) { [EOL]         if (!isPure(exitExpr)) { [EOL]             return n; [EOL]         } [EOL]     } [EOL]     if (follow == null && (n.isThrow() || exitExpr != null)) { [EOL]         return n; [EOL]     } [EOL]     if (follow == null || areMatchingExits(n, follow)) { [EOL]         n.detachFromParent(); [EOL]         reportCodeChange(); [EOL]         return null; [EOL]     } [EOL]     return n; [EOL] } <line_num>: 517,548
boolean isPure(Node n) { [EOL]     return n == null || (!NodeUtil.canBeSideEffected(n) && !mayHaveSideEffects(n)); [EOL] } <line_num>: 554,558
Node skipFinallyNodes(Node n) { [EOL]     while (n != null && NodeUtil.isTryFinallyNode(n.getParent(), n)) { [EOL]         n = ControlFlowAnalysis.computeFollowNode(n); [EOL]     } [EOL]     return n; [EOL] } <line_num>: 563,568
boolean areMatchingExits(Node nodeThis, Node nodeThat) { [EOL]     return nodeThis.isEquivalentTo(nodeThat) && (!isExceptionPossible(nodeThis) || getExceptionHandler(nodeThis) == getExceptionHandler(nodeThat)); [EOL] } <line_num>: 576,580
boolean isExceptionPossible(Node n) { [EOL]     Preconditions.checkState(n.isReturn() || n.isThrow()); [EOL]     return n.isThrow() || (n.hasChildren() && !NodeUtil.isLiteralValue(n.getLastChild(), true)); [EOL] } <line_num>: 582,589
Node getExceptionHandler(Node n) { [EOL]     return ControlFlowAnalysis.getExceptionHandler(n); [EOL] } <line_num>: 591,593
private Node tryMinimizeNot(Node n) { [EOL]     Node parent = n.getParent(); [EOL]     Node notChild = n.getFirstChild(); [EOL]     int complementOperator; [EOL]     switch(notChild.getType()) { [EOL]         case Token.EQ: [EOL]             complementOperator = Token.NE; [EOL]             break; [EOL]         case Token.NE: [EOL]             complementOperator = Token.EQ; [EOL]             break; [EOL]         case Token.SHEQ: [EOL]             complementOperator = Token.SHNE; [EOL]             break; [EOL]         case Token.SHNE: [EOL]             complementOperator = Token.SHEQ; [EOL]             break; [EOL]         default: [EOL]             return n; [EOL]     } [EOL]     Node newOperator = n.removeFirstChild(); [EOL]     newOperator.setType(complementOperator); [EOL]     parent.replaceChild(n, newOperator); [EOL]     reportCodeChange(); [EOL]     return newOperator; [EOL] } <line_num>: 600,628
private Node tryMinimizeIf(Node n) { [EOL]     Node parent = n.getParent(); [EOL]     Node cond = n.getFirstChild(); [EOL]     if (NodeUtil.isLiteralValue(cond, true)) { [EOL]         return n; [EOL]     } [EOL]     Node thenBranch = cond.getNext(); [EOL]     Node elseBranch = thenBranch.getNext(); [EOL]     if (elseBranch == null) { [EOL]         if (isFoldableExpressBlock(thenBranch)) { [EOL]             Node expr = getBlockExpression(thenBranch); [EOL]             if (!late && isPropertyAssignmentInExpression(expr)) { [EOL]                 return n; [EOL]             } [EOL]             if (cond.isNot()) { [EOL]                 if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) { [EOL]                     return n; [EOL]                 } [EOL]                 Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n); [EOL]                 Node newExpr = NodeUtil.newExpr(or); [EOL]                 parent.replaceChild(n, newExpr); [EOL]                 reportCodeChange(); [EOL]                 return newExpr; [EOL]             } [EOL]             if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) { [EOL]                 return n; [EOL]             } [EOL]             n.removeChild(cond); [EOL]             Node and = IR.and(cond, expr.removeFirstChild()).srcref(n); [EOL]             Node newExpr = NodeUtil.newExpr(and); [EOL]             parent.replaceChild(n, newExpr); [EOL]             reportCodeChange(); [EOL]             return newExpr; [EOL]         } else { [EOL]             if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) { [EOL]                 Node innerIf = thenBranch.getFirstChild(); [EOL]                 if (innerIf.isIf()) { [EOL]                     Node innerCond = innerIf.getFirstChild(); [EOL]                     Node innerThenBranch = innerCond.getNext(); [EOL]                     Node innerElseBranch = innerThenBranch.getNext(); [EOL]                     if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) { [EOL]                         n.detachChildren(); [EOL]                         n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond)); [EOL]                         n.addChildrenToBack(innerThenBranch.detachFromParent()); [EOL]                         reportCodeChange(); [EOL]                         return n; [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         return n; [EOL]     } [EOL]     tryRemoveRepeatedStatements(n); [EOL]     if (cond.isNot() && !consumesDanglingElse(elseBranch)) { [EOL]         n.replaceChild(cond, cond.removeFirstChild()); [EOL]         n.removeChild(thenBranch); [EOL]         n.addChildToBack(thenBranch); [EOL]         reportCodeChange(); [EOL]         return n; [EOL]     } [EOL]     if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) { [EOL]         Node thenExpr = getBlockReturnExpression(thenBranch); [EOL]         Node elseExpr = getBlockReturnExpression(elseBranch); [EOL]         n.removeChild(cond); [EOL]         thenExpr.detachFromParent(); [EOL]         elseExpr.detachFromParent(); [EOL]         Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n)); [EOL]         parent.replaceChild(n, returnNode); [EOL]         reportCodeChange(); [EOL]         return returnNode; [EOL]     } [EOL]     boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch); [EOL]     boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch); [EOL]     if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) { [EOL]         Node thenOp = getBlockExpression(thenBranch).getFirstChild(); [EOL]         Node elseOp = getBlockExpression(elseBranch).getFirstChild(); [EOL]         if (thenOp.getType() == elseOp.getType()) { [EOL]             if (NodeUtil.isAssignmentOp(thenOp)) { [EOL]                 Node lhs = thenOp.getFirstChild(); [EOL]                 if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && !mayEffectMutableState(lhs)) { [EOL]                     n.removeChild(cond); [EOL]                     Node assignName = thenOp.removeFirstChild(); [EOL]                     Node thenExpr = thenOp.removeFirstChild(); [EOL]                     Node elseExpr = elseOp.getLastChild(); [EOL]                     elseOp.removeChild(elseExpr); [EOL]                     Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); [EOL]                     Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp); [EOL]                     Node expr = NodeUtil.newExpr(assign); [EOL]                     parent.replaceChild(n, expr); [EOL]                     reportCodeChange(); [EOL]                     return expr; [EOL]                 } [EOL]             } [EOL]         } [EOL]         n.removeChild(cond); [EOL]         thenOp.detachFromParent(); [EOL]         elseOp.detachFromParent(); [EOL]         Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n)); [EOL]         parent.replaceChild(n, expr); [EOL]         reportCodeChange(); [EOL]         return expr; [EOL]     } [EOL]     boolean thenBranchIsVar = isVarBlock(thenBranch); [EOL]     boolean elseBranchIsVar = isVarBlock(elseBranch); [EOL]     if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) { [EOL]         Node var = getBlockVar(thenBranch); [EOL]         Node elseAssign = getBlockExpression(elseBranch).getFirstChild(); [EOL]         Node name1 = var.getFirstChild(); [EOL]         Node maybeName2 = elseAssign.getFirstChild(); [EOL]         if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) { [EOL]             Node thenExpr = name1.removeChildren(); [EOL]             Node elseExpr = elseAssign.getLastChild().detachFromParent(); [EOL]             cond.detachFromParent(); [EOL]             Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); [EOL]             var.detachFromParent(); [EOL]             name1.addChildrenToBack(hookNode); [EOL]             parent.replaceChild(n, var); [EOL]             reportCodeChange(); [EOL]             return var; [EOL]         } [EOL]     } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) { [EOL]         Node var = getBlockVar(elseBranch); [EOL]         Node thenAssign = getBlockExpression(thenBranch).getFirstChild(); [EOL]         Node maybeName1 = thenAssign.getFirstChild(); [EOL]         Node name2 = var.getFirstChild(); [EOL]         if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) { [EOL]             Node thenExpr = thenAssign.getLastChild().detachFromParent(); [EOL]             Node elseExpr = name2.removeChildren(); [EOL]             cond.detachFromParent(); [EOL]             Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); [EOL]             var.detachFromParent(); [EOL]             name2.addChildrenToBack(hookNode); [EOL]             parent.replaceChild(n, var); [EOL]             reportCodeChange(); [EOL]             return var; [EOL]         } [EOL]     } [EOL]     return n; [EOL] } <line_num>: 636,868
private void tryRemoveRepeatedStatements(Node n) { [EOL]     Preconditions.checkState(n.isIf()); [EOL]     Node parent = n.getParent(); [EOL]     if (!NodeUtil.isStatementBlock(parent)) { [EOL]         return; [EOL]     } [EOL]     Node cond = n.getFirstChild(); [EOL]     Node trueBranch = cond.getNext(); [EOL]     Node falseBranch = trueBranch.getNext(); [EOL]     Preconditions.checkNotNull(trueBranch); [EOL]     Preconditions.checkNotNull(falseBranch); [EOL]     while (true) { [EOL]         Node lastTrue = trueBranch.getLastChild(); [EOL]         Node lastFalse = falseBranch.getLastChild(); [EOL]         if (lastTrue == null || lastFalse == null || !areNodesEqualForInlining(lastTrue, lastFalse)) { [EOL]             break; [EOL]         } [EOL]         lastTrue.detachFromParent(); [EOL]         lastFalse.detachFromParent(); [EOL]         parent.addChildAfter(lastTrue, n); [EOL]         reportCodeChange(); [EOL]     } [EOL] } <line_num>: 892,920
private boolean isFoldableExpressBlock(Node n) { [EOL]     if (n.isBlock()) { [EOL]         if (n.hasOneChild()) { [EOL]             Node maybeExpr = n.getFirstChild(); [EOL]             if (maybeExpr.isExprResult()) { [EOL]                 if (maybeExpr.getFirstChild().isCall()) { [EOL]                     Node calledFn = maybeExpr.getFirstChild().getFirstChild(); [EOL]                     if (calledFn.isGetElem()) { [EOL]                         return false; [EOL]                     } else if (calledFn.isGetProp() && calledFn.getLastChild().getString().startsWith("on")) { [EOL]                         return false; [EOL]                     } [EOL]                 } [EOL]                 return true; [EOL]             } [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 926,957
private Node getBlockExpression(Node n) { [EOL]     Preconditions.checkState(isFoldableExpressBlock(n)); [EOL]     return n.getFirstChild(); [EOL] } <line_num>: 962,965
private boolean isReturnBlock(Node n) { [EOL]     if (n.isBlock()) { [EOL]         if (n.hasOneChild()) { [EOL]             Node first = n.getFirstChild(); [EOL]             return first.isReturn(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 971,980
private boolean isReturnExpressBlock(Node n) { [EOL]     if (n.isBlock()) { [EOL]         if (n.hasOneChild()) { [EOL]             Node first = n.getFirstChild(); [EOL]             if (first.isReturn()) { [EOL]                 return first.hasOneChild(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 986,997
private boolean isReturnExpression(Node n) { [EOL]     if (n.isReturn()) { [EOL]         return n.hasOneChild(); [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1002,1007
private Node getBlockReturnExpression(Node n) { [EOL]     Preconditions.checkState(isReturnExpressBlock(n)); [EOL]     return n.getFirstChild().getFirstChild(); [EOL] } <line_num>: 1012,1015
private boolean isVarBlock(Node n) { [EOL]     if (n.isBlock()) { [EOL]         if (n.hasOneChild()) { [EOL]             Node first = n.getFirstChild(); [EOL]             if (first.isVar()) { [EOL]                 return first.hasOneChild(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1021,1032
private Node getBlockVar(Node n) { [EOL]     Preconditions.checkState(isVarBlock(n)); [EOL]     return n.getFirstChild(); [EOL] } <line_num>: 1037,1040
private boolean consumesDanglingElse(Node n) { [EOL]     while (true) { [EOL]         switch(n.getType()) { [EOL]             case Token.IF: [EOL]                 if (n.getChildCount() < 3) { [EOL]                     return true; [EOL]                 } [EOL]                 n = n.getLastChild(); [EOL]                 continue; [EOL]             case Token.WITH: [EOL]             case Token.WHILE: [EOL]             case Token.FOR: [EOL]                 n = n.getLastChild(); [EOL]                 continue; [EOL]             default: [EOL]                 return false; [EOL]         } [EOL]     } [EOL] } <line_num>: 1047,1066
@Override [EOL] public boolean apply(Node input) { [EOL]     return NodeUtil.precedence(input.getType()) < precedence; [EOL] } <line_num>: 1075,1078
private boolean isLowerPrecedenceInExpression(Node n, final int precedence) { [EOL]     Predicate<Node> isLowerPrecedencePredicate = new Predicate<Node>() { [EOL]  [EOL]         @Override [EOL]         public boolean apply(Node input) { [EOL]             return NodeUtil.precedence(input.getType()) < precedence; [EOL]         } [EOL]     }; [EOL]     return NodeUtil.has(n, isLowerPrecedencePredicate, DONT_TRAVERSE_FUNCTIONS_PREDICATE); [EOL] } <line_num>: 1072,1083
private boolean isLowerPrecedence(Node n, final int precedence) { [EOL]     return NodeUtil.precedence(n.getType()) < precedence; [EOL] } <line_num>: 1088,1090
private boolean isHigherPrecedence(Node n, final int precedence) { [EOL]     return NodeUtil.precedence(n.getType()) > precedence; [EOL] } <line_num>: 1095,1097
@Override [EOL] public boolean apply(Node input) { [EOL]     return (input.isGetProp() && input.getParent().isAssign()); [EOL] } <line_num>: 1104,1108
private boolean isPropertyAssignmentInExpression(Node n) { [EOL]     Predicate<Node> isPropertyAssignmentInExpressionPredicate = new Predicate<Node>() { [EOL]  [EOL]         @Override [EOL]         public boolean apply(Node input) { [EOL]             return (input.isGetProp() && input.getParent().isAssign()); [EOL]         } [EOL]     }; [EOL]     return NodeUtil.has(n, isPropertyAssignmentInExpressionPredicate, DONT_TRAVERSE_FUNCTIONS_PREDICATE); [EOL] } <line_num>: 1101,1113
private Node tryMinimizeCondition(Node n) { [EOL]     Node parent = n.getParent(); [EOL]     switch(n.getType()) { [EOL]         case Token.NOT: [EOL]             Node first = n.getFirstChild(); [EOL]             switch(first.getType()) { [EOL]                 case Token.NOT: [EOL]                     { [EOL]                         Node newRoot = first.removeFirstChild(); [EOL]                         parent.replaceChild(n, newRoot); [EOL]                         reportCodeChange(); [EOL]                         return newRoot; [EOL]                     } [EOL]                 case Token.AND: [EOL]                 case Token.OR: [EOL]                     { [EOL]                         Node leftParent = first.getFirstChild(); [EOL]                         Node rightParent = first.getLastChild(); [EOL]                         Node left, right; [EOL]                         if (!leftParent.isNot() && !rightParent.isNot()) { [EOL]                             int op_precedence = NodeUtil.precedence(first.getType()); [EOL]                             if ((isLowerPrecedence(leftParent, NOT_PRECEDENCE) && isHigherPrecedence(leftParent, op_precedence)) || (isLowerPrecedence(rightParent, NOT_PRECEDENCE) && isHigherPrecedence(rightParent, op_precedence))) { [EOL]                                 return n; [EOL]                             } [EOL]                         } [EOL]                         if (leftParent.isNot()) { [EOL]                             left = leftParent.removeFirstChild(); [EOL]                         } else { [EOL]                             leftParent.detachFromParent(); [EOL]                             left = IR.not(leftParent).srcref(leftParent); [EOL]                         } [EOL]                         if (rightParent.isNot()) { [EOL]                             right = rightParent.removeFirstChild(); [EOL]                         } else { [EOL]                             rightParent.detachFromParent(); [EOL]                             right = IR.not(rightParent).srcref(rightParent); [EOL]                         } [EOL]                         int newOp = (first.isAnd()) ? Token.OR : Token.AND; [EOL]                         Node newRoot = new Node(newOp, left, right); [EOL]                         parent.replaceChild(n, newRoot); [EOL]                         reportCodeChange(); [EOL]                         return newRoot; [EOL]                     } [EOL]                 default: [EOL]                     TernaryValue nVal = NodeUtil.getPureBooleanValue(first); [EOL]                     if (nVal != TernaryValue.UNKNOWN) { [EOL]                         boolean result = nVal.not().toBoolean(true); [EOL]                         int equivalentResult = result ? 1 : 0; [EOL]                         return maybeReplaceChildWithNumber(n, parent, equivalentResult); [EOL]                     } [EOL]             } [EOL]             return n; [EOL]         case Token.OR: [EOL]         case Token.AND: [EOL]             { [EOL]                 Node left = n.getFirstChild(); [EOL]                 Node right = n.getLastChild(); [EOL]                 left = tryMinimizeCondition(left); [EOL]                 right = tryMinimizeCondition(right); [EOL]                 TernaryValue rightVal = NodeUtil.getPureBooleanValue(right); [EOL]                 if (NodeUtil.getPureBooleanValue(right) != TernaryValue.UNKNOWN) { [EOL]                     int type = n.getType(); [EOL]                     Node replacement = null; [EOL]                     boolean rval = rightVal.toBoolean(true); [EOL]                     if (type == Token.OR && !rval || type == Token.AND && rval) { [EOL]                         replacement = left; [EOL]                     } else if (!mayHaveSideEffects(left)) { [EOL]                         replacement = right; [EOL]                     } [EOL]                     if (replacement != null) { [EOL]                         n.detachChildren(); [EOL]                         parent.replaceChild(n, replacement); [EOL]                         reportCodeChange(); [EOL]                         return replacement; [EOL]                     } [EOL]                 } [EOL]                 return n; [EOL]             } [EOL]         case Token.HOOK: [EOL]             { [EOL]                 Node condition = n.getFirstChild(); [EOL]                 Node trueNode = n.getFirstChild().getNext(); [EOL]                 Node falseNode = n.getLastChild(); [EOL]                 trueNode = tryMinimizeCondition(trueNode); [EOL]                 falseNode = tryMinimizeCondition(falseNode); [EOL]                 Node replacement = null; [EOL]                 TernaryValue trueNodeVal = NodeUtil.getPureBooleanValue(trueNode); [EOL]                 TernaryValue falseNodeVal = NodeUtil.getPureBooleanValue(falseNode); [EOL]                 if (trueNodeVal == TernaryValue.TRUE && falseNodeVal == TernaryValue.FALSE) { [EOL]                     condition.detachFromParent(); [EOL]                     replacement = condition; [EOL]                 } else if (trueNodeVal == TernaryValue.FALSE && falseNodeVal == TernaryValue.TRUE) { [EOL]                     condition.detachFromParent(); [EOL]                     replacement = IR.not(condition); [EOL]                 } else if (trueNodeVal == TernaryValue.TRUE) { [EOL]                     n.detachChildren(); [EOL]                     replacement = IR.or(condition, falseNode); [EOL]                 } else if (falseNodeVal == TernaryValue.FALSE) { [EOL]                     n.detachChildren(); [EOL]                     replacement = IR.and(condition, trueNode); [EOL]                 } [EOL]                 if (replacement != null) { [EOL]                     parent.replaceChild(n, replacement); [EOL]                     n = replacement; [EOL]                     reportCodeChange(); [EOL]                 } [EOL]                 return n; [EOL]             } [EOL]         default: [EOL]             TernaryValue nVal = NodeUtil.getPureBooleanValue(n); [EOL]             if (nVal != TernaryValue.UNKNOWN) { [EOL]                 boolean result = nVal.toBoolean(true); [EOL]                 int equivalentResult = result ? 1 : 0; [EOL]                 return maybeReplaceChildWithNumber(n, parent, equivalentResult); [EOL]             } [EOL]             return n; [EOL]     } [EOL] } <line_num>: 1129,1309
private Node maybeReplaceChildWithNumber(Node n, Node parent, int num) { [EOL]     Node newNode = IR.number(num); [EOL]     if (!newNode.isEquivalentTo(n)) { [EOL]         parent.replaceChild(n, newNode); [EOL]         reportCodeChange(); [EOL]         return newNode; [EOL]     } [EOL]     return n; [EOL] } <line_num>: 1317,1327
private Node tryFoldStandardConstructors(Node n) { [EOL]     Preconditions.checkState(n.isNew()); [EOL]     if (isASTNormalized()) { [EOL]         if (n.getFirstChild().isName()) { [EOL]             String className = n.getFirstChild().getString(); [EOL]             if (STANDARD_OBJECT_CONSTRUCTORS.contains(className)) { [EOL]                 n.setType(Token.CALL); [EOL]                 n.putBooleanProp(Node.FREE_CALL, true); [EOL]                 reportCodeChange(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return n; [EOL] } <line_num>: 1343,1361
private Node tryFoldLiteralConstructor(Node n) { [EOL]     Preconditions.checkArgument(n.isCall() || n.isNew()); [EOL]     Node constructorNameNode = n.getFirstChild(); [EOL]     Node newLiteralNode = null; [EOL]     if (isASTNormalized() && Token.NAME == constructorNameNode.getType()) { [EOL]         String className = constructorNameNode.getString(); [EOL]         if ("RegExp".equals(className)) { [EOL]             return tryFoldRegularExpressionConstructor(n); [EOL]         } else { [EOL]             boolean constructorHasArgs = constructorNameNode.getNext() != null; [EOL]             if ("Object".equals(className) && !constructorHasArgs) { [EOL]                 newLiteralNode = IR.objectlit(); [EOL]             } else if ("Array".equals(className)) { [EOL]                 Node arg0 = constructorNameNode.getNext(); [EOL]                 FoldArrayAction action = isSafeToFoldArrayConstructor(arg0); [EOL]                 if (action == FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS || action == FoldArrayAction.SAFE_TO_FOLD_WITHOUT_ARGS) { [EOL]                     newLiteralNode = IR.arraylit(); [EOL]                     n.removeChildren(); [EOL]                     if (action == FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS) { [EOL]                         newLiteralNode.addChildrenToFront(arg0); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (newLiteralNode != null) { [EOL]                 n.getParent().replaceChild(n, newLiteralNode); [EOL]                 reportCodeChange(); [EOL]                 return newLiteralNode; [EOL]             } [EOL]         } [EOL]     } [EOL]     return n; [EOL] } <line_num>: 1367,1415
private FoldArrayAction isSafeToFoldArrayConstructor(Node arg) { [EOL]     FoldArrayAction action = FoldArrayAction.NOT_SAFE_TO_FOLD; [EOL]     if (arg == null) { [EOL]         action = FoldArrayAction.SAFE_TO_FOLD_WITHOUT_ARGS; [EOL]     } else if (arg.getNext() != null) { [EOL]         action = FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS; [EOL]     } else { [EOL]         switch(arg.getType()) { [EOL]             case Token.STRING: [EOL]                 action = FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS; [EOL]                 break; [EOL]             case Token.NUMBER: [EOL]                 if (arg.getDouble() == 0) { [EOL]                     action = FoldArrayAction.SAFE_TO_FOLD_WITHOUT_ARGS; [EOL]                 } [EOL]                 break; [EOL]             case Token.ARRAYLIT: [EOL]                 action = FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS; [EOL]                 break; [EOL]             default: [EOL]         } [EOL]     } [EOL]     return action; [EOL] } <line_num>: 1426,1453
private Node tryFoldRegularExpressionConstructor(Node n) { [EOL]     Node parent = n.getParent(); [EOL]     Node constructor = n.getFirstChild(); [EOL]     Node pattern = constructor.getNext(); [EOL]     Node flags = null != pattern ? pattern.getNext() : null; [EOL]     if (null == pattern || (null != flags && null != flags.getNext())) { [EOL]         return n; [EOL]     } [EOL]     if (pattern.isString() && !"".equals(pattern.getString()) && pattern.getString().length() < 100 && (null == flags || flags.isString()) && (isEcmaScript5OrGreater() || !containsUnicodeEscape(pattern.getString()))) { [EOL]         pattern = makeForwardSlashBracketSafe(pattern); [EOL]         Node regexLiteral; [EOL]         if (null == flags || "".equals(flags.getString())) { [EOL]             regexLiteral = IR.regexp(pattern); [EOL]         } else { [EOL]             if (!areValidRegexpFlags(flags.getString())) { [EOL]                 report(INVALID_REGULAR_EXPRESSION_FLAGS, flags); [EOL]                 return n; [EOL]             } [EOL]             if (!areSafeFlagsToFold(flags.getString())) { [EOL]                 return n; [EOL]             } [EOL]             n.removeChild(flags); [EOL]             regexLiteral = IR.regexp(pattern, flags); [EOL]         } [EOL]         parent.replaceChild(n, regexLiteral); [EOL]         reportCodeChange(); [EOL]         return regexLiteral; [EOL]     } [EOL]     return n; [EOL] } <line_num>: 1455,1510
private Node reduceTrueFalse(Node n) { [EOL]     if (late) { [EOL]         Node not = IR.not(IR.number(n.isTrue() ? 0 : 1)); [EOL]         not.copyInformationFromForTree(n); [EOL]         n.getParent().replaceChild(n, not); [EOL]         reportCodeChange(); [EOL]         return not; [EOL]     } [EOL]     return n; [EOL] } <line_num>: 1512,1521
private Node tryMinimizeArrayLiteral(Node n) { [EOL]     boolean allStrings = true; [EOL]     for (Node cur = n.getFirstChild(); cur != null; cur = cur.getNext()) { [EOL]         if (!cur.isString()) { [EOL]             allStrings = false; [EOL]         } [EOL]     } [EOL]     if (allStrings) { [EOL]         return tryMinimizeStringArrayLiteral(n); [EOL]     } else { [EOL]         return n; [EOL]     } [EOL] } <line_num>: 1523,1536
private Node tryMinimizeStringArrayLiteral(Node n) { [EOL]     if (!late) { [EOL]         return n; [EOL]     } [EOL]     int numElements = n.getChildCount(); [EOL]     int saving = numElements * 2 - STRING_SPLIT_OVERHEAD; [EOL]     if (saving <= 0) { [EOL]         return n; [EOL]     } [EOL]     String[] strings = new String[n.getChildCount()]; [EOL]     int idx = 0; [EOL]     for (Node cur = n.getFirstChild(); cur != null; cur = cur.getNext()) { [EOL]         strings[idx++] = cur.getString(); [EOL]     } [EOL]     String delimiter = pickDelimiter(strings); [EOL]     if (delimiter != null) { [EOL]         String template = Joiner.on(delimiter).join(strings); [EOL]         Node call = IR.call(IR.getprop(IR.string(template), IR.string("split")), IR.string("" + delimiter)); [EOL]         call.copyInformationFromForTree(n); [EOL]         n.getParent().replaceChild(n, call); [EOL]         reportCodeChange(); [EOL]         return call; [EOL]     } [EOL]     return n; [EOL] } <line_num>: 1538,1572
private String pickDelimiter(String[] strings) { [EOL]     boolean allLength1 = true; [EOL]     for (String s : strings) { [EOL]         if (s.length() != 1) { [EOL]             allLength1 = false; [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (allLength1) { [EOL]         return ""; [EOL]     } [EOL]     String[] delimiters = new String[] { " ", ";", ",", "{", "}", null }; [EOL]     int i = 0; [EOL]     NEXT_DELIMITER: for (; delimiters[i] != null; i++) { [EOL]         for (String cur : strings) { [EOL]             if (cur.contains(delimiters[i])) { [EOL]                 continue NEXT_DELIMITER; [EOL]             } [EOL]         } [EOL]         break; [EOL]     } [EOL]     return delimiters[i]; [EOL] } <line_num>: 1579,1603
private static boolean areValidRegexpFlags(String flags) { [EOL]     return REGEXP_FLAGS_RE.matcher(flags).matches(); [EOL] } <line_num>: 1614,1616
private boolean areSafeFlagsToFold(String flags) { [EOL]     return isEcmaScript5OrGreater() || flags.indexOf('g') < 0; [EOL] } <line_num>: 1634,1636
private static Node makeForwardSlashBracketSafe(Node n) { [EOL]     String s = n.getString(); [EOL]     StringBuilder sb = null; [EOL]     int pos = 0; [EOL]     boolean isEscaped = false, inCharset = false; [EOL]     for (int i = 0; i < s.length(); ++i) { [EOL]         char ch = s.charAt(i); [EOL]         switch(ch) { [EOL]             case '\\': [EOL]                 isEscaped = !isEscaped; [EOL]                 continue; [EOL]             case '/': [EOL]                 if (!isEscaped && !inCharset) { [EOL]                     if (null == sb) { [EOL]                         sb = new StringBuilder(s.length() + 16); [EOL]                     } [EOL]                     sb.append(s, pos, i).append('\\'); [EOL]                     pos = i; [EOL]                 } [EOL]                 break; [EOL]             case '[': [EOL]                 if (!isEscaped) { [EOL]                     inCharset = true; [EOL]                 } [EOL]                 break; [EOL]             case ']': [EOL]                 if (!isEscaped) { [EOL]                     inCharset = false; [EOL]                 } [EOL]                 break; [EOL]             case '\r': [EOL]             case '\n': [EOL]             case '\u2028': [EOL]             case '\u2029': [EOL]                 if (null == sb) { [EOL]                     sb = new StringBuilder(s.length() + 16); [EOL]                 } [EOL]                 if (isEscaped) { [EOL]                     sb.append(s, pos, i - 1); [EOL]                 } else { [EOL]                     sb.append(s, pos, i); [EOL]                 } [EOL]                 switch(ch) { [EOL]                     case '\r': [EOL]                         sb.append("\\r"); [EOL]                         break; [EOL]                     case '\n': [EOL]                         sb.append("\\n"); [EOL]                         break; [EOL]                     case '\u2028': [EOL]                         sb.append("\\u2028"); [EOL]                         break; [EOL]                     case '\u2029': [EOL]                         sb.append("\\u2029"); [EOL]                         break; [EOL]                 } [EOL]                 pos = i + 1; [EOL]                 break; [EOL]         } [EOL]         isEscaped = false; [EOL]     } [EOL]     if (null == sb) { [EOL]         return n.cloneTree(); [EOL]     } [EOL]     sb.append(s, pos, s.length()); [EOL]     return IR.string(sb.toString()).srcref(n); [EOL] } <line_num>: 1641,1706
static boolean containsUnicodeEscape(String s) { [EOL]     String esc = REGEXP_ESCAPER.regexpEscape(s); [EOL]     for (int i = -1; (i = esc.indexOf("\\u", i + 1)) >= 0; ) { [EOL]         int nSlashes = 0; [EOL]         while (i - nSlashes > 0 && '\\' == esc.charAt(i - nSlashes - 1)) { [EOL]             ++nSlashes; [EOL]         } [EOL]         if (0 == (nSlashes & 1)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1712,1724
