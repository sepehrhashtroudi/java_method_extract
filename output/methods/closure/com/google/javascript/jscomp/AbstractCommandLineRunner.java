AbstractCommandLineRunner() { [EOL]     this(System.out, System.err); [EOL] } <line_num>: 136,138
AbstractCommandLineRunner(PrintStream out, PrintStream err) { [EOL]     this.config = new CommandLineConfig(); [EOL]     this.jsOutput = Preconditions.checkNotNull(out); [EOL]     this.err = Preconditions.checkNotNull(err); [EOL] } <line_num>: 140,144
public FlagUsageException(String message) { [EOL]     super(message); [EOL] } <line_num>: 427,429
private Entry(CheckLevel level, String groupName) { [EOL]     this.level = level; [EOL]     this.groupName = groupName; [EOL] } <line_num>: 2084,2087
@VisibleForTesting [EOL] void enableTestMode(Supplier<List<SourceFile>> externsSupplier, Supplier<List<SourceFile>> inputsSupplier, Supplier<List<JSModule>> modulesSupplier, Function<Integer, Boolean> exitCodeReceiver) { [EOL]     Preconditions.checkArgument(inputsSupplier == null ^ modulesSupplier == null); [EOL]     testMode = true; [EOL]     this.externsSupplierForTesting = externsSupplier; [EOL]     this.inputsSupplierForTesting = inputsSupplier; [EOL]     this.modulesSupplierForTesting = modulesSupplier; [EOL]     this.exitCodeReceiverForTesting = exitCodeReceiver; [EOL] } <line_num>: 156,169
protected boolean isInTestMode() { [EOL]     return testMode; [EOL] } <line_num>: 174,176
protected CommandLineConfig getCommandLineConfig() { [EOL]     return config; [EOL] } <line_num>: 181,183
protected abstract A createCompiler(); <line_num>: 189,189
protected abstract B createOptions(); <line_num>: 196,196
protected DiagnosticGroups getDiagnosticGroups() { [EOL]     if (compiler == null) { [EOL]         return new DiagnosticGroups(); [EOL]     } [EOL]     return compiler.getDiagnosticGroups(); [EOL] } <line_num>: 201,206
@Deprecated [EOL] protected void initOptionsFromFlags(CompilerOptions options) { [EOL] } <line_num>: 209,210
static DependencyOptions createDependencyOptions(boolean manageClosureDependencies, boolean onlyClosureDependencies, boolean processCommonJSModules, List<String> closureEntryPoints) throws FlagUsageException { [EOL]     if (onlyClosureDependencies) { [EOL]         if (closureEntryPoints.isEmpty()) { [EOL]             throw new FlagUsageException("When only_closure_dependencies is " + "on, you must specify at least one closure_entry_point"); [EOL]         } [EOL]         return new DependencyOptions().setDependencyPruning(true).setDependencySorting(true).setMoocherDropping(true).setEntryPoints(closureEntryPoints); [EOL]     } else if (processCommonJSModules) { [EOL]         return new DependencyOptions().setDependencyPruning(false).setDependencySorting(true).setMoocherDropping(false).setEntryPoints(closureEntryPoints); [EOL]     } else if (manageClosureDependencies || closureEntryPoints.size() > 0) { [EOL]         return new DependencyOptions().setDependencyPruning(true).setDependencySorting(true).setMoocherDropping(false).setEntryPoints(closureEntryPoints); [EOL]     } [EOL]     return null; [EOL] } <line_num>: 215,248
protected void setRunOptions(CompilerOptions options) throws FlagUsageException, IOException { [EOL]     DiagnosticGroups diagnosticGroups = getDiagnosticGroups(); [EOL]     if (config.warningGuards != null) { [EOL]         for (WarningGuardSpec.Entry entry : config.warningGuards.entries) { [EOL]             diagnosticGroups.setWarningLevel(options, entry.groupName, entry.level); [EOL]         } [EOL]     } [EOL]     if (!config.warningsWhitelistFile.isEmpty()) { [EOL]         options.addWarningsGuard(WhitelistWarningsGuard.fromFile(new File(config.warningsWhitelistFile))); [EOL]     } [EOL]     createDefineOrTweakReplacements(config.define, options, false); [EOL]     options.setTweakProcessing(config.tweakProcessing); [EOL]     createDefineOrTweakReplacements(config.tweak, options, true); [EOL]     DependencyOptions depOptions = createDependencyOptions(config.manageClosureDependencies, config.onlyClosureDependencies, config.processCommonJSModules, config.closureEntryPoints); [EOL]     if (depOptions != null) { [EOL]         options.setDependencyOptions(depOptions); [EOL]     } [EOL]     options.devMode = config.jscompDevMode; [EOL]     options.setCodingConvention(config.codingConvention); [EOL]     options.setSummaryDetailLevel(config.summaryDetailLevel); [EOL]     options.setTrustedStrings(true); [EOL]     legacyOutputCharset = options.outputCharset = getLegacyOutputCharset(); [EOL]     outputCharset2 = getOutputCharset2(); [EOL]     inputCharset = getInputCharset(); [EOL]     if (config.jsOutputFile.length() > 0) { [EOL]         if (config.skipNormalOutputs) { [EOL]             throw new FlagUsageException("skip_normal_outputs and js_output_file" + " cannot be used together."); [EOL]         } [EOL]     } [EOL]     if (config.skipNormalOutputs && config.printAst) { [EOL]         throw new FlagUsageException("skip_normal_outputs and print_ast cannot" + " be used together."); [EOL]     } [EOL]     if (config.skipNormalOutputs && config.printTree) { [EOL]         throw new FlagUsageException("skip_normal_outputs and print_tree cannot" + " be used together."); [EOL]     } [EOL]     if (config.createSourceMap.length() > 0) { [EOL]         options.sourceMapOutputPath = config.createSourceMap; [EOL]     } [EOL]     options.sourceMapDetailLevel = config.sourceMapDetailLevel; [EOL]     options.sourceMapFormat = config.sourceMapFormat; [EOL]     if (!config.variableMapInputFile.equals("")) { [EOL]         options.inputVariableMap = VariableMap.load(config.variableMapInputFile); [EOL]     } [EOL]     if (!config.propertyMapInputFile.equals("")) { [EOL]         options.inputPropertyMap = VariableMap.load(config.propertyMapInputFile); [EOL]     } [EOL]     if (config.languageIn.length() > 0) { [EOL]         CompilerOptions.LanguageMode languageMode = CompilerOptions.LanguageMode.fromString(config.languageIn); [EOL]         if (languageMode != null) { [EOL]             options.setLanguageIn(languageMode); [EOL]         } else { [EOL]             throw new FlagUsageException("Unknown language `" + config.languageIn + "' specified."); [EOL]         } [EOL]     } [EOL]     if (!config.outputManifests.isEmpty()) { [EOL]         Set<String> uniqueNames = Sets.newHashSet(); [EOL]         for (String filename : config.outputManifests) { [EOL]             if (!uniqueNames.add(filename)) { [EOL]                 throw new FlagUsageException("output_manifest flags specify " + "duplicate file names: " + filename); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (!config.outputBundles.isEmpty()) { [EOL]         Set<String> uniqueNames = Sets.newHashSet(); [EOL]         for (String filename : config.outputBundles) { [EOL]             if (!uniqueNames.add(filename)) { [EOL]                 throw new FlagUsageException("output_bundle flags specify " + "duplicate file names: " + filename); [EOL]             } [EOL]         } [EOL]     } [EOL]     options.acceptConstKeyword = config.acceptConstKeyword; [EOL]     options.transformAMDToCJSModules = config.transformAMDToCJSModules; [EOL]     options.processCommonJSModules = config.processCommonJSModules; [EOL]     options.commonJSModulePathPrefix = config.commonJSModulePathPrefix; [EOL] } <line_num>: 256,363
final protected A getCompiler() { [EOL]     return compiler; [EOL] } <line_num>: 365,367
final public void run() { [EOL]     int result = 0; [EOL]     int runs = 1; [EOL]     if (config.computePhaseOrdering) { [EOL]         runs = NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER; [EOL]         PhaseOptimizer.randomizeLoops(); [EOL]     } [EOL]     try { [EOL]         for (int i = 0; i < runs && result == 0; i++) { [EOL]             runTimeStats.recordStartRun(); [EOL]             result = doRun(); [EOL]             runTimeStats.recordEndRun(); [EOL]         } [EOL]     } catch (AbstractCommandLineRunner.FlagUsageException e) { [EOL]         System.err.println(e.getMessage()); [EOL]         result = -1; [EOL]     } catch (Throwable t) { [EOL]         t.printStackTrace(); [EOL]         result = -2; [EOL]     } [EOL]     if (config.computePhaseOrdering) { [EOL]         runTimeStats.outputBestPhaseOrdering(); [EOL]     } [EOL]     try { [EOL]         if (jsOutput instanceof Closeable) { [EOL]             ((Closeable) jsOutput).close(); [EOL]         } [EOL]     } catch (IOException e) { [EOL]         throw Throwables.propagate(e); [EOL]     } [EOL]     if (testMode) { [EOL]         exitCodeReceiverForTesting.apply(result); [EOL]     } else { [EOL]         System.exit(result); [EOL]     } [EOL] } <line_num>: 373,411
protected PrintStream getErrorPrintStream() { [EOL]     return err; [EOL] } <line_num>: 417,419
protected List<SourceFile> createInputs(List<String> files, boolean allowStdIn) throws FlagUsageException, IOException { [EOL]     List<SourceFile> inputs = new ArrayList<SourceFile>(files.size()); [EOL]     boolean usingStdin = false; [EOL]     for (String filename : files) { [EOL]         if (!"-".equals(filename)) { [EOL]             SourceFile newFile = SourceFile.fromFile(filename, inputCharset); [EOL]             inputs.add(newFile); [EOL]         } else { [EOL]             if (!allowStdIn) { [EOL]                 throw new FlagUsageException("Can't specify stdin."); [EOL]             } [EOL]             if (usingStdin) { [EOL]                 throw new FlagUsageException("Can't specify stdin twice."); [EOL]             } [EOL]             if (!config.outputManifests.isEmpty()) { [EOL]                 throw new FlagUsageException("Manifest files cannot be generated " + "when the input is from stdin."); [EOL]             } [EOL]             if (!config.outputBundles.isEmpty()) { [EOL]                 throw new FlagUsageException("Bundle files cannot be generated " + "when the input is from stdin."); [EOL]             } [EOL]             inputs.add(SourceFile.fromInputStream("stdin", System.in)); [EOL]             usingStdin = true; [EOL]         } [EOL]     } [EOL]     return inputs; [EOL] } <line_num>: 443,472
private List<SourceFile> createSourceInputs(List<String> files) throws FlagUsageException, IOException { [EOL]     if (isInTestMode()) { [EOL]         return inputsSupplierForTesting.get(); [EOL]     } [EOL]     if (files.isEmpty()) { [EOL]         files = Collections.singletonList("-"); [EOL]     } [EOL]     try { [EOL]         return createInputs(files, true); [EOL]     } catch (FlagUsageException e) { [EOL]         throw new FlagUsageException("Bad --js flag. " + e.getMessage()); [EOL]     } [EOL] } <line_num>: 477,490
private List<SourceFile> createExternInputs(List<String> files) throws FlagUsageException, IOException { [EOL]     if (files.isEmpty()) { [EOL]         return ImmutableList.of(SourceFile.fromCode("/dev/null", "")); [EOL]     } [EOL]     try { [EOL]         return createInputs(files, false); [EOL]     } catch (FlagUsageException e) { [EOL]         throw new FlagUsageException("Bad --externs flag. " + e.getMessage()); [EOL]     } [EOL] } <line_num>: 495,505
List<JSModule> createJsModules(List<String> specs, List<String> jsFiles) throws FlagUsageException, IOException { [EOL]     if (isInTestMode()) { [EOL]         return modulesSupplierForTesting.get(); [EOL]     } [EOL]     Preconditions.checkState(specs != null); [EOL]     Preconditions.checkState(!specs.isEmpty()); [EOL]     Preconditions.checkState(jsFiles != null); [EOL]     final int totalNumJsFiles = jsFiles.size(); [EOL]     int nextJsFileIndex = 0; [EOL]     Map<String, JSModule> modulesByName = Maps.newLinkedHashMap(); [EOL]     for (String spec : specs) { [EOL]         String[] parts = spec.split(":"); [EOL]         if (parts.length < 2 || parts.length > 4) { [EOL]             throw new FlagUsageException("Expected 2-4 colon-delimited parts in " + "module spec: " + spec); [EOL]         } [EOL]         String name = parts[0]; [EOL]         checkModuleName(name); [EOL]         if (modulesByName.containsKey(name)) { [EOL]             throw new FlagUsageException("Duplicate module name: " + name); [EOL]         } [EOL]         JSModule module = new JSModule(name); [EOL]         int numJsFiles = -1; [EOL]         try { [EOL]             numJsFiles = Integer.parseInt(parts[1]); [EOL]         } catch (NumberFormatException ignored) { [EOL]             numJsFiles = -1; [EOL]         } [EOL]         if (numJsFiles < 0) { [EOL]             throw new FlagUsageException("Invalid JS file count '" + parts[1] + "' for module: " + name); [EOL]         } [EOL]         if (nextJsFileIndex + numJsFiles > totalNumJsFiles) { [EOL]             throw new FlagUsageException("Not enough JS files specified. Expected " + (nextJsFileIndex + numJsFiles - totalNumJsFiles) + " more in module:" + name); [EOL]         } [EOL]         List<String> moduleJsFiles = jsFiles.subList(nextJsFileIndex, nextJsFileIndex + numJsFiles); [EOL]         for (SourceFile input : createInputs(moduleJsFiles, false)) { [EOL]             module.add(input); [EOL]         } [EOL]         nextJsFileIndex += numJsFiles; [EOL]         if (parts.length > 2) { [EOL]             String depList = parts[2]; [EOL]             if (depList.length() > 0) { [EOL]                 String[] deps = depList.split(","); [EOL]                 for (String dep : deps) { [EOL]                     JSModule other = modulesByName.get(dep); [EOL]                     if (other == null) { [EOL]                         throw new FlagUsageException("Module '" + name + "' depends on unknown module '" + dep + "'. Be sure to list modules in dependency order."); [EOL]                     } [EOL]                     module.addDependency(other); [EOL]                 } [EOL]             } [EOL]         } [EOL]         modulesByName.put(name, module); [EOL]     } [EOL]     if (nextJsFileIndex < totalNumJsFiles) { [EOL]         throw new FlagUsageException("Too many JS files specified. Expected " + nextJsFileIndex + " but found " + totalNumJsFiles); [EOL]     } [EOL]     return Lists.newArrayList(modulesByName.values()); [EOL] } <line_num>: 516,599
protected void checkModuleName(String name) throws FlagUsageException { [EOL]     if (!TokenStream.isJSIdentifier(name)) { [EOL]         throw new FlagUsageException("Invalid module name: '" + name + "'"); [EOL]     } [EOL] } <line_num>: 606,611
static Map<String, String> parseModuleWrappers(List<String> specs, List<JSModule> modules) throws FlagUsageException { [EOL]     Preconditions.checkState(specs != null); [EOL]     Map<String, String> wrappers = Maps.newHashMapWithExpectedSize(modules.size()); [EOL]     for (JSModule m : modules) { [EOL]         wrappers.put(m.getName(), ""); [EOL]     } [EOL]     for (String spec : specs) { [EOL]         int pos = spec.indexOf(':'); [EOL]         if (pos == -1) { [EOL]             throw new FlagUsageException("Expected module wrapper to have " + "<name>:<wrapper> format: " + spec); [EOL]         } [EOL]         String name = spec.substring(0, pos); [EOL]         if (!wrappers.containsKey(name)) { [EOL]             throw new FlagUsageException("Unknown module: '" + name + "'"); [EOL]         } [EOL]         String wrapper = spec.substring(pos + 1); [EOL]         if (!wrapper.contains("%s")) { [EOL]             throw new FlagUsageException("No %s placeholder in module wrapper: '" + wrapper + "'"); [EOL]         } [EOL]         wrappers.put(name, wrapper); [EOL]     } [EOL]     return wrappers; [EOL] } <line_num>: 622,656
private String getModuleOutputFileName(JSModule m) { [EOL]     return config.moduleOutputPathPrefix + m.getName() + ".js"; [EOL] } <line_num>: 658,660
@VisibleForTesting [EOL] void writeModuleOutput(Appendable out, JSModule m) throws FlagUsageException, IOException { [EOL]     if (parsedModuleWrappers == null) { [EOL]         parsedModuleWrappers = parseModuleWrappers(config.moduleWrapper, Lists.newArrayList(compiler.getDegenerateModuleGraph().getAllModules())); [EOL]     } [EOL]     String fileName = getModuleOutputFileName(m); [EOL]     String baseName = new File(fileName).getName(); [EOL]     writeOutput(out, compiler, compiler.toSource(m), parsedModuleWrappers.get(m.getName()).replace("%basename%", baseName), "%s", null); [EOL] } <line_num>: 662,677
static void writeOutput(Appendable out, Compiler compiler, String code, String wrapper, String codePlaceholder, @Nullable Function<String, String> escaper) throws IOException { [EOL]     int pos = wrapper.indexOf(codePlaceholder); [EOL]     if (pos != -1) { [EOL]         String prefix = ""; [EOL]         if (pos > 0) { [EOL]             prefix = wrapper.substring(0, pos); [EOL]             out.append(prefix); [EOL]         } [EOL]         out.append(escaper == null ? code : escaper.apply(code)); [EOL]         int suffixStart = pos + codePlaceholder.length(); [EOL]         if (suffixStart != wrapper.length()) { [EOL]             out.append(wrapper.substring(suffixStart)); [EOL]         } [EOL]         out.append('\n'); [EOL]         if (compiler != null && compiler.getSourceMap() != null) { [EOL]             compiler.getSourceMap().setWrapperPrefix(prefix); [EOL]         } [EOL]     } else { [EOL]         out.append(code); [EOL]         out.append('\n'); [EOL]     } [EOL] } <line_num>: 683,716
private static void maybeCreateDirsForPath(String pathPrefix) { [EOL]     if (pathPrefix.length() > 0) { [EOL]         String dirName = pathPrefix.charAt(pathPrefix.length() - 1) == File.separatorChar ? pathPrefix.substring(0, pathPrefix.length() - 1) : new File(pathPrefix).getParent(); [EOL]         if (dirName != null) { [EOL]             new File(dirName).mkdirs(); [EOL]         } [EOL]     } [EOL] } <line_num>: 722,732
protected int doRun() throws FlagUsageException, IOException { [EOL]     Compiler.setLoggingLevel(Level.parse(config.loggingLevel)); [EOL]     List<SourceFile> externs = createExterns(); [EOL]     compiler = createCompiler(); [EOL]     B options = createOptions(); [EOL]     List<JSModule> modules = null; [EOL]     Result result = null; [EOL]     setRunOptions(options); [EOL]     boolean writeOutputToFile = !config.jsOutputFile.isEmpty(); [EOL]     List<String> outputFileNames = Lists.newArrayList(); [EOL]     if (writeOutputToFile) { [EOL]         outputFileNames.add(config.jsOutputFile); [EOL]         jsOutput = fileNameToLegacyOutputWriter(config.jsOutputFile); [EOL]     } else if (jsOutput instanceof OutputStream) { [EOL]         jsOutput = streamToLegacyOutputWriter((OutputStream) jsOutput); [EOL]     } [EOL]     List<String> jsFiles = config.js; [EOL]     List<String> moduleSpecs = config.module; [EOL]     boolean createCommonJsModules = false; [EOL]     if (options.processCommonJSModules) { [EOL]         if (moduleSpecs.size() == 1 && "auto".equals(moduleSpecs.get(0))) { [EOL]             createCommonJsModules = true; [EOL]             moduleSpecs.remove(0); [EOL]         } [EOL]     } [EOL]     if (!moduleSpecs.isEmpty()) { [EOL]         modules = createJsModules(moduleSpecs, jsFiles); [EOL]         for (JSModule m : modules) { [EOL]             outputFileNames.add(getModuleOutputFileName(m)); [EOL]         } [EOL]         if (config.skipNormalOutputs) { [EOL]             compiler.initModules(externs, modules, options); [EOL]         } else { [EOL]             result = compiler.compileModules(externs, modules, options); [EOL]         } [EOL]     } else { [EOL]         List<SourceFile> inputs = createSourceInputs(jsFiles); [EOL]         if (config.skipNormalOutputs) { [EOL]             compiler.init(externs, inputs, options); [EOL]         } else { [EOL]             result = compiler.compile(externs, inputs, options); [EOL]         } [EOL]     } [EOL]     if (createCommonJsModules) { [EOL]         modules = Lists.newArrayList(compiler.getDegenerateModuleGraph().getAllModules()); [EOL]         for (JSModule m : modules) { [EOL]             outputFileNames.add(getModuleOutputFileName(m)); [EOL]         } [EOL]     } [EOL]     for (String outputFileName : outputFileNames) { [EOL]         if (compiler.getSourceFileByName(outputFileName) != null) { [EOL]             compiler.report(JSError.make(OUTPUT_SAME_AS_INPUT_ERROR, outputFileName)); [EOL]             return 1; [EOL]         } [EOL]     } [EOL]     int errCode = processResults(result, modules, options); [EOL]     if (jsOutput instanceof Flushable) { [EOL]         ((Flushable) jsOutput).flush(); [EOL]     } [EOL]     return errCode; [EOL] } <line_num>: 739,815
int processResults(Result result, List<JSModule> modules, B options) throws FlagUsageException, IOException { [EOL]     if (config.computePhaseOrdering) { [EOL]         return 0; [EOL]     } [EOL]     if (config.printPassGraph) { [EOL]         if (compiler.getRoot() == null) { [EOL]             return 1; [EOL]         } else { [EOL]             jsOutput.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph())); [EOL]             jsOutput.append('\n'); [EOL]             return 0; [EOL]         } [EOL]     } [EOL]     if (config.printAst) { [EOL]         if (compiler.getRoot() == null) { [EOL]             return 1; [EOL]         } else { [EOL]             ControlFlowGraph<Node> cfg = compiler.computeCFG(); [EOL]             DotFormatter.appendDot(compiler.getRoot().getLastChild(), cfg, jsOutput); [EOL]             jsOutput.append('\n'); [EOL]             return 0; [EOL]         } [EOL]     } [EOL]     if (config.printTree) { [EOL]         if (compiler.getRoot() == null) { [EOL]             jsOutput.append("Code contains errors; no tree was generated.\n"); [EOL]             return 1; [EOL]         } else { [EOL]             compiler.getRoot().appendStringTree(jsOutput); [EOL]             jsOutput.append("\n"); [EOL]             return 0; [EOL]         } [EOL]     } [EOL]     rootRelativePathsMap = constructRootRelativePathsMap(); [EOL]     if (config.skipNormalOutputs) { [EOL]         outputManifest(); [EOL]         outputBundle(); [EOL]         outputModuleGraphJson(); [EOL]         return 0; [EOL]     } else if (result.success) { [EOL]         outputModuleGraphJson(); [EOL]         if (modules == null) { [EOL]             outputSingleBinary(); [EOL]             outputSourceMap(options, config.jsOutputFile); [EOL]         } else { [EOL]             outputModuleBinaryAndSourceMaps(modules, options); [EOL]         } [EOL]         if (options.externExportsPath != null) { [EOL]             Writer eeOut = openExternExportsStream(options, config.jsOutputFile); [EOL]             eeOut.append(result.externExport); [EOL]             eeOut.close(); [EOL]         } [EOL]         outputNameMaps(options); [EOL]         outputManifest(); [EOL]         outputBundle(); [EOL]     } [EOL]     return Math.min(result.errors.length, 0x7f); [EOL] } <line_num>: 820,897
Function<String, String> getJavascriptEscaper() { [EOL]     throw new UnsupportedOperationException("SourceCodeEscapers is not in the standard release of Guava yet :("); [EOL] } <line_num>: 899,902
void outputSingleBinary() throws IOException { [EOL]     Function<String, String> escaper = null; [EOL]     String marker = OUTPUT_MARKER; [EOL]     if (config.outputWrapper.contains(OUTPUT_MARKER_JS_STRING)) { [EOL]         marker = OUTPUT_MARKER_JS_STRING; [EOL]         escaper = getJavascriptEscaper(); [EOL]     } [EOL]     writeOutput(jsOutput, compiler, compiler.toSource(), config.outputWrapper, marker, escaper); [EOL] } <line_num>: 904,915
private void outputModuleBinaryAndSourceMaps(List<JSModule> modules, B options) throws FlagUsageException, IOException { [EOL]     parsedModuleWrappers = parseModuleWrappers(config.moduleWrapper, modules); [EOL]     maybeCreateDirsForPath(config.moduleOutputPathPrefix); [EOL]     Writer mapOut = null; [EOL]     if (!shouldGenerateMapPerModule(options)) { [EOL]         mapOut = fileNameToOutputWriter2(expandSourceMapPath(options, null)); [EOL]     } [EOL]     for (JSModule m : modules) { [EOL]         if (shouldGenerateMapPerModule(options)) { [EOL]             mapOut = fileNameToOutputWriter2(expandSourceMapPath(options, m)); [EOL]         } [EOL]         Writer writer = fileNameToLegacyOutputWriter(getModuleOutputFileName(m)); [EOL]         if (options.sourceMapOutputPath != null) { [EOL]             compiler.getSourceMap().reset(); [EOL]         } [EOL]         writeModuleOutput(writer, m); [EOL]         if (options.sourceMapOutputPath != null) { [EOL]             compiler.getSourceMap().appendTo(mapOut, m.getName()); [EOL]         } [EOL]         writer.close(); [EOL]         if (shouldGenerateMapPerModule(options) && mapOut != null) { [EOL]             mapOut.close(); [EOL]             mapOut = null; [EOL]         } [EOL]     } [EOL]     if (mapOut != null) { [EOL]         mapOut.close(); [EOL]     } [EOL] } <line_num>: 917,962
private Charset getInputCharset() throws FlagUsageException { [EOL]     if (!config.charset.isEmpty()) { [EOL]         if (!Charset.isSupported(config.charset)) { [EOL]             throw new FlagUsageException(config.charset + " is not a valid charset name."); [EOL]         } [EOL]         return Charset.forName(config.charset); [EOL]     } [EOL]     return Charsets.UTF_8; [EOL] } <line_num>: 971,980
private String getLegacyOutputCharset() throws FlagUsageException { [EOL]     if (!config.charset.isEmpty()) { [EOL]         if (!Charset.isSupported(config.charset)) { [EOL]             throw new FlagUsageException(config.charset + " is not a valid charset name."); [EOL]         } [EOL]         return config.charset; [EOL]     } [EOL]     return "US-ASCII"; [EOL] } <line_num>: 994,1003
private Charset getOutputCharset2() throws FlagUsageException { [EOL]     if (!config.charset.isEmpty()) { [EOL]         if (!Charset.isSupported(config.charset)) { [EOL]             throw new FlagUsageException(config.charset + " is not a valid charset name."); [EOL]         } [EOL]         return Charset.forName(config.charset); [EOL]     } [EOL]     return Charsets.UTF_8; [EOL] } <line_num>: 1009,1018
protected List<SourceFile> createExterns() throws FlagUsageException, IOException { [EOL]     return isInTestMode() ? externsSupplierForTesting.get() : createExternInputs(config.externs); [EOL] } <line_num>: 1020,1024
private boolean shouldGenerateMapPerModule(B options) { [EOL]     return options.sourceMapOutputPath != null && options.sourceMapOutputPath.contains("%outname%"); [EOL] } <line_num>: 1031,1034
private Writer openExternExportsStream(B options, String path) throws IOException { [EOL]     if (options.externExportsPath == null) { [EOL]         return null; [EOL]     } [EOL]     String exPath = options.externExportsPath; [EOL]     if (!exPath.contains(File.separator)) { [EOL]         File outputFile = new File(path); [EOL]         exPath = outputFile.getParent() + File.separatorChar + exPath; [EOL]     } [EOL]     return fileNameToOutputWriter2(exPath); [EOL] } <line_num>: 1044,1058
private String expandCommandLinePath(String path, JSModule forModule) { [EOL]     String sub; [EOL]     if (forModule != null) { [EOL]         sub = config.moduleOutputPathPrefix + forModule.getName() + ".js"; [EOL]     } else if (!config.module.isEmpty()) { [EOL]         sub = config.moduleOutputPathPrefix; [EOL]     } else { [EOL]         sub = config.jsOutputFile; [EOL]     } [EOL]     return path.replace("%outname%", sub); [EOL] } <line_num>: 1075,1086
@VisibleForTesting [EOL] String expandSourceMapPath(B options, JSModule forModule) { [EOL]     if (Strings.isNullOrEmpty(options.sourceMapOutputPath)) { [EOL]         return null; [EOL]     } [EOL]     return expandCommandLinePath(options.sourceMapOutputPath, forModule); [EOL] } <line_num>: 1089,1095
private Writer fileNameToLegacyOutputWriter(String fileName) throws IOException { [EOL]     if (fileName == null) { [EOL]         return null; [EOL]     } [EOL]     if (testMode) { [EOL]         return new StringWriter(); [EOL]     } [EOL]     return streamToLegacyOutputWriter(filenameToOutputStream(fileName)); [EOL] } <line_num>: 1101,1111
private Writer fileNameToOutputWriter2(String fileName) throws IOException { [EOL]     if (fileName == null) { [EOL]         return null; [EOL]     } [EOL]     if (testMode) { [EOL]         return new StringWriter(); [EOL]     } [EOL]     return streamToOutputWriter2(filenameToOutputStream(fileName)); [EOL] } <line_num>: 1117,1126
protected OutputStream filenameToOutputStream(String fileName) throws IOException { [EOL]     if (fileName == null) { [EOL]         return null; [EOL]     } [EOL]     return new FileOutputStream(fileName); [EOL] } <line_num>: 1132,1138
private Writer streamToLegacyOutputWriter(OutputStream stream) throws IOException { [EOL]     if (legacyOutputCharset == null) { [EOL]         return new BufferedWriter(new OutputStreamWriter(stream)); [EOL]     } else { [EOL]         return new BufferedWriter(new OutputStreamWriter(stream, legacyOutputCharset)); [EOL]     } [EOL] } <line_num>: 1143,1152
private Writer streamToOutputWriter2(OutputStream stream) { [EOL]     if (outputCharset2 == null) { [EOL]         return new BufferedWriter(new OutputStreamWriter(stream)); [EOL]     } else { [EOL]         return new BufferedWriter(new OutputStreamWriter(stream, outputCharset2)); [EOL]     } [EOL] } <line_num>: 1157,1165
private void outputSourceMap(B options, String associatedName) throws IOException { [EOL]     if (Strings.isNullOrEmpty(options.sourceMapOutputPath)) { [EOL]         return; [EOL]     } [EOL]     String outName = expandSourceMapPath(options, null); [EOL]     Writer out = fileNameToOutputWriter2(outName); [EOL]     compiler.getSourceMap().appendTo(out, associatedName); [EOL]     out.close(); [EOL] } <line_num>: 1173,1183
private String getMapPath(String outputFile) { [EOL]     String basePath = ""; [EOL]     if (outputFile.equals("")) { [EOL]         if (!config.moduleOutputPathPrefix.equals("")) { [EOL]             basePath = config.moduleOutputPathPrefix; [EOL]         } else { [EOL]             basePath = "jscompiler"; [EOL]         } [EOL]     } else { [EOL]         File file = new File(outputFile); [EOL]         String outputFileName = file.getName(); [EOL]         if (outputFileName.endsWith(".js")) { [EOL]             outputFileName = outputFileName.substring(0, outputFileName.length() - 3); [EOL]         } [EOL]         basePath = file.getParent() + File.separatorChar + outputFileName; [EOL]     } [EOL]     return basePath; [EOL] } <line_num>: 1191,1218
private void outputNameMaps(B options) throws FlagUsageException, IOException { [EOL]     String propertyMapOutputPath = null; [EOL]     String variableMapOutputPath = null; [EOL]     String functionInformationMapOutputPath = null; [EOL]     if (config.createNameMapFiles) { [EOL]         String basePath = getMapPath(config.jsOutputFile); [EOL]         propertyMapOutputPath = basePath + "_props_map.out"; [EOL]         variableMapOutputPath = basePath + "_vars_map.out"; [EOL]         functionInformationMapOutputPath = basePath + "_functions_map.out"; [EOL]     } [EOL]     if (!config.variableMapOutputFile.equals("")) { [EOL]         if (variableMapOutputPath != null) { [EOL]             throw new FlagUsageException("The flags variable_map_output_file and " + "create_name_map_files cannot both be used simultaniously."); [EOL]         } [EOL]         variableMapOutputPath = config.variableMapOutputFile; [EOL]     } [EOL]     if (!config.propertyMapOutputFile.equals("")) { [EOL]         if (propertyMapOutputPath != null) { [EOL]             throw new FlagUsageException("The flags property_map_output_file and " + "create_name_map_files cannot both be used simultaniously."); [EOL]         } [EOL]         propertyMapOutputPath = config.propertyMapOutputFile; [EOL]     } [EOL]     if (variableMapOutputPath != null) { [EOL]         if (compiler.getVariableMap() != null) { [EOL]             compiler.getVariableMap().save(variableMapOutputPath); [EOL]         } [EOL]     } [EOL]     if (propertyMapOutputPath != null) { [EOL]         if (compiler.getPropertyMap() != null) { [EOL]             compiler.getPropertyMap().save(propertyMapOutputPath); [EOL]         } [EOL]     } [EOL]     if (functionInformationMapOutputPath != null) { [EOL]         if (compiler.getFunctionalInformationMap() != null) { [EOL]             OutputStream file = filenameToOutputStream(functionInformationMapOutputPath); [EOL]             CodedOutputStream outputStream = CodedOutputStream.newInstance(file); [EOL]             compiler.getFunctionalInformationMap().writeTo(outputStream); [EOL]             outputStream.flush(); [EOL]             file.flush(); [EOL]             file.close(); [EOL]         } [EOL]     } [EOL] } <line_num>: 1224,1283
@VisibleForTesting [EOL] static void createDefineOrTweakReplacements(List<String> definitions, CompilerOptions options, boolean tweaks) { [EOL]     for (String override : definitions) { [EOL]         String[] assignment = override.split("=", 2); [EOL]         String defName = assignment[0]; [EOL]         if (defName.length() > 0) { [EOL]             String defValue = assignment.length == 1 ? "true" : assignment[1]; [EOL]             boolean isTrue = defValue.equals("true"); [EOL]             boolean isFalse = defValue.equals("false"); [EOL]             if (isTrue || isFalse) { [EOL]                 if (tweaks) { [EOL]                     options.setTweakToBooleanLiteral(defName, isTrue); [EOL]                 } else { [EOL]                     options.setDefineToBooleanLiteral(defName, isTrue); [EOL]                 } [EOL]                 continue; [EOL]             } else if (defValue.length() > 1 && ((defValue.charAt(0) == '\'' && defValue.charAt(defValue.length() - 1) == '\'') || (defValue.charAt(0) == '\"' && defValue.charAt(defValue.length() - 1) == '\"'))) { [EOL]                 String maybeStringVal = defValue.substring(1, defValue.length() - 1); [EOL]                 if (maybeStringVal.indexOf(defValue.charAt(0)) == -1) { [EOL]                     if (tweaks) { [EOL]                         options.setTweakToStringLiteral(defName, maybeStringVal); [EOL]                     } else { [EOL]                         options.setDefineToStringLiteral(defName, maybeStringVal); [EOL]                     } [EOL]                     continue; [EOL]                 } [EOL]             } else { [EOL]                 try { [EOL]                     double value = Double.parseDouble(defValue); [EOL]                     if (tweaks) { [EOL]                         options.setTweakToDoubleLiteral(defName, value); [EOL]                     } else { [EOL]                         options.setDefineToDoubleLiteral(defName, value); [EOL]                     } [EOL]                     continue; [EOL]                 } catch (NumberFormatException e) { [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (tweaks) { [EOL]             throw new RuntimeException("--tweak flag syntax invalid: " + override); [EOL]         } [EOL]         throw new RuntimeException("--define flag syntax invalid: " + override); [EOL]     } [EOL] } <line_num>: 1293,1352
private boolean shouldGenerateOutputPerModule(String output) { [EOL]     return !config.module.isEmpty() && output != null && output.contains("%outname%"); [EOL] } <line_num>: 1358,1361
private void outputManifest() throws IOException { [EOL]     outputManifestOrBundle(config.outputManifests, true); [EOL] } <line_num>: 1363,1365
private void outputBundle() throws IOException { [EOL]     outputManifestOrBundle(config.outputBundles, false); [EOL] } <line_num>: 1367,1369
private void outputManifestOrBundle(List<String> outputFiles, boolean isManifest) throws IOException { [EOL]     if (outputFiles.isEmpty()) { [EOL]         return; [EOL]     } [EOL]     for (String output : outputFiles) { [EOL]         if (output.isEmpty()) { [EOL]             continue; [EOL]         } [EOL]         if (shouldGenerateOutputPerModule(output)) { [EOL]             JSModuleGraph graph = compiler.getDegenerateModuleGraph(); [EOL]             Iterable<JSModule> modules = graph.getAllModules(); [EOL]             for (JSModule module : modules) { [EOL]                 Writer out = fileNameToOutputWriter2(expandCommandLinePath(output, module)); [EOL]                 if (isManifest) { [EOL]                     printManifestTo(module.getInputs(), out); [EOL]                 } else { [EOL]                     printBundleTo(module.getInputs(), out); [EOL]                 } [EOL]                 out.close(); [EOL]             } [EOL]         } else { [EOL]             Writer out = fileNameToOutputWriter2(expandCommandLinePath(output, null)); [EOL]             if (config.module.isEmpty()) { [EOL]                 if (isManifest) { [EOL]                     printManifestTo(compiler.getInputsInOrder(), out); [EOL]                 } else { [EOL]                     printBundleTo(compiler.getInputsInOrder(), out); [EOL]                 } [EOL]             } else { [EOL]                 printModuleGraphManifestOrBundleTo(compiler.getDegenerateModuleGraph(), out, isManifest); [EOL]             } [EOL]             out.close(); [EOL]         } [EOL]     } [EOL] } <line_num>: 1375,1417
private void outputModuleGraphJson() throws IOException { [EOL]     if (config.outputModuleDependencies != null && config.outputModuleDependencies != "") { [EOL]         Writer out = fileNameToOutputWriter2(config.outputModuleDependencies); [EOL]         printModuleGraphJsonTo(compiler.getDegenerateModuleGraph(), out); [EOL]         out.close(); [EOL]     } [EOL] } <line_num>: 1422,1429
@VisibleForTesting [EOL] void printModuleGraphJsonTo(JSModuleGraph graph, Appendable out) throws IOException { [EOL]     out.append(compiler.getDegenerateModuleGraph().toJson().toString()); [EOL] } <line_num>: 1434,1438
@VisibleForTesting [EOL] void printModuleGraphManifestOrBundleTo(JSModuleGraph graph, Appendable out, boolean isManifest) throws IOException { [EOL]     Joiner commas = Joiner.on(","); [EOL]     boolean requiresNewline = false; [EOL]     for (JSModule module : graph.getAllModules()) { [EOL]         if (requiresNewline) { [EOL]             out.append("\n"); [EOL]         } [EOL]         if (isManifest) { [EOL]             String dependencies = commas.join(module.getSortedDependencyNames()); [EOL]             out.append(String.format("{%s%s}\n", module.getName(), dependencies.isEmpty() ? "" : ":" + dependencies)); [EOL]             printManifestTo(module.getInputs(), out); [EOL]         } else { [EOL]             printBundleTo(module.getInputs(), out); [EOL]         } [EOL]         requiresNewline = true; [EOL]     } [EOL] } <line_num>: 1443,1467
private void printManifestTo(Iterable<CompilerInput> inputs, Appendable out) throws IOException { [EOL]     for (CompilerInput input : inputs) { [EOL]         String rootRelativePath = rootRelativePathsMap.get(input.getName()); [EOL]         String displayName = rootRelativePath != null ? rootRelativePath : input.getName(); [EOL]         out.append(displayName); [EOL]         out.append("\n"); [EOL]     } [EOL] } <line_num>: 1473,1483
private void printBundleTo(Iterable<CompilerInput> inputs, Appendable out) throws IOException { [EOL]     for (CompilerInput input : inputs) { [EOL]         if (input.getName().equals(Compiler.createFillFileName(Compiler.SINGLETON_MODULE_NAME))) { [EOL]             Preconditions.checkState(1 == Iterables.size(inputs)); [EOL]             return; [EOL]         } [EOL]         String rootRelativePath = rootRelativePathsMap.get(input.getName()); [EOL]         String displayName = rootRelativePath != null ? rootRelativePath : input.getName(); [EOL]         File file = new File(input.getName()); [EOL]         out.append("//"); [EOL]         out.append(displayName); [EOL]         out.append("\n"); [EOL]         Files.copy(file, inputCharset, out); [EOL]         out.append("\n"); [EOL]     } [EOL] } <line_num>: 1489,1520
private Map<String, String> constructRootRelativePathsMap() { [EOL]     Map<String, String> rootRelativePathsMap = Maps.newLinkedHashMap(); [EOL]     for (String mapString : config.manifestMaps) { [EOL]         int colonIndex = mapString.indexOf(':'); [EOL]         Preconditions.checkState(colonIndex > 0); [EOL]         String execPath = mapString.substring(0, colonIndex); [EOL]         String rootRelativePath = mapString.substring(colonIndex + 1); [EOL]         Preconditions.checkState(rootRelativePath.indexOf(':') == -1); [EOL]         rootRelativePathsMap.put(execPath, rootRelativePath); [EOL]     } [EOL]     return rootRelativePathsMap; [EOL] } <line_num>: 1526,1537
private void recordStartRun() { [EOL]     lastStartTime = System.currentTimeMillis(); [EOL]     PhaseOptimizer.clearLoopsRun(); [EOL] } <line_num>: 1548,1551
private void recordEndRun() { [EOL]     long endTime = System.currentTimeMillis(); [EOL]     long length = endTime - lastStartTime; [EOL]     worstRunTime = Math.max(length, worstRunTime); [EOL]     if (length < bestRunTime) { [EOL]         loopedPassesInBestRun = PhaseOptimizer.getLoopsRun(); [EOL]         bestRunTime = length; [EOL]     } [EOL] } <line_num>: 1556,1564
private void outputBestPhaseOrdering() { [EOL]     try { [EOL]         jsOutput.append("Best time: " + bestRunTime + "\n"); [EOL]         jsOutput.append("Worst time: " + worstRunTime + "\n"); [EOL]         int i = 1; [EOL]         for (List<String> loop : loopedPassesInBestRun) { [EOL]             jsOutput.append("\nLoop " + i + ":\n" + Joiner.on("\n").join(loop) + "\n"); [EOL]             i++; [EOL]         } [EOL]     } catch (IOException e) { [EOL]         throw new RuntimeException("unexpected exception", e); [EOL]     } [EOL] } <line_num>: 1569,1583
CommandLineConfig setPrintTree(boolean printTree) { [EOL]     this.printTree = printTree; [EOL]     return this; [EOL] } <line_num>: 1598,1601
CommandLineConfig setComputePhaseOrdering(boolean computePhaseOrdering) { [EOL]     this.computePhaseOrdering = computePhaseOrdering; [EOL]     return this; [EOL] } <line_num>: 1609,1612
CommandLineConfig setPrintAst(boolean printAst) { [EOL]     this.printAst = printAst; [EOL]     return this; [EOL] } <line_num>: 1620,1623
CommandLineConfig setPrintPassGraph(boolean printPassGraph) { [EOL]     this.printPassGraph = printPassGraph; [EOL]     return this; [EOL] } <line_num>: 1628,1631
CommandLineConfig setJscompDevMode(CompilerOptions.DevMode jscompDevMode) { [EOL]     this.jscompDevMode = jscompDevMode; [EOL]     return this; [EOL] } <line_num>: 1636,1639
CommandLineConfig setLoggingLevel(String loggingLevel) { [EOL]     this.loggingLevel = loggingLevel; [EOL]     return this; [EOL] } <line_num>: 1648,1651
CommandLineConfig setExterns(List<String> externs) { [EOL]     this.externs.clear(); [EOL]     this.externs.addAll(externs); [EOL]     return this; [EOL] } <line_num>: 1658,1662
CommandLineConfig setJs(List<String> js) { [EOL]     this.js.clear(); [EOL]     this.js.addAll(js); [EOL]     return this; [EOL] } <line_num>: 1669,1673
CommandLineConfig setJsOutputFile(String jsOutputFile) { [EOL]     this.jsOutputFile = jsOutputFile; [EOL]     return this; [EOL] } <line_num>: 1680,1683
CommandLineConfig setModule(List<String> module) { [EOL]     this.module.clear(); [EOL]     this.module.addAll(module); [EOL]     return this; [EOL] } <line_num>: 1695,1699
CommandLineConfig setVariableMapInputFile(String variableMapInputFile) { [EOL]     this.variableMapInputFile = variableMapInputFile; [EOL]     return this; [EOL] } <line_num>: 1707,1710
CommandLineConfig setPropertyMapInputFile(String propertyMapInputFile) { [EOL]     this.propertyMapInputFile = propertyMapInputFile; [EOL]     return this; [EOL] } <line_num>: 1718,1721
CommandLineConfig setVariableMapOutputFile(String variableMapOutputFile) { [EOL]     this.variableMapOutputFile = variableMapOutputFile; [EOL]     return this; [EOL] } <line_num>: 1729,1732
CommandLineConfig setCreateNameMapFiles(boolean createNameMapFiles) { [EOL]     this.createNameMapFiles = createNameMapFiles; [EOL]     return this; [EOL] } <line_num>: 1743,1746
CommandLineConfig setPropertyMapOutputFile(String propertyMapOutputFile) { [EOL]     this.propertyMapOutputFile = propertyMapOutputFile; [EOL]     return this; [EOL] } <line_num>: 1754,1757
CommandLineConfig setCodingConvention(CodingConvention codingConvention) { [EOL]     this.codingConvention = codingConvention; [EOL]     return this; [EOL] } <line_num>: 1764,1767
CommandLineConfig setSummaryDetailLevel(int summaryDetailLevel) { [EOL]     this.summaryDetailLevel = summaryDetailLevel; [EOL]     return this; [EOL] } <line_num>: 1778,1781
CommandLineConfig setOutputWrapper(String outputWrapper) { [EOL]     this.outputWrapper = outputWrapper; [EOL]     return this; [EOL] } <line_num>: 1789,1792
CommandLineConfig setModuleWrapper(List<String> moduleWrapper) { [EOL]     this.moduleWrapper.clear(); [EOL]     this.moduleWrapper.addAll(moduleWrapper); [EOL]     return this; [EOL] } <line_num>: 1800,1804
CommandLineConfig setModuleOutputPathPrefix(String moduleOutputPathPrefix) { [EOL]     this.moduleOutputPathPrefix = moduleOutputPathPrefix; [EOL]     return this; [EOL] } <line_num>: 1813,1816
CommandLineConfig setCreateSourceMap(String createSourceMap) { [EOL]     this.createSourceMap = createSourceMap; [EOL]     return this; [EOL] } <line_num>: 1827,1830
CommandLineConfig setSourceMapDetailLevel(SourceMap.DetailLevel level) { [EOL]     this.sourceMapDetailLevel = level; [EOL]     return this; [EOL] } <line_num>: 1838,1841
CommandLineConfig setSourceMapFormat(SourceMap.Format format) { [EOL]     this.sourceMapFormat = format; [EOL]     return this; [EOL] } <line_num>: 1849,1852
CommandLineConfig setWarningGuardSpec(WarningGuardSpec spec) { [EOL]     this.warningGuards = spec; [EOL]     return this; [EOL] } <line_num>: 1859,1862
CommandLineConfig setDefine(List<String> define) { [EOL]     this.define.clear(); [EOL]     this.define.addAll(define); [EOL]     return this; [EOL] } <line_num>: 1873,1877
CommandLineConfig setTweak(List<String> tweak) { [EOL]     this.tweak.clear(); [EOL]     this.tweak.addAll(tweak); [EOL]     return this; [EOL] } <line_num>: 1887,1891
CommandLineConfig setTweakProcessing(TweakProcessing tweakProcessing) { [EOL]     this.tweakProcessing = tweakProcessing; [EOL]     return this; [EOL] } <line_num>: 1898,1901
CommandLineConfig setCharset(String charset) { [EOL]     this.charset = charset; [EOL]     return this; [EOL] } <line_num>: 1908,1911
CommandLineConfig setManageClosureDependencies(boolean newVal) { [EOL]     this.manageClosureDependencies = newVal; [EOL]     return this; [EOL] } <line_num>: 1919,1922
CommandLineConfig setOnlyClosureDependencies(boolean newVal) { [EOL]     this.onlyClosureDependencies = newVal; [EOL]     return this; [EOL] } <line_num>: 1931,1934
CommandLineConfig setClosureEntryPoints(List<String> entryPoints) { [EOL]     Preconditions.checkNotNull(entryPoints); [EOL]     this.closureEntryPoints = entryPoints; [EOL]     return this; [EOL] } <line_num>: 1942,1946
CommandLineConfig setOutputManifest(List<String> outputManifests) { [EOL]     this.outputManifests = Lists.newArrayList(); [EOL]     for (String manifestName : outputManifests) { [EOL]         if (!manifestName.isEmpty()) { [EOL]             this.outputManifests.add(manifestName); [EOL]         } [EOL]     } [EOL]     this.outputManifests = ImmutableList.copyOf(this.outputManifests); [EOL]     return this; [EOL] } <line_num>: 1954,1963
CommandLineConfig setOutputModuleDependencies(String outputModuleDependencies) { [EOL]     this.outputModuleDependencies = outputModuleDependencies; [EOL]     return this; [EOL] } <line_num>: 1971,1975
CommandLineConfig setOutputBundle(List<String> outputBundles) { [EOL]     this.outputBundles = outputBundles; [EOL]     return this; [EOL] } <line_num>: 1982,1985
CommandLineConfig setAcceptConstKeyword(boolean acceptConstKeyword) { [EOL]     this.acceptConstKeyword = acceptConstKeyword; [EOL]     return this; [EOL] } <line_num>: 1992,1995
CommandLineConfig setLanguageIn(String languageIn) { [EOL]     this.languageIn = languageIn; [EOL]     return this; [EOL] } <line_num>: 2003,2006
CommandLineConfig setSkipNormalOutputs(boolean skipNormalOutputs) { [EOL]     this.skipNormalOutputs = skipNormalOutputs; [EOL]     return this; [EOL] } <line_num>: 2013,2016
CommandLineConfig setManifestMaps(List<String> manifestMaps) { [EOL]     this.manifestMaps = manifestMaps; [EOL]     return this; [EOL] } <line_num>: 2023,2026
CommandLineConfig setTransformAMDToCJSModules(boolean transformAMDToCJSModules) { [EOL]     this.transformAMDToCJSModules = transformAMDToCJSModules; [EOL]     return this; [EOL] } <line_num>: 2034,2038
CommandLineConfig setProcessCommonJSModules(boolean processCommonJSModules) { [EOL]     this.processCommonJSModules = processCommonJSModules; [EOL]     return this; [EOL] } <line_num>: 2045,2049
CommandLineConfig setCommonJSModulePathPrefix(String commonJSModulePathPrefix) { [EOL]     this.commonJSModulePathPrefix = commonJSModulePathPrefix; [EOL]     return this; [EOL] } <line_num>: 2058,2062
CommandLineConfig setWarningsWhitelistFile(String fileName) { [EOL]     this.warningsWhitelistFile = fileName; [EOL]     return this; [EOL] } <line_num>: 2069,2072
protected void add(CheckLevel level, String groupName) { [EOL]     entries.add(new Entry(level, groupName)); [EOL] } <line_num>: 2093,2095
protected void clear() { [EOL]     entries.clear(); [EOL] } <line_num>: 2097,2099
