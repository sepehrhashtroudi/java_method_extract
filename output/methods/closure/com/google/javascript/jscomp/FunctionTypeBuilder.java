FunctionTypeBuilder(String fnName, AbstractCompiler compiler, Node errorRoot, String sourceName, Scope scope) { [EOL]     Preconditions.checkNotNull(errorRoot); [EOL]     this.fnName = fnName == null ? "" : fnName; [EOL]     this.codingConvention = compiler.getCodingConvention(); [EOL]     this.typeRegistry = compiler.getTypeRegistry(); [EOL]     this.errorRoot = errorRoot; [EOL]     this.sourceName = sourceName; [EOL]     this.compiler = compiler; [EOL]     this.scope = scope; [EOL] } <line_num>: 201,212
AstFunctionContents(Node n) { [EOL]     this.n = n; [EOL] } <line_num>: 849,851
@Override [EOL] public boolean apply(JSType type) { [EOL]     ObjectType objectType = ObjectType.cast(type); [EOL]     if (objectType == null) { [EOL]         reportWarning(EXTENDS_NON_OBJECT, fnName, type.toString()); [EOL]         return false; [EOL]     } else if (objectType.isEmptyType()) { [EOL]         reportWarning(RESOLVED_TAG_EMPTY, "@extends", fnName); [EOL]         return false; [EOL]     } else if (objectType.isUnknownType()) { [EOL]         if (hasMoreTagsToResolve(objectType)) { [EOL]             return true; [EOL]         } else { [EOL]             reportWarning(RESOLVED_TAG_EMPTY, "@extends", fnName); [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         return true; [EOL]     } [EOL] } <line_num>: 147,166
@Override [EOL] public boolean apply(JSType type) { [EOL]     ObjectType objectType = ObjectType.cast(type); [EOL]     if (objectType == null) { [EOL]         reportError(BAD_IMPLEMENTED_TYPE, fnName); [EOL]         return false; [EOL]     } else if (objectType.isEmptyType()) { [EOL]         reportWarning(RESOLVED_TAG_EMPTY, "@implements", fnName); [EOL]         return false; [EOL]     } else if (objectType.isUnknownType()) { [EOL]         if (hasMoreTagsToResolve(objectType)) { [EOL]             return true; [EOL]         } else { [EOL]             reportWarning(RESOLVED_TAG_EMPTY, "@implements", fnName); [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         return true; [EOL]     } [EOL] } <line_num>: 170,189
FunctionTypeBuilder setContents(@Nullable FunctionContents contents) { [EOL]     if (contents != null) { [EOL]         this.contents = contents; [EOL]     } [EOL]     return this; [EOL] } <line_num>: 217,222
FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) { [EOL]     if (oldType == null) { [EOL]         return this; [EOL]     } [EOL]     returnType = oldType.getReturnType(); [EOL]     returnTypeInferred = oldType.isReturnTypeInferred(); [EOL]     if (paramsParent == null) { [EOL]         parametersNode = oldType.getParametersNode(); [EOL]         if (parametersNode == null) { [EOL]             parametersNode = new FunctionParamBuilder(typeRegistry).build(); [EOL]         } [EOL]     } else { [EOL]         FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry); [EOL]         Iterator<Node> oldParams = oldType.getParameters().iterator(); [EOL]         boolean warnedAboutArgList = false; [EOL]         boolean oldParamsListHitOptArgs = false; [EOL]         for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) { [EOL]             if (oldParams.hasNext()) { [EOL]                 Node oldParam = oldParams.next(); [EOL]                 Node newParam = paramBuilder.newParameterFromNode(oldParam); [EOL]                 oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg(); [EOL]                 if (currentParam.getNext() != null && newParam.isVarArgs()) { [EOL]                     newParam.setVarArgs(false); [EOL]                     newParam.setOptionalArg(true); [EOL]                 } [EOL]             } else { [EOL]                 warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam)); [EOL]             } [EOL]         } [EOL]         while (oldParams.hasNext()) { [EOL]             paramBuilder.newOptionalParameterFromNode(oldParams.next()); [EOL]         } [EOL]         parametersNode = paramBuilder.build(); [EOL]     } [EOL]     return this; [EOL] } <line_num>: 233,291
FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) { [EOL]     if (info != null && info.hasReturnType()) { [EOL]         returnType = info.getReturnType().evaluate(scope, typeRegistry); [EOL]         returnTypeInferred = false; [EOL]     } [EOL]     return this; [EOL] } <line_num>: 296,303
FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) { [EOL]     if (info != null) { [EOL]         isConstructor = info.isConstructor(); [EOL]         makesStructs = info.makesStructs(); [EOL]         makesDicts = info.makesDicts(); [EOL]         isInterface = info.isInterface(); [EOL]         if (makesStructs && !isConstructor) { [EOL]             reportWarning(CONSTRUCTOR_REQUIRED, "@struct", fnName); [EOL]         } else if (makesDicts && !isConstructor) { [EOL]             reportWarning(CONSTRUCTOR_REQUIRED, "@dict", fnName); [EOL]         } [EOL]         if (info.hasBaseType()) { [EOL]             if (isConstructor) { [EOL]                 JSType maybeBaseType = info.getBaseType().evaluate(scope, typeRegistry); [EOL]                 if (maybeBaseType != null && maybeBaseType.setValidator(new ExtendedTypeValidator())) { [EOL]                     baseType = (ObjectType) maybeBaseType; [EOL]                 } [EOL]             } else { [EOL]                 reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName); [EOL]             } [EOL]         } [EOL]         if (info.getImplementedInterfaceCount() > 0) { [EOL]             if (isConstructor) { [EOL]                 implementedInterfaces = Lists.newArrayList(); [EOL]                 for (JSTypeExpression t : info.getImplementedInterfaces()) { [EOL]                     JSType maybeInterType = t.evaluate(scope, typeRegistry); [EOL]                     if (maybeInterType != null && maybeInterType.setValidator(new ImplementedTypeValidator())) { [EOL]                         implementedInterfaces.add((ObjectType) maybeInterType); [EOL]                     } [EOL]                 } [EOL]             } else if (isInterface) { [EOL]                 reportWarning(TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName); [EOL]             } else { [EOL]                 reportWarning(CONSTRUCTOR_REQUIRED, "@implements", fnName); [EOL]             } [EOL]         } [EOL]         if (isInterface) { [EOL]             extendedInterfaces = Lists.newArrayList(); [EOL]             for (JSTypeExpression t : info.getExtendedInterfaces()) { [EOL]                 JSType maybeInterfaceType = t.evaluate(scope, typeRegistry); [EOL]                 if (maybeInterfaceType != null && maybeInterfaceType.setValidator(new ExtendedTypeValidator())) { [EOL]                     extendedInterfaces.add((ObjectType) maybeInterfaceType); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] } <line_num>: 309,370
FunctionTypeBuilder inferThisType(JSDocInfo info, JSType type) { [EOL]     inferThisType(info); [EOL]     if (thisType == null) { [EOL]         ObjectType objType = ObjectType.cast(type); [EOL]         if (objType != null && (info == null || !info.hasType())) { [EOL]             thisType = objType; [EOL]         } [EOL]     } [EOL]     return this; [EOL] } <line_num>: 376,388
FunctionTypeBuilder inferThisType(JSDocInfo info) { [EOL]     JSType maybeThisType = null; [EOL]     if (info != null && info.hasThisType()) { [EOL]         maybeThisType = info.getThisType().evaluate(scope, typeRegistry).restrictByNotNullOrUndefined(); [EOL]     } [EOL]     if (maybeThisType != null) { [EOL]         thisType = maybeThisType; [EOL]     } [EOL]     return this; [EOL] } <line_num>: 394,408
FunctionTypeBuilder inferParameterTypes(JSDocInfo info) { [EOL]     Node lp = IR.paramList(); [EOL]     for (String name : info.getParameterNames()) { [EOL]         lp.addChildToBack(IR.name(name)); [EOL]     } [EOL]     return inferParameterTypes(lp, info); [EOL] } <line_num>: 413,421
FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) { [EOL]     if (argsParent == null) { [EOL]         if (info == null) { [EOL]             return this; [EOL]         } else { [EOL]             return inferParameterTypes(info); [EOL]         } [EOL]     } [EOL]     Node oldParameterType = null; [EOL]     if (parametersNode != null) { [EOL]         oldParameterType = parametersNode.getFirstChild(); [EOL]     } [EOL]     FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry); [EOL]     boolean warnedAboutArgList = false; [EOL]     Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames()); [EOL]     boolean foundTemplateType = false; [EOL]     boolean isVarArgs = false; [EOL]     for (Node arg : argsParent.children()) { [EOL]         String argumentName = arg.getString(); [EOL]         allJsDocParams.remove(argumentName); [EOL]         JSType parameterType = null; [EOL]         boolean isOptionalParam = isOptionalParameter(arg, info); [EOL]         isVarArgs = isVarArgsParameter(arg, info); [EOL]         if (info != null && info.hasParameterType(argumentName)) { [EOL]             parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry); [EOL]         } else if (oldParameterType != null && oldParameterType.getJSType() != null) { [EOL]             parameterType = oldParameterType.getJSType(); [EOL]             isOptionalParam = oldParameterType.isOptionalArg(); [EOL]             isVarArgs = oldParameterType.isVarArgs(); [EOL]         } else { [EOL]             parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE); [EOL]         } [EOL]         warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs); [EOL]         if (oldParameterType != null) { [EOL]             oldParameterType = oldParameterType.getNext(); [EOL]         } [EOL]     } [EOL]     if (!isVarArgs) { [EOL]         while (oldParameterType != null && !isVarArgs) { [EOL]             builder.newParameterFromNode(oldParameterType); [EOL]             oldParameterType = oldParameterType.getNext(); [EOL]         } [EOL]     } [EOL]     for (String inexistentName : allJsDocParams) { [EOL]         reportWarning(INEXISTANT_PARAM, inexistentName, fnName); [EOL]     } [EOL]     parametersNode = builder.build(); [EOL]     return this; [EOL] } <line_num>: 427,495
private boolean isOptionalParameter(Node param, @Nullable JSDocInfo info) { [EOL]     if (codingConvention.isOptionalParameter(param)) { [EOL]         return true; [EOL]     } [EOL]     String paramName = param.getString(); [EOL]     return info != null && info.hasParameterType(paramName) && info.getParameterType(paramName).isOptionalArg(); [EOL] } <line_num>: 500,509
private boolean isVarArgsParameter(Node param, @Nullable JSDocInfo info) { [EOL]     if (codingConvention.isVarArgsParameter(param)) { [EOL]         return true; [EOL]     } [EOL]     String paramName = param.getString(); [EOL]     return info != null && info.hasParameterType(paramName) && info.getParameterType(paramName).isVarArgs(); [EOL] } <line_num>: 515,524
FunctionTypeBuilder inferTemplateTypeName(@Nullable JSDocInfo info) { [EOL]     if (info != null) { [EOL]         templateTypeNames = info.getTemplateTypeNames(); [EOL]         typeRegistry.setTemplateTypeNames(templateTypeNames); [EOL]     } [EOL]     return this; [EOL] } <line_num>: 529,535
private boolean addParameter(FunctionParamBuilder builder, JSType paramType, boolean warnedAboutArgList, boolean isOptional, boolean isVarArgs) { [EOL]     boolean emittedWarning = false; [EOL]     if (isOptional) { [EOL]         if (!builder.addOptionalParams(paramType) && !warnedAboutArgList) { [EOL]             reportWarning(VAR_ARGS_MUST_BE_LAST); [EOL]             emittedWarning = true; [EOL]         } [EOL]     } else if (isVarArgs) { [EOL]         if (!builder.addVarArgs(paramType) && !warnedAboutArgList) { [EOL]             reportWarning(VAR_ARGS_MUST_BE_LAST); [EOL]             emittedWarning = true; [EOL]         } [EOL]     } else { [EOL]         if (!builder.addRequiredParams(paramType) && !warnedAboutArgList) { [EOL]             if (builder.hasVarArgs()) { [EOL]                 reportWarning(VAR_ARGS_MUST_BE_LAST); [EOL]             } else { [EOL]                 reportWarning(OPTIONAL_ARG_AT_END); [EOL]             } [EOL]             emittedWarning = true; [EOL]         } [EOL]     } [EOL]     return emittedWarning; [EOL] } <line_num>: 547,577
FunctionType buildAndRegister() { [EOL]     if (returnType == null) { [EOL]         if (!contents.mayHaveNonEmptyReturns() && !contents.mayHaveSingleThrow() && !contents.mayBeFromExterns()) { [EOL]             returnType = typeRegistry.getNativeType(VOID_TYPE); [EOL]             returnTypeInferred = true; [EOL]         } [EOL]     } [EOL]     if (returnType == null) { [EOL]         returnType = typeRegistry.getNativeType(UNKNOWN_TYPE); [EOL]     } [EOL]     if (parametersNode == null) { [EOL]         throw new IllegalStateException("All Function types must have params and a return type"); [EOL]     } [EOL]     FunctionType fnType; [EOL]     if (isConstructor) { [EOL]         fnType = getOrCreateConstructor(); [EOL]     } else if (isInterface) { [EOL]         fnType = typeRegistry.createInterfaceType(fnName, contents.getSourceNode()); [EOL]         if (getScopeDeclaredIn().isGlobal() && !fnName.isEmpty()) { [EOL]             typeRegistry.declareType(fnName, fnType.getInstanceType()); [EOL]         } [EOL]         maybeSetBaseType(fnType); [EOL]     } else { [EOL]         fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(contents.getSourceNode()).withParamsNode(parametersNode).withReturnType(returnType, returnTypeInferred).withTypeOfThis(thisType).withTemplateKeys(templateTypeNames).build(); [EOL]         maybeSetBaseType(fnType); [EOL]     } [EOL]     if (implementedInterfaces != null) { [EOL]         fnType.setImplementedInterfaces(implementedInterfaces); [EOL]     } [EOL]     if (extendedInterfaces != null) { [EOL]         fnType.setExtendedInterfaces(extendedInterfaces); [EOL]     } [EOL]     typeRegistry.clearTemplateTypeNames(); [EOL]     return fnType; [EOL] } <line_num>: 582,644
private void maybeSetBaseType(FunctionType fnType) { [EOL]     if (!fnType.isInterface() && baseType != null) { [EOL]         fnType.setPrototypeBasedOn(baseType); [EOL]     } [EOL] } <line_num>: 646,650
private FunctionType getOrCreateConstructor() { [EOL]     FunctionType fnType = typeRegistry.createConstructorType(fnName, contents.getSourceNode(), parametersNode, returnType, null); [EOL]     JSType existingType = typeRegistry.getType(fnName); [EOL]     if (makesStructs) { [EOL]         fnType.setStruct(); [EOL]     } else if (makesDicts) { [EOL]         fnType.setDict(); [EOL]     } [EOL]     if (existingType != null) { [EOL]         boolean isInstanceObject = existingType.isInstanceType(); [EOL]         if (isInstanceObject || fnName.equals("Function")) { [EOL]             FunctionType existingFn = isInstanceObject ? existingType.toObjectType().getConstructor() : typeRegistry.getNativeFunctionType(FUNCTION_FUNCTION_TYPE); [EOL]             if (existingFn.getSource() == null) { [EOL]                 existingFn.setSource(contents.getSourceNode()); [EOL]             } [EOL]             if (!existingFn.hasEqualCallType(fnType)) { [EOL]                 reportWarning(TYPE_REDEFINITION, fnName, fnType.toString(), existingFn.toString()); [EOL]             } [EOL]             return existingFn; [EOL]         } else { [EOL]         } [EOL]     } [EOL]     maybeSetBaseType(fnType); [EOL]     if (getScopeDeclaredIn().isGlobal() && !fnName.isEmpty()) { [EOL]         typeRegistry.declareType(fnName, fnType.getInstanceType()); [EOL]     } [EOL]     return fnType; [EOL] } <line_num>: 665,706
private void reportWarning(DiagnosticType warning, String... args) { [EOL]     compiler.report(JSError.make(sourceName, errorRoot, warning, args)); [EOL] } <line_num>: 708,710
private void reportError(DiagnosticType error, String... args) { [EOL]     compiler.report(JSError.make(sourceName, errorRoot, error, args)); [EOL] } <line_num>: 712,714
static boolean isFunctionTypeDeclaration(JSDocInfo info) { [EOL]     return info.getParameterCount() > 0 || info.hasReturnType() || info.hasThisType() || info.isConstructor() || info.isInterface(); [EOL] } <line_num>: 719,725
private Scope getScopeDeclaredIn() { [EOL]     int dotIndex = fnName.indexOf("."); [EOL]     if (dotIndex != -1) { [EOL]         String rootVarName = fnName.substring(0, dotIndex); [EOL]         Var rootVar = scope.getVar(rootVarName); [EOL]         if (rootVar != null) { [EOL]             return rootVar.getScope(); [EOL]         } [EOL]     } [EOL]     return scope; [EOL] } <line_num>: 732,742
private static boolean hasMoreTagsToResolve(ObjectType objectType) { [EOL]     Preconditions.checkArgument(objectType.isUnknownType()); [EOL]     if (objectType.getImplicitPrototype() != null) { [EOL]         if (objectType.getImplicitPrototype().isResolved()) { [EOL]             return false; [EOL]         } else { [EOL]             return true; [EOL]         } [EOL]     } else { [EOL]         FunctionType ctor = objectType.getConstructor(); [EOL]         if (ctor != null) { [EOL]             for (ObjectType interfaceType : ctor.getExtendedInterfaces()) { [EOL]                 if (!interfaceType.isResolved()) { [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL] } <line_num>: 751,772
Node getSourceNode(); <line_num>: 777,777
boolean mayBeFromExterns(); <line_num>: 780,780
boolean mayHaveNonEmptyReturns(); <line_num>: 783,783
boolean mayHaveSingleThrow(); <line_num>: 786,786
Iterable<String> getEscapedVarNames(); <line_num>: 789,789
Set<String> getEscapedQualifiedNames(); <line_num>: 792,792
Multiset<String> getAssignedNameCounts(); <line_num>: 795,795
static FunctionContents get() { [EOL]     return singleton; [EOL] } <line_num>: 802,804
@Override [EOL] public Node getSourceNode() { [EOL]     return null; [EOL] } <line_num>: 806,809
@Override [EOL] public boolean mayBeFromExterns() { [EOL]     return true; [EOL] } <line_num>: 811,814
@Override [EOL] public boolean mayHaveNonEmptyReturns() { [EOL]     return true; [EOL] } <line_num>: 816,819
@Override [EOL] public boolean mayHaveSingleThrow() { [EOL]     return true; [EOL] } <line_num>: 821,824
@Override [EOL] public Iterable<String> getEscapedVarNames() { [EOL]     return ImmutableList.of(); [EOL] } <line_num>: 826,829
@Override [EOL] public Set<String> getEscapedQualifiedNames() { [EOL]     return ImmutableSet.of(); [EOL] } <line_num>: 831,834
@Override [EOL] public Multiset<String> getAssignedNameCounts() { [EOL]     return ImmutableMultiset.of(); [EOL] } <line_num>: 836,839
@Override [EOL] public Node getSourceNode() { [EOL]     return n; [EOL] } <line_num>: 853,856
@Override [EOL] public boolean mayBeFromExterns() { [EOL]     return n.isFromExterns(); [EOL] } <line_num>: 858,861
@Override [EOL] public boolean mayHaveNonEmptyReturns() { [EOL]     return hasNonEmptyReturns; [EOL] } <line_num>: 863,866
void recordNonEmptyReturn() { [EOL]     hasNonEmptyReturns = true; [EOL] } <line_num>: 868,870
@Override [EOL] public boolean mayHaveSingleThrow() { [EOL]     Node block = n.getLastChild(); [EOL]     return block.hasOneChild() && block.getFirstChild().isThrow(); [EOL] } <line_num>: 872,876
@Override [EOL] public Iterable<String> getEscapedVarNames() { [EOL]     return escapedVarNames == null ? ImmutableList.<String>of() : escapedVarNames; [EOL] } <line_num>: 878,882
void recordEscapedVarName(String name) { [EOL]     if (escapedVarNames == null) { [EOL]         escapedVarNames = Sets.newHashSet(); [EOL]     } [EOL]     escapedVarNames.add(name); [EOL] } <line_num>: 884,889
@Override [EOL] public Set<String> getEscapedQualifiedNames() { [EOL]     return escapedQualifiedNames == null ? ImmutableSet.<String>of() : escapedQualifiedNames; [EOL] } <line_num>: 891,895
void recordEscapedQualifiedName(String name) { [EOL]     if (escapedQualifiedNames == null) { [EOL]         escapedQualifiedNames = Sets.newHashSet(); [EOL]     } [EOL]     escapedQualifiedNames.add(name); [EOL] } <line_num>: 897,902
@Override [EOL] public Multiset<String> getAssignedNameCounts() { [EOL]     return assignedVarNames; [EOL] } <line_num>: 904,907
void recordAssignedName(String name) { [EOL]     assignedVarNames.add(name); [EOL] } <line_num>: 909,911
