private IRFactory(String sourceString, StaticSourceFile sourceFile, Config config, ErrorReporter errorReporter) { [EOL]     this.sourceString = sourceString; [EOL]     this.sourceFile = sourceFile; [EOL]     this.sourceName = sourceFile == null ? null : sourceFile.getName(); [EOL]     this.config = config; [EOL]     this.errorReporter = errorReporter; [EOL]     this.transformDispatcher = new TransformDispatcher(); [EOL]     this.templateNode = createTemplateNode(); [EOL]     switch(config.languageMode) { [EOL]         case ECMASCRIPT3: [EOL]             reservedKeywords = null; [EOL]             break; [EOL]         case ECMASCRIPT5: [EOL]             reservedKeywords = ES5_RESERVED_KEYWORDS; [EOL]             break; [EOL]         case ECMASCRIPT5_STRICT: [EOL]             reservedKeywords = ES5_STRICT_RESERVED_KEYWORDS; [EOL]             break; [EOL]         default: [EOL]             throw new IllegalStateException("unknown language mode"); [EOL]     } [EOL] } <line_num>: 137,167
private Node createTemplateNode() { [EOL]     Node templateNode = new Node(Token.SCRIPT); [EOL]     templateNode.setStaticSourceFile(sourceFile); [EOL]     return templateNode; [EOL] } <line_num>: 172,177
public static Node transformTree(AstRoot node, StaticSourceFile sourceFile, String sourceString, Config config, ErrorReporter errorReporter) { [EOL]     IRFactory irFactory = new IRFactory(sourceString, sourceFile, config, errorReporter); [EOL]     Node irNode = irFactory.transform(node); [EOL]     if (node.getComments() != null) { [EOL]         for (Comment comment : node.getComments()) { [EOL]             if (comment.getCommentType() == CommentType.JSDOC && !irFactory.parsedComments.contains(comment)) { [EOL]                 irFactory.handlePossibleFileOverviewJsDoc(comment, irNode); [EOL]             } else if (comment.getCommentType() == CommentType.BLOCK_COMMENT) { [EOL]                 irFactory.handleBlockComment(comment); [EOL]             } [EOL]         } [EOL]     } [EOL]     irFactory.setFileOverviewJsDoc(irNode); [EOL]     return irNode; [EOL] } <line_num>: 179,202
private void setFileOverviewJsDoc(Node irNode) { [EOL]     JSDocInfo rootNodeJsDoc = rootNodeJsDocHolder.getJSDocInfo(); [EOL]     if (rootNodeJsDoc != null) { [EOL]         irNode.setJSDocInfo(rootNodeJsDoc); [EOL]         rootNodeJsDoc.setAssociatedNode(irNode); [EOL]     } [EOL]     if (fileOverviewInfo != null) { [EOL]         if ((irNode.getJSDocInfo() != null) && (irNode.getJSDocInfo().getLicense() != null)) { [EOL]             fileOverviewInfo.setLicense(irNode.getJSDocInfo().getLicense()); [EOL]         } [EOL]         irNode.setJSDocInfo(fileOverviewInfo); [EOL]         fileOverviewInfo.setAssociatedNode(irNode); [EOL]     } [EOL] } <line_num>: 204,222
private Node transformBlock(AstNode node) { [EOL]     Node irNode = transform(node); [EOL]     if (!irNode.isBlock()) { [EOL]         if (irNode.isEmpty()) { [EOL]             irNode.setType(Token.BLOCK); [EOL]             irNode.setWasEmptyNode(true); [EOL]         } else { [EOL]             Node newBlock = newNode(Token.BLOCK, irNode); [EOL]             newBlock.setLineno(irNode.getLineno()); [EOL]             newBlock.setCharno(irNode.getCharno()); [EOL]             maybeSetLengthFrom(newBlock, node); [EOL]             irNode = newBlock; [EOL]         } [EOL]     } [EOL]     return irNode; [EOL] } <line_num>: 224,239
private void handleBlockComment(Comment comment) { [EOL]     String value = comment.getValue(); [EOL]     if (value.indexOf("/* @") != -1 || value.indexOf("\n * @") != -1) { [EOL]         errorReporter.warning(SUSPICIOUS_COMMENT_WARNING, sourceName, comment.getLineno(), "", 0); [EOL]     } [EOL] } <line_num>: 244,253
private boolean handlePossibleFileOverviewJsDoc(JsDocInfoParser jsDocParser) { [EOL]     if (jsDocParser.getFileOverviewJSDocInfo() != fileOverviewInfo) { [EOL]         fileOverviewInfo = jsDocParser.getFileOverviewJSDocInfo(); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 258,265
private void handlePossibleFileOverviewJsDoc(Comment comment, Node irNode) { [EOL]     JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, irNode); [EOL]     parsedComments.add(comment); [EOL]     handlePossibleFileOverviewJsDoc(jsDocParser); [EOL] } <line_num>: 267,271
private JSDocInfo handleJsDoc(AstNode node, Node irNode) { [EOL]     Comment comment = node.getJsDocNode(); [EOL]     if (comment != null) { [EOL]         JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, irNode); [EOL]         parsedComments.add(comment); [EOL]         if (!handlePossibleFileOverviewJsDoc(jsDocParser)) { [EOL]             JSDocInfo info = jsDocParser.retrieveAndResetParsedJSDocInfo(); [EOL]             if (info != null) { [EOL]                 validateTypeAnnotations(info, node, irNode); [EOL]             } [EOL]             return info; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 273,287
private void validateTypeAnnotations(JSDocInfo info, AstNode node, Node irNode) { [EOL]     if (info.hasType()) { [EOL]         boolean valid = false; [EOL]         switch(node.getType()) { [EOL]             case com.google.javascript.rhino.head.Token.LP: [EOL]                 valid = node instanceof ParenthesizedExpression; [EOL]                 break; [EOL]             case com.google.javascript.rhino.head.Token.VAR: [EOL]                 valid = true; [EOL]                 break; [EOL]             case com.google.javascript.rhino.head.Token.FUNCTION: [EOL]                 FunctionNode fnNode = (FunctionNode) node; [EOL]                 valid = fnNode.getFunctionType() == FunctionNode.FUNCTION_STATEMENT; [EOL]                 break; [EOL]             case com.google.javascript.rhino.head.Token.NAME: [EOL]                 valid = node.getParent() instanceof ObjectProperty || node.getParent() instanceof CatchClause || node.getParent() instanceof FunctionNode; [EOL]                 break; [EOL]             case com.google.javascript.rhino.head.Token.GET: [EOL]             case com.google.javascript.rhino.head.Token.SET: [EOL]             case com.google.javascript.rhino.head.Token.NUMBER: [EOL]             case com.google.javascript.rhino.head.Token.STRING: [EOL]                 valid = node.getParent() instanceof ObjectProperty; [EOL]                 break; [EOL]             case com.google.javascript.rhino.head.Token.ASSIGN: [EOL]                 if (node instanceof Assignment) { [EOL]                     valid = isExprStmt(node.getParent()) && isPropAccess(((Assignment) node).getLeft()); [EOL]                 } [EOL]                 break; [EOL]             case com.google.javascript.rhino.head.Token.GETPROP: [EOL]             case com.google.javascript.rhino.head.Token.GETELEM: [EOL]                 valid = isExprStmt(node.getParent()); [EOL]                 break; [EOL]         } [EOL]         if (!valid) { [EOL]             errorReporter.warning(MISPLACED_TYPE_ANNOTATION, sourceName, node.getLineno(), "", 0); [EOL]         } [EOL]     } [EOL] } <line_num>: 289,341
private boolean isPropAccess(AstNode node) { [EOL]     return node.getType() == com.google.javascript.rhino.head.Token.GETPROP || node.getType() == com.google.javascript.rhino.head.Token.GETELEM; [EOL] } <line_num>: 343,346
private boolean isExprStmt(AstNode node) { [EOL]     return node.getType() == com.google.javascript.rhino.head.Token.EXPR_RESULT || node.getType() == com.google.javascript.rhino.head.Token.EXPR_VOID; [EOL] } <line_num>: 348,351
private Node transform(AstNode node) { [EOL]     Node irNode = justTransform(node); [EOL]     JSDocInfo jsDocInfo = handleJsDoc(node, irNode); [EOL]     if (jsDocInfo != null) { [EOL]         irNode = maybeInjectCastNode(node, jsDocInfo, irNode); [EOL]         irNode.setJSDocInfo(jsDocInfo); [EOL]     } [EOL]     setSourceInfo(irNode, node); [EOL]     return irNode; [EOL] } <line_num>: 353,362
private Node maybeInjectCastNode(AstNode node, JSDocInfo info, Node irNode) { [EOL]     if (node.getType() == com.google.javascript.rhino.head.Token.LP && node instanceof ParenthesizedExpression && info.hasType() && !irNode.isObjectLit()) { [EOL]         irNode = newNode(Token.CAST, irNode); [EOL]     } [EOL]     return irNode; [EOL] } <line_num>: 364,373
private Node transformNameAsString(Name node) { [EOL]     Node irNode = transformDispatcher.processName(node, true); [EOL]     JSDocInfo jsDocInfo = handleJsDoc(node, irNode); [EOL]     if (jsDocInfo != null) { [EOL]         irNode.setJSDocInfo(jsDocInfo); [EOL]     } [EOL]     setSourceInfo(irNode, node); [EOL]     return irNode; [EOL] } <line_num>: 375,383
private Node transformNumberAsString(NumberLiteral literalNode) { [EOL]     Node irNode = newStringNode(getStringValue(literalNode.getNumber())); [EOL]     JSDocInfo jsDocInfo = handleJsDoc(literalNode, irNode); [EOL]     if (jsDocInfo != null) { [EOL]         irNode.setJSDocInfo(jsDocInfo); [EOL]     } [EOL]     setSourceInfo(irNode, literalNode); [EOL]     return irNode; [EOL] } <line_num>: 385,393
private static String getStringValue(double value) { [EOL]     long longValue = (long) value; [EOL]     if (longValue == value) { [EOL]         return Long.toString(longValue); [EOL]     } else { [EOL]         return Double.toString(value); [EOL]     } [EOL] } <line_num>: 395,404
private void setSourceInfo(Node irNode, AstNode node) { [EOL]     if (irNode.getLineno() == -1) { [EOL]         int lineno = node.getLineno(); [EOL]         irNode.setLineno(lineno); [EOL]         int charno = position2charno(node.getAbsolutePosition()); [EOL]         irNode.setCharno(charno); [EOL]         maybeSetLengthFrom(irNode, node); [EOL]     } [EOL] } <line_num>: 406,417
private JsDocInfoParser createJsDocInfoParser(Comment node, Node irNode) { [EOL]     String comment = node.getValue(); [EOL]     int lineno = node.getLineno(); [EOL]     int position = node.getAbsolutePosition(); [EOL]     int numOpeningChars = 3; [EOL]     JsDocInfoParser jsdocParser = new JsDocInfoParser(new JsDocTokenStream(comment.substring(numOpeningChars), lineno, position2charno(position) + numOpeningChars), node, irNode, config, errorReporter); [EOL]     jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder); [EOL]     jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo); [EOL]     jsdocParser.parse(); [EOL]     return jsdocParser; [EOL] } <line_num>: 430,450
private void maybeSetLengthFrom(Node node, AstNode source) { [EOL]     if (config.isIdeMode) { [EOL]         node.setLength(source.getLength()); [EOL]     } [EOL] } <line_num>: 453,457
private int position2charno(int position) { [EOL]     int lineIndex = sourceString.lastIndexOf('\n', position); [EOL]     if (lineIndex == -1) { [EOL]         return position; [EOL]     } else { [EOL]         return position - lineIndex - 1; [EOL]     } [EOL] } <line_num>: 459,467
private Node justTransform(AstNode node) { [EOL]     return transformDispatcher.process(node); [EOL] } <line_num>: 469,471
private Node processGeneric(com.google.javascript.rhino.head.Node n) { [EOL]     Node node = newNode(transformTokenType(n.getType())); [EOL]     for (com.google.javascript.rhino.head.Node child : n) { [EOL]         node.addChildToBack(transform((AstNode) child)); [EOL]     } [EOL]     return node; [EOL] } <line_num>: 474,481
private Node transformAsString(AstNode n) { [EOL]     Node ret; [EOL]     if (n instanceof Name) { [EOL]         ret = transformNameAsString((Name) n); [EOL]     } else if (n instanceof NumberLiteral) { [EOL]         ret = transformNumberAsString((NumberLiteral) n); [EOL]         ret.putBooleanProp(Node.QUOTED_PROP, true); [EOL]     } else { [EOL]         ret = transform(n); [EOL]         ret.putBooleanProp(Node.QUOTED_PROP, true); [EOL]     } [EOL]     Preconditions.checkState(ret.isString()); [EOL]     return ret; [EOL] } <line_num>: 492,505
@Override [EOL] Node processArrayLiteral(ArrayLiteral literalNode) { [EOL]     if (literalNode.isDestructuring()) { [EOL]         reportDestructuringAssign(literalNode); [EOL]     } [EOL]     Node node = newNode(Token.ARRAYLIT); [EOL]     for (AstNode child : literalNode.getElements()) { [EOL]         Node c = transform(child); [EOL]         node.addChildToBack(c); [EOL]     } [EOL]     return node; [EOL] } <line_num>: 507,519
@Override [EOL] Node processAssignment(Assignment assignmentNode) { [EOL]     Node assign = processInfixExpression(assignmentNode); [EOL]     Node target = assign.getFirstChild(); [EOL]     if (!validAssignmentTarget(target)) { [EOL]         errorReporter.error("invalid assignment target", sourceName, target.getLineno(), "", 0); [EOL]     } [EOL]     return assign; [EOL] } <line_num>: 521,532
@Override [EOL] Node processAstRoot(AstRoot rootNode) { [EOL]     Node node = newNode(Token.SCRIPT); [EOL]     for (com.google.javascript.rhino.head.Node child : rootNode) { [EOL]         node.addChildToBack(transform((AstNode) child)); [EOL]     } [EOL]     parseDirectives(node); [EOL]     return node; [EOL] } <line_num>: 534,542
private void parseDirectives(Node node) { [EOL]     Set<String> directives = null; [EOL]     while (isDirective(node.getFirstChild())) { [EOL]         String directive = node.removeFirstChild().getFirstChild().getString(); [EOL]         if (directives == null) { [EOL]             directives = Sets.newHashSet(directive); [EOL]         } else { [EOL]             directives.add(directive); [EOL]         } [EOL]     } [EOL]     if (directives != null) { [EOL]         node.setDirectives(directives); [EOL]     } [EOL] } <line_num>: 553,568
private boolean isDirective(Node n) { [EOL]     if (n == null) [EOL]         return false; [EOL]     int nType = n.getType(); [EOL]     return nType == Token.EXPR_RESULT && n.getFirstChild().isString() && ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString()); [EOL] } <line_num>: 570,577
@Override [EOL] Node processBlock(Block blockNode) { [EOL]     return processGeneric(blockNode); [EOL] } <line_num>: 579,582
@Override [EOL] Node processBreakStatement(BreakStatement statementNode) { [EOL]     Node node = newNode(Token.BREAK); [EOL]     if (statementNode.getBreakLabel() != null) { [EOL]         Node labelName = transform(statementNode.getBreakLabel()); [EOL]         labelName.setType(Token.LABEL_NAME); [EOL]         node.addChildToBack(labelName); [EOL]     } [EOL]     return node; [EOL] } <line_num>: 584,594
@Override [EOL] Node processCatchClause(CatchClause clauseNode) { [EOL]     AstNode catchVar = clauseNode.getVarName(); [EOL]     Node node = newNode(Token.CATCH, transform(catchVar)); [EOL]     if (clauseNode.getCatchCondition() != null) { [EOL]         errorReporter.error("Catch clauses are not supported", sourceName, clauseNode.getCatchCondition().getLineno(), "", 0); [EOL]     } [EOL]     node.addChildToBack(transformBlock(clauseNode.getBody())); [EOL]     return node; [EOL] } <line_num>: 596,608
@Override [EOL] Node processConditionalExpression(ConditionalExpression exprNode) { [EOL]     return newNode(Token.HOOK, transform(exprNode.getTestExpression()), transform(exprNode.getTrueExpression()), transform(exprNode.getFalseExpression())); [EOL] } <line_num>: 610,617
@Override [EOL] Node processContinueStatement(ContinueStatement statementNode) { [EOL]     Node node = newNode(Token.CONTINUE); [EOL]     if (statementNode.getLabel() != null) { [EOL]         Node labelName = transform(statementNode.getLabel()); [EOL]         labelName.setType(Token.LABEL_NAME); [EOL]         node.addChildToBack(labelName); [EOL]     } [EOL]     return node; [EOL] } <line_num>: 619,629
@Override [EOL] Node processDoLoop(DoLoop loopNode) { [EOL]     return newNode(Token.DO, transformBlock(loopNode.getBody()), transform(loopNode.getCondition())); [EOL] } <line_num>: 631,637
@Override [EOL] Node processElementGet(ElementGet getNode) { [EOL]     return newNode(Token.GETELEM, transform(getNode.getTarget()), transform(getNode.getElement())); [EOL] } <line_num>: 639,645
@Override [EOL] Node processEmptyExpression(EmptyExpression exprNode) { [EOL]     Node node = newNode(Token.EMPTY); [EOL]     return node; [EOL] } <line_num>: 647,651
@Override [EOL] Node processEmptyStatement(EmptyStatement exprNode) { [EOL]     Node node = newNode(Token.EMPTY); [EOL]     return node; [EOL] } <line_num>: 653,657
@Override [EOL] Node processExpressionStatement(ExpressionStatement statementNode) { [EOL]     Node node = newNode(transformTokenType(statementNode.getType())); [EOL]     node.addChildToBack(transform(statementNode.getExpression())); [EOL]     return node; [EOL] } <line_num>: 659,664
@Override [EOL] Node processForInLoop(ForInLoop loopNode) { [EOL]     if (loopNode.isForEach()) { [EOL]         errorReporter.error("unsupported language extension: for each", sourceName, loopNode.getLineno(), "", 0); [EOL]         return newNode(Token.EXPR_RESULT, Node.newNumber(0)); [EOL]     } [EOL]     return newNode(Token.FOR, transform(loopNode.getIterator()), transform(loopNode.getIteratedObject()), transformBlock(loopNode.getBody())); [EOL] } <line_num>: 666,682
@Override [EOL] Node processForLoop(ForLoop loopNode) { [EOL]     Node node = newNode(Token.FOR, transform(loopNode.getInitializer()), transform(loopNode.getCondition()), transform(loopNode.getIncrement())); [EOL]     node.addChildToBack(transformBlock(loopNode.getBody())); [EOL]     return node; [EOL] } <line_num>: 684,693
@Override [EOL] Node processFunctionCall(FunctionCall callNode) { [EOL]     Node node = newNode(transformTokenType(callNode.getType()), transform(callNode.getTarget())); [EOL]     for (AstNode child : callNode.getArguments()) { [EOL]         node.addChildToBack(transform(child)); [EOL]     } [EOL]     node.setLineno(node.getFirstChild().getLineno()); [EOL]     node.setCharno(node.getFirstChild().getCharno()); [EOL]     maybeSetLengthFrom(node, callNode); [EOL]     return node; [EOL] } <line_num>: 695,707
@Override [EOL] Node processFunctionNode(FunctionNode functionNode) { [EOL]     Name name = functionNode.getFunctionName(); [EOL]     Boolean isUnnamedFunction = false; [EOL]     if (name == null) { [EOL]         int functionType = functionNode.getFunctionType(); [EOL]         if (functionType != FunctionNode.FUNCTION_EXPRESSION) { [EOL]             errorReporter.error("unnamed function statement", sourceName, functionNode.getLineno(), "", 0); [EOL]             return newNode(Token.EXPR_RESULT, Node.newNumber(0)); [EOL]         } [EOL]         name = new Name(); [EOL]         name.setIdentifier(""); [EOL]         isUnnamedFunction = true; [EOL]     } [EOL]     Node node = newNode(Token.FUNCTION); [EOL]     Node newName = transform(name); [EOL]     if (isUnnamedFunction) { [EOL]         newName.setLineno(functionNode.getLineno()); [EOL]         int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp(); [EOL]         newName.setCharno(position2charno(lpColumn)); [EOL]         maybeSetLengthFrom(newName, name); [EOL]     } [EOL]     node.addChildToBack(newName); [EOL]     Node lp = newNode(Token.PARAM_LIST); [EOL]     Name fnName = functionNode.getFunctionName(); [EOL]     if (fnName != null) { [EOL]         lp.setLineno(fnName.getLineno()); [EOL]     } else { [EOL]         lp.setLineno(functionNode.getLineno()); [EOL]     } [EOL]     int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition(); [EOL]     lp.setCharno(position2charno(lparenCharno)); [EOL]     for (AstNode param : functionNode.getParams()) { [EOL]         Node paramNode = transform(param); [EOL]         if (paramNode.isName()) { [EOL]             lp.addChildToBack(paramNode); [EOL]         } else { [EOL]             Preconditions.checkState(config.isIdeMode || paramNode.isObjectLit() || paramNode.isArrayLit()); [EOL]         } [EOL]     } [EOL]     node.addChildToBack(lp); [EOL]     Node bodyNode = transform(functionNode.getBody()); [EOL]     if (!bodyNode.isBlock()) { [EOL]         Preconditions.checkState(config.isIdeMode); [EOL]         bodyNode = IR.block(); [EOL]     } [EOL]     parseDirectives(bodyNode); [EOL]     node.addChildToBack(bodyNode); [EOL]     return node; [EOL] } <line_num>: 709,791
@Override [EOL] Node processIfStatement(IfStatement statementNode) { [EOL]     Node node = newNode(Token.IF); [EOL]     node.addChildToBack(transform(statementNode.getCondition())); [EOL]     node.addChildToBack(transformBlock(statementNode.getThenPart())); [EOL]     if (statementNode.getElsePart() != null) { [EOL]         node.addChildToBack(transformBlock(statementNode.getElsePart())); [EOL]     } [EOL]     return node; [EOL] } <line_num>: 793,802
@Override [EOL] Node processInfixExpression(InfixExpression exprNode) { [EOL]     Node n = newNode(transformTokenType(exprNode.getType()), transform(exprNode.getLeft()), transform(exprNode.getRight())); [EOL]     n.setLineno(exprNode.getLineno()); [EOL]     n.setCharno(position2charno(exprNode.getAbsolutePosition())); [EOL]     maybeSetLengthFrom(n, exprNode); [EOL]     return n; [EOL] } <line_num>: 804,814
@Override [EOL] Node processKeywordLiteral(KeywordLiteral literalNode) { [EOL]     return newNode(transformTokenType(literalNode.getType())); [EOL] } <line_num>: 816,819
@Override [EOL] Node processLabel(Label labelNode) { [EOL]     return newStringNode(Token.LABEL_NAME, labelNode.getName()); [EOL] } <line_num>: 821,824
@Override [EOL] Node processLabeledStatement(LabeledStatement statementNode) { [EOL]     Node node = newNode(Token.LABEL); [EOL]     Node prev = null; [EOL]     Node cur = node; [EOL]     for (Label label : statementNode.getLabels()) { [EOL]         if (prev != null) { [EOL]             prev.addChildToBack(cur); [EOL]         } [EOL]         cur.addChildToBack(transform(label)); [EOL]         cur.setLineno(label.getLineno()); [EOL]         maybeSetLengthFrom(cur, label); [EOL]         int clauseAbsolutePosition = position2charno(label.getAbsolutePosition()); [EOL]         cur.setCharno(clauseAbsolutePosition); [EOL]         prev = cur; [EOL]         cur = newNode(Token.LABEL); [EOL]     } [EOL]     prev.addChildToBack(transform(statementNode.getStatement())); [EOL]     return node; [EOL] } <line_num>: 826,849
@Override [EOL] Node processName(Name nameNode) { [EOL]     return processName(nameNode, false); [EOL] } <line_num>: 851,854
Node processName(Name nameNode, boolean asString) { [EOL]     if (asString) { [EOL]         return newStringNode(Token.STRING, nameNode.getIdentifier()); [EOL]     } else { [EOL]         if (isReservedKeyword(nameNode.getIdentifier())) { [EOL]             errorReporter.error("identifier is a reserved word", sourceName, nameNode.getLineno(), "", 0); [EOL]         } [EOL]         return newStringNode(Token.NAME, nameNode.getIdentifier()); [EOL]     } [EOL] } <line_num>: 856,868
private boolean isReservedKeyword(String identifier) { [EOL]     return reservedKeywords != null && reservedKeywords.contains(identifier); [EOL] } <line_num>: 873,875
@Override [EOL] Node processNewExpression(NewExpression exprNode) { [EOL]     Node node = newNode(transformTokenType(exprNode.getType()), transform(exprNode.getTarget())); [EOL]     for (AstNode child : exprNode.getArguments()) { [EOL]         node.addChildToBack(transform(child)); [EOL]     } [EOL]     node.setLineno(exprNode.getLineno()); [EOL]     node.setCharno(position2charno(exprNode.getAbsolutePosition())); [EOL]     maybeSetLengthFrom(node, exprNode); [EOL]     return node; [EOL] } <line_num>: 877,889
@Override [EOL] Node processNumberLiteral(NumberLiteral literalNode) { [EOL]     return newNumberNode(literalNode.getNumber()); [EOL] } <line_num>: 891,894
@Override [EOL] Node processObjectLiteral(ObjectLiteral literalNode) { [EOL]     if (literalNode.isDestructuring()) { [EOL]         reportDestructuringAssign(literalNode); [EOL]     } [EOL]     Node node = newNode(Token.OBJECTLIT); [EOL]     for (ObjectProperty el : literalNode.getElements()) { [EOL]         if (config.languageMode == LanguageMode.ECMASCRIPT3) { [EOL]             if (el.isGetter()) { [EOL]                 reportGetter(el); [EOL]                 continue; [EOL]             } else if (el.isSetter()) { [EOL]                 reportSetter(el); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         Node key = transformAsString(el.getLeft()); [EOL]         key.setType(Token.STRING_KEY); [EOL]         Node value = transform(el.getRight()); [EOL]         if (el.isGetter()) { [EOL]             key.setType(Token.GETTER_DEF); [EOL]             Preconditions.checkState(value.isFunction()); [EOL]             if (getFnParamNode(value).hasChildren()) { [EOL]                 reportGetterParam(el.getLeft()); [EOL]             } [EOL]         } else if (el.isSetter()) { [EOL]             key.setType(Token.SETTER_DEF); [EOL]             Preconditions.checkState(value.isFunction()); [EOL]             if (!getFnParamNode(value).hasOneChild()) { [EOL]                 reportSetterParam(el.getLeft()); [EOL]             } [EOL]         } [EOL]         key.addChildToFront(value); [EOL]         node.addChildToBack(key); [EOL]     } [EOL]     return node; [EOL] } <line_num>: 896,935
Node getFnParamNode(Node fnNode) { [EOL]     Preconditions.checkArgument(fnNode.isFunction()); [EOL]     return fnNode.getFirstChild().getNext(); [EOL] } <line_num>: 941,945
@Override [EOL] Node processObjectProperty(ObjectProperty propertyNode) { [EOL]     return processInfixExpression(propertyNode); [EOL] } <line_num>: 947,950
@Override [EOL] Node processParenthesizedExpression(ParenthesizedExpression exprNode) { [EOL]     Node node = transform(exprNode.getExpression()); [EOL]     return node; [EOL] } <line_num>: 952,956
@Override [EOL] Node processPropertyGet(PropertyGet getNode) { [EOL]     Node leftChild = transform(getNode.getTarget()); [EOL]     Node newNode = newNode(Token.GETPROP, leftChild, transformAsString(getNode.getProperty())); [EOL]     newNode.setLineno(leftChild.getLineno()); [EOL]     newNode.setCharno(leftChild.getCharno()); [EOL]     maybeSetLengthFrom(newNode, getNode); [EOL]     return newNode; [EOL] } <line_num>: 958,967
@Override [EOL] Node processRegExpLiteral(RegExpLiteral literalNode) { [EOL]     Node literalStringNode = newStringNode(literalNode.getValue()); [EOL]     literalStringNode.setLineno(literalNode.getLineno()); [EOL]     maybeSetLengthFrom(literalStringNode, literalNode); [EOL]     Node node = newNode(Token.REGEXP, literalStringNode); [EOL]     String flags = literalNode.getFlags(); [EOL]     if (flags != null && !flags.isEmpty()) { [EOL]         Node flagsNode = newStringNode(flags); [EOL]         flagsNode.setLineno(literalNode.getLineno()); [EOL]         maybeSetLengthFrom(flagsNode, literalNode); [EOL]         node.addChildToBack(flagsNode); [EOL]     } [EOL]     return node; [EOL] } <line_num>: 969,985
@Override [EOL] Node processReturnStatement(ReturnStatement statementNode) { [EOL]     Node node = newNode(Token.RETURN); [EOL]     if (statementNode.getReturnValue() != null) { [EOL]         node.addChildToBack(transform(statementNode.getReturnValue())); [EOL]     } [EOL]     return node; [EOL] } <line_num>: 987,994
@Override [EOL] Node processScope(Scope scopeNode) { [EOL]     return processGeneric(scopeNode); [EOL] } <line_num>: 996,999
@Override [EOL] Node processStringLiteral(StringLiteral literalNode) { [EOL]     String value = literalNode.getValue(); [EOL]     Node n = newStringNode(value); [EOL]     if (value.indexOf('\u000B') != -1) { [EOL]         int start = literalNode.getAbsolutePosition(); [EOL]         int end = start + literalNode.getLength(); [EOL]         if (start < sourceString.length() && (sourceString.substring(start, Math.min(sourceString.length(), end)).indexOf("\\v") != -1)) { [EOL]             n.putBooleanProp(Node.SLASH_V, true); [EOL]         } [EOL]     } [EOL]     return n; [EOL] } <line_num>: 1001,1028
@Override [EOL] Node processSwitchCase(SwitchCase caseNode) { [EOL]     Node node; [EOL]     if (caseNode.isDefault()) { [EOL]         node = newNode(Token.DEFAULT_CASE); [EOL]     } else { [EOL]         AstNode expr = caseNode.getExpression(); [EOL]         node = newNode(Token.CASE, transform(expr)); [EOL]     } [EOL]     Node block = newNode(Token.BLOCK); [EOL]     block.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true); [EOL]     block.setLineno(caseNode.getLineno()); [EOL]     block.setCharno(position2charno(caseNode.getAbsolutePosition())); [EOL]     maybeSetLengthFrom(block, caseNode); [EOL]     if (caseNode.getStatements() != null) { [EOL]         for (AstNode child : caseNode.getStatements()) { [EOL]             block.addChildToBack(transform(child)); [EOL]         } [EOL]     } [EOL]     node.addChildToBack(block); [EOL]     return node; [EOL] } <line_num>: 1030,1051
@Override [EOL] Node processSwitchStatement(SwitchStatement statementNode) { [EOL]     Node node = newNode(Token.SWITCH, transform(statementNode.getExpression())); [EOL]     for (AstNode child : statementNode.getCases()) { [EOL]         node.addChildToBack(transform(child)); [EOL]     } [EOL]     return node; [EOL] } <line_num>: 1053,1061
@Override [EOL] Node processThrowStatement(ThrowStatement statementNode) { [EOL]     return newNode(Token.THROW, transform(statementNode.getExpression())); [EOL] } <line_num>: 1063,1067
@Override [EOL] Node processTryStatement(TryStatement statementNode) { [EOL]     Node node = newNode(Token.TRY, transformBlock(statementNode.getTryBlock())); [EOL]     Node block = newNode(Token.BLOCK); [EOL]     boolean lineSet = false; [EOL]     for (CatchClause cc : statementNode.getCatchClauses()) { [EOL]         if (lineSet == false) { [EOL]             block.setLineno(cc.getLineno()); [EOL]             maybeSetLengthFrom(block, cc); [EOL]             lineSet = true; [EOL]         } [EOL]         block.addChildToBack(transform(cc)); [EOL]     } [EOL]     node.addChildToBack(block); [EOL]     AstNode finallyBlock = statementNode.getFinallyBlock(); [EOL]     if (finallyBlock != null) { [EOL]         node.addChildToBack(transformBlock(finallyBlock)); [EOL]     } [EOL]     if ((lineSet == false) && (finallyBlock != null)) { [EOL]         block.setLineno(finallyBlock.getLineno()); [EOL]         maybeSetLengthFrom(block, finallyBlock); [EOL]     } [EOL]     return node; [EOL] } <line_num>: 1069,1102
@Override [EOL] Node processUnaryExpression(UnaryExpression exprNode) { [EOL]     int type = transformTokenType(exprNode.getType()); [EOL]     Node operand = transform(exprNode.getOperand()); [EOL]     if (type == Token.NEG && operand.isNumber()) { [EOL]         operand.setDouble(-operand.getDouble()); [EOL]         return operand; [EOL]     } else { [EOL]         if (type == Token.DELPROP && !(operand.isGetProp() || operand.isGetElem() || operand.isName())) { [EOL]             String msg = "Invalid delete operand. Only properties can be deleted."; [EOL]             errorReporter.error(msg, sourceName, operand.getLineno(), "", 0); [EOL]         } else if (type == Token.INC || type == Token.DEC) { [EOL]             if (!validAssignmentTarget(operand)) { [EOL]                 String msg = (type == Token.INC) ? "invalid increment target" : "invalid decrement target"; [EOL]                 errorReporter.error(msg, sourceName, operand.getLineno(), "", 0); [EOL]             } [EOL]         } [EOL]         Node node = newNode(type, operand); [EOL]         if (exprNode.isPostfix()) { [EOL]             node.putBooleanProp(Node.INCRDECR_PROP, true); [EOL]         } [EOL]         return node; [EOL]     } [EOL] } <line_num>: 1104,1140
private boolean validAssignmentTarget(Node target) { [EOL]     switch(target.getType()) { [EOL]         case Token.NAME: [EOL]         case Token.GETPROP: [EOL]         case Token.GETELEM: [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1142,1150
@Override [EOL] Node processVariableDeclaration(VariableDeclaration declarationNode) { [EOL]     if (!config.acceptConstKeyword && declarationNode.getType() == com.google.javascript.rhino.head.Token.CONST) { [EOL]         processIllegalToken(declarationNode); [EOL]     } [EOL]     Node node = newNode(Token.VAR); [EOL]     for (VariableInitializer child : declarationNode.getVariables()) { [EOL]         node.addChildToBack(transform(child)); [EOL]     } [EOL]     return node; [EOL] } <line_num>: 1152,1164
@Override [EOL] Node processVariableInitializer(VariableInitializer initializerNode) { [EOL]     Node node = transform(initializerNode.getTarget()); [EOL]     if (initializerNode.getInitializer() != null) { [EOL]         Node initalizer = transform(initializerNode.getInitializer()); [EOL]         node.addChildToBack(initalizer); [EOL]     } [EOL]     return node; [EOL] } <line_num>: 1166,1174
@Override [EOL] Node processWhileLoop(WhileLoop loopNode) { [EOL]     return newNode(Token.WHILE, transform(loopNode.getCondition()), transformBlock(loopNode.getBody())); [EOL] } <line_num>: 1176,1182
@Override [EOL] Node processWithStatement(WithStatement statementNode) { [EOL]     return newNode(Token.WITH, transform(statementNode.getExpression()), transformBlock(statementNode.getStatement())); [EOL] } <line_num>: 1184,1190
@Override [EOL] Node processIllegalToken(AstNode node) { [EOL]     errorReporter.error("Unsupported syntax: " + com.google.javascript.rhino.head.Token.typeToName(node.getType()), sourceName, node.getLineno(), "", 0); [EOL]     return newNode(Token.EMPTY); [EOL] } <line_num>: 1192,1201
void reportDestructuringAssign(AstNode node) { [EOL]     errorReporter.error("destructuring assignment forbidden", sourceName, node.getLineno(), "", 0); [EOL] } <line_num>: 1203,1208
void reportGetter(AstNode node) { [EOL]     errorReporter.error(GETTER_ERROR_MESSAGE, sourceName, node.getLineno(), "", 0); [EOL] } <line_num>: 1210,1215
void reportSetter(AstNode node) { [EOL]     errorReporter.error(SETTER_ERROR_MESSAGE, sourceName, node.getLineno(), "", 0); [EOL] } <line_num>: 1217,1222
void reportGetterParam(AstNode node) { [EOL]     errorReporter.error("getters may not have parameters", sourceName, node.getLineno(), "", 0); [EOL] } <line_num>: 1224,1229
void reportSetterParam(AstNode node) { [EOL]     errorReporter.error("setters must have exactly one parameter", sourceName, node.getLineno(), "", 0); [EOL] } <line_num>: 1231,1236
private static int transformTokenType(int token) { [EOL]     switch(token) { [EOL]         case com.google.javascript.rhino.head.Token.RETURN: [EOL]             return Token.RETURN; [EOL]         case com.google.javascript.rhino.head.Token.BITOR: [EOL]             return Token.BITOR; [EOL]         case com.google.javascript.rhino.head.Token.BITXOR: [EOL]             return Token.BITXOR; [EOL]         case com.google.javascript.rhino.head.Token.BITAND: [EOL]             return Token.BITAND; [EOL]         case com.google.javascript.rhino.head.Token.EQ: [EOL]             return Token.EQ; [EOL]         case com.google.javascript.rhino.head.Token.NE: [EOL]             return Token.NE; [EOL]         case com.google.javascript.rhino.head.Token.LT: [EOL]             return Token.LT; [EOL]         case com.google.javascript.rhino.head.Token.LE: [EOL]             return Token.LE; [EOL]         case com.google.javascript.rhino.head.Token.GT: [EOL]             return Token.GT; [EOL]         case com.google.javascript.rhino.head.Token.GE: [EOL]             return Token.GE; [EOL]         case com.google.javascript.rhino.head.Token.LSH: [EOL]             return Token.LSH; [EOL]         case com.google.javascript.rhino.head.Token.RSH: [EOL]             return Token.RSH; [EOL]         case com.google.javascript.rhino.head.Token.URSH: [EOL]             return Token.URSH; [EOL]         case com.google.javascript.rhino.head.Token.ADD: [EOL]             return Token.ADD; [EOL]         case com.google.javascript.rhino.head.Token.SUB: [EOL]             return Token.SUB; [EOL]         case com.google.javascript.rhino.head.Token.MUL: [EOL]             return Token.MUL; [EOL]         case com.google.javascript.rhino.head.Token.DIV: [EOL]             return Token.DIV; [EOL]         case com.google.javascript.rhino.head.Token.MOD: [EOL]             return Token.MOD; [EOL]         case com.google.javascript.rhino.head.Token.NOT: [EOL]             return Token.NOT; [EOL]         case com.google.javascript.rhino.head.Token.BITNOT: [EOL]             return Token.BITNOT; [EOL]         case com.google.javascript.rhino.head.Token.POS: [EOL]             return Token.POS; [EOL]         case com.google.javascript.rhino.head.Token.NEG: [EOL]             return Token.NEG; [EOL]         case com.google.javascript.rhino.head.Token.NEW: [EOL]             return Token.NEW; [EOL]         case com.google.javascript.rhino.head.Token.DELPROP: [EOL]             return Token.DELPROP; [EOL]         case com.google.javascript.rhino.head.Token.TYPEOF: [EOL]             return Token.TYPEOF; [EOL]         case com.google.javascript.rhino.head.Token.GETPROP: [EOL]             return Token.GETPROP; [EOL]         case com.google.javascript.rhino.head.Token.GETELEM: [EOL]             return Token.GETELEM; [EOL]         case com.google.javascript.rhino.head.Token.CALL: [EOL]             return Token.CALL; [EOL]         case com.google.javascript.rhino.head.Token.NAME: [EOL]             return Token.NAME; [EOL]         case com.google.javascript.rhino.head.Token.NUMBER: [EOL]             return Token.NUMBER; [EOL]         case com.google.javascript.rhino.head.Token.STRING: [EOL]             return Token.STRING; [EOL]         case com.google.javascript.rhino.head.Token.NULL: [EOL]             return Token.NULL; [EOL]         case com.google.javascript.rhino.head.Token.THIS: [EOL]             return Token.THIS; [EOL]         case com.google.javascript.rhino.head.Token.FALSE: [EOL]             return Token.FALSE; [EOL]         case com.google.javascript.rhino.head.Token.TRUE: [EOL]             return Token.TRUE; [EOL]         case com.google.javascript.rhino.head.Token.SHEQ: [EOL]             return Token.SHEQ; [EOL]         case com.google.javascript.rhino.head.Token.SHNE: [EOL]             return Token.SHNE; [EOL]         case com.google.javascript.rhino.head.Token.REGEXP: [EOL]             return Token.REGEXP; [EOL]         case com.google.javascript.rhino.head.Token.THROW: [EOL]             return Token.THROW; [EOL]         case com.google.javascript.rhino.head.Token.IN: [EOL]             return Token.IN; [EOL]         case com.google.javascript.rhino.head.Token.INSTANCEOF: [EOL]             return Token.INSTANCEOF; [EOL]         case com.google.javascript.rhino.head.Token.ARRAYLIT: [EOL]             return Token.ARRAYLIT; [EOL]         case com.google.javascript.rhino.head.Token.OBJECTLIT: [EOL]             return Token.OBJECTLIT; [EOL]         case com.google.javascript.rhino.head.Token.TRY: [EOL]             return Token.TRY; [EOL]         case com.google.javascript.rhino.head.Token.LP: [EOL]             return Token.PARAM_LIST; [EOL]         case com.google.javascript.rhino.head.Token.COMMA: [EOL]             return Token.COMMA; [EOL]         case com.google.javascript.rhino.head.Token.ASSIGN: [EOL]             return Token.ASSIGN; [EOL]         case com.google.javascript.rhino.head.Token.ASSIGN_BITOR: [EOL]             return Token.ASSIGN_BITOR; [EOL]         case com.google.javascript.rhino.head.Token.ASSIGN_BITXOR: [EOL]             return Token.ASSIGN_BITXOR; [EOL]         case com.google.javascript.rhino.head.Token.ASSIGN_BITAND: [EOL]             return Token.ASSIGN_BITAND; [EOL]         case com.google.javascript.rhino.head.Token.ASSIGN_LSH: [EOL]             return Token.ASSIGN_LSH; [EOL]         case com.google.javascript.rhino.head.Token.ASSIGN_RSH: [EOL]             return Token.ASSIGN_RSH; [EOL]         case com.google.javascript.rhino.head.Token.ASSIGN_URSH: [EOL]             return Token.ASSIGN_URSH; [EOL]         case com.google.javascript.rhino.head.Token.ASSIGN_ADD: [EOL]             return Token.ASSIGN_ADD; [EOL]         case com.google.javascript.rhino.head.Token.ASSIGN_SUB: [EOL]             return Token.ASSIGN_SUB; [EOL]         case com.google.javascript.rhino.head.Token.ASSIGN_MUL: [EOL]             return Token.ASSIGN_MUL; [EOL]         case com.google.javascript.rhino.head.Token.ASSIGN_DIV: [EOL]             return Token.ASSIGN_DIV; [EOL]         case com.google.javascript.rhino.head.Token.ASSIGN_MOD: [EOL]             return Token.ASSIGN_MOD; [EOL]         case com.google.javascript.rhino.head.Token.HOOK: [EOL]             return Token.HOOK; [EOL]         case com.google.javascript.rhino.head.Token.OR: [EOL]             return Token.OR; [EOL]         case com.google.javascript.rhino.head.Token.AND: [EOL]             return Token.AND; [EOL]         case com.google.javascript.rhino.head.Token.INC: [EOL]             return Token.INC; [EOL]         case com.google.javascript.rhino.head.Token.DEC: [EOL]             return Token.DEC; [EOL]         case com.google.javascript.rhino.head.Token.FUNCTION: [EOL]             return Token.FUNCTION; [EOL]         case com.google.javascript.rhino.head.Token.IF: [EOL]             return Token.IF; [EOL]         case com.google.javascript.rhino.head.Token.SWITCH: [EOL]             return Token.SWITCH; [EOL]         case com.google.javascript.rhino.head.Token.CASE: [EOL]             return Token.CASE; [EOL]         case com.google.javascript.rhino.head.Token.DEFAULT: [EOL]             return Token.DEFAULT_CASE; [EOL]         case com.google.javascript.rhino.head.Token.WHILE: [EOL]             return Token.WHILE; [EOL]         case com.google.javascript.rhino.head.Token.DO: [EOL]             return Token.DO; [EOL]         case com.google.javascript.rhino.head.Token.FOR: [EOL]             return Token.FOR; [EOL]         case com.google.javascript.rhino.head.Token.BREAK: [EOL]             return Token.BREAK; [EOL]         case com.google.javascript.rhino.head.Token.CONTINUE: [EOL]             return Token.CONTINUE; [EOL]         case com.google.javascript.rhino.head.Token.VAR: [EOL]             return Token.VAR; [EOL]         case com.google.javascript.rhino.head.Token.WITH: [EOL]             return Token.WITH; [EOL]         case com.google.javascript.rhino.head.Token.CATCH: [EOL]             return Token.CATCH; [EOL]         case com.google.javascript.rhino.head.Token.VOID: [EOL]             return Token.VOID; [EOL]         case com.google.javascript.rhino.head.Token.EMPTY: [EOL]             return Token.EMPTY; [EOL]         case com.google.javascript.rhino.head.Token.BLOCK: [EOL]             return Token.BLOCK; [EOL]         case com.google.javascript.rhino.head.Token.LABEL: [EOL]             return Token.LABEL; [EOL]         case com.google.javascript.rhino.head.Token.EXPR_VOID: [EOL]         case com.google.javascript.rhino.head.Token.EXPR_RESULT: [EOL]             return Token.EXPR_RESULT; [EOL]         case com.google.javascript.rhino.head.Token.SCRIPT: [EOL]             return Token.SCRIPT; [EOL]         case com.google.javascript.rhino.head.Token.GET: [EOL]             return Token.GETTER_DEF; [EOL]         case com.google.javascript.rhino.head.Token.SET: [EOL]             return Token.SETTER_DEF; [EOL]         case com.google.javascript.rhino.head.Token.CONST: [EOL]             return Token.CONST; [EOL]         case com.google.javascript.rhino.head.Token.DEBUGGER: [EOL]             return Token.DEBUGGER; [EOL]     } [EOL]     throw new IllegalStateException(String.valueOf(token)); [EOL] } <line_num>: 1239,1419
private Node newNode(int type) { [EOL]     return new Node(type).clonePropsFrom(templateNode); [EOL] } <line_num>: 1422,1424
private Node newNode(int type, Node child1) { [EOL]     return new Node(type, child1).clonePropsFrom(templateNode); [EOL] } <line_num>: 1426,1428
private Node newNode(int type, Node child1, Node child2) { [EOL]     return new Node(type, child1, child2).clonePropsFrom(templateNode); [EOL] } <line_num>: 1430,1432
private Node newNode(int type, Node child1, Node child2, Node child3) { [EOL]     return new Node(type, child1, child2, child3).clonePropsFrom(templateNode); [EOL] } <line_num>: 1434,1436
private Node newStringNode(String value) { [EOL]     return IR.string(value).clonePropsFrom(templateNode); [EOL] } <line_num>: 1438,1440
private Node newStringNode(int type, String value) { [EOL]     return Node.newString(type, value).clonePropsFrom(templateNode); [EOL] } <line_num>: 1442,1444
private Node newNumberNode(Double value) { [EOL]     return IR.number(value).clonePropsFrom(templateNode); [EOL] } <line_num>: 1446,1448
