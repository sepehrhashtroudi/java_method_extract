JsDocInfoParser(JsDocTokenStream stream, Comment commentNode, Node associatedNode, Config config, ErrorReporter errorReporter) { [EOL]     this.stream = stream; [EOL]     this.associatedNode = associatedNode; [EOL]     this.sourceFile = associatedNode == null ? null : associatedNode.getStaticSourceFile(); [EOL]     this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation); [EOL]     if (commentNode != null) { [EOL]         this.jsdocBuilder.recordOriginalCommentString(commentNode.getValue()); [EOL]     } [EOL]     this.annotationNames = config.annotationNames; [EOL]     this.suppressionNames = config.suppressionNames; [EOL]     this.errorReporter = errorReporter; [EOL]     this.templateNode = this.createTemplateNode(); [EOL] } <line_num>: 126,147
public ExtractionInfo(String string, JsDocToken token) { [EOL]     this.string = string; [EOL]     this.token = token; [EOL] } <line_num>: 1290,1293
public ExtendedTypeInfo(JSTypeExpression type, int lineno, int charno) { [EOL]     this.type = type; [EOL]     this.lineno = lineno; [EOL]     this.charno = charno; [EOL] } <line_num>: 1304,1308
void addParserWarning(String messageId, String messageArg, int lineno, int charno) { [EOL]     errorReporter.warning(ScriptRuntime.getMessage1(messageId, messageArg), getSourceName(), lineno, null, charno); [EOL] } <line_num>: 62,66
void addParserWarning(String messageId, int lineno, int charno) { [EOL]     errorReporter.warning(ScriptRuntime.getMessage0(messageId), getSourceName(), lineno, null, charno); [EOL] } <line_num>: 68,71
void addTypeWarning(String messageId, String messageArg, int lineno, int charno) { [EOL]     errorReporter.warning("Bad type annotation. " + ScriptRuntime.getMessage1(messageId, messageArg), getSourceName(), lineno, null, charno); [EOL] } <line_num>: 73,79
void addTypeWarning(String messageId, int lineno, int charno) { [EOL]     errorReporter.warning("Bad type annotation. " + ScriptRuntime.getMessage0(messageId), getSourceName(), lineno, null, charno); [EOL] } <line_num>: 81,86
void setFileLevelJsDocBuilder(Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) { [EOL]     this.fileLevelJsDocBuilder = fileLevelJsDocBuilder; [EOL] } <line_num>: 107,110
void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo) { [EOL]     this.fileOverviewJSDocInfo = fileOverviewJSDocInfo; [EOL] } <line_num>: 116,118
private String getSourceName() { [EOL]     return sourceFile == null ? null : sourceFile.getName(); [EOL] } <line_num>: 149,151
public static Node parseTypeString(String typeString) { [EOL]     Config config = new Config(Sets.<String>newHashSet(), Sets.<String>newHashSet(), false, LanguageMode.ECMASCRIPT3, false); [EOL]     JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), null, null, config, NullErrorReporter.forNewRhino()); [EOL]     return parser.parseTopLevelTypeExpression(parser.next()); [EOL] } <line_num>: 157,172
@SuppressWarnings("incomplete-switch") [EOL] boolean parse() { [EOL]     int lineno; [EOL]     int charno; [EOL]     JSTypeExpression type; [EOL]     state = State.SEARCHING_ANNOTATION; [EOL]     skipEOLs(); [EOL]     JsDocToken token = next(); [EOL]     List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList(); [EOL]     if (jsdocBuilder.shouldParseDocumentation()) { [EOL]         ExtractionInfo blockInfo = extractBlockComment(token); [EOL]         token = blockInfo.token; [EOL]         if (!blockInfo.string.isEmpty()) { [EOL]             jsdocBuilder.recordBlockDescription(blockInfo.string); [EOL]         } [EOL]     } else { [EOL]         if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) { [EOL]             jsdocBuilder.recordBlockDescription(""); [EOL]         } [EOL]     } [EOL]     retry: for (; ; ) { [EOL]         switch(token) { [EOL]             case ANNOTATION: [EOL]                 if (state == State.SEARCHING_ANNOTATION) { [EOL]                     state = State.SEARCHING_NEWLINE; [EOL]                     lineno = stream.getLineno(); [EOL]                     charno = stream.getCharno(); [EOL]                     String annotationName = stream.getString(); [EOL]                     Annotation annotation = annotationNames.get(annotationName); [EOL]                     if (annotation == null) { [EOL]                         parser.addParserWarning("msg.bad.jsdoc.tag", annotationName, stream.getLineno(), stream.getCharno()); [EOL]                     } else { [EOL]                         jsdocBuilder.markAnnotation(annotationName, lineno, charno); [EOL]                         switch(annotation) { [EOL]                             case AUTHOR: [EOL]                                 if (jsdocBuilder.shouldParseDocumentation()) { [EOL]                                     ExtractionInfo authorInfo = extractSingleLineBlock(); [EOL]                                     String author = authorInfo.string; [EOL]                                     if (author.length() == 0) { [EOL]                                         parser.addParserWarning("msg.jsdoc.authormissing", stream.getLineno(), stream.getCharno()); [EOL]                                     } else { [EOL]                                         jsdocBuilder.addAuthor(author); [EOL]                                     } [EOL]                                     token = authorInfo.token; [EOL]                                 } else { [EOL]                                     token = eatTokensUntilEOL(token); [EOL]                                 } [EOL]                                 continue retry; [EOL]                             case CONSISTENTIDGENERATOR: [EOL]                                 if (!jsdocBuilder.recordConsistentIdGenerator()) { [EOL]                                     parser.addParserWarning("msg.jsdoc.consistidgen", stream.getLineno(), stream.getCharno()); [EOL]                                 } [EOL]                                 token = eatTokensUntilEOL(); [EOL]                                 continue retry; [EOL]                             case STRUCT: [EOL]                                 if (!jsdocBuilder.recordStruct()) { [EOL]                                     parser.addTypeWarning("msg.jsdoc.incompat.type", stream.getLineno(), stream.getCharno()); [EOL]                                 } [EOL]                                 token = eatTokensUntilEOL(); [EOL]                                 continue retry; [EOL]                             case DICT: [EOL]                                 if (!jsdocBuilder.recordDict()) { [EOL]                                     parser.addTypeWarning("msg.jsdoc.incompat.type", stream.getLineno(), stream.getCharno()); [EOL]                                 } [EOL]                                 token = eatTokensUntilEOL(); [EOL]                                 continue retry; [EOL]                             case CONSTRUCTOR: [EOL]                                 if (!jsdocBuilder.recordConstructor()) { [EOL]                                     if (jsdocBuilder.isInterfaceRecorded()) { [EOL]                                         parser.addTypeWarning("msg.jsdoc.interface.constructor", stream.getLineno(), stream.getCharno()); [EOL]                                     } else { [EOL]                                         parser.addTypeWarning("msg.jsdoc.incompat.type", stream.getLineno(), stream.getCharno()); [EOL]                                     } [EOL]                                 } [EOL]                                 token = eatTokensUntilEOL(); [EOL]                                 continue retry; [EOL]                             case DEPRECATED: [EOL]                                 if (!jsdocBuilder.recordDeprecated()) { [EOL]                                     parser.addParserWarning("msg.jsdoc.deprecated", stream.getLineno(), stream.getCharno()); [EOL]                                 } [EOL]                                 ExtractionInfo reasonInfo = extractMultilineTextualBlock(token); [EOL]                                 String reason = reasonInfo.string; [EOL]                                 if (reason.length() > 0) { [EOL]                                     jsdocBuilder.recordDeprecationReason(reason); [EOL]                                 } [EOL]                                 token = reasonInfo.token; [EOL]                                 continue retry; [EOL]                             case INTERFACE: [EOL]                                 if (!jsdocBuilder.recordInterface()) { [EOL]                                     if (jsdocBuilder.isConstructorRecorded()) { [EOL]                                         parser.addTypeWarning("msg.jsdoc.interface.constructor", stream.getLineno(), stream.getCharno()); [EOL]                                     } else { [EOL]                                         parser.addTypeWarning("msg.jsdoc.incompat.type", stream.getLineno(), stream.getCharno()); [EOL]                                     } [EOL]                                 } [EOL]                                 token = eatTokensUntilEOL(); [EOL]                                 continue retry; [EOL]                             case DESC: [EOL]                                 if (jsdocBuilder.isDescriptionRecorded()) { [EOL]                                     parser.addParserWarning("msg.jsdoc.desc.extra", stream.getLineno(), stream.getCharno()); [EOL]                                     token = eatTokensUntilEOL(); [EOL]                                     continue retry; [EOL]                                 } else { [EOL]                                     ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); [EOL]                                     String description = descriptionInfo.string; [EOL]                                     jsdocBuilder.recordDescription(description); [EOL]                                     token = descriptionInfo.token; [EOL]                                     continue retry; [EOL]                                 } [EOL]                             case FILE_OVERVIEW: [EOL]                                 String fileOverview = ""; [EOL]                                 if (jsdocBuilder.shouldParseDocumentation()) { [EOL]                                     ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM); [EOL]                                     fileOverview = fileOverviewInfo.string; [EOL]                                     token = fileOverviewInfo.token; [EOL]                                 } else { [EOL]                                     token = eatTokensUntilEOL(token); [EOL]                                 } [EOL]                                 if (!jsdocBuilder.recordFileOverview(fileOverview)) { [EOL]                                     parser.addParserWarning("msg.jsdoc.fileoverview.extra", stream.getLineno(), stream.getCharno()); [EOL]                                 } [EOL]                                 continue retry; [EOL]                             case LICENSE: [EOL]                             case PRESERVE: [EOL]                                 ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE); [EOL]                                 String preserve = preserveInfo.string; [EOL]                                 if (preserve.length() > 0) { [EOL]                                     if (fileLevelJsDocBuilder != null) { [EOL]                                         fileLevelJsDocBuilder.append(preserve); [EOL]                                     } [EOL]                                 } [EOL]                                 token = preserveInfo.token; [EOL]                                 continue retry; [EOL]                             case ENUM: [EOL]                                 token = next(); [EOL]                                 lineno = stream.getLineno(); [EOL]                                 charno = stream.getCharno(); [EOL]                                 type = null; [EOL]                                 if (token != JsDocToken.EOL && token != JsDocToken.EOC) { [EOL]                                     type = createJSTypeExpression(parseAndRecordTypeNode(token)); [EOL]                                 } [EOL]                                 if (type == null) { [EOL]                                     type = createJSTypeExpression(newStringNode("number")); [EOL]                                 } [EOL]                                 if (!jsdocBuilder.recordEnumParameterType(type)) { [EOL]                                     parser.addTypeWarning("msg.jsdoc.incompat.type", lineno, charno); [EOL]                                 } [EOL]                                 token = eatTokensUntilEOL(token); [EOL]                                 continue retry; [EOL]                             case EXPORT: [EOL]                                 if (!jsdocBuilder.recordExport()) { [EOL]                                     parser.addParserWarning("msg.jsdoc.export", stream.getLineno(), stream.getCharno()); [EOL]                                 } [EOL]                                 token = eatTokensUntilEOL(); [EOL]                                 continue retry; [EOL]                             case EXPOSE: [EOL]                                 if (!jsdocBuilder.recordExpose()) { [EOL]                                     parser.addParserWarning("msg.jsdoc.expose", stream.getLineno(), stream.getCharno()); [EOL]                                 } [EOL]                                 token = eatTokensUntilEOL(); [EOL]                                 continue retry; [EOL]                             case EXTERNS: [EOL]                                 if (!jsdocBuilder.recordExterns()) { [EOL]                                     parser.addParserWarning("msg.jsdoc.externs", stream.getLineno(), stream.getCharno()); [EOL]                                 } [EOL]                                 token = eatTokensUntilEOL(); [EOL]                                 continue retry; [EOL]                             case JAVA_DISPATCH: [EOL]                                 if (!jsdocBuilder.recordJavaDispatch()) { [EOL]                                     parser.addParserWarning("msg.jsdoc.javadispatch", stream.getLineno(), stream.getCharno()); [EOL]                                 } [EOL]                                 token = eatTokensUntilEOL(); [EOL]                                 continue retry; [EOL]                             case EXTENDS: [EOL]                             case IMPLEMENTS: [EOL]                                 skipEOLs(); [EOL]                                 token = next(); [EOL]                                 lineno = stream.getLineno(); [EOL]                                 charno = stream.getCharno(); [EOL]                                 boolean matchingRc = false; [EOL]                                 if (token == JsDocToken.LC) { [EOL]                                     token = next(); [EOL]                                     matchingRc = true; [EOL]                                 } [EOL]                                 if (token == JsDocToken.STRING) { [EOL]                                     Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc); [EOL]                                     lineno = stream.getLineno(); [EOL]                                     charno = stream.getCharno(); [EOL]                                     typeNode = wrapNode(Token.BANG, typeNode); [EOL]                                     type = createJSTypeExpression(typeNode); [EOL]                                     if (annotation == Annotation.EXTENDS) { [EOL]                                         extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno())); [EOL]                                     } else { [EOL]                                         Preconditions.checkState(annotation == Annotation.IMPLEMENTS); [EOL]                                         if (!jsdocBuilder.recordImplementedInterface(type)) { [EOL]                                             parser.addTypeWarning("msg.jsdoc.implements.duplicate", lineno, charno); [EOL]                                         } [EOL]                                     } [EOL]                                     token = next(); [EOL]                                     if (matchingRc) { [EOL]                                         if (token != JsDocToken.RC) { [EOL]                                             parser.addTypeWarning("msg.jsdoc.missing.rc", stream.getLineno(), stream.getCharno()); [EOL]                                         } [EOL]                                     } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) { [EOL]                                         parser.addTypeWarning("msg.end.annotation.expected", stream.getLineno(), stream.getCharno()); [EOL]                                     } [EOL]                                 } else { [EOL]                                     parser.addTypeWarning("msg.no.type.name", lineno, charno); [EOL]                                 } [EOL]                                 token = eatTokensUntilEOL(token); [EOL]                                 continue retry; [EOL]                             case HIDDEN: [EOL]                                 if (!jsdocBuilder.recordHiddenness()) { [EOL]                                     parser.addParserWarning("msg.jsdoc.hidden", stream.getLineno(), stream.getCharno()); [EOL]                                 } [EOL]                                 token = eatTokensUntilEOL(); [EOL]                                 continue retry; [EOL]                             case LENDS: [EOL]                                 skipEOLs(); [EOL]                                 matchingRc = false; [EOL]                                 if (match(JsDocToken.LC)) { [EOL]                                     token = next(); [EOL]                                     matchingRc = true; [EOL]                                 } [EOL]                                 if (match(JsDocToken.STRING)) { [EOL]                                     token = next(); [EOL]                                     if (!jsdocBuilder.recordLends(stream.getString())) { [EOL]                                         parser.addTypeWarning("msg.jsdoc.lends.incompatible", stream.getLineno(), stream.getCharno()); [EOL]                                     } [EOL]                                 } else { [EOL]                                     parser.addTypeWarning("msg.jsdoc.lends.missing", stream.getLineno(), stream.getCharno()); [EOL]                                 } [EOL]                                 if (matchingRc && !match(JsDocToken.RC)) { [EOL]                                     parser.addTypeWarning("msg.jsdoc.missing.rc", stream.getLineno(), stream.getCharno()); [EOL]                                 } [EOL]                                 token = eatTokensUntilEOL(); [EOL]                                 continue retry; [EOL]                             case MEANING: [EOL]                                 ExtractionInfo meaningInfo = extractMultilineTextualBlock(token); [EOL]                                 String meaning = meaningInfo.string; [EOL]                                 token = meaningInfo.token; [EOL]                                 if (!jsdocBuilder.recordMeaning(meaning)) { [EOL]                                     parser.addParserWarning("msg.jsdoc.meaning.extra", stream.getLineno(), stream.getCharno()); [EOL]                                 } [EOL]                                 continue retry; [EOL]                             case NO_ALIAS: [EOL]                                 if (!jsdocBuilder.recordNoAlias()) { [EOL]                                     parser.addParserWarning("msg.jsdoc.noalias", stream.getLineno(), stream.getCharno()); [EOL]                                 } [EOL]                                 token = eatTokensUntilEOL(); [EOL]                                 continue retry; [EOL]                             case NO_COMPILE: [EOL]                                 if (!jsdocBuilder.recordNoCompile()) { [EOL]                                     parser.addParserWarning("msg.jsdoc.nocompile", stream.getLineno(), stream.getCharno()); [EOL]                                 } [EOL]                                 token = eatTokensUntilEOL(); [EOL]                                 continue retry; [EOL]                             case NO_TYPE_CHECK: [EOL]                                 if (!jsdocBuilder.recordNoTypeCheck()) { [EOL]                                     parser.addParserWarning("msg.jsdoc.nocheck", stream.getLineno(), stream.getCharno()); [EOL]                                 } [EOL]                                 token = eatTokensUntilEOL(); [EOL]                                 continue retry; [EOL]                             case NOT_IMPLEMENTED: [EOL]                                 token = eatTokensUntilEOL(); [EOL]                                 continue retry; [EOL]                             case INHERIT_DOC: [EOL]                             case OVERRIDE: [EOL]                                 if (!jsdocBuilder.recordOverride()) { [EOL]                                     parser.addTypeWarning("msg.jsdoc.override", stream.getLineno(), stream.getCharno()); [EOL]                                 } [EOL]                                 token = eatTokensUntilEOL(); [EOL]                                 continue retry; [EOL]                             case THROWS: [EOL]                                 skipEOLs(); [EOL]                                 token = next(); [EOL]                                 lineno = stream.getLineno(); [EOL]                                 charno = stream.getCharno(); [EOL]                                 type = null; [EOL]                                 if (token == JsDocToken.LC) { [EOL]                                     type = createJSTypeExpression(parseAndRecordTypeNode(token)); [EOL]                                     if (type == null) { [EOL]                                         token = eatTokensUntilEOL(); [EOL]                                         continue retry; [EOL]                                     } [EOL]                                 } [EOL]                                 token = current(); [EOL]                                 jsdocBuilder.recordThrowType(type); [EOL]                                 if (jsdocBuilder.shouldParseDocumentation()) { [EOL]                                     ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); [EOL]                                     String description = descriptionInfo.string; [EOL]                                     if (description.length() > 0) { [EOL]                                         jsdocBuilder.recordThrowDescription(type, description); [EOL]                                     } [EOL]                                     token = descriptionInfo.token; [EOL]                                 } else { [EOL]                                     token = eatTokensUntilEOL(token); [EOL]                                 } [EOL]                                 continue retry; [EOL]                             case PARAM: [EOL]                                 skipEOLs(); [EOL]                                 token = next(); [EOL]                                 lineno = stream.getLineno(); [EOL]                                 charno = stream.getCharno(); [EOL]                                 type = null; [EOL]                                 if (token == JsDocToken.LC) { [EOL]                                     type = createJSTypeExpression(parseAndRecordParamTypeNode(token)); [EOL]                                     if (type == null) { [EOL]                                         token = eatTokensUntilEOL(); [EOL]                                         continue retry; [EOL]                                     } [EOL]                                     skipEOLs(); [EOL]                                     token = next(); [EOL]                                     lineno = stream.getLineno(); [EOL]                                     charno = stream.getCharno(); [EOL]                                 } [EOL]                                 String name = null; [EOL]                                 boolean isBracketedParam = JsDocToken.LB == token; [EOL]                                 if (isBracketedParam) { [EOL]                                     token = next(); [EOL]                                 } [EOL]                                 if (JsDocToken.STRING != token) { [EOL]                                     parser.addTypeWarning("msg.missing.variable.name", lineno, charno); [EOL]                                 } else { [EOL]                                     name = stream.getString(); [EOL]                                     if (isBracketedParam) { [EOL]                                         token = next(); [EOL]                                         if (JsDocToken.EQUALS == token) { [EOL]                                             token = next(); [EOL]                                             if (JsDocToken.STRING == token) { [EOL]                                                 token = next(); [EOL]                                             } [EOL]                                         } [EOL]                                         if (JsDocToken.RB != token) { [EOL]                                             reportTypeSyntaxWarning("msg.jsdoc.missing.rb"); [EOL]                                         } else if (type != null) { [EOL]                                             type = JSTypeExpression.makeOptionalArg(type); [EOL]                                         } [EOL]                                     } [EOL]                                     if (name.indexOf('.') > -1) { [EOL]                                         name = null; [EOL]                                     } else if (!jsdocBuilder.recordParameter(name, type)) { [EOL]                                         if (jsdocBuilder.hasParameter(name)) { [EOL]                                             parser.addTypeWarning("msg.dup.variable.name", name, lineno, charno); [EOL]                                         } else { [EOL]                                             parser.addTypeWarning("msg.jsdoc.incompat.type", name, lineno, charno); [EOL]                                         } [EOL]                                     } [EOL]                                 } [EOL]                                 if (name == null) { [EOL]                                     token = eatTokensUntilEOL(token); [EOL]                                     continue retry; [EOL]                                 } [EOL]                                 jsdocBuilder.markName(name, sourceFile, lineno, charno); [EOL]                                 if (jsdocBuilder.shouldParseDocumentation()) { [EOL]                                     ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token); [EOL]                                     String paramDescription = paramDescriptionInfo.string; [EOL]                                     if (paramDescription.length() > 0) { [EOL]                                         jsdocBuilder.recordParameterDescription(name, paramDescription); [EOL]                                     } [EOL]                                     token = paramDescriptionInfo.token; [EOL]                                 } else { [EOL]                                     token = eatTokensUntilEOL(token); [EOL]                                 } [EOL]                                 continue retry; [EOL]                             case PRESERVE_TRY: [EOL]                                 if (!jsdocBuilder.recordPreserveTry()) { [EOL]                                     parser.addParserWarning("msg.jsdoc.preservertry", stream.getLineno(), stream.getCharno()); [EOL]                                 } [EOL]                                 token = eatTokensUntilEOL(); [EOL]                                 continue retry; [EOL]                             case NO_SHADOW: [EOL]                                 if (!jsdocBuilder.recordNoShadow()) { [EOL]                                     parser.addParserWarning("msg.jsdoc.noshadow", stream.getLineno(), stream.getCharno()); [EOL]                                 } [EOL]                                 token = eatTokensUntilEOL(); [EOL]                                 continue retry; [EOL]                             case NO_SIDE_EFFECTS: [EOL]                                 if (!jsdocBuilder.recordNoSideEffects()) { [EOL]                                     parser.addParserWarning("msg.jsdoc.nosideeffects", stream.getLineno(), stream.getCharno()); [EOL]                                 } [EOL]                                 token = eatTokensUntilEOL(); [EOL]                                 continue retry; [EOL]                             case MODIFIES: [EOL]                                 token = parseModifiesTag(next()); [EOL]                                 continue retry; [EOL]                             case IMPLICIT_CAST: [EOL]                                 if (!jsdocBuilder.recordImplicitCast()) { [EOL]                                     parser.addTypeWarning("msg.jsdoc.implicitcast", stream.getLineno(), stream.getCharno()); [EOL]                                 } [EOL]                                 token = eatTokensUntilEOL(); [EOL]                                 continue retry; [EOL]                             case SEE: [EOL]                                 if (jsdocBuilder.shouldParseDocumentation()) { [EOL]                                     ExtractionInfo referenceInfo = extractSingleLineBlock(); [EOL]                                     String reference = referenceInfo.string; [EOL]                                     if (reference.length() == 0) { [EOL]                                         parser.addParserWarning("msg.jsdoc.seemissing", stream.getLineno(), stream.getCharno()); [EOL]                                     } else { [EOL]                                         jsdocBuilder.addReference(reference); [EOL]                                     } [EOL]                                     token = referenceInfo.token; [EOL]                                 } else { [EOL]                                     token = eatTokensUntilEOL(token); [EOL]                                 } [EOL]                                 continue retry; [EOL]                             case STABLEIDGENERATOR: [EOL]                                 if (!jsdocBuilder.recordStableIdGenerator()) { [EOL]                                     parser.addParserWarning("msg.jsdoc.stableidgen", stream.getLineno(), stream.getCharno()); [EOL]                                 } [EOL]                                 token = eatTokensUntilEOL(); [EOL]                                 continue retry; [EOL]                             case SUPPRESS: [EOL]                                 token = parseSuppressTag(next()); [EOL]                                 continue retry; [EOL]                             case TEMPLATE: [EOL]                                 ExtractionInfo templateInfo = extractSingleLineBlock(); [EOL]                                 List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(templateInfo.string)); [EOL]                                 if (names.size() == 0 || names.get(0).length() == 0) { [EOL]                                     parser.addTypeWarning("msg.jsdoc.templatemissing", stream.getLineno(), stream.getCharno()); [EOL]                                 } else if (!jsdocBuilder.recordTemplateTypeNames(names)) { [EOL]                                     parser.addTypeWarning("msg.jsdoc.template.at.most.once", stream.getLineno(), stream.getCharno()); [EOL]                                 } [EOL]                                 token = templateInfo.token; [EOL]                                 continue retry; [EOL]                             case IDGENERATOR: [EOL]                                 if (!jsdocBuilder.recordIdGenerator()) { [EOL]                                     parser.addParserWarning("msg.jsdoc.idgen", stream.getLineno(), stream.getCharno()); [EOL]                                 } [EOL]                                 token = eatTokensUntilEOL(); [EOL]                                 continue retry; [EOL]                             case VERSION: [EOL]                                 ExtractionInfo versionInfo = extractSingleLineBlock(); [EOL]                                 String version = versionInfo.string; [EOL]                                 if (version.length() == 0) { [EOL]                                     parser.addParserWarning("msg.jsdoc.versionmissing", stream.getLineno(), stream.getCharno()); [EOL]                                 } else { [EOL]                                     if (!jsdocBuilder.recordVersion(version)) { [EOL]                                         parser.addParserWarning("msg.jsdoc.extraversion", stream.getLineno(), stream.getCharno()); [EOL]                                     } [EOL]                                 } [EOL]                                 token = versionInfo.token; [EOL]                                 continue retry; [EOL]                             case CONSTANT: [EOL]                             case DEFINE: [EOL]                             case RETURN: [EOL]                             case PRIVATE: [EOL]                             case PROTECTED: [EOL]                             case PUBLIC: [EOL]                             case THIS: [EOL]                             case TYPE: [EOL]                             case TYPEDEF: [EOL]                                 lineno = stream.getLineno(); [EOL]                                 charno = stream.getCharno(); [EOL]                                 Node typeNode = null; [EOL]                                 boolean hasType = lookAheadForTypeAnnotation(); [EOL]                                 boolean isAlternateTypeAnnotation = (annotation == Annotation.PRIVATE || annotation == Annotation.PROTECTED || annotation == Annotation.PUBLIC || annotation == Annotation.CONSTANT); [EOL]                                 boolean canSkipTypeAnnotation = (isAlternateTypeAnnotation || annotation == Annotation.RETURN); [EOL]                                 type = null; [EOL]                                 if (hasType || !canSkipTypeAnnotation) { [EOL]                                     skipEOLs(); [EOL]                                     token = next(); [EOL]                                     typeNode = parseAndRecordTypeNode(token); [EOL]                                     if (annotation == Annotation.THIS) { [EOL]                                         typeNode = wrapNode(Token.BANG, typeNode); [EOL]                                     } [EOL]                                     type = createJSTypeExpression(typeNode); [EOL]                                 } [EOL]                                 boolean hasError = type == null && !canSkipTypeAnnotation; [EOL]                                 if (!hasError) { [EOL]                                     if ((type != null && isAlternateTypeAnnotation) || annotation == Annotation.TYPE) { [EOL]                                         if (!jsdocBuilder.recordType(type)) { [EOL]                                             parser.addTypeWarning("msg.jsdoc.incompat.type", lineno, charno); [EOL]                                         } [EOL]                                     } [EOL]                                     switch(annotation) { [EOL]                                         case CONSTANT: [EOL]                                             if (!jsdocBuilder.recordConstancy()) { [EOL]                                                 parser.addParserWarning("msg.jsdoc.const", stream.getLineno(), stream.getCharno()); [EOL]                                             } [EOL]                                             break; [EOL]                                         case DEFINE: [EOL]                                             if (!jsdocBuilder.recordDefineType(type)) { [EOL]                                                 parser.addParserWarning("msg.jsdoc.define", lineno, charno); [EOL]                                             } [EOL]                                             break; [EOL]                                         case PRIVATE: [EOL]                                             if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) { [EOL]                                                 parser.addParserWarning("msg.jsdoc.visibility.private", lineno, charno); [EOL]                                             } [EOL]                                             break; [EOL]                                         case PROTECTED: [EOL]                                             if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) { [EOL]                                                 parser.addParserWarning("msg.jsdoc.visibility.protected", lineno, charno); [EOL]                                             } [EOL]                                             break; [EOL]                                         case PUBLIC: [EOL]                                             if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) { [EOL]                                                 parser.addParserWarning("msg.jsdoc.visibility.public", lineno, charno); [EOL]                                             } [EOL]                                             break; [EOL]                                         case RETURN: [EOL]                                             if (type == null) { [EOL]                                                 type = createJSTypeExpression(newNode(Token.QMARK)); [EOL]                                             } [EOL]                                             if (!jsdocBuilder.recordReturnType(type)) { [EOL]                                                 parser.addTypeWarning("msg.jsdoc.incompat.type", lineno, charno); [EOL]                                                 break; [EOL]                                             } [EOL]                                             if (jsdocBuilder.shouldParseDocumentation()) { [EOL]                                                 ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token); [EOL]                                                 String returnDescription = returnDescriptionInfo.string; [EOL]                                                 if (returnDescription.length() > 0) { [EOL]                                                     jsdocBuilder.recordReturnDescription(returnDescription); [EOL]                                                 } [EOL]                                                 token = returnDescriptionInfo.token; [EOL]                                             } else { [EOL]                                                 token = eatTokensUntilEOL(token); [EOL]                                             } [EOL]                                             continue retry; [EOL]                                         case THIS: [EOL]                                             if (!jsdocBuilder.recordThisType(type)) { [EOL]                                                 parser.addTypeWarning("msg.jsdoc.incompat.type", lineno, charno); [EOL]                                             } [EOL]                                             break; [EOL]                                         case TYPEDEF: [EOL]                                             if (!jsdocBuilder.recordTypedef(type)) { [EOL]                                                 parser.addTypeWarning("msg.jsdoc.incompat.type", lineno, charno); [EOL]                                             } [EOL]                                             break; [EOL]                                     } [EOL]                                 } [EOL]                                 token = eatTokensUntilEOL(); [EOL]                                 continue retry; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case EOC: [EOL]                 if (hasParsedFileOverviewDocInfo()) { [EOL]                     fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo(); [EOL]                 } [EOL]                 checkExtendedTypes(extendedTypes); [EOL]                 return true; [EOL]             case EOF: [EOL]                 jsdocBuilder.build(null); [EOL]                 parser.addParserWarning("msg.unexpected.eof", stream.getLineno(), stream.getCharno()); [EOL]                 checkExtendedTypes(extendedTypes); [EOL]                 return false; [EOL]             case EOL: [EOL]                 if (state == State.SEARCHING_NEWLINE) { [EOL]                     state = State.SEARCHING_ANNOTATION; [EOL]                 } [EOL]                 token = next(); [EOL]                 continue retry; [EOL]             default: [EOL]                 if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) { [EOL]                     token = next(); [EOL]                     continue retry; [EOL]                 } else { [EOL]                     state = State.SEARCHING_NEWLINE; [EOL]                     token = eatTokensUntilEOL(); [EOL]                     continue retry; [EOL]                 } [EOL]         } [EOL]         token = next(); [EOL]     } [EOL] } <line_num>: 182,992
private void checkExtendedTypes(List<ExtendedTypeInfo> extendedTypes) { [EOL]     for (ExtendedTypeInfo typeInfo : extendedTypes) { [EOL]         if (jsdocBuilder.isInterfaceRecorded()) { [EOL]             if (!jsdocBuilder.recordExtendedInterface(typeInfo.type)) { [EOL]                 parser.addParserWarning("msg.jsdoc.extends.duplicate", typeInfo.lineno, typeInfo.charno); [EOL]             } [EOL]         } else { [EOL]             if (!jsdocBuilder.recordBaseType(typeInfo.type)) { [EOL]                 parser.addTypeWarning("msg.jsdoc.incompat.type", typeInfo.lineno, typeInfo.charno); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 994,1009
private JsDocToken parseSuppressTag(JsDocToken token) { [EOL]     if (token == JsDocToken.LC) { [EOL]         Set<String> suppressions = new HashSet<String>(); [EOL]         while (true) { [EOL]             if (match(JsDocToken.STRING)) { [EOL]                 String name = stream.getString(); [EOL]                 if (!suppressionNames.contains(name)) { [EOL]                     parser.addParserWarning("msg.jsdoc.suppress.unknown", name, stream.getLineno(), stream.getCharno()); [EOL]                 } [EOL]                 suppressions.add(stream.getString()); [EOL]                 token = next(); [EOL]             } else { [EOL]                 parser.addParserWarning("msg.jsdoc.suppress", stream.getLineno(), stream.getCharno()); [EOL]                 return token; [EOL]             } [EOL]             if (match(JsDocToken.PIPE)) { [EOL]                 token = next(); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (!match(JsDocToken.RC)) { [EOL]             parser.addParserWarning("msg.jsdoc.suppress", stream.getLineno(), stream.getCharno()); [EOL]         } else { [EOL]             token = next(); [EOL]             if (!jsdocBuilder.recordSuppressions(suppressions)) { [EOL]                 parser.addParserWarning("msg.jsdoc.suppress.duplicate", stream.getLineno(), stream.getCharno()); [EOL]             } [EOL]         } [EOL]     } [EOL]     return token; [EOL] } <line_num>: 1017,1055
private JsDocToken parseModifiesTag(JsDocToken token) { [EOL]     if (token == JsDocToken.LC) { [EOL]         Set<String> modifies = new HashSet<String>(); [EOL]         while (true) { [EOL]             if (match(JsDocToken.STRING)) { [EOL]                 String name = stream.getString(); [EOL]                 if (!modifiesAnnotationKeywords.contains(name) && !jsdocBuilder.hasParameter(name)) { [EOL]                     parser.addParserWarning("msg.jsdoc.modifies.unknown", name, stream.getLineno(), stream.getCharno()); [EOL]                 } [EOL]                 modifies.add(stream.getString()); [EOL]                 token = next(); [EOL]             } else { [EOL]                 parser.addParserWarning("msg.jsdoc.modifies", stream.getLineno(), stream.getCharno()); [EOL]                 return token; [EOL]             } [EOL]             if (match(JsDocToken.PIPE)) { [EOL]                 token = next(); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (!match(JsDocToken.RC)) { [EOL]             parser.addParserWarning("msg.jsdoc.modifies", stream.getLineno(), stream.getCharno()); [EOL]         } else { [EOL]             token = next(); [EOL]             if (!jsdocBuilder.recordModifies(modifies)) { [EOL]                 parser.addParserWarning("msg.jsdoc.modifies.duplicate", stream.getLineno(), stream.getCharno()); [EOL]             } [EOL]         } [EOL]     } [EOL]     return token; [EOL] } <line_num>: 1063,1102
private Node parseAndRecordTypeNode(JsDocToken token) { [EOL]     return parseAndRecordTypeNode(token, token == JsDocToken.LC); [EOL] } <line_num>: 1111,1113
private Node parseAndRecordTypeNode(JsDocToken token, boolean matchingLC) { [EOL]     return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(), matchingLC, false); [EOL] } <line_num>: 1123,1126
private Node parseAndRecordTypeNameNode(JsDocToken token, int lineno, int startCharno, boolean matchingLC) { [EOL]     return parseAndRecordTypeNode(token, lineno, startCharno, matchingLC, true); [EOL] } <line_num>: 1138,1141
private Node parseAndRecordParamTypeNode(JsDocToken token) { [EOL]     Preconditions.checkArgument(token == JsDocToken.LC); [EOL]     int lineno = stream.getLineno(); [EOL]     int startCharno = stream.getCharno(); [EOL]     Node typeNode = parseParamTypeExpressionAnnotation(token); [EOL]     if (typeNode != null) { [EOL]         int endLineno = stream.getLineno(); [EOL]         int endCharno = stream.getCharno(); [EOL]         jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endLineno, endCharno, true); [EOL]     } [EOL]     return typeNode; [EOL] } <line_num>: 1156,1170
private Node parseAndRecordTypeNode(JsDocToken token, int lineno, int startCharno, boolean matchingLC, boolean onlyParseSimpleNames) { [EOL]     Node typeNode = null; [EOL]     if (onlyParseSimpleNames) { [EOL]         typeNode = parseTypeNameAnnotation(token); [EOL]     } else { [EOL]         typeNode = parseTypeExpressionAnnotation(token); [EOL]     } [EOL]     if (typeNode != null) { [EOL]         int endLineno = stream.getLineno(); [EOL]         int endCharno = stream.getCharno(); [EOL]         jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endLineno, endCharno, matchingLC); [EOL]     } [EOL]     return typeNode; [EOL] } <line_num>: 1185,1206
private String toString(JsDocToken token) { [EOL]     switch(token) { [EOL]         case ANNOTATION: [EOL]             return "@" + stream.getString(); [EOL]         case BANG: [EOL]             return "!"; [EOL]         case COMMA: [EOL]             return ","; [EOL]         case COLON: [EOL]             return ":"; [EOL]         case GT: [EOL]             return ">"; [EOL]         case LB: [EOL]             return "["; [EOL]         case LC: [EOL]             return "{"; [EOL]         case LP: [EOL]             return "("; [EOL]         case LT: [EOL]             return ".<"; [EOL]         case QMARK: [EOL]             return "?"; [EOL]         case PIPE: [EOL]             return "|"; [EOL]         case RB: [EOL]             return "]"; [EOL]         case RC: [EOL]             return "}"; [EOL]         case RP: [EOL]             return ")"; [EOL]         case STAR: [EOL]             return "*"; [EOL]         case ELLIPSIS: [EOL]             return "..."; [EOL]         case EQUALS: [EOL]             return "="; [EOL]         case STRING: [EOL]             return stream.getString(); [EOL]         default: [EOL]             throw new IllegalStateException(token.toString()); [EOL]     } [EOL] } <line_num>: 1211,1270
private JSTypeExpression createJSTypeExpression(Node n) { [EOL]     return n == null ? null : new JSTypeExpression(n, getSourceName()); [EOL] } <line_num>: 1276,1279
private ExtractionInfo extractSingleLineBlock() { [EOL]     stream.update(); [EOL]     int lineno = stream.getLineno(); [EOL]     int charno = stream.getCharno() + 1; [EOL]     String line = stream.getRemainingJSDocLine().trim(); [EOL]     if (line.length() > 0) { [EOL]         jsdocBuilder.markText(line, lineno, charno, lineno, charno + line.length()); [EOL]     } [EOL]     return new ExtractionInfo(line, next()); [EOL] } <line_num>: 1318,1334
private ExtractionInfo extractMultilineTextualBlock(JsDocToken token) { [EOL]     return extractMultilineTextualBlock(token, WhitespaceOption.SINGLE_LINE); [EOL] } <line_num>: 1336,1338
@SuppressWarnings("fallthrough") [EOL] private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) { [EOL]     if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) { [EOL]         return new ExtractionInfo("", token); [EOL]     } [EOL]     stream.update(); [EOL]     int startLineno = stream.getLineno(); [EOL]     int startCharno = stream.getCharno() + 1; [EOL]     String line = stream.getRemainingJSDocLine(); [EOL]     if (option != WhitespaceOption.PRESERVE) { [EOL]         line = line.trim(); [EOL]     } [EOL]     StringBuilder builder = new StringBuilder(); [EOL]     builder.append(line); [EOL]     state = State.SEARCHING_ANNOTATION; [EOL]     token = next(); [EOL]     boolean ignoreStar = false; [EOL]     int lineStartChar = -1; [EOL]     do { [EOL]         switch(token) { [EOL]             case STAR: [EOL]                 if (ignoreStar) { [EOL]                     lineStartChar = stream.getCharno() + 1; [EOL]                 } else { [EOL]                     if (builder.length() > 0) { [EOL]                         builder.append(' '); [EOL]                     } [EOL]                     builder.append('*'); [EOL]                 } [EOL]                 token = next(); [EOL]                 continue; [EOL]             case EOL: [EOL]                 if (option != WhitespaceOption.SINGLE_LINE) { [EOL]                     builder.append("\n"); [EOL]                 } [EOL]                 ignoreStar = true; [EOL]                 lineStartChar = 0; [EOL]                 token = next(); [EOL]                 continue; [EOL]             default: [EOL]                 ignoreStar = false; [EOL]                 state = State.SEARCHING_ANNOTATION; [EOL]                 boolean isEOC = token == JsDocToken.EOC; [EOL]                 if (!isEOC) { [EOL]                     if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) { [EOL]                         int numSpaces = stream.getCharno() - lineStartChar; [EOL]                         for (int i = 0; i < numSpaces; i++) { [EOL]                             builder.append(' '); [EOL]                         } [EOL]                         lineStartChar = -1; [EOL]                     } else if (builder.length() > 0) { [EOL]                         builder.append(' '); [EOL]                     } [EOL]                 } [EOL]                 if (token == JsDocToken.EOC || token == JsDocToken.EOF || (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) { [EOL]                     String multilineText = builder.toString(); [EOL]                     if (option != WhitespaceOption.PRESERVE) { [EOL]                         multilineText = multilineText.trim(); [EOL]                     } [EOL]                     int endLineno = stream.getLineno(); [EOL]                     int endCharno = stream.getCharno(); [EOL]                     if (multilineText.length() > 0) { [EOL]                         jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno); [EOL]                     } [EOL]                     return new ExtractionInfo(multilineText, token); [EOL]                 } [EOL]                 builder.append(toString(token)); [EOL]                 line = stream.getRemainingJSDocLine(); [EOL]                 if (option != WhitespaceOption.PRESERVE) { [EOL]                     line = trimEnd(line); [EOL]                 } [EOL]                 builder.append(line); [EOL]                 token = next(); [EOL]         } [EOL]     } while (true); [EOL] } <line_num>: 1367,1480
private ExtractionInfo extractBlockComment(JsDocToken token) { [EOL]     StringBuilder builder = new StringBuilder(); [EOL]     boolean ignoreStar = true; [EOL]     do { [EOL]         switch(token) { [EOL]             case ANNOTATION: [EOL]             case EOC: [EOL]             case EOF: [EOL]                 return new ExtractionInfo(builder.toString().trim(), token); [EOL]             case STAR: [EOL]                 if (!ignoreStar) { [EOL]                     if (builder.length() > 0) { [EOL]                         builder.append(' '); [EOL]                     } [EOL]                     builder.append('*'); [EOL]                 } [EOL]                 token = next(); [EOL]                 continue; [EOL]             case EOL: [EOL]                 ignoreStar = true; [EOL]                 builder.append('\n'); [EOL]                 token = next(); [EOL]                 continue; [EOL]             default: [EOL]                 if (!ignoreStar && builder.length() > 0) { [EOL]                     builder.append(' '); [EOL]                 } [EOL]                 ignoreStar = false; [EOL]                 builder.append(toString(token)); [EOL]                 String line = stream.getRemainingJSDocLine(); [EOL]                 line = trimEnd(line); [EOL]                 builder.append(line); [EOL]                 token = next(); [EOL]         } [EOL]     } while (true); [EOL] } <line_num>: 1494,1539
private static String trimEnd(String s) { [EOL]     int trimCount = 0; [EOL]     while (trimCount < s.length()) { [EOL]         char ch = s.charAt(s.length() - trimCount - 1); [EOL]         if (Character.isWhitespace(ch)) { [EOL]             trimCount++; [EOL]         } else { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (trimCount == 0) { [EOL]         return s; [EOL]     } [EOL]     return s.substring(0, s.length() - trimCount); [EOL] } <line_num>: 1551,1566
private Node parseTypeExpressionAnnotation(JsDocToken token) { [EOL]     if (token == JsDocToken.LC) { [EOL]         skipEOLs(); [EOL]         Node typeNode = parseTopLevelTypeExpression(next()); [EOL]         if (typeNode != null) { [EOL]             skipEOLs(); [EOL]             if (!match(JsDocToken.RC)) { [EOL]                 reportTypeSyntaxWarning("msg.jsdoc.missing.rc"); [EOL]             } else { [EOL]                 next(); [EOL]             } [EOL]         } [EOL]         return typeNode; [EOL]     } else { [EOL]         return parseTypeExpression(token); [EOL]     } [EOL] } <line_num>: 1581,1598
private Node parseParamTypeExpressionAnnotation(JsDocToken token) { [EOL]     Preconditions.checkArgument(token == JsDocToken.LC); [EOL]     skipEOLs(); [EOL]     boolean restArg = false; [EOL]     token = next(); [EOL]     if (token == JsDocToken.ELLIPSIS) { [EOL]         token = next(); [EOL]         if (token == JsDocToken.RC) { [EOL]             return wrapNode(Token.ELLIPSIS, IR.empty()); [EOL]         } [EOL]         restArg = true; [EOL]     } [EOL]     Node typeNode = parseTopLevelTypeExpression(token); [EOL]     if (typeNode != null) { [EOL]         skipEOLs(); [EOL]         if (restArg) { [EOL]             typeNode = wrapNode(Token.ELLIPSIS, typeNode); [EOL]         } else if (match(JsDocToken.EQUALS)) { [EOL]             next(); [EOL]             skipEOLs(); [EOL]             typeNode = wrapNode(Token.EQUALS, typeNode); [EOL]         } [EOL]         if (!match(JsDocToken.RC)) { [EOL]             reportTypeSyntaxWarning("msg.jsdoc.missing.rc"); [EOL]         } else { [EOL]             next(); [EOL]         } [EOL]     } [EOL]     return typeNode; [EOL] } <line_num>: 1609,1644
private Node parseTypeNameAnnotation(JsDocToken token) { [EOL]     if (token == JsDocToken.LC) { [EOL]         skipEOLs(); [EOL]         Node typeNode = parseTypeName(next()); [EOL]         if (typeNode != null) { [EOL]             skipEOLs(); [EOL]             if (!match(JsDocToken.RC)) { [EOL]                 reportTypeSyntaxWarning("msg.jsdoc.missing.rc"); [EOL]             } else { [EOL]                 next(); [EOL]             } [EOL]         } [EOL]         return typeNode; [EOL]     } else { [EOL]         return parseTypeName(token); [EOL]     } [EOL] } <line_num>: 1649,1666
private Node parseTopLevelTypeExpression(JsDocToken token) { [EOL]     Node typeExpr = parseTypeExpression(token); [EOL]     if (typeExpr != null) { [EOL]         if (match(JsDocToken.PIPE)) { [EOL]             next(); [EOL]             if (match(JsDocToken.PIPE)) { [EOL]                 next(); [EOL]             } [EOL]             skipEOLs(); [EOL]             token = next(); [EOL]             return parseUnionTypeWithAlternate(token, typeExpr); [EOL]         } [EOL]     } [EOL]     return typeExpr; [EOL] } <line_num>: 1674,1690
private Node parseTypeExpressionList(JsDocToken token) { [EOL]     Node typeExpr = parseTopLevelTypeExpression(token); [EOL]     if (typeExpr == null) { [EOL]         return null; [EOL]     } [EOL]     Node typeList = IR.block(); [EOL]     typeList.addChildToBack(typeExpr); [EOL]     while (match(JsDocToken.COMMA)) { [EOL]         next(); [EOL]         skipEOLs(); [EOL]         typeExpr = parseTopLevelTypeExpression(next()); [EOL]         if (typeExpr == null) { [EOL]             return null; [EOL]         } [EOL]         typeList.addChildToBack(typeExpr); [EOL]     } [EOL]     return typeList; [EOL] } <line_num>: 1696,1713
private Node parseTypeExpression(JsDocToken token) { [EOL]     if (token == JsDocToken.QMARK) { [EOL]         token = next(); [EOL]         if (token == JsDocToken.COMMA || token == JsDocToken.EQUALS || token == JsDocToken.RB || token == JsDocToken.RC || token == JsDocToken.RP || token == JsDocToken.PIPE || token == JsDocToken.GT) { [EOL]             restoreLookAhead(token); [EOL]             return newNode(Token.QMARK); [EOL]         } [EOL]         return wrapNode(Token.QMARK, parseBasicTypeExpression(token)); [EOL]     } else if (token == JsDocToken.BANG) { [EOL]         return wrapNode(Token.BANG, parseBasicTypeExpression(next())); [EOL]     } else { [EOL]         Node basicTypeExpr = parseBasicTypeExpression(token); [EOL]         if (basicTypeExpr != null) { [EOL]             if (match(JsDocToken.QMARK)) { [EOL]                 next(); [EOL]                 return wrapNode(Token.QMARK, basicTypeExpr); [EOL]             } else if (match(JsDocToken.BANG)) { [EOL]                 next(); [EOL]                 return wrapNode(Token.BANG, basicTypeExpr); [EOL]             } [EOL]         } [EOL]         return basicTypeExpr; [EOL]     } [EOL] } <line_num>: 1723,1766
private Node parseBasicTypeExpression(JsDocToken token) { [EOL]     if (token == JsDocToken.STAR) { [EOL]         return newNode(Token.STAR); [EOL]     } else if (token == JsDocToken.LB) { [EOL]         skipEOLs(); [EOL]         return parseArrayType(next()); [EOL]     } else if (token == JsDocToken.LC) { [EOL]         skipEOLs(); [EOL]         return parseRecordType(next()); [EOL]     } else if (token == JsDocToken.LP) { [EOL]         skipEOLs(); [EOL]         return parseUnionType(next()); [EOL]     } else if (token == JsDocToken.STRING) { [EOL]         String string = stream.getString(); [EOL]         if ("function".equals(string)) { [EOL]             skipEOLs(); [EOL]             return parseFunctionType(next()); [EOL]         } else if ("null".equals(string) || "undefined".equals(string)) { [EOL]             return newStringNode(string); [EOL]         } else { [EOL]             return parseTypeName(token); [EOL]         } [EOL]     } [EOL]     restoreLookAhead(token); [EOL]     return reportGenericTypeSyntaxWarning(); [EOL] } <line_num>: 1772,1798
private Node parseTypeName(JsDocToken token) { [EOL]     if (token != JsDocToken.STRING) { [EOL]         return reportGenericTypeSyntaxWarning(); [EOL]     } [EOL]     String typeName = stream.getString(); [EOL]     int lineno = stream.getLineno(); [EOL]     int charno = stream.getCharno(); [EOL]     while (match(JsDocToken.EOL) && typeName.charAt(typeName.length() - 1) == '.') { [EOL]         skipEOLs(); [EOL]         if (match(JsDocToken.STRING)) { [EOL]             next(); [EOL]             typeName += stream.getString(); [EOL]         } [EOL]     } [EOL]     Node typeNameNode = newStringNode(typeName, lineno, charno); [EOL]     if (match(JsDocToken.LT)) { [EOL]         next(); [EOL]         skipEOLs(); [EOL]         Node memberType = parseTypeExpressionList(next()); [EOL]         if (memberType != null) { [EOL]             typeNameNode.addChildToFront(memberType); [EOL]             skipEOLs(); [EOL]             if (!match(JsDocToken.GT)) { [EOL]                 return reportTypeSyntaxWarning("msg.jsdoc.missing.gt"); [EOL]             } [EOL]             next(); [EOL]         } [EOL]     } [EOL]     return typeNameNode; [EOL] } <line_num>: 1804,1839
private Node parseFunctionType(JsDocToken token) { [EOL]     if (token != JsDocToken.LP) { [EOL]         restoreLookAhead(token); [EOL]         return reportTypeSyntaxWarning("msg.jsdoc.missing.lp"); [EOL]     } [EOL]     Node functionType = newNode(Token.FUNCTION); [EOL]     Node parameters = null; [EOL]     skipEOLs(); [EOL]     if (!match(JsDocToken.RP)) { [EOL]         token = next(); [EOL]         boolean hasParams = true; [EOL]         if (token == JsDocToken.STRING) { [EOL]             String tokenStr = stream.getString(); [EOL]             boolean isThis = "this".equals(tokenStr); [EOL]             boolean isNew = "new".equals(tokenStr); [EOL]             if (isThis || isNew) { [EOL]                 if (match(JsDocToken.COLON)) { [EOL]                     next(); [EOL]                     skipEOLs(); [EOL]                     Node contextType = wrapNode(isThis ? Token.THIS : Token.NEW, parseTypeName(next())); [EOL]                     if (contextType == null) { [EOL]                         return null; [EOL]                     } [EOL]                     functionType.addChildToFront(contextType); [EOL]                 } else { [EOL]                     return reportTypeSyntaxWarning("msg.jsdoc.missing.colon"); [EOL]                 } [EOL]                 if (match(JsDocToken.COMMA)) { [EOL]                     next(); [EOL]                     skipEOLs(); [EOL]                     token = next(); [EOL]                 } else { [EOL]                     hasParams = false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (hasParams) { [EOL]             parameters = parseParametersType(token); [EOL]             if (parameters == null) { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (parameters != null) { [EOL]         functionType.addChildToBack(parameters); [EOL]     } [EOL]     skipEOLs(); [EOL]     if (!match(JsDocToken.RP)) { [EOL]         return reportTypeSyntaxWarning("msg.jsdoc.missing.rp"); [EOL]     } [EOL]     skipEOLs(); [EOL]     Node resultType = parseResultType(next()); [EOL]     if (resultType == null) { [EOL]         return null; [EOL]     } else { [EOL]         functionType.addChildToBack(resultType); [EOL]     } [EOL]     return functionType; [EOL] } <line_num>: 1846,1916
private Node parseParametersType(JsDocToken token) { [EOL]     Node paramsType = newNode(Token.PARAM_LIST); [EOL]     boolean isVarArgs = false; [EOL]     Node paramType = null; [EOL]     if (token != JsDocToken.RP) { [EOL]         do { [EOL]             if (paramType != null) { [EOL]                 next(); [EOL]                 skipEOLs(); [EOL]                 token = next(); [EOL]             } [EOL]             if (token == JsDocToken.ELLIPSIS) { [EOL]                 skipEOLs(); [EOL]                 if (match(JsDocToken.RP)) { [EOL]                     paramType = newNode(Token.ELLIPSIS); [EOL]                 } else { [EOL]                     skipEOLs(); [EOL]                     if (!match(JsDocToken.LB)) { [EOL]                         return reportTypeSyntaxWarning("msg.jsdoc.missing.lb"); [EOL]                     } [EOL]                     next(); [EOL]                     skipEOLs(); [EOL]                     paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next())); [EOL]                     skipEOLs(); [EOL]                     if (!match(JsDocToken.RB)) { [EOL]                         return reportTypeSyntaxWarning("msg.jsdoc.missing.rb"); [EOL]                     } [EOL]                     skipEOLs(); [EOL]                     next(); [EOL]                 } [EOL]                 isVarArgs = true; [EOL]             } else { [EOL]                 paramType = parseTypeExpression(token); [EOL]                 if (match(JsDocToken.EQUALS)) { [EOL]                     skipEOLs(); [EOL]                     next(); [EOL]                     paramType = wrapNode(Token.EQUALS, paramType); [EOL]                 } [EOL]             } [EOL]             if (paramType == null) { [EOL]                 return null; [EOL]             } [EOL]             paramsType.addChildToBack(paramType); [EOL]             if (isVarArgs) { [EOL]                 break; [EOL]             } [EOL]         } while (match(JsDocToken.COMMA)); [EOL]     } [EOL]     if (isVarArgs && match(JsDocToken.COMMA)) { [EOL]         return reportTypeSyntaxWarning("msg.jsdoc.function.varargs"); [EOL]     } [EOL]     return paramsType; [EOL] } <line_num>: 1940,2004
private Node parseResultType(JsDocToken token) { [EOL]     skipEOLs(); [EOL]     if (!match(JsDocToken.COLON)) { [EOL]         return newNode(Token.EMPTY); [EOL]     } [EOL]     token = next(); [EOL]     skipEOLs(); [EOL]     if (match(JsDocToken.STRING) && "void".equals(stream.getString())) { [EOL]         next(); [EOL]         return newNode(Token.VOID); [EOL]     } else { [EOL]         return parseTypeExpression(next()); [EOL]     } [EOL] } <line_num>: 2009,2023
private Node parseUnionType(JsDocToken token) { [EOL]     return parseUnionTypeWithAlternate(token, null); [EOL] } <line_num>: 2031,2033
private Node parseUnionTypeWithAlternate(JsDocToken token, Node alternate) { [EOL]     Node union = newNode(Token.PIPE); [EOL]     if (alternate != null) { [EOL]         union.addChildToBack(alternate); [EOL]     } [EOL]     Node expr = null; [EOL]     do { [EOL]         if (expr != null) { [EOL]             skipEOLs(); [EOL]             token = next(); [EOL]             Preconditions.checkState(token == JsDocToken.PIPE || token == JsDocToken.COMMA); [EOL]             boolean isPipe = token == JsDocToken.PIPE; [EOL]             if (isPipe && match(JsDocToken.PIPE)) { [EOL]                 next(); [EOL]             } [EOL]             skipEOLs(); [EOL]             token = next(); [EOL]         } [EOL]         expr = parseTypeExpression(token); [EOL]         if (expr == null) { [EOL]             return null; [EOL]         } [EOL]         union.addChildToBack(expr); [EOL]     } while (match(JsDocToken.PIPE, JsDocToken.COMMA)); [EOL]     if (alternate == null) { [EOL]         skipEOLs(); [EOL]         if (!match(JsDocToken.RP)) { [EOL]             return reportTypeSyntaxWarning("msg.jsdoc.missing.rp"); [EOL]         } [EOL]         next(); [EOL]     } [EOL]     return union; [EOL] } <line_num>: 2039,2078
private Node parseArrayType(JsDocToken token) { [EOL]     Node array = newNode(Token.LB); [EOL]     Node arg = null; [EOL]     boolean hasVarArgs = false; [EOL]     do { [EOL]         if (arg != null) { [EOL]             next(); [EOL]             skipEOLs(); [EOL]             token = next(); [EOL]         } [EOL]         if (token == JsDocToken.ELLIPSIS) { [EOL]             arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next())); [EOL]             hasVarArgs = true; [EOL]         } else { [EOL]             arg = parseTypeExpression(token); [EOL]         } [EOL]         if (arg == null) { [EOL]             return null; [EOL]         } [EOL]         array.addChildToBack(arg); [EOL]         if (hasVarArgs) { [EOL]             break; [EOL]         } [EOL]         skipEOLs(); [EOL]     } while (match(JsDocToken.COMMA)); [EOL]     if (!match(JsDocToken.RB)) { [EOL]         return reportTypeSyntaxWarning("msg.jsdoc.missing.rb"); [EOL]     } [EOL]     next(); [EOL]     return array; [EOL] } <line_num>: 2085,2119
private Node parseRecordType(JsDocToken token) { [EOL]     Node recordType = newNode(Token.LC); [EOL]     Node fieldTypeList = parseFieldTypeList(token); [EOL]     if (fieldTypeList == null) { [EOL]         return reportGenericTypeSyntaxWarning(); [EOL]     } [EOL]     skipEOLs(); [EOL]     if (!match(JsDocToken.RC)) { [EOL]         return reportTypeSyntaxWarning("msg.jsdoc.missing.rc"); [EOL]     } [EOL]     next(); [EOL]     recordType.addChildToBack(fieldTypeList); [EOL]     return recordType; [EOL] } <line_num>: 2124,2141
private Node parseFieldTypeList(JsDocToken token) { [EOL]     Node fieldTypeList = newNode(Token.LB); [EOL]     do { [EOL]         Node fieldType = parseFieldType(token); [EOL]         if (fieldType == null) { [EOL]             return null; [EOL]         } [EOL]         fieldTypeList.addChildToBack(fieldType); [EOL]         skipEOLs(); [EOL]         if (!match(JsDocToken.COMMA)) { [EOL]             break; [EOL]         } [EOL]         next(); [EOL]         skipEOLs(); [EOL]         token = next(); [EOL]     } while (true); [EOL]     return fieldTypeList; [EOL] } <line_num>: 2146,2172
private Node parseFieldType(JsDocToken token) { [EOL]     Node fieldName = parseFieldName(token); [EOL]     if (fieldName == null) { [EOL]         return null; [EOL]     } [EOL]     skipEOLs(); [EOL]     if (!match(JsDocToken.COLON)) { [EOL]         return fieldName; [EOL]     } [EOL]     next(); [EOL]     skipEOLs(); [EOL]     Node typeExpression = parseTypeExpression(next()); [EOL]     if (typeExpression == null) { [EOL]         return null; [EOL]     } [EOL]     Node fieldType = newNode(Token.COLON); [EOL]     fieldType.addChildToBack(fieldName); [EOL]     fieldType.addChildToBack(typeExpression); [EOL]     return fieldType; [EOL] } <line_num>: 2177,2205
private Node parseFieldName(JsDocToken token) { [EOL]     switch(token) { [EOL]         case STRING: [EOL]             String string = stream.getString(); [EOL]             return newStringNode(string); [EOL]         default: [EOL]             return null; [EOL]     } [EOL] } <line_num>: 2211,2220
private Node wrapNode(int type, Node n) { [EOL]     return n == null ? null : new Node(type, n, stream.getLineno(), stream.getCharno()).clonePropsFrom(templateNode); [EOL] } <line_num>: 2222,2226
private Node newNode(int type) { [EOL]     return new Node(type, stream.getLineno(), stream.getCharno()).clonePropsFrom(templateNode); [EOL] } <line_num>: 2228,2231
private Node newStringNode(String s) { [EOL]     return newStringNode(s, stream.getLineno(), stream.getCharno()); [EOL] } <line_num>: 2233,2235
private Node newStringNode(String s, int lineno, int charno) { [EOL]     Node n = Node.newString(s, lineno, charno).clonePropsFrom(templateNode); [EOL]     n.setLength(s.length()); [EOL]     return n; [EOL] } <line_num>: 2237,2241
private Node createTemplateNode() { [EOL]     Node templateNode = IR.script(); [EOL]     templateNode.setStaticSourceFile(this.associatedNode != null ? this.associatedNode.getStaticSourceFile() : null); [EOL]     return templateNode; [EOL] } <line_num>: 2245,2253
private Node reportTypeSyntaxWarning(String warning) { [EOL]     parser.addTypeWarning(warning, stream.getLineno(), stream.getCharno()); [EOL]     return null; [EOL] } <line_num>: 2255,2258
private Node reportGenericTypeSyntaxWarning() { [EOL]     return reportTypeSyntaxWarning("msg.jsdoc.type.syntax"); [EOL] } <line_num>: 2260,2262
private JsDocToken eatTokensUntilEOL() { [EOL]     return eatTokensUntilEOL(next()); [EOL] } <line_num>: 2268,2270
private JsDocToken eatTokensUntilEOL(JsDocToken token) { [EOL]     do { [EOL]         if (token == JsDocToken.EOL || token == JsDocToken.EOC || token == JsDocToken.EOF) { [EOL]             state = State.SEARCHING_ANNOTATION; [EOL]             return token; [EOL]         } [EOL]         token = next(); [EOL]     } while (true); [EOL] } <line_num>: 2276,2285
private void restoreLookAhead(JsDocToken token) { [EOL]     unreadToken = token; [EOL] } <line_num>: 2298,2300
private boolean match(JsDocToken token) { [EOL]     unreadToken = next(); [EOL]     return unreadToken == token; [EOL] } <line_num>: 2306,2309
private boolean match(JsDocToken token1, JsDocToken token2) { [EOL]     unreadToken = next(); [EOL]     return unreadToken == token1 || unreadToken == token2; [EOL] } <line_num>: 2315,2318
private JsDocToken next() { [EOL]     if (unreadToken == NO_UNREAD_TOKEN) { [EOL]         return stream.getJsDocToken(); [EOL]     } else { [EOL]         return current(); [EOL]     } [EOL] } <line_num>: 2324,2330
private JsDocToken current() { [EOL]     JsDocToken t = unreadToken; [EOL]     unreadToken = NO_UNREAD_TOKEN; [EOL]     return t; [EOL] } <line_num>: 2335,2339
private void skipEOLs() { [EOL]     while (match(JsDocToken.EOL)) { [EOL]         next(); [EOL]         if (match(JsDocToken.STAR)) { [EOL]             next(); [EOL]         } [EOL]     } [EOL] } <line_num>: 2345,2352
private boolean hasParsedFileOverviewDocInfo() { [EOL]     return jsdocBuilder.isPopulatedWithFileOverview(); [EOL] } <line_num>: 2358,2360
boolean hasParsedJSDocInfo() { [EOL]     return jsdocBuilder.isPopulated(); [EOL] } <line_num>: 2362,2364
JSDocInfo retrieveAndResetParsedJSDocInfo() { [EOL]     return jsdocBuilder.build(associatedNode); [EOL] } <line_num>: 2366,2368
JSDocInfo getFileOverviewJSDocInfo() { [EOL]     return fileOverviewJSDocInfo; [EOL] } <line_num>: 2373,2375
private boolean lookAheadForTypeAnnotation() { [EOL]     boolean matchedLc = false; [EOL]     int c; [EOL]     while (true) { [EOL]         c = stream.getChar(); [EOL]         if (c == ' ') { [EOL]             continue; [EOL]         } else if (c == '{') { [EOL]             matchedLc = true; [EOL]             break; [EOL]         } else { [EOL]             break; [EOL]         } [EOL]     } [EOL]     stream.ungetChar(c); [EOL]     return matchedLc; [EOL] } <line_num>: 2385,2401
