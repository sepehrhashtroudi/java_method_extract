PhaseOptimizer(AbstractCompiler compiler, PerformanceTracker tracker, ProgressRange progressRange) { [EOL]     this.compiler = compiler; [EOL]     this.tracker = tracker; [EOL]     this.progressRange = progressRange; [EOL]     compiler.addChangeHandler(recentChange); [EOL] } <line_num>: 91,97
NamedPass(PassFactory factory) { [EOL]     this.name = factory.getName(); [EOL]     this.factory = factory; [EOL] } <line_num>: 276,279
public ProgressRange(double initialValue, double maxValue) { [EOL]     this.initialValue = initialValue; [EOL]     this.maxValue = maxValue; [EOL] } <line_num>: 413,416
static void randomizeLoops() { [EOL]     randomizeLoops = true; [EOL] } <line_num>: 103,105
static List<List<String>> getLoopsRun() { [EOL]     return loopsRun; [EOL] } <line_num>: 111,113
static void clearLoopsRun() { [EOL]     loopsRun.clear(); [EOL] } <line_num>: 118,120
void consume(List<PassFactory> factories) { [EOL]     Loop currentLoop = new Loop(); [EOL]     boolean isCurrentLoopPopulated = false; [EOL]     for (PassFactory factory : factories) { [EOL]         if (factory.isOneTimePass()) { [EOL]             if (isCurrentLoopPopulated) { [EOL]                 passes.add(currentLoop); [EOL]                 currentLoop = new Loop(); [EOL]                 isCurrentLoopPopulated = false; [EOL]             } [EOL]             addOneTimePass(factory); [EOL]         } else { [EOL]             currentLoop.addLoopedPass(factory); [EOL]             isCurrentLoopPopulated = true; [EOL]         } [EOL]     } [EOL]     if (isCurrentLoopPopulated) { [EOL]         passes.add(currentLoop); [EOL]     } [EOL] } <line_num>: 133,153
void addOneTimePass(PassFactory factory) { [EOL]     passes.add(new NamedPass(factory)); [EOL] } <line_num>: 159,161
Loop addFixedPointLoop() { [EOL]     Loop loop = new Loop(); [EOL]     passes.add(loop); [EOL]     return loop; [EOL] } <line_num>: 168,172
void setSanityCheck(PassFactory sanityCheck) { [EOL]     this.sanityCheck = sanityCheck; [EOL] } <line_num>: 177,179
@Override [EOL] public void process(Node externs, Node root) { [EOL]     progress = 0.0; [EOL]     progressStep = 0.0; [EOL]     if (progressRange != null) { [EOL]         progressStep = (progressRange.maxValue - progressRange.initialValue) / passes.size(); [EOL]         progress = progressRange.initialValue; [EOL]     } [EOL]     for (CompilerPass pass : passes) { [EOL]         pass.process(externs, root); [EOL]         if (hasHaltingErrors()) { [EOL]             return; [EOL]         } [EOL]     } [EOL] } <line_num>: 184,200
private void startPass(String passName) { [EOL]     Preconditions.checkState(currentTracer == null && currentPassName == null); [EOL]     currentPassName = passName; [EOL]     currentTracer = newTracer(passName); [EOL] } <line_num>: 205,209
private void endPass(Node externs, Node root) { [EOL]     Preconditions.checkState(currentTracer != null && currentPassName != null); [EOL]     String passToCheck = currentPassName; [EOL]     try { [EOL]         if (progressRange == null) { [EOL]             compiler.setProgress(-1, currentPassName); [EOL]         } else { [EOL]             progress += progressStep; [EOL]             compiler.setProgress(progress, currentPassName); [EOL]         } [EOL]         stopTracer(currentTracer, currentPassName); [EOL]         currentPassName = null; [EOL]         currentTracer = null; [EOL]         maybeSanityCheck(externs, root); [EOL]     } catch (Exception e) { [EOL]         throw new RuntimeException("Sanity check failed for " + passToCheck, e); [EOL]     } [EOL] } <line_num>: 214,235
void maybeSanityCheck(Node externs, Node root) { [EOL]     if (sanityCheck != null) { [EOL]         sanityCheck.create(compiler).process(externs, root); [EOL]     } [EOL] } <line_num>: 240,244
private boolean hasHaltingErrors() { [EOL]     return compiler.hasHaltingErrors(); [EOL] } <line_num>: 246,248
private Tracer newTracer(String passName) { [EOL]     String comment = passName + (recentChange.hasCodeChanged() ? " on recently changed AST" : ""); [EOL]     if (tracker != null) { [EOL]         tracker.recordPassStart(passName); [EOL]     } [EOL]     return new Tracer("JSCompiler", comment); [EOL] } <line_num>: 253,260
private void stopTracer(Tracer t, String passName) { [EOL]     long result = t.stop(); [EOL]     if (tracker != null) { [EOL]         tracker.recordPassStop(passName, result); [EOL]     } [EOL] } <line_num>: 262,267
@Override [EOL] public void process(Node externs, Node root) { [EOL]     logger.fine(name); [EOL]     startPass(name); [EOL]     factory.create(compiler).process(externs, root); [EOL]     endPass(externs, root); [EOL] } <line_num>: 281,290
void addLoopedPass(PassFactory factory) { [EOL]     String name = factory.getName(); [EOL]     Preconditions.checkArgument(!myNames.contains(name), "Already a pass with name '%s' in this loop", name); [EOL]     myNames.add(name); [EOL]     myPasses.add(new NamedPass(factory)); [EOL] } <line_num>: 303,309
private List<String> getPassOrder() { [EOL]     List<String> order = Lists.newArrayList(); [EOL]     for (NamedPass pass : myPasses) { [EOL]         order.add(pass.name); [EOL]     } [EOL]     return order; [EOL] } <line_num>: 314,320
@Override [EOL] public void process(Node externs, Node root) { [EOL]     Preconditions.checkState(!loopMutex, "Nested loops are forbidden"); [EOL]     loopMutex = true; [EOL]     if (randomizeLoops) { [EOL]         randomizePasses(); [EOL]     } else { [EOL]         optimizePasses(); [EOL]     } [EOL]     Set<NamedPass> madeChanges = new HashSet<NamedPass>(); [EOL]     Set<NamedPass> runInPrevIter = new HashSet<NamedPass>(); [EOL]     State s = State.RUN_PASSES_NOT_RUN_IN_PREV_ITER; [EOL]     boolean lastIterMadeChanges; [EOL]     int count = 0; [EOL]     try { [EOL]         while (true) { [EOL]             if (count++ > MAX_LOOPS) { [EOL]                 compiler.throwInternalError(OPTIMIZE_LOOP_ERROR, null); [EOL]             } [EOL]             lastIterMadeChanges = false; [EOL]             for (NamedPass pass : myPasses) { [EOL]                 recentChange.reset(); [EOL]                 if ((s == State.RUN_PASSES_NOT_RUN_IN_PREV_ITER && !runInPrevIter.contains(pass)) || (s == State.RUN_PASSES_THAT_CHANGED_STH_IN_PREV_ITER && madeChanges.contains(pass))) { [EOL]                     pass.process(externs, root); [EOL]                     runInPrevIter.add(pass); [EOL]                     if (hasHaltingErrors()) { [EOL]                         return; [EOL]                     } else if (recentChange.hasCodeChanged()) { [EOL]                         madeChanges.add(pass); [EOL]                         lastIterMadeChanges = true; [EOL]                     } else { [EOL]                         madeChanges.remove(pass); [EOL]                     } [EOL]                 } else { [EOL]                     runInPrevIter.remove(pass); [EOL]                 } [EOL]             } [EOL]             if (s == State.RUN_PASSES_NOT_RUN_IN_PREV_ITER) { [EOL]                 if (lastIterMadeChanges) { [EOL]                     s = State.RUN_PASSES_THAT_CHANGED_STH_IN_PREV_ITER; [EOL]                 } else { [EOL]                     return; [EOL]                 } [EOL]             } else if (!lastIterMadeChanges) { [EOL]                 s = State.RUN_PASSES_NOT_RUN_IN_PREV_ITER; [EOL]             } [EOL]         } [EOL]     } finally { [EOL]         loopMutex = false; [EOL]     } [EOL] } <line_num>: 322,379
private void randomizePasses() { [EOL]     Collections.shuffle(myPasses); [EOL] } <line_num>: 382,384
private void optimizePasses() { [EOL]     List<NamedPass> optimalPasses = Lists.newArrayList(); [EOL]     for (String passName : OPTIMAL_ORDER) { [EOL]         for (NamedPass pass : myPasses) { [EOL]             if (pass.name.equals(passName)) { [EOL]                 optimalPasses.add(pass); [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     myPasses.removeAll(optimalPasses); [EOL]     myPasses.addAll(optimalPasses); [EOL] } <line_num>: 387,406
