InlineFunctions(AbstractCompiler compiler, Supplier<String> safeNameIdSupplier, boolean inlineGlobalFunctions, boolean inlineLocalFunctions, boolean blockFunctionInliningEnabled, boolean assumeStrictThis, boolean assumeMinimumCapture) { [EOL]     Preconditions.checkArgument(compiler != null); [EOL]     Preconditions.checkArgument(safeNameIdSupplier != null); [EOL]     this.compiler = compiler; [EOL]     this.inlineGlobalFunctions = inlineGlobalFunctions; [EOL]     this.inlineLocalFunctions = inlineLocalFunctions; [EOL]     this.blockFunctionInliningEnabled = blockFunctionInliningEnabled; [EOL]     this.assumeMinimumCapture = assumeMinimumCapture; [EOL]     this.injector = new FunctionInjector(compiler, safeNameIdSupplier, true, assumeStrictThis, assumeMinimumCapture); [EOL] } <line_num>: 76,95
CallVisitor(Map<String, FunctionState> fns, Map<Node, String> anonFns, CallVisitorCallback callback) { [EOL]     this.functionMap = fns; [EOL]     this.anonFunctionMap = anonFns; [EOL]     this.callback = callback; [EOL] } <line_num>: 380,386
FindCandidatesReferences(Map<String, FunctionState> fns, Map<Node, String> anonFns) { [EOL]     super(fns, anonFns, null); [EOL]     this.callback = this; [EOL] } <line_num>: 469,474
Inline(FunctionInjector injector, SpecializeModule.SpecializationState specializationState) { [EOL]     this.injector = injector; [EOL]     this.specializationState = specializationState; [EOL] } <line_num>: 598,602
public NamedFunction(Node fn) { [EOL]     this.fn = fn; [EOL] } <line_num>: 1023,1025
public FunctionVar(Node var) { [EOL]     this.var = var; [EOL] } <line_num>: 1052,1054
public FunctionExpression(Node fn, int index) { [EOL]     this.fn = fn; [EOL]     this.fakeName = String.valueOf(index); [EOL] } <line_num>: 1082,1087
Reference(Node callNode, JSModule module, InliningMode mode, boolean decompose) { [EOL]     super(callNode, module, mode); [EOL]     this.requiresDecomposition = decompose; [EOL] } <line_num>: 1114,1118
FunctionState getOrCreateFunctionState(String fnName) { [EOL]     FunctionState fs = fns.get(fnName); [EOL]     if (fs == null) { [EOL]         fs = new FunctionState(); [EOL]         fns.put(fnName, fs); [EOL]     } [EOL]     return fs; [EOL] } <line_num>: 97,104
@Override [EOL] public void enableSpecialization(SpecializeModule.SpecializationState specializationState) { [EOL]     this.specializationState = specializationState; [EOL] } <line_num>: 106,110
@Override [EOL] public void process(Node externs, Node root) { [EOL]     Preconditions.checkState(compiler.getLifeCycleStage().isNormalized()); [EOL]     NodeTraversal.traverse(compiler, root, new FindCandidateFunctions()); [EOL]     if (fns.isEmpty()) { [EOL]         return; [EOL]     } [EOL]     NodeTraversal.traverse(compiler, root, new FindCandidatesReferences(fns, anonFns)); [EOL]     trimCanidatesNotMeetingMinimumRequirements(); [EOL]     if (fns.isEmpty()) { [EOL]         return; [EOL]     } [EOL]     Set<String> fnNames = Sets.newHashSet(fns.keySet()); [EOL]     injector.setKnownConstants(fnNames); [EOL]     trimCanidatesUsingOnCost(); [EOL]     if (fns.isEmpty()) { [EOL]         return; [EOL]     } [EOL]     resolveInlineConflicts(); [EOL]     decomposeExpressions(fnNames); [EOL]     NodeTraversal.traverse(compiler, root, new CallVisitor(fns, anonFns, new Inline(injector, specializationState))); [EOL]     removeInlinedFunctions(); [EOL] } <line_num>: 112,149
@Override [EOL] public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) { [EOL]     return inlineLocalFunctions || nodeTraversal.inGlobalScope(); [EOL] } <line_num>: 157,163
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if ((t.inGlobalScope() && inlineGlobalFunctions) || (!t.inGlobalScope() && inlineLocalFunctions)) { [EOL]         findNamedFunctions(t, n, parent); [EOL]         findFunctionExpressions(t, n); [EOL]     } [EOL] } <line_num>: 165,173
public void findNamedFunctions(NodeTraversal t, Node n, Node parent) { [EOL]     if (!NodeUtil.isStatement(n)) { [EOL]         return; [EOL]     } [EOL]     switch(n.getType()) { [EOL]         case Token.VAR: [EOL]             Preconditions.checkState(n.hasOneChild()); [EOL]             Node nameNode = n.getFirstChild(); [EOL]             if (nameNode.isName() && nameNode.hasChildren() && nameNode.getFirstChild().isFunction()) { [EOL]                 maybeAddFunction(new FunctionVar(n), t.getModule()); [EOL]             } [EOL]             break; [EOL]         case Token.FUNCTION: [EOL]             Preconditions.checkState(NodeUtil.isStatementBlock(parent) || parent.isLabel()); [EOL]             if (!NodeUtil.isFunctionExpression(n)) { [EOL]                 Function fn = new NamedFunction(n); [EOL]                 maybeAddFunction(fn, t.getModule()); [EOL]             } [EOL]             break; [EOL]     } [EOL] } <line_num>: 175,204
public void findFunctionExpressions(NodeTraversal t, Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.CALL: [EOL]             Node fnNode = null; [EOL]             if (n.getFirstChild().isFunction()) { [EOL]                 fnNode = n.getFirstChild(); [EOL]             } else if (NodeUtil.isFunctionObjectCall(n)) { [EOL]                 Node fnIdentifingNode = n.getFirstChild().getFirstChild(); [EOL]                 if (fnIdentifingNode.isFunction()) { [EOL]                     fnNode = fnIdentifingNode; [EOL]                 } [EOL]             } [EOL]             if (fnNode != null) { [EOL]                 Function fn = new FunctionExpression(fnNode, callsSeen++); [EOL]                 maybeAddFunction(fn, t.getModule()); [EOL]                 anonFns.put(fnNode, fn.getName()); [EOL]             } [EOL]             break; [EOL]     } [EOL] } <line_num>: 212,235
private void maybeAddFunction(Function fn, JSModule module) { [EOL]     String name = fn.getName(); [EOL]     FunctionState fs = getOrCreateFunctionState(name); [EOL]     if (fs.hasExistingFunctionDefinition()) { [EOL]         fs.setInline(false); [EOL]     } else { [EOL]         if (fs.canInline()) { [EOL]             fs.setFn(fn); [EOL]             if (injector.isDirectCallNodeReplacementPossible(fn.getFunctionNode())) { [EOL]                 fs.inlineDirectly(true); [EOL]             } [EOL]             if (!isCandidateFunction(fn)) { [EOL]                 fs.setInline(false); [EOL]             } [EOL]             if (fs.canInline()) { [EOL]                 fs.setModule(module); [EOL]                 Node fnNode = fn.getFunctionNode(); [EOL]                 Set<String> namesToAlias = FunctionArgumentInjector.findModifiedParameters(fnNode); [EOL]                 if (!namesToAlias.isEmpty()) { [EOL]                     fs.inlineDirectly(false); [EOL]                     fs.setNamesToAlias(namesToAlias); [EOL]                 } [EOL]                 Node block = NodeUtil.getFunctionBody(fnNode); [EOL]                 if (NodeUtil.referencesThis(block)) { [EOL]                     fs.setReferencesThis(true); [EOL]                 } [EOL]                 if (NodeUtil.containsFunction(block)) { [EOL]                     fs.setHasInnerFunctions(true); [EOL]                     if (!assumeMinimumCapture && hasLocalNames(fnNode)) { [EOL]                         fs.setInline(false); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (fs.canInline() && !fs.canInlineDirectly()) { [EOL]                 if (!blockFunctionInliningEnabled) { [EOL]                     fs.setInline(false); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 242,308
private boolean hasLocalNames(Node fnNode) { [EOL]     Node block = NodeUtil.getFunctionBody(fnNode); [EOL]     return NodeUtil.getFunctionParameters(fnNode).hasChildren() || NodeUtil.has(block, new NodeUtil.MatchDeclaration(), new NodeUtil.MatchShallowStatement()); [EOL] } <line_num>: 314,321
private static Node getContainingFunction(NodeTraversal t) { [EOL]     return (t.inGlobalScope()) ? null : t.getScopeRoot(); [EOL] } <line_num>: 327,329
private boolean isCandidateFunction(Function fn) { [EOL]     String fnName = fn.getName(); [EOL]     if (compiler.getCodingConvention().isExported(fnName)) { [EOL]         return false; [EOL]     } [EOL]     if (RenameProperties.RENAME_PROPERTY_FUNCTION_NAME.equals(fnName)) { [EOL]         return false; [EOL]     } [EOL]     if (specializationState != null && !specializationState.canFixupFunction(fn.getFunctionNode())) { [EOL]         return false; [EOL]     } [EOL]     Node fnNode = fn.getFunctionNode(); [EOL]     return injector.doesFunctionMeetMinimumRequirements(fnName, fnNode); [EOL] } <line_num>: 335,361
public void visitCallSite(NodeTraversal t, Node callNode, Node parent, FunctionState fs); <line_num>: 367,368
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     switch(n.getType()) { [EOL]         case Token.CALL: [EOL]             Node child = n.getFirstChild(); [EOL]             String name = null; [EOL]             if (child.isName()) { [EOL]                 name = child.getString(); [EOL]             } else if (child.isFunction()) { [EOL]                 name = anonFunctionMap.get(child); [EOL]             } else if (NodeUtil.isFunctionObjectCall(n)) { [EOL]                 Preconditions.checkState(NodeUtil.isGet(child)); [EOL]                 Node fnIdentifingNode = child.getFirstChild(); [EOL]                 if (fnIdentifingNode.isName()) { [EOL]                     name = fnIdentifingNode.getString(); [EOL]                 } else if (fnIdentifingNode.isFunction()) { [EOL]                     name = anonFunctionMap.get(fnIdentifingNode); [EOL]                 } [EOL]             } [EOL]             if (name != null) { [EOL]                 FunctionState fs = functionMap.get(name); [EOL]                 if (fs != null) { [EOL]                     callback.visitCallSite(t, n, parent, fs); [EOL]                 } [EOL]             } [EOL]             break; [EOL]     } [EOL] } <line_num>: 388,420
static boolean isCandidateUsage(Node name) { [EOL]     Node parent = name.getParent(); [EOL]     Preconditions.checkState(name.isName()); [EOL]     if (parent.isVar() || parent.isFunction()) { [EOL]         return true; [EOL]     } [EOL]     if (parent.isCall() && parent.getFirstChild() == name) { [EOL]         return true; [EOL]     } [EOL]     if (NodeUtil.isGet(parent) && name == parent.getFirstChild() && name.getNext().isString() && name.getNext().getString().equals("call")) { [EOL]         Node gramps = name.getAncestor(2); [EOL]         if (gramps.isCall() && gramps.getFirstChild() == parent) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 427,461
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     super.visit(t, n, parent); [EOL]     if (n.isName()) { [EOL]         checkNameUsage(t, n, parent); [EOL]     } [EOL] } <line_num>: 476,482
@Override [EOL] public void visitCallSite(NodeTraversal t, Node callNode, Node parent, FunctionState fs) { [EOL]     maybeAddReference(t, fs, callNode, t.getModule()); [EOL] } <line_num>: 484,488
void maybeAddReference(NodeTraversal t, FunctionState fs, Node callNode, JSModule module) { [EOL]     if (!fs.canInline()) { [EOL]         return; [EOL]     } [EOL]     boolean referenceAdded = false; [EOL]     InliningMode mode = fs.canInlineDirectly() ? InliningMode.DIRECT : InliningMode.BLOCK; [EOL]     referenceAdded = maybeAddReferenceUsingMode(t, fs, callNode, module, mode); [EOL]     if (!referenceAdded && mode == InliningMode.DIRECT && blockFunctionInliningEnabled) { [EOL]         mode = InliningMode.BLOCK; [EOL]         referenceAdded = maybeAddReferenceUsingMode(t, fs, callNode, module, mode); [EOL]     } [EOL]     if (!referenceAdded) { [EOL]         fs.setRemove(false); [EOL]     } [EOL] } <line_num>: 490,515
private boolean maybeAddReferenceUsingMode(NodeTraversal t, FunctionState fs, Node callNode, JSModule module, InliningMode mode) { [EOL]     if (specializationState != null) { [EOL]         Node containingFunction = getContainingFunction(t); [EOL]         if (containingFunction != null && !specializationState.canFixupFunction(containingFunction)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     CanInlineResult result = injector.canInlineReferenceToFunction(t, callNode, fs.getFn().getFunctionNode(), fs.getNamesToAlias(), mode, fs.getReferencesThis(), fs.hasInnerFunctions()); [EOL]     if (result != CanInlineResult.NO) { [EOL]         boolean decompose = (result == CanInlineResult.AFTER_PREPARATION); [EOL]         fs.addReference(new Reference(callNode, module, mode, decompose)); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 517,544
private void checkNameUsage(NodeTraversal t, Node n, Node parent) { [EOL]     Preconditions.checkState(n.isName()); [EOL]     if (isCandidateUsage(n)) { [EOL]         return; [EOL]     } [EOL]     String name = n.getString(); [EOL]     FunctionState fs = fns.get(name); [EOL]     if (fs == null) { [EOL]         return; [EOL]     } [EOL]     if (parent.isNew()) { [EOL]         Node target = parent.getFirstChild(); [EOL]         if (target.isName() && target.getString().equals(ObjectPropertyStringPreprocess.EXTERN_OBJECT_PROPERTY_STRING)) { [EOL]             fs.setInline(false); [EOL]         } [EOL]     } [EOL]     if (parent.isAssign() && parent.getFirstChild() == n) { [EOL]         fs.setInline(false); [EOL]     } else { [EOL]         fs.setRemove(false); [EOL]     } [EOL] } <line_num>: 549,588
@Override [EOL] public void visitCallSite(NodeTraversal t, Node callNode, Node parent, FunctionState fs) { [EOL]     Preconditions.checkState(fs.hasExistingFunctionDefinition()); [EOL]     if (fs.canInline()) { [EOL]         Reference ref = fs.getReference(callNode); [EOL]         if (ref != null) { [EOL]             if (specializationState != null) { [EOL]                 Node containingFunction = getContainingFunction(t); [EOL]                 if (containingFunction != null) { [EOL]                     specializationState.reportSpecializedFunction(containingFunction); [EOL]                 } [EOL]             } [EOL]             inlineFunction(t, callNode, fs, ref.mode); [EOL]             ref.inlined = true; [EOL]         } [EOL]     } [EOL] } <line_num>: 604,631
private void inlineFunction(NodeTraversal t, Node callNode, FunctionState fs, InliningMode mode) { [EOL]     Function fn = fs.getFn(); [EOL]     String fnName = fn.getName(); [EOL]     Node fnNode = fs.getSafeFnNode(); [EOL]     Node newCode = injector.inline(t, callNode, fnName, fnNode, mode); [EOL]     t.getCompiler().reportCodeChange(); [EOL]     t.getCompiler().addToDebugLog("Inlined function: " + fn.getName()); [EOL] } <line_num>: 636,645
private void trimCanidatesNotMeetingMinimumRequirements() { [EOL]     Iterator<Entry<String, FunctionState>> i; [EOL]     for (i = fns.entrySet().iterator(); i.hasNext(); ) { [EOL]         FunctionState fs = i.next().getValue(); [EOL]         if (!fs.hasExistingFunctionDefinition() || !fs.canInline()) { [EOL]             i.remove(); [EOL]         } [EOL]     } [EOL] } <line_num>: 652,660
void trimCanidatesUsingOnCost() { [EOL]     Iterator<Entry<String, FunctionState>> i; [EOL]     for (i = fns.entrySet().iterator(); i.hasNext(); ) { [EOL]         FunctionState fs = i.next().getValue(); [EOL]         if (fs.hasReferences()) { [EOL]             boolean lowersCost = mimimizeCost(fs); [EOL]             if (!lowersCost) { [EOL]                 i.remove(); [EOL]             } [EOL]         } else if (!fs.canRemove()) { [EOL]             i.remove(); [EOL]         } [EOL]     } [EOL] } <line_num>: 665,682
private boolean mimimizeCost(FunctionState fs) { [EOL]     if (!inliningLowersCost(fs)) { [EOL]         if (fs.hasBlockInliningReferences()) { [EOL]             fs.setRemove(false); [EOL]             fs.removeBlockInliningReferences(); [EOL]             if (!fs.hasReferences() || !inliningLowersCost(fs)) { [EOL]                 return false; [EOL]             } [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 689,703
private boolean inliningLowersCost(FunctionState fs) { [EOL]     return injector.inliningLowersCost(fs.getModule(), fs.getFn().getFunctionNode(), fs.getReferences(), fs.getNamesToAlias(), fs.canRemove(), fs.getReferencesThis()); [EOL] } <line_num>: 708,716
private void resolveInlineConflicts() { [EOL]     for (FunctionState fs : fns.values()) { [EOL]         resolveInlineConflictsForFunction(fs); [EOL]     } [EOL] } <line_num>: 735,739
private void resolveInlineConflictsForFunction(FunctionState fs) { [EOL]     if (!fs.hasReferences() || !fs.canInline()) { [EOL]         return; [EOL]     } [EOL]     Node fnNode = fs.getFn().getFunctionNode(); [EOL]     Set<String> names = findCalledFunctions(fnNode); [EOL]     if (!names.isEmpty()) { [EOL]         for (String name : names) { [EOL]             FunctionState fsCalled = fns.get(name); [EOL]             if (fsCalled != null && fsCalled.canRemove()) { [EOL]                 fsCalled.setRemove(false); [EOL]                 if (!mimimizeCost(fsCalled)) { [EOL]                     fsCalled.setInline(false); [EOL]                 } [EOL]             } [EOL]         } [EOL]         fs.setSafeFnNode(fs.getFn().getFunctionNode().cloneTree()); [EOL]     } [EOL] } <line_num>: 744,770
private Set<String> findCalledFunctions(Node node) { [EOL]     Set<String> changed = Sets.newHashSet(); [EOL]     findCalledFunctions(NodeUtil.getFunctionBody(node), changed); [EOL]     return changed; [EOL] } <line_num>: 775,779
private void findCalledFunctions(Node node, Set<String> changed) { [EOL]     Preconditions.checkArgument(changed != null); [EOL]     if (node.isName()) { [EOL]         if (isCandidateUsage(node)) { [EOL]             changed.add(node.getString()); [EOL]         } [EOL]     } [EOL]     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) { [EOL]         findCalledFunctions(c, changed); [EOL]     } [EOL] } <line_num>: 784,797
private void decomposeExpressions(Set<String> fnNames) { [EOL]     ExpressionDecomposer decomposer = new ExpressionDecomposer(compiler, compiler.getUniqueNameIdSupplier(), fnNames); [EOL]     for (FunctionState fs : fns.values()) { [EOL]         if (fs.canInline()) { [EOL]             for (Reference ref : fs.getReferences()) { [EOL]                 if (ref.requiresDecomposition) { [EOL]                     injector.maybePrepareCall(ref.callNode); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 803,816
void removeInlinedFunctions() { [EOL]     for (FunctionState fs : fns.values()) { [EOL]         if (fs.canRemove()) { [EOL]             Function fn = fs.getFn(); [EOL]             Preconditions.checkState(fs.canInline()); [EOL]             Preconditions.checkState(fn != null); [EOL]             verifyAllReferencesInlined(fs); [EOL]             if (specializationState != null) { [EOL]                 specializationState.reportRemovedFunction(fn.getFunctionNode(), fn.getDeclaringBlock()); [EOL]             } [EOL]             fn.remove(); [EOL]             compiler.reportCodeChange(); [EOL]         } [EOL]     } [EOL] } <line_num>: 821,838
void verifyAllReferencesInlined(FunctionState fs) { [EOL]     for (Reference ref : fs.getReferences()) { [EOL]         if (!ref.inlined) { [EOL]             throw new IllegalStateException("Call site missed.\n call: " + ref.callNode.toStringTree() + "\n parent:  " + ref.callNode.getParent().toStringTree()); [EOL]         } [EOL]     } [EOL] } <line_num>: 844,852
boolean hasExistingFunctionDefinition() { [EOL]     return (fn != null); [EOL] } <line_num>: 869,871
public void setReferencesThis(boolean referencesThis) { [EOL]     this.referencesThis = referencesThis; [EOL] } <line_num>: 873,875
public boolean getReferencesThis() { [EOL]     return this.referencesThis; [EOL] } <line_num>: 877,879
public void setHasInnerFunctions(boolean hasInnerFunctions) { [EOL]     this.hasInnerFunctions = hasInnerFunctions; [EOL] } <line_num>: 881,883
public boolean hasInnerFunctions() { [EOL]     return hasInnerFunctions; [EOL] } <line_num>: 886,888
void removeBlockInliningReferences() { [EOL]     Iterator<Entry<Node, Reference>> i; [EOL]     for (i = getReferencesInternal().entrySet().iterator(); i.hasNext(); ) { [EOL]         Entry<Node, Reference> entry = i.next(); [EOL]         if (entry.getValue().mode == InliningMode.BLOCK) { [EOL]             i.remove(); [EOL]         } [EOL]     } [EOL] } <line_num>: 890,898
public boolean hasBlockInliningReferences() { [EOL]     for (Reference r : getReferencesInternal().values()) { [EOL]         if (r.mode == InliningMode.BLOCK) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 900,907
public Function getFn() { [EOL]     return fn; [EOL] } <line_num>: 909,911
public void setFn(Function fn) { [EOL]     Preconditions.checkState(this.fn == null); [EOL]     this.fn = fn; [EOL] } <line_num>: 913,916
public Node getSafeFnNode() { [EOL]     return (safeFnNode != null) ? safeFnNode : fn.getFunctionNode(); [EOL] } <line_num>: 918,920
public void setSafeFnNode(Node safeFnNode) { [EOL]     this.safeFnNode = safeFnNode; [EOL] } <line_num>: 922,924
public boolean canInline() { [EOL]     return inline; [EOL] } <line_num>: 926,928
public void setInline(boolean inline) { [EOL]     this.inline = inline; [EOL]     if (inline == false) { [EOL]         references = null; [EOL]         remove = false; [EOL]     } [EOL] } <line_num>: 930,938
public boolean canRemove() { [EOL]     return remove; [EOL] } <line_num>: 940,942
public void setRemove(boolean remove) { [EOL]     this.remove = remove; [EOL] } <line_num>: 944,946
public boolean canInlineDirectly() { [EOL]     return inlineDirectly; [EOL] } <line_num>: 948,950
public void inlineDirectly(boolean directReplacement) { [EOL]     this.inlineDirectly = directReplacement; [EOL] } <line_num>: 952,954
public boolean hasReferences() { [EOL]     return (references != null && !references.isEmpty()); [EOL] } <line_num>: 956,958
private Map<Node, Reference> getReferencesInternal() { [EOL]     if (references == null) { [EOL]         return Collections.emptyMap(); [EOL]     } [EOL]     return references; [EOL] } <line_num>: 960,965
public void addReference(Reference ref) { [EOL]     if (references == null) { [EOL]         references = Maps.newHashMap(); [EOL]     } [EOL]     references.put(ref.callNode, ref); [EOL] } <line_num>: 967,972
public Collection<Reference> getReferences() { [EOL]     return getReferencesInternal().values(); [EOL] } <line_num>: 974,976
public Reference getReference(Node n) { [EOL]     return getReferencesInternal().get(n); [EOL] } <line_num>: 978,980
public Set<String> getNamesToAlias() { [EOL]     if (namesToAlias == null) { [EOL]         return Collections.emptySet(); [EOL]     } [EOL]     return Collections.unmodifiableSet(namesToAlias); [EOL] } <line_num>: 982,987
public void setNamesToAlias(Set<String> names) { [EOL]     namesToAlias = names; [EOL] } <line_num>: 989,991
public void setModule(JSModule module) { [EOL]     this.module = module; [EOL] } <line_num>: 993,995
public JSModule getModule() { [EOL]     return module; [EOL] } <line_num>: 997,999
public String getName(); <line_num>: 1008,1008
public Node getFunctionNode(); <line_num>: 1011,1011
public void remove(); <line_num>: 1014,1014
public Node getDeclaringBlock(); <line_num>: 1016,1016
@Override [EOL] public String getName() { [EOL]     return fn.getFirstChild().getString(); [EOL] } <line_num>: 1027,1030
@Override [EOL] public Node getFunctionNode() { [EOL]     return fn; [EOL] } <line_num>: 1032,1035
@Override [EOL] public void remove() { [EOL]     NodeUtil.removeChild(fn.getParent(), fn); [EOL] } <line_num>: 1037,1040
@Override [EOL] public Node getDeclaringBlock() { [EOL]     return fn.getParent(); [EOL] } <line_num>: 1042,1045
@Override [EOL] public String getName() { [EOL]     return var.getFirstChild().getString(); [EOL] } <line_num>: 1056,1059
@Override [EOL] public Node getFunctionNode() { [EOL]     return var.getFirstChild().getFirstChild(); [EOL] } <line_num>: 1061,1064
@Override [EOL] public void remove() { [EOL]     NodeUtil.removeChild(var.getParent(), var); [EOL] } <line_num>: 1066,1069
@Override [EOL] public Node getDeclaringBlock() { [EOL]     return var.getParent(); [EOL] } <line_num>: 1071,1074
@Override [EOL] public String getName() { [EOL]     return fakeName; [EOL] } <line_num>: 1089,1092
@Override [EOL] public Node getFunctionNode() { [EOL]     return fn; [EOL] } <line_num>: 1094,1097
@Override [EOL] public void remove() { [EOL] } <line_num>: 1099,1102
@Override [EOL] public Node getDeclaringBlock() { [EOL]     return null; [EOL] } <line_num>: 1104,1107
