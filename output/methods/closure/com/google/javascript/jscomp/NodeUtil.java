private NodeUtil() { [EOL] } <line_num>: 67,67
MatchNameNode(String name) { [EOL]     this.name = name; [EOL] } <line_num>: 2590,2592
MatchNodeType(int type) { [EOL]     this.type = type; [EOL] } <line_num>: 2606,2608
static TernaryValue getImpureBooleanValue(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.ASSIGN: [EOL]         case Token.COMMA: [EOL]             return getImpureBooleanValue(n.getLastChild()); [EOL]         case Token.NOT: [EOL]             TernaryValue value = getImpureBooleanValue(n.getLastChild()); [EOL]             return value.not(); [EOL]         case Token.AND: [EOL]             { [EOL]                 TernaryValue lhs = getImpureBooleanValue(n.getFirstChild()); [EOL]                 TernaryValue rhs = getImpureBooleanValue(n.getLastChild()); [EOL]                 return lhs.and(rhs); [EOL]             } [EOL]         case Token.OR: [EOL]             { [EOL]                 TernaryValue lhs = getImpureBooleanValue(n.getFirstChild()); [EOL]                 TernaryValue rhs = getImpureBooleanValue(n.getLastChild()); [EOL]                 return lhs.or(rhs); [EOL]             } [EOL]         case Token.HOOK: [EOL]             { [EOL]                 TernaryValue trueValue = getImpureBooleanValue(n.getFirstChild().getNext()); [EOL]                 TernaryValue falseValue = getImpureBooleanValue(n.getLastChild()); [EOL]                 if (trueValue.equals(falseValue)) { [EOL]                     return trueValue; [EOL]                 } else { [EOL]                     return TernaryValue.UNKNOWN; [EOL]                 } [EOL]             } [EOL]         case Token.ARRAYLIT: [EOL]         case Token.OBJECTLIT: [EOL]             return TernaryValue.TRUE; [EOL]         case Token.VOID: [EOL]             return TernaryValue.FALSE; [EOL]         default: [EOL]             return getPureBooleanValue(n); [EOL]     } [EOL] } <line_num>: 75,115
static TernaryValue getPureBooleanValue(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.STRING: [EOL]             return TernaryValue.forBoolean(n.getString().length() > 0); [EOL]         case Token.NUMBER: [EOL]             return TernaryValue.forBoolean(n.getDouble() != 0); [EOL]         case Token.NOT: [EOL]             return getPureBooleanValue(n.getLastChild()).not(); [EOL]         case Token.NULL: [EOL]         case Token.FALSE: [EOL]             return TernaryValue.FALSE; [EOL]         case Token.VOID: [EOL]             if (!mayHaveSideEffects(n.getFirstChild())) { [EOL]                 return TernaryValue.FALSE; [EOL]             } [EOL]             break; [EOL]         case Token.NAME: [EOL]             String name = n.getString(); [EOL]             if ("undefined".equals(name) || "NaN".equals(name)) { [EOL]                 return TernaryValue.FALSE; [EOL]             } else if ("Infinity".equals(name)) { [EOL]                 return TernaryValue.TRUE; [EOL]             } [EOL]             break; [EOL]         case Token.TRUE: [EOL]         case Token.REGEXP: [EOL]             return TernaryValue.TRUE; [EOL]         case Token.ARRAYLIT: [EOL]         case Token.OBJECTLIT: [EOL]             if (!mayHaveSideEffects(n)) { [EOL]                 return TernaryValue.TRUE; [EOL]             } [EOL]             break; [EOL]     } [EOL]     return TernaryValue.UNKNOWN; [EOL] } <line_num>: 123,169
static String getStringValue(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.STRING: [EOL]         case Token.STRING_KEY: [EOL]             return n.getString(); [EOL]         case Token.NAME: [EOL]             String name = n.getString(); [EOL]             if ("undefined".equals(name) || "Infinity".equals(name) || "NaN".equals(name)) { [EOL]                 return name; [EOL]             } [EOL]             break; [EOL]         case Token.NUMBER: [EOL]             return getStringValue(n.getDouble()); [EOL]         case Token.FALSE: [EOL]             return "false"; [EOL]         case Token.TRUE: [EOL]             return "true"; [EOL]         case Token.NULL: [EOL]             return "null"; [EOL]         case Token.VOID: [EOL]             return "undefined"; [EOL]         case Token.NOT: [EOL]             TernaryValue child = getPureBooleanValue(n.getFirstChild()); [EOL]             if (child != TernaryValue.UNKNOWN) { [EOL]                 return child.toBoolean(true) ? "false" : "true"; [EOL]             } [EOL]             break; [EOL]         case Token.ARRAYLIT: [EOL]             return arrayToString(n); [EOL]         case Token.OBJECTLIT: [EOL]             return "[object Object]"; [EOL]     } [EOL]     return null; [EOL] } <line_num>: 176,221
static String getStringValue(double value) { [EOL]     long longValue = (long) value; [EOL]     if (longValue == value) { [EOL]         return Long.toString(longValue); [EOL]     } else { [EOL]         return Double.toString(value); [EOL]     } [EOL] } <line_num>: 223,232
static String getArrayElementStringValue(Node n) { [EOL]     return (NodeUtil.isNullOrUndefined(n) || n.isEmpty()) ? "" : getStringValue(n); [EOL] } <line_num>: 242,245
static String arrayToString(Node literal) { [EOL]     Node first = literal.getFirstChild(); [EOL]     StringBuilder result = new StringBuilder(); [EOL]     int nextSlot = 0; [EOL]     int nextSkipSlot = 0; [EOL]     for (Node n = first; n != null; n = n.getNext()) { [EOL]         String childValue = getArrayElementStringValue(n); [EOL]         if (childValue == null) { [EOL]             return null; [EOL]         } [EOL]         if (n != first) { [EOL]             result.append(','); [EOL]         } [EOL]         result.append(childValue); [EOL]         nextSlot++; [EOL]     } [EOL]     return result.toString(); [EOL] } <line_num>: 247,265
static Double getNumberValue(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.TRUE: [EOL]             return 1.0; [EOL]         case Token.FALSE: [EOL]         case Token.NULL: [EOL]             return 0.0; [EOL]         case Token.NUMBER: [EOL]             return n.getDouble(); [EOL]         case Token.VOID: [EOL]             if (mayHaveSideEffects(n.getFirstChild())) { [EOL]                 return null; [EOL]             } else { [EOL]                 return Double.NaN; [EOL]             } [EOL]         case Token.NAME: [EOL]             String name = n.getString(); [EOL]             if (name.equals("undefined")) { [EOL]                 return Double.NaN; [EOL]             } [EOL]             if (name.equals("NaN")) { [EOL]                 return Double.NaN; [EOL]             } [EOL]             if (name.equals("Infinity")) { [EOL]                 return Double.POSITIVE_INFINITY; [EOL]             } [EOL]             return null; [EOL]         case Token.NEG: [EOL]             if (n.getChildCount() == 1 && n.getFirstChild().isName() && n.getFirstChild().getString().equals("Infinity")) { [EOL]                 return Double.NEGATIVE_INFINITY; [EOL]             } [EOL]             return null; [EOL]         case Token.NOT: [EOL]             TernaryValue child = getPureBooleanValue(n.getFirstChild()); [EOL]             if (child != TernaryValue.UNKNOWN) { [EOL]                 return child.toBoolean(true) ? 0.0 : 1.0; [EOL]             } [EOL]             break; [EOL]         case Token.STRING: [EOL]             return getStringNumberValue(n.getString()); [EOL]         case Token.ARRAYLIT: [EOL]         case Token.OBJECTLIT: [EOL]             String value = getStringValue(n); [EOL]             return value != null ? getStringNumberValue(value) : null; [EOL]     } [EOL]     return null; [EOL] } <line_num>: 272,329
static Double getStringNumberValue(String rawJsString) { [EOL]     if (rawJsString.contains("\u000b")) { [EOL]         return null; [EOL]     } [EOL]     String s = trimJsWhiteSpace(rawJsString); [EOL]     if (s.length() == 0) { [EOL]         return 0.0; [EOL]     } [EOL]     if (s.length() > 2 && s.charAt(0) == '0' && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) { [EOL]         try { [EOL]             return Double.valueOf(Integer.parseInt(s.substring(2), 16)); [EOL]         } catch (NumberFormatException e) { [EOL]             return Double.NaN; [EOL]         } [EOL]     } [EOL]     if (s.length() > 3 && (s.charAt(0) == '-' || s.charAt(0) == '+') && s.charAt(1) == '0' && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) { [EOL]         return null; [EOL]     } [EOL]     if (s.equals("infinity") || s.equals("-infinity") || s.equals("+infinity")) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         return Double.parseDouble(s); [EOL]     } catch (NumberFormatException e) { [EOL]         return Double.NaN; [EOL]     } [EOL] } <line_num>: 331,375
static String trimJsWhiteSpace(String s) { [EOL]     int start = 0; [EOL]     int end = s.length(); [EOL]     while (end > 0 && isStrWhiteSpaceChar(s.charAt(end - 1)) == TernaryValue.TRUE) { [EOL]         end--; [EOL]     } [EOL]     while (start < end && isStrWhiteSpaceChar(s.charAt(start)) == TernaryValue.TRUE) { [EOL]         start++; [EOL]     } [EOL]     return s.substring(start, end); [EOL] } <line_num>: 377,389
public static TernaryValue isStrWhiteSpaceChar(int c) { [EOL]     switch(c) { [EOL]         case '\u000B': [EOL]             return TernaryValue.UNKNOWN; [EOL]         case ' ': [EOL]         case '\n': [EOL]         case '\r': [EOL]         case '\t': [EOL]         case '\u00A0': [EOL]         case '\u000C': [EOL]         case '\u2028': [EOL]         case '\u2029': [EOL]         case '\uFEFF': [EOL]             return TernaryValue.TRUE; [EOL]         default: [EOL]             return (Character.getType(c) == Character.SPACE_SEPARATOR) ? TernaryValue.TRUE : TernaryValue.FALSE; [EOL]     } [EOL] } <line_num>: 394,412
static String getFunctionName(Node n) { [EOL]     Preconditions.checkState(n.isFunction()); [EOL]     Node parent = n.getParent(); [EOL]     switch(parent.getType()) { [EOL]         case Token.NAME: [EOL]             return parent.getQualifiedName(); [EOL]         case Token.ASSIGN: [EOL]             return parent.getFirstChild().getQualifiedName(); [EOL]         default: [EOL]             String name = n.getFirstChild().getQualifiedName(); [EOL]             return name; [EOL]     } [EOL] } <line_num>: 429,448
public static String getNearestFunctionName(Node n) { [EOL]     if (!n.isFunction()) { [EOL]         return null; [EOL]     } [EOL]     String name = getFunctionName(n); [EOL]     if (name != null) { [EOL]         return name; [EOL]     } [EOL]     Node parent = n.getParent(); [EOL]     switch(parent.getType()) { [EOL]         case Token.SETTER_DEF: [EOL]         case Token.GETTER_DEF: [EOL]         case Token.STRING_KEY: [EOL]             return parent.getString(); [EOL]         case Token.NUMBER: [EOL]             return getStringValue(parent); [EOL]     } [EOL]     return null; [EOL] } <line_num>: 465,488
static boolean isImmutableValue(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.STRING: [EOL]         case Token.NUMBER: [EOL]         case Token.NULL: [EOL]         case Token.TRUE: [EOL]         case Token.FALSE: [EOL]             return true; [EOL]         case Token.CAST: [EOL]         case Token.NOT: [EOL]             return isImmutableValue(n.getFirstChild()); [EOL]         case Token.VOID: [EOL]         case Token.NEG: [EOL]             return isImmutableValue(n.getFirstChild()); [EOL]         case Token.NAME: [EOL]             String name = n.getString(); [EOL]             return "undefined".equals(name) || "Infinity".equals(name) || "NaN".equals(name); [EOL]     } [EOL]     return false; [EOL] } <line_num>: 494,518
static boolean isSymmetricOperation(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.EQ: [EOL]         case Token.NE: [EOL]         case Token.SHEQ: [EOL]         case Token.SHNE: [EOL]         case Token.MUL: [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 523,534
static boolean isRelationalOperation(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.GT: [EOL]         case Token.GE: [EOL]         case Token.LT: [EOL]         case Token.LE: [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 540,549
static int getInverseOperator(int type) { [EOL]     switch(type) { [EOL]         case Token.GT: [EOL]             return Token.LT; [EOL]         case Token.LT: [EOL]             return Token.GT; [EOL]         case Token.GE: [EOL]             return Token.LE; [EOL]         case Token.LE: [EOL]             return Token.GE; [EOL]     } [EOL]     return Token.ERROR; [EOL] } <line_num>: 555,567
static boolean isLiteralValue(Node n, boolean includeFunctions) { [EOL]     switch(n.getType()) { [EOL]         case Token.CAST: [EOL]             return isLiteralValue(n.getFirstChild(), includeFunctions); [EOL]         case Token.ARRAYLIT: [EOL]             for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { [EOL]                 if ((!child.isEmpty()) && !isLiteralValue(child, includeFunctions)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]             return true; [EOL]         case Token.REGEXP: [EOL]             for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { [EOL]                 if (!isLiteralValue(child, includeFunctions)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]             return true; [EOL]         case Token.OBJECTLIT: [EOL]             for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { [EOL]                 if (!isLiteralValue(child.getFirstChild(), includeFunctions)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]             return true; [EOL]         case Token.FUNCTION: [EOL]             return includeFunctions && !NodeUtil.isFunctionDeclaration(n); [EOL]         default: [EOL]             return isImmutableValue(n); [EOL]     } [EOL] } <line_num>: 591,631
static boolean isValidDefineValue(Node val, Set<String> defines) { [EOL]     switch(val.getType()) { [EOL]         case Token.STRING: [EOL]         case Token.NUMBER: [EOL]         case Token.TRUE: [EOL]         case Token.FALSE: [EOL]             return true; [EOL]         case Token.ADD: [EOL]         case Token.BITAND: [EOL]         case Token.BITNOT: [EOL]         case Token.BITOR: [EOL]         case Token.BITXOR: [EOL]         case Token.DIV: [EOL]         case Token.EQ: [EOL]         case Token.GE: [EOL]         case Token.GT: [EOL]         case Token.LE: [EOL]         case Token.LSH: [EOL]         case Token.LT: [EOL]         case Token.MOD: [EOL]         case Token.MUL: [EOL]         case Token.NE: [EOL]         case Token.RSH: [EOL]         case Token.SHEQ: [EOL]         case Token.SHNE: [EOL]         case Token.SUB: [EOL]         case Token.URSH: [EOL]             return isValidDefineValue(val.getFirstChild(), defines) && isValidDefineValue(val.getLastChild(), defines); [EOL]         case Token.NOT: [EOL]         case Token.NEG: [EOL]         case Token.POS: [EOL]             return isValidDefineValue(val.getFirstChild(), defines); [EOL]         case Token.NAME: [EOL]         case Token.GETPROP: [EOL]             if (val.isQualifiedName()) { [EOL]                 return defines.contains(val.getQualifiedName()); [EOL]             } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 639,685
static boolean isEmptyBlock(Node block) { [EOL]     if (!block.isBlock()) { [EOL]         return false; [EOL]     } [EOL]     for (Node n = block.getFirstChild(); n != null; n = n.getNext()) { [EOL]         if (!n.isEmpty()) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 692,703
static boolean isSimpleOperator(Node n) { [EOL]     return isSimpleOperatorType(n.getType()); [EOL] } <line_num>: 705,707
static boolean isSimpleOperatorType(int type) { [EOL]     switch(type) { [EOL]         case Token.ADD: [EOL]         case Token.BITAND: [EOL]         case Token.BITNOT: [EOL]         case Token.BITOR: [EOL]         case Token.BITXOR: [EOL]         case Token.COMMA: [EOL]         case Token.DIV: [EOL]         case Token.EQ: [EOL]         case Token.GE: [EOL]         case Token.GETELEM: [EOL]         case Token.GETPROP: [EOL]         case Token.GT: [EOL]         case Token.INSTANCEOF: [EOL]         case Token.LE: [EOL]         case Token.LSH: [EOL]         case Token.LT: [EOL]         case Token.MOD: [EOL]         case Token.MUL: [EOL]         case Token.NE: [EOL]         case Token.NOT: [EOL]         case Token.RSH: [EOL]         case Token.SHEQ: [EOL]         case Token.SHNE: [EOL]         case Token.SUB: [EOL]         case Token.TYPEOF: [EOL]         case Token.VOID: [EOL]         case Token.POS: [EOL]         case Token.NEG: [EOL]         case Token.URSH: [EOL]             return true; [EOL]         default: [EOL]             return false; [EOL]     } [EOL] } <line_num>: 714,750
static Node newExpr(Node child) { [EOL]     return IR.exprResult(child).srcref(child); [EOL] } <line_num>: 758,760
static boolean mayEffectMutableState(Node n) { [EOL]     return mayEffectMutableState(n, null); [EOL] } <line_num>: 768,770
static boolean mayEffectMutableState(Node n, AbstractCompiler compiler) { [EOL]     return checkForStateChangeHelper(n, true, compiler); [EOL] } <line_num>: 772,774
static boolean mayHaveSideEffects(Node n) { [EOL]     return mayHaveSideEffects(n, null); [EOL] } <line_num>: 779,781
static boolean mayHaveSideEffects(Node n, AbstractCompiler compiler) { [EOL]     return checkForStateChangeHelper(n, false, compiler); [EOL] } <line_num>: 783,785
private static boolean checkForStateChangeHelper(Node n, boolean checkForNewObjects, AbstractCompiler compiler) { [EOL]     switch(n.getType()) { [EOL]         case Token.CAST: [EOL]         case Token.AND: [EOL]         case Token.BLOCK: [EOL]         case Token.EXPR_RESULT: [EOL]         case Token.HOOK: [EOL]         case Token.IF: [EOL]         case Token.IN: [EOL]         case Token.PARAM_LIST: [EOL]         case Token.NUMBER: [EOL]         case Token.OR: [EOL]         case Token.THIS: [EOL]         case Token.TRUE: [EOL]         case Token.FALSE: [EOL]         case Token.NULL: [EOL]         case Token.STRING: [EOL]         case Token.STRING_KEY: [EOL]         case Token.SWITCH: [EOL]         case Token.TRY: [EOL]         case Token.EMPTY: [EOL]             break; [EOL]         case Token.THROW: [EOL]             return true; [EOL]         case Token.OBJECTLIT: [EOL]             if (checkForNewObjects) { [EOL]                 return true; [EOL]             } [EOL]             for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { [EOL]                 if (checkForStateChangeHelper(c.getFirstChild(), checkForNewObjects, compiler)) { [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]             return false; [EOL]         case Token.ARRAYLIT: [EOL]         case Token.REGEXP: [EOL]             if (checkForNewObjects) { [EOL]                 return true; [EOL]             } [EOL]             break; [EOL]         case Token.VAR: [EOL]         case Token.NAME: [EOL]             if (n.getFirstChild() != null) { [EOL]                 return true; [EOL]             } [EOL]             break; [EOL]         case Token.FUNCTION: [EOL]             return checkForNewObjects || !isFunctionExpression(n); [EOL]         case Token.NEW: [EOL]             if (checkForNewObjects) { [EOL]                 return true; [EOL]             } [EOL]             if (!constructorCallHasSideEffects(n)) { [EOL]                 break; [EOL]             } [EOL]             return true; [EOL]         case Token.CALL: [EOL]             if (!functionCallHasSideEffects(n, compiler)) { [EOL]                 break; [EOL]             } [EOL]             return true; [EOL]         default: [EOL]             if (isSimpleOperator(n)) { [EOL]                 break; [EOL]             } [EOL]             if (isAssignmentOp(n)) { [EOL]                 Node assignTarget = n.getFirstChild(); [EOL]                 if (assignTarget.isName()) { [EOL]                     return true; [EOL]                 } [EOL]                 if (checkForStateChangeHelper(n.getFirstChild(), checkForNewObjects, compiler) || checkForStateChangeHelper(n.getLastChild(), checkForNewObjects, compiler)) { [EOL]                     return true; [EOL]                 } [EOL]                 if (isGet(assignTarget)) { [EOL]                     Node current = assignTarget.getFirstChild(); [EOL]                     if (evaluatesToLocalValue(current)) { [EOL]                         return false; [EOL]                     } [EOL]                     while (isGet(current)) { [EOL]                         current = current.getFirstChild(); [EOL]                     } [EOL]                     return !isLiteralValue(current, true); [EOL]                 } else { [EOL]                     return !isLiteralValue(assignTarget, true); [EOL]                 } [EOL]             } [EOL]             return true; [EOL]     } [EOL]     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { [EOL]         if (checkForStateChangeHelper(c, checkForNewObjects, compiler)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 793,938
static boolean constructorCallHasSideEffects(Node callNode) { [EOL]     return constructorCallHasSideEffects(callNode, null); [EOL] } <line_num>: 945,947
static boolean constructorCallHasSideEffects(Node callNode, AbstractCompiler compiler) { [EOL]     if (!callNode.isNew()) { [EOL]         throw new IllegalStateException("Expected NEW node, got " + Token.name(callNode.getType())); [EOL]     } [EOL]     if (callNode.isNoSideEffectsCall()) { [EOL]         return false; [EOL]     } [EOL]     Node nameNode = callNode.getFirstChild(); [EOL]     if (nameNode.isName() && CONSTRUCTORS_WITHOUT_SIDE_EFFECTS.contains(nameNode.getString())) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } <line_num>: 949,967
static boolean functionCallHasSideEffects(Node callNode) { [EOL]     return functionCallHasSideEffects(callNode, null); [EOL] } <line_num>: 987,989
static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) { [EOL]     if (!callNode.isCall()) { [EOL]         throw new IllegalStateException("Expected CALL node, got " + Token.name(callNode.getType())); [EOL]     } [EOL]     if (callNode.isNoSideEffectsCall()) { [EOL]         return false; [EOL]     } [EOL]     Node nameNode = callNode.getFirstChild(); [EOL]     if (nameNode.isName()) { [EOL]         String name = nameNode.getString(); [EOL]         if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) { [EOL]             return false; [EOL]         } [EOL]     } else if (nameNode.isGetProp()) { [EOL]         if (callNode.hasOneChild() && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(nameNode.getLastChild().getString())) { [EOL]             return false; [EOL]         } [EOL]         if (callNode.isOnlyModifiesThisCall() && evaluatesToLocalValue(nameNode.getFirstChild())) { [EOL]             return false; [EOL]         } [EOL]         if (nameNode.getFirstChild().isName()) { [EOL]             if ("Math.floor".equals(nameNode.getQualifiedName())) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (compiler != null && !compiler.hasRegExpGlobalReferences()) { [EOL]             if (nameNode.getFirstChild().isRegExp() && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) { [EOL]                 return false; [EOL]             } else if (nameNode.getFirstChild().isString() && STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) { [EOL]                 Node param = nameNode.getNext(); [EOL]                 if (param != null && (param.isString() || param.isRegExp())) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 998,1055
static boolean callHasLocalResult(Node n) { [EOL]     Preconditions.checkState(n.isCall()); [EOL]     return (n.getSideEffectFlags() & Node.FLAG_LOCAL_RESULTS) > 0; [EOL] } <line_num>: 1060,1063
static boolean newHasLocalResult(Node n) { [EOL]     Preconditions.checkState(n.isNew()); [EOL]     return n.isOnlyModifiesThisCall(); [EOL] } <line_num>: 1068,1071
static boolean nodeTypeMayHaveSideEffects(Node n) { [EOL]     return nodeTypeMayHaveSideEffects(n, null); [EOL] } <line_num>: 1080,1082
static boolean nodeTypeMayHaveSideEffects(Node n, AbstractCompiler compiler) { [EOL]     if (isAssignmentOp(n)) { [EOL]         return true; [EOL]     } [EOL]     switch(n.getType()) { [EOL]         case Token.DELPROP: [EOL]         case Token.DEC: [EOL]         case Token.INC: [EOL]         case Token.THROW: [EOL]             return true; [EOL]         case Token.CALL: [EOL]             return NodeUtil.functionCallHasSideEffects(n, compiler); [EOL]         case Token.NEW: [EOL]             return NodeUtil.constructorCallHasSideEffects(n, compiler); [EOL]         case Token.NAME: [EOL]             return n.hasChildren(); [EOL]         default: [EOL]             return false; [EOL]     } [EOL] } <line_num>: 1084,1105
static boolean canBeSideEffected(Node n) { [EOL]     Set<String> emptySet = Collections.emptySet(); [EOL]     return canBeSideEffected(n, emptySet); [EOL] } <line_num>: 1111,1114
static boolean canBeSideEffected(Node n, Set<String> knownConstants) { [EOL]     switch(n.getType()) { [EOL]         case Token.CALL: [EOL]         case Token.NEW: [EOL]             return true; [EOL]         case Token.NAME: [EOL]             return !isConstantName(n) && !knownConstants.contains(n.getString()); [EOL]         case Token.GETPROP: [EOL]         case Token.GETELEM: [EOL]             return true; [EOL]         case Token.FUNCTION: [EOL]             Preconditions.checkState(isFunctionExpression(n)); [EOL]             return false; [EOL]     } [EOL]     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { [EOL]         if (canBeSideEffected(c, knownConstants)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1122,1154
static int precedence(int type) { [EOL]     switch(type) { [EOL]         case Token.COMMA: [EOL]             return 0; [EOL]         case Token.ASSIGN_BITOR: [EOL]         case Token.ASSIGN_BITXOR: [EOL]         case Token.ASSIGN_BITAND: [EOL]         case Token.ASSIGN_LSH: [EOL]         case Token.ASSIGN_RSH: [EOL]         case Token.ASSIGN_URSH: [EOL]         case Token.ASSIGN_ADD: [EOL]         case Token.ASSIGN_SUB: [EOL]         case Token.ASSIGN_MUL: [EOL]         case Token.ASSIGN_DIV: [EOL]         case Token.ASSIGN_MOD: [EOL]         case Token.ASSIGN: [EOL]             return 1; [EOL]         case Token.HOOK: [EOL]             return 2; [EOL]         case Token.OR: [EOL]             return 3; [EOL]         case Token.AND: [EOL]             return 4; [EOL]         case Token.BITOR: [EOL]             return 5; [EOL]         case Token.BITXOR: [EOL]             return 6; [EOL]         case Token.BITAND: [EOL]             return 7; [EOL]         case Token.EQ: [EOL]         case Token.NE: [EOL]         case Token.SHEQ: [EOL]         case Token.SHNE: [EOL]             return 8; [EOL]         case Token.LT: [EOL]         case Token.GT: [EOL]         case Token.LE: [EOL]         case Token.GE: [EOL]         case Token.INSTANCEOF: [EOL]         case Token.IN: [EOL]             return 9; [EOL]         case Token.LSH: [EOL]         case Token.RSH: [EOL]         case Token.URSH: [EOL]             return 10; [EOL]         case Token.SUB: [EOL]         case Token.ADD: [EOL]             return 11; [EOL]         case Token.MUL: [EOL]         case Token.MOD: [EOL]         case Token.DIV: [EOL]             return 12; [EOL]         case Token.INC: [EOL]         case Token.DEC: [EOL]         case Token.NEW: [EOL]         case Token.DELPROP: [EOL]         case Token.TYPEOF: [EOL]         case Token.VOID: [EOL]         case Token.NOT: [EOL]         case Token.BITNOT: [EOL]         case Token.POS: [EOL]         case Token.NEG: [EOL]             return 13; [EOL]         case Token.CALL: [EOL]         case Token.GETELEM: [EOL]         case Token.GETPROP: [EOL]         case Token.ARRAYLIT: [EOL]         case Token.EMPTY: [EOL]         case Token.FALSE: [EOL]         case Token.FUNCTION: [EOL]         case Token.NAME: [EOL]         case Token.NULL: [EOL]         case Token.NUMBER: [EOL]         case Token.OBJECTLIT: [EOL]         case Token.REGEXP: [EOL]         case Token.STRING: [EOL]         case Token.STRING_KEY: [EOL]         case Token.THIS: [EOL]         case Token.TRUE: [EOL]             return 15; [EOL]         case Token.CAST: [EOL]             return 16; [EOL]         default: [EOL]             throw new Error("Unknown precedence for " + Token.name(type) + " (type " + type + ")"); [EOL]     } [EOL] } <line_num>: 1173,1248
static boolean isUndefined(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.VOID: [EOL]             return true; [EOL]         case Token.NAME: [EOL]             return n.getString().equals("undefined"); [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1250,1258
static boolean isNullOrUndefined(Node n) { [EOL]     return n.isNull() || isUndefined(n); [EOL] } <line_num>: 1260,1262
@Override [EOL] public boolean apply(Node n) { [EOL]     return isImmutableValue(n); [EOL] } <line_num>: 1265,1268
static boolean isImmutableResult(Node n) { [EOL]     return allResultsMatch(n, IMMUTABLE_PREDICATE); [EOL] } <line_num>: 1271,1273
static boolean allResultsMatch(Node n, Predicate<Node> p) { [EOL]     switch(n.getType()) { [EOL]         case Token.CAST: [EOL]             return allResultsMatch(n.getFirstChild(), p); [EOL]         case Token.ASSIGN: [EOL]         case Token.COMMA: [EOL]             return allResultsMatch(n.getLastChild(), p); [EOL]         case Token.AND: [EOL]         case Token.OR: [EOL]             return allResultsMatch(n.getFirstChild(), p) && allResultsMatch(n.getLastChild(), p); [EOL]         case Token.HOOK: [EOL]             return allResultsMatch(n.getFirstChild().getNext(), p) && allResultsMatch(n.getLastChild(), p); [EOL]         default: [EOL]             return p.apply(n); [EOL]     } [EOL] } <line_num>: 1279,1296
static boolean anyResultsMatch(Node n, Predicate<Node> p) { [EOL]     switch(n.getType()) { [EOL]         case Token.CAST: [EOL]             return anyResultsMatch(n.getFirstChild(), p); [EOL]         case Token.ASSIGN: [EOL]         case Token.COMMA: [EOL]             return anyResultsMatch(n.getLastChild(), p); [EOL]         case Token.AND: [EOL]         case Token.OR: [EOL]             return anyResultsMatch(n.getFirstChild(), p) || anyResultsMatch(n.getLastChild(), p); [EOL]         case Token.HOOK: [EOL]             return anyResultsMatch(n.getFirstChild().getNext(), p) || anyResultsMatch(n.getLastChild(), p); [EOL]         default: [EOL]             return p.apply(n); [EOL]     } [EOL] } <line_num>: 1302,1319
@Override [EOL] public boolean apply(Node n) { [EOL]     return isNumericResultHelper(n); [EOL] } <line_num>: 1322,1325
static boolean isNumericResult(Node n) { [EOL]     return allResultsMatch(n, NUMBERIC_RESULT_PREDICATE); [EOL] } <line_num>: 1334,1336
static boolean isNumericResultHelper(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.ADD: [EOL]             return !mayBeString(n.getFirstChild()) && !mayBeString(n.getLastChild()); [EOL]         case Token.BITNOT: [EOL]         case Token.BITOR: [EOL]         case Token.BITXOR: [EOL]         case Token.BITAND: [EOL]         case Token.LSH: [EOL]         case Token.RSH: [EOL]         case Token.URSH: [EOL]         case Token.SUB: [EOL]         case Token.MUL: [EOL]         case Token.MOD: [EOL]         case Token.DIV: [EOL]         case Token.INC: [EOL]         case Token.DEC: [EOL]         case Token.POS: [EOL]         case Token.NEG: [EOL]         case Token.NUMBER: [EOL]             return true; [EOL]         case Token.NAME: [EOL]             String name = n.getString(); [EOL]             if (name.equals("NaN")) { [EOL]                 return true; [EOL]             } [EOL]             if (name.equals("Infinity")) { [EOL]                 return true; [EOL]             } [EOL]             return false; [EOL]         default: [EOL]             return false; [EOL]     } [EOL] } <line_num>: 1338,1372
@Override [EOL] public boolean apply(Node n) { [EOL]     return isBooleanResultHelper(n); [EOL] } <line_num>: 1375,1378
static boolean isBooleanResult(Node n) { [EOL]     return allResultsMatch(n, BOOLEAN_RESULT_PREDICATE); [EOL] } <line_num>: 1387,1389
static boolean isBooleanResultHelper(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.TRUE: [EOL]         case Token.FALSE: [EOL]         case Token.EQ: [EOL]         case Token.NE: [EOL]         case Token.SHEQ: [EOL]         case Token.SHNE: [EOL]         case Token.LT: [EOL]         case Token.GT: [EOL]         case Token.LE: [EOL]         case Token.GE: [EOL]         case Token.IN: [EOL]         case Token.INSTANCEOF: [EOL]         case Token.NOT: [EOL]         case Token.DELPROP: [EOL]             return true; [EOL]         default: [EOL]             return false; [EOL]     } [EOL] } <line_num>: 1391,1416
@Override [EOL] public boolean apply(Node n) { [EOL]     return mayBeStringHelper(n); [EOL] } <line_num>: 1421,1424
static boolean mayBeString(Node n) { [EOL]     return mayBeString(n, true); [EOL] } <line_num>: 1433,1435
static boolean mayBeString(Node n, boolean recurse) { [EOL]     if (recurse) { [EOL]         return anyResultsMatch(n, MAY_BE_STRING_PREDICATE); [EOL]     } else { [EOL]         return mayBeStringHelper(n); [EOL]     } [EOL] } <line_num>: 1437,1443
static boolean mayBeStringHelper(Node n) { [EOL]     return !isNumericResult(n) && !isBooleanResult(n) && !isUndefined(n) && !n.isNull(); [EOL] } <line_num>: 1445,1448
static boolean isAssociative(int type) { [EOL]     switch(type) { [EOL]         case Token.MUL: [EOL]         case Token.AND: [EOL]         case Token.OR: [EOL]         case Token.BITOR: [EOL]         case Token.BITXOR: [EOL]         case Token.BITAND: [EOL]             return true; [EOL]         default: [EOL]             return false; [EOL]     } [EOL] } <line_num>: 1456,1468
static boolean isCommutative(int type) { [EOL]     switch(type) { [EOL]         case Token.MUL: [EOL]         case Token.BITOR: [EOL]         case Token.BITXOR: [EOL]         case Token.BITAND: [EOL]             return true; [EOL]         default: [EOL]             return false; [EOL]     } [EOL] } <line_num>: 1477,1487
static boolean isAssignmentOp(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.ASSIGN: [EOL]         case Token.ASSIGN_BITOR: [EOL]         case Token.ASSIGN_BITXOR: [EOL]         case Token.ASSIGN_BITAND: [EOL]         case Token.ASSIGN_LSH: [EOL]         case Token.ASSIGN_RSH: [EOL]         case Token.ASSIGN_URSH: [EOL]         case Token.ASSIGN_ADD: [EOL]         case Token.ASSIGN_SUB: [EOL]         case Token.ASSIGN_MUL: [EOL]         case Token.ASSIGN_DIV: [EOL]         case Token.ASSIGN_MOD: [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1489,1506
static int getOpFromAssignmentOp(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.ASSIGN_BITOR: [EOL]             return Token.BITOR; [EOL]         case Token.ASSIGN_BITXOR: [EOL]             return Token.BITXOR; [EOL]         case Token.ASSIGN_BITAND: [EOL]             return Token.BITAND; [EOL]         case Token.ASSIGN_LSH: [EOL]             return Token.LSH; [EOL]         case Token.ASSIGN_RSH: [EOL]             return Token.RSH; [EOL]         case Token.ASSIGN_URSH: [EOL]             return Token.URSH; [EOL]         case Token.ASSIGN_ADD: [EOL]             return Token.ADD; [EOL]         case Token.ASSIGN_SUB: [EOL]             return Token.SUB; [EOL]         case Token.ASSIGN_MUL: [EOL]             return Token.MUL; [EOL]         case Token.ASSIGN_DIV: [EOL]             return Token.DIV; [EOL]         case Token.ASSIGN_MOD: [EOL]             return Token.MOD; [EOL]     } [EOL]     throw new IllegalArgumentException("Not an assignment op:" + n); [EOL] } <line_num>: 1508,1534
static boolean containsFunction(Node n) { [EOL]     return containsType(n, Token.FUNCTION); [EOL] } <line_num>: 1540,1542
static boolean referencesThis(Node n) { [EOL]     Node start = (n.isFunction()) ? n.getLastChild() : n; [EOL]     return containsType(start, Token.THIS, MATCH_NOT_FUNCTION); [EOL] } <line_num>: 1547,1550
static boolean isGet(Node n) { [EOL]     return n.isGetProp() || n.isGetElem(); [EOL] } <line_num>: 1555,1557
static boolean isVarDeclaration(Node n) { [EOL]     return n.isName() && n.getParent().isVar(); [EOL] } <line_num>: 1565,1569
static Node getAssignedValue(Node n) { [EOL]     Preconditions.checkState(n.isName()); [EOL]     Node parent = n.getParent(); [EOL]     if (parent.isVar()) { [EOL]         return n.getFirstChild(); [EOL]     } else if (parent.isAssign() && parent.getFirstChild() == n) { [EOL]         return n.getNext(); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] } <line_num>: 1575,1585
static boolean isExprAssign(Node n) { [EOL]     return n.isExprResult() && n.getFirstChild().isAssign(); [EOL] } <line_num>: 1594,1597
static boolean isExprCall(Node n) { [EOL]     return n.isExprResult() && n.getFirstChild().isCall(); [EOL] } <line_num>: 1606,1609
static boolean isForIn(Node n) { [EOL]     return n.isFor() && n.getChildCount() == 3; [EOL] } <line_num>: 1614,1617
static boolean isLoopStructure(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.FOR: [EOL]         case Token.DO: [EOL]         case Token.WHILE: [EOL]             return true; [EOL]         default: [EOL]             return false; [EOL]     } [EOL] } <line_num>: 1622,1631
static Node getLoopCodeBlock(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.FOR: [EOL]         case Token.WHILE: [EOL]             return n.getLastChild(); [EOL]         case Token.DO: [EOL]             return n.getFirstChild(); [EOL]         default: [EOL]             return null; [EOL]     } [EOL] } <line_num>: 1638,1648
static boolean isWithinLoop(Node n) { [EOL]     for (Node parent : n.getAncestors()) { [EOL]         if (NodeUtil.isLoopStructure(parent)) { [EOL]             return true; [EOL]         } [EOL]         if (parent.isFunction()) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1654,1665
static boolean isControlStructure(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.FOR: [EOL]         case Token.DO: [EOL]         case Token.WHILE: [EOL]         case Token.WITH: [EOL]         case Token.IF: [EOL]         case Token.LABEL: [EOL]         case Token.TRY: [EOL]         case Token.CATCH: [EOL]         case Token.SWITCH: [EOL]         case Token.CASE: [EOL]         case Token.DEFAULT_CASE: [EOL]             return true; [EOL]         default: [EOL]             return false; [EOL]     } [EOL] } <line_num>: 1670,1687
static boolean isControlStructureCodeBlock(Node parent, Node n) { [EOL]     switch(parent.getType()) { [EOL]         case Token.FOR: [EOL]         case Token.WHILE: [EOL]         case Token.LABEL: [EOL]         case Token.WITH: [EOL]             return parent.getLastChild() == n; [EOL]         case Token.DO: [EOL]             return parent.getFirstChild() == n; [EOL]         case Token.IF: [EOL]             return parent.getFirstChild() != n; [EOL]         case Token.TRY: [EOL]             return parent.getFirstChild() == n || parent.getLastChild() == n; [EOL]         case Token.CATCH: [EOL]             return parent.getLastChild() == n; [EOL]         case Token.SWITCH: [EOL]         case Token.CASE: [EOL]             return parent.getFirstChild() != n; [EOL]         case Token.DEFAULT_CASE: [EOL]             return true; [EOL]         default: [EOL]             Preconditions.checkState(isControlStructure(parent)); [EOL]             return false; [EOL]     } [EOL] } <line_num>: 1693,1717
static Node getConditionExpression(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.IF: [EOL]         case Token.WHILE: [EOL]             return n.getFirstChild(); [EOL]         case Token.DO: [EOL]             return n.getLastChild(); [EOL]         case Token.FOR: [EOL]             switch(n.getChildCount()) { [EOL]                 case 3: [EOL]                     return null; [EOL]                 case 4: [EOL]                     return n.getFirstChild().getNext(); [EOL]             } [EOL]             throw new IllegalArgumentException("malformed 'for' statement " + n); [EOL]         case Token.CASE: [EOL]             return null; [EOL]     } [EOL]     throw new IllegalArgumentException(n + " does not have a condition."); [EOL] } <line_num>: 1724,1743
static boolean isStatementBlock(Node n) { [EOL]     return n.isScript() || n.isBlock(); [EOL] } <line_num>: 1748,1750
static boolean isStatement(Node n) { [EOL]     return isStatementParent(n.getParent()); [EOL] } <line_num>: 1755,1757
static boolean isStatementParent(Node parent) { [EOL]     Preconditions.checkState(parent != null); [EOL]     switch(parent.getType()) { [EOL]         case Token.SCRIPT: [EOL]         case Token.BLOCK: [EOL]         case Token.LABEL: [EOL]             return true; [EOL]         default: [EOL]             return false; [EOL]     } [EOL] } <line_num>: 1759,1772
static boolean isSwitchCase(Node n) { [EOL]     return n.isCase() || n.isDefaultCase(); [EOL] } <line_num>: 1775,1777
static boolean isReferenceName(Node n) { [EOL]     return n.isName() && !n.getString().isEmpty(); [EOL] } <line_num>: 1783,1785
static boolean isTryFinallyNode(Node parent, Node child) { [EOL]     return parent.isTry() && parent.getChildCount() == 3 && child == parent.getLastChild(); [EOL] } <line_num>: 1788,1791
static boolean isTryCatchNodeContainer(Node n) { [EOL]     Node parent = n.getParent(); [EOL]     return parent.isTry() && parent.getFirstChild().getNext() == n; [EOL] } <line_num>: 1794,1798
static void removeChild(Node parent, Node node) { [EOL]     if (isTryFinallyNode(parent, node)) { [EOL]         if (NodeUtil.hasCatchHandler(getCatchBlock(parent))) { [EOL]             parent.removeChild(node); [EOL]         } else { [EOL]             node.detachChildren(); [EOL]         } [EOL]     } else if (node.isCatch()) { [EOL]         Node tryNode = node.getParent().getParent(); [EOL]         Preconditions.checkState(NodeUtil.hasFinally(tryNode)); [EOL]         node.detachFromParent(); [EOL]     } else if (isTryCatchNodeContainer(node)) { [EOL]         Node tryNode = node.getParent(); [EOL]         Preconditions.checkState(NodeUtil.hasFinally(tryNode)); [EOL]         node.detachChildren(); [EOL]     } else if (node.isBlock()) { [EOL]         node.detachChildren(); [EOL]     } else if (isStatementBlock(parent) || isSwitchCase(node)) { [EOL]         parent.removeChild(node); [EOL]     } else if (parent.isVar()) { [EOL]         if (parent.hasMoreThanOneChild()) { [EOL]             parent.removeChild(node); [EOL]         } else { [EOL]             parent.removeChild(node); [EOL]             removeChild(parent.getParent(), parent); [EOL]         } [EOL]     } else if (parent.isLabel() && node == parent.getLastChild()) { [EOL]         parent.removeChild(node); [EOL]         removeChild(parent.getParent(), parent); [EOL]     } else if (parent.isFor() && parent.getChildCount() == 4) { [EOL]         parent.replaceChild(node, IR.empty()); [EOL]     } else { [EOL]         throw new IllegalStateException("Invalid attempt to remove node: " + node.toString() + " of " + parent.toString()); [EOL]     } [EOL] } <line_num>: 1801,1854
static void maybeAddFinally(Node tryNode) { [EOL]     Preconditions.checkState(tryNode.isTry()); [EOL]     if (!NodeUtil.hasFinally(tryNode)) { [EOL]         tryNode.addChildrenToBack(IR.block().srcref(tryNode)); [EOL]     } [EOL] } <line_num>: 1859,1864
static boolean tryMergeBlock(Node block) { [EOL]     Preconditions.checkState(block.isBlock()); [EOL]     Node parent = block.getParent(); [EOL]     if (isStatementBlock(parent)) { [EOL]         Node previous = block; [EOL]         while (block.hasChildren()) { [EOL]             Node child = block.removeFirstChild(); [EOL]             parent.addChildAfter(child, previous); [EOL]             previous = child; [EOL]         } [EOL]         parent.removeChild(block); [EOL]         return true; [EOL]     } else { [EOL]         return false; [EOL]     } [EOL] } <line_num>: 1870,1887
static boolean isCallOrNew(Node node) { [EOL]     return node.isCall() || node.isNew(); [EOL] } <line_num>: 1893,1895
static Node getFunctionBody(Node fn) { [EOL]     Preconditions.checkArgument(fn.isFunction()); [EOL]     return fn.getLastChild(); [EOL] } <line_num>: 1900,1903
static boolean isFunctionDeclaration(Node n) { [EOL]     return n.isFunction() && isStatement(n); [EOL] } <line_num>: 1910,1912
static boolean isHoistedFunctionDeclaration(Node n) { [EOL]     return isFunctionDeclaration(n) && (n.getParent().isScript() || n.getParent().getParent().isFunction()); [EOL] } <line_num>: 1919,1923
static boolean isFunctionExpression(Node n) { [EOL]     return n.isFunction() && !isStatement(n); [EOL] } <line_num>: 1948,1950
static boolean isBleedingFunctionName(Node n) { [EOL]     return n.isName() && !n.getString().isEmpty() && isFunctionExpression(n.getParent()); [EOL] } <line_num>: 1956,1959
static boolean isEmptyFunctionExpression(Node node) { [EOL]     return isFunctionExpression(node) && isEmptyBlock(node.getLastChild()); [EOL] } <line_num>: 1967,1969
static boolean isVarArgsFunction(Node function) { [EOL]     Preconditions.checkArgument(function.isFunction()); [EOL]     return isNameReferenced(function.getLastChild(), "arguments", MATCH_NOT_FUNCTION); [EOL] } <line_num>: 1975,1982
static boolean isObjectCallMethod(Node callNode, String methodName) { [EOL]     if (callNode.isCall()) { [EOL]         Node functionIndentifyingExpression = callNode.getFirstChild(); [EOL]         if (isGet(functionIndentifyingExpression)) { [EOL]             Node last = functionIndentifyingExpression.getLastChild(); [EOL]             if (last != null && last.isString()) { [EOL]                 String propName = last.getString(); [EOL]                 return (propName.equals(methodName)); [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1989,2001
static boolean isFunctionObjectCall(Node callNode) { [EOL]     return isObjectCallMethod(callNode, "call"); [EOL] } <line_num>: 2009,2011
static boolean isFunctionObjectApply(Node callNode) { [EOL]     return isObjectCallMethod(callNode, "apply"); [EOL] } <line_num>: 2018,2020
static boolean isVarOrSimpleAssignLhs(Node n, Node parent) { [EOL]     return (parent.isAssign() && parent.getFirstChild() == n) || parent.isVar(); [EOL] } <line_num>: 2031,2034
public static boolean isLValue(Node n) { [EOL]     Preconditions.checkArgument(n.isName() || n.isGetProp() || n.isGetElem()); [EOL]     Node parent = n.getParent(); [EOL]     if (parent == null) { [EOL]         return false; [EOL]     } [EOL]     return (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) || (NodeUtil.isForIn(parent) && parent.getFirstChild() == n) || parent.isVar() || (parent.isFunction() && parent.getFirstChild() == n) || parent.isDec() || parent.isInc() || parent.isParamList() || parent.isCatch(); [EOL] } <line_num>: 2049,2064
static boolean isObjectLitKey(Node node, Node parent) { [EOL]     switch(node.getType()) { [EOL]         case Token.STRING_KEY: [EOL]         case Token.GETTER_DEF: [EOL]         case Token.SETTER_DEF: [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 2073,2081
static String getObjectLitKeyName(Node key) { [EOL]     switch(key.getType()) { [EOL]         case Token.STRING_KEY: [EOL]         case Token.GETTER_DEF: [EOL]         case Token.SETTER_DEF: [EOL]             return key.getString(); [EOL]     } [EOL]     throw new IllegalStateException("Unexpected node type: " + key); [EOL] } <line_num>: 2088,2096
static JSType getObjectLitKeyTypeFromValueType(Node key, JSType valueType) { [EOL]     if (valueType != null) { [EOL]         switch(key.getType()) { [EOL]             case Token.GETTER_DEF: [EOL]                 if (valueType.isFunctionType()) { [EOL]                     FunctionType fntype = valueType.toMaybeFunctionType(); [EOL]                     valueType = fntype.getReturnType(); [EOL]                 } else { [EOL]                     return null; [EOL]                 } [EOL]                 break; [EOL]             case Token.SETTER_DEF: [EOL]                 if (valueType.isFunctionType()) { [EOL]                     FunctionType fntype = valueType.toMaybeFunctionType(); [EOL]                     Node param = fntype.getParametersNode().getFirstChild(); [EOL]                     valueType = param.getJSType(); [EOL]                 } else { [EOL]                     return null; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return valueType; [EOL] } <line_num>: 2102,2128
static boolean isGetOrSetKey(Node node) { [EOL]     switch(node.getType()) { [EOL]         case Token.GETTER_DEF: [EOL]         case Token.SETTER_DEF: [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 2136,2143
static String opToStr(int operator) { [EOL]     switch(operator) { [EOL]         case Token.BITOR: [EOL]             return "|"; [EOL]         case Token.OR: [EOL]             return "||"; [EOL]         case Token.BITXOR: [EOL]             return "^"; [EOL]         case Token.AND: [EOL]             return "&&"; [EOL]         case Token.BITAND: [EOL]             return "&"; [EOL]         case Token.SHEQ: [EOL]             return "==="; [EOL]         case Token.EQ: [EOL]             return "=="; [EOL]         case Token.NOT: [EOL]             return "!"; [EOL]         case Token.NE: [EOL]             return "!="; [EOL]         case Token.SHNE: [EOL]             return "!=="; [EOL]         case Token.LSH: [EOL]             return "<<"; [EOL]         case Token.IN: [EOL]             return "in"; [EOL]         case Token.LE: [EOL]             return "<="; [EOL]         case Token.LT: [EOL]             return "<"; [EOL]         case Token.URSH: [EOL]             return ">>>"; [EOL]         case Token.RSH: [EOL]             return ">>"; [EOL]         case Token.GE: [EOL]             return ">="; [EOL]         case Token.GT: [EOL]             return ">"; [EOL]         case Token.MUL: [EOL]             return "*"; [EOL]         case Token.DIV: [EOL]             return "/"; [EOL]         case Token.MOD: [EOL]             return "%"; [EOL]         case Token.BITNOT: [EOL]             return "~"; [EOL]         case Token.ADD: [EOL]             return "+"; [EOL]         case Token.SUB: [EOL]             return "-"; [EOL]         case Token.POS: [EOL]             return "+"; [EOL]         case Token.NEG: [EOL]             return "-"; [EOL]         case Token.ASSIGN: [EOL]             return "="; [EOL]         case Token.ASSIGN_BITOR: [EOL]             return "|="; [EOL]         case Token.ASSIGN_BITXOR: [EOL]             return "^="; [EOL]         case Token.ASSIGN_BITAND: [EOL]             return "&="; [EOL]         case Token.ASSIGN_LSH: [EOL]             return "<<="; [EOL]         case Token.ASSIGN_RSH: [EOL]             return ">>="; [EOL]         case Token.ASSIGN_URSH: [EOL]             return ">>>="; [EOL]         case Token.ASSIGN_ADD: [EOL]             return "+="; [EOL]         case Token.ASSIGN_SUB: [EOL]             return "-="; [EOL]         case Token.ASSIGN_MUL: [EOL]             return "*="; [EOL]         case Token.ASSIGN_DIV: [EOL]             return "/="; [EOL]         case Token.ASSIGN_MOD: [EOL]             return "%="; [EOL]         case Token.VOID: [EOL]             return "void"; [EOL]         case Token.TYPEOF: [EOL]             return "typeof"; [EOL]         case Token.INSTANCEOF: [EOL]             return "instanceof"; [EOL]         default: [EOL]             return null; [EOL]     } [EOL] } <line_num>: 2153,2198
static String opToStrNoFail(int operator) { [EOL]     String res = opToStr(operator); [EOL]     if (res == null) { [EOL]         throw new Error("Unknown op " + operator + ": " + Token.name(operator)); [EOL]     } [EOL]     return res; [EOL] } <line_num>: 2208,2215
static boolean containsType(Node node, int type, Predicate<Node> traverseChildrenPred) { [EOL]     return has(node, new MatchNodeType(type), traverseChildrenPred); [EOL] } <line_num>: 2220,2224
static boolean containsType(Node node, int type) { [EOL]     return containsType(node, type, Predicates.<Node>alwaysTrue()); [EOL] } <line_num>: 2229,2231
static void redeclareVarsInsideBranch(Node branch) { [EOL]     Collection<Node> vars = getVarsDeclaredInBranch(branch); [EOL]     if (vars.isEmpty()) { [EOL]         return; [EOL]     } [EOL]     Node parent = getAddingRoot(branch); [EOL]     for (Node nameNode : vars) { [EOL]         Node var = IR.var(IR.name(nameNode.getString()).srcref(nameNode)).srcref(nameNode); [EOL]         copyNameAnnotations(nameNode, var.getFirstChild()); [EOL]         parent.addChildToFront(var); [EOL]     } [EOL] } <line_num>: 2239,2254
static void copyNameAnnotations(Node source, Node destination) { [EOL]     if (source.getBooleanProp(Node.IS_CONSTANT_NAME)) { [EOL]         destination.putBooleanProp(Node.IS_CONSTANT_NAME, true); [EOL]     } [EOL] } <line_num>: 2261,2265
private static Node getAddingRoot(Node n) { [EOL]     Node addingRoot = null; [EOL]     Node ancestor = n; [EOL]     while (null != (ancestor = ancestor.getParent())) { [EOL]         int type = ancestor.getType(); [EOL]         if (type == Token.SCRIPT) { [EOL]             addingRoot = ancestor; [EOL]             break; [EOL]         } else if (type == Token.FUNCTION) { [EOL]             addingRoot = ancestor.getLastChild(); [EOL]             break; [EOL]         } [EOL]     } [EOL]     Preconditions.checkState(addingRoot.isBlock() || addingRoot.isScript()); [EOL]     Preconditions.checkState(addingRoot.getFirstChild() == null || !addingRoot.getFirstChild().isScript()); [EOL]     return addingRoot; [EOL] } <line_num>: 2271,2291
public static Node newQualifiedNameNode(CodingConvention convention, String name) { [EOL]     int endPos = name.indexOf('.'); [EOL]     if (endPos == -1) { [EOL]         return newName(convention, name); [EOL]     } [EOL]     Node node = newName(convention, name.substring(0, endPos)); [EOL]     int startPos; [EOL]     do { [EOL]         startPos = endPos + 1; [EOL]         endPos = name.indexOf('.', startPos); [EOL]         String part = (endPos == -1 ? name.substring(startPos) : name.substring(startPos, endPos)); [EOL]         Node propNode = IR.string(part); [EOL]         if (convention.isConstantKey(part)) { [EOL]             propNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); [EOL]         } [EOL]         node = IR.getprop(node, propNode); [EOL]     } while (endPos != -1); [EOL]     return node; [EOL] } <line_num>: 2299,2321
static Node newQualifiedNameNode(CodingConvention convention, String name, Node basisNode, String originalName) { [EOL]     Node node = newQualifiedNameNode(convention, name); [EOL]     setDebugInformation(node, basisNode, originalName); [EOL]     return node; [EOL] } <line_num>: 2336,2342
static Node getRootOfQualifiedName(Node qName) { [EOL]     for (Node current = qName; true; current = current.getFirstChild()) { [EOL]         if (current.isName() || current.isThis()) { [EOL]             return current; [EOL]         } [EOL]         Preconditions.checkState(current.isGetProp()); [EOL]     } [EOL] } <line_num>: 2347,2355
static void setDebugInformation(Node node, Node basisNode, String originalName) { [EOL]     node.copyInformationFromForTree(basisNode); [EOL]     node.putProp(Node.ORIGINALNAME_PROP, originalName); [EOL] } <line_num>: 2365,2369
private static Node newName(CodingConvention convention, String name) { [EOL]     Node nameNode = IR.name(name); [EOL]     if (convention.isConstant(name)) { [EOL]         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); [EOL]     } [EOL]     return nameNode; [EOL] } <line_num>: 2371,2378
static Node newName(CodingConvention convention, String name, Node srcref) { [EOL]     return newName(convention, name).srcref(srcref); [EOL] } <line_num>: 2390,2392
static Node newName(CodingConvention convention, String name, Node basisNode, String originalName) { [EOL]     Node nameNode = newName(convention, name, basisNode); [EOL]     nameNode.putProp(Node.ORIGINALNAME_PROP, originalName); [EOL]     return nameNode; [EOL] } <line_num>: 2407,2413
static boolean isLatin(String s) { [EOL]     int len = s.length(); [EOL]     for (int index = 0; index < len; index++) { [EOL]         char c = s.charAt(index); [EOL]         if (c > LARGEST_BASIC_LATIN) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 2428,2437
static boolean isValidSimpleName(String name) { [EOL]     return TokenStream.isJSIdentifier(name) && !TokenStream.isKeyword(name) && isLatin(name); [EOL] } <line_num>: 2442,2452
public static boolean isValidQualifiedName(String name) { [EOL]     if (name.endsWith(".") || name.startsWith(".")) { [EOL]         return false; [EOL]     } [EOL]     String[] parts = name.split("\\."); [EOL]     for (String part : parts) { [EOL]         if (!isValidSimpleName(part)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 2459,2470
static boolean isValidPropertyName(String name) { [EOL]     return isValidSimpleName(name); [EOL] } <line_num>: 2476,2478
@Override [EOL] public void visit(Node n) { [EOL]     if (n.isName()) { [EOL]         Node parent = n.getParent(); [EOL]         if (parent != null && parent.isVar()) { [EOL]             String name = n.getString(); [EOL]             if (!vars.containsKey(name)) { [EOL]                 vars.put(name, n); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 2483,2494
static Collection<Node> getVarsDeclaredInBranch(Node root) { [EOL]     VarCollector collector = new VarCollector(); [EOL]     visitPreOrder(root, collector, MATCH_NOT_FUNCTION); [EOL]     return collector.vars.values(); [EOL] } <line_num>: 2500,2507
static boolean isPrototypePropertyDeclaration(Node n) { [EOL]     if (!isExprAssign(n)) { [EOL]         return false; [EOL]     } [EOL]     return isPrototypeProperty(n.getFirstChild().getFirstChild()); [EOL] } <line_num>: 2513,2518
static boolean isPrototypeProperty(Node n) { [EOL]     String lhsString = n.getQualifiedName(); [EOL]     if (lhsString == null) { [EOL]         return false; [EOL]     } [EOL]     int prototypeIdx = lhsString.indexOf(".prototype."); [EOL]     return prototypeIdx != -1; [EOL] } <line_num>: 2523,2530
static Node getPrototypeClassName(Node qName) { [EOL]     Node cur = qName; [EOL]     while (cur.isGetProp()) { [EOL]         if (cur.getLastChild().getString().equals("prototype")) { [EOL]             return cur.getFirstChild(); [EOL]         } else { [EOL]             cur = cur.getFirstChild(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 2535,2545
static String getPrototypePropertyName(Node qName) { [EOL]     String qNameStr = qName.getQualifiedName(); [EOL]     int prototypeIdx = qNameStr.lastIndexOf(".prototype."); [EOL]     int memberIndex = prototypeIdx + ".prototype".length() + 1; [EOL]     return qNameStr.substring(memberIndex); [EOL] } <line_num>: 2550,2555
static Node newUndefinedNode(Node srcReferenceNode) { [EOL]     Node node = IR.voidNode(IR.number(0)); [EOL]     if (srcReferenceNode != null) { [EOL]         node.copyInformationFromForTree(srcReferenceNode); [EOL]     } [EOL]     return node; [EOL] } <line_num>: 2561,2567
static Node newVarNode(String name, Node value) { [EOL]     Node nodeName = IR.name(name); [EOL]     if (value != null) { [EOL]         Preconditions.checkState(value.getNext() == null); [EOL]         nodeName.addChildToBack(value); [EOL]         nodeName.srcref(value); [EOL]     } [EOL]     Node var = IR.var(nodeName).srcref(nodeName); [EOL]     return var; [EOL] } <line_num>: 2572,2582
@Override [EOL] public boolean apply(Node n) { [EOL]     return n.isName() && n.getString().equals(name); [EOL] } <line_num>: 2594,2597
@Override [EOL] public boolean apply(Node n) { [EOL]     return n.getType() == type; [EOL] } <line_num>: 2610,2613
@Override [EOL] public boolean apply(Node n) { [EOL]     return isFunctionDeclaration(n) || n.isVar(); [EOL] } <line_num>: 2621,2624
@Override [EOL] public boolean apply(Node n) { [EOL]     return !n.isFunction(); [EOL] } <line_num>: 2631,2634
@Override [EOL] public boolean apply(Node n) { [EOL]     Node parent = n.getParent(); [EOL]     return n.isBlock() || (!n.isFunction() && (parent == null || isControlStructure(parent) || isStatementBlock(parent))); [EOL] } <line_num>: 2643,2650
static int getNodeTypeReferenceCount(Node node, int type, Predicate<Node> traverseChildrenPred) { [EOL]     return getCount(node, new MatchNodeType(type), traverseChildrenPred); [EOL] } <line_num>: 2656,2659
static boolean isNameReferenced(Node node, String name, Predicate<Node> traverseChildrenPred) { [EOL]     return has(node, new MatchNameNode(name), traverseChildrenPred); [EOL] } <line_num>: 2664,2668
static boolean isNameReferenced(Node node, String name) { [EOL]     return isNameReferenced(node, name, Predicates.<Node>alwaysTrue()); [EOL] } <line_num>: 2673,2675
static int getNameReferenceCount(Node node, String name) { [EOL]     return getCount(node, new MatchNameNode(name), Predicates.<Node>alwaysTrue()); [EOL] } <line_num>: 2680,2683
static boolean has(Node node, Predicate<Node> pred, Predicate<Node> traverseChildrenPred) { [EOL]     if (pred.apply(node)) { [EOL]         return true; [EOL]     } [EOL]     if (!traverseChildrenPred.apply(node)) { [EOL]         return false; [EOL]     } [EOL]     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) { [EOL]         if (has(c, pred, traverseChildrenPred)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 2688,2706
static int getCount(Node n, Predicate<Node> pred, Predicate<Node> traverseChildrenPred) { [EOL]     int total = 0; [EOL]     if (pred.apply(n)) { [EOL]         total++; [EOL]     } [EOL]     if (traverseChildrenPred.apply(n)) { [EOL]         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { [EOL]             total += getCount(c, pred, traverseChildrenPred); [EOL]         } [EOL]     } [EOL]     return total; [EOL] } <line_num>: 2712,2727
void visit(Node node); <line_num>: 2734,2734
static void visitPreOrder(Node node, Visitor visitor, Predicate<Node> traverseChildrenPred) { [EOL]     visitor.visit(node); [EOL]     if (traverseChildrenPred.apply(node)) { [EOL]         for (Node c = node.getFirstChild(); c != null; c = c.getNext()) { [EOL]             visitPreOrder(c, visitor, traverseChildrenPred); [EOL]         } [EOL]     } [EOL] } <line_num>: 2741,2751
static void visitPostOrder(Node node, Visitor visitor, Predicate<Node> traverseChildrenPred) { [EOL]     if (traverseChildrenPred.apply(node)) { [EOL]         for (Node c = node.getFirstChild(); c != null; c = c.getNext()) { [EOL]             visitPostOrder(c, visitor, traverseChildrenPred); [EOL]         } [EOL]     } [EOL]     visitor.visit(node); [EOL] } <line_num>: 2757,2767
static boolean hasFinally(Node n) { [EOL]     Preconditions.checkArgument(n.isTry()); [EOL]     return n.getChildCount() == 3; [EOL] } <line_num>: 2772,2775
static Node getCatchBlock(Node n) { [EOL]     Preconditions.checkArgument(n.isTry()); [EOL]     return n.getFirstChild().getNext(); [EOL] } <line_num>: 2781,2784
static boolean hasCatchHandler(Node n) { [EOL]     Preconditions.checkArgument(n.isBlock()); [EOL]     return n.hasChildren() && n.getFirstChild().isCatch(); [EOL] } <line_num>: 2790,2793
public static Node getFunctionParameters(Node fnNode) { [EOL]     Preconditions.checkArgument(fnNode.isFunction()); [EOL]     return fnNode.getFirstChild().getNext(); [EOL] } <line_num>: 2799,2803
static boolean isConstantName(Node node) { [EOL]     return node.getBooleanProp(Node.IS_CONSTANT_NAME); [EOL] } <line_num>: 2822,2824
static boolean isConstantByConvention(CodingConvention convention, Node node, Node parent) { [EOL]     String name = node.getString(); [EOL]     if (parent.isGetProp() && node == parent.getLastChild()) { [EOL]         return convention.isConstantKey(name); [EOL]     } else if (isObjectLitKey(node, parent)) { [EOL]         return convention.isConstantKey(name); [EOL]     } else { [EOL]         return convention.isConstant(name); [EOL]     } [EOL] } <line_num>: 2827,2838
public static JSDocInfo getFunctionJSDocInfo(Node n) { [EOL]     Preconditions.checkState(n.isFunction()); [EOL]     JSDocInfo fnInfo = n.getJSDocInfo(); [EOL]     if (fnInfo == null && NodeUtil.isFunctionExpression(n)) { [EOL]         Node parent = n.getParent(); [EOL]         if (parent.isAssign()) { [EOL]             fnInfo = parent.getJSDocInfo(); [EOL]         } else if (parent.isName()) { [EOL]             fnInfo = parent.getParent().getJSDocInfo(); [EOL]         } [EOL]     } [EOL]     return fnInfo; [EOL] } <line_num>: 2843,2858
public static String getSourceName(Node n) { [EOL]     String sourceName = null; [EOL]     while (sourceName == null && n != null) { [EOL]         sourceName = n.getSourceFileName(); [EOL]         n = n.getParent(); [EOL]     } [EOL]     return sourceName; [EOL] } <line_num>: 2864,2871
public static StaticSourceFile getSourceFile(Node n) { [EOL]     StaticSourceFile sourceName = null; [EOL]     while (sourceName == null && n != null) { [EOL]         sourceName = n.getStaticSourceFile(); [EOL]         n = n.getParent(); [EOL]     } [EOL]     return sourceName; [EOL] } <line_num>: 2877,2884
public static InputId getInputId(Node n) { [EOL]     while (n != null && !n.isScript()) { [EOL]         n = n.getParent(); [EOL]     } [EOL]     return (n != null && n.isScript()) ? n.getInputId() : null; [EOL] } <line_num>: 2890,2896
static Node newCallNode(Node callTarget, Node... parameters) { [EOL]     boolean isFreeCall = !isGet(callTarget); [EOL]     Node call = IR.call(callTarget); [EOL]     call.putBooleanProp(Node.FREE_CALL, isFreeCall); [EOL]     for (Node parameter : parameters) { [EOL]         call.addChildToBack(parameter); [EOL]     } [EOL]     return call; [EOL] } <line_num>: 2901,2909
static boolean evaluatesToLocalValue(Node value) { [EOL]     return evaluatesToLocalValue(value, Predicates.<Node>alwaysFalse()); [EOL] } <line_num>: 2915,2917
static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { [EOL]     switch(value.getType()) { [EOL]         case Token.CAST: [EOL]             return evaluatesToLocalValue(value.getFirstChild(), locals); [EOL]         case Token.ASSIGN: [EOL]             return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals)); [EOL]         case Token.COMMA: [EOL]             return evaluatesToLocalValue(value.getLastChild(), locals); [EOL]         case Token.AND: [EOL]         case Token.OR: [EOL]             return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); [EOL]         case Token.HOOK: [EOL]             return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); [EOL]         case Token.INC: [EOL]         case Token.DEC: [EOL]             if (value.getBooleanProp(Node.INCRDECR_PROP)) { [EOL]                 return evaluatesToLocalValue(value.getFirstChild(), locals); [EOL]             } else { [EOL]                 return true; [EOL]             } [EOL]         case Token.THIS: [EOL]             return locals.apply(value); [EOL]         case Token.NAME: [EOL]             return isImmutableValue(value) || locals.apply(value); [EOL]         case Token.GETELEM: [EOL]         case Token.GETPROP: [EOL]             return locals.apply(value); [EOL]         case Token.CALL: [EOL]             return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value); [EOL]         case Token.NEW: [EOL]             return newHasLocalResult(value) || locals.apply(value); [EOL]         case Token.FUNCTION: [EOL]         case Token.REGEXP: [EOL]         case Token.ARRAYLIT: [EOL]         case Token.OBJECTLIT: [EOL]             return true; [EOL]         case Token.DELPROP: [EOL]         case Token.IN: [EOL]             return true; [EOL]         default: [EOL]             if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) { [EOL]                 return true; [EOL]             } [EOL]             throw new IllegalStateException("Unexpected expression node" + value + "\n parent:" + value.getParent()); [EOL]     } [EOL] } <line_num>: 2924,2990
private static Node getNthSibling(Node first, int index) { [EOL]     Node sibling = first; [EOL]     while (index != 0 && sibling != null) { [EOL]         sibling = sibling.getNext(); [EOL]         index--; [EOL]     } [EOL]     return sibling; [EOL] } <line_num>: 2997,3004
static Node getArgumentForFunction(Node function, int index) { [EOL]     Preconditions.checkState(function.isFunction()); [EOL]     return getNthSibling(function.getFirstChild().getNext().getFirstChild(), index); [EOL] } <line_num>: 3010,3014
static Node getArgumentForCallOrNew(Node call, int index) { [EOL]     Preconditions.checkState(isCallOrNew(call)); [EOL]     return getNthSibling(call.getFirstChild().getNext(), index); [EOL] } <line_num>: 3020,3024
static boolean isCallOrNewTarget(Node target) { [EOL]     Node parent = target.getParent(); [EOL]     return parent != null && NodeUtil.isCallOrNew(parent) && parent.getFirstChild() == target; [EOL] } <line_num>: 3029,3034
private static boolean isToStringMethodCall(Node call) { [EOL]     Node getNode = call.getFirstChild(); [EOL]     if (isGet(getNode)) { [EOL]         Node propNode = getNode.getLastChild(); [EOL]         return propNode.isString() && "toString".equals(propNode.getString()); [EOL]     } [EOL]     return false; [EOL] } <line_num>: 3036,3043
static JSDocInfo getBestJSDocInfo(Node n) { [EOL]     JSDocInfo info = n.getJSDocInfo(); [EOL]     if (info == null) { [EOL]         Node parent = n.getParent(); [EOL]         if (parent == null) { [EOL]             return null; [EOL]         } [EOL]         if (parent.isName()) { [EOL]             return getBestJSDocInfo(parent); [EOL]         } else if (parent.isAssign()) { [EOL]             return parent.getJSDocInfo(); [EOL]         } else if (isObjectLitKey(parent, parent.getParent())) { [EOL]             return parent.getJSDocInfo(); [EOL]         } else if (parent.isFunction()) { [EOL]             return parent.getJSDocInfo(); [EOL]         } else if (parent.isVar() && parent.hasOneChild()) { [EOL]             return parent.getJSDocInfo(); [EOL]         } else if ((parent.isHook() && parent.getFirstChild() != n) || parent.isOr() || parent.isAnd() || (parent.isComma() && parent.getFirstChild() != n)) { [EOL]             return getBestJSDocInfo(parent); [EOL]         } else if (parent.isCast()) { [EOL]             return parent.getJSDocInfo(); [EOL]         } [EOL]     } [EOL]     return info; [EOL] } <line_num>: 3046,3074
static Node getBestLValue(Node n) { [EOL]     Node parent = n.getParent(); [EOL]     boolean isFunctionDeclaration = isFunctionDeclaration(n); [EOL]     if (isFunctionDeclaration) { [EOL]         return n.getFirstChild(); [EOL]     } else if (parent.isName()) { [EOL]         return parent; [EOL]     } else if (parent.isAssign()) { [EOL]         return parent.getFirstChild(); [EOL]     } else if (isObjectLitKey(parent, parent.getParent())) { [EOL]         return parent; [EOL]     } else if ((parent.isHook() && parent.getFirstChild() != n) || parent.isOr() || parent.isAnd() || (parent.isComma() && parent.getFirstChild() != n)) { [EOL]         return getBestLValue(parent); [EOL]     } else if (parent.isCast()) { [EOL]         return getBestLValue(parent); [EOL]     } [EOL]     return null; [EOL] } <line_num>: 3077,3098
static Node getRValueOfLValue(Node n) { [EOL]     Node parent = n.getParent(); [EOL]     switch(parent.getType()) { [EOL]         case Token.ASSIGN: [EOL]             return n.getNext(); [EOL]         case Token.VAR: [EOL]             return n.getFirstChild(); [EOL]         case Token.FUNCTION: [EOL]             return parent; [EOL]     } [EOL]     return null; [EOL] } <line_num>: 3101,3112
static Node getBestLValueOwner(@Nullable Node lValue) { [EOL]     if (lValue == null || lValue.getParent() == null) { [EOL]         return null; [EOL]     } [EOL]     if (isObjectLitKey(lValue, lValue.getParent())) { [EOL]         return getBestLValue(lValue.getParent()); [EOL]     } else if (isGet(lValue)) { [EOL]         return lValue.getFirstChild(); [EOL]     } [EOL]     return null; [EOL] } <line_num>: 3115,3126
static String getBestLValueName(@Nullable Node lValue) { [EOL]     if (lValue == null || lValue.getParent() == null) { [EOL]         return null; [EOL]     } [EOL]     if (isObjectLitKey(lValue, lValue.getParent())) { [EOL]         Node owner = getBestLValue(lValue.getParent()); [EOL]         if (owner != null) { [EOL]             String ownerName = getBestLValueName(owner); [EOL]             if (ownerName != null) { [EOL]                 return ownerName + "." + getObjectLitKeyName(lValue); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     return lValue.getQualifiedName(); [EOL] } <line_num>: 3129,3144
static boolean isExpressionResultUsed(Node expr) { [EOL]     Node parent = expr.getParent(); [EOL]     switch(parent.getType()) { [EOL]         case Token.BLOCK: [EOL]         case Token.EXPR_RESULT: [EOL]             return false; [EOL]         case Token.CAST: [EOL]             return isExpressionResultUsed(parent); [EOL]         case Token.HOOK: [EOL]         case Token.AND: [EOL]         case Token.OR: [EOL]             return (expr == parent.getFirstChild()) ? true : isExpressionResultUsed(parent); [EOL]         case Token.COMMA: [EOL]             Node gramps = parent.getParent(); [EOL]             if (gramps.isCall() && parent == gramps.getFirstChild()) { [EOL]                 if (expr == parent.getFirstChild() && parent.getChildCount() == 2 && expr.getNext().isName() && "eval".equals(expr.getNext().getString())) { [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]             return (expr == parent.getFirstChild()) ? false : isExpressionResultUsed(parent); [EOL]         case Token.FOR: [EOL]             if (!NodeUtil.isForIn(parent)) { [EOL]                 return (parent.getChildAtIndex(1) == expr); [EOL]             } [EOL]             break; [EOL]     } [EOL]     return true; [EOL] } <line_num>: 3149,3190
static boolean isExecutedExactlyOnce(Node n) { [EOL]     inspect: do { [EOL]         Node parent = n.getParent(); [EOL]         switch(parent.getType()) { [EOL]             case Token.IF: [EOL]             case Token.HOOK: [EOL]             case Token.AND: [EOL]             case Token.OR: [EOL]                 if (parent.getFirstChild() != n) { [EOL]                     return false; [EOL]                 } [EOL]                 continue inspect; [EOL]             case Token.FOR: [EOL]                 if (NodeUtil.isForIn(parent)) { [EOL]                     if (parent.getChildAtIndex(1) != n) { [EOL]                         return false; [EOL]                     } [EOL]                 } else { [EOL]                     if (parent.getFirstChild() != n) { [EOL]                         return false; [EOL]                     } [EOL]                 } [EOL]                 continue inspect; [EOL]             case Token.WHILE: [EOL]             case Token.DO: [EOL]                 return false; [EOL]             case Token.TRY: [EOL]                 if (!hasFinally(parent) || parent.getLastChild() != n) { [EOL]                     return false; [EOL]                 } [EOL]                 continue inspect; [EOL]             case Token.CASE: [EOL]             case Token.DEFAULT_CASE: [EOL]                 return false; [EOL]             case Token.SCRIPT: [EOL]             case Token.FUNCTION: [EOL]                 break inspect; [EOL]         } [EOL]     } while ((n = n.getParent()) != null); [EOL]     return true; [EOL] } <line_num>: 3197,3241
static Node booleanNode(boolean value) { [EOL]     return value ? IR.trueNode() : IR.falseNode(); [EOL] } <line_num>: 3246,3248
static Node numberNode(double value, Node srcref) { [EOL]     Node result; [EOL]     if (Double.isNaN(value)) { [EOL]         result = IR.name("NaN"); [EOL]     } else if (value == Double.POSITIVE_INFINITY) { [EOL]         result = IR.name("Infinity"); [EOL]     } else if (value == Double.NEGATIVE_INFINITY) { [EOL]         result = IR.neg(IR.name("Infinity")); [EOL]     } else { [EOL]         result = IR.number(value); [EOL]     } [EOL]     if (srcref != null) { [EOL]         result.srcrefTree(srcref); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 3253,3268
static boolean isNaN(Node n) { [EOL]     if ((n.isName() && n.getString().equals("NaN")) || (n.getType() == Token.DIV && n.getFirstChild().isNumber() && n.getFirstChild().getDouble() == 0 && n.getLastChild().isNumber() && n.getLastChild().getDouble() == 0)) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 3270,3278
