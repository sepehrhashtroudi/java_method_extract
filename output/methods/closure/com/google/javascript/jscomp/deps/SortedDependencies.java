public SortedDependencies(List<INPUT> inputs) throws CircularDependencyException { [EOL]     this.inputs = Lists.newArrayList(inputs); [EOL]     noProvides = Lists.newArrayList(); [EOL]     for (INPUT input : inputs) { [EOL]         Collection<String> currentProvides = input.getProvides(); [EOL]         if (currentProvides.isEmpty()) { [EOL]             noProvides.add(input); [EOL]         } [EOL]         for (String provide : currentProvides) { [EOL]             provideMap.put(provide, input); [EOL]         } [EOL]     } [EOL]     final Multimap<INPUT, INPUT> deps = HashMultimap.create(); [EOL]     for (INPUT input : inputs) { [EOL]         for (String req : input.getRequires()) { [EOL]             INPUT dep = provideMap.get(req); [EOL]             if (dep != null && dep != input) { [EOL]                 deps.put(input, dep); [EOL]             } [EOL]         } [EOL]     } [EOL]     sortedList = topologicalStableSort(inputs, deps); [EOL]     if (sortedList.size() < inputs.size()) { [EOL]         List<INPUT> subGraph = Lists.newArrayList(inputs); [EOL]         subGraph.removeAll(sortedList); [EOL]         throw new CircularDependencyException(cycleToString(findCycle(subGraph, deps))); [EOL]     } [EOL] } <line_num>: 64,108
CircularDependencyException(String message) { [EOL]     super(message); [EOL] } <line_num>: 291,293
MissingProvideException(String provide) { [EOL]     super(provide); [EOL] } <line_num>: 297,299
public INPUT getInputProviding(String symbol) throws MissingProvideException { [EOL]     if (provideMap.containsKey(symbol)) { [EOL]         return provideMap.get(symbol); [EOL]     } [EOL]     throw new MissingProvideException(symbol); [EOL] } <line_num>: 115,121
public INPUT maybeGetInputProviding(String symbol) { [EOL]     return provideMap.get(symbol); [EOL] } <line_num>: 126,128
private List<INPUT> findCycle(List<INPUT> subGraph, Multimap<INPUT, INPUT> deps) { [EOL]     return findCycle(subGraph.get(0), Sets.<INPUT>newHashSet(subGraph), deps, Sets.<INPUT>newHashSet()); [EOL] } <line_num>: 135,139
private List<INPUT> findCycle(INPUT current, Set<INPUT> subGraph, Multimap<INPUT, INPUT> deps, Set<INPUT> covered) { [EOL]     if (covered.add(current)) { [EOL]         List<INPUT> cycle = findCycle(findRequireInSubGraphOrFail(current, subGraph), subGraph, deps, covered); [EOL]         if (cycle.get(0) != cycle.get(cycle.size() - 1)) { [EOL]             cycle.add(current); [EOL]         } [EOL]         return cycle; [EOL]     } else { [EOL]         List<INPUT> cycle = Lists.<INPUT>newArrayList(); [EOL]         cycle.add(current); [EOL]         return cycle; [EOL]     } [EOL] } <line_num>: 141,163
private INPUT findRequireInSubGraphOrFail(INPUT input, Set<INPUT> subGraph) { [EOL]     for (String symbol : input.getRequires()) { [EOL]         INPUT candidate = provideMap.get(symbol); [EOL]         if (subGraph.contains(candidate)) { [EOL]             return candidate; [EOL]         } [EOL]     } [EOL]     throw new IllegalStateException("no require found in subgraph"); [EOL] } <line_num>: 165,173
private String cycleToString(List<INPUT> cycle) { [EOL]     List<String> symbols = Lists.newArrayList(); [EOL]     for (int i = cycle.size() - 1; i >= 0; i--) { [EOL]         symbols.add(cycle.get(i).getProvides().iterator().next()); [EOL]     } [EOL]     symbols.add(symbols.get(0)); [EOL]     return Joiner.on(" -> ").join(symbols); [EOL] } <line_num>: 178,185
public List<INPUT> getSortedList() { [EOL]     return Collections.<INPUT>unmodifiableList(sortedList); [EOL] } <line_num>: 187,189
public List<INPUT> getSortedDependenciesOf(List<INPUT> roots) { [EOL]     return getDependenciesOf(roots, true); [EOL] } <line_num>: 197,199
public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted) { [EOL]     Preconditions.checkArgument(inputs.containsAll(roots)); [EOL]     Set<INPUT> included = Sets.newHashSet(); [EOL]     Deque<INPUT> worklist = new ArrayDeque<INPUT>(roots); [EOL]     while (!worklist.isEmpty()) { [EOL]         INPUT current = worklist.pop(); [EOL]         if (included.add(current)) { [EOL]             for (String req : current.getRequires()) { [EOL]                 INPUT dep = provideMap.get(req); [EOL]                 if (dep != null) { [EOL]                     worklist.add(dep); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     ImmutableList.Builder<INPUT> builder = ImmutableList.builder(); [EOL]     for (INPUT current : (sorted ? sortedList : inputs)) { [EOL]         if (included.contains(current)) { [EOL]             builder.add(current); [EOL]         } [EOL]     } [EOL]     return builder.build(); [EOL] } <line_num>: 210,233
public List<INPUT> getInputsWithoutProvides() { [EOL]     return Collections.<INPUT>unmodifiableList(noProvides); [EOL] } <line_num>: 235,237
@Override [EOL] public int compare(T a, T b) { [EOL]     return originalIndex.get(a).intValue() - originalIndex.get(b).intValue(); [EOL] } <line_num>: 254,258
private static <T> List<T> topologicalStableSort(List<T> items, Multimap<T, T> deps) { [EOL]     if (items.size() == 0) { [EOL]         return Lists.newArrayList(); [EOL]     } [EOL]     final Map<T, Integer> originalIndex = Maps.newHashMap(); [EOL]     for (int i = 0; i < items.size(); i++) { [EOL]         originalIndex.put(items.get(i), i); [EOL]     } [EOL]     PriorityQueue<T> inDegreeZero = new PriorityQueue<T>(items.size(), new Comparator<T>() { [EOL]  [EOL]         @Override [EOL]         public int compare(T a, T b) { [EOL]             return originalIndex.get(a).intValue() - originalIndex.get(b).intValue(); [EOL]         } [EOL]     }); [EOL]     List<T> result = Lists.newArrayList(); [EOL]     Multiset<T> inDegree = HashMultiset.create(); [EOL]     Multimap<T, T> reverseDeps = ArrayListMultimap.create(); [EOL]     Multimaps.invertFrom(deps, reverseDeps); [EOL]     for (T item : items) { [EOL]         Collection<T> itemDeps = deps.get(item); [EOL]         inDegree.add(item, itemDeps.size()); [EOL]         if (itemDeps.isEmpty()) { [EOL]             inDegreeZero.add(item); [EOL]         } [EOL]     } [EOL]     while (!inDegreeZero.isEmpty()) { [EOL]         T item = inDegreeZero.remove(); [EOL]         result.add(item); [EOL]         for (T inWaiting : reverseDeps.get(item)) { [EOL]             inDegree.remove(inWaiting, 1); [EOL]             if (inDegree.count(inWaiting) == 0) { [EOL]                 inDegreeZero.add(inWaiting); [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] } <line_num>: 239,288
