public DepsGenerator(Collection<SourceFile> deps, Collection<SourceFile> srcs, InclusionStrategy mergeStrategy, String closurePathAbs, ErrorManager errorManager) { [EOL]     this.deps = deps; [EOL]     this.srcs = srcs; [EOL]     this.mergeStrategy = mergeStrategy; [EOL]     this.closurePathAbs = closurePathAbs; [EOL]     this.errorManager = errorManager; [EOL] } <line_num>: 94,105
public String computeDependencyCalls() throws IOException { [EOL]     Map<String, DependencyInfo> depsFiles = parseDepsFiles(); [EOL]     logger.fine("preparsedFiles: " + depsFiles); [EOL]     Map<String, DependencyInfo> jsFiles = parseSources(depsFiles.keySet()); [EOL]     if (errorManager.getErrorCount() > 0) { [EOL]         return null; [EOL]     } [EOL]     cleanUpDuplicatedFiles(depsFiles, jsFiles); [EOL]     validateDependencies(depsFiles.values(), jsFiles.values()); [EOL]     if (errorManager.getErrorCount() > 0) { [EOL]         return null; [EOL]     } [EOL]     ByteArrayOutputStream output = new ByteArrayOutputStream(); [EOL]     writeDepsContent(depsFiles, jsFiles, new PrintStream(output)); [EOL]     return new String(output.toByteArray()); [EOL] } <line_num>: 113,138
protected void cleanUpDuplicatedFiles(Map<String, DependencyInfo> depsFiles, Map<String, DependencyInfo> jsFiles) { [EOL]     Set<String> depsPathsCopy = Sets.newHashSet(depsFiles.keySet()); [EOL]     for (String path : depsPathsCopy) { [EOL]         if (mergeStrategy != InclusionStrategy.WHEN_IN_SRCS) { [EOL]             jsFiles.remove(path); [EOL]         } [EOL]     } [EOL]     for (String path : jsFiles.keySet()) { [EOL]         depsFiles.remove(path); [EOL]     } [EOL] } <line_num>: 147,162
private void validateDependencies(Iterable<DependencyInfo> preparsedFileDepedencies, Iterable<DependencyInfo> parsedFileDependencies) { [EOL]     Map<String, DependencyInfo> providesMap = Maps.newHashMap(); [EOL]     addToProvideMap(preparsedFileDepedencies, providesMap); [EOL]     addToProvideMap(parsedFileDependencies, providesMap); [EOL]     for (DependencyInfo depInfo : parsedFileDependencies) { [EOL]         List<String> requires = Lists.newArrayList(depInfo.getRequires()); [EOL]         for (int i = 0, l = requires.size(); i < l; ++i) { [EOL]             String namespace = requires.get(i); [EOL]             if (requires.subList(i + 1, l).contains(namespace)) { [EOL]                 reportDuplicateRequire(namespace, depInfo); [EOL]             } [EOL]             DependencyInfo provider = providesMap.get(namespace); [EOL]             if (provider == null) { [EOL]                 reportUndefinedNamespace(namespace, depInfo); [EOL]             } else if (provider == depInfo) { [EOL]                 reportSameFile(namespace, depInfo); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 175,200
private void reportSameFile(String namespace, DependencyInfo depInfo) { [EOL]     errorManager.report(CheckLevel.WARNING, JSError.make(depInfo.getName(), -1, -1, SAME_FILE_WARNING, namespace)); [EOL] } <line_num>: 202,206
private void reportUndefinedNamespace(String namespace, DependencyInfo depInfo) { [EOL]     errorManager.report(CheckLevel.ERROR, JSError.make(depInfo.getName(), -1, -1, NEVER_PROVIDED_ERROR, namespace)); [EOL] } <line_num>: 208,213
private void reportDuplicateProvide(String namespace, DependencyInfo firstDep, DependencyInfo secondDep) { [EOL]     if (firstDep == secondDep) { [EOL]         errorManager.report(CheckLevel.WARNING, JSError.make(firstDep.getName(), -1, -1, DUPE_PROVIDES_WARNING, namespace)); [EOL]     } else { [EOL]         errorManager.report(CheckLevel.ERROR, JSError.make(secondDep.getName(), -1, -1, MULTIPLE_PROVIDES_ERROR, namespace, firstDep.getName())); [EOL]     } [EOL] } <line_num>: 215,226
private void reportDuplicateRequire(String namespace, DependencyInfo depInfo) { [EOL]     errorManager.report(CheckLevel.WARNING, JSError.make(depInfo.getName(), -1, -1, DUPE_REQUIRE_WARNING, namespace)); [EOL] } <line_num>: 228,233
private void reportNoDepsInDepsFile(String filePath) { [EOL]     errorManager.report(CheckLevel.WARNING, JSError.make(filePath, -1, -1, NO_DEPS_WARNING)); [EOL] } <line_num>: 235,238
private void addToProvideMap(Iterable<DependencyInfo> depInfos, Map<String, DependencyInfo> providesMap) { [EOL]     for (DependencyInfo depInfo : depInfos) { [EOL]         for (String provide : depInfo.getProvides()) { [EOL]             DependencyInfo prevValue = providesMap.put(provide, depInfo); [EOL]             if (prevValue != null) { [EOL]                 reportDuplicateProvide(provide, prevValue, depInfo); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 244,255
protected DepsFileParser createDepsFileParser() { [EOL]     DepsFileParser depsParser = new DepsFileParser(errorManager); [EOL]     depsParser.setShortcutMode(true); [EOL]     return depsParser; [EOL] } <line_num>: 257,261
protected boolean shouldSkipDepsFile(SourceFile file) { [EOL]     return false; [EOL] } <line_num>: 266,268
private Map<String, DependencyInfo> parseDepsFiles() throws IOException { [EOL]     DepsFileParser depsParser = createDepsFileParser(); [EOL]     Map<String, DependencyInfo> depsFiles = Maps.newHashMap(); [EOL]     for (SourceFile file : deps) { [EOL]         if (!shouldSkipDepsFile(file)) { [EOL]             List<DependencyInfo> depInfos = depsParser.parseFileReader(file.getName(), file.getCodeReader()); [EOL]             if (depInfos.isEmpty()) { [EOL]                 reportNoDepsInDepsFile(file.getName()); [EOL]             } else { [EOL]                 for (DependencyInfo info : depInfos) { [EOL]                     depsFiles.put(info.getPathRelativeToClosureBase(), info); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     for (SourceFile src : srcs) { [EOL]         if ((new File(src.getName())).exists() && !shouldSkipDepsFile(src)) { [EOL]             List<DependencyInfo> srcInfos = depsParser.parseFileReader(src.getName(), src.getCodeReader()); [EOL]             for (DependencyInfo info : srcInfos) { [EOL]                 depsFiles.put(info.getPathRelativeToClosureBase(), info); [EOL]             } [EOL]         } [EOL]     } [EOL]     return depsFiles; [EOL] } <line_num>: 274,307
private Map<String, DependencyInfo> parseSources(Set<String> preparsedFiles) throws IOException { [EOL]     Map<String, DependencyInfo> parsedFiles = Maps.newHashMap(); [EOL]     JsFileParser jsParser = new JsFileParser(errorManager); [EOL]     for (SourceFile file : srcs) { [EOL]         String closureRelativePath = PathUtil.makeRelative(closurePathAbs, PathUtil.makeAbsolute(file.getName())); [EOL]         logger.fine("Closure-relative path: " + closureRelativePath); [EOL]         if (InclusionStrategy.WHEN_IN_SRCS == mergeStrategy || !preparsedFiles.contains(closureRelativePath)) { [EOL]             DependencyInfo depInfo = jsParser.parseFile(file.getName(), closureRelativePath, file.getCode()); [EOL]             file.clearCachedSource(); [EOL]             parsedFiles.put(closureRelativePath, depInfo); [EOL]         } [EOL]     } [EOL]     return parsedFiles; [EOL] } <line_num>: 317,342
@Override [EOL] public String apply(DependencyInfo from) { [EOL]     return from.getName(); [EOL] } <line_num>: 363,366
private void writeDepsContent(Map<String, DependencyInfo> depsFiles, Map<String, DependencyInfo> jsFiles, PrintStream out) throws IOException { [EOL]     writeDepInfos(out, jsFiles.values()); [EOL]     if (mergeStrategy == InclusionStrategy.ALWAYS) { [EOL]         Multimap<String, DependencyInfo> infosIndex = Multimaps.index(depsFiles.values(), new Function<DependencyInfo, String>() { [EOL]  [EOL]             @Override [EOL]             public String apply(DependencyInfo from) { [EOL]                 return from.getName(); [EOL]             } [EOL]         }); [EOL]         for (String depsPath : infosIndex.keySet()) { [EOL]             String path = formatPathToDepsFile(depsPath); [EOL]             out.println("\n// Included from: " + path); [EOL]             writeDepInfos(out, infosIndex.get(depsPath)); [EOL]         } [EOL]     } [EOL] } <line_num>: 350,375
protected String formatPathToDepsFile(String path) { [EOL]     return path; [EOL] } <line_num>: 380,382
private void writeDepInfos(PrintStream out, Collection<DependencyInfo> depInfos) throws IOException { [EOL]     for (DependencyInfo depInfo : depInfos) { [EOL]         Collection<String> provides = depInfo.getProvides(); [EOL]         Collection<String> requires = depInfo.getRequires(); [EOL]         out.print("goog.addDependency('" + depInfo.getPathRelativeToClosureBase() + "', "); [EOL]         writeJsArray(out, provides); [EOL]         out.print(", "); [EOL]         writeJsArray(out, requires); [EOL]         out.println(");"); [EOL]     } [EOL] } <line_num>: 388,406
private static void writeJsArray(PrintStream out, Collection<String> values) { [EOL]     if (values.isEmpty()) { [EOL]         out.print("[]"); [EOL]     } else { [EOL]         out.print("['"); [EOL]         out.print(Joiner.on("', '").join(values)); [EOL]         out.print("']"); [EOL]     } [EOL] } <line_num>: 412,420
static List<SourceFile> createSourceFilesFromPaths(Collection<String> paths) { [EOL]     List<SourceFile> files = Lists.newArrayList(); [EOL]     for (String path : paths) { [EOL]         files.add(SourceFile.fromFile(path)); [EOL]     } [EOL]     return files; [EOL] } <line_num>: 422,429
static List<SourceFile> createSourceFilesFromPaths(String... paths) { [EOL]     return createSourceFilesFromPaths(Arrays.asList(paths)); [EOL] } <line_num>: 431,434
