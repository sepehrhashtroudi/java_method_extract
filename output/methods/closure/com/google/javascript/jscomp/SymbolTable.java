SymbolTable(JSTypeRegistry registry) { [EOL]     this.registry = registry; [EOL] } <line_num>: 132,134
Symbol(String name, JSType type, boolean inferred, SymbolScope scope) { [EOL]     super(name, type, inferred); [EOL]     this.scope = scope; [EOL] } <line_num>: 1062,1065
Reference(Symbol symbol, Node node) { [EOL]     super(symbol, node); [EOL] } <line_num>: 1153,1155
SymbolScope(Node rootNode, @Nullable SymbolScope parent, JSType typeOfThis, Symbol mySymbol) { [EOL]     this.rootNode = rootNode; [EOL]     this.parent = parent; [EOL]     this.typeOfThis = typeOfThis; [EOL]     this.scopeDepth = parent == null ? 0 : (parent.getScopeDepth() + 1); [EOL]     this.mySymbol = mySymbol; [EOL] } <line_num>: 1171,1181
PropertyRefCollector(AbstractCompiler compiler) { [EOL]     this.compiler = compiler; [EOL] } <line_num>: 1293,1295
ThisRefCollector(AbstractCompiler compiler) { [EOL]     this.compiler = compiler; [EOL] } <line_num>: 1425,1427
private JSDocInfoCollector(JSTypeRegistry registry) { [EOL]     this.typeRegistry = registry; [EOL] } <line_num>: 1516,1518
@Override [EOL] public Iterable<Reference> getReferences(Symbol symbol) { [EOL]     return Collections.unmodifiableCollection(symbol.references.values()); [EOL] } <line_num>: 136,139
public List<Reference> getReferenceList(Symbol symbol) { [EOL]     return ImmutableList.copyOf(symbol.references.values()); [EOL] } <line_num>: 141,143
@Override [EOL] public Iterable<Symbol> getAllSymbols() { [EOL]     return Collections.unmodifiableCollection(symbols.values()); [EOL] } <line_num>: 145,148
public List<Symbol> getAllSymbolsSorted() { [EOL]     List<Symbol> sortedSymbols = Lists.newArrayList(symbols.values()); [EOL]     Collections.sort(sortedSymbols, getNaturalSymbolOrdering()); [EOL]     return sortedSymbols; [EOL] } <line_num>: 154,158
public Ordering<Symbol> getNaturalSymbolOrdering() { [EOL]     return SYMBOL_ORDERING; [EOL] } <line_num>: 167,169
@Override [EOL] public SymbolScope getScope(Symbol slot) { [EOL]     return slot.scope; [EOL] } <line_num>: 171,174
public Collection<JSDocInfo> getAllJSDocInfo() { [EOL]     return Collections.unmodifiableList(docInfos); [EOL] } <line_num>: 176,178
public Symbol declareInferredSymbol(SymbolScope scope, String name, Node declNode) { [EOL]     return declareSymbol(name, null, true, scope, declNode, null); [EOL] } <line_num>: 184,187
public SymbolScope getEnclosingScope(Node n) { [EOL]     Node current = n.getParent(); [EOL]     if (n.isName() && n.getParent().isFunction()) { [EOL]         current = current.getParent(); [EOL]     } [EOL]     for (; current != null; current = current.getParent()) { [EOL]         if (scopes.containsKey(current)) { [EOL]             return scopes.get(current); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 194,207
public Symbol getParameterInFunction(Symbol sym, String paramName) { [EOL]     SymbolScope scope = getScopeInFunction(sym); [EOL]     if (scope != null) { [EOL]         Symbol param = scope.getSlot(paramName); [EOL]         if (param != null && param.scope == scope) { [EOL]             return param; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 222,231
private SymbolScope getScopeInFunction(Symbol sym) { [EOL]     FunctionType type = sym.getFunctionType(); [EOL]     if (type == null) { [EOL]         return null; [EOL]     } [EOL]     Node functionNode = type.getSource(); [EOL]     if (functionNode == null) { [EOL]         return null; [EOL]     } [EOL]     return scopes.get(functionNode); [EOL] } <line_num>: 233,245
public Symbol getSymbolForScope(SymbolScope scope) { [EOL]     if (scope.getSymbolForScope() == null) { [EOL]         scope.setSymbolForScope(findSymbolForScope(scope)); [EOL]     } [EOL]     return scope.getSymbolForScope(); [EOL] } <line_num>: 252,257
private Symbol findSymbolForScope(SymbolScope scope) { [EOL]     Node rootNode = scope.getRootNode(); [EOL]     if (rootNode.getParent() == null) { [EOL]         return globalScope.getSlot(GLOBAL_THIS); [EOL]     } [EOL]     if (!rootNode.isFunction()) { [EOL]         return null; [EOL]     } [EOL]     String name = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(rootNode)); [EOL]     return name == null ? null : scope.getParentScope().getQualifiedSlot(name); [EOL] } <line_num>: 265,278
public Iterable<Symbol> getAllSymbolsForTypeOf(Symbol sym) { [EOL]     return getAllSymbolsForType(sym.getType()); [EOL] } <line_num>: 288,290
public SymbolScope getGlobalScope() { [EOL]     return globalScope; [EOL] } <line_num>: 295,297
public Symbol getSymbolDeclaredBy(FunctionType fn) { [EOL]     Preconditions.checkState(fn.isConstructor() || fn.isInterface()); [EOL]     ObjectType instanceType = fn.getInstanceType(); [EOL]     return getSymbolForName(fn.getSource(), instanceType.getReferenceName()); [EOL] } <line_num>: 302,306
public Symbol getSymbolDeclaredBy(EnumType enumType) { [EOL]     return getSymbolForName(null, enumType.getElementsType().getReferenceName()); [EOL] } <line_num>: 311,314
public Symbol getSymbolForInstancesOf(Symbol sym) { [EOL]     FunctionType fn = sym.getFunctionType(); [EOL]     if (fn != null && fn.isNominalConstructor()) { [EOL]         return getSymbolForInstancesOf(fn); [EOL]     } [EOL]     return null; [EOL] } <line_num>: 320,326
public Symbol getSymbolForInstancesOf(FunctionType fn) { [EOL]     Preconditions.checkState(fn.isConstructor() || fn.isInterface()); [EOL]     ObjectType pType = fn.getPrototype(); [EOL]     return getSymbolForName(fn.getSource(), pType.getReferenceName()); [EOL] } <line_num>: 331,335
private Symbol getSymbolForName(Node source, String name) { [EOL]     if (name == null || globalScope == null) { [EOL]         return null; [EOL]     } [EOL]     SymbolScope scope = source == null ? globalScope : getEnclosingScope(source); [EOL]     return scope == null ? null : scope.getQualifiedSlot(name); [EOL] } <line_num>: 337,348
public List<Symbol> getAllSymbolsForType(JSType type) { [EOL]     if (type == null) { [EOL]         return ImmutableList.of(); [EOL]     } [EOL]     UnionType unionType = type.toMaybeUnionType(); [EOL]     if (unionType != null) { [EOL]         List<Symbol> result = Lists.newArrayListWithExpectedSize(2); [EOL]         for (JSType alt : unionType.getAlternates()) { [EOL]             Symbol altSym = getSymbolForTypeHelper(alt, true); [EOL]             if (altSym != null) { [EOL]                 result.add(altSym); [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } [EOL]     Symbol result = getSymbolForTypeHelper(type, true); [EOL]     return result == null ? ImmutableList.<Symbol>of() : ImmutableList.of(result); [EOL] } <line_num>: 356,376
private Symbol getSymbolForTypeHelper(JSType type, boolean linkToCtor) { [EOL]     if (type == null) { [EOL]         return null; [EOL]     } [EOL]     if (type.isGlobalThisType()) { [EOL]         return globalScope.getSlot(GLOBAL_THIS); [EOL]     } else if (type.isNominalConstructor()) { [EOL]         return linkToCtor ? globalScope.getSlot("Function") : getSymbolDeclaredBy(type.toMaybeFunctionType()); [EOL]     } else if (type.isFunctionPrototypeType()) { [EOL]         FunctionType ownerFn = ((ObjectType) type).getOwnerFunction(); [EOL]         if (!ownerFn.isConstructor() && !ownerFn.isInterface()) { [EOL]             return null; [EOL]         } [EOL]         return linkToCtor ? getSymbolDeclaredBy(ownerFn) : getSymbolForInstancesOf(ownerFn); [EOL]     } else if (type.isInstanceType()) { [EOL]         FunctionType ownerFn = ((ObjectType) type).getConstructor(); [EOL]         return linkToCtor ? getSymbolDeclaredBy(ownerFn) : getSymbolForInstancesOf(ownerFn); [EOL]     } else if (type.isFunctionType()) { [EOL]         return linkToCtor ? globalScope.getSlot("Function") : globalScope.getQualifiedSlot("Function.prototype"); [EOL]     } else if (type.autoboxesTo() != null) { [EOL]         return getSymbolForTypeHelper(type.autoboxesTo(), linkToCtor); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] } <line_num>: 389,422
public String toDebugString() { [EOL]     StringBuilder builder = new StringBuilder(); [EOL]     for (Symbol symbol : getAllSymbols()) { [EOL]         toDebugString(builder, symbol); [EOL]     } [EOL]     return builder.toString(); [EOL] } <line_num>: 424,430
private void toDebugString(StringBuilder builder, Symbol symbol) { [EOL]     SymbolScope scope = symbol.scope; [EOL]     if (scope.isGlobalScope()) { [EOL]         builder.append(String.format("'%s' : in global scope:\n", symbol.getName())); [EOL]     } else if (scope.getRootNode() != null) { [EOL]         builder.append(String.format("'%s' : in scope %s:%d\n", symbol.getName(), scope.getRootNode().getSourceFileName(), scope.getRootNode().getLineno())); [EOL]     } else if (scope.getSymbolForScope() != null) { [EOL]         builder.append(String.format("'%s' : in scope %s\n", symbol.getName(), scope.getSymbolForScope().getName())); [EOL]     } else { [EOL]         builder.append(String.format("'%s' : in unknown scope\n", symbol.getName())); [EOL]     } [EOL]     int refCount = 0; [EOL]     for (Reference ref : getReferences(symbol)) { [EOL]         builder.append(String.format("  Ref %d: %s:%d\n", refCount, ref.getNode().getSourceFileName(), ref.getNode().getLineno())); [EOL]         refCount++; [EOL]     } [EOL] } <line_num>: 432,461
<S extends StaticScope<JSType>> void addScopes(Collection<S> scopes) { [EOL]     for (S scope : scopes) { [EOL]         createScopeFrom(scope); [EOL]     } [EOL] } <line_num>: 467,472
@Override [EOL] public void enterScope(NodeTraversal t) { [EOL]     createScopeFrom(t.getScope()); [EOL] } <line_num>: 480,483
@Override [EOL] public void visit(NodeTraversal t, Node n, Node p) { [EOL] } <line_num>: 485,486
void findScopes(AbstractCompiler compiler, Node externs, Node root) { [EOL]     NodeTraversal.traverseRoots(compiler, Lists.newArrayList(externs, root), new NodeTraversal.AbstractScopedCallback() { [EOL]  [EOL]         @Override [EOL]         public void enterScope(NodeTraversal t) { [EOL]             createScopeFrom(t.getScope()); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void visit(NodeTraversal t, Node n, Node p) { [EOL]         } [EOL]     }); [EOL] } <line_num>: 475,488
public Collection<SymbolScope> getAllScopes() { [EOL]     return Collections.unmodifiableCollection(scopes.values()); [EOL] } <line_num>: 491,493
public void addAnonymousFunctions() { [EOL]     TreeSet<SymbolScope> scopes = Sets.newTreeSet(LEXICAL_SCOPE_ORDERING); [EOL]     for (SymbolScope scope : getAllScopes()) { [EOL]         if (scope.isLexicalScope()) { [EOL]             scopes.add(scope); [EOL]         } [EOL]     } [EOL]     for (SymbolScope scope : scopes) { [EOL]         addAnonymousFunctionsInScope(scope); [EOL]     } [EOL] } <line_num>: 500,511
private void addAnonymousFunctionsInScope(SymbolScope scope) { [EOL]     Symbol sym = getSymbolForScope(scope); [EOL]     if (sym == null) { [EOL]         if (scope.isLexicalScope() && !scope.isGlobalScope() && scope.getRootNode() != null && !scope.getRootNode().isFromExterns() && scope.getParentScope() != null) { [EOL]             SymbolScope parent = scope.getParentScope(); [EOL]             int count = parent.innerAnonFunctionsWithNames++; [EOL]             String innerName = "function%" + count; [EOL]             scope.setSymbolForScope(declareInferredSymbol(parent, innerName, scope.getRootNode())); [EOL]         } [EOL]     } [EOL] } <line_num>: 513,532
<S extends StaticSlot<JSType>, R extends StaticReference<JSType>> void addSymbolsFrom(StaticSymbolTable<S, R> otherSymbolTable) { [EOL]     for (S otherSymbol : otherSymbolTable.getAllSymbols()) { [EOL]         String name = otherSymbol.getName(); [EOL]         SymbolScope myScope = createScopeFrom(otherSymbolTable.getScope(otherSymbol)); [EOL]         StaticReference<JSType> decl = findBestDeclToAdd(otherSymbolTable, otherSymbol); [EOL]         Symbol mySymbol = null; [EOL]         if (decl != null) { [EOL]             Node declNode = decl.getNode(); [EOL]             mySymbol = isAnySymbolDeclared(name, declNode, myScope); [EOL]             if (mySymbol == null) { [EOL]                 mySymbol = copySymbolTo(otherSymbol, declNode, myScope); [EOL]             } [EOL]         } else { [EOL]             mySymbol = myScope.getOwnSlot(name); [EOL]         } [EOL]         if (mySymbol != null) { [EOL]             for (R otherRef : otherSymbolTable.getReferences(otherSymbol)) { [EOL]                 if (isGoodRefToAdd(otherRef)) { [EOL]                     mySymbol.defineReferenceAt(otherRef.getNode()); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 545,578
private Symbol isAnySymbolDeclared(String name, Node declNode, SymbolScope scope) { [EOL]     Symbol sym = symbols.get(declNode, name); [EOL]     if (sym == null) { [EOL]         return scope.ownSymbols.get(name); [EOL]     } [EOL]     return sym; [EOL] } <line_num>: 584,595
private <S extends StaticSlot<JSType>, R extends StaticReference<JSType>> StaticReference<JSType> findBestDeclToAdd(StaticSymbolTable<S, R> otherSymbolTable, S slot) { [EOL]     StaticReference<JSType> decl = slot.getDeclaration(); [EOL]     if (isGoodRefToAdd(decl)) { [EOL]         return decl; [EOL]     } [EOL]     for (R ref : otherSymbolTable.getReferences(slot)) { [EOL]         if (isGoodRefToAdd(ref)) { [EOL]             return ref; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 598,613
private boolean isGoodRefToAdd(@Nullable StaticReference<JSType> ref) { [EOL]     return ref != null && ref.getNode() != null && ref.getNode().getStaticSourceFile() != null && !Compiler.SYNTHETIC_EXTERNS.equals(ref.getNode().getStaticSourceFile().getName()); [EOL] } <line_num>: 619,624
private Symbol copySymbolTo(StaticSlot<JSType> sym, SymbolScope scope) { [EOL]     return copySymbolTo(sym, sym.getDeclaration().getNode(), scope); [EOL] } <line_num>: 626,628
private Symbol copySymbolTo(StaticSlot<JSType> sym, Node declNode, SymbolScope scope) { [EOL]     Preconditions.checkNotNull(declNode); [EOL]     return declareSymbol(sym.getName(), sym.getType(), sym.isTypeInferred(), scope, declNode, sym.getJSDocInfo()); [EOL] } <line_num>: 630,637
private Symbol addSymbol(String name, JSType type, boolean inferred, SymbolScope scope, Node declNode) { [EOL]     Symbol symbol = new Symbol(name, type, inferred, scope); [EOL]     Symbol replacedSymbol = symbols.put(declNode, name, symbol); [EOL]     Preconditions.checkState(replacedSymbol == null, "Found duplicate symbol %s in global index. Type %s", name, type); [EOL]     replacedSymbol = scope.ownSymbols.put(name, symbol); [EOL]     Preconditions.checkState(replacedSymbol == null, "Found duplicate symbol %s in its scope. Type %s", name, type); [EOL]     return symbol; [EOL] } <line_num>: 639,653
private Symbol declareSymbol(String name, JSType type, boolean inferred, SymbolScope scope, Node declNode, JSDocInfo info) { [EOL]     Symbol symbol = addSymbol(name, type, inferred, scope, declNode); [EOL]     symbol.setJSDocInfo(info); [EOL]     symbol.setDeclaration(symbol.defineReferenceAt(declNode)); [EOL]     return symbol; [EOL] } <line_num>: 655,662
private void removeSymbol(Symbol s) { [EOL]     SymbolScope scope = getScope(s); [EOL]     if (scope.ownSymbols.remove(s.getName()) != s) { [EOL]         throw new IllegalStateException("Symbol not found in scope " + s); [EOL]     } [EOL]     if (symbols.remove(s.getDeclaration().getNode(), s.getName()) != s) { [EOL]         throw new IllegalStateException("Symbol not found in table " + s); [EOL]     } [EOL] } <line_num>: 664,672
void fillNamespaceReferences() { [EOL]     for (Symbol symbol : getAllSymbolsSorted()) { [EOL]         String qName = symbol.getName(); [EOL]         int rootIndex = qName.indexOf('.'); [EOL]         if (rootIndex == -1) { [EOL]             continue; [EOL]         } [EOL]         Symbol root = symbol.scope.getQualifiedSlot(qName.substring(0, rootIndex)); [EOL]         if (root == null) { [EOL]             continue; [EOL]         } [EOL]         for (Reference ref : getReferences(symbol)) { [EOL]             Node currentNode = ref.getNode(); [EOL]             if (!currentNode.isQualifiedName()) { [EOL]                 continue; [EOL]             } [EOL]             while (currentNode.isGetProp()) { [EOL]                 currentNode = currentNode.getFirstChild(); [EOL]                 String name = currentNode.getQualifiedName(); [EOL]                 if (name != null) { [EOL]                     Symbol namespace = isAnySymbolDeclared(name, currentNode, root.scope); [EOL]                     if (namespace == null) { [EOL]                         namespace = root.scope.getQualifiedSlot(name); [EOL]                     } [EOL]                     if (namespace == null && root.scope.isGlobalScope()) { [EOL]                         namespace = declareSymbol(name, registry.getNativeType(JSTypeNative.UNKNOWN_TYPE), true, root.scope, currentNode, null); [EOL]                     } [EOL]                     if (namespace != null) { [EOL]                         namespace.defineReferenceAt(currentNode); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 681,730
void fillPropertyScopes() { [EOL]     List<Symbol> types = Lists.newArrayList(); [EOL]     for (Symbol sym : getAllSymbols()) { [EOL]         if (needsPropertyScope(sym)) { [EOL]             types.add(sym); [EOL]         } [EOL]     } [EOL]     Collections.sort(types, Collections.reverseOrder(getNaturalSymbolOrdering())); [EOL]     for (Symbol s : types) { [EOL]         createPropertyScopeFor(s); [EOL]     } [EOL]     pruneOrphanedNames(); [EOL] } <line_num>: 732,764
private boolean needsPropertyScope(Symbol sym) { [EOL]     ObjectType type = ObjectType.cast(sym.getType()); [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     if (type.getReferenceName() == null) { [EOL]         return true; [EOL]     } [EOL]     if (sym.getName().equals(type.getReferenceName())) { [EOL]         return true; [EOL]     } [EOL]     if (type.isEnumType() && sym.getName().equals(type.toMaybeEnumType().getElementsType().getReferenceName())) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 766,793
void pruneOrphanedNames() { [EOL]     nextSymbol: for (Symbol s : getAllSymbolsSorted()) { [EOL]         if (s.isProperty()) { [EOL]             continue; [EOL]         } [EOL]         String currentName = s.getName(); [EOL]         int dot = -1; [EOL]         while (-1 != (dot = currentName.lastIndexOf('.'))) { [EOL]             currentName = currentName.substring(0, dot); [EOL]             Symbol owner = s.scope.getQualifiedSlot(currentName); [EOL]             if (owner != null && owner.getType() != null && (owner.getType().isNominalConstructor() || owner.getType().isFunctionPrototypeType() || owner.getType().isEnumType())) { [EOL]                 removeSymbol(s); [EOL]                 continue nextSymbol; [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 807,829
void fillPropertySymbols(AbstractCompiler compiler, Node externs, Node root) { [EOL]     (new PropertyRefCollector(compiler)).process(externs, root); [EOL] } <line_num>: 856,859
void fillJSDocInfo(AbstractCompiler compiler, Node externs, Node root) { [EOL]     NodeTraversal.traverseRoots(compiler, Lists.newArrayList(externs, root), new JSDocInfoCollector(compiler.getTypeRegistry())); [EOL]     for (Symbol sym : getAllSymbolsSorted()) { [EOL]         JSDocInfo info = sym.getJSDocInfo(); [EOL]         if (info == null) { [EOL]             continue; [EOL]         } [EOL]         for (Marker marker : info.getMarkers()) { [EOL]             SourcePosition<Node> pos = marker.getNameNode(); [EOL]             if (pos == null) { [EOL]                 continue; [EOL]             } [EOL]             Node paramNode = pos.getItem(); [EOL]             String name = paramNode.getString(); [EOL]             Symbol param = getParameterInFunction(sym, name); [EOL]             if (param == null) { [EOL]                 SourcePosition<Node> typePos = marker.getType(); [EOL]                 JSType type = null; [EOL]                 if (typePos != null) { [EOL]                     type = typePos.getItem().getJSType(); [EOL]                 } [EOL]                 if (sym.docScope == null) { [EOL]                     sym.docScope = new SymbolScope(null, null, null, sym); [EOL]                 } [EOL]                 Symbol existingSymbol = isAnySymbolDeclared(name, paramNode, sym.docScope); [EOL]                 if (existingSymbol == null) { [EOL]                     declareSymbol(name, type, type == null, sym.docScope, paramNode, null); [EOL]                 } [EOL]             } else { [EOL]                 param.defineReferenceAt(paramNode); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 862,914
private void createPropertyScopeFor(Symbol s) { [EOL]     if (s.propertyScope != null) { [EOL]         return; [EOL]     } [EOL]     SymbolScope parentPropertyScope = null; [EOL]     ObjectType type = s.getType() == null ? null : s.getType().toObjectType(); [EOL]     if (type == null) { [EOL]         return; [EOL]     } [EOL]     ObjectType proto = type.getParentScope(); [EOL]     if (proto != null && proto != type && proto.getConstructor() != null) { [EOL]         Symbol parentSymbol = getSymbolForInstancesOf(proto.getConstructor()); [EOL]         if (parentSymbol != null) { [EOL]             createPropertyScopeFor(parentSymbol); [EOL]             parentPropertyScope = parentSymbol.getPropertyScope(); [EOL]         } [EOL]     } [EOL]     ObjectType instanceType = type; [EOL]     Iterable<String> propNames = type.getOwnPropertyNames(); [EOL]     if (instanceType.isFunctionPrototypeType()) { [EOL]         instanceType = instanceType.getOwnerFunction().getInstanceType(); [EOL]         Set<String> set = Sets.newHashSet(propNames); [EOL]         Iterables.addAll(set, instanceType.getOwnPropertyNames()); [EOL]         propNames = set; [EOL]     } [EOL]     s.setPropertyScope(new SymbolScope(null, parentPropertyScope, type, s)); [EOL]     for (String propName : propNames) { [EOL]         StaticSlot<JSType> newProp = instanceType.getSlot(propName); [EOL]         if (newProp.getDeclaration() == null) { [EOL]             continue; [EOL]         } [EOL]         Symbol oldProp = symbols.get(newProp.getDeclaration().getNode(), s.getName() + "." + propName); [EOL]         if (oldProp != null) { [EOL]             removeSymbol(oldProp); [EOL]         } [EOL]         if (symbols.get(newProp.getDeclaration().getNode(), newProp.getName()) != null) { [EOL]             logger.warning("Found duplicate symbol " + newProp); [EOL]             continue; [EOL]         } [EOL]         Symbol newSym = copySymbolTo(newProp, s.propertyScope); [EOL]         if (oldProp != null) { [EOL]             if (newSym.getJSDocInfo() == null) { [EOL]                 newSym.setJSDocInfo(oldProp.getJSDocInfo()); [EOL]             } [EOL]             newSym.setPropertyScope(oldProp.propertyScope); [EOL]             for (Reference ref : oldProp.references.values()) { [EOL]                 newSym.defineReferenceAt(ref.getNode()); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 926,1000
void fillThisReferences(AbstractCompiler compiler, Node externs, Node root) { [EOL]     (new ThisRefCollector(compiler)).process(externs, root); [EOL] } <line_num>: 1005,1008
private SymbolScope createScopeFrom(StaticScope<JSType> otherScope) { [EOL]     Node otherScopeRoot = otherScope.getRootNode(); [EOL]     SymbolScope myScope = scopes.get(otherScopeRoot); [EOL]     if (myScope == null) { [EOL]         StaticScope<JSType> otherScopeParent = otherScope.getParentScope(); [EOL]         if (otherScopeParent == null) { [EOL]             Preconditions.checkState(globalScope == null, "Global scopes found at different roots"); [EOL]         } [EOL]         myScope = new SymbolScope(otherScopeRoot, otherScopeParent == null ? null : createScopeFrom(otherScopeParent), otherScope.getTypeOfThis(), null); [EOL]         scopes.put(otherScopeRoot, myScope); [EOL]         if (myScope.isGlobalScope()) { [EOL]             globalScope = myScope; [EOL]         } [EOL]     } [EOL]     return myScope; [EOL] } <line_num>: 1014,1044
@Override [EOL] public Reference getDeclaration() { [EOL]     return declaration; [EOL] } <line_num>: 1067,1070
public FunctionType getFunctionType() { [EOL]     return JSType.toMaybeFunctionType(getType()); [EOL] } <line_num>: 1072,1074
public Reference defineReferenceAt(Node n) { [EOL]     Reference result = references.get(n); [EOL]     if (result == null) { [EOL]         result = new Reference(this, n); [EOL]         references.put(n, result); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 1076,1083
void setDeclaration(Reference ref) { [EOL]     Preconditions.checkState(this.declaration == null); [EOL]     this.declaration = ref; [EOL] } <line_num>: 1086,1089
public boolean inGlobalScope() { [EOL]     return scope.isGlobalScope(); [EOL] } <line_num>: 1091,1093
public boolean inExterns() { [EOL]     Node n = getDeclarationNode(); [EOL]     return n == null ? false : n.isFromExterns(); [EOL] } <line_num>: 1095,1098
public Node getDeclarationNode() { [EOL]     return declaration == null ? null : declaration.getNode(); [EOL] } <line_num>: 1100,1102
public String getSourceFileName() { [EOL]     Node n = getDeclarationNode(); [EOL]     return n == null ? null : n.getSourceFileName(); [EOL] } <line_num>: 1104,1107
public SymbolScope getPropertyScope() { [EOL]     return propertyScope; [EOL] } <line_num>: 1109,1111
void setPropertyScope(SymbolScope scope) { [EOL]     this.propertyScope = scope; [EOL]     if (scope != null) { [EOL]         this.propertyScope.setSymbolForScope(this); [EOL]     } [EOL] } <line_num>: 1113,1118
@Override [EOL] public JSDocInfo getJSDocInfo() { [EOL]     return docInfo; [EOL] } <line_num>: 1120,1123
void setJSDocInfo(JSDocInfo info) { [EOL]     this.docInfo = info; [EOL] } <line_num>: 1125,1127
public boolean isProperty() { [EOL]     return scope.isPropertyScope(); [EOL] } <line_num>: 1130,1132
public boolean isLexicalVariable() { [EOL]     return scope.isLexicalScope(); [EOL] } <line_num>: 1135,1137
public boolean isDocOnlyParameter() { [EOL]     return scope.isDocScope(); [EOL] } <line_num>: 1140,1142
@Override [EOL] public String toString() { [EOL]     Node n = getDeclarationNode(); [EOL]     int lineNo = n == null ? -1 : n.getLineno(); [EOL]     return getName() + "@" + getSourceFileName() + ":" + lineNo; [EOL] } <line_num>: 1144,1149
Symbol getSymbolForScope() { [EOL]     return mySymbol; [EOL] } <line_num>: 1183,1185
void setSymbolForScope(Symbol sym) { [EOL]     this.mySymbol = sym; [EOL] } <line_num>: 1187,1189
public int getIndexOfSymbol(Symbol sym) { [EOL]     return Iterables.indexOf(ownSymbols.values(), Predicates.equalTo(sym)); [EOL] } <line_num>: 1192,1195
@Override [EOL] public Node getRootNode() { [EOL]     return rootNode; [EOL] } <line_num>: 1197,1200
@Override [EOL] public SymbolScope getParentScope() { [EOL]     return parent; [EOL] } <line_num>: 1202,1205
public Symbol getQualifiedSlot(String name) { [EOL]     Symbol fullyNamedSym = getSlot(name); [EOL]     if (fullyNamedSym != null) { [EOL]         return fullyNamedSym; [EOL]     } [EOL]     int dot = name.lastIndexOf("."); [EOL]     if (dot != -1) { [EOL]         Symbol owner = getQualifiedSlot(name.substring(0, dot)); [EOL]         if (owner != null && owner.getPropertyScope() != null) { [EOL]             return owner.getPropertyScope().getSlot(name.substring(dot + 1)); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 1211,1226
@Override [EOL] public Symbol getSlot(String name) { [EOL]     Symbol own = getOwnSlot(name); [EOL]     if (own != null) { [EOL]         return own; [EOL]     } [EOL]     Symbol ancestor = parent == null ? null : parent.getSlot(name); [EOL]     if (ancestor != null) { [EOL]         return ancestor; [EOL]     } [EOL]     return null; [EOL] } <line_num>: 1228,1240
@Override [EOL] public Symbol getOwnSlot(String name) { [EOL]     return ownSymbols.get(name); [EOL] } <line_num>: 1242,1245
@Override [EOL] public JSType getTypeOfThis() { [EOL]     return typeOfThis; [EOL] } <line_num>: 1247,1250
public boolean isGlobalScope() { [EOL]     return getParentScope() == null && getRootNode() != null; [EOL] } <line_num>: 1252,1254
public boolean isDocScope() { [EOL]     return getRootNode() == null && mySymbol != null && mySymbol.docScope == this; [EOL] } <line_num>: 1260,1263
public boolean isPropertyScope() { [EOL]     return getRootNode() == null && !isDocScope(); [EOL] } <line_num>: 1265,1267
public boolean isLexicalScope() { [EOL]     return getRootNode() != null; [EOL] } <line_num>: 1269,1271
public int getScopeDepth() { [EOL]     return scopeDepth; [EOL] } <line_num>: 1273,1275
@Override [EOL] public String toString() { [EOL]     Node n = getRootNode(); [EOL]     if (n != null) { [EOL]         return "Scope@" + n.getSourceFileName() + ":" + n.getLineno(); [EOL]     } else { [EOL]         return "PropertyScope@" + getSymbolForScope(); [EOL]     } [EOL] } <line_num>: 1277,1285
@Override [EOL] public void process(Node externs, Node root) { [EOL]     NodeTraversal.traverseRoots(compiler, Lists.newArrayList(externs, root), this); [EOL] } <line_num>: 1297,1303
private boolean maybeDefineReference(Node n, String propName, Symbol ownerSymbol) { [EOL]     if (ownerSymbol != null && ownerSymbol.getPropertyScope() != null) { [EOL]         Symbol prop = ownerSymbol.getPropertyScope().getSlot(propName); [EOL]         if (prop != null) { [EOL]             prop.defineReferenceAt(n); [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1305,1317
private boolean tryDefineLexicalQualifiedNameRef(String name, Node n) { [EOL]     if (name != null) { [EOL]         Symbol lexicalSym = getEnclosingScope(n).getQualifiedSlot(name); [EOL]         if (lexicalSym != null) { [EOL]             lexicalSym.defineReferenceAt(n); [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1320,1329
private void tryRemoveLexicalQualifiedNameRef(String name, Node n) { [EOL]     if (name != null) { [EOL]         Symbol lexicalSym = getEnclosingScope(n).getQualifiedSlot(name); [EOL]         if (lexicalSym != null && lexicalSym.isLexicalVariable() && lexicalSym.getDeclaration().getNode() == n) { [EOL]             removeSymbol(lexicalSym); [EOL]         } [EOL]     } [EOL] } <line_num>: 1333,1342
private boolean maybeDefineTypedReference(Node n, String propName, JSType owner) { [EOL]     if (owner.isGlobalThisType()) { [EOL]         Symbol sym = globalScope.getSlot(propName); [EOL]         if (sym != null) { [EOL]             sym.defineReferenceAt(n); [EOL]             return true; [EOL]         } [EOL]     } else if (owner.isNominalConstructor()) { [EOL]         return maybeDefineReference(n, propName, getSymbolDeclaredBy(owner.toMaybeFunctionType())); [EOL]     } else if (owner.isEnumType()) { [EOL]         return maybeDefineReference(n, propName, getSymbolDeclaredBy(owner.toMaybeEnumType())); [EOL]     } else { [EOL]         boolean defined = false; [EOL]         for (Symbol ctor : getAllSymbolsForType(owner)) { [EOL]             if (maybeDefineReference(n, propName, getSymbolForInstancesOf(ctor))) { [EOL]                 defined = true; [EOL]             } [EOL]         } [EOL]         return defined; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1344,1369
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (n.isGetProp()) { [EOL]         JSType owner = n.getFirstChild().getJSType(); [EOL]         if (owner != null) { [EOL]             boolean defined = maybeDefineTypedReference(n, n.getLastChild().getString(), owner); [EOL]             if (defined) { [EOL]                 tryRemoveLexicalQualifiedNameRef(n.getQualifiedName(), n); [EOL]                 return; [EOL]             } [EOL]         } [EOL]         tryDefineLexicalQualifiedNameRef(n.getQualifiedName(), n); [EOL]     } else if (n.isStringKey()) { [EOL]         JSType owner = parent.getJSType(); [EOL]         if (owner != null) { [EOL]             boolean defined = maybeDefineTypedReference(n, n.getString(), owner); [EOL]             if (defined) { [EOL]                 tryRemoveLexicalQualifiedNameRef(NodeUtil.getBestLValueName(n), n); [EOL]                 return; [EOL]             } [EOL]         } [EOL]         tryDefineLexicalQualifiedNameRef(NodeUtil.getBestLValueName(n), n); [EOL]     } [EOL] } <line_num>: 1371,1409
@Override [EOL] public void process(Node externs, Node root) { [EOL]     NodeTraversal.traverseRoots(compiler, Lists.newArrayList(externs, root), this); [EOL] } <line_num>: 1429,1435
@Override [EOL] public void enterScope(NodeTraversal t) { [EOL]     Symbol symbol = null; [EOL]     if (t.inGlobalScope()) { [EOL]         Node firstInputRoot = t.getScopeRoot().getLastChild().getFirstChild(); [EOL]         if (firstInputRoot != null) { [EOL]             symbol = addSymbol(GLOBAL_THIS, registry.getNativeType(JSTypeNative.GLOBAL_THIS), false, globalScope, firstInputRoot); [EOL]             symbol.setDeclaration(new Reference(symbol, firstInputRoot)); [EOL]         } [EOL]     } else { [EOL]         SymbolScope scope = scopes.get(t.getScopeRoot()); [EOL]         Preconditions.checkNotNull(scope); [EOL]         Symbol scopeSymbol = getSymbolForScope(scope); [EOL]         if (scopeSymbol != null) { [EOL]             SymbolScope propScope = scopeSymbol.getPropertyScope(); [EOL]             if (propScope != null) { [EOL]                 symbol = propScope.getOwnSlot("this"); [EOL]                 if (symbol == null) { [EOL]                     JSType rootType = t.getScopeRoot().getJSType(); [EOL]                     FunctionType fnType = rootType == null ? null : rootType.toMaybeFunctionType(); [EOL]                     JSType type = fnType == null ? null : fnType.getTypeOfThis(); [EOL]                     symbol = addSymbol("this", type, false, scope, t.getScopeRoot()); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     thisStack.add(symbol); [EOL] } <line_num>: 1437,1488
@Override [EOL] public void exitScope(NodeTraversal t) { [EOL]     thisStack.remove(thisStack.size() - 1); [EOL] } <line_num>: 1490,1493
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (!n.isThis()) { [EOL]         return; [EOL]     } [EOL]     Symbol symbol = thisStack.get(thisStack.size() - 1); [EOL]     if (symbol != null) { [EOL]         Reference ref = symbol.defineReferenceAt(n); [EOL]         if (symbol.getDeclaration() == null) { [EOL]             symbol.setDeclaration(ref); [EOL]         } [EOL]     } [EOL] } <line_num>: 1495,1508
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (n.getJSDocInfo() != null) { [EOL]         JSDocInfo info = n.getJSDocInfo(); [EOL]         docInfos.add(info); [EOL]         for (Node typeAst : info.getTypeNodes()) { [EOL]             SymbolScope scope = scopes.get(t.getScopeRoot()); [EOL]             visitTypeNode(scope == null ? globalScope : scope, typeAst); [EOL]         } [EOL]     } [EOL] } <line_num>: 1520,1532
public void visitTypeNode(SymbolScope scope, Node n) { [EOL]     if (n.isString()) { [EOL]         Symbol symbol = scope.getSlot(n.getString()); [EOL]         if (symbol == null) { [EOL]             JSType type = typeRegistry.getType(n.getString()); [EOL]             JSType autobox = type == null ? null : type.autoboxesTo(); [EOL]             symbol = autobox == null ? null : getSymbolForTypeHelper(autobox, true); [EOL]         } [EOL]         if (symbol != null) { [EOL]             symbol.defineReferenceAt(n); [EOL]         } [EOL]     } [EOL]     for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { [EOL]         visitTypeNode(scope, child); [EOL]     } [EOL] } <line_num>: 1534,1554
@Override [EOL] public int compare(Node a, Node b) { [EOL]     int result = SOURCE_NAME_ORDERING.compare(a.getSourceFileName(), b.getSourceFileName()); [EOL]     if (result != 0) { [EOL]         return result; [EOL]     } [EOL]     return a.getSourcePosition() - b.getSourcePosition(); [EOL] } <line_num>: 1562,1573
@Override [EOL] public int compare(SymbolScope a, SymbolScope b) { [EOL]     Preconditions.checkState(a.isLexicalScope() && b.isLexicalScope(), "We can only sort lexical scopes"); [EOL]     return NODE_ORDERING.compare(a.getRootNode(), b.getRootNode()); [EOL] } <line_num>: 1578,1583
@Override [EOL] public int compare(Symbol a, Symbol b) { [EOL]     SymbolScope scopeA = getScope(a); [EOL]     SymbolScope scopeB = getScope(b); [EOL]     int result = getLexicalScopeDepth(scopeA) - getLexicalScopeDepth(scopeB); [EOL]     if (result != 0) { [EOL]         return result; [EOL]     } [EOL]     return a.getName().compareTo(b.getName()); [EOL] } <line_num>: 1587,1601
private int getLexicalScopeDepth(SymbolScope scope) { [EOL]     if (scope.isLexicalScope() || scope.isDocScope()) { [EOL]         return scope.getScopeDepth(); [EOL]     } else { [EOL]         Preconditions.checkState(scope.isPropertyScope()); [EOL]         Symbol sym = scope.getSymbolForScope(); [EOL]         Preconditions.checkNotNull(sym); [EOL]         return getLexicalScopeDepth(getScope(sym)) + 1; [EOL]     } [EOL] } <line_num>: 1612,1621
