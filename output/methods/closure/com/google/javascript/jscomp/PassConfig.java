public PassConfig(CompilerOptions options) { [EOL]     this.options = options; [EOL] } <line_num>: 55,57
PassConfigDelegate(PassConfig delegate) { [EOL]     super(delegate.options); [EOL]     this.delegate = delegate; [EOL] } <line_num>: 249,252
public State(Map<String, Integer> cssNames, Set<String> exportedNames, CrossModuleMethodMotion.IdGenerator crossModuleIdGenerator, VariableMap variableMap, VariableMap propertyMap, VariableMap anonymousFunctionNameMap, VariableMap stringMap, FunctionNames functionNames, String idGeneratorMap) { [EOL]     this.cssNames = cssNames; [EOL]     this.exportedNames = exportedNames; [EOL]     this.crossModuleIdGenerator = crossModuleIdGenerator; [EOL]     this.variableMap = variableMap; [EOL]     this.propertyMap = propertyMap; [EOL]     this.anonymousFunctionNameMap = anonymousFunctionNameMap; [EOL]     this.stringMap = stringMap; [EOL]     this.idGeneratorMap = idGeneratorMap; [EOL]     this.functionNames = functionNames; [EOL] } <line_num>: 295,310
void regenerateGlobalTypedScope(AbstractCompiler compiler, Node root) { [EOL]     internalScopeCreator = new TypedScopeCreator(compiler); [EOL]     typedScopeCreator = new MemoizedScopeCreator(internalScopeCreator); [EOL]     topScope = typedScopeCreator.createScope(root, null); [EOL] } <line_num>: 65,69
void clearTypedScope() { [EOL]     internalScopeCreator = null; [EOL]     typedScopeCreator = null; [EOL]     topScope = null; [EOL] } <line_num>: 71,75
void patchGlobalTypedScope(AbstractCompiler compiler, Node scriptRoot) { [EOL]     Preconditions.checkNotNull(internalScopeCreator); [EOL]     internalScopeCreator.patchGlobalScope(topScope, scriptRoot); [EOL] } <line_num>: 84,87
MemoizedScopeCreator getTypedScopeCreator() { [EOL]     return typedScopeCreator; [EOL] } <line_num>: 92,94
Scope getTopScope() { [EOL]     return topScope; [EOL] } <line_num>: 99,101
abstract protected List<PassFactory> getChecks(); <line_num>: 113,113
abstract protected List<PassFactory> getOptimizations(); <line_num>: 121,121
GraphvizGraph getPassGraph() { [EOL]     LinkedDirectedGraph<String, String> graph = LinkedDirectedGraph.createWithoutAnnotations(); [EOL]     Iterable<PassFactory> allPasses = Iterables.concat(getChecks(), getOptimizations()); [EOL]     String lastPass = null; [EOL]     String loopStart = null; [EOL]     for (PassFactory pass : allPasses) { [EOL]         String passName = pass.getName(); [EOL]         int i = 1; [EOL]         while (graph.hasNode(passName)) { [EOL]             passName = pass.getName() + (i++); [EOL]         } [EOL]         graph.createNode(passName); [EOL]         if (loopStart == null && !pass.isOneTimePass()) { [EOL]             loopStart = passName; [EOL]         } else if (loopStart != null && pass.isOneTimePass()) { [EOL]             graph.connect(lastPass, "loop", loopStart); [EOL]             loopStart = null; [EOL]         } [EOL]         if (lastPass != null) { [EOL]             graph.connect(lastPass, "", passName); [EOL]         } [EOL]         lastPass = passName; [EOL]     } [EOL]     return graph; [EOL] } <line_num>: 126,154
final TypeInferencePass makeTypeInference(AbstractCompiler compiler) { [EOL]     return new TypeInferencePass(compiler, compiler.getReverseAbstractInterpreter(), topScope, typedScopeCreator); [EOL] } <line_num>: 159,163
final InferJSDocInfo makeInferJsDocInfo(AbstractCompiler compiler) { [EOL]     return new InferJSDocInfo(compiler); [EOL] } <line_num>: 165,167
final TypeCheck makeTypeCheck(AbstractCompiler compiler) { [EOL]     return new TypeCheck(compiler, compiler.getReverseAbstractInterpreter(), compiler.getTypeRegistry(), topScope, typedScopeCreator, options.reportMissingOverride, options.reportUnknownTypes).reportMissingProperties(options.enables(DiagnosticGroup.forType(TypeCheck.INEXISTENT_PROPERTY))); [EOL] } <line_num>: 172,183
final static void addPassFactoryBefore(List<PassFactory> factoryList, PassFactory factory, String passName) { [EOL]     factoryList.add(findPassIndexByName(factoryList, passName), factory); [EOL] } <line_num>: 188,192
final static void replacePassFactory(List<PassFactory> factoryList, PassFactory factory) { [EOL]     factoryList.set(findPassIndexByName(factoryList, factory.getName()), factory); [EOL] } <line_num>: 197,201
private static int findPassIndexByName(List<PassFactory> factoryList, String name) { [EOL]     for (int i = 0; i < factoryList.size(); i++) { [EOL]         if (factoryList.get(i).getName().equals(name)) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("No factory named '" + name + "' in the factory list"); [EOL] } <line_num>: 206,216
final PassConfig getBasePassConfig() { [EOL]     PassConfig current = this; [EOL]     while (current instanceof PassConfigDelegate) { [EOL]         current = ((PassConfigDelegate) current).delegate; [EOL]     } [EOL]     return current; [EOL] } <line_num>: 221,227
protected abstract State getIntermediateState(); <line_num>: 233,233
protected abstract void setIntermediateState(State state); <line_num>: 239,239
@Override [EOL] protected List<PassFactory> getChecks() { [EOL]     return delegate.getChecks(); [EOL] } <line_num>: 254,256
@Override [EOL] protected List<PassFactory> getOptimizations() { [EOL]     return delegate.getOptimizations(); [EOL] } <line_num>: 258,260
@Override [EOL] MemoizedScopeCreator getTypedScopeCreator() { [EOL]     return delegate.getTypedScopeCreator(); [EOL] } <line_num>: 262,264
@Override [EOL] Scope getTopScope() { [EOL]     return delegate.getTopScope(); [EOL] } <line_num>: 266,268
@Override [EOL] protected State getIntermediateState() { [EOL]     return delegate.getIntermediateState(); [EOL] } <line_num>: 270,272
@Override [EOL] protected void setIntermediateState(State state) { [EOL]     delegate.setIntermediateState(state); [EOL] } <line_num>: 274,276
