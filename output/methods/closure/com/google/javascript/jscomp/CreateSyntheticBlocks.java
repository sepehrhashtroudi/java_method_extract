public Marker(Node startMarker, Node endMarker) { [EOL]     this.startMarker = startMarker; [EOL]     this.endMarker = endMarker; [EOL] } <line_num>: 63,66
public CreateSyntheticBlocks(AbstractCompiler compiler, String startMarkerName, String endMarkerName) { [EOL]     this.compiler = compiler; [EOL]     this.startMarkerName = startMarkerName; [EOL]     this.endMarkerName = endMarkerName; [EOL] } <line_num>: 69,74
@Override [EOL] public void process(Node externs, Node root) { [EOL]     NodeTraversal.traverse(compiler, root, new Callback()); [EOL]     for (Node node : markerStack) { [EOL]         compiler.report(JSError.make(NodeUtil.getSourceName(node), node, UNMATCHED_START_MARKER, startMarkerName)); [EOL]     } [EOL]     for (Marker marker : validMarkers) { [EOL]         addBlocks(marker); [EOL]     } [EOL] } <line_num>: 76,93
private void addBlocks(Marker marker) { [EOL]     Node originalParent = marker.endMarker.getParent(); [EOL]     Node outerBlock = IR.block(); [EOL]     outerBlock.setIsSyntheticBlock(true); [EOL]     originalParent.addChildBefore(outerBlock, marker.startMarker); [EOL]     Node innerBlock = IR.block(); [EOL]     innerBlock.setIsSyntheticBlock(true); [EOL]     moveSiblingExclusive(originalParent, innerBlock, marker.startMarker, marker.endMarker); [EOL]     outerBlock.addChildToBack(originalParent.removeChildAfter(outerBlock)); [EOL]     outerBlock.addChildToBack(innerBlock); [EOL]     outerBlock.addChildToBack(originalParent.removeChildAfter(outerBlock)); [EOL]     compiler.reportCodeChange(); [EOL] } <line_num>: 98,130
private void moveSiblingExclusive(Node src, Node dest, @Nullable Node start, @Nullable Node end) { [EOL]     while (childAfter(src, start) != end) { [EOL]         Node child = removeChildAfter(src, start); [EOL]         dest.addChildToBack(child); [EOL]     } [EOL] } <line_num>: 137,143
private Node childAfter(Node parent, @Nullable Node siblingBefore) { [EOL]     if (siblingBefore == null) { [EOL]         return parent.getFirstChild(); [EOL]     } else { [EOL]         return siblingBefore.getNext(); [EOL]     } [EOL] } <line_num>: 149,155
private Node removeChildAfter(Node parent, @Nullable Node siblingBefore) { [EOL]     if (siblingBefore == null) { [EOL]         return parent.removeFirstChild(); [EOL]     } else { [EOL]         return parent.removeChildAfter(siblingBefore); [EOL]     } [EOL] } <line_num>: 160,166
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (!n.isCall() || !n.getFirstChild().isName()) { [EOL]         return; [EOL]     } [EOL]     Node callTarget = n.getFirstChild(); [EOL]     String callName = callTarget.getString(); [EOL]     if (startMarkerName.equals(callName)) { [EOL]         if (!parent.isExprResult()) { [EOL]             compiler.report(t.makeError(n, INVALID_MARKER_USAGE, startMarkerName)); [EOL]             return; [EOL]         } [EOL]         markerStack.push(parent); [EOL]         return; [EOL]     } [EOL]     if (!endMarkerName.equals(callName)) { [EOL]         return; [EOL]     } [EOL]     Node endMarkerNode = parent; [EOL]     if (!endMarkerNode.isExprResult()) { [EOL]         compiler.report(t.makeError(n, INVALID_MARKER_USAGE, endMarkerName)); [EOL]         return; [EOL]     } [EOL]     if (markerStack.isEmpty()) { [EOL]         compiler.report(t.makeError(n, UNMATCHED_END_MARKER, startMarkerName, endMarkerName)); [EOL]         return; [EOL]     } [EOL]     Node startMarkerNode = markerStack.pop(); [EOL]     if (endMarkerNode.getParent() != startMarkerNode.getParent()) { [EOL]         compiler.report(t.makeError(n, UNMATCHED_END_MARKER, startMarkerName, endMarkerName)); [EOL]         return; [EOL]     } [EOL]     validMarkers.add(new Marker(startMarkerNode, endMarkerNode)); [EOL] } <line_num>: 169,215
