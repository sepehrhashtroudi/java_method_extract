InstrumentFunctions(AbstractCompiler compiler, FunctionNames functionNames, String templateFilename, String appNameStr, Readable readable) { [EOL]     this.compiler = compiler; [EOL]     this.functionNames = functionNames; [EOL]     this.templateFilename = templateFilename; [EOL]     this.appNameStr = appNameStr; [EOL]     Instrumentation.Builder builder = Instrumentation.newBuilder(); [EOL]     try { [EOL]         TextFormat.merge(readable, builder); [EOL]     } catch (IOException e) { [EOL]         compiler.report(JSError.make(RhinoErrorReporter.PARSE_ERROR, "Error reading instrumentation template protobuf at " + templateFilename)); [EOL]         this.initCodeSource = ""; [EOL]         this.definedFunctionName = ""; [EOL]         this.reportFunctionName = ""; [EOL]         this.reportFunctionExitName = ""; [EOL]         this.appNameSetter = ""; [EOL]         this.declarationsToRemove = Lists.newArrayList(); [EOL]         return; [EOL]     } [EOL]     Instrumentation template = builder.build(); [EOL]     StringBuilder initCodeSourceBuilder = new StringBuilder(); [EOL]     for (String line : template.getInitList()) { [EOL]         initCodeSourceBuilder.append(line).append("\n"); [EOL]     } [EOL]     this.initCodeSource = initCodeSourceBuilder.toString(); [EOL]     this.definedFunctionName = template.getReportDefined(); [EOL]     this.reportFunctionName = template.getReportCall(); [EOL]     this.reportFunctionExitName = template.getReportExit(); [EOL]     this.appNameSetter = template.getAppNameSetter(); [EOL]     this.declarationsToRemove = ImmutableList.copyOf(template.getDeclarationToRemoveList()); [EOL] } <line_num>: 80,121
RemoveCallback(List<String> removable) { [EOL]     this.removable = removable; [EOL] } <line_num>: 168,170
InstrumentReturns(int functionId) { [EOL]     this.functionId = functionId; [EOL] } <line_num>: 220,222
@Override [EOL] public void process(Node externs, Node root) { [EOL]     Node initCode = null; [EOL]     if (!initCodeSource.isEmpty()) { [EOL]         Node initCodeRoot = compiler.parseSyntheticCode(templateFilename + ":init", initCodeSource); [EOL]         if (initCodeRoot != null && initCodeRoot.getFirstChild() != null) { [EOL]             initCode = initCodeRoot.removeChildren(); [EOL]         } else { [EOL]             return; [EOL]         } [EOL]     } [EOL]     NodeTraversal.traverse(compiler, root, new RemoveCallback(declarationsToRemove)); [EOL]     NodeTraversal.traverse(compiler, root, new InstrumentCallback()); [EOL]     if (!appNameSetter.isEmpty()) { [EOL]         Node call = IR.call(IR.name(appNameSetter), IR.string(appNameStr)); [EOL]         call.putBooleanProp(Node.FREE_CALL, true); [EOL]         Node expr = IR.exprResult(call); [EOL]         Node addingRoot = compiler.getNodeForCodeInsertion(null); [EOL]         addingRoot.addChildrenToFront(expr); [EOL]         compiler.reportCodeChange(); [EOL]     } [EOL]     if (initCode != null) { [EOL]         Node addingRoot = compiler.getNodeForCodeInsertion(null); [EOL]         addingRoot.addChildrenToFront(initCode); [EOL]         compiler.reportCodeChange(); [EOL]     } [EOL] } <line_num>: 123,157
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (NodeUtil.isVarDeclaration(n)) { [EOL]         if (removable.contains(n.getString())) { [EOL]             parent.removeChild(n); [EOL]             if (!parent.hasChildren()) { [EOL]                 parent.getParent().removeChild(parent); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 172,182
void process(Node body) { [EOL]     NodeTraversal.traverse(compiler, body, this); [EOL]     if (!allPathsReturn(body)) { [EOL]         Node call = newReportFunctionExitNode(); [EOL]         Node expr = IR.exprResult(call); [EOL]         body.addChildToBack(expr); [EOL]         compiler.reportCodeChange(); [EOL]     } [EOL] } <line_num>: 227,236
@Override [EOL] public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { [EOL]     return !n.isFunction(); [EOL] } <line_num>: 238,241
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (!n.isReturn()) { [EOL]         return; [EOL]     } [EOL]     Node call = newReportFunctionExitNode(); [EOL]     Node returnRhs = n.removeFirstChild(); [EOL]     if (returnRhs != null) { [EOL]         call.addChildToBack(returnRhs); [EOL]     } [EOL]     n.addChildToFront(call); [EOL]     compiler.reportCodeChange(); [EOL] } <line_num>: 243,256
private Node newReportFunctionExitNode() { [EOL]     Node call = IR.call(IR.name(reportFunctionExitName), IR.number(functionId)); [EOL]     call.putBooleanProp(Node.FREE_CALL, true); [EOL]     return call; [EOL] } <line_num>: 258,264
private boolean allPathsReturn(Node block) { [EOL]     ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, false); [EOL]     cfa.process(null, block); [EOL]     ControlFlowGraph<Node> cfg = cfa.getCfg(); [EOL]     Node returnPathsParent = cfg.getImplicitReturn().getValue(); [EOL]     for (DiGraphNode<Node, Branch> pred : cfg.getDirectedPredNodes(returnPathsParent)) { [EOL]         Node n = pred.getValue(); [EOL]         if (!n.isReturn()) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 269,285
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (!n.isFunction()) { [EOL]         return; [EOL]     } [EOL]     int id = functionNames.getFunctionId(n); [EOL]     if (id < 0) { [EOL]         return; [EOL]     } [EOL]     if (!reportFunctionName.isEmpty()) { [EOL]         Node body = n.getFirstChild().getNext().getNext(); [EOL]         Node call = IR.call(IR.name(reportFunctionName), IR.number(id)); [EOL]         call.putBooleanProp(Node.FREE_CALL, true); [EOL]         Node expr = IR.exprResult(call); [EOL]         body.addChildToFront(expr); [EOL]         compiler.reportCodeChange(); [EOL]     } [EOL]     if (!reportFunctionExitName.isEmpty()) { [EOL]         Node body = n.getFirstChild().getNext().getNext(); [EOL]         (new InstrumentReturns(id)).process(body); [EOL]     } [EOL]     if (!definedFunctionName.isEmpty()) { [EOL]         Node call = IR.call(IR.name(definedFunctionName), IR.number(id)); [EOL]         call.putBooleanProp(Node.FREE_CALL, true); [EOL]         Node expr = NodeUtil.newExpr(call); [EOL]         Node addingRoot = null; [EOL]         if (NodeUtil.isFunctionDeclaration(n)) { [EOL]             JSModule module = t.getModule(); [EOL]             addingRoot = compiler.getNodeForCodeInsertion(module); [EOL]             addingRoot.addChildToFront(expr); [EOL]         } else { [EOL]             Node beforeChild = n; [EOL]             for (Node ancestor : n.getAncestors()) { [EOL]                 int type = ancestor.getType(); [EOL]                 if (type == Token.BLOCK || type == Token.SCRIPT) { [EOL]                     addingRoot = ancestor; [EOL]                     break; [EOL]                 } [EOL]                 beforeChild = ancestor; [EOL]             } [EOL]             addingRoot.addChildBefore(expr, beforeChild); [EOL]         } [EOL]         compiler.reportCodeChange(); [EOL]     } [EOL] } <line_num>: 289,343
