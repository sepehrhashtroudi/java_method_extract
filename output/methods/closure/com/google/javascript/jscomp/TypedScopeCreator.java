DeferredSetType(Node node, JSType type) { [EOL]     Preconditions.checkNotNull(node); [EOL]     Preconditions.checkNotNull(type); [EOL]     this.node = node; [EOL]     this.type = type; [EOL]     node.setJSType(type); [EOL] } <line_num>: 163,172
TypedScopeCreator(AbstractCompiler compiler) { [EOL]     this(compiler, compiler.getCodingConvention()); [EOL] } <line_num>: 179,181
TypedScopeCreator(AbstractCompiler compiler, CodingConvention codingConvention) { [EOL]     this.compiler = compiler; [EOL]     this.validator = compiler.getTypeValidator(); [EOL]     this.codingConvention = codingConvention; [EOL]     this.typeRegistry = compiler.getTypeRegistry(); [EOL]     this.typeParsingErrorReporter = typeRegistry.getErrorReporter(); [EOL]     this.unknownType = typeRegistry.getNativeObjectType(UNKNOWN_TYPE); [EOL] } <line_num>: 183,191
DiscoverEnumsAndTypedefs(JSTypeRegistry registry) { [EOL]     this.registry = registry; [EOL] } <line_num>: 361,363
private AbstractScopeBuilder(Scope scope) { [EOL]     this.scope = scope; [EOL] } <line_num>: 456,458
CollectProperties(JSType thisType) { [EOL]     this.thisType = thisType; [EOL] } <line_num>: 1723,1725
private StubDeclaration(Node node, boolean isExtern, String ownerName) { [EOL]     this.node = node; [EOL]     this.isExtern = isExtern; [EOL]     this.ownerName = ownerName; [EOL] } <line_num>: 1779,1783
private GlobalScopeBuilder(Scope scope) { [EOL]     super(scope); [EOL] } <line_num>: 1792,1794
private LocalScopeBuilder(Scope scope) { [EOL]     super(scope); [EOL] } <line_num>: 1871,1873
FirstOrderFunctionAnalyzer(AbstractCompiler compiler, Map<Node, AstFunctionContents> outParam) { [EOL]     this.compiler = compiler; [EOL]     this.data = outParam; [EOL] } <line_num>: 2002,2006
void resolve(Scope scope) { [EOL]     node.setJSType(type.resolve(typeParsingErrorReporter, scope)); [EOL] } <line_num>: 174,176
@Override [EOL] public Scope createScope(Node root, Scope parent) { [EOL]     Scope newScope = null; [EOL]     AbstractScopeBuilder scopeBuilder = null; [EOL]     if (parent == null) { [EOL]         JSType globalThis = typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS); [EOL]         root.setJSType(globalThis); [EOL]         root.getFirstChild().setJSType(globalThis); [EOL]         root.getLastChild().setJSType(globalThis); [EOL]         (new FirstOrderFunctionAnalyzer(compiler, functionAnalysisResults)).process(root.getFirstChild(), root.getLastChild()); [EOL]         newScope = createInitialScope(root); [EOL]         GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope); [EOL]         scopeBuilder = globalScopeBuilder; [EOL]         NodeTraversal.traverse(compiler, root, scopeBuilder); [EOL]     } else { [EOL]         newScope = new Scope(parent, root); [EOL]         LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope); [EOL]         scopeBuilder = localScopeBuilder; [EOL]         localScopeBuilder.build(); [EOL]     } [EOL]     scopeBuilder.resolveStubDeclarations(); [EOL]     scopeBuilder.resolveTypes(); [EOL]     for (Node functionNode : scopeBuilder.nonExternFunctions) { [EOL]         JSType type = functionNode.getJSType(); [EOL]         if (type != null && type.isFunctionType()) { [EOL]             FunctionType fnType = type.toMaybeFunctionType(); [EOL]             JSType fnThisType = fnType.getTypeOfThis(); [EOL]             if (!fnThisType.isUnknownType()) { [EOL]                 NodeTraversal.traverse(compiler, functionNode.getLastChild(), scopeBuilder.new CollectProperties(fnThisType)); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (parent == null) { [EOL]         codingConvention.defineDelegateProxyPrototypeProperties(typeRegistry, newScope, delegateProxyPrototypes, delegateCallingConventions); [EOL]     } [EOL]     return newScope; [EOL] } <line_num>: 197,255
void patchGlobalScope(Scope globalScope, Node scriptRoot) { [EOL]     Preconditions.checkState(scriptRoot.isScript()); [EOL]     Preconditions.checkNotNull(globalScope); [EOL]     Preconditions.checkState(globalScope.isGlobal()); [EOL]     String scriptName = NodeUtil.getSourceName(scriptRoot); [EOL]     Preconditions.checkNotNull(scriptName); [EOL]     for (Node node : ImmutableList.copyOf(functionAnalysisResults.keySet())) { [EOL]         if (scriptName.equals(NodeUtil.getSourceName(node))) { [EOL]             functionAnalysisResults.remove(node); [EOL]         } [EOL]     } [EOL]     (new FirstOrderFunctionAnalyzer(compiler, functionAnalysisResults)).process(null, scriptRoot); [EOL]     Iterator<Var> varIter = globalScope.getVars(); [EOL]     List<Var> varsToRemove = Lists.newArrayList(); [EOL]     while (varIter.hasNext()) { [EOL]         Var oldVar = varIter.next(); [EOL]         if (scriptName.equals(oldVar.getInputName())) { [EOL]             varsToRemove.add(oldVar); [EOL]         } [EOL]     } [EOL]     for (Var var : varsToRemove) { [EOL]         globalScope.undeclare(var); [EOL]         globalScope.getTypeOfThis().toObjectType().removeProperty(var.getName()); [EOL]     } [EOL]     GlobalScopeBuilder scopeBuilder = new GlobalScopeBuilder(globalScope); [EOL]     NodeTraversal.traverse(compiler, scriptRoot, scopeBuilder); [EOL] } <line_num>: 264,303
@VisibleForTesting [EOL] Scope createInitialScope(Node root) { [EOL]     NodeTraversal.traverse(compiler, root, new DiscoverEnumsAndTypedefs(typeRegistry)); [EOL]     Scope s = Scope.createGlobalScope(root); [EOL]     declareNativeFunctionType(s, ARRAY_FUNCTION_TYPE); [EOL]     declareNativeFunctionType(s, BOOLEAN_OBJECT_FUNCTION_TYPE); [EOL]     declareNativeFunctionType(s, DATE_FUNCTION_TYPE); [EOL]     declareNativeFunctionType(s, ERROR_FUNCTION_TYPE); [EOL]     declareNativeFunctionType(s, EVAL_ERROR_FUNCTION_TYPE); [EOL]     declareNativeFunctionType(s, FUNCTION_FUNCTION_TYPE); [EOL]     declareNativeFunctionType(s, NUMBER_OBJECT_FUNCTION_TYPE); [EOL]     declareNativeFunctionType(s, OBJECT_FUNCTION_TYPE); [EOL]     declareNativeFunctionType(s, RANGE_ERROR_FUNCTION_TYPE); [EOL]     declareNativeFunctionType(s, REFERENCE_ERROR_FUNCTION_TYPE); [EOL]     declareNativeFunctionType(s, REGEXP_FUNCTION_TYPE); [EOL]     declareNativeFunctionType(s, STRING_OBJECT_FUNCTION_TYPE); [EOL]     declareNativeFunctionType(s, SYNTAX_ERROR_FUNCTION_TYPE); [EOL]     declareNativeFunctionType(s, TYPE_ERROR_FUNCTION_TYPE); [EOL]     declareNativeFunctionType(s, URI_ERROR_FUNCTION_TYPE); [EOL]     declareNativeValueType(s, "undefined", VOID_TYPE); [EOL]     declareNativeValueType(s, "ActiveXObject", FUNCTION_INSTANCE_TYPE); [EOL]     return s; [EOL] } <line_num>: 309,339
private void declareNativeFunctionType(Scope scope, JSTypeNative tId) { [EOL]     FunctionType t = typeRegistry.getNativeFunctionType(tId); [EOL]     declareNativeType(scope, t.getInstanceType().getReferenceName(), t); [EOL]     declareNativeType(scope, t.getPrototype().getReferenceName(), t.getPrototype()); [EOL] } <line_num>: 341,346
private void declareNativeValueType(Scope scope, String name, JSTypeNative tId) { [EOL]     declareNativeType(scope, name, typeRegistry.getNativeType(tId)); [EOL] } <line_num>: 348,351
private void declareNativeType(Scope scope, String name, JSType t) { [EOL]     scope.declare(name, null, t, null, false); [EOL] } <line_num>: 353,355
@Override [EOL] public void visit(NodeTraversal t, Node node, Node parent) { [EOL]     Node nameNode = null; [EOL]     switch(node.getType()) { [EOL]         case Token.VAR: [EOL]             for (Node child = node.getFirstChild(); child != null; child = child.getNext()) { [EOL]                 identifyNameNode(child, child.getFirstChild(), NodeUtil.getBestJSDocInfo(child)); [EOL]             } [EOL]             break; [EOL]         case Token.EXPR_RESULT: [EOL]             Node firstChild = node.getFirstChild(); [EOL]             if (firstChild.isAssign()) { [EOL]                 identifyNameNode(firstChild.getFirstChild(), firstChild.getLastChild(), firstChild.getJSDocInfo()); [EOL]             } else { [EOL]                 identifyNameNode(firstChild, null, firstChild.getJSDocInfo()); [EOL]             } [EOL]             break; [EOL]     } [EOL] } <line_num>: 365,389
private void identifyNameNode(Node nameNode, Node valueNode, JSDocInfo info) { [EOL]     if (nameNode.isQualifiedName()) { [EOL]         if (info != null) { [EOL]             if (info.hasEnumParameterType()) { [EOL]                 registry.identifyNonNullableName(nameNode.getQualifiedName()); [EOL]             } else if (info.hasTypedefType()) { [EOL]                 registry.identifyNonNullableName(nameNode.getQualifiedName()); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 391,402
private JSType getNativeType(JSTypeNative nativeType) { [EOL]     return typeRegistry.getNativeType(nativeType); [EOL] } <line_num>: 405,407
void setDeferredType(Node node, JSType type) { [EOL]     deferredSetTypes.add(new DeferredSetType(node, type)); [EOL] } <line_num>: 460,462
void resolveTypes() { [EOL]     for (DeferredSetType deferred : deferredSetTypes) { [EOL]         deferred.resolve(scope); [EOL]     } [EOL]     Iterator<Var> vars = scope.getVars(); [EOL]     while (vars.hasNext()) { [EOL]         vars.next().resolveType(typeParsingErrorReporter); [EOL]     } [EOL]     typeRegistry.resolveTypesInScope(scope); [EOL] } <line_num>: 464,479
@Override [EOL] public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { [EOL]     inputId = t.getInputId(); [EOL]     if (n.isFunction() || n.isScript()) { [EOL]         Preconditions.checkNotNull(inputId); [EOL]         sourceName = NodeUtil.getSourceName(n); [EOL]     } [EOL]     boolean descend = parent == null || !parent.isFunction() || n == parent.getFirstChild() || parent == scope.getRootNode(); [EOL]     if (descend) { [EOL]         if (NodeUtil.isStatementParent(n)) { [EOL]             for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { [EOL]                 if (NodeUtil.isHoistedFunctionDeclaration(child)) { [EOL]                     defineFunctionLiteral(child); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return descend; [EOL] } <line_num>: 481,510
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     inputId = t.getInputId(); [EOL]     attachLiteralTypes(t, n); [EOL]     switch(n.getType()) { [EOL]         case Token.CALL: [EOL]             checkForClassDefiningCalls(t, n, parent); [EOL]             checkForCallingConventionDefiningCalls(n, delegateCallingConventions); [EOL]             break; [EOL]         case Token.FUNCTION: [EOL]             if (t.getInput() == null || !t.getInput().isExtern()) { [EOL]                 nonExternFunctions.add(n); [EOL]             } [EOL]             if (!NodeUtil.isHoistedFunctionDeclaration(n)) { [EOL]                 defineFunctionLiteral(n); [EOL]             } [EOL]             break; [EOL]         case Token.ASSIGN: [EOL]             Node firstChild = n.getFirstChild(); [EOL]             if (firstChild.isGetProp() && firstChild.isQualifiedName()) { [EOL]                 maybeDeclareQualifiedName(t, n.getJSDocInfo(), firstChild, n, firstChild.getNext()); [EOL]             } [EOL]             break; [EOL]         case Token.CATCH: [EOL]             defineCatch(n); [EOL]             break; [EOL]         case Token.VAR: [EOL]             defineVar(n); [EOL]             break; [EOL]         case Token.GETPROP: [EOL]             if (parent.isExprResult() && n.isQualifiedName()) { [EOL]                 maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null); [EOL]             } [EOL]             break; [EOL]     } [EOL]     if (n.getParent() != null && NodeUtil.isStatement(n) && lentObjectLiterals != null) { [EOL]         for (Node objLit : lentObjectLiterals) { [EOL]             defineObjectLiteral(objLit); [EOL]         } [EOL]         lentObjectLiterals.clear(); [EOL]     } [EOL] } <line_num>: 512,569
private void attachLiteralTypes(NodeTraversal t, Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.NULL: [EOL]             n.setJSType(getNativeType(NULL_TYPE)); [EOL]             break; [EOL]         case Token.VOID: [EOL]             n.setJSType(getNativeType(VOID_TYPE)); [EOL]             break; [EOL]         case Token.STRING: [EOL]             n.setJSType(getNativeType(STRING_TYPE)); [EOL]             break; [EOL]         case Token.NUMBER: [EOL]             n.setJSType(getNativeType(NUMBER_TYPE)); [EOL]             break; [EOL]         case Token.TRUE: [EOL]         case Token.FALSE: [EOL]             n.setJSType(getNativeType(BOOLEAN_TYPE)); [EOL]             break; [EOL]         case Token.REGEXP: [EOL]             n.setJSType(getNativeType(REGEXP_TYPE)); [EOL]             break; [EOL]         case Token.OBJECTLIT: [EOL]             JSDocInfo info = n.getJSDocInfo(); [EOL]             if (info != null && info.getLendsName() != null) { [EOL]                 if (lentObjectLiterals == null) { [EOL]                     lentObjectLiterals = Lists.newArrayList(); [EOL]                 } [EOL]                 lentObjectLiterals.add(n); [EOL]             } else { [EOL]                 defineObjectLiteral(n); [EOL]             } [EOL]             break; [EOL]     } [EOL] } <line_num>: 571,614
private void defineObjectLiteral(Node objectLit) { [EOL]     JSType type = null; [EOL]     JSDocInfo info = objectLit.getJSDocInfo(); [EOL]     if (info != null && info.getLendsName() != null) { [EOL]         String lendsName = info.getLendsName(); [EOL]         Var lendsVar = scope.getVar(lendsName); [EOL]         if (lendsVar == null) { [EOL]             compiler.report(JSError.make(sourceName, objectLit, UNKNOWN_LENDS, lendsName)); [EOL]         } else { [EOL]             type = lendsVar.getType(); [EOL]             if (type == null) { [EOL]                 type = unknownType; [EOL]             } [EOL]             if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) { [EOL]                 compiler.report(JSError.make(sourceName, objectLit, LENDS_ON_NON_OBJECT, lendsName, type.toString())); [EOL]                 type = null; [EOL]             } else { [EOL]                 objectLit.setJSType(type); [EOL]             } [EOL]         } [EOL]     } [EOL]     info = NodeUtil.getBestJSDocInfo(objectLit); [EOL]     Node lValue = NodeUtil.getBestLValue(objectLit); [EOL]     String lValueName = NodeUtil.getBestLValueName(lValue); [EOL]     boolean createdEnumType = false; [EOL]     if (info != null && info.hasEnumParameterType()) { [EOL]         type = createEnumTypeFromNodes(objectLit, lValueName, info, lValue); [EOL]         createdEnumType = true; [EOL]     } [EOL]     if (type == null) { [EOL]         type = typeRegistry.createAnonymousObjectType(info); [EOL]     } [EOL]     setDeferredType(objectLit, type); [EOL]     processObjectLitProperties(objectLit, ObjectType.cast(objectLit.getJSType()), !createdEnumType); [EOL] } <line_num>: 616,660
void processObjectLitProperties(Node objLit, ObjectType objLitType, boolean declareOnOwner) { [EOL]     for (Node keyNode = objLit.getFirstChild(); keyNode != null; keyNode = keyNode.getNext()) { [EOL]         Node value = keyNode.getFirstChild(); [EOL]         String memberName = NodeUtil.getObjectLitKeyName(keyNode); [EOL]         JSDocInfo info = keyNode.getJSDocInfo(); [EOL]         JSType valueType = getDeclaredType(keyNode.getSourceFileName(), info, keyNode, value); [EOL]         JSType keyType = objLitType.isEnumType() ? objLitType.toMaybeEnumType().getElementsType() : NodeUtil.getObjectLitKeyTypeFromValueType(keyNode, valueType); [EOL]         String qualifiedName = NodeUtil.getBestLValueName(keyNode); [EOL]         if (qualifiedName != null) { [EOL]             boolean inferred = keyType == null; [EOL]             defineSlot(keyNode, objLit, qualifiedName, keyType, inferred); [EOL]         } else if (keyType != null) { [EOL]             setDeferredType(keyNode, keyType); [EOL]         } [EOL]         if (keyType != null && objLitType != null && declareOnOwner) { [EOL]             boolean isExtern = keyNode.isFromExterns(); [EOL]             objLitType.defineDeclaredProperty(memberName, keyType, keyNode); [EOL]         } [EOL]     } [EOL] } <line_num>: 670,700
private JSType getDeclaredTypeInAnnotation(String sourceName, Node node, JSDocInfo info) { [EOL]     JSType jsType = null; [EOL]     Node objNode = node.isGetProp() ? node.getFirstChild() : NodeUtil.isObjectLitKey(node, node.getParent()) ? node.getParent() : null; [EOL]     if (info != null) { [EOL]         if (info.hasType()) { [EOL]             jsType = info.getType().evaluate(scope, typeRegistry); [EOL]         } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) { [EOL]             String fnName = node.getQualifiedName(); [EOL]             jsType = createFunctionTypeFromNodes(null, fnName, info, node); [EOL]         } [EOL]     } [EOL]     return jsType; [EOL] } <line_num>: 708,725
void assertDefinitionNode(Node n, int type) { [EOL]     Preconditions.checkState(sourceName != null); [EOL]     Preconditions.checkState(n.getType() == type); [EOL] } <line_num>: 731,734
void defineCatch(Node n) { [EOL]     assertDefinitionNode(n, Token.CATCH); [EOL]     Node catchName = n.getFirstChild(); [EOL]     defineSlot(catchName, n, getDeclaredType(sourceName, catchName.getJSDocInfo(), catchName, null)); [EOL] } <line_num>: 739,745
void defineVar(Node n) { [EOL]     assertDefinitionNode(n, Token.VAR); [EOL]     JSDocInfo info = n.getJSDocInfo(); [EOL]     if (n.hasMoreThanOneChild()) { [EOL]         if (info != null) { [EOL]             compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF)); [EOL]         } [EOL]         for (Node name : n.children()) { [EOL]             defineName(name, n, name.getJSDocInfo()); [EOL]         } [EOL]     } else { [EOL]         Node name = n.getFirstChild(); [EOL]         defineName(name, n, (info != null) ? info : name.getJSDocInfo()); [EOL]     } [EOL] } <line_num>: 750,765
void defineFunctionLiteral(Node n) { [EOL]     assertDefinitionNode(n, Token.FUNCTION); [EOL]     Node lValue = NodeUtil.getBestLValue(n); [EOL]     JSDocInfo info = NodeUtil.getBestJSDocInfo(n); [EOL]     String functionName = NodeUtil.getBestLValueName(lValue); [EOL]     FunctionType functionType = createFunctionTypeFromNodes(n, functionName, info, lValue); [EOL]     setDeferredType(n, functionType); [EOL]     if (NodeUtil.isFunctionDeclaration(n)) { [EOL]         defineSlot(n.getFirstChild(), n, functionType); [EOL]     } [EOL] } <line_num>: 770,790
private void defineName(Node name, Node var, JSDocInfo info) { [EOL]     Node value = name.getFirstChild(); [EOL]     JSType type = getDeclaredType(sourceName, info, name, value); [EOL]     if (type == null) { [EOL]         type = name.isFromExterns() ? unknownType : null; [EOL]     } [EOL]     defineSlot(name, var, type); [EOL] } <line_num>: 800,810
private boolean shouldUseFunctionLiteralType(FunctionType type, JSDocInfo info, Node lValue) { [EOL]     if (info != null) { [EOL]         return true; [EOL]     } [EOL]     if (lValue != null && NodeUtil.isObjectLitKey(lValue, lValue.getParent())) { [EOL]         return false; [EOL]     } [EOL]     return scope.isGlobal() || !type.isReturnTypeInferred(); [EOL] } <line_num>: 819,829
private FunctionType createFunctionTypeFromNodes(@Nullable Node rValue, @Nullable String name, @Nullable JSDocInfo info, @Nullable Node lvalueNode) { [EOL]     FunctionType functionType = null; [EOL]     if (rValue != null && rValue.isQualifiedName() && scope.isGlobal()) { [EOL]         Var var = scope.getVar(rValue.getQualifiedName()); [EOL]         if (var != null && var.getType() != null && var.getType().isFunctionType()) { [EOL]             FunctionType aliasedType = var.getType().toMaybeFunctionType(); [EOL]             if ((aliasedType.isConstructor() || aliasedType.isInterface()) && !aliasedType.isNativeObjectType()) { [EOL]                 functionType = aliasedType; [EOL]                 if (name != null && scope.isGlobal()) { [EOL]                     typeRegistry.declareType(name, functionType.getInstanceType()); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (functionType == null) { [EOL]         Node errorRoot = rValue == null ? lvalueNode : rValue; [EOL]         boolean isFnLiteral = rValue != null && rValue.isFunction(); [EOL]         Node fnRoot = isFnLiteral ? rValue : null; [EOL]         Node parametersNode = isFnLiteral ? rValue.getFirstChild().getNext() : null; [EOL]         Node fnBlock = isFnLiteral ? parametersNode.getNext() : null; [EOL]         if (info != null && info.hasType()) { [EOL]             JSType type = info.getType().evaluate(scope, typeRegistry); [EOL]             type = type.restrictByNotNullOrUndefined(); [EOL]             if (type.isFunctionType()) { [EOL]                 functionType = type.toMaybeFunctionType(); [EOL]                 functionType.setJSDocInfo(info); [EOL]             } [EOL]         } [EOL]         if (functionType == null) { [EOL]             Node ownerNode = NodeUtil.getBestLValueOwner(lvalueNode); [EOL]             String ownerName = NodeUtil.getBestLValueName(ownerNode); [EOL]             Var ownerVar = null; [EOL]             String propName = null; [EOL]             ObjectType ownerType = null; [EOL]             if (ownerName != null) { [EOL]                 ownerVar = scope.getVar(ownerName); [EOL]                 if (ownerVar != null) { [EOL]                     ownerType = ObjectType.cast(ownerVar.getType()); [EOL]                 } [EOL]                 if (name != null) { [EOL]                     propName = name.substring(ownerName.length() + 1); [EOL]                 } [EOL]             } [EOL]             FunctionType overriddenType = null; [EOL]             if (ownerType != null && propName != null) { [EOL]                 overriddenType = findOverriddenFunction(ownerType, propName); [EOL]             } [EOL]             FunctionTypeBuilder builder = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setContents(getFunctionAnalysisResults(fnRoot)).inferFromOverriddenFunction(overriddenType, parametersNode).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info); [EOL]             boolean searchedForThisType = false; [EOL]             if (ownerType != null && ownerType.isFunctionPrototypeType() && ownerType.getOwnerFunction().hasInstanceType()) { [EOL]                 builder.inferThisType(info, ownerType.getOwnerFunction().getInstanceType()); [EOL]                 searchedForThisType = true; [EOL]             } else if (ownerNode != null && ownerNode.isThis()) { [EOL]                 JSType injectedThisType = ownerNode.getJSType(); [EOL]                 builder.inferThisType(info, injectedThisType == null ? scope.getTypeOfThis() : injectedThisType); [EOL]                 searchedForThisType = true; [EOL]             } [EOL]             if (!searchedForThisType) { [EOL]                 builder.inferThisType(info); [EOL]             } [EOL]             functionType = builder.inferParameterTypes(parametersNode, info).buildAndRegister(); [EOL]         } [EOL]     } [EOL]     return functionType; [EOL] } <line_num>: 853,961
private FunctionType findOverriddenFunction(ObjectType ownerType, String propName) { [EOL]     JSType propType = ownerType.getPropertyType(propName); [EOL]     if (propType != null && propType.isFunctionType()) { [EOL]         return propType.toMaybeFunctionType(); [EOL]     } else { [EOL]         for (ObjectType iface : ownerType.getCtorImplementedInterfaces()) { [EOL]             propType = iface.getPropertyType(propName); [EOL]             if (propType != null && propType.isFunctionType()) { [EOL]                 return propType.toMaybeFunctionType(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 966,986
private EnumType createEnumTypeFromNodes(Node rValue, String name, JSDocInfo info, Node lValueNode) { [EOL]     Preconditions.checkNotNull(info); [EOL]     Preconditions.checkState(info.hasEnumParameterType()); [EOL]     EnumType enumType = null; [EOL]     if (rValue != null && rValue.isQualifiedName()) { [EOL]         Var var = scope.getVar(rValue.getQualifiedName()); [EOL]         if (var != null && var.getType() instanceof EnumType) { [EOL]             enumType = (EnumType) var.getType(); [EOL]         } [EOL]     } [EOL]     if (enumType == null) { [EOL]         JSType elementsType = info.getEnumParameterType().evaluate(scope, typeRegistry); [EOL]         enumType = typeRegistry.createEnumType(name, rValue, elementsType); [EOL]         if (rValue != null && rValue.isObjectLit()) { [EOL]             Node key = rValue.getFirstChild(); [EOL]             while (key != null) { [EOL]                 String keyName = NodeUtil.getStringValue(key); [EOL]                 if (keyName == null) { [EOL]                     compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName)); [EOL]                 } else if (!codingConvention.isValidEnumKey(keyName)) { [EOL]                     compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName)); [EOL]                 } else { [EOL]                     enumType.defineElement(keyName, key); [EOL]                 } [EOL]                 key = key.getNext(); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (name != null && scope.isGlobal()) { [EOL]         typeRegistry.declareType(name, enumType.getElementsType()); [EOL]     } [EOL]     return enumType; [EOL] } <line_num>: 1005,1049
private void defineSlot(Node name, Node parent, JSType type) { [EOL]     defineSlot(name, parent, type, type == null); [EOL] } <line_num>: 1059,1061
void defineSlot(Node n, Node parent, JSType type, boolean inferred) { [EOL]     Preconditions.checkArgument(inferred || type != null); [EOL]     if (n.isName()) { [EOL]         Preconditions.checkArgument(parent.isFunction() || parent.isVar() || parent.isParamList() || parent.isCatch()); [EOL]     } else { [EOL]         Preconditions.checkArgument(n.isGetProp() && (parent.isAssign() || parent.isExprResult())); [EOL]     } [EOL]     defineSlot(n, parent, n.getQualifiedName(), type, inferred); [EOL] } <line_num>: 1075,1093
void defineSlot(Node n, Node parent, String variableName, JSType type, boolean inferred) { [EOL]     Preconditions.checkArgument(!variableName.isEmpty()); [EOL]     boolean isGlobalVar = n.isName() && scope.isGlobal(); [EOL]     boolean shouldDeclareOnGlobalThis = isGlobalVar && (parent.isVar() || parent.isFunction()); [EOL]     Scope scopeToDeclareIn = scope; [EOL]     if (n.isGetProp() && !scope.isGlobal() && isQnameRootedInGlobalScope(n)) { [EOL]         Scope globalScope = scope.getGlobalScope(); [EOL]         if (!globalScope.isDeclared(variableName, false)) { [EOL]             scopeToDeclareIn = scope.getGlobalScope(); [EOL]         } [EOL]     } [EOL]     boolean isExtern = n.isFromExterns(); [EOL]     Var newVar = null; [EOL]     CompilerInput input = compiler.getInput(inputId); [EOL]     if (scopeToDeclareIn.isDeclared(variableName, false)) { [EOL]         Var oldVar = scopeToDeclareIn.getVar(variableName); [EOL]         newVar = validator.expectUndeclaredVariable(sourceName, input, n, parent, oldVar, variableName, type); [EOL]     } else { [EOL]         if (type != null) { [EOL]             setDeferredType(n, type); [EOL]         } [EOL]         newVar = scopeToDeclareIn.declare(variableName, n, type, input, inferred); [EOL]         if (type instanceof EnumType) { [EOL]             Node initialValue = newVar.getInitialValue(); [EOL]             boolean isValidValue = initialValue != null && (initialValue.isObjectLit() || initialValue.isQualifiedName()); [EOL]             if (!isValidValue) { [EOL]                 compiler.report(JSError.make(sourceName, n, ENUM_INITIALIZER)); [EOL]             } [EOL]         } [EOL]     } [EOL]     FunctionType fnType = JSType.toMaybeFunctionType(type); [EOL]     if (fnType != null && !type.isEmptyType()) { [EOL]         if ((fnType.isConstructor() || fnType.isInterface()) && variableName.equals(fnType.getReferenceName())) { [EOL]             finishConstructorDefinition(n, variableName, fnType, scopeToDeclareIn, input, newVar); [EOL]         } [EOL]     } [EOL]     if (shouldDeclareOnGlobalThis) { [EOL]         ObjectType globalThis = typeRegistry.getNativeObjectType(GLOBAL_THIS); [EOL]         if (inferred) { [EOL]             globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, n); [EOL]         } else { [EOL]             globalThis.defineDeclaredProperty(variableName, type, n); [EOL]         } [EOL]     } [EOL]     if (isGlobalVar && "Window".equals(variableName) && type != null && type.isFunctionType() && type.isConstructor()) { [EOL]         FunctionType globalThisCtor = typeRegistry.getNativeObjectType(GLOBAL_THIS).getConstructor(); [EOL]         globalThisCtor.getInstanceType().clearCachedValues(); [EOL]         globalThisCtor.getPrototype().clearCachedValues(); [EOL]         globalThisCtor.setPrototypeBasedOn((type.toMaybeFunctionType()).getInstanceType()); [EOL]     } [EOL] } <line_num>: 1106,1204
private void finishConstructorDefinition(Node n, String variableName, FunctionType fnType, Scope scopeToDeclareIn, CompilerInput input, Var newVar) { [EOL]     FunctionType superClassCtor = fnType.getSuperClassConstructor(); [EOL]     Property prototypeSlot = fnType.getSlot("prototype"); [EOL]     prototypeSlot.setNode(n); [EOL]     String prototypeName = variableName + ".prototype"; [EOL]     Var prototypeVar = scopeToDeclareIn.getVar(prototypeName); [EOL]     if (prototypeVar != null && prototypeVar.scope == scopeToDeclareIn) { [EOL]         scopeToDeclareIn.undeclare(prototypeVar); [EOL]     } [EOL]     scopeToDeclareIn.declare(prototypeName, n, prototypeSlot.getType(), input, superClassCtor == null || superClassCtor.getInstanceType().isEquivalentTo(getNativeType(OBJECT_TYPE))); [EOL]     if (newVar.getInitialValue() == null && !n.isFromExterns()) { [EOL]         compiler.report(JSError.make(sourceName, n, fnType.isConstructor() ? CTOR_INITIALIZER : IFACE_INITIALIZER, variableName)); [EOL]     } [EOL] } <line_num>: 1206,1250
private boolean isQnameRootedInGlobalScope(Node n) { [EOL]     Scope scope = getQnameRootScope(n); [EOL]     return scope != null && scope.isGlobal(); [EOL] } <line_num>: 1255,1258
private Scope getQnameRootScope(Node n) { [EOL]     Node root = NodeUtil.getRootOfQualifiedName(n); [EOL]     if (root.isName()) { [EOL]         Var var = scope.getVar(root.getString()); [EOL]         if (var != null) { [EOL]             return var.getScope(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 1263,1272
private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) { [EOL]     if (info != null && info.hasType()) { [EOL]         return getDeclaredTypeInAnnotation(sourceName, lValue, info); [EOL]     } else if (rValue != null && rValue.isFunction() && shouldUseFunctionLiteralType(JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) { [EOL]         return rValue.getJSType(); [EOL]     } else if (info != null) { [EOL]         if (info.hasEnumParameterType()) { [EOL]             if (rValue != null && rValue.isObjectLit()) { [EOL]                 return rValue.getJSType(); [EOL]             } else { [EOL]                 return createEnumTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue); [EOL]             } [EOL]         } else if (info.isConstructor() || info.isInterface()) { [EOL]             return createFunctionTypeFromNodes(rValue, lValue.getQualifiedName(), info, lValue); [EOL]         } else { [EOL]             if (info.isConstant()) { [EOL]                 JSType knownType = null; [EOL]                 if (rValue != null) { [EOL]                     JSDocInfo rValueInfo = rValue.getJSDocInfo(); [EOL]                     if (rValueInfo != null && rValueInfo.hasType()) { [EOL]                         return rValueInfo.getType().evaluate(scope, typeRegistry); [EOL]                     } else if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) { [EOL]                         return rValue.getJSType(); [EOL]                     } else if (rValue.isOr()) { [EOL]                         Node firstClause = rValue.getFirstChild(); [EOL]                         Node secondClause = firstClause.getNext(); [EOL]                         boolean namesMatch = firstClause.isName() && lValue.isName() && firstClause.getString().equals(lValue.getString()); [EOL]                         if (namesMatch && secondClause.getJSType() != null && !secondClause.getJSType().isUnknownType()) { [EOL]                             return secondClause.getJSType(); [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return getDeclaredTypeInAnnotation(sourceName, lValue, info); [EOL] } <line_num>: 1283,1337
private FunctionType getFunctionType(@Nullable Var v) { [EOL]     JSType t = v == null ? null : v.getType(); [EOL]     ObjectType o = t == null ? null : t.dereference(); [EOL]     return JSType.toMaybeFunctionType(o); [EOL] } <line_num>: 1339,1343
private void checkForCallingConventionDefiningCalls(Node n, Map<String, String> delegateCallingConventions) { [EOL]     codingConvention.checkForCallingConventionDefiningCalls(n, delegateCallingConventions); [EOL] } <line_num>: 1348,1352
private void checkForClassDefiningCalls(NodeTraversal t, Node n, Node parent) { [EOL]     SubclassRelationship relationship = codingConvention.getClassesDefinedByCall(n); [EOL]     if (relationship != null) { [EOL]         FunctionType superCtor = getFunctionType(scope.getVar(relationship.superclassName)); [EOL]         FunctionType subCtor = getFunctionType(scope.getVar(relationship.subclassName)); [EOL]         if (superCtor != null && superCtor.isConstructor() && subCtor != null && subCtor.isConstructor()) { [EOL]             ObjectType superClass = superCtor.getInstanceType(); [EOL]             ObjectType subClass = subCtor.getInstanceType(); [EOL]             superCtor = superClass.getConstructor(); [EOL]             subCtor = subClass.getConstructor(); [EOL]             if (relationship.type == SubclassType.INHERITS && !superClass.isEmptyType() && !subClass.isEmptyType()) { [EOL]                 validator.expectSuperType(t, n, superClass, subClass); [EOL]             } [EOL]             if (superCtor != null && subCtor != null) { [EOL]                 codingConvention.applySubclassRelationship(superCtor, subCtor, relationship.type); [EOL]             } [EOL]         } [EOL]     } [EOL]     String singletonGetterClassName = codingConvention.getSingletonGetterClassName(n); [EOL]     if (singletonGetterClassName != null) { [EOL]         ObjectType objectType = ObjectType.cast(typeRegistry.getType(singletonGetterClassName)); [EOL]         if (objectType != null) { [EOL]             FunctionType functionType = objectType.getConstructor(); [EOL]             if (functionType != null) { [EOL]                 FunctionType getterType = typeRegistry.createFunctionType(objectType); [EOL]                 codingConvention.applySingletonGetter(functionType, getterType, objectType); [EOL]             } [EOL]         } [EOL]     } [EOL]     DelegateRelationship delegateRelationship = codingConvention.getDelegateRelationship(n); [EOL]     if (delegateRelationship != null) { [EOL]         applyDelegateRelationship(delegateRelationship); [EOL]     } [EOL]     ObjectLiteralCast objectLiteralCast = codingConvention.getObjectLiteralCast(n); [EOL]     if (objectLiteralCast != null) { [EOL]         if (objectLiteralCast.diagnosticType == null) { [EOL]             ObjectType type = ObjectType.cast(typeRegistry.getType(objectLiteralCast.typeName)); [EOL]             if (type != null && type.getConstructor() != null) { [EOL]                 setDeferredType(objectLiteralCast.objectNode, type); [EOL]             } else { [EOL]                 compiler.report(JSError.make(t.getSourceName(), n, CONSTRUCTOR_EXPECTED)); [EOL]             } [EOL]         } else { [EOL]             compiler.report(JSError.make(t.getSourceName(), n, objectLiteralCast.diagnosticType)); [EOL]         } [EOL]     } [EOL] } <line_num>: 1359,1431
private void applyDelegateRelationship(DelegateRelationship delegateRelationship) { [EOL]     ObjectType delegatorObject = ObjectType.cast(typeRegistry.getType(delegateRelationship.delegator)); [EOL]     ObjectType delegateBaseObject = ObjectType.cast(typeRegistry.getType(delegateRelationship.delegateBase)); [EOL]     ObjectType delegateSuperObject = ObjectType.cast(typeRegistry.getType(codingConvention.getDelegateSuperclassName())); [EOL]     if (delegatorObject != null && delegateBaseObject != null && delegateSuperObject != null) { [EOL]         FunctionType delegatorCtor = delegatorObject.getConstructor(); [EOL]         FunctionType delegateBaseCtor = delegateBaseObject.getConstructor(); [EOL]         FunctionType delegateSuperCtor = delegateSuperObject.getConstructor(); [EOL]         if (delegatorCtor != null && delegateBaseCtor != null && delegateSuperCtor != null) { [EOL]             FunctionParamBuilder functionParamBuilder = new FunctionParamBuilder(typeRegistry); [EOL]             functionParamBuilder.addRequiredParams(getNativeType(U2U_CONSTRUCTOR_TYPE)); [EOL]             FunctionType findDelegate = typeRegistry.createFunctionType(typeRegistry.createDefaultObjectUnion(delegateBaseObject), functionParamBuilder.build()); [EOL]             FunctionType delegateProxy = typeRegistry.createConstructorType(delegateBaseObject.getReferenceName() + DELEGATE_PROXY_SUFFIX, null, null, null, null); [EOL]             delegateProxy.setPrototypeBasedOn(delegateBaseObject); [EOL]             codingConvention.applyDelegateRelationship(delegateSuperObject, delegateBaseObject, delegatorObject, delegateProxy, findDelegate); [EOL]             delegateProxyPrototypes.add(delegateProxy.getPrototype()); [EOL]         } [EOL]     } [EOL] } <line_num>: 1436,1472
void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) { [EOL]     Node ownerNode = n.getFirstChild(); [EOL]     String ownerName = ownerNode.getQualifiedName(); [EOL]     String qName = n.getQualifiedName(); [EOL]     String propName = n.getLastChild().getString(); [EOL]     Preconditions.checkArgument(qName != null && ownerName != null); [EOL]     JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue); [EOL]     if (valueType == null && rhsValue != null) { [EOL]         valueType = rhsValue.getJSType(); [EOL]     } [EOL]     if ("prototype".equals(propName)) { [EOL]         Var qVar = scope.getVar(qName); [EOL]         if (qVar != null) { [EOL]             ObjectType qVarType = ObjectType.cast(qVar.getType()); [EOL]             if (qVarType != null && rhsValue != null && rhsValue.isObjectLit()) { [EOL]                 typeRegistry.resetImplicitPrototype(rhsValue.getJSType(), qVarType.getImplicitPrototype()); [EOL]             } else if (!qVar.isTypeInferred()) { [EOL]                 return; [EOL]             } [EOL]             if (qVar.getScope() == scope) { [EOL]                 scope.undeclare(qVar); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (valueType == null) { [EOL]         if (parent.isExprResult()) { [EOL]             stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName)); [EOL]         } [EOL]         return; [EOL]     } [EOL]     boolean inferred = isQualifiedNameInferred(qName, n, info, rhsValue, valueType); [EOL]     if (!inferred) { [EOL]         ObjectType ownerType = getObjectSlot(ownerName); [EOL]         if (ownerType != null) { [EOL]             boolean isExtern = t.getInput() != null && t.getInput().isExtern(); [EOL]             if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) { [EOL]                 ownerType.defineDeclaredProperty(propName, valueType, n); [EOL]             } [EOL]         } [EOL]         defineSlot(n, parent, valueType, inferred); [EOL]     } else if (rhsValue != null && rhsValue.isTrue()) { [EOL]         FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName)); [EOL]         if (ownerType != null) { [EOL]             JSType ownerTypeOfThis = ownerType.getTypeOfThis(); [EOL]             String delegateName = codingConvention.getDelegateSuperclassName(); [EOL]             JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName); [EOL]             if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) { [EOL]                 defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 1484,1591
private boolean isQualifiedNameInferred(String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) { [EOL]     if (valueType == null) { [EOL]         return true; [EOL]     } [EOL]     boolean inferred = true; [EOL]     if (info != null) { [EOL]         inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info)); [EOL]     } [EOL]     if (inferred && rhsValue != null && rhsValue.isFunction()) { [EOL]         if (info != null) { [EOL]             return false; [EOL]         } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) { [EOL]             for (Node current = n.getParent(); !(current.isScript() || current.isFunction()); current = current.getParent()) { [EOL]                 if (NodeUtil.isControlStructure(current)) { [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]             AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode()); [EOL]             if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return inferred; [EOL] } <line_num>: 1620,1663
private ObjectType getObjectSlot(String slotName) { [EOL]     Var ownerVar = scope.getVar(slotName); [EOL]     if (ownerVar != null) { [EOL]         JSType ownerVarType = ownerVar.getType(); [EOL]         return ObjectType.cast(ownerVarType == null ? null : ownerVarType.restrictByNotNullOrUndefined()); [EOL]     } [EOL]     return null; [EOL] } <line_num>: 1670,1678
void resolveStubDeclarations() { [EOL]     for (StubDeclaration stub : stubDeclarations) { [EOL]         Node n = stub.node; [EOL]         Node parent = n.getParent(); [EOL]         String qName = n.getQualifiedName(); [EOL]         String propName = n.getLastChild().getString(); [EOL]         String ownerName = stub.ownerName; [EOL]         boolean isExtern = stub.isExtern; [EOL]         if (scope.isDeclared(qName, false)) { [EOL]             continue; [EOL]         } [EOL]         ObjectType ownerType = getObjectSlot(ownerName); [EOL]         defineSlot(n, parent, unknownType, true); [EOL]         if (ownerType != null && (isExtern || ownerType.isFunctionPrototypeType())) { [EOL]             ownerType.defineInferredProperty(propName, unknownType, n); [EOL]         } else { [EOL]             typeRegistry.registerPropertyOnType(propName, ownerType == null ? unknownType : ownerType); [EOL]         } [EOL]     } [EOL] } <line_num>: 1684,1713
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (n.isExprResult()) { [EOL]         Node child = n.getFirstChild(); [EOL]         switch(child.getType()) { [EOL]             case Token.ASSIGN: [EOL]                 maybeCollectMember(t, child.getFirstChild(), child, child.getLastChild()); [EOL]                 break; [EOL]             case Token.GETPROP: [EOL]                 maybeCollectMember(t, child, child, null); [EOL]                 break; [EOL]         } [EOL]     } [EOL] } <line_num>: 1727,1741
private void maybeCollectMember(NodeTraversal t, Node member, Node nodeWithJsDocInfo, @Nullable Node value) { [EOL]     JSDocInfo info = nodeWithJsDocInfo.getJSDocInfo(); [EOL]     if (info == null || !member.isGetProp() || !member.getFirstChild().isThis()) { [EOL]         return; [EOL]     } [EOL]     member.getFirstChild().setJSType(thisType); [EOL]     JSType jsType = getDeclaredType(t.getSourceName(), info, member, value); [EOL]     Node name = member.getLastChild(); [EOL]     if (jsType != null && (name.isName() || name.isString()) && thisType.toObjectType() != null) { [EOL]         thisType.toObjectType().defineDeclaredProperty(name.getString(), jsType, member); [EOL]     } [EOL] } <line_num>: 1743,1767
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     super.visit(t, n, parent); [EOL]     switch(n.getType()) { [EOL]         case Token.VAR: [EOL]             if (n.hasOneChild()) { [EOL]                 checkForTypedef(t, n.getFirstChild(), n.getJSDocInfo()); [EOL]             } [EOL]             break; [EOL]     } [EOL] } <line_num>: 1804,1816
@Override [EOL] void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) { [EOL]     checkForTypedef(t, n, info); [EOL]     super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue); [EOL] } <line_num>: 1818,1824
private void checkForTypedef(NodeTraversal t, Node candidate, JSDocInfo info) { [EOL]     if (info == null || !info.hasTypedefType()) { [EOL]         return; [EOL]     } [EOL]     String typedef = candidate.getQualifiedName(); [EOL]     if (typedef == null) { [EOL]         return; [EOL]     } [EOL]     typeRegistry.declareType(typedef, unknownType); [EOL]     JSType realType = info.getTypedefType().evaluate(scope, typeRegistry); [EOL]     if (realType == null) { [EOL]         compiler.report(JSError.make(t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef)); [EOL]     } [EOL]     typeRegistry.overwriteDeclaredType(typedef, realType); [EOL]     if (candidate.isGetProp()) { [EOL]         defineSlot(candidate, candidate.getParent(), getNativeType(NO_TYPE), false); [EOL]     } [EOL] } <line_num>: 1832,1860
void build() { [EOL]     NodeTraversal.traverse(compiler, scope.getRootNode(), this); [EOL]     AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode()); [EOL]     if (contents != null) { [EOL]         for (String varName : contents.getEscapedVarNames()) { [EOL]             Var v = scope.getVar(varName); [EOL]             Preconditions.checkState(v.getScope() == scope); [EOL]             v.markEscaped(); [EOL]         } [EOL]         for (Multiset.Entry<String> entry : contents.getAssignedNameCounts().entrySet()) { [EOL]             Var v = scope.getVar(entry.getElement()); [EOL]             Preconditions.checkState(v.getScope() == scope); [EOL]             if (entry.getCount() == 1) { [EOL]                 v.markAssignedExactlyOnce(); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 1878,1899
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (n == scope.getRootNode()) [EOL]         return; [EOL]     if (n.isParamList() && parent == scope.getRootNode()) { [EOL]         handleFunctionInputs(parent); [EOL]         return; [EOL]     } [EOL]     super.visit(t, n, parent); [EOL] } <line_num>: 1909,1918
private void handleFunctionInputs(Node fnNode) { [EOL]     Node fnNameNode = fnNode.getFirstChild(); [EOL]     String fnName = fnNameNode.getString(); [EOL]     if (!fnName.isEmpty()) { [EOL]         Scope.Var fnVar = scope.getVar(fnName); [EOL]         if (fnVar == null || (fnVar.getNameNode() != null && fnVar.getInitialValue() != fnNode)) { [EOL]             defineSlot(fnNameNode, fnNode, fnNode.getJSType(), false); [EOL]         } [EOL]     } [EOL]     declareArguments(fnNode); [EOL] } <line_num>: 1921,1940
private void declareArguments(Node functionNode) { [EOL]     Node astParameters = functionNode.getFirstChild().getNext(); [EOL]     Node iifeArgumentNode = null; [EOL]     if (NodeUtil.isCallOrNewTarget(functionNode)) { [EOL]         iifeArgumentNode = functionNode.getNext(); [EOL]     } [EOL]     Node body = astParameters.getNext(); [EOL]     FunctionType functionType = JSType.toMaybeFunctionType(functionNode.getJSType()); [EOL]     if (functionType != null) { [EOL]         Node jsDocParameters = functionType.getParametersNode(); [EOL]         if (jsDocParameters != null) { [EOL]             Node jsDocParameter = jsDocParameters.getFirstChild(); [EOL]             for (Node astParameter : astParameters.children()) { [EOL]                 JSType paramType = jsDocParameter == null ? unknownType : jsDocParameter.getJSType(); [EOL]                 boolean inferred = paramType == null || paramType == unknownType; [EOL]                 if (iifeArgumentNode != null && inferred) { [EOL]                     String argumentName = iifeArgumentNode.getQualifiedName(); [EOL]                     Var argumentVar = argumentName == null || scope.getParent() == null ? null : scope.getParent().getVar(argumentName); [EOL]                     if (argumentVar != null && !argumentVar.isTypeInferred()) { [EOL]                         paramType = argumentVar.getType(); [EOL]                     } [EOL]                 } [EOL]                 if (paramType == null) { [EOL]                     paramType = unknownType; [EOL]                 } [EOL]                 defineSlot(astParameter, functionNode, paramType, inferred); [EOL]                 if (jsDocParameter != null) { [EOL]                     jsDocParameter = jsDocParameter.getNext(); [EOL]                 } [EOL]                 if (iifeArgumentNode != null) { [EOL]                     iifeArgumentNode = iifeArgumentNode.getNext(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 1945,1990
@Override [EOL] public void process(Node externs, Node root) { [EOL]     if (externs == null) { [EOL]         NodeTraversal.traverse(compiler, root, this); [EOL]     } else { [EOL]         NodeTraversal.traverseRoots(compiler, ImmutableList.of(externs, root), this); [EOL]     } [EOL] } <line_num>: 2008,2015
@Override [EOL] public void enterScope(NodeTraversal t) { [EOL]     if (!t.inGlobalScope()) { [EOL]         Node n = t.getScopeRoot(); [EOL]         data.put(n, new AstFunctionContents(n)); [EOL]     } [EOL] } <line_num>: 2017,2022
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (t.inGlobalScope()) { [EOL]         return; [EOL]     } [EOL]     if (n.isReturn() && n.getFirstChild() != null) { [EOL]         data.get(t.getScopeRoot()).recordNonEmptyReturn(); [EOL]     } [EOL]     if (t.getScopeDepth() <= 1) { [EOL]         return; [EOL]     } [EOL]     if (n.isName() && NodeUtil.isLValue(n) && !NodeUtil.isBleedingFunctionName(n)) { [EOL]         String name = n.getString(); [EOL]         Scope scope = t.getScope(); [EOL]         Var var = scope.getVar(name); [EOL]         if (var != null) { [EOL]             Scope ownerScope = var.getScope(); [EOL]             if (ownerScope.isLocal()) { [EOL]                 data.get(ownerScope.getRootNode()).recordAssignedName(name); [EOL]             } [EOL]             if (scope != ownerScope && ownerScope.isLocal()) { [EOL]                 data.get(ownerScope.getRootNode()).recordEscapedVarName(name); [EOL]             } [EOL]         } [EOL]     } else if (n.isGetProp() && n.isUnscopedQualifiedName() && NodeUtil.isLValue(n)) { [EOL]         String name = NodeUtil.getRootOfQualifiedName(n).getString(); [EOL]         Scope scope = t.getScope(); [EOL]         Var var = scope.getVar(name); [EOL]         if (var != null) { [EOL]             Scope ownerScope = var.getScope(); [EOL]             if (scope != ownerScope && ownerScope.isLocal()) { [EOL]                 data.get(ownerScope.getRootNode()).recordEscapedQualifiedName(n.getQualifiedName()); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 2024,2075
private AstFunctionContents getFunctionAnalysisResults(@Nullable Node n) { [EOL]     if (n == null) { [EOL]         return null; [EOL]     } [EOL]     return functionAnalysisResults.get(n); [EOL] } <line_num>: 2078,2086
