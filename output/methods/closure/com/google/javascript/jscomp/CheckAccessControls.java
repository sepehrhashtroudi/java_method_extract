CheckAccessControls(AbstractCompiler compiler) { [EOL]     this.compiler = compiler; [EOL]     this.validator = compiler.getTypeValidator(); [EOL]     this.initializedConstantProperties = HashMultimap.create(); [EOL] } <line_num>: 122,126
@Override [EOL] public void process(Node externs, Node root) { [EOL]     NodeTraversal.traverse(compiler, root, this); [EOL] } <line_num>: 128,131
@Override [EOL] public void hotSwapScript(Node scriptRoot, Node originalRoot) { [EOL]     NodeTraversal.traverse(compiler, scriptRoot, this); [EOL] } <line_num>: 133,136
@Override [EOL] public void enterScope(NodeTraversal t) { [EOL]     if (!t.inGlobalScope()) { [EOL]         Node n = t.getScopeRoot(); [EOL]         Node parent = n.getParent(); [EOL]         if (isDeprecatedFunction(n, parent)) { [EOL]             deprecatedDepth++; [EOL]         } [EOL]         if (methodDepth == 0) { [EOL]             currentClass = getClassOfMethod(n, parent); [EOL]         } [EOL]         methodDepth++; [EOL]     } [EOL] } <line_num>: 138,152
@Override [EOL] public void exitScope(NodeTraversal t) { [EOL]     if (!t.inGlobalScope()) { [EOL]         Node n = t.getScopeRoot(); [EOL]         Node parent = n.getParent(); [EOL]         if (isDeprecatedFunction(n, parent)) { [EOL]             deprecatedDepth--; [EOL]         } [EOL]         methodDepth--; [EOL]         if (methodDepth == 0) { [EOL]             currentClass = null; [EOL]         } [EOL]     } [EOL] } <line_num>: 154,168
private JSType getClassOfMethod(Node n, Node parent) { [EOL]     if (parent.isAssign()) { [EOL]         Node lValue = parent.getFirstChild(); [EOL]         if (NodeUtil.isGet(lValue)) { [EOL]             JSType lValueType = lValue.getJSType(); [EOL]             if (lValueType != null && lValueType.isNominalConstructor()) { [EOL]                 return (lValueType.toMaybeFunctionType()).getInstanceType(); [EOL]             } else { [EOL]                 return normalizeClassType(lValue.getFirstChild().getJSType()); [EOL]             } [EOL]         } else { [EOL]             return normalizeClassType(lValue.getJSType()); [EOL]         } [EOL]     } else if (NodeUtil.isFunctionDeclaration(n) || parent.isName()) { [EOL]         return normalizeClassType(n.getJSType()); [EOL]     } [EOL]     return null; [EOL] } <line_num>: 174,200
private JSType normalizeClassType(JSType type) { [EOL]     if (type == null || type.isUnknownType()) { [EOL]         return type; [EOL]     } else if (type.isNominalConstructor()) { [EOL]         return (type.toMaybeFunctionType()).getInstanceType(); [EOL]     } else if (type.isFunctionPrototypeType()) { [EOL]         FunctionType owner = ((ObjectType) type).getOwnerFunction(); [EOL]         if (owner.isConstructor()) { [EOL]             return owner.getInstanceType(); [EOL]         } [EOL]     } [EOL]     return type; [EOL] } <line_num>: 206,218
@Override [EOL] public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { [EOL]     return true; [EOL] } <line_num>: 220,223
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     switch(n.getType()) { [EOL]         case Token.NAME: [EOL]             checkNameDeprecation(t, n, parent); [EOL]             checkNameVisibility(t, n, parent); [EOL]             break; [EOL]         case Token.GETPROP: [EOL]             checkPropertyDeprecation(t, n, parent); [EOL]             checkPropertyVisibility(t, n, parent); [EOL]             checkConstantProperty(t, n); [EOL]             break; [EOL]         case Token.NEW: [EOL]             checkConstructorDeprecation(t, n, parent); [EOL]             break; [EOL]         case Token.FUNCTION: [EOL]             checkFinalClassOverrides(t, n, parent); [EOL]             break; [EOL]     } [EOL] } <line_num>: 225,244
private void checkConstructorDeprecation(NodeTraversal t, Node n, Node parent) { [EOL]     JSType type = n.getJSType(); [EOL]     if (type != null) { [EOL]         String deprecationInfo = getTypeDeprecationInfo(type); [EOL]         if (deprecationInfo != null && shouldEmitDeprecationWarning(t, n, parent)) { [EOL]             if (!deprecationInfo.isEmpty()) { [EOL]                 compiler.report(t.makeError(n, DEPRECATED_CLASS_REASON, type.toString(), deprecationInfo)); [EOL]             } else { [EOL]                 compiler.report(t.makeError(n, DEPRECATED_CLASS, type.toString())); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 249,269
private void checkNameDeprecation(NodeTraversal t, Node n, Node parent) { [EOL]     if (parent.isFunction() || parent.isVar() || parent.isNew()) { [EOL]         return; [EOL]     } [EOL]     Scope.Var var = t.getScope().getVar(n.getString()); [EOL]     JSDocInfo docInfo = var == null ? null : var.getJSDocInfo(); [EOL]     if (docInfo != null && docInfo.isDeprecated() && shouldEmitDeprecationWarning(t, n, parent)) { [EOL]         if (docInfo.getDeprecationReason() != null) { [EOL]             compiler.report(t.makeError(n, DEPRECATED_NAME_REASON, n.getString(), docInfo.getDeprecationReason())); [EOL]         } else { [EOL]             compiler.report(t.makeError(n, DEPRECATED_NAME, n.getString())); [EOL]         } [EOL]     } [EOL] } <line_num>: 274,296
private void checkPropertyDeprecation(NodeTraversal t, Node n, Node parent) { [EOL]     if (parent.isNew()) { [EOL]         return; [EOL]     } [EOL]     ObjectType objectType = ObjectType.cast(dereference(n.getFirstChild().getJSType())); [EOL]     String propertyName = n.getLastChild().getString(); [EOL]     if (objectType != null) { [EOL]         String deprecationInfo = getPropertyDeprecationInfo(objectType, propertyName); [EOL]         if (deprecationInfo != null && shouldEmitDeprecationWarning(t, n, parent)) { [EOL]             if (!deprecationInfo.isEmpty()) { [EOL]                 compiler.report(t.makeError(n, DEPRECATED_PROP_REASON, propertyName, validator.getReadableJSTypeName(n.getFirstChild(), true), deprecationInfo)); [EOL]             } else { [EOL]                 compiler.report(t.makeError(n, DEPRECATED_PROP, propertyName, validator.getReadableJSTypeName(n.getFirstChild(), true))); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 302,331
private void checkNameVisibility(NodeTraversal t, Node name, Node parent) { [EOL]     Var var = t.getScope().getVar(name.getString()); [EOL]     if (var != null) { [EOL]         JSDocInfo docInfo = var.getJSDocInfo(); [EOL]         if (docInfo != null) { [EOL]             Visibility visibility = docInfo.getVisibility(); [EOL]             if (visibility == Visibility.PRIVATE) { [EOL]                 StaticSourceFile varSrc = var.getSourceFile(); [EOL]                 StaticSourceFile refSrc = name.getStaticSourceFile(); [EOL]                 if (varSrc != null && refSrc != null && !varSrc.getName().equals(refSrc.getName())) { [EOL]                     if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) { [EOL]                         return; [EOL]                     } [EOL]                     compiler.report(t.makeError(name, BAD_PRIVATE_GLOBAL_ACCESS, name.getString(), varSrc.getName())); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 338,363
private void checkFinalClassOverrides(NodeTraversal t, Node fn, Node parent) { [EOL]     JSType type = fn.getJSType().toMaybeFunctionType(); [EOL]     if (type != null && type.isConstructor()) { [EOL]         JSType finalParentClass = getFinalParentClass(getClassOfMethod(fn, parent)); [EOL]         if (finalParentClass != null) { [EOL]             compiler.report(t.makeError(fn, EXTEND_FINAL_CLASS, type.getDisplayName(), finalParentClass.getDisplayName())); [EOL]         } [EOL]     } [EOL] } <line_num>: 370,380
private void checkConstantProperty(NodeTraversal t, Node getprop) { [EOL]     Node parent = getprop.getParent(); [EOL]     boolean isDelete = parent.isDelProp(); [EOL]     if (!(NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == getprop) && !parent.isInc() && !parent.isDec() && !isDelete) { [EOL]         return; [EOL]     } [EOL]     ObjectType objectType = ObjectType.cast(dereference(getprop.getFirstChild().getJSType())); [EOL]     String propertyName = getprop.getLastChild().getString(); [EOL]     boolean isConstant = isPropertyDeclaredConstant(objectType, propertyName); [EOL]     if (isConstant) { [EOL]         if (isDelete) { [EOL]             compiler.report(t.makeError(getprop, CONST_PROPERTY_DELETED, propertyName)); [EOL]             return; [EOL]         } [EOL]         ObjectType oType = objectType; [EOL]         while (oType != null) { [EOL]             if (oType.hasReferenceName()) { [EOL]                 if (initializedConstantProperties.containsEntry(oType.getReferenceName(), propertyName)) { [EOL]                     compiler.report(t.makeError(getprop, CONST_PROPERTY_REASSIGNED_VALUE, propertyName)); [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             oType = oType.getImplicitPrototype(); [EOL]         } [EOL]         Preconditions.checkState(objectType.hasReferenceName()); [EOL]         initializedConstantProperties.put(objectType.getReferenceName(), propertyName); [EOL]         if (objectType.isInstanceType()) { [EOL]             ObjectType prototype = objectType.getImplicitPrototype(); [EOL]             if (prototype != null) { [EOL]                 if (prototype.hasProperty(propertyName) && prototype.hasReferenceName()) { [EOL]                     initializedConstantProperties.put(prototype.getReferenceName(), propertyName); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 387,442
private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) { [EOL]     ObjectType objectType = ObjectType.cast(dereference(getprop.getFirstChild().getJSType())); [EOL]     String propertyName = getprop.getLastChild().getString(); [EOL]     if (objectType != null) { [EOL]         boolean isOverride = parent.getJSDocInfo() != null && parent.isAssign() && parent.getFirstChild() == getprop; [EOL]         if (isOverride) { [EOL]             objectType = objectType.getImplicitPrototype(); [EOL]         } [EOL]         JSDocInfo docInfo = null; [EOL]         for (; objectType != null; objectType = objectType.getImplicitPrototype()) { [EOL]             docInfo = objectType.getOwnPropertyJSDocInfo(propertyName); [EOL]             if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (objectType == null) { [EOL]             return; [EOL]         } [EOL]         String referenceSource = getprop.getSourceFileName(); [EOL]         String definingSource = docInfo.getSourceName(); [EOL]         boolean sameInput = referenceSource != null && referenceSource.equals(definingSource); [EOL]         Visibility visibility = docInfo.getVisibility(); [EOL]         JSType ownerType = normalizeClassType(objectType); [EOL]         if (isOverride) { [EOL]             JSDocInfo overridingInfo = parent.getJSDocInfo(); [EOL]             Visibility overridingVisibility = overridingInfo == null ? Visibility.INHERITED : overridingInfo.getVisibility(); [EOL]             if (visibility == Visibility.PRIVATE && !sameInput) { [EOL]                 compiler.report(t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString())); [EOL]             } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) { [EOL]                 compiler.report(t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name())); [EOL]             } [EOL]         } else { [EOL]             if (sameInput) { [EOL]                 return; [EOL]             } else if (visibility == Visibility.PRIVATE && (currentClass == null || !ownerType.isEquivalentTo(currentClass))) { [EOL]                 if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) { [EOL]                     return; [EOL]                 } [EOL]                 compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true))); [EOL]             } else if (visibility == Visibility.PROTECTED) { [EOL]                 if (currentClass == null || !currentClass.isSubtype(ownerType)) { [EOL]                     compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName(getprop.getFirstChild(), true))); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 449,544
private static boolean isValidPrivateConstructorAccess(Node parent) { [EOL]     return !parent.isNew(); [EOL] } <line_num>: 560,562
private boolean shouldEmitDeprecationWarning(NodeTraversal t, Node n, Node parent) { [EOL]     if (t.inGlobalScope()) { [EOL]         if (!((parent.isCall() && parent.getFirstChild() == n) || n.isNew())) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if (n.isGetProp() && n == parent.getFirstChild() && NodeUtil.isAssignmentOp(parent)) { [EOL]         return false; [EOL]     } [EOL]     return !canAccessDeprecatedTypes(t); [EOL] } <line_num>: 570,591
private boolean canAccessDeprecatedTypes(NodeTraversal t) { [EOL]     Node scopeRoot = t.getScopeRoot(); [EOL]     Node scopeRootParent = scopeRoot.getParent(); [EOL]     return (deprecatedDepth > 0) || (getTypeDeprecationInfo(t.getScope().getTypeOfThis()) != null) || (scopeRootParent != null && scopeRootParent.isAssign() && getTypeDeprecationInfo(getClassOfMethod(scopeRoot, scopeRootParent)) != null); [EOL] } <line_num>: 603,615
private static boolean isDeprecatedFunction(Node n, Node parent) { [EOL]     if (n.isFunction()) { [EOL]         JSType type = n.getJSType(); [EOL]         if (type != null) { [EOL]             return getTypeDeprecationInfo(type) != null; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 620,629
private static String getTypeDeprecationInfo(JSType type) { [EOL]     if (type == null) { [EOL]         return null; [EOL]     } [EOL]     JSDocInfo info = type.getJSDocInfo(); [EOL]     if (info != null && info.isDeprecated()) { [EOL]         if (info.getDeprecationReason() != null) { [EOL]             return info.getDeprecationReason(); [EOL]         } [EOL]         return ""; [EOL]     } [EOL]     ObjectType objType = ObjectType.cast(type); [EOL]     if (objType != null) { [EOL]         ObjectType implicitProto = objType.getImplicitPrototype(); [EOL]         if (implicitProto != null) { [EOL]             return getTypeDeprecationInfo(implicitProto); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 636,656
private static boolean isPropertyDeclaredConstant(ObjectType objectType, String prop) { [EOL]     for (; objectType != null && objectType.hasReferenceName(); objectType = objectType.getImplicitPrototype()) { [EOL]         JSDocInfo docInfo = objectType.getOwnPropertyJSDocInfo(prop); [EOL]         if (docInfo != null && docInfo.isConstant()) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 661,674
private static String getPropertyDeprecationInfo(ObjectType type, String prop) { [EOL]     JSDocInfo info = type.getOwnPropertyJSDocInfo(prop); [EOL]     if (info != null && info.isDeprecated()) { [EOL]         if (info.getDeprecationReason() != null) { [EOL]             return info.getDeprecationReason(); [EOL]         } [EOL]         return ""; [EOL]     } [EOL]     ObjectType implicitProto = type.getImplicitPrototype(); [EOL]     if (implicitProto != null) { [EOL]         return getPropertyDeprecationInfo(implicitProto, prop); [EOL]     } [EOL]     return null; [EOL] } <line_num>: 681,696
private static JSType dereference(JSType type) { [EOL]     return type == null ? null : type.dereference(); [EOL] } <line_num>: 701,703
private JSType getFinalParentClass(JSType type) { [EOL]     if (type != null) { [EOL]         ObjectType iproto = ObjectType.cast(type).getImplicitPrototype(); [EOL]         while (iproto != null && iproto.getConstructor() == null) { [EOL]             iproto = iproto.getImplicitPrototype(); [EOL]         } [EOL]         if (iproto != null) { [EOL]             Node source = iproto.getConstructor().getSource(); [EOL]             JSDocInfo jsDoc = source != null ? NodeUtil.getBestJSDocInfo(source) : null; [EOL]             if (jsDoc != null && jsDoc.isConstant()) { [EOL]                 return iproto; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 708,723
