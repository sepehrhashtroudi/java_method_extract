AmbiguateProperties(AbstractCompiler compiler, char[] reservedCharacters) { [EOL]     Preconditions.checkState(compiler.getLifeCycleStage().isNormalized()); [EOL]     this.compiler = compiler; [EOL]     this.reservedCharacters = reservedCharacters; [EOL]     JSTypeRegistry r = compiler.getTypeRegistry(); [EOL]     invalidatingTypes = Sets.newHashSet(r.getNativeType(JSTypeNative.ALL_TYPE), r.getNativeType(JSTypeNative.NO_OBJECT_TYPE), r.getNativeType(JSTypeNative.NO_TYPE), r.getNativeType(JSTypeNative.NULL_TYPE), r.getNativeType(JSTypeNative.VOID_TYPE), r.getNativeType(JSTypeNative.FUNCTION_FUNCTION_TYPE), r.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE), r.getNativeType(JSTypeNative.FUNCTION_PROTOTYPE), r.getNativeType(JSTypeNative.GLOBAL_THIS), r.getNativeType(JSTypeNative.OBJECT_TYPE), r.getNativeType(JSTypeNative.OBJECT_PROTOTYPE), r.getNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE), r.getNativeType(JSTypeNative.TOP_LEVEL_PROTOTYPE), r.getNativeType(JSTypeNative.UNKNOWN_TYPE)); [EOL]     for (TypeMismatch mis : compiler.getTypeValidator().getMismatches()) { [EOL]         addInvalidatingType(mis.typeA); [EOL]         addInvalidatingType(mis.typeB); [EOL]     } [EOL] } <line_num>: 130,157
PropertyGraph(Collection<Property> props) { [EOL]     for (Property prop : props) { [EOL]         nodes.put(prop, new PropertyGraphNode(prop)); [EOL]     } [EOL] } <line_num>: 344,348
PropertyGraphNode(Property property) { [EOL]     this.property = property; [EOL] } <line_num>: 410,412
Property(String name) { [EOL]     this.oldName = name; [EOL]     if (name.startsWith(SKIP_PREFIX)) { [EOL]         skipAmbiguating = true; [EOL]     } [EOL] } <line_num>: 572,579
private JSTypeBitSet(int size) { [EOL]     super(size); [EOL] } <line_num>: 618,620
private JSTypeBitSet() { [EOL]     super(); [EOL] } <line_num>: 622,624
@Override [EOL] public int compare(Property p1, Property p2) { [EOL]     if (p1.numOccurrences != p2.numOccurrences) { [EOL]         return p2.numOccurrences - p1.numOccurrences; [EOL]     } [EOL]     return p1.oldName.compareTo(p2.oldName); [EOL] } <line_num>: 103,109
private void addInvalidatingType(JSType type) { [EOL]     type = type.restrictByNotNullOrUndefined(); [EOL]     if (type.isUnionType()) { [EOL]         for (JSType alt : type.toMaybeUnionType().getAlternates()) { [EOL]             addInvalidatingType(alt); [EOL]         } [EOL]     } [EOL]     invalidatingTypes.add(type); [EOL]     ObjectType objType = ObjectType.cast(type); [EOL]     if (objType != null && objType.isInstanceType()) { [EOL]         invalidatingTypes.add(objType.getImplicitPrototype()); [EOL]     } [EOL] } <line_num>: 162,175
Map<String, String> getRenamingMap() { [EOL]     return renamingMap; [EOL] } <line_num>: 177,179
private int getIntForType(JSType type) { [EOL]     if (intForType.containsKey(type)) { [EOL]         return intForType.get(type).intValue(); [EOL]     } [EOL]     int newInt = intForType.size() + 1; [EOL]     intForType.put(type, newInt); [EOL]     return newInt; [EOL] } <line_num>: 182,189
@Override [EOL] public void process(Node externs, Node root) { [EOL]     NodeTraversal.traverse(compiler, externs, new ProcessExterns()); [EOL]     NodeTraversal.traverse(compiler, root, new ProcessProperties()); [EOL]     Set<String> reservedNames = new HashSet<String>(externedNames.size() + quotedNames.size()); [EOL]     reservedNames.addAll(externedNames); [EOL]     reservedNames.addAll(quotedNames); [EOL]     int numRenamedPropertyNames = 0; [EOL]     int numSkippedPropertyNames = 0; [EOL]     Set<Property> propsByFreq = new TreeSet<Property>(FREQUENCY_COMPARATOR); [EOL]     for (Property p : propertyMap.values()) { [EOL]         if (!p.skipAmbiguating) { [EOL]             ++numRenamedPropertyNames; [EOL]             propsByFreq.add(p); [EOL]         } else { [EOL]             ++numSkippedPropertyNames; [EOL]             reservedNames.add(p.oldName); [EOL]         } [EOL]     } [EOL]     PropertyGraph graph = new PropertyGraph(Lists.newLinkedList(propsByFreq)); [EOL]     GraphColoring<Property, Void> coloring = new GreedyGraphColoring<Property, Void>(graph, FREQUENCY_COMPARATOR); [EOL]     int numNewPropertyNames = coloring.color(); [EOL]     NameGenerator nameGen = new NameGenerator(reservedNames, "", reservedCharacters); [EOL]     Map<Integer, String> colorMap = Maps.newHashMap(); [EOL]     for (int i = 0; i < numNewPropertyNames; ++i) { [EOL]         colorMap.put(i, nameGen.generateNextName()); [EOL]     } [EOL]     for (GraphNode<Property, Void> node : graph.getNodes()) { [EOL]         node.getValue().newName = colorMap.get(node.getAnnotation().hashCode()); [EOL]         renamingMap.put(node.getValue().oldName, node.getValue().newName); [EOL]     } [EOL]     for (Node n : stringNodesToRename) { [EOL]         String oldName = n.getString(); [EOL]         Property p = propertyMap.get(oldName); [EOL]         if (p != null && p.newName != null) { [EOL]             Preconditions.checkState(oldName.equals(p.oldName)); [EOL]             if (!p.newName.equals(oldName)) { [EOL]                 n.setString(p.newName); [EOL]                 compiler.reportCodeChange(); [EOL]             } [EOL]         } [EOL]     } [EOL]     logger.fine("Collapsed " + numRenamedPropertyNames + " properties into " + numNewPropertyNames + " and skipped renaming " + numSkippedPropertyNames + " properties."); [EOL] } <line_num>: 191,246
private BitSet getRelatedTypesOnNonUnion(JSType type) { [EOL]     if (relatedBitsets.containsKey(type)) { [EOL]         return relatedBitsets.get(type); [EOL]     } else { [EOL]         throw new RuntimeException("Related types should have been computed for" + " type: " + type + " but have not been."); [EOL]     } [EOL] } <line_num>: 248,257
private void computeRelatedTypes(JSType type) { [EOL]     if (type.isUnionType()) { [EOL]         type = type.restrictByNotNullOrUndefined(); [EOL]         if (type.isUnionType()) { [EOL]             for (JSType alt : type.toMaybeUnionType().getAlternates()) { [EOL]                 computeRelatedTypes(alt); [EOL]             } [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (relatedBitsets.containsKey(type)) { [EOL]         return; [EOL]     } [EOL]     JSTypeBitSet related = new JSTypeBitSet(intForType.size()); [EOL]     relatedBitsets.put(type, related); [EOL]     related.set(getIntForType(type)); [EOL]     if (type.isFunctionPrototypeType()) { [EOL]         addRelatedInstance(((ObjectType) type).getOwnerFunction(), related); [EOL]         return; [EOL]     } [EOL]     FunctionType constructor = type.toObjectType().getConstructor(); [EOL]     if (constructor != null && constructor.getSubTypes() != null) { [EOL]         for (FunctionType subType : constructor.getSubTypes()) { [EOL]             addRelatedInstance(subType, related); [EOL]         } [EOL]     } [EOL]     for (FunctionType implementor : compiler.getTypeRegistry().getDirectImplementors(type.toObjectType())) { [EOL]         addRelatedInstance(implementor, related); [EOL]     } [EOL] } <line_num>: 283,322
private void addRelatedInstance(FunctionType constructor, JSTypeBitSet related) { [EOL]     if (constructor.hasInstanceType()) { [EOL]         ObjectType instanceType = constructor.getInstanceType(); [EOL]         related.set(getIntForType(instanceType.getImplicitPrototype())); [EOL]         computeRelatedTypes(instanceType); [EOL]         related.or(relatedBitsets.get(instanceType)); [EOL]     } [EOL] } <line_num>: 328,339
@Override [EOL] public List<GraphNode<Property, Void>> getNodes() { [EOL]     return Lists.<GraphNode<Property, Void>>newArrayList(nodes.values()); [EOL] } <line_num>: 350,353
@Override [EOL] public GraphNode<Property, Void> getNode(Property property) { [EOL]     return nodes.get(property); [EOL] } <line_num>: 355,358
@Override [EOL] public SubGraph<Property, Void> newSubGraph() { [EOL]     return new PropertySubGraph(); [EOL] } <line_num>: 360,363
@Override [EOL] public void clearNodeAnnotations() { [EOL]     for (PropertyGraphNode node : nodes.values()) { [EOL]         node.setAnnotation(null); [EOL]     } [EOL] } <line_num>: 365,370
@Override [EOL] public int getWeight(Property value) { [EOL]     return value.numOccurrences; [EOL] } <line_num>: 372,375
@Override [EOL] public boolean isIndependentOf(Property prop) { [EOL]     return !relatedTypes.intersects(prop.relatedTypes); [EOL] } <line_num>: 391,394
@Override [EOL] public void addNode(Property prop) { [EOL]     relatedTypes.or(prop.relatedTypes); [EOL] } <line_num>: 400,403
@Override [EOL] public Property getValue() { [EOL]     return property; [EOL] } <line_num>: 414,417
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public <A extends Annotation> A getAnnotation() { [EOL]     return (A) annotation; [EOL] } <line_num>: 419,423
@Override [EOL] public void setAnnotation(Annotation data) { [EOL]     annotation = data; [EOL] } <line_num>: 425,428
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     switch(n.getType()) { [EOL]         case Token.GETPROP: [EOL]             Node dest = n.getFirstChild().getNext(); [EOL]             externedNames.add(dest.getString()); [EOL]             break; [EOL]         case Token.OBJECTLIT: [EOL]             for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { [EOL]                 externedNames.add(child.getString()); [EOL]             } [EOL]             break; [EOL]     } [EOL] } <line_num>: 433,449
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     switch(n.getType()) { [EOL]         case Token.GETPROP: [EOL]             { [EOL]                 Node propNode = n.getFirstChild().getNext(); [EOL]                 JSType jstype = getJSType(n.getFirstChild()); [EOL]                 maybeMarkCandidate(propNode, jstype, t); [EOL]                 break; [EOL]             } [EOL]         case Token.OBJECTLIT: [EOL]             for (Node key = n.getFirstChild(); key != null; key = key.getNext()) { [EOL]                 if (!key.isQuotedString()) { [EOL]                     JSType jstype = getJSType(n.getFirstChild()); [EOL]                     maybeMarkCandidate(key, jstype, t); [EOL]                 } else { [EOL]                     quotedNames.add(key.getString()); [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Token.GETELEM: [EOL]             Node child = n.getLastChild(); [EOL]             if (child.isString()) { [EOL]                 quotedNames.add(child.getString()); [EOL]             } [EOL]             break; [EOL]     } [EOL] } <line_num>: 454,490
private void maybeMarkCandidate(Node n, JSType type, NodeTraversal t) { [EOL]     String name = n.getString(); [EOL]     if (!externedNames.contains(name)) { [EOL]         stringNodesToRename.add(n); [EOL]         recordProperty(name, type); [EOL]     } [EOL] } <line_num>: 499,505
private Property recordProperty(String name, JSType type) { [EOL]     Property prop = getProperty(name); [EOL]     prop.addType(type); [EOL]     return prop; [EOL] } <line_num>: 507,511
private boolean isInvalidatingType(JSType type) { [EOL]     if (type.isUnionType()) { [EOL]         type = type.restrictByNotNullOrUndefined(); [EOL]         if (type.isUnionType()) { [EOL]             for (JSType alt : type.toMaybeUnionType().getAlternates()) { [EOL]                 if (isInvalidatingType(alt)) { [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]             return false; [EOL]         } [EOL]     } [EOL]     ObjectType objType = ObjectType.cast(type); [EOL]     return objType == null || invalidatingTypes.contains(objType) || !objType.hasReferenceName() || objType.isUnknownType() || objType.isEmptyType() || objType.isEnumType() || objType.autoboxesTo() != null; [EOL] } <line_num>: 515,535
private Property getProperty(String name) { [EOL]     Property prop = propertyMap.get(name); [EOL]     if (prop == null) { [EOL]         prop = new Property(name); [EOL]         propertyMap.put(name, prop); [EOL]     } [EOL]     return prop; [EOL] } <line_num>: 537,544
private JSType getJSType(Node n) { [EOL]     JSType jsType = n.getJSType(); [EOL]     if (jsType == null) { [EOL]         return compiler.getTypeRegistry().getNativeType(JSTypeNative.UNKNOWN_TYPE); [EOL]     } else { [EOL]         return jsType; [EOL]     } [EOL] } <line_num>: 550,562
void addType(JSType newType) { [EOL]     if (skipAmbiguating) { [EOL]         return; [EOL]     } [EOL]     ++numOccurrences; [EOL]     if (newType.isUnionType()) { [EOL]         newType = newType.restrictByNotNullOrUndefined(); [EOL]         if (newType.isUnionType()) { [EOL]             for (JSType alt : newType.toMaybeUnionType().getAlternates()) { [EOL]                 addNonUnionType(alt); [EOL]             } [EOL]             return; [EOL]         } [EOL]     } [EOL]     addNonUnionType(newType); [EOL] } <line_num>: 582,599
private void addNonUnionType(JSType newType) { [EOL]     if (skipAmbiguating || isInvalidatingType(newType)) { [EOL]         skipAmbiguating = true; [EOL]         return; [EOL]     } [EOL]     if (!relatedTypes.get(getIntForType(newType))) { [EOL]         computeRelatedTypes(newType); [EOL]         relatedTypes.or(getRelatedTypesOnNonUnion(newType)); [EOL]     } [EOL] } <line_num>: 601,611
@Override [EOL] public String toString() { [EOL]     int from = 0; [EOL]     int current = 0; [EOL]     List<String> types = Lists.newArrayList(); [EOL]     while (-1 != (current = nextSetBit(from))) { [EOL]         types.add(intForType.inverse().get(current).toString()); [EOL]         from = current + 1; [EOL]     } [EOL]     return Joiner.on(" && ").join(types); [EOL] } <line_num>: 629,639
