private CodeGenerator(CodeConsumer consumer) { [EOL]     cc = consumer; [EOL]     outputCharsetEncoder = null; [EOL]     preferSingleQuotes = false; [EOL]     trustedStrings = true; [EOL] } <line_num>: 54,59
CodeGenerator(CodeConsumer consumer, CompilerOptions options) { [EOL]     cc = consumer; [EOL]     Charset outputCharset = options.getOutputCharset(); [EOL]     if (outputCharset == null || outputCharset == Charsets.US_ASCII) { [EOL]         this.outputCharsetEncoder = null; [EOL]     } else { [EOL]         this.outputCharsetEncoder = outputCharset.newEncoder(); [EOL]     } [EOL]     this.preferSingleQuotes = options.preferSingleQuotes; [EOL]     this.trustedStrings = options.trustedStrings; [EOL] } <line_num>: 65,82
static CodeGenerator forCostEstimation(CodeConsumer consumer) { [EOL]     return new CodeGenerator(consumer); [EOL] } <line_num>: 61,63
public void tagAsStrict() { [EOL]     add("'use strict';"); [EOL] } <line_num>: 87,89
void add(String str) { [EOL]     cc.add(str); [EOL] } <line_num>: 91,93
private void addIdentifier(String identifier) { [EOL]     cc.addIdentifier(identifierEscape(identifier)); [EOL] } <line_num>: 95,97
void add(Node n) { [EOL]     add(n, Context.OTHER); [EOL] } <line_num>: 99,101
void add(Node n, Context context) { [EOL]     if (!cc.continueProcessing()) { [EOL]         return; [EOL]     } [EOL]     int type = n.getType(); [EOL]     String opstr = NodeUtil.opToStr(type); [EOL]     int childCount = n.getChildCount(); [EOL]     Node first = n.getFirstChild(); [EOL]     Node last = n.getLastChild(); [EOL]     if (opstr != null && first != last) { [EOL]         Preconditions.checkState(childCount == 2, "Bad binary operator \"%s\": expected 2 arguments but got %s", opstr, childCount); [EOL]         int p = NodeUtil.precedence(type); [EOL]         Context rhsContext = getContextForNoInOperator(context); [EOL]         if (last.getType() == type && NodeUtil.isAssociative(type)) { [EOL]             addExpr(first, p, context); [EOL]             cc.addOp(opstr, true); [EOL]             addExpr(last, p, rhsContext); [EOL]         } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) { [EOL]             addExpr(first, p, context); [EOL]             cc.addOp(opstr, true); [EOL]             addExpr(last, p, rhsContext); [EOL]         } else { [EOL]             unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1); [EOL]         } [EOL]         return; [EOL]     } [EOL]     cc.startSourceMapping(n); [EOL]     switch(type) { [EOL]         case Token.TRY: [EOL]             { [EOL]                 Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild()); [EOL]                 Preconditions.checkState(childCount >= 2 && childCount <= 3); [EOL]                 add("try"); [EOL]                 add(first, Context.PRESERVE_BLOCK); [EOL]                 Node catchblock = first.getNext().getFirstChild(); [EOL]                 if (catchblock != null) { [EOL]                     add(catchblock); [EOL]                 } [EOL]                 if (childCount == 3) { [EOL]                     add("finally"); [EOL]                     add(last, Context.PRESERVE_BLOCK); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case Token.CATCH: [EOL]             Preconditions.checkState(childCount == 2); [EOL]             add("catch("); [EOL]             add(first); [EOL]             add(")"); [EOL]             add(last, Context.PRESERVE_BLOCK); [EOL]             break; [EOL]         case Token.THROW: [EOL]             Preconditions.checkState(childCount == 1); [EOL]             add("throw"); [EOL]             add(first); [EOL]             cc.endStatement(true); [EOL]             break; [EOL]         case Token.RETURN: [EOL]             add("return"); [EOL]             if (childCount == 1) { [EOL]                 add(first); [EOL]             } else { [EOL]                 Preconditions.checkState(childCount == 0); [EOL]             } [EOL]             cc.endStatement(); [EOL]             break; [EOL]         case Token.VAR: [EOL]             if (first != null) { [EOL]                 add("var "); [EOL]                 addList(first, false, getContextForNoInOperator(context)); [EOL]             } [EOL]             break; [EOL]         case Token.LABEL_NAME: [EOL]             Preconditions.checkState(!n.getString().isEmpty()); [EOL]             addIdentifier(n.getString()); [EOL]             break; [EOL]         case Token.NAME: [EOL]             if (first == null || first.isEmpty()) { [EOL]                 addIdentifier(n.getString()); [EOL]             } else { [EOL]                 Preconditions.checkState(childCount == 1); [EOL]                 addIdentifier(n.getString()); [EOL]                 cc.addOp("=", true); [EOL]                 if (first.isComma()) { [EOL]                     addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER); [EOL]                 } else { [EOL]                     addExpr(first, 0, getContextForNoInOperator(context)); [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Token.ARRAYLIT: [EOL]             add("["); [EOL]             addArrayList(first); [EOL]             add("]"); [EOL]             break; [EOL]         case Token.PARAM_LIST: [EOL]             add("("); [EOL]             addList(first); [EOL]             add(")"); [EOL]             break; [EOL]         case Token.COMMA: [EOL]             Preconditions.checkState(childCount == 2); [EOL]             unrollBinaryOperator(n, Token.COMMA, ",", context, Context.OTHER, 0, 0); [EOL]             break; [EOL]         case Token.NUMBER: [EOL]             Preconditions.checkState(childCount == 0); [EOL]             cc.addNumber(n.getDouble()); [EOL]             break; [EOL]         case Token.TYPEOF: [EOL]         case Token.VOID: [EOL]         case Token.NOT: [EOL]         case Token.BITNOT: [EOL]         case Token.POS: [EOL]             { [EOL]                 Preconditions.checkState(childCount == 1); [EOL]                 cc.addOp(NodeUtil.opToStrNoFail(type), false); [EOL]                 addExpr(first, NodeUtil.precedence(type), Context.OTHER); [EOL]                 break; [EOL]             } [EOL]         case Token.NEG: [EOL]             { [EOL]                 Preconditions.checkState(childCount == 1); [EOL]                 if (n.getFirstChild().isNumber()) { [EOL]                     cc.addNumber(-n.getFirstChild().getDouble()); [EOL]                 } else { [EOL]                     cc.addOp(NodeUtil.opToStrNoFail(type), false); [EOL]                     addExpr(first, NodeUtil.precedence(type), Context.OTHER); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case Token.HOOK: [EOL]             { [EOL]                 Preconditions.checkState(childCount == 3); [EOL]                 int p = NodeUtil.precedence(type); [EOL]                 addExpr(first, p + 1, context); [EOL]                 cc.addOp("?", true); [EOL]                 addExpr(first.getNext(), 1, Context.OTHER); [EOL]                 cc.addOp(":", true); [EOL]                 addExpr(last, 1, Context.OTHER); [EOL]                 break; [EOL]             } [EOL]         case Token.REGEXP: [EOL]             if (!first.isString() || !last.isString()) { [EOL]                 throw new Error("Expected children to be strings"); [EOL]             } [EOL]             String regexp = regexpEscape(first.getString(), outputCharsetEncoder); [EOL]             if (childCount == 2) { [EOL]                 add(regexp + last.getString()); [EOL]             } else { [EOL]                 Preconditions.checkState(childCount == 1); [EOL]                 add(regexp); [EOL]             } [EOL]             break; [EOL]         case Token.FUNCTION: [EOL]             if (n.getClass() != Node.class) { [EOL]                 throw new Error("Unexpected Node subclass."); [EOL]             } [EOL]             Preconditions.checkState(childCount == 3); [EOL]             boolean funcNeedsParens = (context == Context.START_OF_EXPR); [EOL]             if (funcNeedsParens) { [EOL]                 add("("); [EOL]             } [EOL]             add("function"); [EOL]             add(first); [EOL]             add(first.getNext()); [EOL]             add(last, Context.PRESERVE_BLOCK); [EOL]             cc.endFunction(context == Context.STATEMENT); [EOL]             if (funcNeedsParens) { [EOL]                 add(")"); [EOL]             } [EOL]             break; [EOL]         case Token.GETTER_DEF: [EOL]         case Token.SETTER_DEF: [EOL]             Preconditions.checkState(n.getParent().isObjectLit()); [EOL]             Preconditions.checkState(childCount == 1); [EOL]             Preconditions.checkState(first.isFunction()); [EOL]             Preconditions.checkState(first.getFirstChild().getString().isEmpty()); [EOL]             if (type == Token.GETTER_DEF) { [EOL]                 Preconditions.checkState(!first.getChildAtIndex(1).hasChildren()); [EOL]                 add("get "); [EOL]             } else { [EOL]                 Preconditions.checkState(first.getChildAtIndex(1).hasOneChild()); [EOL]                 add("set "); [EOL]             } [EOL]             String name = n.getString(); [EOL]             Node fn = first; [EOL]             Node parameters = fn.getChildAtIndex(1); [EOL]             Node body = fn.getLastChild(); [EOL]             if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && NodeUtil.isLatin(name)) { [EOL]                 add(name); [EOL]             } else { [EOL]                 double d = getSimpleNumber(name); [EOL]                 if (!Double.isNaN(d)) { [EOL]                     cc.addNumber(d); [EOL]                 } else { [EOL]                     addJsString(n); [EOL]                 } [EOL]             } [EOL]             add(parameters); [EOL]             add(body, Context.PRESERVE_BLOCK); [EOL]             break; [EOL]         case Token.SCRIPT: [EOL]         case Token.BLOCK: [EOL]             { [EOL]                 if (n.getClass() != Node.class) { [EOL]                     throw new Error("Unexpected Node subclass."); [EOL]                 } [EOL]                 boolean preserveBlock = context == Context.PRESERVE_BLOCK; [EOL]                 if (preserveBlock) { [EOL]                     cc.beginBlock(); [EOL]                 } [EOL]                 boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript()); [EOL]                 for (Node c = first; c != null; c = c.getNext()) { [EOL]                     add(c, Context.STATEMENT); [EOL]                     if (c.isVar()) { [EOL]                         cc.endStatement(); [EOL]                     } [EOL]                     if (c.isFunction()) { [EOL]                         cc.maybeLineBreak(); [EOL]                     } [EOL]                     if (preferLineBreaks) { [EOL]                         cc.notePreferredLineBreak(); [EOL]                     } [EOL]                 } [EOL]                 if (preserveBlock) { [EOL]                     cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case Token.FOR: [EOL]             if (childCount == 4) { [EOL]                 add("for("); [EOL]                 if (first.isVar()) { [EOL]                     add(first, Context.IN_FOR_INIT_CLAUSE); [EOL]                 } else { [EOL]                     addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE); [EOL]                 } [EOL]                 add(";"); [EOL]                 add(first.getNext()); [EOL]                 add(";"); [EOL]                 add(first.getNext().getNext()); [EOL]                 add(")"); [EOL]                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false); [EOL]             } else { [EOL]                 Preconditions.checkState(childCount == 3); [EOL]                 add("for("); [EOL]                 add(first); [EOL]                 add("in"); [EOL]                 add(first.getNext()); [EOL]                 add(")"); [EOL]                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false); [EOL]             } [EOL]             break; [EOL]         case Token.DO: [EOL]             Preconditions.checkState(childCount == 2); [EOL]             add("do"); [EOL]             addNonEmptyStatement(first, Context.OTHER, false); [EOL]             add("while("); [EOL]             add(last); [EOL]             add(")"); [EOL]             cc.endStatement(); [EOL]             break; [EOL]         case Token.WHILE: [EOL]             Preconditions.checkState(childCount == 2); [EOL]             add("while("); [EOL]             add(first); [EOL]             add(")"); [EOL]             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false); [EOL]             break; [EOL]         case Token.EMPTY: [EOL]             Preconditions.checkState(childCount == 0); [EOL]             break; [EOL]         case Token.GETPROP: [EOL]             { [EOL]                 Preconditions.checkState(childCount == 2, "Bad GETPROP: expected 2 children, but got %s", childCount); [EOL]                 Preconditions.checkState(last.isString(), "Bad GETPROP: RHS should be STRING"); [EOL]                 boolean needsParens = (first.isNumber()); [EOL]                 if (needsParens) { [EOL]                     add("("); [EOL]                 } [EOL]                 addExpr(first, NodeUtil.precedence(type), context); [EOL]                 if (needsParens) { [EOL]                     add(")"); [EOL]                 } [EOL]                 add("."); [EOL]                 addIdentifier(last.getString()); [EOL]                 break; [EOL]             } [EOL]         case Token.GETELEM: [EOL]             Preconditions.checkState(childCount == 2, "Bad GETELEM: expected 2 children but got %s", childCount); [EOL]             addExpr(first, NodeUtil.precedence(type), context); [EOL]             add("["); [EOL]             add(first.getNext()); [EOL]             add("]"); [EOL]             break; [EOL]         case Token.WITH: [EOL]             Preconditions.checkState(childCount == 2); [EOL]             add("with("); [EOL]             add(first); [EOL]             add(")"); [EOL]             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false); [EOL]             break; [EOL]         case Token.INC: [EOL]         case Token.DEC: [EOL]             { [EOL]                 Preconditions.checkState(childCount == 1); [EOL]                 String o = type == Token.INC ? "++" : "--"; [EOL]                 int postProp = n.getIntProp(Node.INCRDECR_PROP); [EOL]                 if (postProp != 0) { [EOL]                     addExpr(first, NodeUtil.precedence(type), context); [EOL]                     cc.addOp(o, false); [EOL]                 } else { [EOL]                     cc.addOp(o, false); [EOL]                     add(first); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case Token.CALL: [EOL]             if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) { [EOL]                 add("(0,"); [EOL]                 addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER); [EOL]                 add(")"); [EOL]             } else { [EOL]                 addExpr(first, NodeUtil.precedence(type), context); [EOL]             } [EOL]             add("("); [EOL]             addList(first.getNext()); [EOL]             add(")"); [EOL]             break; [EOL]         case Token.IF: [EOL]             boolean hasElse = childCount == 3; [EOL]             boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse; [EOL]             if (ambiguousElseClause) { [EOL]                 cc.beginBlock(); [EOL]             } [EOL]             add("if("); [EOL]             add(first); [EOL]             add(")"); [EOL]             if (hasElse) { [EOL]                 addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false); [EOL]                 add("else"); [EOL]                 addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false); [EOL]             } else { [EOL]                 addNonEmptyStatement(first.getNext(), Context.OTHER, false); [EOL]                 Preconditions.checkState(childCount == 2); [EOL]             } [EOL]             if (ambiguousElseClause) { [EOL]                 cc.endBlock(); [EOL]             } [EOL]             break; [EOL]         case Token.NULL: [EOL]             Preconditions.checkState(childCount == 0); [EOL]             cc.addConstant("null"); [EOL]             break; [EOL]         case Token.THIS: [EOL]             Preconditions.checkState(childCount == 0); [EOL]             add("this"); [EOL]             break; [EOL]         case Token.FALSE: [EOL]             Preconditions.checkState(childCount == 0); [EOL]             cc.addConstant("false"); [EOL]             break; [EOL]         case Token.TRUE: [EOL]             Preconditions.checkState(childCount == 0); [EOL]             cc.addConstant("true"); [EOL]             break; [EOL]         case Token.CONTINUE: [EOL]             Preconditions.checkState(childCount <= 1); [EOL]             add("continue"); [EOL]             if (childCount == 1) { [EOL]                 if (!first.isLabelName()) { [EOL]                     throw new Error("Unexpected token type. Should be LABEL_NAME."); [EOL]                 } [EOL]                 add(" "); [EOL]                 add(first); [EOL]             } [EOL]             cc.endStatement(); [EOL]             break; [EOL]         case Token.DEBUGGER: [EOL]             Preconditions.checkState(childCount == 0); [EOL]             add("debugger"); [EOL]             cc.endStatement(); [EOL]             break; [EOL]         case Token.BREAK: [EOL]             Preconditions.checkState(childCount <= 1); [EOL]             add("break"); [EOL]             if (childCount == 1) { [EOL]                 if (!first.isLabelName()) { [EOL]                     throw new Error("Unexpected token type. Should be LABEL_NAME."); [EOL]                 } [EOL]                 add(" "); [EOL]                 add(first); [EOL]             } [EOL]             cc.endStatement(); [EOL]             break; [EOL]         case Token.EXPR_RESULT: [EOL]             Preconditions.checkState(childCount == 1); [EOL]             add(first, Context.START_OF_EXPR); [EOL]             cc.endStatement(); [EOL]             break; [EOL]         case Token.NEW: [EOL]             add("new "); [EOL]             int precedence = NodeUtil.precedence(type); [EOL]             if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) { [EOL]                 precedence = NodeUtil.precedence(first.getType()) + 1; [EOL]             } [EOL]             addExpr(first, precedence, Context.OTHER); [EOL]             Node next = first.getNext(); [EOL]             if (next != null) { [EOL]                 add("("); [EOL]                 addList(next); [EOL]                 add(")"); [EOL]             } [EOL]             break; [EOL]         case Token.STRING_KEY: [EOL]             Preconditions.checkState(childCount == 1, "Object lit key must have 1 child"); [EOL]             addJsString(n); [EOL]             break; [EOL]         case Token.STRING: [EOL]             Preconditions.checkState(childCount == 0, "A string may not have children"); [EOL]             addJsString(n); [EOL]             break; [EOL]         case Token.DELPROP: [EOL]             Preconditions.checkState(childCount == 1); [EOL]             add("delete "); [EOL]             add(first); [EOL]             break; [EOL]         case Token.OBJECTLIT: [EOL]             { [EOL]                 boolean needsParens = (context == Context.START_OF_EXPR); [EOL]                 if (needsParens) { [EOL]                     add("("); [EOL]                 } [EOL]                 add("{"); [EOL]                 for (Node c = first; c != null; c = c.getNext()) { [EOL]                     if (c != first) { [EOL]                         cc.listSeparator(); [EOL]                     } [EOL]                     if (c.isGetterDef() || c.isSetterDef()) { [EOL]                         add(c); [EOL]                     } else { [EOL]                         Preconditions.checkState(c.isStringKey()); [EOL]                         String key = c.getString(); [EOL]                         if (!c.isQuotedString() && !TokenStream.isKeyword(key) && TokenStream.isJSIdentifier(key) && NodeUtil.isLatin(key)) { [EOL]                             add(key); [EOL]                         } else { [EOL]                             double d = getSimpleNumber(key); [EOL]                             if (!Double.isNaN(d)) { [EOL]                                 cc.addNumber(d); [EOL]                             } else { [EOL]                                 addExpr(c, 1, Context.OTHER); [EOL]                             } [EOL]                         } [EOL]                         add(":"); [EOL]                         addExpr(c.getFirstChild(), 1, Context.OTHER); [EOL]                     } [EOL]                 } [EOL]                 add("}"); [EOL]                 if (needsParens) { [EOL]                     add(")"); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case Token.SWITCH: [EOL]             add("switch("); [EOL]             add(first); [EOL]             add(")"); [EOL]             cc.beginBlock(); [EOL]             addAllSiblings(first.getNext()); [EOL]             cc.endBlock(context == Context.STATEMENT); [EOL]             break; [EOL]         case Token.CASE: [EOL]             Preconditions.checkState(childCount == 2); [EOL]             add("case "); [EOL]             add(first); [EOL]             addCaseBody(last); [EOL]             break; [EOL]         case Token.DEFAULT_CASE: [EOL]             Preconditions.checkState(childCount == 1); [EOL]             add("default"); [EOL]             addCaseBody(first); [EOL]             break; [EOL]         case Token.LABEL: [EOL]             Preconditions.checkState(childCount == 2); [EOL]             if (!first.isLabelName()) { [EOL]                 throw new Error("Unexpected token type. Should be LABEL_NAME."); [EOL]             } [EOL]             add(first); [EOL]             add(":"); [EOL]             addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true); [EOL]             break; [EOL]         case Token.CAST: [EOL]             add("("); [EOL]             add(first); [EOL]             add(")"); [EOL]             break; [EOL]         default: [EOL]             throw new Error("Unknown type " + type + "\n" + n.toStringTree()); [EOL]     } [EOL]     cc.endSourceMapping(n); [EOL] } <line_num>: 103,756
private void unrollBinaryOperator(Node n, int op, String opStr, Context context, Context rhsContext, int leftPrecedence, int rightPrecedence) { [EOL]     Node firstNonOperator = n.getFirstChild(); [EOL]     while (firstNonOperator.getType() == op) { [EOL]         firstNonOperator = firstNonOperator.getFirstChild(); [EOL]     } [EOL]     addExpr(firstNonOperator, leftPrecedence, context); [EOL]     Node current = firstNonOperator; [EOL]     do { [EOL]         current = current.getParent(); [EOL]         cc.addOp(opStr, true); [EOL]         addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext); [EOL]     } while (current != n); [EOL] } <line_num>: 765,781
static boolean isSimpleNumber(String s) { [EOL]     int len = s.length(); [EOL]     for (int index = 0; index < len; index++) { [EOL]         char c = s.charAt(index); [EOL]         if (c < '0' || c > '9') { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return len > 0 && s.charAt(0) != '0'; [EOL] } <line_num>: 783,792
static double getSimpleNumber(String s) { [EOL]     if (isSimpleNumber(s)) { [EOL]         try { [EOL]             long l = Long.parseLong(s); [EOL]             if (l < NodeUtil.MAX_POSITIVE_INTEGER_NUMBER) { [EOL]                 return l; [EOL]             } [EOL]         } catch (NumberFormatException e) { [EOL]         } [EOL]     } [EOL]     return Double.NaN; [EOL] } <line_num>: 794,806
private boolean isIndirectEval(Node n) { [EOL]     return n.isName() && "eval".equals(n.getString()) && !n.getBooleanProp(Node.DIRECT_EVAL); [EOL] } <line_num>: 811,814
private void addNonEmptyStatement(Node n, Context context, boolean allowNonBlockChild) { [EOL]     Node nodeToProcess = n; [EOL]     if (!allowNonBlockChild && !n.isBlock()) { [EOL]         throw new Error("Missing BLOCK child."); [EOL]     } [EOL]     if (n.isBlock()) { [EOL]         int count = getNonEmptyChildCount(n, 2); [EOL]         if (count == 0) { [EOL]             if (cc.shouldPreserveExtraBlocks()) { [EOL]                 cc.beginBlock(); [EOL]                 cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); [EOL]             } else { [EOL]                 cc.endStatement(true); [EOL]             } [EOL]             return; [EOL]         } [EOL]         if (count == 1) { [EOL]             Node firstAndOnlyChild = getFirstNonEmptyChild(n); [EOL]             boolean alwaysWrapInBlock = cc.shouldPreserveExtraBlocks(); [EOL]             if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild)) { [EOL]                 cc.beginBlock(); [EOL]                 add(firstAndOnlyChild, Context.STATEMENT); [EOL]                 cc.maybeLineBreak(); [EOL]                 cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); [EOL]                 return; [EOL]             } else { [EOL]                 nodeToProcess = firstAndOnlyChild; [EOL]             } [EOL]         } [EOL]         if (count > 1) { [EOL]             context = Context.PRESERVE_BLOCK; [EOL]         } [EOL]     } [EOL]     if (nodeToProcess.isEmpty()) { [EOL]         cc.endStatement(true); [EOL]     } else { [EOL]         add(nodeToProcess, context); [EOL]         if (nodeToProcess.isVar()) { [EOL]             cc.endStatement(); [EOL]         } [EOL]     } [EOL] } <line_num>: 823,879
private boolean isOneExactlyFunctionOrDo(Node n) { [EOL]     if (n.isLabel()) { [EOL]         Node labeledStatement = n.getLastChild(); [EOL]         if (!labeledStatement.isBlock()) { [EOL]             return isOneExactlyFunctionOrDo(labeledStatement); [EOL]         } else { [EOL]             if (getNonEmptyChildCount(n, 2) == 1) { [EOL]                 return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n)); [EOL]             } else { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         return (n.isFunction() || n.isDo()); [EOL]     } [EOL] } <line_num>: 885,905
private void addExpr(Node n, int minPrecedence, Context context) { [EOL]     if ((NodeUtil.precedence(n.getType()) < minPrecedence) || ((context == Context.IN_FOR_INIT_CLAUSE) && n.isIn())) { [EOL]         add("("); [EOL]         add(n, Context.OTHER); [EOL]         add(")"); [EOL]     } else { [EOL]         add(n, context); [EOL]     } [EOL] } <line_num>: 907,916
void addList(Node firstInList) { [EOL]     addList(firstInList, true, Context.OTHER); [EOL] } <line_num>: 918,920
void addList(Node firstInList, boolean isArrayOrFunctionArgument) { [EOL]     addList(firstInList, isArrayOrFunctionArgument, Context.OTHER); [EOL] } <line_num>: 922,924
void addList(Node firstInList, boolean isArrayOrFunctionArgument, Context lhsContext) { [EOL]     for (Node n = firstInList; n != null; n = n.getNext()) { [EOL]         boolean isFirst = n == firstInList; [EOL]         if (isFirst) { [EOL]             addExpr(n, isArrayOrFunctionArgument ? 1 : 0, lhsContext); [EOL]         } else { [EOL]             cc.listSeparator(); [EOL]             addExpr(n, isArrayOrFunctionArgument ? 1 : 0, Context.OTHER); [EOL]         } [EOL]     } [EOL] } <line_num>: 926,937
void addArrayList(Node firstInList) { [EOL]     boolean lastWasEmpty = false; [EOL]     for (Node n = firstInList; n != null; n = n.getNext()) { [EOL]         if (n != firstInList) { [EOL]             cc.listSeparator(); [EOL]         } [EOL]         addExpr(n, 1, Context.OTHER); [EOL]         lastWasEmpty = n.isEmpty(); [EOL]     } [EOL]     if (lastWasEmpty) { [EOL]         cc.listSeparator(); [EOL]     } [EOL] } <line_num>: 947,960
void addCaseBody(Node caseBody) { [EOL]     cc.beginCaseBody(); [EOL]     add(caseBody); [EOL]     cc.endCaseBody(); [EOL] } <line_num>: 962,966
void addAllSiblings(Node n) { [EOL]     for (Node c = n; c != null; c = c.getNext()) { [EOL]         add(c); [EOL]     } [EOL] } <line_num>: 968,972
private void addJsString(Node n) { [EOL]     String s = n.getString(); [EOL]     boolean useSlashV = n.getBooleanProp(Node.SLASH_V); [EOL]     if (useSlashV) { [EOL]         add(jsString(n.getString(), useSlashV)); [EOL]     } else { [EOL]         String cached = ESCAPED_JS_STRINGS.get(s); [EOL]         if (cached == null) { [EOL]             cached = jsString(n.getString(), useSlashV); [EOL]             ESCAPED_JS_STRINGS.put(s, cached); [EOL]         } [EOL]         add(cached); [EOL]     } [EOL] } <line_num>: 975,988
private String jsString(String s, boolean useSlashV) { [EOL]     int singleq = 0, doubleq = 0; [EOL]     for (int i = 0; i < s.length(); i++) { [EOL]         switch(s.charAt(i)) { [EOL]             case '"': [EOL]                 doubleq++; [EOL]                 break; [EOL]             case '\'': [EOL]                 singleq++; [EOL]                 break; [EOL]         } [EOL]     } [EOL]     String doublequote, singlequote; [EOL]     char quote; [EOL]     if (preferSingleQuotes ? (singleq <= doubleq) : (singleq < doubleq)) { [EOL]         quote = '\''; [EOL]         doublequote = "\""; [EOL]         singlequote = "\\\'"; [EOL]     } else { [EOL]         quote = '\"'; [EOL]         doublequote = "\\\""; [EOL]         singlequote = "\'"; [EOL]     } [EOL]     return strEscape(s, quote, doublequote, singlequote, "\\\\", outputCharsetEncoder, useSlashV, false); [EOL] } <line_num>: 990,1018
String regexpEscape(String s, CharsetEncoder outputCharsetEncoder) { [EOL]     return strEscape(s, '/', "\"", "'", "\\", outputCharsetEncoder, false, true); [EOL] } <line_num>: 1021,1023
String escapeToDoubleQuotedJsString(String s) { [EOL]     return strEscape(s, '"', "\\\"", "\'", "\\\\", null, false, false); [EOL] } <line_num>: 1028,1030
String regexpEscape(String s) { [EOL]     return regexpEscape(s, null); [EOL] } <line_num>: 1035,1037
private String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder, boolean useSlashV, boolean isRegexp) { [EOL]     StringBuilder sb = new StringBuilder(s.length() + 2); [EOL]     sb.append(quote); [EOL]     for (int i = 0; i < s.length(); i++) { [EOL]         char c = s.charAt(i); [EOL]         switch(c) { [EOL]             case '\0': [EOL]                 sb.append("\\x00"); [EOL]                 break; [EOL]             case '\u000B': [EOL]                 if (useSlashV) { [EOL]                     sb.append("\\v"); [EOL]                 } else { [EOL]                     sb.append("\\x0B"); [EOL]                 } [EOL]                 break; [EOL]             case '\b': [EOL]                 sb.append("\\b"); [EOL]                 break; [EOL]             case '\f': [EOL]                 sb.append("\\f"); [EOL]                 break; [EOL]             case '\n': [EOL]                 sb.append("\\n"); [EOL]                 break; [EOL]             case '\r': [EOL]                 sb.append("\\r"); [EOL]                 break; [EOL]             case '\t': [EOL]                 sb.append("\\t"); [EOL]                 break; [EOL]             case '\\': [EOL]                 sb.append(backslashEscape); [EOL]                 break; [EOL]             case '\"': [EOL]                 sb.append(doublequoteEscape); [EOL]                 break; [EOL]             case '\'': [EOL]                 sb.append(singlequoteEscape); [EOL]                 break; [EOL]             case '\u2028': [EOL]                 sb.append("\\u2028"); [EOL]                 break; [EOL]             case '\u2029': [EOL]                 sb.append("\\u2029"); [EOL]                 break; [EOL]             case '=': [EOL]                 if (trustedStrings || isRegexp) { [EOL]                     sb.append(c); [EOL]                 } else { [EOL]                     sb.append("\\x3d"); [EOL]                 } [EOL]                 break; [EOL]             case '&': [EOL]                 if (trustedStrings || isRegexp) { [EOL]                     sb.append(c); [EOL]                 } else { [EOL]                     sb.append("\\x26"); [EOL]                 } [EOL]                 break; [EOL]             case '>': [EOL]                 if (!trustedStrings && !isRegexp) { [EOL]                     sb.append(GT_ESCAPED); [EOL]                     break; [EOL]                 } [EOL]                 if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { [EOL]                     sb.append(GT_ESCAPED); [EOL]                 } else { [EOL]                     sb.append(c); [EOL]                 } [EOL]                 break; [EOL]             case '<': [EOL]                 if (!trustedStrings && !isRegexp) { [EOL]                     sb.append(LT_ESCAPED); [EOL]                     break; [EOL]                 } [EOL]                 final String END_SCRIPT = "/script"; [EOL]                 final String START_COMMENT = "!--"; [EOL]                 if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { [EOL]                     sb.append(LT_ESCAPED); [EOL]                 } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { [EOL]                     sb.append(LT_ESCAPED); [EOL]                 } else { [EOL]                     sb.append(c); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 if (outputCharsetEncoder != null) { [EOL]                     if (outputCharsetEncoder.canEncode(c)) { [EOL]                         sb.append(c); [EOL]                     } else { [EOL]                         appendHexJavaScriptRepresentation(sb, c); [EOL]                     } [EOL]                 } else { [EOL]                     if (c > 0x1f && c < 0x7f) { [EOL]                         sb.append(c); [EOL]                     } else { [EOL]                         appendHexJavaScriptRepresentation(sb, c); [EOL]                     } [EOL]                 } [EOL]         } [EOL]     } [EOL]     sb.append(quote); [EOL]     return sb.toString(); [EOL] } <line_num>: 1040,1163
static String identifierEscape(String s) { [EOL]     if (NodeUtil.isLatin(s)) { [EOL]         return s; [EOL]     } [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < s.length(); i++) { [EOL]         char c = s.charAt(i); [EOL]         if (c > 0x1F && c < 0x7F) { [EOL]             sb.append(c); [EOL]         } else { [EOL]             appendHexJavaScriptRepresentation(sb, c); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } <line_num>: 1165,1185
private static int getNonEmptyChildCount(Node n, int maxCount) { [EOL]     int i = 0; [EOL]     Node c = n.getFirstChild(); [EOL]     for (; c != null && i < maxCount; c = c.getNext()) { [EOL]         if (c.isBlock()) { [EOL]             i += getNonEmptyChildCount(c, maxCount - i); [EOL]         } else if (!c.isEmpty()) { [EOL]             i++; [EOL]         } [EOL]     } [EOL]     return i; [EOL] } <line_num>: 1191,1202
private static Node getFirstNonEmptyChild(Node n) { [EOL]     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { [EOL]         if (c.isBlock()) { [EOL]             Node result = getFirstNonEmptyChild(c); [EOL]             if (result != null) { [EOL]                 return result; [EOL]             } [EOL]         } else if (!c.isEmpty()) { [EOL]             return c; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 1205,1217
private Context getContextForNonEmptyExpression(Context currentContext) { [EOL]     return currentContext == Context.BEFORE_DANGLING_ELSE ? Context.BEFORE_DANGLING_ELSE : Context.OTHER; [EOL] } <line_num>: 1234,1237
private Context getContextForNoInOperator(Context context) { [EOL]     return (context == Context.IN_FOR_INIT_CLAUSE ? Context.IN_FOR_INIT_CLAUSE : Context.OTHER); [EOL] } <line_num>: 1243,1246
private static void appendHexJavaScriptRepresentation(StringBuilder sb, char c) { [EOL]     try { [EOL]         appendHexJavaScriptRepresentation(c, sb); [EOL]     } catch (IOException ex) { [EOL]         throw new RuntimeException(ex); [EOL]     } [EOL] } <line_num>: 1251,1259
private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException { [EOL]     if (Character.isSupplementaryCodePoint(codePoint)) { [EOL]         char[] surrogates = Character.toChars(codePoint); [EOL]         appendHexJavaScriptRepresentation(surrogates[0], out); [EOL]         appendHexJavaScriptRepresentation(surrogates[1], out); [EOL]         return; [EOL]     } [EOL]     out.append("\\u").append(HEX_CHARS[(codePoint >>> 12) & 0xf]).append(HEX_CHARS[(codePoint >>> 8) & 0xf]).append(HEX_CHARS[(codePoint >>> 4) & 0xf]).append(HEX_CHARS[codePoint & 0xf]); [EOL] } <line_num>: 1268,1286
