public CheckRegExp(AbstractCompiler compiler) { [EOL]     this.compiler = compiler; [EOL] } <line_num>: 47,49
public boolean isGlobalRegExpPropertiesUsed() { [EOL]     return globalRegExpPropertiesUsed; [EOL] } <line_num>: 43,45
@Override [EOL] public void process(Node externs, Node root) { [EOL]     NodeTraversal.traverse(compiler, root, this); [EOL] } <line_num>: 51,54
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (NodeUtil.isReferenceName(n)) { [EOL]         String name = n.getString(); [EOL]         if (name.equals("RegExp") && t.getScope().getVar(name) == null) { [EOL]             int parentType = parent.getType(); [EOL]             boolean first = (n == parent.getFirstChild()); [EOL]             if (!((parentType == Token.NEW && first) || (parentType == Token.CALL && first) || (parentType == Token.INSTANCEOF && !first))) { [EOL]                 t.report(n, REGEXP_REFERENCE); [EOL]                 globalRegExpPropertiesUsed = true; [EOL]             } [EOL]         } [EOL]     } else if (n.isRegExp()) { [EOL]         String pattern = n.getFirstChild().getString(); [EOL]         String flags = n.getChildCount() == 2 ? n.getLastChild().getString() : ""; [EOL]         try { [EOL]             RegExpTree.parseRegExp(pattern, flags); [EOL]         } catch (IllegalArgumentException ex) { [EOL]             t.report(n, MALFORMED_REGEXP, ex.getMessage()); [EOL]         } [EOL]     } [EOL] } <line_num>: 56,82
