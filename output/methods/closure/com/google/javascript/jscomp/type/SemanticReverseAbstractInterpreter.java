public SemanticReverseAbstractInterpreter(CodingConvention convention, JSTypeRegistry typeRegistry) { [EOL]     super(convention, typeRegistry); [EOL] } <line_num>: 119,122
RestrictByTrueInstanceOfResultVisitor(ObjectType target) { [EOL]     this.target = target; [EOL] } <line_num>: 507,509
RestrictByFalseInstanceOfResultVisitor(ObjectType target) { [EOL]     this.target = target; [EOL] } <line_num>: 561,563
@Override [EOL] public TypePair apply(TypePair p) { [EOL]     if (p.typeA == null || p.typeB == null) { [EOL]         return null; [EOL]     } [EOL]     return p.typeA.getTypesUnderEquality(p.typeB); [EOL] } <line_num>: 49,55
@Override [EOL] public TypePair apply(TypePair p) { [EOL]     if (p.typeA == null || p.typeB == null) { [EOL]         return null; [EOL]     } [EOL]     return p.typeA.getTypesUnderInequality(p.typeB); [EOL] } <line_num>: 63,69
@Override [EOL] public TypePair apply(TypePair p) { [EOL]     if (p.typeA == null || p.typeB == null) { [EOL]         return null; [EOL]     } [EOL]     return p.typeA.getTypesUnderShallowEquality(p.typeB); [EOL] } <line_num>: 78,84
@Override [EOL] public TypePair apply(TypePair p) { [EOL]     if (p.typeA == null || p.typeB == null) { [EOL]         return null; [EOL]     } [EOL]     return p.typeA.getTypesUnderShallowInequality(p.typeB); [EOL] } <line_num>: 93,99
@Override [EOL] public TypePair apply(TypePair p) { [EOL]     return new TypePair(getRestrictedWithoutUndefined(p.typeA), getRestrictedWithoutUndefined(p.typeB)); [EOL] } <line_num>: 108,113
@Override [EOL] public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) { [EOL]     int operatorToken = condition.getType(); [EOL]     switch(operatorToken) { [EOL]         case Token.EQ: [EOL]         case Token.NE: [EOL]         case Token.SHEQ: [EOL]         case Token.SHNE: [EOL]         case Token.CASE: [EOL]             Node left; [EOL]             Node right; [EOL]             if (operatorToken == Token.CASE) { [EOL]                 left = condition.getParent().getFirstChild(); [EOL]                 right = condition.getFirstChild(); [EOL]             } else { [EOL]                 left = condition.getFirstChild(); [EOL]                 right = condition.getLastChild(); [EOL]             } [EOL]             Node typeOfNode = null; [EOL]             Node stringNode = null; [EOL]             if (left.isTypeOf() && right.isString()) { [EOL]                 typeOfNode = left; [EOL]                 stringNode = right; [EOL]             } else if (right.isTypeOf() && left.isString()) { [EOL]                 typeOfNode = right; [EOL]                 stringNode = left; [EOL]             } [EOL]             if (typeOfNode != null && stringNode != null) { [EOL]                 Node operandNode = typeOfNode.getFirstChild(); [EOL]                 JSType operandType = getTypeIfRefinable(operandNode, blindScope); [EOL]                 if (operandType != null) { [EOL]                     boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE; [EOL]                     if (!outcome) { [EOL]                         resultEqualsValue = !resultEqualsValue; [EOL]                     } [EOL]                     return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope); [EOL]                 } [EOL]             } [EOL]     } [EOL]     switch(operatorToken) { [EOL]         case Token.AND: [EOL]             if (outcome) { [EOL]                 return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true); [EOL]             } else { [EOL]                 return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true); [EOL]             } [EOL]         case Token.OR: [EOL]             if (!outcome) { [EOL]                 return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false); [EOL]             } else { [EOL]                 return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false); [EOL]             } [EOL]         case Token.EQ: [EOL]             if (outcome) { [EOL]                 return caseEquality(condition, blindScope, EQ); [EOL]             } else { [EOL]                 return caseEquality(condition, blindScope, NE); [EOL]             } [EOL]         case Token.NE: [EOL]             if (outcome) { [EOL]                 return caseEquality(condition, blindScope, NE); [EOL]             } else { [EOL]                 return caseEquality(condition, blindScope, EQ); [EOL]             } [EOL]         case Token.SHEQ: [EOL]             if (outcome) { [EOL]                 return caseEquality(condition, blindScope, SHEQ); [EOL]             } else { [EOL]                 return caseEquality(condition, blindScope, SHNE); [EOL]             } [EOL]         case Token.SHNE: [EOL]             if (outcome) { [EOL]                 return caseEquality(condition, blindScope, SHNE); [EOL]             } else { [EOL]                 return caseEquality(condition, blindScope, SHEQ); [EOL]             } [EOL]         case Token.NAME: [EOL]         case Token.GETPROP: [EOL]             return caseNameOrGetProp(condition, blindScope, outcome); [EOL]         case Token.ASSIGN: [EOL]             return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome); [EOL]         case Token.NOT: [EOL]             return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome); [EOL]         case Token.LE: [EOL]         case Token.LT: [EOL]         case Token.GE: [EOL]         case Token.GT: [EOL]             if (outcome) { [EOL]                 return caseEquality(condition, blindScope, INEQ); [EOL]             } [EOL]             break; [EOL]         case Token.INSTANCEOF: [EOL]             return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome); [EOL]         case Token.IN: [EOL]             if (outcome && condition.getFirstChild().isString()) { [EOL]                 return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope); [EOL]             } [EOL]             break; [EOL]         case Token.CASE: [EOL]             Node left = condition.getParent().getFirstChild(); [EOL]             Node right = condition.getFirstChild(); [EOL]             if (outcome) { [EOL]                 return caseEquality(left, right, blindScope, SHEQ); [EOL]             } else { [EOL]                 return caseEquality(left, right, blindScope, SHNE); [EOL]             } [EOL]     } [EOL]     return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome); [EOL] } <line_num>: 124,264
private FlowScope caseEquality(Node condition, FlowScope blindScope, Function<TypePair, TypePair> merging) { [EOL]     return caseEquality(condition.getFirstChild(), condition.getLastChild(), blindScope, merging); [EOL] } <line_num>: 266,270
private FlowScope caseEquality(Node left, Node right, FlowScope blindScope, Function<TypePair, TypePair> merging) { [EOL]     JSType leftType = getTypeIfRefinable(left, blindScope); [EOL]     boolean leftIsRefineable; [EOL]     if (leftType != null) { [EOL]         leftIsRefineable = true; [EOL]     } else { [EOL]         leftIsRefineable = false; [EOL]         leftType = left.getJSType(); [EOL]     } [EOL]     JSType rightType = getTypeIfRefinable(right, blindScope); [EOL]     boolean rightIsRefineable; [EOL]     if (rightType != null) { [EOL]         rightIsRefineable = true; [EOL]     } else { [EOL]         rightIsRefineable = false; [EOL]         rightType = right.getJSType(); [EOL]     } [EOL]     TypePair merged = merging.apply(new TypePair(leftType, rightType)); [EOL]     if (merged != null) { [EOL]         return maybeRestrictTwoNames(blindScope, left, leftType, leftIsRefineable ? merged.typeA : null, right, rightType, rightIsRefineable ? merged.typeB : null); [EOL]     } [EOL]     return blindScope; [EOL] } <line_num>: 272,305
private FlowScope caseAndOrNotShortCircuiting(Node left, Node right, FlowScope blindScope, boolean condition) { [EOL]     JSType leftType = getTypeIfRefinable(left, blindScope); [EOL]     boolean leftIsRefineable; [EOL]     if (leftType != null) { [EOL]         leftIsRefineable = true; [EOL]     } else { [EOL]         leftIsRefineable = false; [EOL]         leftType = left.getJSType(); [EOL]         blindScope = firstPreciserScopeKnowingConditionOutcome(left, blindScope, condition); [EOL]     } [EOL]     JSType restrictedLeftType = (leftType == null) ? null : leftType.getRestrictedTypeGivenToBooleanOutcome(condition); [EOL]     if (restrictedLeftType == null) { [EOL]         return firstPreciserScopeKnowingConditionOutcome(right, blindScope, condition); [EOL]     } [EOL]     JSType rightType = getTypeIfRefinable(right, blindScope); [EOL]     boolean rightIsRefineable; [EOL]     if (rightType != null) { [EOL]         rightIsRefineable = true; [EOL]     } else { [EOL]         rightIsRefineable = false; [EOL]         rightType = right.getJSType(); [EOL]         blindScope = firstPreciserScopeKnowingConditionOutcome(right, blindScope, condition); [EOL]     } [EOL]     if (condition) { [EOL]         JSType restrictedRightType = (rightType == null) ? null : rightType.getRestrictedTypeGivenToBooleanOutcome(condition); [EOL]         return maybeRestrictTwoNames(blindScope, left, leftType, leftIsRefineable ? restrictedLeftType : null, right, rightType, rightIsRefineable ? restrictedRightType : null); [EOL]     } [EOL]     return blindScope; [EOL] } <line_num>: 307,352
private FlowScope caseAndOrMaybeShortCircuiting(Node left, Node right, FlowScope blindScope, boolean condition) { [EOL]     FlowScope leftScope = firstPreciserScopeKnowingConditionOutcome(left, blindScope, !condition); [EOL]     StaticSlot<JSType> leftVar = leftScope.findUniqueRefinedSlot(blindScope); [EOL]     if (leftVar == null) { [EOL]         return blindScope; [EOL]     } [EOL]     FlowScope rightScope = firstPreciserScopeKnowingConditionOutcome(left, blindScope, condition); [EOL]     rightScope = firstPreciserScopeKnowingConditionOutcome(right, rightScope, !condition); [EOL]     StaticSlot<JSType> rightVar = rightScope.findUniqueRefinedSlot(blindScope); [EOL]     if (rightVar == null || !leftVar.getName().equals(rightVar.getName())) { [EOL]         return blindScope; [EOL]     } [EOL]     JSType type = leftVar.getType().getLeastSupertype(rightVar.getType()); [EOL]     FlowScope informed = blindScope.createChildFlowScope(); [EOL]     informed.inferSlotType(leftVar.getName(), type); [EOL]     return informed; [EOL] } <line_num>: 354,374
private FlowScope maybeRestrictName(FlowScope blindScope, Node node, JSType originalType, JSType restrictedType) { [EOL]     if (restrictedType != null && restrictedType != originalType) { [EOL]         FlowScope informed = blindScope.createChildFlowScope(); [EOL]         declareNameInScope(informed, node, restrictedType); [EOL]         return informed; [EOL]     } [EOL]     return blindScope; [EOL] } <line_num>: 392,400
private FlowScope maybeRestrictTwoNames(FlowScope blindScope, Node left, JSType originalLeftType, JSType restrictedLeftType, Node right, JSType originalRightType, JSType restrictedRightType) { [EOL]     boolean shouldRefineLeft = restrictedLeftType != null && restrictedLeftType != originalLeftType; [EOL]     boolean shouldRefineRight = restrictedRightType != null && restrictedRightType != originalRightType; [EOL]     if (shouldRefineLeft || shouldRefineRight) { [EOL]         FlowScope informed = blindScope.createChildFlowScope(); [EOL]         if (shouldRefineLeft) { [EOL]             declareNameInScope(informed, left, restrictedLeftType); [EOL]         } [EOL]         if (shouldRefineRight) { [EOL]             declareNameInScope(informed, right, restrictedRightType); [EOL]         } [EOL]         return informed; [EOL]     } [EOL]     return blindScope; [EOL] } <line_num>: 405,424
private FlowScope caseNameOrGetProp(Node name, FlowScope blindScope, boolean outcome) { [EOL]     JSType type = getTypeIfRefinable(name, blindScope); [EOL]     if (type != null) { [EOL]         return maybeRestrictName(blindScope, name, type, type.getRestrictedTypeGivenToBooleanOutcome(outcome)); [EOL]     } [EOL]     return blindScope; [EOL] } <line_num>: 426,435
private FlowScope caseTypeOf(Node node, JSType type, String value, boolean resultEqualsValue, FlowScope blindScope) { [EOL]     return maybeRestrictName(blindScope, node, type, getRestrictedByTypeOfResult(type, value, resultEqualsValue)); [EOL] } <line_num>: 437,442
private FlowScope caseInstanceOf(Node left, Node right, FlowScope blindScope, boolean outcome) { [EOL]     JSType leftType = getTypeIfRefinable(left, blindScope); [EOL]     if (leftType == null) { [EOL]         return blindScope; [EOL]     } [EOL]     JSType rightType = right.getJSType(); [EOL]     ObjectType targetType = typeRegistry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE); [EOL]     if (rightType != null && rightType.isFunctionType()) { [EOL]         targetType = rightType.toMaybeFunctionType(); [EOL]     } [EOL]     Visitor<JSType> visitor; [EOL]     if (outcome) { [EOL]         visitor = new RestrictByTrueInstanceOfResultVisitor(targetType); [EOL]     } else { [EOL]         visitor = new RestrictByFalseInstanceOfResultVisitor(targetType); [EOL]     } [EOL]     return maybeRestrictName(blindScope, left, leftType, leftType.visit(visitor)); [EOL] } <line_num>: 444,464
private FlowScope caseIn(Node object, String propertyName, FlowScope blindScope) { [EOL]     JSType jsType = object.getJSType(); [EOL]     jsType = this.getRestrictedWithoutNull(jsType); [EOL]     jsType = this.getRestrictedWithoutUndefined(jsType); [EOL]     boolean hasProperty = false; [EOL]     ObjectType objectType = ObjectType.cast(jsType); [EOL]     if (objectType != null) { [EOL]         hasProperty = objectType.hasProperty(propertyName); [EOL]     } [EOL]     if (!hasProperty) { [EOL]         String qualifiedName = object.getQualifiedName(); [EOL]         if (qualifiedName != null) { [EOL]             String propertyQualifiedName = qualifiedName + "." + propertyName; [EOL]             if (blindScope.getSlot(propertyQualifiedName) == null) { [EOL]                 FlowScope informed = blindScope.createChildFlowScope(); [EOL]                 JSType unknownType = typeRegistry.getNativeType(JSTypeNative.UNKNOWN_TYPE); [EOL]                 informed.inferQualifiedSlot(object, propertyQualifiedName, unknownType, unknownType); [EOL]                 return informed; [EOL]             } [EOL]         } [EOL]     } [EOL]     return blindScope; [EOL] } <line_num>: 473,498
@Override [EOL] protected JSType caseTopType(JSType type) { [EOL]     return applyCommonRestriction(type); [EOL] } <line_num>: 511,514
@Override [EOL] public JSType caseUnknownType() { [EOL]     FunctionType funcTarget = JSType.toMaybeFunctionType(target); [EOL]     if (funcTarget != null && funcTarget.hasInstanceType()) { [EOL]         return funcTarget.getInstanceType(); [EOL]     } [EOL]     return getNativeType(UNKNOWN_TYPE); [EOL] } <line_num>: 516,523
@Override [EOL] public JSType caseObjectType(ObjectType type) { [EOL]     return applyCommonRestriction(type); [EOL] } <line_num>: 525,528
@Override [EOL] public JSType caseUnionType(UnionType type) { [EOL]     return applyCommonRestriction(type); [EOL] } <line_num>: 530,533
@Override [EOL] public JSType caseFunctionType(FunctionType type) { [EOL]     return caseObjectType(type); [EOL] } <line_num>: 535,538
private JSType applyCommonRestriction(JSType type) { [EOL]     if (target.isUnknownType()) { [EOL]         return type; [EOL]     } [EOL]     FunctionType funcTarget = target.toMaybeFunctionType(); [EOL]     if (funcTarget.hasInstanceType()) { [EOL]         return type.getGreatestSubtype(funcTarget.getInstanceType()); [EOL]     } [EOL]     return null; [EOL] } <line_num>: 540,551
@Override [EOL] public JSType caseObjectType(ObjectType type) { [EOL]     if (target.isUnknownType()) { [EOL]         return type; [EOL]     } [EOL]     FunctionType funcTarget = target.toMaybeFunctionType(); [EOL]     if (funcTarget.hasInstanceType()) { [EOL]         if (type.isSubtype(funcTarget.getInstanceType())) { [EOL]             return null; [EOL]         } [EOL]         return type; [EOL]     } [EOL]     return null; [EOL] } <line_num>: 565,581
@Override [EOL] public JSType caseUnionType(UnionType type) { [EOL]     if (target.isUnknownType()) { [EOL]         return type; [EOL]     } [EOL]     FunctionType funcTarget = target.toMaybeFunctionType(); [EOL]     if (funcTarget.hasInstanceType()) { [EOL]         return type.getRestrictedUnion(funcTarget.getInstanceType()); [EOL]     } [EOL]     return null; [EOL] } <line_num>: 583,595
@Override [EOL] public JSType caseFunctionType(FunctionType type) { [EOL]     return caseObjectType(type); [EOL] } <line_num>: 597,600
