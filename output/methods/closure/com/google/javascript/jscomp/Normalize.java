Normalize(AbstractCompiler compiler, boolean assertOnChange) { [EOL]     this.compiler = compiler; [EOL]     this.assertOnChange = assertOnChange; [EOL] } <line_num>: 79,85
RewriteExposedProperties(Set<String> exposedProperties) { [EOL]     this.exposedProperties = exposedProperties; [EOL] } <line_num>: 192,194
PropagateConstantAnnotationsOverVars(AbstractCompiler compiler, boolean forbidChanges) { [EOL]     this.compiler = compiler; [EOL]     this.assertOnChange = forbidChanges; [EOL] } <line_num>: 224,228
VerifyConstants(AbstractCompiler compiler, boolean checkUserDeclarations) { [EOL]     this.compiler = compiler; [EOL]     this.checkUserDeclarations = checkUserDeclarations; [EOL] } <line_num>: 278,281
NormalizeStatements(AbstractCompiler compiler, boolean assertOnChange) { [EOL]     this.compiler = compiler; [EOL]     this.assertOnChange = assertOnChange; [EOL] } <line_num>: 360,363
static Node parseAndNormalizeSyntheticCode(AbstractCompiler compiler, String code, String prefix) { [EOL]     Node js = compiler.parseSyntheticCode(code); [EOL]     NodeTraversal.traverse(compiler, js, new Normalize.NormalizeStatements(compiler, false)); [EOL]     NodeTraversal.traverse(compiler, js, new MakeDeclaredNamesUnique(new BoilerplateRenamer(compiler.getUniqueNameIdSupplier(), prefix))); [EOL]     return js; [EOL] } <line_num>: 87,99
static Node parseAndNormalizeTestCode(AbstractCompiler compiler, String code, String prefix) { [EOL]     Node js = compiler.parseTestCode(code); [EOL]     NodeTraversal.traverse(compiler, js, new Normalize.NormalizeStatements(compiler, false)); [EOL]     NodeTraversal.traverse(compiler, js, new MakeDeclaredNamesUnique()); [EOL]     return js; [EOL] } <line_num>: 101,110
private void reportCodeChange(String changeDescription) { [EOL]     if (assertOnChange) { [EOL]         throw new IllegalStateException("Normalize constraints violated:\n" + changeDescription); [EOL]     } [EOL]     compiler.reportCodeChange(); [EOL] } <line_num>: 112,118
@Override [EOL] public void process(Node externs, Node root) { [EOL]     new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverseRoots(externs, root); [EOL]     if (MAKE_LOCAL_NAMES_UNIQUE) { [EOL]         MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(); [EOL]         NodeTraversal t = new NodeTraversal(compiler, renamer); [EOL]         t.traverseRoots(externs, root); [EOL]     } [EOL]     removeDuplicateDeclarations(externs, root); [EOL]     new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root); [EOL]     FindExposeAnnotations findExposeAnnotations = new FindExposeAnnotations(); [EOL]     NodeTraversal.traverse(compiler, root, findExposeAnnotations); [EOL]     if (!findExposeAnnotations.exposedProperties.isEmpty()) { [EOL]         NodeTraversal.traverse(compiler, root, new RewriteExposedProperties(findExposeAnnotations.exposedProperties)); [EOL]     } [EOL]     if (!compiler.getLifeCycleStage().isNormalized()) { [EOL]         compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED); [EOL]     } [EOL] } <line_num>: 120,159
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (NodeUtil.isExprAssign(n)) { [EOL]         Node assign = n.getFirstChild(); [EOL]         Node lhs = assign.getFirstChild(); [EOL]         if (lhs.isGetProp() && isMarkedExpose(assign)) { [EOL]             exposedProperties.add(lhs.getLastChild().getString()); [EOL]         } [EOL]     } else if (n.isStringKey() && isMarkedExpose(n)) { [EOL]         exposedProperties.add(n.getString()); [EOL]     } [EOL] } <line_num>: 167,177
private boolean isMarkedExpose(Node n) { [EOL]     JSDocInfo info = n.getJSDocInfo(); [EOL]     return info != null && info.isExpose(); [EOL] } <line_num>: 179,182
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (n.isGetProp()) { [EOL]         String propName = n.getLastChild().getString(); [EOL]         if (exposedProperties.contains(propName)) { [EOL]             Node obj = n.removeFirstChild(); [EOL]             Node prop = n.removeFirstChild(); [EOL]             n.getParent().replaceChild(n, IR.getelem(obj, prop)); [EOL]             compiler.reportCodeChange(); [EOL]         } [EOL]     } else if (n.isStringKey()) { [EOL]         String propName = n.getString(); [EOL]         if (exposedProperties.contains(propName)) { [EOL]             n.setQuotedString(); [EOL]             compiler.reportCodeChange(); [EOL]         } [EOL]     } [EOL] } <line_num>: 196,212
@Override [EOL] public void process(Node externs, Node root) { [EOL]     new NodeTraversal(compiler, this).traverseRoots(externs, root); [EOL] } <line_num>: 230,233
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (n.isName()) { [EOL]         if (n.getString().isEmpty()) { [EOL]             return; [EOL]         } [EOL]         JSDocInfo info = null; [EOL]         Var var = t.getScope().getVar(n.getString()); [EOL]         if (var != null) { [EOL]             info = var.getJSDocInfo(); [EOL]         } [EOL]         boolean shouldBeConstant = (info != null && info.isConstant()) || NodeUtil.isConstantByConvention(compiler.getCodingConvention(), n, parent); [EOL]         boolean isMarkedConstant = n.getBooleanProp(Node.IS_CONSTANT_NAME); [EOL]         if (shouldBeConstant && !isMarkedConstant) { [EOL]             if (assertOnChange) { [EOL]                 String name = n.getString(); [EOL]                 throw new IllegalStateException("Unexpected const change.\n" + "  name: " + name + "\n" + "  parent:" + n.getParent().toStringTree()); [EOL]             } [EOL]             n.putBooleanProp(Node.IS_CONSTANT_NAME, true); [EOL]         } [EOL]     } [EOL] } <line_num>: 235,266
@Override [EOL] public void process(Node externs, Node root) { [EOL]     Node externsAndJs = root.getParent(); [EOL]     Preconditions.checkState(externsAndJs != null); [EOL]     Preconditions.checkState(externsAndJs.hasChild(externs)); [EOL]     NodeTraversal.traverseRoots(compiler, Lists.newArrayList(externs, root), this); [EOL] } <line_num>: 283,291
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (n.isName()) { [EOL]         String name = n.getString(); [EOL]         if (n.getString().isEmpty()) { [EOL]             return; [EOL]         } [EOL]         boolean isConst = n.getBooleanProp(Node.IS_CONSTANT_NAME); [EOL]         if (checkUserDeclarations) { [EOL]             boolean expectedConst = false; [EOL]             CodingConvention convention = compiler.getCodingConvention(); [EOL]             if (NodeUtil.isConstantName(n) || NodeUtil.isConstantByConvention(convention, n, parent)) { [EOL]                 expectedConst = true; [EOL]             } else { [EOL]                 expectedConst = false; [EOL]                 JSDocInfo info = null; [EOL]                 Var var = t.getScope().getVar(n.getString()); [EOL]                 if (var != null) { [EOL]                     info = var.getJSDocInfo(); [EOL]                 } [EOL]                 if (info != null && info.isConstant()) { [EOL]                     expectedConst = true; [EOL]                 } else { [EOL]                     expectedConst = false; [EOL]                 } [EOL]             } [EOL]             if (expectedConst) { [EOL]                 Preconditions.checkState(expectedConst == isConst, "The name %s is not annotated as constant.", name); [EOL]             } else { [EOL]                 Preconditions.checkState(expectedConst == isConst, "The name %s should not be annotated as constant.", name); [EOL]             } [EOL]         } [EOL]         Boolean value = constantMap.get(name); [EOL]         if (value == null) { [EOL]             constantMap.put(name, isConst); [EOL]         } else { [EOL]             Preconditions.checkState(value.booleanValue() == isConst, "The name %s is not consistently annotated as constant.", name); [EOL]         } [EOL]     } [EOL] } <line_num>: 295,343
private void reportCodeChange(String changeDescription) { [EOL]     if (assertOnChange) { [EOL]         throw new IllegalStateException("Normalize constraints violated:\n" + changeDescription); [EOL]     } [EOL]     compiler.reportCodeChange(); [EOL] } <line_num>: 365,371
@Override [EOL] public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { [EOL]     doStatementNormalizations(t, n, parent); [EOL]     return true; [EOL] } <line_num>: 373,378
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     switch(n.getType()) { [EOL]         case Token.WHILE: [EOL]             if (CONVERT_WHILE_TO_FOR) { [EOL]                 Node expr = n.getFirstChild(); [EOL]                 n.setType(Token.FOR); [EOL]                 Node empty = IR.empty(); [EOL]                 empty.copyInformationFrom(n); [EOL]                 n.addChildBefore(empty, expr); [EOL]                 n.addChildAfter(empty.cloneNode(), expr); [EOL]                 reportCodeChange("WHILE node"); [EOL]             } [EOL]             break; [EOL]         case Token.FUNCTION: [EOL]             normalizeFunctionDeclaration(n); [EOL]             break; [EOL]         case Token.NAME: [EOL]         case Token.STRING: [EOL]         case Token.STRING_KEY: [EOL]         case Token.GETTER_DEF: [EOL]         case Token.SETTER_DEF: [EOL]             if (!compiler.getLifeCycleStage().isNormalizedObfuscated()) { [EOL]                 annotateConstantsByConvention(n, parent); [EOL]             } [EOL]             break; [EOL]         case Token.CAST: [EOL]             parent.replaceChild(n, n.removeFirstChild()); [EOL]             break; [EOL]     } [EOL] } <line_num>: 380,413
private void annotateConstantsByConvention(Node n, Node parent) { [EOL]     Preconditions.checkState(n.isName() || n.isString() || n.isStringKey() || n.isGetterDef() || n.isSetterDef()); [EOL]     boolean isObjLitKey = NodeUtil.isObjectLitKey(n, parent); [EOL]     boolean isProperty = isObjLitKey || (parent.isGetProp() && parent.getLastChild() == n); [EOL]     if (n.isName() || isProperty) { [EOL]         boolean isMarkedConstant = n.getBooleanProp(Node.IS_CONSTANT_NAME); [EOL]         if (!isMarkedConstant && NodeUtil.isConstantByConvention(compiler.getCodingConvention(), n, parent)) { [EOL]             if (assertOnChange) { [EOL]                 String name = n.getString(); [EOL]                 throw new IllegalStateException("Unexpected const change.\n" + "  name: " + name + "\n" + "  parent:" + n.getParent().toStringTree()); [EOL]             } [EOL]             n.putBooleanProp(Node.IS_CONSTANT_NAME, true); [EOL]         } [EOL]     } [EOL] } <line_num>: 418,448
private void normalizeFunctionDeclaration(Node n) { [EOL]     Preconditions.checkState(n.isFunction()); [EOL]     if (!NodeUtil.isFunctionExpression(n) && !NodeUtil.isHoistedFunctionDeclaration(n)) { [EOL]         rewriteFunctionDeclaration(n); [EOL]     } [EOL] } <line_num>: 458,464
private void rewriteFunctionDeclaration(Node n) { [EOL]     Node oldNameNode = n.getFirstChild(); [EOL]     Node fnNameNode = oldNameNode.cloneNode(); [EOL]     Node var = IR.var(fnNameNode).srcref(n); [EOL]     oldNameNode.setString(""); [EOL]     Node parent = n.getParent(); [EOL]     parent.replaceChild(n, var); [EOL]     fnNameNode.addChildToFront(n); [EOL]     reportCodeChange("Function declaration"); [EOL] } <line_num>: 482,497
private void doStatementNormalizations(NodeTraversal t, Node n, Node parent) { [EOL]     if (n.isLabel()) { [EOL]         normalizeLabels(n); [EOL]     } [EOL]     if (NodeUtil.isStatementBlock(n) || n.isLabel()) { [EOL]         extractForInitializer(n, null, null); [EOL]     } [EOL]     if (NodeUtil.isStatementBlock(n)) { [EOL]         splitVarDeclarations(n); [EOL]     } [EOL]     if (n.isFunction()) { [EOL]         moveNamedFunctions(n.getLastChild()); [EOL]     } [EOL] } <line_num>: 502,523
private void normalizeLabels(Node n) { [EOL]     Preconditions.checkArgument(n.isLabel()); [EOL]     Node last = n.getLastChild(); [EOL]     switch(last.getType()) { [EOL]         case Token.LABEL: [EOL]         case Token.BLOCK: [EOL]         case Token.FOR: [EOL]         case Token.WHILE: [EOL]         case Token.DO: [EOL]             return; [EOL]         default: [EOL]             Node block = IR.block(); [EOL]             block.copyInformationFrom(last); [EOL]             n.replaceChild(last, block); [EOL]             block.addChildToFront(last); [EOL]             reportCodeChange("LABEL normalization"); [EOL]             return; [EOL]     } [EOL] } <line_num>: 532,551
private void extractForInitializer(Node n, Node before, Node beforeParent) { [EOL]     for (Node next, c = n.getFirstChild(); c != null; c = next) { [EOL]         next = c.getNext(); [EOL]         Node insertBefore = (before == null) ? c : before; [EOL]         Node insertBeforeParent = (before == null) ? n : beforeParent; [EOL]         switch(c.getType()) { [EOL]             case Token.LABEL: [EOL]                 extractForInitializer(c, insertBefore, insertBeforeParent); [EOL]                 break; [EOL]             case Token.FOR: [EOL]                 if (NodeUtil.isForIn(c)) { [EOL]                     Node first = c.getFirstChild(); [EOL]                     if (first.isVar()) { [EOL]                         Node newStatement = first; [EOL]                         Node name = newStatement.getFirstChild().cloneNode(); [EOL]                         first.getParent().replaceChild(first, name); [EOL]                         insertBeforeParent.addChildBefore(newStatement, insertBefore); [EOL]                         reportCodeChange("FOR-IN var declaration"); [EOL]                     } [EOL]                 } else if (!c.getFirstChild().isEmpty()) { [EOL]                     Node init = c.getFirstChild(); [EOL]                     Node empty = IR.empty(); [EOL]                     empty.copyInformationFrom(c); [EOL]                     c.replaceChild(init, empty); [EOL]                     Node newStatement; [EOL]                     if (init.isVar()) { [EOL]                         newStatement = init; [EOL]                     } else { [EOL]                         newStatement = NodeUtil.newExpr(init); [EOL]                     } [EOL]                     insertBeforeParent.addChildBefore(newStatement, insertBefore); [EOL]                     reportCodeChange("FOR initializer"); [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL] } <line_num>: 564,611
private void splitVarDeclarations(Node n) { [EOL]     for (Node next, c = n.getFirstChild(); c != null; c = next) { [EOL]         next = c.getNext(); [EOL]         if (c.isVar()) { [EOL]             if (assertOnChange && !c.hasChildren()) { [EOL]                 throw new IllegalStateException("Empty VAR node."); [EOL]             } [EOL]             while (c.getFirstChild() != c.getLastChild()) { [EOL]                 Node name = c.getFirstChild(); [EOL]                 c.removeChild(name); [EOL]                 Node newVar = IR.var(name).srcref(n); [EOL]                 n.addChildBefore(newVar, c); [EOL]                 reportCodeChange("VAR with multiple children"); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 621,638
private void moveNamedFunctions(Node functionBody) { [EOL]     Preconditions.checkState(functionBody.getParent().isFunction()); [EOL]     Node previous = null; [EOL]     Node current = functionBody.getFirstChild(); [EOL]     while (current != null && NodeUtil.isFunctionDeclaration(current)) { [EOL]         previous = current; [EOL]         current = current.getNext(); [EOL]     } [EOL]     Node insertAfter = previous; [EOL]     while (current != null) { [EOL]         Node next = current.getNext(); [EOL]         if (NodeUtil.isFunctionDeclaration(current)) { [EOL]             Preconditions.checkNotNull(previous); [EOL]             functionBody.removeChildAfter(previous); [EOL]             insertAfter = addToFront(functionBody, current, insertAfter); [EOL]             reportCodeChange("Move function declaration not at top of function"); [EOL]         } else { [EOL]             previous = current; [EOL]         } [EOL]         current = next; [EOL]     } [EOL] } <line_num>: 644,676
private Node addToFront(Node parent, Node newChild, Node after) { [EOL]     if (after == null) { [EOL]         parent.addChildToFront(newChild); [EOL]     } else { [EOL]         parent.addChildAfter(newChild, after); [EOL]     } [EOL]     return newChild; [EOL] } <line_num>: 683,690
private void removeDuplicateDeclarations(Node externs, Node root) { [EOL]     Callback tickler = new ScopeTicklingCallback(); [EOL]     ScopeCreator scopeCreator = new SyntacticScopeCreator(compiler, new DuplicateDeclarationHandler()); [EOL]     NodeTraversal t = new NodeTraversal(compiler, tickler, scopeCreator); [EOL]     t.traverseRoots(externs, root); [EOL] } <line_num>: 696,702
@Override [EOL] public void onRedeclaration(Scope s, String name, Node n, CompilerInput input) { [EOL]     Preconditions.checkState(n.isName()); [EOL]     Node parent = n.getParent(); [EOL]     Var v = s.getVar(name); [EOL]     if (v != null && s.isGlobal()) { [EOL]         if (v.isExtern() && !input.isExtern()) { [EOL]             if (hasOkDuplicateDeclaration.add(v)) { [EOL]                 return; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (v != null && v.getParentNode().isCatch()) { [EOL]         name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name); [EOL]         compiler.report(JSError.make(input.getName(), n, CATCH_BLOCK_VAR_ERROR, name)); [EOL]     } else if (v != null && parent.isFunction()) { [EOL]         if (v.getParentNode().isVar()) { [EOL]             s.undeclare(v); [EOL]             s.declare(name, n, n.getJSType(), v.input); [EOL]             replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent()); [EOL]         } [EOL]     } else if (parent.isVar()) { [EOL]         Preconditions.checkState(parent.hasOneChild()); [EOL]         replaceVarWithAssignment(n, parent, parent.getParent()); [EOL]     } [EOL] } <line_num>: 716,770
private void replaceVarWithAssignment(Node n, Node parent, Node gramps) { [EOL]     if (n.hasChildren()) { [EOL]         parent.removeChild(n); [EOL]         Node value = n.getFirstChild(); [EOL]         n.removeChild(value); [EOL]         Node replacement = IR.assign(n, value); [EOL]         replacement.copyInformationFrom(parent); [EOL]         gramps.replaceChild(parent, NodeUtil.newExpr(replacement)); [EOL]     } else { [EOL]         if (NodeUtil.isStatementBlock(gramps)) { [EOL]             gramps.removeChild(parent); [EOL]         } else if (gramps.isFor()) { [EOL]             parent.removeChild(n); [EOL]             gramps.replaceChild(parent, n); [EOL]         } else { [EOL]             Preconditions.checkState(gramps.isLabel()); [EOL]             throw new IllegalStateException("Unexpected LABEL"); [EOL]         } [EOL]     } [EOL]     reportCodeChange("Duplicate VAR declaration"); [EOL] } <line_num>: 788,816
@Override [EOL] public void enterScope(NodeTraversal t) { [EOL]     t.getScope(); [EOL] } <line_num>: 824,829
@Override [EOL] public void exitScope(NodeTraversal t) { [EOL] } <line_num>: 831,834
@Override [EOL] public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) { [EOL]     return true; [EOL] } <line_num>: 836,840
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL] } <line_num>: 842,845
