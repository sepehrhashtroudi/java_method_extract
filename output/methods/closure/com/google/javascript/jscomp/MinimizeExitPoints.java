MinimizeExitPoints(AbstractCompiler compiler) { [EOL]     this.compiler = compiler; [EOL] } <line_num>: 42,44
@Override [EOL] public void process(Node externs, Node root) { [EOL]     NodeTraversal.traverse(compiler, root, this); [EOL] } <line_num>: 46,49
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     switch(n.getType()) { [EOL]         case Token.LABEL: [EOL]             tryMinimizeExits(n.getLastChild(), Token.BREAK, n.getFirstChild().getString()); [EOL]             break; [EOL]         case Token.FOR: [EOL]         case Token.WHILE: [EOL]             tryMinimizeExits(NodeUtil.getLoopCodeBlock(n), Token.CONTINUE, null); [EOL]             break; [EOL]         case Token.DO: [EOL]             tryMinimizeExits(NodeUtil.getLoopCodeBlock(n), Token.CONTINUE, null); [EOL]             Node cond = NodeUtil.getConditionExpression(n); [EOL]             if (NodeUtil.getImpureBooleanValue(cond) == TernaryValue.FALSE) { [EOL]                 tryMinimizeExits(n.getFirstChild(), Token.BREAK, null); [EOL]             } [EOL]             break; [EOL]         case Token.FUNCTION: [EOL]             tryMinimizeExits(n.getLastChild(), Token.RETURN, null); [EOL]             break; [EOL]     } [EOL] } <line_num>: 51,84
void tryMinimizeExits(Node n, int exitType, String labelName) { [EOL]     if (matchingExitNode(n, exitType, labelName)) { [EOL]         NodeUtil.removeChild(n.getParent(), n); [EOL]         compiler.reportCodeChange(); [EOL]         return; [EOL]     } [EOL]     if (n.isIf()) { [EOL]         Node ifBlock = n.getFirstChild().getNext(); [EOL]         tryMinimizeExits(ifBlock, exitType, labelName); [EOL]         Node elseBlock = ifBlock.getNext(); [EOL]         if (elseBlock != null) { [EOL]             tryMinimizeExits(elseBlock, exitType, labelName); [EOL]         } [EOL]         return; [EOL]     } [EOL]     if (n.isTry()) { [EOL]         Node tryBlock = n.getFirstChild(); [EOL]         tryMinimizeExits(tryBlock, exitType, labelName); [EOL]         Node allCatchNodes = NodeUtil.getCatchBlock(n); [EOL]         if (NodeUtil.hasCatchHandler(allCatchNodes)) { [EOL]             Preconditions.checkState(allCatchNodes.hasOneChild()); [EOL]             Node catchNode = allCatchNodes.getFirstChild(); [EOL]             Node catchCodeBlock = catchNode.getLastChild(); [EOL]             tryMinimizeExits(catchCodeBlock, exitType, labelName); [EOL]         } [EOL]         if (NodeUtil.hasFinally(n)) { [EOL]             Node finallyBlock = n.getLastChild(); [EOL]             tryMinimizeExits(finallyBlock, exitType, labelName); [EOL]         } [EOL]     } [EOL]     if (n.isLabel()) { [EOL]         Node labelBlock = n.getLastChild(); [EOL]         tryMinimizeExits(labelBlock, exitType, labelName); [EOL]     } [EOL]     if (!n.isBlock() || n.getLastChild() == null) { [EOL]         return; [EOL]     } [EOL]     for (Node c : n.children()) { [EOL]         if (c.isIf()) { [EOL]             Node ifTree = c; [EOL]             Node trueBlock, falseBlock; [EOL]             trueBlock = ifTree.getFirstChild().getNext(); [EOL]             falseBlock = trueBlock.getNext(); [EOL]             tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); [EOL]             trueBlock = ifTree.getFirstChild().getNext(); [EOL]             falseBlock = trueBlock.getNext(); [EOL]             if (falseBlock != null) { [EOL]                 tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); [EOL]             } [EOL]         } [EOL]         if (c == n.getLastChild()) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { [EOL]         tryMinimizeExits(c, exitType, labelName); [EOL]         if (c == n.getLastChild()) { [EOL]             break; [EOL]         } [EOL]     } [EOL] } <line_num>: 114,205
private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock, Node ifNode, int exitType, String labelName) { [EOL]     Node exitNodeParent = null; [EOL]     Node exitNode = null; [EOL]     if (srcBlock.isBlock()) { [EOL]         if (!srcBlock.hasChildren()) { [EOL]             return; [EOL]         } [EOL]         exitNodeParent = srcBlock; [EOL]         exitNode = exitNodeParent.getLastChild(); [EOL]     } else { [EOL]         exitNodeParent = ifNode; [EOL]         exitNode = srcBlock; [EOL]     } [EOL]     if (!matchingExitNode(exitNode, exitType, labelName)) { [EOL]         return; [EOL]     } [EOL]     if (ifNode.getNext() != null) { [EOL]         Node newDestBlock = IR.block().srcref(ifNode); [EOL]         if (destBlock == null) { [EOL]             ifNode.addChildToBack(newDestBlock); [EOL]         } else if (destBlock.isEmpty()) { [EOL]             ifNode.replaceChild(destBlock, newDestBlock); [EOL]         } else if (destBlock.isBlock()) { [EOL]             newDestBlock = destBlock; [EOL]         } else { [EOL]             ifNode.replaceChild(destBlock, newDestBlock); [EOL]             newDestBlock.addChildToBack(destBlock); [EOL]         } [EOL]         moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock); [EOL]     } [EOL]     NodeUtil.removeChild(exitNodeParent, exitNode); [EOL]     compiler.reportCodeChange(); [EOL] } <line_num>: 220,271
static private boolean matchingExitNode(Node n, int type, String labelName) { [EOL]     if (n.getType() == type) { [EOL]         if (type == Token.RETURN) { [EOL]             return !n.hasChildren(); [EOL]         } else { [EOL]             if (labelName == null) { [EOL]                 return !n.hasChildren(); [EOL]             } else { [EOL]                 return n.hasChildren() && labelName.equals(n.getFirstChild().getString()); [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 284,299
static private void moveAllFollowing(Node start, Node srcParent, Node destParent) { [EOL]     for (Node n = start.getNext(); n != null; n = start.getNext()) { [EOL]         boolean isFunctionDeclaration = NodeUtil.isFunctionDeclaration(n); [EOL]         srcParent.removeChild(n); [EOL]         if (isFunctionDeclaration) { [EOL]             destParent.addChildToFront(n); [EOL]         } else { [EOL]             destParent.addChildToBack(n); [EOL]         } [EOL]     } [EOL] } <line_num>: 308,322
