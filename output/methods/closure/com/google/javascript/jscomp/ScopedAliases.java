ScopedAliases(AbstractCompiler compiler, @Nullable PreprocessorSymbolTable preprocessorSymbolTable, AliasTransformationHandler transformationHandler) { [EOL]     this.compiler = compiler; [EOL]     this.preprocessorSymbolTable = preprocessorSymbolTable; [EOL]     this.transformationHandler = transformationHandler; [EOL] } <line_num>: 93,99
AliasedNode(Node aliasReference, Node aliasDefinition) { [EOL]     this.aliasReference = aliasReference; [EOL]     this.aliasDefinition = aliasDefinition; [EOL] } <line_num>: 156,159
AliasedTypeNode(Node typeReference, Node aliasDefinition, String aliasName) { [EOL]     this.typeReference = typeReference; [EOL]     this.aliasDefinition = aliasDefinition; [EOL]     this.aliasName = aliasName; [EOL] } <line_num>: 173,178
@Override [EOL] public void process(Node externs, Node root) { [EOL]     hotSwapScript(root, null); [EOL] } <line_num>: 101,104
@Override [EOL] public void hotSwapScript(Node root, Node originalRoot) { [EOL]     Traversal traversal = new Traversal(); [EOL]     NodeTraversal.traverse(compiler, root, traversal); [EOL]     if (!traversal.hasErrors()) { [EOL]         for (AliasUsage aliasUsage : traversal.getAliasUsages()) { [EOL]             aliasUsage.applyAlias(); [EOL]         } [EOL]         for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) { [EOL]             if (aliasDefinition.getParent().isVar() && aliasDefinition.getParent().hasOneChild()) { [EOL]                 aliasDefinition.getParent().detachFromParent(); [EOL]             } else { [EOL]                 aliasDefinition.detachFromParent(); [EOL]             } [EOL]         } [EOL]         for (Node scopeCall : traversal.getScopeCalls()) { [EOL]             Node expressionWithScopeCall = scopeCall.getParent(); [EOL]             Node scopeClosureBlock = scopeCall.getLastChild().getLastChild(); [EOL]             scopeClosureBlock.detachFromParent(); [EOL]             expressionWithScopeCall.getParent().replaceChild(expressionWithScopeCall, scopeClosureBlock); [EOL]             NodeUtil.tryMergeBlock(scopeClosureBlock); [EOL]         } [EOL]         if (traversal.getAliasUsages().size() > 0 || traversal.getAliasDefinitionsInOrder().size() > 0 || traversal.getScopeCalls().size() > 0) { [EOL]             compiler.reportCodeChange(); [EOL]         } [EOL]     } [EOL] } <line_num>: 106,145
public void applyAlias(); <line_num>: 148,148
@Override [EOL] public void applyAlias() { [EOL]     aliasReference.getParent().replaceChild(aliasReference, aliasDefinition.cloneTree()); [EOL] } <line_num>: 161,165
@Override [EOL] public void applyAlias() { [EOL]     String typeName = typeReference.getString(); [EOL]     String aliasExpanded = Preconditions.checkNotNull(aliasDefinition.getQualifiedName()); [EOL]     Preconditions.checkState(typeName.startsWith(aliasName)); [EOL]     typeReference.setString(typeName.replaceFirst(aliasName, aliasExpanded)); [EOL] } <line_num>: 180,187
Collection<Node> getAliasDefinitionsInOrder() { [EOL]     return aliasDefinitionsInOrder; [EOL] } <line_num>: 221,223
private List<AliasUsage> getAliasUsages() { [EOL]     return aliasUsages; [EOL] } <line_num>: 225,227
List<Node> getScopeCalls() { [EOL]     return scopeCalls; [EOL] } <line_num>: 229,231
boolean hasErrors() { [EOL]     return hasErrors; [EOL] } <line_num>: 233,235
private boolean isCallToScopeMethod(Node n) { [EOL]     return n.isCall() && SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName()); [EOL] } <line_num>: 237,240
@Override [EOL] public void enterScope(NodeTraversal t) { [EOL]     Node n = t.getCurrentNode().getParent(); [EOL]     if (n != null && isCallToScopeMethod(n)) { [EOL]         transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n)); [EOL]         findAliases(t); [EOL]     } [EOL] } <line_num>: 242,250
@Override [EOL] public void exitScope(NodeTraversal t) { [EOL]     if (t.getScopeDepth() > 2) { [EOL]         findNamespaceShadows(t); [EOL]     } [EOL]     if (t.getScopeDepth() == 2) { [EOL]         renameNamespaceShadows(t); [EOL]         aliases.clear(); [EOL]         forbiddenLocals.clear(); [EOL]         transformation = null; [EOL]         hasNamespaceShadows = false; [EOL]     } [EOL] } <line_num>: 252,265
@Override [EOL] public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { [EOL]     if (n.isFunction() && t.inGlobalScope()) { [EOL]         if (parent == null || !isCallToScopeMethod(parent)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 267,276
private SourcePosition<AliasTransformation> getSourceRegion(Node n) { [EOL]     Node testNode = n; [EOL]     Node next = null; [EOL]     for (; next != null || testNode.isScript(); ) { [EOL]         next = testNode.getNext(); [EOL]         testNode = testNode.getParent(); [EOL]     } [EOL]     int endLine = next == null ? Integer.MAX_VALUE : next.getLineno(); [EOL]     int endChar = next == null ? Integer.MAX_VALUE : next.getCharno(); [EOL]     SourcePosition<AliasTransformation> pos = new SourcePosition<AliasTransformation>() { [EOL]     }; [EOL]     pos.setPositionInformation(n.getLineno(), n.getCharno(), endLine, endChar); [EOL]     return pos; [EOL] } <line_num>: 278,293
private void report(NodeTraversal t, Node n, DiagnosticType error, String... arguments) { [EOL]     compiler.report(t.makeError(n, error, arguments)); [EOL]     hasErrors = true; [EOL] } <line_num>: 295,299
private void findAliases(NodeTraversal t) { [EOL]     Scope scope = t.getScope(); [EOL]     for (Var v : scope.getVarIterable()) { [EOL]         Node n = v.getNode(); [EOL]         int type = n.getType(); [EOL]         Node parent = n.getParent(); [EOL]         if (parent.isVar() && n.hasChildren() && n.getFirstChild().isQualifiedName()) { [EOL]             String name = n.getString(); [EOL]             Var aliasVar = scope.getVar(name); [EOL]             aliases.put(name, aliasVar); [EOL]             String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); [EOL]             transformation.addAlias(name, qualifiedName); [EOL]             int rootIndex = qualifiedName.indexOf("."); [EOL]             if (rootIndex != -1) { [EOL]                 String qNameRoot = qualifiedName.substring(0, rootIndex); [EOL]                 if (!aliases.containsKey(qNameRoot)) { [EOL]                     forbiddenLocals.add(qNameRoot); [EOL]                 } [EOL]             } [EOL]         } else if (v.isBleedingFunction()) { [EOL]         } else if (parent.getType() == Token.LP) { [EOL]         } else { [EOL]             report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); [EOL]         } [EOL]     } [EOL] } <line_num>: 301,335
private void findNamespaceShadows(NodeTraversal t) { [EOL]     if (hasNamespaceShadows) { [EOL]         return; [EOL]     } [EOL]     Scope scope = t.getScope(); [EOL]     for (Var v : scope.getVarIterable()) { [EOL]         if (forbiddenLocals.contains(v.getName())) { [EOL]             hasNamespaceShadows = true; [EOL]             return; [EOL]         } [EOL]     } [EOL] } <line_num>: 338,350
private void renameNamespaceShadows(NodeTraversal t) { [EOL]     if (hasNamespaceShadows) { [EOL]         MakeDeclaredNamesUnique.Renamer renamer = new MakeDeclaredNamesUnique.WhitelistedRenamer(new MakeDeclaredNamesUnique.ContextualRenamer(), forbiddenLocals); [EOL]         for (String s : forbiddenLocals) { [EOL]             renamer.addDeclaredName(s); [EOL]         } [EOL]         MakeDeclaredNamesUnique uniquifier = new MakeDeclaredNamesUnique(renamer); [EOL]         NodeTraversal.traverse(compiler, t.getScopeRoot(), uniquifier); [EOL]     } [EOL] } <line_num>: 357,370
private void validateScopeCall(NodeTraversal t, Node n, Node parent) { [EOL]     if (preprocessorSymbolTable != null) { [EOL]         preprocessorSymbolTable.addReference(n.getFirstChild()); [EOL]     } [EOL]     if (!parent.isExprResult()) { [EOL]         report(t, n, GOOG_SCOPE_USED_IMPROPERLY); [EOL]     } [EOL]     if (n.getChildCount() != 2) { [EOL]         report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS); [EOL]     } else { [EOL]         Node anonymousFnNode = n.getChildAtIndex(1); [EOL]         if (!anonymousFnNode.isFunction() || NodeUtil.getFunctionName(anonymousFnNode) != null || NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) { [EOL]             report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS); [EOL]         } else { [EOL]             scopeCalls.add(n); [EOL]         } [EOL]     } [EOL] } <line_num>: 372,393
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (isCallToScopeMethod(n)) { [EOL]         validateScopeCall(t, n, n.getParent()); [EOL]     } [EOL]     if (t.getScopeDepth() < 2) { [EOL]         return; [EOL]     } [EOL]     int type = n.getType(); [EOL]     Var aliasVar = null; [EOL]     if (type == Token.NAME) { [EOL]         String name = n.getString(); [EOL]         Var lexicalVar = t.getScope().getVar(n.getString()); [EOL]         if (lexicalVar != null && lexicalVar == aliases.get(name)) { [EOL]             aliasVar = lexicalVar; [EOL]         } [EOL]     } [EOL]     if (t.getScopeDepth() == 2) { [EOL]         if (aliasVar != null && NodeUtil.isLValue(n)) { [EOL]             if (aliasVar.getNode() == n) { [EOL]                 aliasDefinitionsInOrder.add(n); [EOL]                 return; [EOL]             } else { [EOL]                 report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString()); [EOL]             } [EOL]         } [EOL]         if (type == Token.RETURN) { [EOL]             report(t, n, GOOG_SCOPE_USES_RETURN); [EOL]         } else if (type == Token.THIS) { [EOL]             report(t, n, GOOG_SCOPE_REFERENCES_THIS); [EOL]         } else if (type == Token.THROW) { [EOL]             report(t, n, GOOG_SCOPE_USES_THROW); [EOL]         } [EOL]     } [EOL]     if (t.getScopeDepth() >= 2) { [EOL]         if (aliasVar != null) { [EOL]             Node aliasedNode = aliasVar.getInitialValue(); [EOL]             aliasUsages.add(new AliasedNode(n, aliasedNode)); [EOL]         } [EOL]         JSDocInfo info = n.getJSDocInfo(); [EOL]         if (info != null) { [EOL]             for (Node node : info.getTypeNodes()) { [EOL]                 fixTypeNode(node); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 395,461
private void fixTypeNode(Node typeNode) { [EOL]     if (typeNode.isString()) { [EOL]         String name = typeNode.getString(); [EOL]         int endIndex = name.indexOf('.'); [EOL]         if (endIndex == -1) { [EOL]             endIndex = name.length(); [EOL]         } [EOL]         String baseName = name.substring(0, endIndex); [EOL]         Var aliasVar = aliases.get(baseName); [EOL]         if (aliasVar != null) { [EOL]             Node aliasedNode = aliasVar.getInitialValue(); [EOL]             aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode, baseName)); [EOL]         } [EOL]     } [EOL]     for (Node child = typeNode.getFirstChild(); child != null; child = child.getNext()) { [EOL]         fixTypeNode(child); [EOL]     } [EOL] } <line_num>: 463,482
