ReplaceCssNames(AbstractCompiler compiler, @Nullable Map<String, Integer> cssNames, @Nullable Set<String> whitelist) { [EOL]     this.compiler = compiler; [EOL]     this.cssNames = cssNames; [EOL]     this.whitelist = whitelist; [EOL]     this.nativeStringType = compiler.getTypeRegistry().getNativeType(STRING_TYPE); [EOL] } <line_num>: 118,126
@Override [EOL] public void process(Node externs, Node root) { [EOL]     symbolMap = getCssRenamingMap(); [EOL]     NodeTraversal.traverse(compiler, root, new Traversal()); [EOL] } <line_num>: 128,136
@VisibleForTesting [EOL] protected CssRenamingMap getCssRenamingMap() { [EOL]     return compiler.getCssRenamingMap(); [EOL] } <line_num>: 138,141
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (n.isCall() && GET_CSS_NAME_FUNCTION.equals(n.getFirstChild().getQualifiedName())) { [EOL]         int count = n.getChildCount(); [EOL]         Node first = n.getFirstChild().getNext(); [EOL]         switch(count) { [EOL]             case 2: [EOL]                 if (first.isString()) { [EOL]                     processStringNode(t, first); [EOL]                     n.removeChild(first); [EOL]                     parent.replaceChild(n, first); [EOL]                     compiler.reportCodeChange(); [EOL]                 } else { [EOL]                     compiler.report(t.makeError(n, STRING_LITERAL_EXPECTED_ERROR, Token.name(first.getType()))); [EOL]                 } [EOL]                 break; [EOL]             case 3: [EOL]                 Node second = first.getNext(); [EOL]                 if (!second.isString()) { [EOL]                     compiler.report(t.makeError(n, STRING_LITERAL_EXPECTED_ERROR, Token.name(second.getType()))); [EOL]                 } else if (first.isString()) { [EOL]                     compiler.report(t.makeError(n, UNEXPECTED_STRING_LITERAL_ERROR, first.getString(), second.getString())); [EOL]                 } else { [EOL]                     processStringNode(t, second); [EOL]                     n.removeChild(first); [EOL]                     Node replacement = IR.add(first, IR.string("-" + second.getString()).copyInformationFrom(second)).copyInformationFrom(n); [EOL]                     replacement.setJSType(nativeStringType); [EOL]                     parent.replaceChild(n, replacement); [EOL]                     compiler.reportCodeChange(); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 compiler.report(t.makeError(n, INVALID_NUM_ARGUMENTS_ERROR, String.valueOf(count))); [EOL]         } [EOL]     } [EOL] } <line_num>: 145,196
private void processStringNode(NodeTraversal t, Node n) { [EOL]     String name = n.getString(); [EOL]     if (whitelist != null && whitelist.contains(name)) { [EOL]         return; [EOL]     } [EOL]     String[] parts = name.split("-"); [EOL]     if (symbolMap != null) { [EOL]         String replacement = null; [EOL]         switch(symbolMap.getStyle()) { [EOL]             case BY_WHOLE: [EOL]                 replacement = symbolMap.get(name); [EOL]                 if (replacement == null) { [EOL]                     compiler.report(t.makeError(n, UNKNOWN_SYMBOL_WARNING, name, name)); [EOL]                     return; [EOL]                 } [EOL]                 break; [EOL]             case BY_PART: [EOL]                 String[] replaced = new String[parts.length]; [EOL]                 for (int i = 0; i < parts.length; i++) { [EOL]                     String part = symbolMap.get(parts[i]); [EOL]                     if (part == null) { [EOL]                         compiler.report(t.makeError(n, UNKNOWN_SYMBOL_WARNING, parts[i], name)); [EOL]                         return; [EOL]                     } [EOL]                     replaced[i] = part; [EOL]                 } [EOL]                 replacement = Joiner.on("-").join(replaced); [EOL]                 break; [EOL]             default: [EOL]                 throw new IllegalStateException("Unknown replacement style: " + symbolMap.getStyle()); [EOL]         } [EOL]         n.setString(replacement); [EOL]     } [EOL]     if (cssNames != null) { [EOL]         for (int i = 0; i < parts.length; i++) { [EOL]             Integer count = cssNames.get(parts[i]); [EOL]             if (count == null) { [EOL]                 count = Integer.valueOf(0); [EOL]             } [EOL]             cssNames.put(parts[i], count.intValue() + 1); [EOL]         } [EOL]     } [EOL] } <line_num>: 209,260
