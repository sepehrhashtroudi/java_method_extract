AliasExternals(AbstractCompiler compiler, JSModuleGraph moduleGraph) { [EOL]     this(compiler, moduleGraph, null, null); [EOL] } <line_num>: 157,159
AliasExternals(AbstractCompiler compiler, JSModuleGraph moduleGraph, @Nullable String unaliasableGlobals, @Nullable String aliasableGlobals) { [EOL]     this.compiler = compiler; [EOL]     this.moduleGraph = moduleGraph; [EOL]     if (!Strings.isNullOrEmpty(unaliasableGlobals) && !Strings.isNullOrEmpty(aliasableGlobals)) { [EOL]         throw new IllegalArgumentException("Cannot pass in both unaliasable and aliasable globals; you must " + "choose one or the other."); [EOL]     } [EOL]     if (!Strings.isNullOrEmpty(unaliasableGlobals)) { [EOL]         this.unaliasableGlobals.addAll(Arrays.asList(unaliasableGlobals.split(","))); [EOL]     } [EOL]     if (!Strings.isNullOrEmpty(aliasableGlobals)) { [EOL]         this.aliasableGlobals.addAll(Arrays.asList(aliasableGlobals.split(","))); [EOL]     } [EOL]     if (moduleGraph != null) { [EOL]         moduleRoots = Maps.newHashMap(); [EOL]     } [EOL] } <line_num>: 173,198
public GetAliasableNames(final Set<String> whitelist) { [EOL]     this.whitelist = whitelist; [EOL] } <line_num>: 465,467
private Symbol(String name, boolean isConstant) { [EOL]     this.name = name; [EOL]     this.isConstant = isConstant; [EOL] } <line_num>: 756,759
public void setRequiredUsage(int usage) { [EOL]     this.requiredUsage = usage; [EOL] } <line_num>: 205,207
@Override [EOL] public void process(Node externs, Node root) { [EOL]     defaultRoot = root.getFirstChild(); [EOL]     Preconditions.checkState(defaultRoot.isScript()); [EOL]     aliasProperties(externs, root); [EOL]     aliasGlobals(externs, root); [EOL] } <line_num>: 212,219
private void aliasProperties(Node externs, Node root) { [EOL]     NodeTraversal.traverse(compiler, externs, new GetAliasableNames(aliasableGlobals)); [EOL]     props.put("prototype", newSymbolForProperty("prototype")); [EOL]     NodeTraversal.traverse(compiler, root, new PropertyGatherer()); [EOL]     for (Symbol prop : props.values()) { [EOL]         if (prop.name.length() >= MIN_PROP_SIZE) { [EOL]             if (prop.accessorCount >= requiredUsage) { [EOL]                 prop.aliasAccessor = true; [EOL]             } [EOL]             if (prop.mutatorCount >= requiredUsage) { [EOL]                 prop.aliasMutator = true; [EOL]             } [EOL]         } [EOL]     } [EOL]     for (Node propInfo : accessors) { [EOL]         replaceAccessor(propInfo); [EOL]     } [EOL]     for (Node propInfo : mutators) { [EOL]         replaceMutator(propInfo); [EOL]     } [EOL]     for (Symbol prop : props.values()) { [EOL]         if (prop.aliasAccessor) { [EOL]             addAccessorPropName(prop.name, getAddingRoot(prop.deepestModuleAccess)); [EOL]         } [EOL]     } [EOL]     for (Symbol prop : props.values()) { [EOL]         if (prop.aliasMutator) { [EOL]             addMutatorFunction(prop.name, getAddingRoot(prop.deepestModuleMutate)); [EOL]         } [EOL]     } [EOL] } <line_num>: 221,267
private void replaceAccessor(Node getPropNode) { [EOL]     Node propNameNode = getPropNode.getLastChild(); [EOL]     String propName = propNameNode.getString(); [EOL]     if (props.get(propName).aliasAccessor) { [EOL]         Node propSrc = getPropNode.getFirstChild(); [EOL]         getPropNode.removeChild(propSrc); [EOL]         Node newNameNode = IR.name(getArrayNotationNameFor(propName)); [EOL]         Node elemNode = IR.getelem(propSrc, newNameNode); [EOL]         replaceNode(getPropNode.getParent(), getPropNode, elemNode); [EOL]         compiler.reportCodeChange(); [EOL]     } [EOL] } <line_num>: 274,299
private void replaceMutator(Node getPropNode) { [EOL]     Node propNameNode = getPropNode.getLastChild(); [EOL]     Node parentNode = getPropNode.getParent(); [EOL]     Symbol prop = props.get(propNameNode.getString()); [EOL]     if (prop.aliasMutator) { [EOL]         Node propSrc = getPropNode.getFirstChild(); [EOL]         Node propDest = parentNode.getLastChild(); [EOL]         getPropNode.removeChild(propSrc); [EOL]         getPropNode.removeChild(propNameNode); [EOL]         parentNode.removeChild(propDest); [EOL]         Node callName = IR.name(getMutatorFor(propNameNode.getString())); [EOL]         Node call = IR.call(callName, propSrc, propDest); [EOL]         call.putBooleanProp(Node.FREE_CALL, true); [EOL]         replaceNode(parentNode.getParent(), parentNode, call); [EOL]         compiler.reportCodeChange(); [EOL]     } [EOL] } <line_num>: 304,346
private void replaceNode(Node parent, Node before, Node after) { [EOL]     if (replacementMap.containsKey(parent)) { [EOL]         parent = replacementMap.get(parent); [EOL]     } [EOL]     parent.replaceChild(before, after); [EOL]     replacementMap.put(before, after); [EOL] } <line_num>: 356,362
private void addAccessorPropName(String propName, Node root) { [EOL]     Node propValue = IR.string(propName); [EOL]     Node propNameNode = IR.name(getArrayNotationNameFor(propName)); [EOL]     propNameNode.addChildToFront(propValue); [EOL]     Node var = IR.var(propNameNode); [EOL]     root.addChildToFront(var); [EOL]     compiler.reportCodeChange(); [EOL] } <line_num>: 373,389
private void addMutatorFunction(String propName, Node root) { [EOL]     String functionName = getMutatorFor(propName); [EOL]     String localPropName = getMutatorFor(propName) + "$a"; [EOL]     String localValueName = getMutatorFor(propName) + "$b"; [EOL]     Node fnNode = IR.function(IR.name(functionName), IR.paramList(IR.name(localPropName), IR.name(localValueName)), IR.block(IR.returnNode(IR.assign(IR.getprop(IR.name(localPropName), IR.string(propName)), IR.name(localValueName))))); [EOL]     root.addChildToFront(fnNode); [EOL]     compiler.reportCodeChange(); [EOL] } <line_num>: 398,432
private Node getAddingRoot(JSModule m) { [EOL]     if (m != null) { [EOL]         Node root = moduleRoots.get(m); [EOL]         if (root != null) { [EOL]             return root; [EOL]         } [EOL]         root = compiler.getNodeForCodeInsertion(m); [EOL]         if (root != null) { [EOL]             moduleRoots.put(m, root); [EOL]             return root; [EOL]         } [EOL]     } [EOL]     return defaultRoot; [EOL] } <line_num>: 442,457
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     switch(n.getType()) { [EOL]         case Token.GETPROP: [EOL]         case Token.GETELEM: [EOL]             Node dest = n.getFirstChild().getNext(); [EOL]             if (dest.isString() && (whitelist.isEmpty() || whitelist.contains(dest.getString()))) { [EOL]                 props.put(dest.getString(), newSymbolForProperty(dest.getString())); [EOL]             } [EOL]     } [EOL] } <line_num>: 469,480
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (n.isGetProp()) { [EOL]         Node propNameNode = n.getLastChild(); [EOL]         if (canReplaceWithGetProp(propNameNode, n, parent)) { [EOL]             String name = propNameNode.getString(); [EOL]             props.get(name).recordAccessor(t); [EOL]             accessors.add(n); [EOL]         } [EOL]         if (canReplaceWithSetProp(propNameNode, n, parent)) { [EOL]             String name = propNameNode.getString(); [EOL]             props.get(name).recordMutator(t); [EOL]             mutators.add(n); [EOL]         } [EOL]     } [EOL] } <line_num>: 489,506
private boolean canReplaceWithGetProp(Node propNameNode, Node getPropNode, Node parent) { [EOL]     boolean isCallTarget = (parent.isCall()) && (parent.getFirstChild() == getPropNode); [EOL]     boolean isAssignTarget = NodeUtil.isAssignmentOp(parent) && (parent.getFirstChild() == getPropNode); [EOL]     boolean isIncOrDec = (parent.isInc()) || (parent.isDec()); [EOL]     return (propNameNode.isString()) && !isAssignTarget && (!isCallTarget || !"eval".equals(propNameNode.getString())) && !isIncOrDec && props.containsKey(propNameNode.getString()); [EOL] } <line_num>: 519,531
private boolean canReplaceWithSetProp(Node propNameNode, Node getPropNode, Node parent) { [EOL]     boolean isAssignTarget = (parent.isAssign()) && (parent.getFirstChild() == getPropNode); [EOL]     return (propNameNode.isString()) && isAssignTarget && props.containsKey(propNameNode.getString()); [EOL] } <line_num>: 542,548
private static String getMutatorFor(String prop) { [EOL]     return "SETPROP_" + prop; [EOL] } <line_num>: 554,556
private static String getArrayNotationNameFor(String prop) { [EOL]     return "$$PROP_" + prop; [EOL] } <line_num>: 561,563
private void aliasGlobals(Node externs, Node root) { [EOL]     NodeTraversal.traverse(compiler, externs, new GetGlobals()); [EOL]     NodeTraversal.traverse(compiler, root, new GlobalGatherer()); [EOL]     for (Symbol global : globals.values()) { [EOL]         if (global.mutatorCount > 0) { [EOL]             continue; [EOL]         } [EOL]         int currentBytes = global.name.length() * global.accessorCount; [EOL]         int aliasedBytes = 8 + global.name.length() + 2 * global.accessorCount; [EOL]         if (aliasedBytes < currentBytes) { [EOL]             global.aliasAccessor = true; [EOL]         } [EOL]     } [EOL]     for (Symbol global : globals.values()) { [EOL]         for (Node globalUse : global.uses) { [EOL]             replaceGlobalUse(globalUse); [EOL]         } [EOL]         if (global.aliasAccessor) { [EOL]             addGlobalAliasNode(global, getAddingRoot(global.deepestModuleAccess)); [EOL]         } [EOL]     } [EOL] } <line_num>: 565,598
private void getGlobalName(NodeTraversal t, Node dest, Node parent) { [EOL]     if (dest.isName()) { [EOL]         JSDocInfo docInfo = dest.getJSDocInfo() == null ? parent.getJSDocInfo() : dest.getJSDocInfo(); [EOL]         boolean aliasable = !unaliasableGlobals.contains(dest.getString()) && (docInfo == null || !docInfo.isNoAlias()); [EOL]         if (aliasable) { [EOL]             String name = dest.getString(); [EOL]             Scope.Var var = t.getScope().getVar(name); [EOL]             if (var != null && !var.isLocal()) { [EOL]                 globals.put(name, newSymbolForGlobalVar(dest)); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 604,621
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     switch(n.getType()) { [EOL]         case Token.FUNCTION: [EOL]             getGlobalName(t, n.getFirstChild(), n); [EOL]             break; [EOL]         case Token.VAR: [EOL]             for (Node varChild = n.getFirstChild(); varChild != null; varChild = varChild.getNext()) { [EOL]                 getGlobalName(t, varChild, n); [EOL]             } [EOL]             break; [EOL]     } [EOL] } <line_num>: 623,637
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (n.isName()) { [EOL]         String name = n.getString(); [EOL]         Scope.Var var = t.getScope().getVar(name); [EOL]         if (var != null && var.isLocal()) { [EOL]             return; [EOL]         } [EOL]         Symbol global = globals.get(name); [EOL]         if (global != null) { [EOL]             if (n.getParent().isVar() || n.getParent().isFunction()) { [EOL]                 globals.remove(name); [EOL]             } [EOL]             boolean isFirst = parent.getFirstChild() == n; [EOL]             if ((NodeUtil.isAssignmentOp(parent) && isFirst) || (parent.isNew() && isFirst) || parent.isInc() || parent.isDec()) { [EOL]                 global.recordMutator(t); [EOL]             } else { [EOL]                 global.recordAccessor(t); [EOL]             } [EOL]             global.uses.add(n); [EOL]         } [EOL]     } [EOL] } <line_num>: 645,684
private void replaceGlobalUse(Node globalUse) { [EOL]     String globalName = globalUse.getString(); [EOL]     if (globals.get(globalName).aliasAccessor) { [EOL]         globalUse.setString("GLOBAL_" + globalName); [EOL]         globalUse.putBooleanProp(Node.IS_CONSTANT_NAME, false); [EOL]         compiler.reportCodeChange(); [EOL]     } [EOL] } <line_num>: 690,702
private void addGlobalAliasNode(Symbol global, Node root) { [EOL]     String globalName = global.name; [EOL]     Node globalValue = IR.name(global.name); [EOL]     globalValue.putBooleanProp(Node.IS_CONSTANT_NAME, global.isConstant); [EOL]     Node globalNameNode = IR.name("GLOBAL_" + globalName); [EOL]     globalNameNode.addChildToFront(globalValue); [EOL]     Node var = IR.var(globalNameNode); [EOL]     root.addChildToFront(var); [EOL]     compiler.reportCodeChange(); [EOL] } <line_num>: 712,731
private Symbol newSymbolForGlobalVar(Node name) { [EOL]     return new Symbol(name.getString(), name.getBooleanProp(Node.IS_CONSTANT_NAME)); [EOL] } <line_num>: 733,736
private Symbol newSymbolForProperty(String name) { [EOL]     return new Symbol(name, false); [EOL] } <line_num>: 738,740
void recordAccessor(NodeTraversal t) { [EOL]     accessorCount++; [EOL]     if (moduleGraph != null) { [EOL]         deepestModuleAccess = (deepestModuleAccess == null) ? t.getModule() : moduleGraph.getDeepestCommonDependencyInclusive(t.getModule(), deepestModuleAccess); [EOL]     } [EOL] } <line_num>: 761,769
void recordMutator(NodeTraversal t) { [EOL]     mutatorCount++; [EOL]     if (moduleGraph != null) { [EOL]         deepestModuleMutate = (deepestModuleMutate == null) ? t.getModule() : moduleGraph.getDeepestCommonDependencyInclusive(t.getModule(), deepestModuleMutate); [EOL]     } [EOL] } <line_num>: 771,779
