CheckRequiresForConstructors(AbstractCompiler compiler, CheckLevel level) { [EOL]     this.compiler = compiler; [EOL]     this.codingConvention = compiler.getCodingConvention(); [EOL]     this.level = level; [EOL] } <line_num>: 48,53
@Override [EOL] public void process(Node externs, Node root) { [EOL]     Callback callback = new CheckRequiresForConstructorsCallback(); [EOL]     new NodeTraversal(compiler, callback).traverseRoots(externs, root); [EOL] } <line_num>: 59,63
@Override [EOL] public void hotSwapScript(Node scriptRoot, Node originalRoot) { [EOL]     Callback callback = new CheckRequiresForConstructorsCallback(); [EOL]     new NodeTraversal(compiler, callback).traverseWithScope(scriptRoot, SyntacticScopeCreator.generateUntypedTopScope(compiler)); [EOL] } <line_num>: 65,70
private static boolean isClassName(String name) { [EOL]     return (name != null && name.length() > 1 && Character.isUpperCase(name.charAt(0)) && !name.equals(name.toUpperCase())); [EOL] } <line_num>: 74,78
private static String getOutermostClassName(String className) { [EOL]     for (String part : className.split("\\.")) { [EOL]         if (isClassName(part)) { [EOL]             return className.substring(0, className.indexOf(part) + part.length()); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 82,91
@Override [EOL] public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { [EOL]     return parent == null || !parent.isScript() || !t.getInput().isExtern(); [EOL] } <line_num>: 103,107
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     JSDocInfo info; [EOL]     switch(n.getType()) { [EOL]         case Token.ASSIGN: [EOL]             info = (JSDocInfo) n.getProp(Node.JSDOC_INFO_PROP); [EOL]             if (info != null && info.isConstructor()) { [EOL]                 String qualifiedName = n.getFirstChild().getQualifiedName(); [EOL]                 constructors.add(qualifiedName); [EOL]             } [EOL]             break; [EOL]         case Token.FUNCTION: [EOL]             if (NodeUtil.isFunctionExpression(n)) { [EOL]                 if (parent.isName()) { [EOL]                     String functionName = parent.getString(); [EOL]                     info = (JSDocInfo) parent.getProp(Node.JSDOC_INFO_PROP); [EOL]                     if (info != null && info.isConstructor()) { [EOL]                         constructors.add(functionName); [EOL]                     } else { [EOL]                         Node gramps = parent.getParent(); [EOL]                         Preconditions.checkState(gramps != null && gramps.isVar()); [EOL]                         info = (JSDocInfo) gramps.getProp(Node.JSDOC_INFO_PROP); [EOL]                         if (info != null && info.isConstructor()) { [EOL]                             constructors.add(functionName); [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } else { [EOL]                 info = (JSDocInfo) n.getProp(Node.JSDOC_INFO_PROP); [EOL]                 if (info != null && info.isConstructor()) { [EOL]                     String functionName = n.getFirstChild().getString(); [EOL]                     constructors.add(functionName); [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Token.CALL: [EOL]             visitCallNode(n, parent); [EOL]             break; [EOL]         case Token.SCRIPT: [EOL]             visitScriptNode(t); [EOL]             break; [EOL]         case Token.NEW: [EOL]             visitNewNode(t, n); [EOL]     } [EOL] } <line_num>: 109,154
private void visitScriptNode(NodeTraversal t) { [EOL]     Set<String> classNames = Sets.newHashSet(); [EOL]     for (Node node : newNodes) { [EOL]         String className = node.getFirstChild().getQualifiedName(); [EOL]         String outermostClassName = getOutermostClassName(className); [EOL]         boolean notProvidedByConstructors = (constructors == null || !constructors.contains(className)); [EOL]         boolean notProvidedByRequires = (requires == null || (!requires.contains(className) && !requires.contains(outermostClassName))); [EOL]         if (notProvidedByConstructors && notProvidedByRequires && !classNames.contains(className)) { [EOL]             compiler.report(t.makeError(node, level, MISSING_REQUIRE_WARNING, className)); [EOL]             classNames.add(className); [EOL]         } [EOL]     } [EOL]     this.newNodes.clear(); [EOL]     this.requires.clear(); [EOL]     this.constructors.clear(); [EOL] } <line_num>: 156,178
private void visitCallNode(Node n, Node parent) { [EOL]     String required = codingConvention.extractClassNameIfRequire(n, parent); [EOL]     if (required != null) { [EOL]         requires.add(required); [EOL]     } [EOL] } <line_num>: 180,185
private void visitNewNode(NodeTraversal t, Node n) { [EOL]     Node qNameNode = n.getFirstChild(); [EOL]     if (!qNameNode.isQualifiedName()) { [EOL]         return; [EOL]     } [EOL]     Node nameNode = qNameNode; [EOL]     for (; nameNode.hasChildren(); nameNode = nameNode.getFirstChild()) { [EOL]     } [EOL]     if (!nameNode.isName()) { [EOL]         return; [EOL]     } [EOL]     String name = nameNode.getString(); [EOL]     Scope.Var var = t.getScope().getVar(name); [EOL]     if (var == null || var.isLocal() || var.isExtern()) { [EOL]         return; [EOL]     } [EOL]     newNodes.add(n); [EOL] } <line_num>: 187,211
