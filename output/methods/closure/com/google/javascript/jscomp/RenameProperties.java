RenameProperties(AbstractCompiler compiler, boolean affinity, boolean generatePseudoNames) { [EOL]     this(compiler, affinity, generatePseudoNames, null, null); [EOL] } <line_num>: 158,161
RenameProperties(AbstractCompiler compiler, boolean affinity, boolean generatePseudoNames, VariableMap prevUsedPropertyMap) { [EOL]     this(compiler, affinity, generatePseudoNames, prevUsedPropertyMap, null); [EOL] } <line_num>: 173,176
RenameProperties(AbstractCompiler compiler, boolean affinity, boolean generatePseudoNames, VariableMap prevUsedPropertyMap, @Nullable char[] reservedCharacters) { [EOL]     this.compiler = compiler; [EOL]     this.generatePseudoNames = generatePseudoNames; [EOL]     this.prevUsedPropertyMap = prevUsedPropertyMap; [EOL]     this.reservedCharacters = reservedCharacters; [EOL]     if (affinity) { [EOL]         this.affinityGraph = LinkedUndirectedGraph.createWithoutAnnotations(); [EOL]     } else { [EOL]         this.affinityGraph = null; [EOL]     } [EOL] } <line_num>: 190,204
Property(String name) { [EOL]     this.oldName = name; [EOL] } <line_num>: 575,577
private PropertyAffinity(int affinity) { [EOL]     this.affinity = affinity; [EOL] } <line_num>: 584,586
@Override [EOL] public int compare(Property p1, Property p2) { [EOL]     if (p1.numOccurrences != p2.numOccurrences) { [EOL]         return p2.numOccurrences - p1.numOccurrences; [EOL]     } else if (p1.affinityScore != p2.affinityScore) { [EOL]         return p2.affinityScore - p1.affinityScore; [EOL]     } [EOL]     return p1.oldName.compareTo(p2.oldName); [EOL] } <line_num>: 103,126
@Override [EOL] public void process(Node externs, Node root) { [EOL]     Preconditions.checkState(compiler.getLifeCycleStage().isNormalized()); [EOL]     NodeTraversal.traverse(compiler, externs, new ProcessExterns()); [EOL]     NodeTraversal.traverse(compiler, root, new ProcessProperties()); [EOL]     Set<String> reservedNames = new HashSet<String>(externedNames.size() + quotedNames.size()); [EOL]     reservedNames.addAll(externedNames); [EOL]     reservedNames.addAll(quotedNames); [EOL]     if (prevUsedPropertyMap != null) { [EOL]         reusePropertyNames(reservedNames, propertyMap.values()); [EOL]     } [EOL]     compiler.addToDebugLog("JS property assignments:"); [EOL]     if (affinityGraph != null) { [EOL]         computeAffinityScores(); [EOL]     } [EOL]     Set<Property> propsByFreq = new TreeSet<Property>(FREQUENCY_COMPARATOR); [EOL]     propsByFreq.addAll(propertyMap.values()); [EOL]     generateNames(propsByFreq, reservedNames); [EOL]     boolean changed = false; [EOL]     for (Node n : stringNodesToRename) { [EOL]         String oldName = n.getString(); [EOL]         Property p = propertyMap.get(oldName); [EOL]         if (p != null && p.newName != null) { [EOL]             Preconditions.checkState(oldName.equals(p.oldName)); [EOL]             n.setString(p.newName); [EOL]             changed = changed || !p.newName.equals(oldName); [EOL]         } [EOL]     } [EOL]     for (Map.Entry<Node, Node> nodeEntry : callNodeToParentMap.entrySet()) { [EOL]         Node parent = nodeEntry.getValue(); [EOL]         Node firstArg = nodeEntry.getKey().getFirstChild().getNext(); [EOL]         StringBuilder sb = new StringBuilder(); [EOL]         for (String oldName : firstArg.getString().split("[.]")) { [EOL]             Property p = propertyMap.get(oldName); [EOL]             String replacement; [EOL]             if (p != null && p.newName != null) { [EOL]                 Preconditions.checkState(oldName.equals(p.oldName)); [EOL]                 replacement = p.newName; [EOL]             } else { [EOL]                 replacement = oldName; [EOL]             } [EOL]             if (sb.length() > 0) { [EOL]                 sb.append('.'); [EOL]             } [EOL]             sb.append(replacement); [EOL]         } [EOL]         parent.replaceChild(nodeEntry.getKey(), IR.string(sb.toString())); [EOL]         changed = true; [EOL]     } [EOL]     if (changed) { [EOL]         compiler.reportCodeChange(); [EOL]     } [EOL]     compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED_OBFUSCATED); [EOL] } <line_num>: 206,274
private void reusePropertyNames(Set<String> reservedNames, Collection<Property> allProps) { [EOL]     for (Property prop : allProps) { [EOL]         String prevName = prevUsedPropertyMap.lookupNewName(prop.oldName); [EOL]         if (!generatePseudoNames && prevName != null) { [EOL]             if (reservedNames.contains(prevName)) { [EOL]                 continue; [EOL]             } [EOL]             prop.newName = prevName; [EOL]             reservedNames.add(prevName); [EOL]         } [EOL]     } [EOL] } <line_num>: 283,299
private void computeAffinityScores() { [EOL]     for (Property p : propertyMap.values()) { [EOL]         UndiGraphNode<Property, PropertyAffinity> node = affinityGraph.getUndirectedGraphNode(p); [EOL]         int affinityScore = 0; [EOL]         for (Iterator<UndiGraphEdge<Property, PropertyAffinity>> edgeIterator = node.getNeighborEdgesIterator(); edgeIterator.hasNext(); ) { [EOL]             UndiGraphEdge<Property, PropertyAffinity> edge = edgeIterator.next(); [EOL]             affinityScore += edge.getValue().affinity + (node == edge.getNodeA() ? edge.getNodeB().getValue().numOccurrences : edge.getNodeA().getValue().numOccurrences); [EOL]         } [EOL]         node.getValue().affinityScore = affinityScore; [EOL]     } [EOL] } <line_num>: 311,327
private void generateNames(Set<Property> props, Set<String> reservedNames) { [EOL]     NameGenerator nameGen = new NameGenerator(reservedNames, "", reservedCharacters); [EOL]     for (Property p : props) { [EOL]         if (generatePseudoNames) { [EOL]             p.newName = "$" + p.oldName + "$"; [EOL]         } else { [EOL]             if (p.newName == null) { [EOL]                 p.newName = nameGen.generateNextName(); [EOL]             } [EOL]         } [EOL]         reservedNames.add(p.newName); [EOL]         compiler.addToDebugLog(p.oldName + " => " + p.newName); [EOL]     } [EOL] } <line_num>: 336,351
VariableMap getPropertyMap() { [EOL]     ImmutableMap.Builder<String, String> map = ImmutableMap.builder(); [EOL]     for (Property p : propertyMap.values()) { [EOL]         if (p.newName != null) { [EOL]             map.put(p.oldName, p.newName); [EOL]         } [EOL]     } [EOL]     return new VariableMap(map.build()); [EOL] } <line_num>: 358,366
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     switch(n.getType()) { [EOL]         case Token.GETPROP: [EOL]             Node dest = n.getFirstChild().getNext(); [EOL]             if (dest.isString()) { [EOL]                 externedNames.add(dest.getString()); [EOL]             } [EOL]             break; [EOL]         case Token.OBJECTLIT: [EOL]             for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { [EOL]                 externedNames.add(child.getString()); [EOL]             } [EOL]             break; [EOL]     } [EOL] } <line_num>: 375,392
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     switch(n.getType()) { [EOL]         case Token.GETPROP: [EOL]             Node propNode = n.getFirstChild().getNext(); [EOL]             if (propNode.isString()) { [EOL]                 maybeMarkCandidate(propNode); [EOL]             } [EOL]             break; [EOL]         case Token.OBJECTLIT: [EOL]             for (Node key = n.getFirstChild(); key != null; key = key.getNext()) { [EOL]                 if (!key.isQuotedString()) { [EOL]                     maybeMarkCandidate(key); [EOL]                 } else { [EOL]                     quotedNames.add(key.getString()); [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Token.GETELEM: [EOL]             Node child = n.getLastChild(); [EOL]             if (child != null && child.isString()) { [EOL]                 quotedNames.add(child.getString()); [EOL]             } [EOL]             break; [EOL]         case Token.CALL: [EOL]             Node fnName = n.getFirstChild(); [EOL]             if (fnName.isName() && RENAME_PROPERTY_FUNCTION_NAME.equals(fnName.getString())) { [EOL]                 callNodeToParentMap.put(n, parent); [EOL]                 countCallCandidates(t, n); [EOL]             } [EOL]             break; [EOL]         case Token.FUNCTION: [EOL]             if (NodeUtil.isFunctionDeclaration(n)) { [EOL]                 String name = n.getFirstChild().getString(); [EOL]                 if (RENAME_PROPERTY_FUNCTION_NAME.equals(name)) { [EOL]                     if (parent.isExprResult()) { [EOL]                         parent.detachFromParent(); [EOL]                     } else { [EOL]                         parent.removeChild(n); [EOL]                     } [EOL]                     compiler.reportCodeChange(); [EOL]                 } [EOL]             } else if (parent.isName() && RENAME_PROPERTY_FUNCTION_NAME.equals(parent.getString())) { [EOL]                 Node varNode = parent.getParent(); [EOL]                 if (varNode.isVar()) { [EOL]                     varNode.removeChild(parent); [EOL]                     if (!varNode.hasChildren()) { [EOL]                         varNode.detachFromParent(); [EOL]                     } [EOL]                     compiler.reportCodeChange(); [EOL]                 } [EOL]             } [EOL]             break; [EOL]     } [EOL] } <line_num>: 407,472
private void maybeMarkCandidate(Node n) { [EOL]     String name = n.getString(); [EOL]     if (!externedNames.contains(name)) { [EOL]         stringNodesToRename.add(n); [EOL]         countPropertyOccurrence(name); [EOL]     } [EOL] } <line_num>: 480,486
private void countCallCandidates(NodeTraversal t, Node callNode) { [EOL]     Node firstArg = callNode.getFirstChild().getNext(); [EOL]     if (!firstArg.isString()) { [EOL]         t.report(callNode, BAD_CALL); [EOL]         return; [EOL]     } [EOL]     for (String name : firstArg.getString().split("[.]")) { [EOL]         if (!TokenStream.isJSIdentifier(name)) { [EOL]             t.report(callNode, BAD_ARG, name); [EOL]             continue; [EOL]         } [EOL]         if (!externedNames.contains(name)) { [EOL]             countPropertyOccurrence(name); [EOL]         } [EOL]     } [EOL] } <line_num>: 495,511
private void countPropertyOccurrence(String name) { [EOL]     Property prop = propertyMap.get(name); [EOL]     if (prop == null) { [EOL]         prop = new Property(name); [EOL]         propertyMap.put(name, prop); [EOL]         if (affinityGraph != null) { [EOL]             affinityGraph.createNode(prop); [EOL]         } [EOL]     } [EOL]     prop.numOccurrences++; [EOL]     if (currentHighAffinityProperties != null) { [EOL]         currentHighAffinityProperties.add(prop); [EOL]     } [EOL] } <line_num>: 518,531
@Override [EOL] public void enterScope(NodeTraversal t) { [EOL]     if (!t.inGlobalScope() && t.getScope().getParent().isGlobal()) { [EOL]         currentHighAffinityProperties = Sets.newHashSet(); [EOL]     } [EOL] } <line_num>: 533,538
@Override [EOL] public void exitScope(NodeTraversal t) { [EOL]     if (affinityGraph == null) { [EOL]         return; [EOL]     } [EOL]     if (!t.inGlobalScope() && t.getScope().getParent().isGlobal()) { [EOL]         for (Property p1 : currentHighAffinityProperties) { [EOL]             for (Property p2 : currentHighAffinityProperties) { [EOL]                 if (p1.oldName.compareTo(p2.oldName) < 0) { [EOL]                     GraphEdge<Property, PropertyAffinity> edge = affinityGraph.getFirstEdge(p1, p2); [EOL]                     if (edge == null) { [EOL]                         affinityGraph.connect(p1, new PropertyAffinity(1), p2); [EOL]                     } else { [EOL]                         edge.getValue().increase(); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         currentHighAffinityProperties = null; [EOL]     } [EOL] } <line_num>: 540,561
private void increase() { [EOL]     affinity++; [EOL] } <line_num>: 588,590
