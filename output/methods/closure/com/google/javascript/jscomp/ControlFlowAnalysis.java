ControlFlowAnalysis(AbstractCompiler compiler, boolean shouldTraverseFunctions, boolean edgeAnnotations) { [EOL]     this.compiler = compiler; [EOL]     this.shouldTraverseFunctions = shouldTraverseFunctions; [EOL]     this.edgeAnnotations = edgeAnnotations; [EOL] } <line_num>: 137,142
private AstControlFlowGraph(Node entry, Map<DiGraphNode<Node, Branch>, Integer> priorities, boolean edgeAnnotations) { [EOL]     super(entry, true, edgeAnnotations); [EOL]     this.priorities = priorities; [EOL] } <line_num>: 1013,1019
@Override [EOL] public int compare(DiGraphNode<Node, Branch> a, DiGraphNode<Node, Branch> b) { [EOL]     return astPosition.get(a.getValue()) - astPosition.get(b.getValue()); [EOL] } <line_num>: 72,76
ControlFlowGraph<Node> getCfg() { [EOL]     return cfg; [EOL] } <line_num>: 144,146
@Override [EOL] public void process(Node externs, Node root) { [EOL]     this.root = root; [EOL]     astPositionCounter = 0; [EOL]     astPosition = Maps.newHashMap(); [EOL]     nodePriorities = Maps.newHashMap(); [EOL]     cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities, edgeAnnotations); [EOL]     NodeTraversal.traverse(compiler, root, this); [EOL]     astPosition.put(null, ++astPositionCounter); [EOL]     priorityCounter = 0; [EOL]     DiGraphNode<Node, Branch> entry = cfg.getEntry(); [EOL]     prioritizeFromEntryNode(entry); [EOL]     if (shouldTraverseFunctions) { [EOL]         for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) { [EOL]             Node value = candidate.getValue(); [EOL]             if (value != null && value.isFunction()) { [EOL]                 Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry); [EOL]                 prioritizeFromEntryNode(candidate); [EOL]             } [EOL]         } [EOL]     } [EOL]     for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) { [EOL]         if (!nodePriorities.containsKey(candidate)) { [EOL]             nodePriorities.put(candidate, ++priorityCounter); [EOL]         } [EOL]     } [EOL]     nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter); [EOL] } <line_num>: 148,190
private void prioritizeFromEntryNode(DiGraphNode<Node, Branch> entry) { [EOL]     PriorityQueue<DiGraphNode<Node, Branch>> worklist = new PriorityQueue<DiGraphNode<Node, Branch>>(10, priorityComparator); [EOL]     worklist.add(entry); [EOL]     while (!worklist.isEmpty()) { [EOL]         DiGraphNode<Node, Branch> current = worklist.remove(); [EOL]         if (nodePriorities.containsKey(current)) { [EOL]             continue; [EOL]         } [EOL]         nodePriorities.put(current, ++priorityCounter); [EOL]         List<DiGraphNode<Node, Branch>> successors = cfg.getDirectedSuccNodes(current); [EOL]         for (DiGraphNode<Node, Branch> candidate : successors) { [EOL]             worklist.add(candidate); [EOL]         } [EOL]     } [EOL] } <line_num>: 196,215
@Override [EOL] public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) { [EOL]     astPosition.put(n, astPositionCounter++); [EOL]     switch(n.getType()) { [EOL]         case Token.FUNCTION: [EOL]             if (shouldTraverseFunctions || n == cfg.getEntry().getValue()) { [EOL]                 exceptionHandler.push(n); [EOL]                 return true; [EOL]             } [EOL]             return false; [EOL]         case Token.TRY: [EOL]             exceptionHandler.push(n); [EOL]             return true; [EOL]     } [EOL]     if (parent != null) { [EOL]         switch(parent.getType()) { [EOL]             case Token.FOR: [EOL]                 return n == parent.getLastChild(); [EOL]             case Token.IF: [EOL]             case Token.WHILE: [EOL]             case Token.WITH: [EOL]                 return n != parent.getFirstChild(); [EOL]             case Token.DO: [EOL]                 return n != parent.getFirstChild().getNext(); [EOL]             case Token.SWITCH: [EOL]             case Token.CASE: [EOL]             case Token.CATCH: [EOL]             case Token.LABEL: [EOL]                 return n != parent.getFirstChild(); [EOL]             case Token.FUNCTION: [EOL]                 return n == parent.getFirstChild().getNext().getNext(); [EOL]             case Token.CONTINUE: [EOL]             case Token.BREAK: [EOL]             case Token.EXPR_RESULT: [EOL]             case Token.VAR: [EOL]             case Token.RETURN: [EOL]             case Token.THROW: [EOL]                 return false; [EOL]             case Token.TRY: [EOL]                 if (n == parent.getFirstChild().getNext()) { [EOL]                     Preconditions.checkState(exceptionHandler.peek() == parent); [EOL]                     exceptionHandler.pop(); [EOL]                 } [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 217,292
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     switch(n.getType()) { [EOL]         case Token.IF: [EOL]             handleIf(n); [EOL]             return; [EOL]         case Token.WHILE: [EOL]             handleWhile(n); [EOL]             return; [EOL]         case Token.DO: [EOL]             handleDo(n); [EOL]             return; [EOL]         case Token.FOR: [EOL]             handleFor(n); [EOL]             return; [EOL]         case Token.SWITCH: [EOL]             handleSwitch(n); [EOL]             return; [EOL]         case Token.CASE: [EOL]             handleCase(n); [EOL]             return; [EOL]         case Token.DEFAULT_CASE: [EOL]             handleDefault(n); [EOL]             return; [EOL]         case Token.BLOCK: [EOL]         case Token.SCRIPT: [EOL]             handleStmtList(n); [EOL]             return; [EOL]         case Token.FUNCTION: [EOL]             handleFunction(n); [EOL]             return; [EOL]         case Token.EXPR_RESULT: [EOL]             handleExpr(n); [EOL]             return; [EOL]         case Token.THROW: [EOL]             handleThrow(n); [EOL]             return; [EOL]         case Token.TRY: [EOL]             handleTry(n); [EOL]             return; [EOL]         case Token.CATCH: [EOL]             handleCatch(n); [EOL]             return; [EOL]         case Token.BREAK: [EOL]             handleBreak(n); [EOL]             return; [EOL]         case Token.CONTINUE: [EOL]             handleContinue(n); [EOL]             return; [EOL]         case Token.RETURN: [EOL]             handleReturn(n); [EOL]             return; [EOL]         case Token.WITH: [EOL]             handleWith(n); [EOL]             return; [EOL]         case Token.LABEL: [EOL]             return; [EOL]         default: [EOL]             handleStmt(n); [EOL]             return; [EOL]     } [EOL] } <line_num>: 294,355
private void handleIf(Node node) { [EOL]     Node thenBlock = node.getFirstChild().getNext(); [EOL]     Node elseBlock = thenBlock.getNext(); [EOL]     createEdge(node, Branch.ON_TRUE, computeFallThrough(thenBlock)); [EOL]     if (elseBlock == null) { [EOL]         createEdge(node, Branch.ON_FALSE, computeFollowNode(node, this)); [EOL]     } else { [EOL]         createEdge(node, Branch.ON_FALSE, computeFallThrough(elseBlock)); [EOL]     } [EOL]     connectToPossibleExceptionHandler(node, NodeUtil.getConditionExpression(node)); [EOL] } <line_num>: 357,370
private void handleWhile(Node node) { [EOL]     createEdge(node, Branch.ON_TRUE, computeFallThrough(node.getFirstChild().getNext())); [EOL]     createEdge(node, Branch.ON_FALSE, computeFollowNode(node, this)); [EOL]     connectToPossibleExceptionHandler(node, NodeUtil.getConditionExpression(node)); [EOL] } <line_num>: 372,382
private void handleDo(Node node) { [EOL]     createEdge(node, Branch.ON_TRUE, computeFallThrough(node.getFirstChild())); [EOL]     createEdge(node, Branch.ON_FALSE, computeFollowNode(node, this)); [EOL]     connectToPossibleExceptionHandler(node, NodeUtil.getConditionExpression(node)); [EOL] } <line_num>: 384,393
private void handleFor(Node forNode) { [EOL]     if (forNode.getChildCount() == 4) { [EOL]         Node init = forNode.getFirstChild(); [EOL]         Node cond = init.getNext(); [EOL]         Node iter = cond.getNext(); [EOL]         Node body = iter.getNext(); [EOL]         createEdge(init, Branch.UNCOND, forNode); [EOL]         createEdge(forNode, Branch.ON_TRUE, computeFallThrough(body)); [EOL]         createEdge(forNode, Branch.ON_FALSE, computeFollowNode(forNode, this)); [EOL]         createEdge(iter, Branch.UNCOND, forNode); [EOL]         connectToPossibleExceptionHandler(init, init); [EOL]         connectToPossibleExceptionHandler(forNode, cond); [EOL]         connectToPossibleExceptionHandler(iter, iter); [EOL]     } else { [EOL]         Node item = forNode.getFirstChild(); [EOL]         Node collection = item.getNext(); [EOL]         Node body = collection.getNext(); [EOL]         createEdge(collection, Branch.UNCOND, forNode); [EOL]         createEdge(forNode, Branch.ON_TRUE, computeFallThrough(body)); [EOL]         createEdge(forNode, Branch.ON_FALSE, computeFollowNode(forNode, this)); [EOL]         connectToPossibleExceptionHandler(forNode, collection); [EOL]     } [EOL] } <line_num>: 395,432
private void handleSwitch(Node node) { [EOL]     Node next = getNextSiblingOfType(node.getFirstChild().getNext(), Token.CASE, Token.EMPTY); [EOL]     if (next != null) { [EOL]         createEdge(node, Branch.UNCOND, next); [EOL]     } else { [EOL]         if (node.getFirstChild().getNext() != null) { [EOL]             createEdge(node, Branch.UNCOND, node.getFirstChild().getNext()); [EOL]         } else { [EOL]             createEdge(node, Branch.UNCOND, computeFollowNode(node, this)); [EOL]         } [EOL]     } [EOL]     connectToPossibleExceptionHandler(node, node.getFirstChild()); [EOL] } <line_num>: 434,449
private void handleCase(Node node) { [EOL]     createEdge(node, Branch.ON_TRUE, node.getFirstChild().getNext()); [EOL]     Node next = getNextSiblingOfType(node.getNext(), Token.CASE); [EOL]     if (next != null) { [EOL]         Preconditions.checkState(next.isCase()); [EOL]         createEdge(node, Branch.ON_FALSE, next); [EOL]     } else { [EOL]         Node parent = node.getParent(); [EOL]         Node deflt = getNextSiblingOfType(parent.getFirstChild().getNext(), Token.DEFAULT_CASE); [EOL]         if (deflt != null) { [EOL]             createEdge(node, Branch.ON_FALSE, deflt); [EOL]         } else { [EOL]             createEdge(node, Branch.ON_FALSE, computeFollowNode(node, this)); [EOL]         } [EOL]     } [EOL]     connectToPossibleExceptionHandler(node, node.getFirstChild()); [EOL] } <line_num>: 451,471
private void handleDefault(Node node) { [EOL]     createEdge(node, Branch.UNCOND, node.getFirstChild()); [EOL] } <line_num>: 473,476
private void handleWith(Node node) { [EOL]     createEdge(node, Branch.UNCOND, node.getLastChild()); [EOL]     connectToPossibleExceptionHandler(node, node.getFirstChild()); [EOL] } <line_num>: 478,482
private void handleStmtList(Node node) { [EOL]     Node parent = node.getParent(); [EOL]     if (node.isBlock() && parent != null && parent.isTry() && NodeUtil.getCatchBlock(parent) == node && !NodeUtil.hasCatchHandler(node)) { [EOL]         return; [EOL]     } [EOL]     Node child = node.getFirstChild(); [EOL]     while (child != null && child.isFunction()) { [EOL]         child = child.getNext(); [EOL]     } [EOL]     if (child != null) { [EOL]         createEdge(node, Branch.UNCOND, computeFallThrough(child)); [EOL]     } else { [EOL]         createEdge(node, Branch.UNCOND, computeFollowNode(node, this)); [EOL]     } [EOL]     if (parent != null) { [EOL]         switch(parent.getType()) { [EOL]             case Token.DEFAULT_CASE: [EOL]             case Token.CASE: [EOL]             case Token.TRY: [EOL]                 break; [EOL]             default: [EOL]                 if (node.isBlock() && node.isSyntheticBlock()) { [EOL]                     createEdge(node, Branch.SYN_BLOCK, computeFollowNode(node, this)); [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL] } <line_num>: 484,523
private void handleFunction(Node node) { [EOL]     Preconditions.checkState(node.getChildCount() >= 3); [EOL]     createEdge(node, Branch.UNCOND, computeFallThrough(node.getFirstChild().getNext().getNext())); [EOL]     Preconditions.checkState(exceptionHandler.peek() == node); [EOL]     exceptionHandler.pop(); [EOL] } <line_num>: 525,532
private void handleExpr(Node node) { [EOL]     createEdge(node, Branch.UNCOND, computeFollowNode(node, this)); [EOL]     connectToPossibleExceptionHandler(node, node); [EOL] } <line_num>: 534,537
private void handleThrow(Node node) { [EOL]     connectToPossibleExceptionHandler(node, node); [EOL] } <line_num>: 539,541
private void handleTry(Node node) { [EOL]     createEdge(node, Branch.UNCOND, node.getFirstChild()); [EOL] } <line_num>: 543,545
private void handleCatch(Node node) { [EOL]     createEdge(node, Branch.UNCOND, node.getLastChild()); [EOL] } <line_num>: 547,549
private void handleBreak(Node node) { [EOL]     String label = null; [EOL]     if (node.hasChildren()) { [EOL]         label = node.getFirstChild().getString(); [EOL]     } [EOL]     Node cur; [EOL]     Node previous = null; [EOL]     Node lastJump; [EOL]     Node parent = node.getParent(); [EOL]     for (cur = node, lastJump = node; !isBreakTarget(cur, label); cur = parent, parent = parent.getParent()) { [EOL]         if (cur.isTry() && NodeUtil.hasFinally(cur) && cur.getLastChild() != previous) { [EOL]             if (lastJump == node) { [EOL]                 createEdge(lastJump, Branch.UNCOND, computeFallThrough(cur.getLastChild())); [EOL]             } else { [EOL]                 finallyMap.put(lastJump, computeFallThrough(cur.getLastChild())); [EOL]             } [EOL]             lastJump = cur; [EOL]         } [EOL]         if (parent == null) { [EOL]             if (compiler.isIdeMode()) { [EOL]                 return; [EOL]             } else { [EOL]                 throw new IllegalStateException("Cannot find break target."); [EOL]             } [EOL]         } [EOL]         previous = cur; [EOL]     } [EOL]     if (lastJump == node) { [EOL]         createEdge(lastJump, Branch.UNCOND, computeFollowNode(cur, this)); [EOL]     } else { [EOL]         finallyMap.put(lastJump, computeFollowNode(cur, this)); [EOL]     } [EOL] } <line_num>: 551,599
private void handleContinue(Node node) { [EOL]     String label = null; [EOL]     if (node.hasChildren()) { [EOL]         label = node.getFirstChild().getString(); [EOL]     } [EOL]     Node cur; [EOL]     Node previous = null; [EOL]     Node lastJump; [EOL]     Node parent = node.getParent(); [EOL]     for (cur = node, lastJump = node; !isContinueTarget(cur, parent, label); cur = parent, parent = parent.getParent()) { [EOL]         if (cur.isTry() && NodeUtil.hasFinally(cur) && cur.getLastChild() != previous) { [EOL]             if (lastJump == node) { [EOL]                 createEdge(lastJump, Branch.UNCOND, cur.getLastChild()); [EOL]             } else { [EOL]                 finallyMap.put(lastJump, computeFallThrough(cur.getLastChild())); [EOL]             } [EOL]             lastJump = cur; [EOL]         } [EOL]         Preconditions.checkState(parent != null, "Cannot find continue target."); [EOL]         previous = cur; [EOL]     } [EOL]     Node iter = cur; [EOL]     if (cur.getChildCount() == 4) { [EOL]         iter = cur.getFirstChild().getNext().getNext(); [EOL]     } [EOL]     if (lastJump == node) { [EOL]         createEdge(node, Branch.UNCOND, iter); [EOL]     } else { [EOL]         finallyMap.put(lastJump, iter); [EOL]     } [EOL] } <line_num>: 601,637
private void handleReturn(Node node) { [EOL]     Node lastJump = null; [EOL]     for (Iterator<Node> iter = exceptionHandler.iterator(); iter.hasNext(); ) { [EOL]         Node curHandler = iter.next(); [EOL]         if (curHandler.isFunction()) { [EOL]             break; [EOL]         } [EOL]         if (NodeUtil.hasFinally(curHandler)) { [EOL]             if (lastJump == null) { [EOL]                 createEdge(node, Branch.UNCOND, curHandler.getLastChild()); [EOL]             } else { [EOL]                 finallyMap.put(lastJump, computeFallThrough(curHandler.getLastChild())); [EOL]             } [EOL]             lastJump = curHandler; [EOL]         } [EOL]     } [EOL]     if (node.hasChildren()) { [EOL]         connectToPossibleExceptionHandler(node, node.getFirstChild()); [EOL]     } [EOL]     if (lastJump == null) { [EOL]         createEdge(node, Branch.UNCOND, null); [EOL]     } else { [EOL]         finallyMap.put(lastJump, null); [EOL]     } [EOL] } <line_num>: 639,666
private void handleStmt(Node node) { [EOL]     createEdge(node, Branch.UNCOND, computeFollowNode(node, this)); [EOL]     connectToPossibleExceptionHandler(node, node); [EOL] } <line_num>: 668,672
static Node computeFollowNode(Node node, ControlFlowAnalysis cfa) { [EOL]     return computeFollowNode(node, node, cfa); [EOL] } <line_num>: 674,676
static Node computeFollowNode(Node node) { [EOL]     return computeFollowNode(node, node, null); [EOL] } <line_num>: 678,680
private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) { [EOL]     Node parent = node.getParent(); [EOL]     if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) { [EOL]         return null; [EOL]     } [EOL]     switch(parent.getType()) { [EOL]         case Token.IF: [EOL]             return computeFollowNode(fromNode, parent, cfa); [EOL]         case Token.CASE: [EOL]         case Token.DEFAULT_CASE: [EOL]             if (parent.getNext() != null) { [EOL]                 if (parent.getNext().isCase()) { [EOL]                     return parent.getNext().getFirstChild().getNext(); [EOL]                 } else if (parent.getNext().isDefaultCase()) { [EOL]                     return parent.getNext().getFirstChild(); [EOL]                 } else { [EOL]                     Preconditions.checkState(false, "Not reachable"); [EOL]                 } [EOL]             } else { [EOL]                 return computeFollowNode(fromNode, parent, cfa); [EOL]             } [EOL]             break; [EOL]         case Token.FOR: [EOL]             if (NodeUtil.isForIn(parent)) { [EOL]                 return parent; [EOL]             } else { [EOL]                 return parent.getFirstChild().getNext().getNext(); [EOL]             } [EOL]         case Token.WHILE: [EOL]         case Token.DO: [EOL]             return parent; [EOL]         case Token.TRY: [EOL]             if (parent.getFirstChild() == node) { [EOL]                 if (NodeUtil.hasFinally(parent)) { [EOL]                     return computeFallThrough(parent.getLastChild()); [EOL]                 } else { [EOL]                     return computeFollowNode(fromNode, parent, cfa); [EOL]                 } [EOL]             } else if (NodeUtil.getCatchBlock(parent) == node) { [EOL]                 if (NodeUtil.hasFinally(parent)) { [EOL]                     return computeFallThrough(node.getNext()); [EOL]                 } else { [EOL]                     return computeFollowNode(fromNode, parent, cfa); [EOL]                 } [EOL]             } else if (parent.getLastChild() == node) { [EOL]                 if (cfa != null) { [EOL]                     for (Node finallyNode : cfa.finallyMap.get(parent)) { [EOL]                         cfa.createEdge(fromNode, Branch.ON_EX, finallyNode); [EOL]                     } [EOL]                 } [EOL]                 return computeFollowNode(fromNode, parent, cfa); [EOL]             } [EOL]     } [EOL]     Node nextSibling = node.getNext(); [EOL]     while (nextSibling != null && nextSibling.isFunction()) { [EOL]         nextSibling = nextSibling.getNext(); [EOL]     } [EOL]     if (nextSibling != null) { [EOL]         return computeFallThrough(nextSibling); [EOL]     } else { [EOL]         return computeFollowNode(fromNode, parent, cfa); [EOL]     } [EOL] } <line_num>: 692,789
static Node computeFallThrough(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.DO: [EOL]             return computeFallThrough(n.getFirstChild()); [EOL]         case Token.FOR: [EOL]             if (NodeUtil.isForIn(n)) { [EOL]                 return n.getFirstChild().getNext(); [EOL]             } [EOL]             return computeFallThrough(n.getFirstChild()); [EOL]         case Token.LABEL: [EOL]             return computeFallThrough(n.getLastChild()); [EOL]         default: [EOL]             return n; [EOL]     } [EOL] } <line_num>: 796,810
private void createEdge(Node fromNode, ControlFlowGraph.Branch branch, Node toNode) { [EOL]     cfg.createNode(fromNode); [EOL]     cfg.createNode(toNode); [EOL]     cfg.connectIfNotFound(fromNode, branch, toNode); [EOL] } <line_num>: 818,823
private void connectToPossibleExceptionHandler(Node cfgNode, Node target) { [EOL]     if (mayThrowException(target) && !exceptionHandler.isEmpty()) { [EOL]         Node lastJump = cfgNode; [EOL]         for (Node handler : exceptionHandler) { [EOL]             if (handler.isFunction()) { [EOL]                 return; [EOL]             } [EOL]             Preconditions.checkState(handler.isTry()); [EOL]             Node catchBlock = NodeUtil.getCatchBlock(handler); [EOL]             if (!NodeUtil.hasCatchHandler(catchBlock)) { [EOL]                 if (lastJump == cfgNode) { [EOL]                     createEdge(cfgNode, Branch.ON_EX, handler.getLastChild()); [EOL]                 } else { [EOL]                     finallyMap.put(lastJump, handler.getLastChild()); [EOL]                 } [EOL]             } else { [EOL]                 if (lastJump == cfgNode) { [EOL]                     createEdge(cfgNode, Branch.ON_EX, catchBlock); [EOL]                     return; [EOL]                 } else { [EOL]                     finallyMap.put(lastJump, catchBlock); [EOL]                 } [EOL]             } [EOL]             lastJump = handler; [EOL]         } [EOL]     } [EOL] } <line_num>: 830,857
private static Node getNextSiblingOfType(Node first, int... types) { [EOL]     for (Node c = first; c != null; c = c.getNext()) { [EOL]         for (int type : types) { [EOL]             if (c.getType() == type) { [EOL]                 return c; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 862,871
public static boolean isBreakTarget(Node target, String label) { [EOL]     return isBreakStructure(target, label != null) && matchLabel(target.getParent(), label); [EOL] } <line_num>: 877,880
private static boolean isContinueTarget(Node target, Node parent, String label) { [EOL]     return isContinueStructure(target) && matchLabel(parent, label); [EOL] } <line_num>: 886,889
private static boolean matchLabel(Node target, String label) { [EOL]     if (label == null) { [EOL]         return true; [EOL]     } [EOL]     while (target.isLabel()) { [EOL]         if (target.getFirstChild().getString().equals(label)) { [EOL]             return true; [EOL]         } [EOL]         target = target.getParent(); [EOL]     } [EOL]     return false; [EOL] } <line_num>: 894,905
public static boolean mayThrowException(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.CALL: [EOL]         case Token.GETPROP: [EOL]         case Token.GETELEM: [EOL]         case Token.THROW: [EOL]         case Token.NEW: [EOL]         case Token.ASSIGN: [EOL]         case Token.INC: [EOL]         case Token.DEC: [EOL]         case Token.INSTANCEOF: [EOL]             return true; [EOL]         case Token.FUNCTION: [EOL]             return false; [EOL]     } [EOL]     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { [EOL]         if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 910,931
static boolean isBreakStructure(Node n, boolean labeled) { [EOL]     switch(n.getType()) { [EOL]         case Token.FOR: [EOL]         case Token.DO: [EOL]         case Token.WHILE: [EOL]         case Token.SWITCH: [EOL]             return true; [EOL]         case Token.BLOCK: [EOL]         case Token.IF: [EOL]         case Token.TRY: [EOL]             return labeled; [EOL]         default: [EOL]             return false; [EOL]     } [EOL] } <line_num>: 936,950
static boolean isContinueStructure(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.FOR: [EOL]         case Token.DO: [EOL]         case Token.WHILE: [EOL]             return true; [EOL]         default: [EOL]             return false; [EOL]     } [EOL] } <line_num>: 955,964
static Node getExceptionHandler(Node n) { [EOL]     for (Node cur = n; !cur.isScript() && !cur.isFunction(); cur = cur.getParent()) { [EOL]         Node catchNode = getCatchHandlerForBlock(cur); [EOL]         if (catchNode != null) { [EOL]             return catchNode; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 971,981
static Node getCatchHandlerForBlock(Node block) { [EOL]     if (block.isBlock() && block.getParent().isTry() && block.getParent().getFirstChild() == block) { [EOL]         for (Node s = block.getNext(); s != null; s = s.getNext()) { [EOL]             if (NodeUtil.hasCatchHandler(s)) { [EOL]                 return s.getFirstChild(); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 987,998
@Override [EOL] public int compare(DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) { [EOL]     return getPosition(n2) - getPosition(n1); [EOL] } <line_num>: 1039,1043
@Override [EOL] public int compare(DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) { [EOL]     return getPosition(n1) - getPosition(n2); [EOL] } <line_num>: 1031,1035
@Override [EOL] public Comparator<DiGraphNode<Node, Branch>> getOptionalNodeComparator(boolean isForward) { [EOL]     if (isForward) { [EOL]         return new Comparator<DiGraphNode<Node, Branch>>() { [EOL]  [EOL]             @Override [EOL]             public int compare(DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) { [EOL]                 return getPosition(n1) - getPosition(n2); [EOL]             } [EOL]         }; [EOL]     } else { [EOL]         return new Comparator<DiGraphNode<Node, Branch>>() { [EOL]  [EOL]             @Override [EOL]             public int compare(DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) { [EOL]                 return getPosition(n2) - getPosition(n1); [EOL]             } [EOL]         }; [EOL]     } [EOL] } <line_num>: 1021,1046
private int getPosition(DiGraphNode<Node, Branch> n) { [EOL]     Integer priority = priorities.get(n); [EOL]     Preconditions.checkNotNull(priority); [EOL]     return priority; [EOL] } <line_num>: 1052,1056
