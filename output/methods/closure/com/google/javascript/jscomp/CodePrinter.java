MappedCodePrinter(int lineLengthThreshold, boolean createSrcMap, SourceMap.DetailLevel sourceMapDetailLevel) { [EOL]     Preconditions.checkState(sourceMapDetailLevel != null); [EOL]     this.lineLengthThreshold = lineLengthThreshold <= 0 ? Integer.MAX_VALUE : lineLengthThreshold; [EOL]     this.createSrcMap = createSrcMap; [EOL]     this.sourceMapDetailLevel = sourceMapDetailLevel; [EOL]     this.mappings = createSrcMap ? new ArrayDeque<Mapping>() : null; [EOL]     this.allMappings = createSrcMap ? new ArrayList<Mapping>() : null; [EOL] } <line_num>: 57,68
private PrettyCodePrinter(int lineLengthThreshold, boolean createSourceMap, SourceMap.DetailLevel sourceMapDetailLevel) { [EOL]     super(lineLengthThreshold, createSourceMap, sourceMapDetailLevel); [EOL] } <line_num>: 233,238
private CompactCodePrinter(boolean lineBreak, boolean preferLineBreakAtEndOfFile, int lineLengthThreshold, boolean createSrcMap, SourceMap.DetailLevel sourceMapDetailLevel) { [EOL]     super(lineLengthThreshold, createSrcMap, sourceMapDetailLevel); [EOL]     this.lineBreak = lineBreak; [EOL]     this.preferLineBreakAtEndOfFile = preferLineBreakAtEndOfFile; [EOL] } <line_num>: 431,437
Builder(Node node) { [EOL]     root = node; [EOL] } <line_num>: 556,558
@Override [EOL] void startSourceMapping(Node node) { [EOL]     Preconditions.checkState(sourceMapDetailLevel != null); [EOL]     Preconditions.checkState(node != null); [EOL]     if (createSrcMap && node.getSourceFileName() != null && node.getLineno() > 0 && sourceMapDetailLevel.apply(node)) { [EOL]         int line = getCurrentLineIndex(); [EOL]         int index = getCurrentCharIndex(); [EOL]         Preconditions.checkState(line >= 0); [EOL]         Mapping mapping = new Mapping(); [EOL]         mapping.node = node; [EOL]         mapping.start = new FilePosition(line, index); [EOL]         mappings.push(mapping); [EOL]         allMappings.add(mapping); [EOL]     } [EOL] } <line_num>: 89,106
@Override [EOL] void endSourceMapping(Node node) { [EOL]     if (createSrcMap && !mappings.isEmpty() && mappings.peek().node == node) { [EOL]         Mapping mapping = mappings.pop(); [EOL]         int line = getCurrentLineIndex(); [EOL]         int index = getCurrentCharIndex(); [EOL]         Preconditions.checkState(line >= 0); [EOL]         mapping.end = new FilePosition(line, index); [EOL]     } [EOL] } <line_num>: 112,121
void generateSourceMap(SourceMap map) { [EOL]     if (createSrcMap) { [EOL]         for (Mapping mapping : allMappings) { [EOL]             map.addMapping(mapping.node, mapping.start, mapping.end); [EOL]         } [EOL]     } [EOL] } <line_num>: 128,134
void reportLineCut(int lineIndex, int charIndex, boolean insertion) { [EOL]     if (createSrcMap) { [EOL]         for (Mapping mapping : allMappings) { [EOL]             mapping.start = convertPosition(mapping.start, lineIndex, charIndex, insertion); [EOL]             if (mapping.end != null) { [EOL]                 mapping.end = convertPosition(mapping.end, lineIndex, charIndex, insertion); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 143,155
private FilePosition convertPosition(FilePosition position, int lineIndex, int characterPosition, boolean insertion) { [EOL]     int originalLine = position.getLine(); [EOL]     int originalChar = position.getColumn(); [EOL]     if (insertion) { [EOL]         if (originalLine == lineIndex && originalChar >= characterPosition) { [EOL]             return new FilePosition(originalLine + 1, originalChar - characterPosition); [EOL]         } else { [EOL]             return position; [EOL]         } [EOL]     } else { [EOL]         if (originalLine == lineIndex) { [EOL]             return new FilePosition(originalLine - 1, originalChar + characterPosition); [EOL]         } else if (originalLine > lineIndex) { [EOL]             throw new IllegalStateException("Cannot undo line cut on a previous line."); [EOL]         } else { [EOL]             return position; [EOL]         } [EOL]     } [EOL] } <line_num>: 172,199
public String getCode() { [EOL]     return code.toString(); [EOL] } <line_num>: 201,203
@Override [EOL] char getLastChar() { [EOL]     return (code.length() > 0) ? code.charAt(code.length() - 1) : '\0'; [EOL] } <line_num>: 205,208
protected final int getCurrentCharIndex() { [EOL]     return lineLength; [EOL] } <line_num>: 210,212
protected final int getCurrentLineIndex() { [EOL]     return lineIndex; [EOL] } <line_num>: 214,216
@Override [EOL] void append(String str) { [EOL]     if (lineLength == 0) { [EOL]         for (int i = 0; i < indent; i++) { [EOL]             code.append(INDENT); [EOL]             lineLength += INDENT.length(); [EOL]         } [EOL]     } [EOL]     code.append(str); [EOL]     lineLength += str.length(); [EOL] } <line_num>: 243,254
@Override [EOL] void startNewLine() { [EOL]     if (lineLength > 0) { [EOL]         code.append('\n'); [EOL]         lineIndex++; [EOL]         lineLength = 0; [EOL]     } [EOL] } <line_num>: 260,267
@Override [EOL] void maybeLineBreak() { [EOL]     maybeCutLine(); [EOL] } <line_num>: 269,272
@Override [EOL] void maybeCutLine() { [EOL]     if (lineLength > lineLengthThreshold) { [EOL]         startNewLine(); [EOL]     } [EOL] } <line_num>: 278,283
@Override [EOL] void endLine() { [EOL]     startNewLine(); [EOL] } <line_num>: 285,288
@Override [EOL] void appendBlockStart() { [EOL]     append(" {"); [EOL]     indent++; [EOL] } <line_num>: 290,294
@Override [EOL] void appendBlockEnd() { [EOL]     endLine(); [EOL]     indent--; [EOL]     append("}"); [EOL] } <line_num>: 296,301
@Override [EOL] void listSeparator() { [EOL]     add(", "); [EOL]     maybeLineBreak(); [EOL] } <line_num>: 303,307
@Override [EOL] void endFunction(boolean statementContext) { [EOL]     super.endFunction(statementContext); [EOL]     if (statementContext) { [EOL]         startNewLine(); [EOL]     } [EOL] } <line_num>: 309,315
@Override [EOL] void beginCaseBody() { [EOL]     super.beginCaseBody(); [EOL]     indent++; [EOL]     endLine(); [EOL] } <line_num>: 317,322
@Override [EOL] void endCaseBody() { [EOL]     super.endCaseBody(); [EOL]     indent--; [EOL]     endStatement(); [EOL] } <line_num>: 324,329
@Override [EOL] void appendOp(String op, boolean binOp) { [EOL]     if (binOp) { [EOL]         if (getLastChar() != ' ' && op.charAt(0) != ',') { [EOL]             append(" "); [EOL]         } [EOL]         append(op); [EOL]         append(" "); [EOL]     } else { [EOL]         append(op); [EOL]     } [EOL] } <line_num>: 331,342
@Override [EOL] boolean shouldPreserveExtraBlocks() { [EOL]     return true; [EOL] } <line_num>: 349,355
private Node getTryForCatch(Node n) { [EOL]     return n.getParent().getParent(); [EOL] } <line_num>: 360,362
@Override [EOL] boolean breakAfterBlockFor(Node n, boolean isStatementContext) { [EOL]     Preconditions.checkState(n.isBlock()); [EOL]     Node parent = n.getParent(); [EOL]     if (parent != null) { [EOL]         int type = parent.getType(); [EOL]         switch(type) { [EOL]             case Token.DO: [EOL]                 return false; [EOL]             case Token.FUNCTION: [EOL]                 return false; [EOL]             case Token.TRY: [EOL]                 return n != parent.getFirstChild(); [EOL]             case Token.CATCH: [EOL]                 return !NodeUtil.hasFinally(getTryForCatch(parent)); [EOL]             case Token.IF: [EOL]                 return n == parent.getLastChild(); [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 368,393
@Override [EOL] void endFile() { [EOL]     maybeEndStatement(); [EOL] } <line_num>: 395,398
@Override [EOL] void append(String str) { [EOL]     code.append(str); [EOL]     lineLength += str.length(); [EOL] } <line_num>: 442,446
@Override [EOL] void startNewLine() { [EOL]     if (lineLength > 0) { [EOL]         prevCutPosition = code.length(); [EOL]         prevLineStartPosition = lineStartPosition; [EOL]         code.append('\n'); [EOL]         lineLength = 0; [EOL]         lineIndex++; [EOL]         lineStartPosition = code.length(); [EOL]     } [EOL] } <line_num>: 451,461
@Override [EOL] void maybeLineBreak() { [EOL]     if (lineBreak) { [EOL]         if (sawFunction) { [EOL]             startNewLine(); [EOL]             sawFunction = false; [EOL]         } [EOL]     } [EOL]     int len = code.length(); [EOL]     if (preferredBreakPosition == len - 1) { [EOL]         char ch = code.charAt(len - 1); [EOL]         if (ch == ';') { [EOL]             preferredBreakPosition = len; [EOL]         } [EOL]     } [EOL]     maybeCutLine(); [EOL] } <line_num>: 463,483
@Override [EOL] void maybeCutLine() { [EOL]     if (lineLength > lineLengthThreshold) { [EOL]         if (preferredBreakPosition > lineStartPosition && preferredBreakPosition < lineStartPosition + lineLength) { [EOL]             int position = preferredBreakPosition; [EOL]             code.insert(position, '\n'); [EOL]             prevCutPosition = position; [EOL]             reportLineCut(lineIndex, position - lineStartPosition, true); [EOL]             lineIndex++; [EOL]             lineLength -= (position - lineStartPosition); [EOL]             lineStartPosition = position + 1; [EOL]         } else { [EOL]             startNewLine(); [EOL]         } [EOL]     } [EOL] } <line_num>: 489,506
@Override [EOL] void notePreferredLineBreak() { [EOL]     preferredBreakPosition = code.length(); [EOL] } <line_num>: 508,511
@Override [EOL] void endFile() { [EOL]     super.endFile(); [EOL]     if (!preferLineBreakAtEndOfFile) { [EOL]         return; [EOL]     } [EOL]     if (lineLength > lineLengthThreshold / 2) { [EOL]         append(";"); [EOL]         startNewLine(); [EOL]     } else if (prevCutPosition > 0) { [EOL]         code.setCharAt(prevCutPosition, ' '); [EOL]         lineStartPosition = prevLineStartPosition; [EOL]         lineLength = code.length() - lineStartPosition; [EOL]         reportLineCut(lineIndex, prevCutPosition + 1, false); [EOL]         lineIndex--; [EOL]         prevCutPosition = 0; [EOL]         prevLineStartPosition = 0; [EOL]         append(";"); [EOL]         startNewLine(); [EOL]     } else { [EOL]     } [EOL] } <line_num>: 513,541
Builder setCompilerOptions(CompilerOptions options) { [EOL]     try { [EOL]         this.options = (CompilerOptions) options.clone(); [EOL]     } catch (CloneNotSupportedException e) { [EOL]         throw Throwables.propagate(e); [EOL]     } [EOL]     return this; [EOL] } <line_num>: 563,570
Builder setPrettyPrint(boolean prettyPrint) { [EOL]     options.prettyPrint = prettyPrint; [EOL]     return this; [EOL] } <line_num>: 576,579
Builder setLineBreak(boolean lineBreak) { [EOL]     options.lineBreak = lineBreak; [EOL]     return this; [EOL] } <line_num>: 585,588
Builder setOutputTypes(boolean outputTypes) { [EOL]     this.outputTypes = outputTypes; [EOL]     return this; [EOL] } <line_num>: 594,597
Builder setSourceMap(SourceMap sourceMap) { [EOL]     this.sourceMap = sourceMap; [EOL]     return this; [EOL] } <line_num>: 605,608
Builder setTagAsStrict(boolean tagAsStrict) { [EOL]     this.tagAsStrict = tagAsStrict; [EOL]     return this; [EOL] } <line_num>: 613,616
String build() { [EOL]     if (root == null) { [EOL]         throw new IllegalStateException("Cannot build without root node being specified"); [EOL]     } [EOL]     Format outputFormat = outputTypes ? Format.TYPED : options.prettyPrint ? Format.PRETTY : Format.COMPACT; [EOL]     return toSource(root, outputFormat, options, sourceMap, tagAsStrict); [EOL] } <line_num>: 621,634
private static String toSource(Node root, Format outputFormat, CompilerOptions options, SourceMap sourceMap, boolean tagAsStrict) { [EOL]     Preconditions.checkState(options.sourceMapDetailLevel != null); [EOL]     boolean createSourceMap = (sourceMap != null); [EOL]     MappedCodePrinter mcp = outputFormat == Format.COMPACT ? new CompactCodePrinter(options.lineBreak, options.preferLineBreakAtEndOfFile, options.lineLengthThreshold, createSourceMap, options.sourceMapDetailLevel) : new PrettyCodePrinter(options.lineLengthThreshold, createSourceMap, options.sourceMapDetailLevel); [EOL]     CodeGenerator cg = outputFormat == Format.TYPED ? new TypedCodeGenerator(mcp, options) : new CodeGenerator(mcp, options); [EOL]     if (tagAsStrict) { [EOL]         cg.tagAsStrict(); [EOL]     } [EOL]     cg.add(root); [EOL]     mcp.endFile(); [EOL]     String code = mcp.getCode(); [EOL]     if (createSourceMap) { [EOL]         mcp.generateSourceMap(sourceMap); [EOL]     } [EOL]     return code; [EOL] } <line_num>: 646,682
