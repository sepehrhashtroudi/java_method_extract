NameReferenceGraphConstruction(AbstractCompiler compiler) { [EOL]     this.compiler = compiler; [EOL]     this.graph = new NameReferenceGraph(compiler); [EOL] } <line_num>: 66,69
private Traversal(boolean isExtern) { [EOL]     this.isExtern = isExtern; [EOL]     pushContainingFunction(graph.MAIN); [EOL] } <line_num>: 106,109
private NameUse(Name name, Reference reference) { [EOL]     this.name = name; [EOL]     this.reference = reference; [EOL] } <line_num>: 629,632
NameReferenceGraph getNameReferenceGraph() { [EOL]     return this.graph; [EOL] } <line_num>: 71,73
@Override [EOL] public void process(Node externs, Node root) { [EOL]     ScopeCreator scopeCreator = compiler.getTypedScopeCreator(); [EOL]     if (scopeCreator == null) { [EOL]         scopeCreator = new MemoizedScopeCreator(new TypedScopeCreator(compiler)); [EOL]     } [EOL]     NodeTraversal externsTraversal = new NodeTraversal(compiler, new Traversal(true), scopeCreator); [EOL]     NodeTraversal codeTraversal = new NodeTraversal(compiler, new Traversal(false), scopeCreator); [EOL]     Scope topScope = compiler.getTopScope(); [EOL]     if (topScope != null) { [EOL]         externsTraversal.traverseWithScope(externs, topScope); [EOL]         codeTraversal.traverseWithScope(root, topScope); [EOL]     } else { [EOL]         externsTraversal.traverse(externs); [EOL]         codeTraversal.traverse(root); [EOL]     } [EOL]     connectUnknowns(); [EOL] } <line_num>: 75,100
@Override [EOL] public void enterScope(NodeTraversal t) { [EOL]     Node root = t.getScopeRoot(); [EOL]     Node parent = root.getParent(); [EOL]     if (!t.inGlobalScope()) { [EOL]         String name = NodeUtil.getFunctionName(root); [EOL]         if (name == null) { [EOL]             pushContainingFunction(graph.UNKNOWN); [EOL]             return; [EOL]         } [EOL]         JSType type = getType(root); [EOL]         Node gParent = parent.getParent(); [EOL]         Node ggParent = gParent.getParent(); [EOL]         if (parent.isAssign() && NodeUtil.isPrototypeProperty(parent.getFirstChild())) { [EOL]             pushContainingFunction(recordPrototypePropDefinition(t, parent.getFirstChild(), type, parent, gParent, ggParent)); [EOL]         } else { [EOL]             pushContainingFunction(recordStaticNameDefinition(t, name, type, root, parent, gParent, root.getLastChild())); [EOL]         } [EOL]     } [EOL] } <line_num>: 111,151
@Override [EOL] public void exitScope(NodeTraversal t) { [EOL]     if (!t.inGlobalScope()) { [EOL]         popContainingFunction(); [EOL]     } [EOL] } <line_num>: 153,158
@Override [EOL] public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { [EOL]     return true; [EOL] } <line_num>: 160,163
@SuppressWarnings("fallthrough") [EOL] @Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     switch(n.getType()) { [EOL]         case Token.NAME: [EOL]         case Token.GETPROP: [EOL]             if (parent.isGetProp()) { [EOL]                 return; [EOL]             } else if (parent.isFunction()) { [EOL]                 return; [EOL]             } else if (parent.isAssign()) { [EOL]                 return; [EOL]             } [EOL]             if (isLocalNameReference(t, n)) { [EOL]                 return; [EOL]             } [EOL]             if (isPrototypeNameReference(n)) { [EOL]                 recordPrototypePropUse(t, n, parent); [EOL]             } else if (isStaticNameReference(n, t.getScope())) { [EOL]                 recordStaticNameUse(t, n, parent); [EOL]             } else { [EOL]                 recordUnknownUse(t, n, parent); [EOL]             } [EOL]             break; [EOL]         case Token.ASSIGN: [EOL]             Node lhs = n.getFirstChild(); [EOL]             Node rhs = n.getLastChild(); [EOL]             if (rhs.isFunction()) { [EOL]                 return; [EOL]             } [EOL]             if (lhs.isName() || lhs.isGetProp() || rhs.isGetProp()) { [EOL]                 if (NodeUtil.isPrototypeProperty(lhs)) { [EOL]                     Name name = recordPrototypePropDefinition(t, lhs, getType(rhs), n, parent, parent.getParent()); [EOL]                     name.setAliased(true); [EOL]                 } [EOL]             } [EOL]             maybeAliasNamesOnAssign(lhs, rhs); [EOL]             break; [EOL]         case Token.VAR: [EOL]             Node varName = n.getFirstChild(); [EOL]             Node assignedValue = varName.getFirstChild(); [EOL]             if (assignedValue == null) { [EOL]                 return; [EOL]             } [EOL]             maybeAliasNamesOnAssign(varName, assignedValue); [EOL]             break; [EOL]         case Token.CALL: [EOL]             Node param = n.getFirstChild(); [EOL]             while ((param = param.getNext()) != null) { [EOL]                 if (param.isName() || param.isGetProp()) { [EOL]                     safeAlias(param); [EOL]                 } [EOL]             } [EOL]             maybeRecordExport(n); [EOL]             break; [EOL]     } [EOL] } <line_num>: 165,238
private boolean containsName(Node n) { [EOL]     return NodeUtil.containsType(n, Token.NAME) || NodeUtil.containsType(n, Token.GETELEM) || NodeUtil.containsType(n, Token.GETPROP); [EOL] } <line_num>: 240,244
private void safeAlias(Node n) { [EOL]     if (n.isName() || n.isGetProp()) { [EOL]         String name = n.getQualifiedName(); [EOL]         if (name != null) { [EOL]             defineAndAlias(name); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (n.isGetProp()) { [EOL]         defineAndAlias(n.getLastChild().getString()); [EOL]     } else if (n.isAssign()) { [EOL]         safeAlias(n.getFirstChild()); [EOL]     } else if (n.hasChildren()) { [EOL]         Node cur = n.getFirstChild(); [EOL]         do { [EOL]             safeAlias(cur); [EOL]         } while ((cur = cur.getNext()) != null); [EOL]     } else { [EOL]     } [EOL] } <line_num>: 252,277
private void maybeAliasNamesOnAssign(Node lhs, Node rhs) { [EOL]     if ((lhs.isName() || lhs.isGetProp()) && containsName(rhs) && !rhs.isFunction() && !rhs.isNew()) { [EOL]         safeAlias(lhs); [EOL]         safeAlias(rhs); [EOL]     } [EOL] } <line_num>: 279,287
private void defineAndAlias(String name) { [EOL]     graph.defineNameIfNotExists(name, isExtern).setAliased(true); [EOL] } <line_num>: 289,291
private void maybeRecordExport(Node call) { [EOL]     Preconditions.checkArgument(call.isCall()); [EOL]     Node getProp = call.getFirstChild(); [EOL]     if (!getProp.isGetProp()) { [EOL]         return; [EOL]     } [EOL]     String propQName = getProp.getQualifiedName(); [EOL]     if (propQName == null) { [EOL]         return; [EOL]     } [EOL]     if (propQName.endsWith(".call") || propQName.endsWith(".apply")) { [EOL]         graph.defineNameIfNotExists(getProp.getFirstChild().getQualifiedName(), isExtern).markExposedToCallOrApply(); [EOL]     } [EOL]     if (!"goog.exportSymbol".equals(propQName)) { [EOL]         return; [EOL]     } [EOL]     Node symbol = getProp.getNext(); [EOL]     if (!symbol.isString()) { [EOL]         return; [EOL]     } [EOL]     Node obj = symbol.getNext(); [EOL]     String qName = obj.getQualifiedName(); [EOL]     if (qName == null || obj.getNext() != null) { [EOL]         return; [EOL]     } [EOL]     graph.defineNameIfNotExists(qName, false).markExported(); [EOL] } <line_num>: 293,330
private boolean isLocalNameReference(NodeTraversal t, Node n) { [EOL]     if (n.isName()) { [EOL]         Var v = t.getScope().getVar(n.getString()); [EOL]         return v != null && v.isLocal(); [EOL]     } [EOL]     return false; [EOL] } <line_num>: 335,343
private boolean isStaticNameReference(Node n, Scope scope) { [EOL]     Preconditions.checkArgument(n.isName() || n.isGetProp()); [EOL]     if (n.isName()) { [EOL]         return true; [EOL]     } [EOL]     String qName = n.getQualifiedName(); [EOL]     if (qName == null) { [EOL]         return false; [EOL]     } [EOL]     return scope.isDeclared(qName, true); [EOL] } <line_num>: 348,359
private boolean isPrototypeNameReference(Node n) { [EOL]     if (!n.isGetProp()) { [EOL]         return false; [EOL]     } [EOL]     JSType type = getType(n.getFirstChild()); [EOL]     if (type.isUnknownType() || type.isUnionType()) { [EOL]         return false; [EOL]     } [EOL]     return (type.isInstanceType() || type.autoboxesTo() != null); [EOL] } <line_num>: 364,373
private Name recordStaticNameDefinition(NodeTraversal t, String name, JSType type, Node n, Node parent, Node gParent, Node rValue) { [EOL]     if (getNamedContainingFunction() != graph.MAIN) { [EOL]     } [EOL]     if (type.isConstructor()) { [EOL]         return recordClassConstructorOrInterface(name, type.toMaybeFunctionType(), n, parent, parent.getParent(), rValue); [EOL]     } else { [EOL]         Name symbol = graph.defineNameIfNotExists(name, isExtern); [EOL]         symbol.setType(type); [EOL]         if (n.isAssign()) { [EOL]             symbol.addAssignmentDeclaration(n); [EOL]         } else { [EOL]             symbol.addFunctionDeclaration(n); [EOL]         } [EOL]         return symbol; [EOL]     } [EOL] } <line_num>: 375,396
private Name recordPrototypePropDefinition(NodeTraversal t, Node qName, JSType type, @Nullable Node assign, @Nullable Node parent, @Nullable Node gParent) { [EOL]     JSType constructor = getType(NodeUtil.getPrototypeClassName(qName)); [EOL]     FunctionType classType = null; [EOL]     String className = null; [EOL]     if (constructor != null && constructor.isConstructor()) { [EOL]         classType = constructor.toMaybeFunctionType(); [EOL]         className = classType.getReferenceName(); [EOL]     } else { [EOL]         classType = compiler.getTypeRegistry().getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE); [EOL]         className = NodeUtil.getPrototypeClassName(qName).getQualifiedName(); [EOL]     } [EOL]     recordClassConstructorOrInterface(className, classType, null, null, null, null); [EOL]     String qNameStr = className + ".prototype." + NodeUtil.getPrototypePropertyName(qName); [EOL]     Name prototypeProp = graph.defineNameIfNotExists(qNameStr, isExtern); [EOL]     Preconditions.checkNotNull(prototypeProp, "%s should be in the name graph as a node.", qNameStr); [EOL]     if (assign != null) { [EOL]         prototypeProp.addAssignmentDeclaration(assign); [EOL]     } [EOL]     prototypeProp.setType(type); [EOL]     return prototypeProp; [EOL] } <line_num>: 402,433
private Reference recordStaticNameUse(NodeTraversal t, Node n, Node parent) { [EOL]     if (isExtern) { [EOL]         return null; [EOL]     } else { [EOL]         Reference reference = new Reference(n, parent); [EOL]         Name name = graph.defineNameIfNotExists(n.getQualifiedName(), isExtern); [EOL]         name.setType(getType(n)); [EOL]         graph.connect(getNamedContainingFunction(), reference, name); [EOL]         return reference; [EOL]     } [EOL] } <line_num>: 435,447
private void recordPrototypePropUse(NodeTraversal t, Node n, Node parent) { [EOL]     Preconditions.checkArgument(n.isGetProp()); [EOL]     Node instance = n.getFirstChild(); [EOL]     JSType instanceType = getType(instance); [EOL]     JSType boxedType = instanceType.autoboxesTo(); [EOL]     instanceType = boxedType != null ? boxedType : instanceType; [EOL]     ObjectType objType = instanceType.toObjectType(); [EOL]     Preconditions.checkState(objType != null); [EOL]     if (!isExtern) { [EOL]         Reference ref = new Reference(n, parent); [EOL]         FunctionType constructor = objType.getConstructor(); [EOL]         if (constructor != null) { [EOL]             String propName = n.getLastChild().getString(); [EOL]             if (!constructor.getPrototype().hasOwnProperty(propName)) { [EOL]                 recordSuperClassPrototypePropUse(constructor, propName, ref); [EOL]             } [EOL]             recordSubclassPrototypePropUse(constructor, propName, ref); [EOL]         } else { [EOL]             recordUnknownUse(t, n, parent); [EOL]         } [EOL]     } [EOL] } <line_num>: 449,478
private void recordSuperClassPrototypePropUse(FunctionType classType, String prop, Reference ref) { [EOL]     FunctionType superClass = classType.getSuperClassConstructor(); [EOL]     while (superClass != null) { [EOL]         if (superClass.getPrototype().hasOwnProperty(prop)) { [EOL]             graph.connect(getNamedContainingFunction(), ref, graph.defineNameIfNotExists(superClass.getReferenceName() + ".prototype." + prop, false)); [EOL]             return; [EOL]         } else { [EOL]             superClass = superClass.getSuperClassConstructor(); [EOL]         } [EOL]     } [EOL] } <line_num>: 483,496
private void recordSubclassPrototypePropUse(FunctionType classType, String prop, Reference ref) { [EOL]     if (classType.getPrototype().hasOwnProperty(prop)) { [EOL]         graph.connect(getNamedContainingFunction(), ref, graph.defineNameIfNotExists(classType.getReferenceName() + ".prototype." + prop, false)); [EOL]     } [EOL]     if (classType.getSubTypes() != null) { [EOL]         for (FunctionType subclass : classType.getSubTypes()) { [EOL]             recordSubclassPrototypePropUse(subclass, prop, ref); [EOL]         } [EOL]     } [EOL] } <line_num>: 502,514
private void recordUnknownUse(NodeTraversal t, Node n, Node parent) { [EOL]     if (isExtern) { [EOL]         return; [EOL]     } else { [EOL]         Preconditions.checkArgument(n.isGetProp()); [EOL]         Reference ref = new Reference(n, parent); [EOL]         ref.setUnknown(true); [EOL]         unknownNameUse.put(n.getLastChild().getString(), new NameUse(getNamedContainingFunction(), ref)); [EOL]     } [EOL] } <line_num>: 516,527
private Name recordClassConstructorOrInterface(String name, FunctionType type, @Nullable Node n, @Nullable Node parent, @Nullable Node gParent, @Nullable Node rhs) { [EOL]     Preconditions.checkArgument(type.isConstructor() || type.isInterface()); [EOL]     Name symbol = graph.defineNameIfNotExists(name, isExtern); [EOL]     if (rhs != null) { [EOL]         symbol.setType(getType(rhs)); [EOL]         if (n.isAssign()) { [EOL]             symbol.addAssignmentDeclaration(n); [EOL]         } else { [EOL]             symbol.addFunctionDeclaration(n); [EOL]         } [EOL]     } [EOL]     ObjectType prototype = type.getPrototype(); [EOL]     for (String prop : prototype.getOwnPropertyNames()) { [EOL]         graph.defineNameIfNotExists(name + ".prototype." + prop, isExtern); [EOL]     } [EOL]     return symbol; [EOL] } <line_num>: 533,553
private void connectUnknowns() { [EOL]     for (GraphNode<Name, Reference> node : graph.getNodes()) { [EOL]         Name name = node.getValue(); [EOL]         String propName = name.getPropertyName(); [EOL]         if (propName == null) { [EOL]             continue; [EOL]         } [EOL]         Collection<NameUse> uses = unknownNameUse.get(propName); [EOL]         if (uses != null) { [EOL]             for (NameUse use : uses) { [EOL]                 graph.connect(use.name, use.reference, name); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 556,570
private JSType getType(Node n) { [EOL]     JSType type = n.getJSType(); [EOL]     if (type == null) { [EOL]         if (CONSERVATIVE) { [EOL]             throw new RuntimeException("Type system failed us :("); [EOL]         } else { [EOL]             return compiler.getTypeRegistry().getNativeType(JSTypeNative.UNKNOWN_TYPE); [EOL]         } [EOL]     } [EOL]     return type.restrictByNotNullOrUndefined(); [EOL] } <line_num>: 575,587
private void pushContainingFunction(Name functionNode) { [EOL]     currentFunctionStack.add(functionNode); [EOL] } <line_num>: 595,597
private void popContainingFunction() { [EOL]     currentFunctionStack.remove(currentFunctionStack.size() - 1); [EOL] } <line_num>: 603,605
private Name getNamedContainingFunction() { [EOL]     Name containingFn = null; [EOL]     int pos; [EOL]     for (pos = currentFunctionStack.size() - 1; pos >= 0; pos = pos - 1) { [EOL]         Name cf = currentFunctionStack.get(pos); [EOL]         if (cf != graph.UNKNOWN) { [EOL]             containingFn = cf; [EOL]             break; [EOL]         } [EOL]     } [EOL]     Preconditions.checkNotNull(containingFn); [EOL]     return containingFn; [EOL] } <line_num>: 611,623
