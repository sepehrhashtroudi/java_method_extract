public ReplaceIdGenerators(AbstractCompiler compiler, Set<String> idGens, boolean generatePseudoNames, String previousMapSerialized) { [EOL]     this.compiler = compiler; [EOL]     this.generatePseudoNames = generatePseudoNames; [EOL]     nameGenerators = Maps.newLinkedHashMap(); [EOL]     idGeneratorMaps = Maps.newLinkedHashMap(); [EOL]     consistNameMap = Maps.newLinkedHashMap(); [EOL]     Map<String, BiMap<String, String>> previousMap; [EOL]     previousMap = parsePreviousResults(previousMapSerialized); [EOL]     this.previousMap = previousMap; [EOL]     if (idGens != null) { [EOL]         for (String gen : idGens) { [EOL]             nameGenerators.put(gen, createNameSupplier(RenameStrategy.INCONSISTENT, previousMap.get(gen))); [EOL]             idGeneratorMaps.put(gen, Maps.<String, String>newLinkedHashMap()); [EOL]         } [EOL]     } [EOL] } <line_num>: 73,94
public ObfuscatedNameSuppier(RenameStrategy renameStrategy, BiMap<String, String> previousMappings) { [EOL]     this.previousMappings = previousMappings.inverse(); [EOL]     this.generator = new NameGenerator(previousMappings.keySet(), "", null); [EOL]     this.renameStrategy = renameStrategy; [EOL] } <line_num>: 112,118
public PseudoNameSuppier(RenameStrategy renameStrategy) { [EOL]     this.renameStrategy = renameStrategy; [EOL] } <line_num>: 139,141
String getName(String id, String name); <line_num>: 103,103
RenameStrategy getRenameStrategy(); <line_num>: 104,104
@Override [EOL] public String getName(String id, String name) { [EOL]     String newName = previousMappings.get(id); [EOL]     if (newName == null) { [EOL]         newName = generator.generateNextName(); [EOL]     } [EOL]     return newName; [EOL] } <line_num>: 120,127
@Override [EOL] public RenameStrategy getRenameStrategy() { [EOL]     return renameStrategy; [EOL] } <line_num>: 129,132
@Override [EOL] public String getName(String id, String name) { [EOL]     if (renameStrategy == RenameStrategy.INCONSISTENT) { [EOL]         return name + "$" + counter++; [EOL]     } [EOL]     return name + "$0"; [EOL] } <line_num>: 143,149
@Override [EOL] public RenameStrategy getRenameStrategy() { [EOL]     return renameStrategy; [EOL] } <line_num>: 151,154
@Override [EOL] public String getName(String id, String name) { [EOL]     return Base64.base64EncodeInt(name.hashCode()); [EOL] } <line_num>: 158,161
@Override [EOL] public RenameStrategy getRenameStrategy() { [EOL]     return RenameStrategy.STABLE; [EOL] } <line_num>: 162,165
private NameSupplier createNameSupplier(RenameStrategy renameStrategy, BiMap<String, String> previousMappings) { [EOL]     previousMappings = previousMappings != null ? previousMappings : ImmutableBiMap.<String, String>of(); [EOL]     if (renameStrategy == RenameStrategy.STABLE) { [EOL]         return new StableNameSupplier(); [EOL]     } else if (generatePseudoNames) { [EOL]         return new PseudoNameSuppier(renameStrategy); [EOL]     } else { [EOL]         return new ObfuscatedNameSuppier(renameStrategy, previousMappings); [EOL]     } [EOL] } <line_num>: 168,180
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     JSDocInfo doc = n.getJSDocInfo(); [EOL]     if (doc == null) { [EOL]         return; [EOL]     } [EOL]     int numGeneratorAnnotations = (doc.isConsistentIdGenerator() ? 1 : 0) + (doc.isIdGenerator() ? 1 : 0) + (doc.isStableIdGenerator() ? 1 : 0); [EOL]     if (numGeneratorAnnotations == 0) { [EOL]         return; [EOL]     } else if (numGeneratorAnnotations > 1) { [EOL]         compiler.report(t.makeError(n, CONFLICTING_GENERATOR_TYPE)); [EOL]     } [EOL]     String name = null; [EOL]     if (n.isAssign()) { [EOL]         name = n.getFirstChild().getQualifiedName(); [EOL]     } else if (n.isVar()) { [EOL]         name = n.getFirstChild().getString(); [EOL]     } else if (n.isFunction()) { [EOL]         name = n.getFirstChild().getString(); [EOL]         if (name.isEmpty()) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (doc.isConsistentIdGenerator()) { [EOL]         consistNameMap.put(name, Maps.<String, String>newLinkedHashMap()); [EOL]         nameGenerators.put(name, createNameSupplier(RenameStrategy.CONSISTENT, previousMap.get(name))); [EOL]     } else if (doc.isStableIdGenerator()) { [EOL]         nameGenerators.put(name, createNameSupplier(RenameStrategy.STABLE, previousMap.get(name))); [EOL]     } else { [EOL]         nameGenerators.put(name, createNameSupplier(RenameStrategy.INCONSISTENT, previousMap.get(name))); [EOL]     } [EOL]     idGeneratorMaps.put(name, Maps.<String, String>newLinkedHashMap()); [EOL] } <line_num>: 184,225
@Override [EOL] public void process(Node externs, Node root) { [EOL]     NodeTraversal.traverse(compiler, root, new GatherGenerators()); [EOL]     if (!nameGenerators.isEmpty()) { [EOL]         NodeTraversal.traverse(compiler, root, new ReplaceGenerators()); [EOL]     } [EOL] } <line_num>: 228,234
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (!n.isCall()) { [EOL]         return; [EOL]     } [EOL]     String callName = n.getFirstChild().getQualifiedName(); [EOL]     NameSupplier nameGenerator = nameGenerators.get(callName); [EOL]     if (nameGenerator == null) { [EOL]         return; [EOL]     } [EOL]     if (!t.inGlobalScope() && nameGenerator.getRenameStrategy() == RenameStrategy.INCONSISTENT) { [EOL]         compiler.report(t.makeError(n, NON_GLOBAL_ID_GENERATOR_CALL)); [EOL]         return; [EOL]     } [EOL]     if (nameGenerator.getRenameStrategy() == RenameStrategy.INCONSISTENT) { [EOL]         for (Node ancestor : n.getAncestors()) { [EOL]             if (NodeUtil.isControlStructure(ancestor)) { [EOL]                 compiler.report(t.makeError(n, CONDITIONAL_ID_GENERATOR_CALL)); [EOL]                 return; [EOL]             } [EOL]         } [EOL]     } [EOL]     Node id = n.getFirstChild().getNext(); [EOL]     if (!id.isString()) { [EOL]         return; [EOL]     } [EOL]     Map<String, String> idGeneratorMap = idGeneratorMaps.get(callName); [EOL]     String rename = null; [EOL]     String name = id.getString(); [EOL]     String instanceId = getIdForGeneratorNode(nameGenerator.getRenameStrategy() == RenameStrategy.CONSISTENT, id); [EOL]     if (nameGenerator.getRenameStrategy() == RenameStrategy.CONSISTENT) { [EOL]         Map<String, String> entry = consistNameMap.get(callName); [EOL]         rename = entry.get(instanceId); [EOL]         if (rename == null) { [EOL]             rename = nameGenerator.getName(instanceId, name); [EOL]             entry.put(instanceId, rename); [EOL]         } [EOL]     } else { [EOL]         rename = nameGenerator.getName(instanceId, name); [EOL]     } [EOL]     parent.replaceChild(n, IR.string(rename)); [EOL]     idGeneratorMap.put(rename, instanceId); [EOL]     compiler.reportCodeChange(); [EOL] } <line_num>: 237,294
public String getSerializedIdMappings() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (Map.Entry<String, Map<String, String>> replacements : idGeneratorMaps.entrySet()) { [EOL]         if (!replacements.getValue().isEmpty()) { [EOL]             sb.append("["); [EOL]             sb.append(replacements.getKey()); [EOL]             sb.append("]\n\n"); [EOL]             for (Map.Entry<String, String> replacement : replacements.getValue().entrySet()) { [EOL]                 sb.append(replacement.getKey()); [EOL]                 sb.append(':'); [EOL]                 sb.append(replacement.getValue()); [EOL]                 sb.append("\n"); [EOL]             } [EOL]             sb.append("\n"); [EOL]         } [EOL]     } [EOL]     return sb.toString(); [EOL] } <line_num>: 301,320
private Map<String, BiMap<String, String>> parsePreviousResults(String serializedMap) { [EOL]     if (serializedMap == null || serializedMap.isEmpty()) { [EOL]         return Collections.emptyMap(); [EOL]     } [EOL]     Map<String, BiMap<String, String>> resultMap = Maps.newHashMap(); [EOL]     BufferedReader reader = new BufferedReader(new StringReader(serializedMap)); [EOL]     BiMap<String, String> currentSectionMap = null; [EOL]     String line; [EOL]     int lineIndex = 0; [EOL]     try { [EOL]         while ((line = reader.readLine()) != null) { [EOL]             lineIndex++; [EOL]             if (line.isEmpty()) { [EOL]                 continue; [EOL]             } [EOL]             if (line.charAt(0) == '[') { [EOL]                 String currentSection = line.substring(1, line.length() - 1); [EOL]                 currentSectionMap = resultMap.get(currentSection); [EOL]                 if (currentSectionMap == null) { [EOL]                     currentSectionMap = HashBiMap.create(); [EOL]                     resultMap.put(currentSection, currentSectionMap); [EOL]                 } else { [EOL]                     reportInvalidLine(line, lineIndex); [EOL]                     return Collections.emptyMap(); [EOL]                 } [EOL]             } else { [EOL]                 int split = line.indexOf(':'); [EOL]                 if (split != -1) { [EOL]                     String name = line.substring(0, split); [EOL]                     String location = line.substring(split + 1, line.length()); [EOL]                     currentSectionMap.put(name, location); [EOL]                 } else { [EOL]                     reportInvalidLine(line, lineIndex); [EOL]                     return Collections.emptyMap(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } catch (IOException e) { [EOL]         JSError.make(INVALID_GENERATOR_ID_MAPPING, e.getMessage()); [EOL]     } [EOL]     return resultMap; [EOL] } <line_num>: 322,375
private void reportInvalidLine(String line, int lineIndex) { [EOL]     JSError.make(INVALID_GENERATOR_ID_MAPPING, "line(" + line + "): " + lineIndex); [EOL] } <line_num>: 377,380
String getIdForGeneratorNode(boolean consistent, Node n) { [EOL]     Preconditions.checkState(n.isString()); [EOL]     if (consistent) { [EOL]         return n.getString(); [EOL]     } else { [EOL]         return n.getSourceFileName() + ':' + n.getLineno() + ":" + n.getCharno(); [EOL]     } [EOL] } <line_num>: 382,389
