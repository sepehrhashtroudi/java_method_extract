FunctionToBlockMutator(AbstractCompiler compiler, Supplier<String> safeNameIdSupplier) { [EOL]     this.compiler = compiler; [EOL]     this.safeNameIdSupplier = safeNameIdSupplier; [EOL] } <line_num>: 47,51
LabelNameSupplier(Supplier<String> idSupplier) { [EOL]     this.idSupplier = idSupplier; [EOL] } <line_num>: 194,196
Node mutate(String fnName, Node fnNode, Node callNode, String resultName, boolean needsDefaultResult, boolean isCallInLoop) { [EOL]     Node newFnNode = fnNode.cloneTree(); [EOL]     makeLocalNamesUnique(newFnNode, isCallInLoop); [EOL]     rewriteFunctionDeclarations(newFnNode.getLastChild()); [EOL]     Set<String> namesToAlias = FunctionArgumentInjector.findModifiedParameters(newFnNode); [EOL]     LinkedHashMap<String, Node> args = FunctionArgumentInjector.getFunctionCallParameterMap(newFnNode, callNode, this.safeNameIdSupplier); [EOL]     boolean hasArgs = !args.isEmpty(); [EOL]     if (hasArgs) { [EOL]         FunctionArgumentInjector.maybeAddTempsForCallArguments(newFnNode, args, namesToAlias, compiler.getCodingConvention()); [EOL]     } [EOL]     Node newBlock = NodeUtil.getFunctionBody(newFnNode); [EOL]     newBlock.detachFromParent(); [EOL]     if (hasArgs) { [EOL]         Node inlineResult = aliasAndInlineArguments(newBlock, args, namesToAlias); [EOL]         Preconditions.checkState(newBlock == inlineResult); [EOL]     } [EOL]     if (isCallInLoop) { [EOL]         fixUnitializedVarDeclarations(newBlock); [EOL]     } [EOL]     String labelName = getLabelNameForFunction(fnName); [EOL]     Node injectableBlock = replaceReturns(newBlock, resultName, labelName, needsDefaultResult); [EOL]     Preconditions.checkState(injectableBlock != null); [EOL]     return injectableBlock; [EOL] } <line_num>: 64,115
private void rewriteFunctionDeclarations(Node n) { [EOL]     if (n.isFunction()) { [EOL]         if (NodeUtil.isFunctionDeclaration(n)) { [EOL]             Node fnNameNode = n.getFirstChild(); [EOL]             Node name = IR.name(fnNameNode.getString()).srcref(fnNameNode); [EOL]             Node var = IR.var(name).srcref(n); [EOL]             fnNameNode.setString(""); [EOL]             n.getParent().replaceChild(n, var); [EOL]             name.addChildToFront(n); [EOL]         } [EOL]         return; [EOL]     } [EOL]     for (Node c = n.getFirstChild(), next; c != null; c = next) { [EOL]         next = c.getNext(); [EOL]         rewriteFunctionDeclarations(c); [EOL]     } [EOL] } <line_num>: 121,143
private void fixUnitializedVarDeclarations(Node n) { [EOL]     if (NodeUtil.isLoopStructure(n)) { [EOL]         return; [EOL]     } [EOL]     if (n.isVar()) { [EOL]         Node name = n.getFirstChild(); [EOL]         if (!name.hasChildren()) { [EOL]             Node srcLocation = name; [EOL]             name.addChildToBack(NodeUtil.newUndefinedNode(srcLocation)); [EOL]         } [EOL]         return; [EOL]     } [EOL]     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { [EOL]         fixUnitializedVarDeclarations(c); [EOL]     } [EOL] } <line_num>: 149,170
private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) { [EOL]     Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier(); [EOL]     NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, "inline_", isCallInLoop))); [EOL]     new RenameLabels(compiler, new LabelNameSupplier(idSupplier), false).process(null, fnNode); [EOL] } <line_num>: 177,189
@Override [EOL] public String get() { [EOL]     return "JSCompiler_inline_label_" + idSupplier.get(); [EOL] } <line_num>: 198,201
private String getLabelNameForFunction(String fnName) { [EOL]     String name = (fnName == null || fnName.isEmpty()) ? "anon" : fnName; [EOL]     return "JSCompiler_inline_label_" + name + "_" + safeNameIdSupplier.get(); [EOL] } <line_num>: 207,210
private String getUniqueThisName() { [EOL]     return "JSCompiler_inline_this_" + safeNameIdSupplier.get(); [EOL] } <line_num>: 215,217
private Node aliasAndInlineArguments(Node fnTemplateRoot, LinkedHashMap<String, Node> argMap, Set<String> namesToAlias) { [EOL]     if (namesToAlias == null || namesToAlias.isEmpty()) { [EOL]         Node result = FunctionArgumentInjector.inject(compiler, fnTemplateRoot, null, argMap); [EOL]         Preconditions.checkState(result == fnTemplateRoot); [EOL]         return result; [EOL]     } else { [EOL]         Map<String, Node> newArgMap = Maps.newHashMap(argMap); [EOL]         List<Node> newVars = Lists.newLinkedList(); [EOL]         for (Entry<String, Node> entry : argMap.entrySet()) { [EOL]             String name = entry.getKey(); [EOL]             if (namesToAlias.contains(name)) { [EOL]                 if (name.equals(THIS_MARKER)) { [EOL]                     boolean referencesThis = NodeUtil.referencesThis(fnTemplateRoot); [EOL]                     Node value = entry.getValue(); [EOL]                     if (!value.isThis() && (referencesThis || NodeUtil.mayHaveSideEffects(value, compiler))) { [EOL]                         String newName = getUniqueThisName(); [EOL]                         Node newValue = entry.getValue().cloneTree(); [EOL]                         Node newNode = NodeUtil.newVarNode(newName, newValue).copyInformationFromForTree(newValue); [EOL]                         newVars.add(0, newNode); [EOL]                         newArgMap.put(THIS_MARKER, IR.name(newName).srcrefTree(newValue)); [EOL]                     } [EOL]                 } else { [EOL]                     Node newValue = entry.getValue().cloneTree(); [EOL]                     Node newNode = NodeUtil.newVarNode(name, newValue).copyInformationFromForTree(newValue); [EOL]                     newVars.add(0, newNode); [EOL]                     newArgMap.remove(name); [EOL]                 } [EOL]             } [EOL]         } [EOL]         Node result = FunctionArgumentInjector.inject(compiler, fnTemplateRoot, null, newArgMap); [EOL]         Preconditions.checkState(result == fnTemplateRoot); [EOL]         for (Node n : newVars) { [EOL]             fnTemplateRoot.addChildToFront(n); [EOL]         } [EOL]         return result; [EOL]     } [EOL] } <line_num>: 229,299
private static Node replaceReturns(Node block, String resultName, String labelName, boolean resultMustBeSet) { [EOL]     Preconditions.checkNotNull(block); [EOL]     Preconditions.checkNotNull(labelName); [EOL]     Node root = block; [EOL]     boolean hasReturnAtExit = false; [EOL]     int returnCount = NodeUtil.getNodeTypeReferenceCount(block, Token.RETURN, new NodeUtil.MatchShallowStatement()); [EOL]     if (returnCount > 0) { [EOL]         hasReturnAtExit = hasReturnAtExit(block); [EOL]         if (hasReturnAtExit) { [EOL]             convertLastReturnToStatement(block, resultName); [EOL]             returnCount--; [EOL]         } [EOL]         if (returnCount > 0) { [EOL]             replaceReturnWithBreak(block, null, resultName, labelName); [EOL]             Node name = IR.labelName(labelName).srcref(block); [EOL]             Node label = IR.label(name, block).srcref(block); [EOL]             Node newRoot = IR.block().srcref(block); [EOL]             newRoot.addChildrenToBack(label); [EOL]             root = newRoot; [EOL]         } [EOL]     } [EOL]     if (resultMustBeSet && !hasReturnAtExit && resultName != null) { [EOL]         addDummyAssignment(block, resultName); [EOL]     } [EOL]     return root; [EOL] } <line_num>: 322,368
private static void addDummyAssignment(Node node, String resultName) { [EOL]     Preconditions.checkArgument(node.isBlock()); [EOL]     Node srcLocation = node; [EOL]     Node retVal = NodeUtil.newUndefinedNode(srcLocation); [EOL]     Node resultNode = createAssignStatementNode(resultName, retVal); [EOL]     resultNode.copyInformationFromForTree(node); [EOL]     node.addChildrenToBack(resultNode); [EOL] } <line_num>: 378,388
private static void convertLastReturnToStatement(Node block, String resultName) { [EOL]     Node ret = block.getLastChild(); [EOL]     Preconditions.checkArgument(ret.isReturn()); [EOL]     Node resultNode = getReplacementReturnStatement(ret, resultName); [EOL]     if (resultNode == null) { [EOL]         block.removeChild(ret); [EOL]     } else { [EOL]         resultNode.copyInformationFromForTree(ret); [EOL]         block.replaceChild(ret, resultNode); [EOL]     } [EOL] } <line_num>: 398,410
private static Node createAssignStatementNode(String name, Node expression) { [EOL]     Node nameNode = IR.name(name); [EOL]     Node assign = IR.assign(nameNode, expression); [EOL]     return NodeUtil.newExpr(assign); [EOL] } <line_num>: 416,422
private static Node getReplacementReturnStatement(Node node, String resultName) { [EOL]     Node resultNode = null; [EOL]     Node retVal = null; [EOL]     if (node.hasChildren()) { [EOL]         retVal = node.getFirstChild().cloneTree(); [EOL]     } [EOL]     if (resultName == null) { [EOL]         if (retVal != null) { [EOL]             resultNode = NodeUtil.newExpr(retVal); [EOL]         } [EOL]     } else { [EOL]         if (retVal == null) { [EOL]             Node srcLocation = node; [EOL]             retVal = NodeUtil.newUndefinedNode(srcLocation); [EOL]         } [EOL]         resultNode = createAssignStatementNode(resultName, retVal); [EOL]     } [EOL]     return resultNode; [EOL] } <line_num>: 433,459
private static boolean hasReturnAtExit(Node block) { [EOL]     return (block.getLastChild().isReturn()); [EOL] } <line_num>: 464,468
private static Node replaceReturnWithBreak(Node current, Node parent, String resultName, String labelName) { [EOL]     if (current.isFunction() || current.isExprResult()) { [EOL]         return current; [EOL]     } [EOL]     if (current.isReturn()) { [EOL]         Preconditions.checkState(NodeUtil.isStatementBlock(parent)); [EOL]         Node resultNode = getReplacementReturnStatement(current, resultName); [EOL]         Node breakNode = IR.breakNode(IR.labelName(labelName)); [EOL]         breakNode.copyInformationFromForTree(current); [EOL]         parent.replaceChild(current, breakNode); [EOL]         if (resultNode != null) { [EOL]             resultNode.copyInformationFromForTree(current); [EOL]             parent.addChildBefore(resultNode, breakNode); [EOL]         } [EOL]         current = breakNode; [EOL]     } else { [EOL]         for (Node c = current.getFirstChild(); c != null; c = c.getNext()) { [EOL]             c = replaceReturnWithBreak(c, current, resultName, labelName); [EOL]         } [EOL]     } [EOL]     return current; [EOL] } <line_num>: 476,508
