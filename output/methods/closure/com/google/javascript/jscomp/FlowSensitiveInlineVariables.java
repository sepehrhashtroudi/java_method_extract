public FlowSensitiveInlineVariables(AbstractCompiler compiler) { [EOL]     this.compiler = compiler; [EOL] } <line_num>: 120,122
Candidate(String varName, Definition defMetadata, Node use, Node useCfgNode) { [EOL]     Preconditions.checkArgument(use.isName()); [EOL]     this.varName = varName; [EOL]     this.defMetadata = defMetadata; [EOL]     this.use = use; [EOL]     this.useCfgNode = useCfgNode; [EOL] } <line_num>: 267,274
@Override [EOL] public boolean apply(Node n) { [EOL]     if (n == null) { [EOL]         return false; [EOL]     } [EOL]     if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) { [EOL]         return true; [EOL]     } [EOL]     if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) { [EOL]         return true; [EOL]     } [EOL]     if (n.isDelProp()) { [EOL]         return true; [EOL]     } [EOL]     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { [EOL]         if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 88,117
@Override [EOL] public void enterScope(NodeTraversal t) { [EOL]     if (t.inGlobalScope()) { [EOL]         return; [EOL]     } [EOL]     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) { [EOL]         return; [EOL]     } [EOL]     ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true); [EOL]     Preconditions.checkState(t.getScopeRoot().isFunction()); [EOL]     cfa.process(null, t.getScopeRoot().getLastChild()); [EOL]     cfg = cfa.getCfg(); [EOL]     reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler); [EOL]     reachingDef.analyze(); [EOL]     candidates = Lists.newLinkedList(); [EOL]     new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild()); [EOL]     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler); [EOL]     reachingUses.analyze(); [EOL]     for (Candidate c : candidates) { [EOL]         if (c.canInline(t.getScope())) { [EOL]             c.inlineVariable(); [EOL]             if (!c.defMetadata.depends.isEmpty()) { [EOL]                 inlinedNewDependencies.add(t.getScope().getVar(c.varName)); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 124,170
@Override [EOL] public void exitScope(NodeTraversal t) { [EOL] } <line_num>: 172,173
@Override [EOL] public void process(Node externs, Node root) { [EOL]     (new NodeTraversal(compiler, this)).traverseRoots(externs, root); [EOL] } <line_num>: 175,178
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL] } <line_num>: 180,187
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (n.isName()) { [EOL]         if (parent == null) { [EOL]             return; [EOL]         } [EOL]         if ((NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) || parent.isVar() || parent.isInc() || parent.isDec() || parent.isParamList() || parent.isCatch()) { [EOL]             return; [EOL]         } [EOL]         String name = n.getString(); [EOL]         if (compiler.getCodingConvention().isExported(name)) { [EOL]             return; [EOL]         } [EOL]         Definition def = reachingDef.getDef(name, cfgNode); [EOL]         if (def != null && !reachingDef.dependsOnOuterScopeVars(def)) { [EOL]             candidates.add(new Candidate(name, def, n, cfgNode)); [EOL]         } [EOL]     } [EOL] } <line_num>: 210,240
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     DiGraphNode<Node, Branch> graphNode = cfg.getDirectedGraphNode(n); [EOL]     if (graphNode == null) { [EOL]         return; [EOL]     } [EOL]     FlowState<MustDef> state = graphNode.getAnnotation(); [EOL]     final MustDef defs = state.getIn(); [EOL]     final Node cfgNode = n; [EOL]     AbstractCfgNodeTraversalCallback gatherCb = new AbstractCfgNodeTraversalCallback() { [EOL]  [EOL]         @Override [EOL]         public void visit(NodeTraversal t, Node n, Node parent) { [EOL]             if (n.isName()) { [EOL]                 if (parent == null) { [EOL]                     return; [EOL]                 } [EOL]                 if ((NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) || parent.isVar() || parent.isInc() || parent.isDec() || parent.isParamList() || parent.isCatch()) { [EOL]                     return; [EOL]                 } [EOL]                 String name = n.getString(); [EOL]                 if (compiler.getCodingConvention().isExported(name)) { [EOL]                     return; [EOL]                 } [EOL]                 Definition def = reachingDef.getDef(name, cfgNode); [EOL]                 if (def != null && !reachingDef.dependsOnOuterScopeVars(def)) { [EOL]                     candidates.add(new Candidate(name, def, n, cfgNode)); [EOL]                 } [EOL]             } [EOL]         } [EOL]     }; [EOL]     NodeTraversal.traverse(compiler, cfgNode, gatherCb); [EOL] } <line_num>: 197,244
private Node getDefCfgNode() { [EOL]     return defMetadata.node; [EOL] } <line_num>: 276,278
@Override [EOL] public boolean apply(Node input) { [EOL]     switch(input.getType()) { [EOL]         case Token.GETELEM: [EOL]         case Token.GETPROP: [EOL]         case Token.ARRAYLIT: [EOL]         case Token.OBJECTLIT: [EOL]         case Token.REGEXP: [EOL]         case Token.NEW: [EOL]             return true; [EOL]         case Token.NAME: [EOL]             Var var = scope.getOwnSlot(input.getString()); [EOL]             if (var != null && var.getParentNode().isCatch()) { [EOL]                 return true; [EOL]             } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 365,383
@Override [EOL] public boolean apply(Node input) { [EOL]     return !input.isFunction(); [EOL] } <line_num>: 386,390
private boolean canInline(final Scope scope) { [EOL]     if (getDefCfgNode().isFunction()) { [EOL]         return false; [EOL]     } [EOL]     for (Var dependency : defMetadata.depends) { [EOL]         if (inlinedNewDependencies.contains(dependency)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     getDefinition(getDefCfgNode(), null); [EOL]     getNumUseInUseCfgNode(useCfgNode, null); [EOL]     if (def == null) { [EOL]         return false; [EOL]     } [EOL]     if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) { [EOL]         return false; [EOL]     } [EOL]     if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) { [EOL]         return false; [EOL]     } [EOL]     if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) { [EOL]         return false; [EOL]     } [EOL]     if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) { [EOL]         return false; [EOL]     } [EOL]     if (numUseWithinUseCfgNode != 1) { [EOL]         return false; [EOL]     } [EOL]     if (NodeUtil.isWithinLoop(use)) { [EOL]         return false; [EOL]     } [EOL]     Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode()); [EOL]     if (uses.size() != 1) { [EOL]         return false; [EOL]     } [EOL]     if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() { [EOL]  [EOL]         @Override [EOL]         public boolean apply(Node input) { [EOL]             switch(input.getType()) { [EOL]                 case Token.GETELEM: [EOL]                 case Token.GETPROP: [EOL]                 case Token.ARRAYLIT: [EOL]                 case Token.OBJECTLIT: [EOL]                 case Token.REGEXP: [EOL]                 case Token.NEW: [EOL]                     return true; [EOL]                 case Token.NAME: [EOL]                     Var var = scope.getOwnSlot(input.getString()); [EOL]                     if (var != null && var.getParentNode().isCatch()) { [EOL]                         return true; [EOL]                     } [EOL]             } [EOL]             return false; [EOL]         } [EOL]     }, new Predicate<Node>() { [EOL]  [EOL]         @Override [EOL]         public boolean apply(Node input) { [EOL]             return !input.isFunction(); [EOL]         } [EOL]     })) { [EOL]         return false; [EOL]     } [EOL]     if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) { [EOL]         CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false); [EOL]         if (pathCheck.somePathsSatisfyPredicate()) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 280,417
private void inlineVariable() { [EOL]     Node defParent = def.getParent(); [EOL]     Node useParent = use.getParent(); [EOL]     if (def.isAssign()) { [EOL]         Node rhs = def.getLastChild(); [EOL]         rhs.detachFromParent(); [EOL]         Preconditions.checkState(defParent.isExprResult()); [EOL]         while (defParent.getParent().isLabel()) { [EOL]             defParent = defParent.getParent(); [EOL]         } [EOL]         defParent.detachFromParent(); [EOL]         useParent.replaceChild(use, rhs); [EOL]     } else if (defParent.isVar()) { [EOL]         Node rhs = def.getLastChild(); [EOL]         def.removeChild(rhs); [EOL]         useParent.replaceChild(use, rhs); [EOL]     } else { [EOL]         Preconditions.checkState(false, "No other definitions can be inlined."); [EOL]     } [EOL]     compiler.reportCodeChange(); [EOL] } <line_num>: 422,443
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     switch(n.getType()) { [EOL]         case Token.NAME: [EOL]             if (n.getString().equals(varName) && n.hasChildren()) { [EOL]                 def = n; [EOL]             } [EOL]             return; [EOL]         case Token.ASSIGN: [EOL]             Node lhs = n.getFirstChild(); [EOL]             if (lhs.isName() && lhs.getString().equals(varName)) { [EOL]                 def = n; [EOL]             } [EOL]             return; [EOL]     } [EOL] } <line_num>: 454,470
private void getDefinition(Node n, Node parent) { [EOL]     AbstractCfgNodeTraversalCallback gatherCb = new AbstractCfgNodeTraversalCallback() { [EOL]  [EOL]         @Override [EOL]         public void visit(NodeTraversal t, Node n, Node parent) { [EOL]             switch(n.getType()) { [EOL]                 case Token.NAME: [EOL]                     if (n.getString().equals(varName) && n.hasChildren()) { [EOL]                         def = n; [EOL]                     } [EOL]                     return; [EOL]                 case Token.ASSIGN: [EOL]                     Node lhs = n.getFirstChild(); [EOL]                     if (lhs.isName() && lhs.getString().equals(varName)) { [EOL]                         def = n; [EOL]                     } [EOL]                     return; [EOL]             } [EOL]         } [EOL]     }; [EOL]     NodeTraversal.traverse(compiler, n, gatherCb); [EOL] } <line_num>: 450,473
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (n.isName() && n.getString().equals(varName) && !(parent.isAssign() && (parent.getFirstChild() == n))) { [EOL]         numUseWithinUseCfgNode++; [EOL]     } [EOL] } <line_num>: 484,492
private void getNumUseInUseCfgNode(Node n, Node parant) { [EOL]     AbstractCfgNodeTraversalCallback gatherCb = new AbstractCfgNodeTraversalCallback() { [EOL]  [EOL]         @Override [EOL]         public void visit(NodeTraversal t, Node n, Node parent) { [EOL]             if (n.isName() && n.getString().equals(varName) && !(parent.isAssign() && (parent.getFirstChild() == n))) { [EOL]                 numUseWithinUseCfgNode++; [EOL]             } [EOL]         } [EOL]     }; [EOL]     NodeTraversal.traverse(compiler, n, gatherCb); [EOL] } <line_num>: 479,496
private static boolean checkRightOf(Node n, Node expressionRoot, Predicate<Node> predicate) { [EOL]     for (Node p = n; p != expressionRoot; p = p.getParent()) { [EOL]         for (Node cur = p.getNext(); cur != null; cur = cur.getNext()) { [EOL]             if (predicate.apply(cur)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 507,517
private static boolean checkLeftOf(Node n, Node expressionRoot, Predicate<Node> predicate) { [EOL]     for (Node p = n.getParent(); p != expressionRoot; p = p.getParent()) { [EOL]         for (Node cur = p.getParent().getFirstChild(); cur != p; cur = cur.getNext()) { [EOL]             if (predicate.apply(cur)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 527,538
