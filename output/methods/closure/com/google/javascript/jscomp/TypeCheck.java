public TypeCheck(AbstractCompiler compiler, ReverseAbstractInterpreter reverseInterpreter, JSTypeRegistry typeRegistry, Scope topScope, MemoizedScopeCreator scopeCreator, CheckLevel reportMissingOverride, CheckLevel reportUnknownTypes) { [EOL]     this.compiler = compiler; [EOL]     this.validator = compiler.getTypeValidator(); [EOL]     this.reverseInterpreter = reverseInterpreter; [EOL]     this.typeRegistry = typeRegistry; [EOL]     this.topScope = topScope; [EOL]     this.scopeCreator = scopeCreator; [EOL]     this.reportMissingOverride = reportMissingOverride; [EOL]     this.reportUnknownTypes = reportUnknownTypes; [EOL]     this.inferJSDocInfo = new InferJSDocInfo(compiler); [EOL] } <line_num>: 315,331
public TypeCheck(AbstractCompiler compiler, ReverseAbstractInterpreter reverseInterpreter, JSTypeRegistry typeRegistry, CheckLevel reportMissingOverride, CheckLevel reportUnknownTypes) { [EOL]     this(compiler, reverseInterpreter, typeRegistry, null, null, reportMissingOverride, reportUnknownTypes); [EOL] } <line_num>: 333,340
TypeCheck(AbstractCompiler compiler, ReverseAbstractInterpreter reverseInterpreter, JSTypeRegistry typeRegistry) { [EOL]     this(compiler, reverseInterpreter, typeRegistry, null, null, CheckLevel.WARNING, CheckLevel.OFF); [EOL] } <line_num>: 342,347
TypeCheck reportMissingProperties(boolean report) { [EOL]     reportMissingProperties = report; [EOL]     return this; [EOL] } <line_num>: 350,353
@Override [EOL] public void process(Node externsRoot, Node jsRoot) { [EOL]     Preconditions.checkNotNull(scopeCreator); [EOL]     Preconditions.checkNotNull(topScope); [EOL]     Node externsAndJs = jsRoot.getParent(); [EOL]     Preconditions.checkState(externsAndJs != null); [EOL]     Preconditions.checkState(externsRoot == null || externsAndJs.hasChild(externsRoot)); [EOL]     if (externsRoot != null) { [EOL]         check(externsRoot, true); [EOL]     } [EOL]     check(jsRoot, false); [EOL] } <line_num>: 362,376
public Scope processForTesting(Node externsRoot, Node jsRoot) { [EOL]     Preconditions.checkState(scopeCreator == null); [EOL]     Preconditions.checkState(topScope == null); [EOL]     Preconditions.checkState(jsRoot.getParent() != null); [EOL]     Node externsAndJsRoot = jsRoot.getParent(); [EOL]     scopeCreator = new MemoizedScopeCreator(new TypedScopeCreator(compiler)); [EOL]     topScope = scopeCreator.createScope(externsAndJsRoot, null); [EOL]     TypeInferencePass inference = new TypeInferencePass(compiler, reverseInterpreter, topScope, scopeCreator); [EOL]     inference.process(externsRoot, jsRoot); [EOL]     process(externsRoot, jsRoot); [EOL]     return topScope; [EOL] } <line_num>: 379,396
public void check(Node node, boolean externs) { [EOL]     Preconditions.checkNotNull(node); [EOL]     NodeTraversal t = new NodeTraversal(compiler, this, scopeCreator); [EOL]     inExterns = externs; [EOL]     t.traverseWithScope(node, topScope); [EOL]     if (externs) { [EOL]         inferJSDocInfo.process(node, null); [EOL]     } else { [EOL]         inferJSDocInfo.process(null, node); [EOL]     } [EOL] } <line_num>: 399,410
private void checkNoTypeCheckSection(Node n, boolean enterSection) { [EOL]     switch(n.getType()) { [EOL]         case Token.SCRIPT: [EOL]         case Token.BLOCK: [EOL]         case Token.VAR: [EOL]         case Token.FUNCTION: [EOL]         case Token.ASSIGN: [EOL]             JSDocInfo info = n.getJSDocInfo(); [EOL]             if (info != null && info.isNoTypeCheck()) { [EOL]                 if (enterSection) { [EOL]                     noTypeCheckSection++; [EOL]                 } else { [EOL]                     noTypeCheckSection--; [EOL]                 } [EOL]             } [EOL]             validator.setShouldReport(noTypeCheckSection == 0); [EOL]             break; [EOL]     } [EOL] } <line_num>: 413,431
private void report(NodeTraversal t, Node n, DiagnosticType diagnosticType, String... arguments) { [EOL]     if (noTypeCheckSection == 0) { [EOL]         t.report(n, diagnosticType, arguments); [EOL]     } [EOL] } <line_num>: 433,438
@Override [EOL] public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { [EOL]     checkNoTypeCheckSection(n, true); [EOL]     switch(n.getType()) { [EOL]         case Token.FUNCTION: [EOL]             final Scope outerScope = t.getScope(); [EOL]             final String functionPrivateName = n.getFirstChild().getString(); [EOL]             if (functionPrivateName != null && functionPrivateName.length() > 0 && outerScope.isDeclared(functionPrivateName, false) && !(outerScope.getVar(functionPrivateName).getType() instanceof FunctionType)) { [EOL]                 report(t, n, FUNCTION_MASKS_VARIABLE, functionPrivateName); [EOL]             } [EOL]             break; [EOL]     } [EOL]     return true; [EOL] } <line_num>: 440,465
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     JSType childType; [EOL]     JSType leftType, rightType; [EOL]     Node left, right; [EOL]     boolean typeable = true; [EOL]     switch(n.getType()) { [EOL]         case Token.CAST: [EOL]             Node expr = n.getFirstChild(); [EOL]             ensureTyped(t, n, getJSType(expr)); [EOL]             JSType castType = getJSType(n); [EOL]             JSType exprType = getJSType(expr); [EOL]             if (castType.isSubtype(exprType)) { [EOL]                 expr.setJSType(castType); [EOL]             } [EOL]             break; [EOL]         case Token.NAME: [EOL]             typeable = visitName(t, n, parent); [EOL]             break; [EOL]         case Token.PARAM_LIST: [EOL]             typeable = false; [EOL]             break; [EOL]         case Token.COMMA: [EOL]             ensureTyped(t, n, getJSType(n.getLastChild())); [EOL]             break; [EOL]         case Token.TRUE: [EOL]         case Token.FALSE: [EOL]             ensureTyped(t, n, BOOLEAN_TYPE); [EOL]             break; [EOL]         case Token.THIS: [EOL]             ensureTyped(t, n, t.getScope().getTypeOfThis()); [EOL]             break; [EOL]         case Token.NULL: [EOL]             ensureTyped(t, n, NULL_TYPE); [EOL]             break; [EOL]         case Token.NUMBER: [EOL]             ensureTyped(t, n, NUMBER_TYPE); [EOL]             break; [EOL]         case Token.STRING: [EOL]             ensureTyped(t, n, STRING_TYPE); [EOL]             break; [EOL]         case Token.STRING_KEY: [EOL]             typeable = false; [EOL]             break; [EOL]         case Token.GETTER_DEF: [EOL]         case Token.SETTER_DEF: [EOL]             break; [EOL]         case Token.ARRAYLIT: [EOL]             ensureTyped(t, n, ARRAY_TYPE); [EOL]             break; [EOL]         case Token.REGEXP: [EOL]             ensureTyped(t, n, REGEXP_TYPE); [EOL]             break; [EOL]         case Token.GETPROP: [EOL]             visitGetProp(t, n, parent); [EOL]             typeable = !(parent.isAssign() && parent.getFirstChild() == n); [EOL]             break; [EOL]         case Token.GETELEM: [EOL]             visitGetElem(t, n); [EOL]             typeable = false; [EOL]             break; [EOL]         case Token.VAR: [EOL]             visitVar(t, n); [EOL]             typeable = false; [EOL]             break; [EOL]         case Token.NEW: [EOL]             visitNew(t, n); [EOL]             break; [EOL]         case Token.CALL: [EOL]             visitCall(t, n); [EOL]             typeable = !parent.isExprResult(); [EOL]             break; [EOL]         case Token.RETURN: [EOL]             visitReturn(t, n); [EOL]             typeable = false; [EOL]             break; [EOL]         case Token.DEC: [EOL]         case Token.INC: [EOL]             left = n.getFirstChild(); [EOL]             checkPropCreation(t, left); [EOL]             validator.expectNumber(t, left, getJSType(left), "increment/decrement"); [EOL]             ensureTyped(t, n, NUMBER_TYPE); [EOL]             break; [EOL]         case Token.NOT: [EOL]             ensureTyped(t, n, BOOLEAN_TYPE); [EOL]             break; [EOL]         case Token.VOID: [EOL]             ensureTyped(t, n, VOID_TYPE); [EOL]             break; [EOL]         case Token.TYPEOF: [EOL]             ensureTyped(t, n, STRING_TYPE); [EOL]             break; [EOL]         case Token.BITNOT: [EOL]             childType = getJSType(n.getFirstChild()); [EOL]             if (!childType.matchesInt32Context()) { [EOL]                 report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString()); [EOL]             } [EOL]             ensureTyped(t, n, NUMBER_TYPE); [EOL]             break; [EOL]         case Token.POS: [EOL]         case Token.NEG: [EOL]             left = n.getFirstChild(); [EOL]             validator.expectNumber(t, left, getJSType(left), "sign operator"); [EOL]             ensureTyped(t, n, NUMBER_TYPE); [EOL]             break; [EOL]         case Token.EQ: [EOL]         case Token.NE: [EOL]         case Token.SHEQ: [EOL]         case Token.SHNE: [EOL]             { [EOL]                 left = n.getFirstChild(); [EOL]                 right = n.getLastChild(); [EOL]                 if (left.isTypeOf()) { [EOL]                     if (right.isString()) { [EOL]                         checkTypeofString(t, right, right.getString()); [EOL]                     } [EOL]                 } else if (right.isTypeOf() && left.isString()) { [EOL]                     checkTypeofString(t, left, left.getString()); [EOL]                 } [EOL]                 leftType = getJSType(left); [EOL]                 rightType = getJSType(right); [EOL]                 JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined(); [EOL]                 JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined(); [EOL]                 TernaryValue result = TernaryValue.UNKNOWN; [EOL]                 if (n.getType() == Token.EQ || n.getType() == Token.NE) { [EOL]                     result = leftTypeRestricted.testForEquality(rightTypeRestricted); [EOL]                     if (n.isNE()) { [EOL]                         result = result.not(); [EOL]                     } [EOL]                 } else { [EOL]                     if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) { [EOL]                         result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE; [EOL]                     } [EOL]                 } [EOL]                 if (result != TernaryValue.UNKNOWN) { [EOL]                     report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString()); [EOL]                 } [EOL]                 ensureTyped(t, n, BOOLEAN_TYPE); [EOL]                 break; [EOL]             } [EOL]         case Token.LT: [EOL]         case Token.LE: [EOL]         case Token.GT: [EOL]         case Token.GE: [EOL]             leftType = getJSType(n.getFirstChild()); [EOL]             rightType = getJSType(n.getLastChild()); [EOL]             if (rightType.isNumber()) { [EOL]                 validator.expectNumber(t, n, leftType, "left side of numeric comparison"); [EOL]             } else if (leftType.isNumber()) { [EOL]                 validator.expectNumber(t, n, rightType, "right side of numeric comparison"); [EOL]             } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) { [EOL]             } else { [EOL]                 String message = "left side of comparison"; [EOL]                 validator.expectString(t, n, leftType, message); [EOL]                 validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE)); [EOL]                 message = "right side of comparison"; [EOL]                 validator.expectString(t, n, rightType, message); [EOL]                 validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE)); [EOL]             } [EOL]             ensureTyped(t, n, BOOLEAN_TYPE); [EOL]             break; [EOL]         case Token.IN: [EOL]             left = n.getFirstChild(); [EOL]             right = n.getLastChild(); [EOL]             rightType = getJSType(right); [EOL]             validator.expectString(t, left, getJSType(left), "left side of 'in'"); [EOL]             validator.expectObject(t, n, rightType, "'in' requires an object"); [EOL]             if (rightType.isStruct()) { [EOL]                 report(t, right, IN_USED_WITH_STRUCT); [EOL]             } [EOL]             ensureTyped(t, n, BOOLEAN_TYPE); [EOL]             break; [EOL]         case Token.INSTANCEOF: [EOL]             left = n.getFirstChild(); [EOL]             right = n.getLastChild(); [EOL]             rightType = getJSType(right).restrictByNotNullOrUndefined(); [EOL]             validator.expectAnyObject(t, left, getJSType(left), "deterministic instanceof yields false"); [EOL]             validator.expectActualObject(t, right, rightType, "instanceof requires an object"); [EOL]             ensureTyped(t, n, BOOLEAN_TYPE); [EOL]             break; [EOL]         case Token.ASSIGN: [EOL]             visitAssign(t, n); [EOL]             typeable = false; [EOL]             break; [EOL]         case Token.ASSIGN_LSH: [EOL]         case Token.ASSIGN_RSH: [EOL]         case Token.ASSIGN_URSH: [EOL]         case Token.ASSIGN_DIV: [EOL]         case Token.ASSIGN_MOD: [EOL]         case Token.ASSIGN_BITOR: [EOL]         case Token.ASSIGN_BITXOR: [EOL]         case Token.ASSIGN_BITAND: [EOL]         case Token.ASSIGN_SUB: [EOL]         case Token.ASSIGN_ADD: [EOL]         case Token.ASSIGN_MUL: [EOL]             checkPropCreation(t, n.getFirstChild()); [EOL]         case Token.LSH: [EOL]         case Token.RSH: [EOL]         case Token.URSH: [EOL]         case Token.DIV: [EOL]         case Token.MOD: [EOL]         case Token.BITOR: [EOL]         case Token.BITXOR: [EOL]         case Token.BITAND: [EOL]         case Token.SUB: [EOL]         case Token.ADD: [EOL]         case Token.MUL: [EOL]             visitBinaryOperator(n.getType(), t, n); [EOL]             break; [EOL]         case Token.DELPROP: [EOL]             ensureTyped(t, n, BOOLEAN_TYPE); [EOL]             break; [EOL]         case Token.CASE: [EOL]             JSType switchType = getJSType(parent.getFirstChild()); [EOL]             JSType caseType = getJSType(n.getFirstChild()); [EOL]             validator.expectSwitchMatchesCase(t, n, switchType, caseType); [EOL]             typeable = false; [EOL]             break; [EOL]         case Token.WITH: [EOL]             { [EOL]                 Node child = n.getFirstChild(); [EOL]                 childType = getJSType(child); [EOL]                 validator.expectObject(t, child, childType, "with requires an object"); [EOL]                 typeable = false; [EOL]                 break; [EOL]             } [EOL]         case Token.FUNCTION: [EOL]             visitFunction(t, n); [EOL]             break; [EOL]         case Token.LABEL: [EOL]         case Token.LABEL_NAME: [EOL]         case Token.SWITCH: [EOL]         case Token.BREAK: [EOL]         case Token.CATCH: [EOL]         case Token.TRY: [EOL]         case Token.SCRIPT: [EOL]         case Token.EXPR_RESULT: [EOL]         case Token.BLOCK: [EOL]         case Token.EMPTY: [EOL]         case Token.DEFAULT_CASE: [EOL]         case Token.CONTINUE: [EOL]         case Token.DEBUGGER: [EOL]         case Token.THROW: [EOL]             typeable = false; [EOL]             break; [EOL]         case Token.DO: [EOL]         case Token.IF: [EOL]         case Token.WHILE: [EOL]             typeable = false; [EOL]             break; [EOL]         case Token.FOR: [EOL]             if (NodeUtil.isForIn(n)) { [EOL]                 Node obj = n.getChildAtIndex(1); [EOL]                 if (getJSType(obj).isStruct()) { [EOL]                     report(t, obj, IN_USED_WITH_STRUCT); [EOL]                 } [EOL]             } [EOL]             typeable = false; [EOL]             break; [EOL]         case Token.AND: [EOL]         case Token.HOOK: [EOL]         case Token.OBJECTLIT: [EOL]         case Token.OR: [EOL]             if (n.getJSType() != null) { [EOL]                 ensureTyped(t, n); [EOL]             } else { [EOL]                 if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) { [EOL]                     ensureTyped(t, n, parent.getJSType()); [EOL]                 } else { [EOL]                     ensureTyped(t, n); [EOL]                 } [EOL]             } [EOL]             if (n.isObjectLit()) { [EOL]                 JSType typ = getJSType(n); [EOL]                 for (Node key : n.children()) { [EOL]                     visitObjLitKey(t, key, n, typ); [EOL]                 } [EOL]             } [EOL]             break; [EOL]         default: [EOL]             report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType())); [EOL]             ensureTyped(t, n); [EOL]             break; [EOL]     } [EOL]     typeable = typeable && !inExterns; [EOL]     if (typeable) { [EOL]         doPercentTypedAccounting(t, n); [EOL]     } [EOL]     checkNoTypeCheckSection(n, false); [EOL] } <line_num>: 477,854
private void checkTypeofString(NodeTraversal t, Node n, String s) { [EOL]     if (!(s.equals("number") || s.equals("string") || s.equals("boolean") || s.equals("undefined") || s.equals("function") || s.equals("object") || s.equals("unknown"))) { [EOL]         validator.expectValidTypeofName(t, n, s); [EOL]     } [EOL] } <line_num>: 856,862
private void doPercentTypedAccounting(NodeTraversal t, Node n) { [EOL]     JSType type = n.getJSType(); [EOL]     if (type == null) { [EOL]         nullCount++; [EOL]     } else if (type.isUnknownType()) { [EOL]         if (reportUnknownTypes.isOn()) { [EOL]             compiler.report(t.makeError(n, reportUnknownTypes, UNKNOWN_EXPR_TYPE)); [EOL]         } [EOL]         unknownCount++; [EOL]     } else { [EOL]         typedCount++; [EOL]     } [EOL] } <line_num>: 868,881
private void visitAssign(NodeTraversal t, Node assign) { [EOL]     JSDocInfo info = assign.getJSDocInfo(); [EOL]     Node lvalue = assign.getFirstChild(); [EOL]     Node rvalue = assign.getLastChild(); [EOL]     if (lvalue.isGetProp()) { [EOL]         Node object = lvalue.getFirstChild(); [EOL]         JSType objectJsType = getJSType(object); [EOL]         Node property = lvalue.getLastChild(); [EOL]         String pname = property.getString(); [EOL]         if (object.isGetProp()) { [EOL]             JSType jsType = getJSType(object.getFirstChild()); [EOL]             if (jsType.isInterface() && object.getLastChild().getString().equals("prototype")) { [EOL]                 visitInterfaceGetprop(t, assign, object, pname, lvalue, rvalue); [EOL]             } [EOL]         } [EOL]         checkEnumAlias(t, info, rvalue); [EOL]         checkPropCreation(t, lvalue); [EOL]         if (pname.equals("prototype")) { [EOL]             if (objectJsType != null && objectJsType.isFunctionType()) { [EOL]                 FunctionType functionType = objectJsType.toMaybeFunctionType(); [EOL]                 if (functionType.isConstructor()) { [EOL]                     JSType rvalueType = rvalue.getJSType(); [EOL]                     validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT); [EOL]                     if (functionType.makesStructs() && !rvalueType.isStruct()) { [EOL]                         String funName = functionType.getTypeOfThis().toString(); [EOL]                         compiler.report(t.makeError(assign, CONFLICTING_EXTENDED_TYPE, "struct", funName)); [EOL]                     } [EOL]                     return; [EOL]                 } [EOL]             } [EOL]         } [EOL]         ObjectType type = ObjectType.cast(objectJsType.restrictByNotNullOrUndefined()); [EOL]         if (type != null) { [EOL]             if (type.hasProperty(pname) && !type.isPropertyTypeInferred(pname) && !propertyIsImplicitCast(type, pname)) { [EOL]                 JSType expectedType = type.getPropertyType(pname); [EOL]                 if (!expectedType.isUnknownType()) { [EOL]                     validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), expectedType, object, pname); [EOL]                     checkPropertyInheritanceOnGetpropAssign(t, assign, object, pname, info, expectedType); [EOL]                     return; [EOL]                 } [EOL]             } [EOL]         } [EOL]         checkPropertyInheritanceOnGetpropAssign(t, assign, object, pname, info, getNativeType(UNKNOWN_TYPE)); [EOL]     } [EOL]     JSType leftType = getJSType(lvalue); [EOL]     if (lvalue.isQualifiedName()) { [EOL]         JSType rvalueType = getJSType(assign.getLastChild()); [EOL]         Var var = t.getScope().getVar(lvalue.getQualifiedName()); [EOL]         if (var != null) { [EOL]             if (var.isTypeInferred()) { [EOL]                 return; [EOL]             } [EOL]             if (NodeUtil.getRootOfQualifiedName(lvalue).isThis() && t.getScope() != var.getScope()) { [EOL]                 return; [EOL]             } [EOL]             if (var.getType() != null) { [EOL]                 leftType = var.getType(); [EOL]             } [EOL]         } [EOL]     } [EOL]     Node rightChild = assign.getLastChild(); [EOL]     JSType rightType = getJSType(rightChild); [EOL]     if (validator.expectCanAssignTo(t, assign, rightType, leftType, "assignment")) { [EOL]         ensureTyped(t, assign, rightType); [EOL]     } else { [EOL]         ensureTyped(t, assign); [EOL]     } [EOL] } <line_num>: 891,1001
private void checkPropCreation(NodeTraversal t, Node lvalue) { [EOL]     if (lvalue.isGetProp()) { [EOL]         Node obj = lvalue.getFirstChild(); [EOL]         Node prop = lvalue.getLastChild(); [EOL]         JSType objType = getJSType(obj); [EOL]         String pname = prop.getString(); [EOL]         if (objType.isStruct() && !objType.hasProperty(pname)) { [EOL]             if (!(obj.isThis() && getJSType(t.getScope().getRootNode()).isConstructor())) { [EOL]                 report(t, prop, ILLEGAL_PROPERTY_CREATION); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 1004,1017
private void checkPropertyInheritanceOnGetpropAssign(NodeTraversal t, Node assign, Node object, String property, JSDocInfo info, JSType propertyType) { [EOL]     if (object.isGetProp()) { [EOL]         Node object2 = object.getFirstChild(); [EOL]         String property2 = NodeUtil.getStringValue(object.getLastChild()); [EOL]         if ("prototype".equals(property2)) { [EOL]             JSType jsType = getJSType(object2); [EOL]             if (jsType.isFunctionType()) { [EOL]                 FunctionType functionType = jsType.toMaybeFunctionType(); [EOL]                 if (functionType.isConstructor() || functionType.isInterface()) { [EOL]                     checkDeclaredPropertyInheritance(t, assign, functionType, property, info, propertyType); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 1019,1048
private void visitObjLitKey(NodeTraversal t, Node key, Node objlit, JSType litType) { [EOL]     if (objlit.isFromExterns()) { [EOL]         ensureTyped(t, key); [EOL]         return; [EOL]     } [EOL]     if (litType.isStruct() && key.isQuotedString()) { [EOL]         report(t, key, ILLEGAL_OBJLIT_KEY, "struct"); [EOL]     } else if (litType.isDict() && !key.isQuotedString()) { [EOL]         report(t, key, ILLEGAL_OBJLIT_KEY, "dict"); [EOL]     } [EOL]     Node rvalue = key.getFirstChild(); [EOL]     JSType rightType = NodeUtil.getObjectLitKeyTypeFromValueType(key, getJSType(rvalue)); [EOL]     if (rightType == null) { [EOL]         rightType = getNativeType(UNKNOWN_TYPE); [EOL]     } [EOL]     Node owner = objlit; [EOL]     JSType keyType = getJSType(key); [EOL]     JSType allowedValueType = keyType; [EOL]     if (allowedValueType.isEnumElementType()) { [EOL]         allowedValueType = allowedValueType.toMaybeEnumElementType().getPrimitiveType(); [EOL]     } [EOL]     boolean valid = validator.expectCanAssignToPropertyOf(t, key, rightType, allowedValueType, owner, NodeUtil.getObjectLitKeyName(key)); [EOL]     if (valid) { [EOL]         ensureTyped(t, key, rightType); [EOL]     } else { [EOL]         ensureTyped(t, key); [EOL]     } [EOL]     JSType objlitType = getJSType(objlit); [EOL]     ObjectType type = ObjectType.cast(objlitType.restrictByNotNullOrUndefined()); [EOL]     if (type != null) { [EOL]         String property = NodeUtil.getObjectLitKeyName(key); [EOL]         if (type.hasProperty(property) && !type.isPropertyTypeInferred(property) && !propertyIsImplicitCast(type, property)) { [EOL]             validator.expectCanAssignToPropertyOf(t, key, keyType, type.getPropertyType(property), owner, property); [EOL]         } [EOL]         return; [EOL]     } [EOL] } <line_num>: 1059,1128
private boolean propertyIsImplicitCast(ObjectType type, String prop) { [EOL]     for (; type != null; type = type.getImplicitPrototype()) { [EOL]         JSDocInfo docInfo = type.getOwnPropertyJSDocInfo(prop); [EOL]         if (docInfo != null && docInfo.isImplicitCast()) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1134,1142
private void checkDeclaredPropertyInheritance(NodeTraversal t, Node n, FunctionType ctorType, String propertyName, JSDocInfo info, JSType propertyType) { [EOL]     if (hasUnknownOrEmptySupertype(ctorType)) { [EOL]         return; [EOL]     } [EOL]     FunctionType superClass = ctorType.getSuperClassConstructor(); [EOL]     boolean superClassHasProperty = superClass != null && superClass.getInstanceType().hasProperty(propertyName); [EOL]     boolean superClassHasDeclaredProperty = superClass != null && superClass.getInstanceType().isPropertyTypeDeclared(propertyName); [EOL]     boolean superInterfaceHasProperty = false; [EOL]     boolean superInterfaceHasDeclaredProperty = false; [EOL]     if (ctorType.isInterface()) { [EOL]         for (ObjectType interfaceType : ctorType.getExtendedInterfaces()) { [EOL]             superInterfaceHasProperty = superInterfaceHasProperty || interfaceType.hasProperty(propertyName); [EOL]             superInterfaceHasDeclaredProperty = superInterfaceHasDeclaredProperty || interfaceType.isPropertyTypeDeclared(propertyName); [EOL]         } [EOL]     } [EOL]     boolean declaredOverride = info != null && info.isOverride(); [EOL]     boolean foundInterfaceProperty = false; [EOL]     if (ctorType.isConstructor()) { [EOL]         for (JSType implementedInterface : ctorType.getAllImplementedInterfaces()) { [EOL]             if (implementedInterface.isUnknownType() || implementedInterface.isEmptyType()) { [EOL]                 continue; [EOL]             } [EOL]             FunctionType interfaceType = implementedInterface.toObjectType().getConstructor(); [EOL]             Preconditions.checkNotNull(interfaceType); [EOL]             boolean interfaceHasProperty = interfaceType.getPrototype().hasProperty(propertyName); [EOL]             foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty; [EOL]             if (reportMissingOverride.isOn() && !declaredOverride && interfaceHasProperty) { [EOL]                 compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_INTERFACE_PROPERTY, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString())); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (!declaredOverride && !superClassHasProperty && !superInterfaceHasProperty) { [EOL]         return; [EOL]     } [EOL]     ObjectType topInstanceType = superClassHasDeclaredProperty ? superClass.getTopMostDefiningType(propertyName) : null; [EOL]     boolean declaredLocally = ctorType.isConstructor() && (ctorType.getPrototype().hasOwnProperty(propertyName) || ctorType.getInstanceType().hasOwnProperty(propertyName)); [EOL]     if (reportMissingOverride.isOn() && !declaredOverride && superClassHasDeclaredProperty && declaredLocally) { [EOL]         compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_SUPERCLASS_PROPERTY, propertyName, topInstanceType.toString())); [EOL]     } [EOL]     if (superClassHasDeclaredProperty) { [EOL]         JSType superClassPropType = superClass.getInstanceType().getPropertyType(propertyName); [EOL]         if (!propertyType.isSubtype(superClassPropType)) { [EOL]             compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString())); [EOL]         } [EOL]     } else if (superInterfaceHasDeclaredProperty) { [EOL]         for (ObjectType interfaceType : ctorType.getExtendedInterfaces()) { [EOL]             if (interfaceType.hasProperty(propertyName)) { [EOL]                 JSType superPropertyType = interfaceType.getPropertyType(propertyName); [EOL]                 if (!propertyType.isSubtype(superPropertyType)) { [EOL]                     topInstanceType = interfaceType.getConstructor().getTopMostDefiningType(propertyName); [EOL]                     compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superPropertyType.toString(), propertyType.toString())); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } else if (!foundInterfaceProperty && !superClassHasProperty && !superInterfaceHasProperty) { [EOL]         compiler.report(t.makeError(n, UNKNOWN_OVERRIDE, propertyName, ctorType.getInstanceType().toString())); [EOL]     } [EOL] } <line_num>: 1150,1268
private static boolean hasUnknownOrEmptySupertype(FunctionType ctor) { [EOL]     Preconditions.checkArgument(ctor.isConstructor() || ctor.isInterface()); [EOL]     Preconditions.checkArgument(!ctor.isUnknownType()); [EOL]     while (true) { [EOL]         ObjectType maybeSuperInstanceType = ctor.getPrototype().getImplicitPrototype(); [EOL]         if (maybeSuperInstanceType == null) { [EOL]             return false; [EOL]         } [EOL]         if (maybeSuperInstanceType.isUnknownType() || maybeSuperInstanceType.isEmptyType()) { [EOL]             return true; [EOL]         } [EOL]         ctor = maybeSuperInstanceType.getConstructor(); [EOL]         if (ctor == null) { [EOL]             return false; [EOL]         } [EOL]         Preconditions.checkState(ctor.isConstructor() || ctor.isInterface()); [EOL]     } [EOL] } <line_num>: 1274,1296
private void visitInterfaceGetprop(NodeTraversal t, Node assign, Node object, String property, Node lvalue, Node rvalue) { [EOL]     JSType rvalueType = getJSType(rvalue); [EOL]     String abstractMethodName = compiler.getCodingConvention().getAbstractMethodName(); [EOL]     if (!rvalueType.isFunctionType()) { [EOL]         String abstractMethodMessage = (abstractMethodName != null) ? ", or " + abstractMethodName : ""; [EOL]         compiler.report(t.makeError(object, INVALID_INTERFACE_MEMBER_DECLARATION, abstractMethodMessage)); [EOL]     } [EOL]     if (assign.getLastChild().isFunction() && !NodeUtil.isEmptyBlock(assign.getLastChild().getLastChild())) { [EOL]         compiler.report(t.makeError(object, INTERFACE_FUNCTION_NOT_EMPTY, abstractMethodName)); [EOL]     } [EOL] } <line_num>: 1304,1333
boolean visitName(NodeTraversal t, Node n, Node parent) { [EOL]     int parentNodeType = parent.getType(); [EOL]     if (parentNodeType == Token.FUNCTION || parentNodeType == Token.CATCH || parentNodeType == Token.PARAM_LIST || parentNodeType == Token.VAR) { [EOL]         return false; [EOL]     } [EOL]     JSType type = n.getJSType(); [EOL]     if (type == null) { [EOL]         type = getNativeType(UNKNOWN_TYPE); [EOL]         Var var = t.getScope().getVar(n.getString()); [EOL]         if (var != null) { [EOL]             JSType varType = var.getType(); [EOL]             if (varType != null) { [EOL]                 type = varType; [EOL]             } [EOL]         } [EOL]     } [EOL]     ensureTyped(t, n, type); [EOL]     return true; [EOL] } <line_num>: 1344,1373
private void visitGetProp(NodeTraversal t, Node n, Node parent) { [EOL]     Node property = n.getLastChild(); [EOL]     Node objNode = n.getFirstChild(); [EOL]     JSType childType = getJSType(objNode); [EOL]     if (childType.isDict()) { [EOL]         report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, "'.'", "dict"); [EOL]     } else if (validator.expectNotNullOrUndefined(t, n, childType, "No properties on this expression", getNativeType(OBJECT_TYPE))) { [EOL]         checkPropertyAccess(childType, property.getString(), t, n); [EOL]     } [EOL]     ensureTyped(t, n); [EOL] } <line_num>: 1383,1399
private void checkPropertyAccess(JSType childType, String propName, NodeTraversal t, Node n) { [EOL]     JSType propType = getJSType(n); [EOL]     if (propType.isEquivalentTo(typeRegistry.getNativeType(UNKNOWN_TYPE))) { [EOL]         childType = childType.autobox(); [EOL]         ObjectType objectType = ObjectType.cast(childType); [EOL]         if (objectType != null) { [EOL]             if (!objectType.hasProperty(propName) || objectType.isEquivalentTo(typeRegistry.getNativeType(UNKNOWN_TYPE))) { [EOL]                 if (objectType instanceof EnumType) { [EOL]                     report(t, n, INEXISTENT_ENUM_ELEMENT, propName); [EOL]                 } else { [EOL]                     checkPropertyAccessHelper(objectType, propName, t, n); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             checkPropertyAccessHelper(childType, propName, t, n); [EOL]         } [EOL]     } [EOL] } <line_num>: 1408,1436
private void checkPropertyAccessHelper(JSType objectType, String propName, NodeTraversal t, Node n) { [EOL]     if (!objectType.isEmptyType() && reportMissingProperties && !isPropertyTest(n)) { [EOL]         if (!typeRegistry.canPropertyBeDefined(objectType, propName)) { [EOL]             report(t, n, INEXISTENT_PROPERTY, propName, validator.getReadableJSTypeName(n.getFirstChild(), true)); [EOL]         } [EOL]     } [EOL] } <line_num>: 1438,1447
private boolean isPropertyTest(Node getProp) { [EOL]     Node parent = getProp.getParent(); [EOL]     switch(parent.getType()) { [EOL]         case Token.CALL: [EOL]             return parent.getFirstChild() != getProp && compiler.getCodingConvention().isPropertyTestFunction(parent); [EOL]         case Token.IF: [EOL]         case Token.WHILE: [EOL]         case Token.DO: [EOL]         case Token.FOR: [EOL]             return NodeUtil.getConditionExpression(parent) == getProp; [EOL]         case Token.INSTANCEOF: [EOL]         case Token.TYPEOF: [EOL]             return true; [EOL]         case Token.AND: [EOL]         case Token.HOOK: [EOL]             return parent.getFirstChild() == getProp; [EOL]         case Token.NOT: [EOL]             return parent.getParent().isOr() && parent.getParent().getFirstChild() == parent; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1455,1481
private void visitGetElem(NodeTraversal t, Node n) { [EOL]     validator.expectIndexMatch(t, n, getJSType(n.getFirstChild()), getJSType(n.getLastChild())); [EOL]     ensureTyped(t, n); [EOL] } <line_num>: 1490,1494
private void visitVar(NodeTraversal t, Node n) { [EOL]     JSDocInfo varInfo = n.hasOneChild() ? n.getJSDocInfo() : null; [EOL]     for (Node name : n.children()) { [EOL]         Node value = name.getFirstChild(); [EOL]         Var var = t.getScope().getVar(name.getString()); [EOL]         if (value != null) { [EOL]             JSType valueType = getJSType(value); [EOL]             JSType nameType = var.getType(); [EOL]             nameType = (nameType == null) ? getNativeType(UNKNOWN_TYPE) : nameType; [EOL]             JSDocInfo info = name.getJSDocInfo(); [EOL]             if (info == null) { [EOL]                 info = varInfo; [EOL]             } [EOL]             checkEnumAlias(t, info, value); [EOL]             if (var.isTypeInferred()) { [EOL]                 ensureTyped(t, name, valueType); [EOL]             } else { [EOL]                 validator.expectCanAssignTo(t, value, valueType, nameType, "initializing variable"); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 1503,1532
private void visitNew(NodeTraversal t, Node n) { [EOL]     Node constructor = n.getFirstChild(); [EOL]     JSType type = getJSType(constructor).restrictByNotNullOrUndefined(); [EOL]     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) { [EOL]         FunctionType fnType = type.toMaybeFunctionType(); [EOL]         if (fnType != null) { [EOL]             visitParameterList(t, n, fnType); [EOL]             ensureTyped(t, n, fnType.getInstanceType()); [EOL]         } else { [EOL]             ensureTyped(t, n); [EOL]         } [EOL]     } else { [EOL]         report(t, n, NOT_A_CONSTRUCTOR); [EOL]         ensureTyped(t, n); [EOL]     } [EOL] } <line_num>: 1537,1552
private void checkInterfaceConflictProperties(NodeTraversal t, Node n, String functionName, HashMap<String, ObjectType> properties, HashMap<String, ObjectType> currentProperties, ObjectType interfaceType) { [EOL]     ObjectType implicitProto = interfaceType.getImplicitPrototype(); [EOL]     Set<String> currentPropertyNames; [EOL]     if (implicitProto == null) { [EOL]         currentPropertyNames = ImmutableSet.of(); [EOL]     } else { [EOL]         currentPropertyNames = implicitProto.getOwnPropertyNames(); [EOL]     } [EOL]     for (String name : currentPropertyNames) { [EOL]         ObjectType oType = properties.get(name); [EOL]         if (oType != null) { [EOL]             if (!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))) { [EOL]                 compiler.report(t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE, functionName, name, oType.toString(), interfaceType.toString())); [EOL]             } [EOL]         } [EOL]         currentProperties.put(name, interfaceType); [EOL]     } [EOL]     for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) { [EOL]         checkInterfaceConflictProperties(t, n, functionName, properties, currentProperties, iType); [EOL]     } [EOL] } <line_num>: 1566,1596
private void visitFunction(NodeTraversal t, Node n) { [EOL]     FunctionType functionType = JSType.toMaybeFunctionType(n.getJSType()); [EOL]     String functionPrivateName = n.getFirstChild().getString(); [EOL]     if (functionType.isConstructor()) { [EOL]         FunctionType baseConstructor = functionType.getSuperClassConstructor(); [EOL]         if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) && baseConstructor != null && baseConstructor.isInterface()) { [EOL]             compiler.report(t.makeError(n, CONFLICTING_EXTENDED_TYPE, "constructor", functionPrivateName)); [EOL]         } else { [EOL]             if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE)) { [EOL]                 ObjectType proto = functionType.getPrototype(); [EOL]                 if (functionType.makesStructs() && !proto.isStruct()) { [EOL]                     compiler.report(t.makeError(n, CONFLICTING_EXTENDED_TYPE, "struct", functionPrivateName)); [EOL]                 } else if (functionType.makesDicts() && !proto.isDict()) { [EOL]                     compiler.report(t.makeError(n, CONFLICTING_EXTENDED_TYPE, "dict", functionPrivateName)); [EOL]                 } [EOL]             } [EOL]             for (JSType baseInterface : functionType.getImplementedInterfaces()) { [EOL]                 boolean badImplementedType = false; [EOL]                 ObjectType baseInterfaceObj = ObjectType.cast(baseInterface); [EOL]                 if (baseInterfaceObj != null) { [EOL]                     FunctionType interfaceConstructor = baseInterfaceObj.getConstructor(); [EOL]                     if (interfaceConstructor != null && !interfaceConstructor.isInterface()) { [EOL]                         badImplementedType = true; [EOL]                     } [EOL]                 } else { [EOL]                     badImplementedType = true; [EOL]                 } [EOL]                 if (badImplementedType) { [EOL]                     report(t, n, BAD_IMPLEMENTED_TYPE, functionPrivateName); [EOL]                 } [EOL]             } [EOL]             validator.expectAllInterfaceProperties(t, n, functionType); [EOL]         } [EOL]     } else if (functionType.isInterface()) { [EOL]         for (ObjectType extInterface : functionType.getExtendedInterfaces()) { [EOL]             if (extInterface.getConstructor() != null && !extInterface.getConstructor().isInterface()) { [EOL]                 compiler.report(t.makeError(n, CONFLICTING_EXTENDED_TYPE, "interface", functionPrivateName)); [EOL]             } [EOL]         } [EOL]         if (functionType.getExtendedInterfacesCount() > 1) { [EOL]             HashMap<String, ObjectType> properties = new HashMap<String, ObjectType>(); [EOL]             HashMap<String, ObjectType> currentProperties = new HashMap<String, ObjectType>(); [EOL]             for (ObjectType interfaceType : functionType.getExtendedInterfaces()) { [EOL]                 currentProperties.clear(); [EOL]                 checkInterfaceConflictProperties(t, n, functionPrivateName, properties, currentProperties, interfaceType); [EOL]                 properties.putAll(currentProperties); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 1605,1674
private void visitCall(NodeTraversal t, Node n) { [EOL]     Node child = n.getFirstChild(); [EOL]     JSType childType = getJSType(child).restrictByNotNullOrUndefined(); [EOL]     if (!childType.canBeCalled()) { [EOL]         report(t, n, NOT_CALLABLE, childType.toString()); [EOL]         ensureTyped(t, n); [EOL]         return; [EOL]     } [EOL]     if (childType.isFunctionType()) { [EOL]         FunctionType functionType = childType.toMaybeFunctionType(); [EOL]         boolean isExtern = false; [EOL]         JSDocInfo functionJSDocInfo = functionType.getJSDocInfo(); [EOL]         if (functionJSDocInfo != null && functionJSDocInfo.getAssociatedNode() != null) { [EOL]             isExtern = functionJSDocInfo.getAssociatedNode().isFromExterns(); [EOL]         } [EOL]         if (functionType.isConstructor() && !functionType.isNativeObjectType() && (functionType.getReturnType().isUnknownType() || functionType.getReturnType().isVoidType() || !isExtern)) { [EOL]             report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString()); [EOL]         } [EOL]         if (functionType.isOrdinaryFunction() && !functionType.getTypeOfThis().isUnknownType() && !(functionType.getTypeOfThis().toObjectType() != null && functionType.getTypeOfThis().toObjectType().isNativeObjectType()) && !(child.isGetElem() || child.isGetProp())) { [EOL]             report(t, n, EXPECTED_THIS_TYPE, functionType.toString()); [EOL]         } [EOL]         visitParameterList(t, n, functionType); [EOL]         ensureTyped(t, n, functionType.getReturnType()); [EOL]     } else { [EOL]         ensureTyped(t, n); [EOL]     } [EOL] } <line_num>: 1683,1736
private void visitParameterList(NodeTraversal t, Node call, FunctionType functionType) { [EOL]     Iterator<Node> arguments = call.children().iterator(); [EOL]     arguments.next(); [EOL]     Iterator<Node> parameters = functionType.getParameters().iterator(); [EOL]     int ordinal = 0; [EOL]     Node parameter = null; [EOL]     Node argument = null; [EOL]     while (arguments.hasNext() && (parameters.hasNext() || parameter != null && parameter.isVarArgs())) { [EOL]         if (parameters.hasNext()) { [EOL]             parameter = parameters.next(); [EOL]         } [EOL]         argument = arguments.next(); [EOL]         ordinal++; [EOL]         validator.expectArgumentMatchesParameter(t, argument, getJSType(argument), getJSType(parameter), call, ordinal); [EOL]     } [EOL]     int numArgs = call.getChildCount() - 1; [EOL]     int minArgs = functionType.getMinArguments(); [EOL]     int maxArgs = functionType.getMaxArguments(); [EOL]     if (minArgs > numArgs || maxArgs < numArgs) { [EOL]         report(t, call, WRONG_ARGUMENT_COUNT, validator.getReadableJSTypeName(call.getFirstChild(), false), String.valueOf(numArgs), String.valueOf(minArgs), maxArgs != Integer.MAX_VALUE ? " and no more than " + maxArgs + " argument(s)" : ""); [EOL]     } [EOL] } <line_num>: 1741,1775
private void visitReturn(NodeTraversal t, Node n) { [EOL]     JSType jsType = getJSType(t.getEnclosingFunction()); [EOL]     if (jsType.isFunctionType()) { [EOL]         FunctionType functionType = jsType.toMaybeFunctionType(); [EOL]         JSType returnType = functionType.getReturnType(); [EOL]         if (returnType == null) { [EOL]             returnType = getNativeType(VOID_TYPE); [EOL]         } [EOL]         Node valueNode = n.getFirstChild(); [EOL]         JSType actualReturnType; [EOL]         if (valueNode == null) { [EOL]             actualReturnType = getNativeType(VOID_TYPE); [EOL]             valueNode = n; [EOL]         } else { [EOL]             actualReturnType = getJSType(valueNode); [EOL]         } [EOL]         validator.expectCanAssignTo(t, valueNode, actualReturnType, returnType, "inconsistent return type"); [EOL]     } [EOL] } <line_num>: 1784,1812
private void visitBinaryOperator(int op, NodeTraversal t, Node n) { [EOL]     Node left = n.getFirstChild(); [EOL]     JSType leftType = getJSType(left); [EOL]     Node right = n.getLastChild(); [EOL]     JSType rightType = getJSType(right); [EOL]     switch(op) { [EOL]         case Token.ASSIGN_LSH: [EOL]         case Token.ASSIGN_RSH: [EOL]         case Token.LSH: [EOL]         case Token.RSH: [EOL]         case Token.ASSIGN_URSH: [EOL]         case Token.URSH: [EOL]             if (!leftType.matchesInt32Context()) { [EOL]                 report(t, left, BIT_OPERATION, NodeUtil.opToStr(n.getType()), leftType.toString()); [EOL]             } [EOL]             if (!rightType.matchesUint32Context()) { [EOL]                 report(t, right, BIT_OPERATION, NodeUtil.opToStr(n.getType()), rightType.toString()); [EOL]             } [EOL]             break; [EOL]         case Token.ASSIGN_DIV: [EOL]         case Token.ASSIGN_MOD: [EOL]         case Token.ASSIGN_MUL: [EOL]         case Token.ASSIGN_SUB: [EOL]         case Token.DIV: [EOL]         case Token.MOD: [EOL]         case Token.MUL: [EOL]         case Token.SUB: [EOL]             validator.expectNumber(t, left, leftType, "left operand"); [EOL]             validator.expectNumber(t, right, rightType, "right operand"); [EOL]             break; [EOL]         case Token.ASSIGN_BITAND: [EOL]         case Token.ASSIGN_BITXOR: [EOL]         case Token.ASSIGN_BITOR: [EOL]         case Token.BITAND: [EOL]         case Token.BITXOR: [EOL]         case Token.BITOR: [EOL]             validator.expectBitwiseable(t, left, leftType, "bad left operand to bitwise operator"); [EOL]             validator.expectBitwiseable(t, right, rightType, "bad right operand to bitwise operator"); [EOL]             break; [EOL]         case Token.ASSIGN_ADD: [EOL]         case Token.ADD: [EOL]             break; [EOL]         default: [EOL]             report(t, n, UNEXPECTED_TOKEN, Token.name(op)); [EOL]     } [EOL]     ensureTyped(t, n); [EOL] } <line_num>: 1824,1878
private void checkEnumAlias(NodeTraversal t, JSDocInfo declInfo, Node value) { [EOL]     if (declInfo == null || !declInfo.hasEnumParameterType()) { [EOL]         return; [EOL]     } [EOL]     JSType valueType = getJSType(value); [EOL]     if (!valueType.isEnumType()) { [EOL]         return; [EOL]     } [EOL]     EnumType valueEnumType = valueType.toMaybeEnumType(); [EOL]     JSType valueEnumPrimitiveType = valueEnumType.getElementsType().getPrimitiveType(); [EOL]     validator.expectCanAssignTo(t, value, valueEnumPrimitiveType, declInfo.getEnumParameterType().evaluate(t.getScope(), typeRegistry), "incompatible enum element types"); [EOL] } <line_num>: 1895,1912
private JSType getJSType(Node n) { [EOL]     JSType jsType = n.getJSType(); [EOL]     if (jsType == null) { [EOL]         return getNativeType(UNKNOWN_TYPE); [EOL]     } else { [EOL]         return jsType; [EOL]     } [EOL] } <line_num>: 1918,1929
private void ensureTyped(NodeTraversal t, Node n) { [EOL]     ensureTyped(t, n, getNativeType(UNKNOWN_TYPE)); [EOL] } <line_num>: 1941,1943
private void ensureTyped(NodeTraversal t, Node n, JSTypeNative type) { [EOL]     ensureTyped(t, n, getNativeType(type)); [EOL] } <line_num>: 1945,1947
private void ensureTyped(NodeTraversal t, Node n, JSType type) { [EOL]     Preconditions.checkState(!n.isFunction() || type.isFunctionType() || type.isUnknownType()); [EOL]     JSDocInfo info = n.getJSDocInfo(); [EOL]     if (info != null) { [EOL]         if (info.hasType()) { [EOL]             JSType infoType = info.getType().evaluate(t.getScope(), typeRegistry); [EOL]             validator.expectCanCast(t, n, infoType, type); [EOL]             type = infoType; [EOL]         } [EOL]         if (info.isImplicitCast() && !inExterns) { [EOL]             String propName = n.isGetProp() ? n.getLastChild().getString() : "(missing)"; [EOL]             compiler.report(t.makeError(n, ILLEGAL_IMPLICIT_CAST, propName)); [EOL]         } [EOL]     } [EOL]     if (n.getJSType() == null) { [EOL]         n.setJSType(type); [EOL]     } [EOL] } <line_num>: 1967,1995
double getTypedPercent() { [EOL]     int total = nullCount + unknownCount + typedCount; [EOL]     return (total == 0) ? 0.0 : (100.0 * typedCount) / total; [EOL] } <line_num>: 2001,2004
private JSType getNativeType(JSTypeNative typeId) { [EOL]     return typeRegistry.getNativeType(typeId); [EOL] } <line_num>: 2006,2008
