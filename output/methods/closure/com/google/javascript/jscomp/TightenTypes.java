TightenTypes(AbstractCompiler compiler) { [EOL]     this.compiler = compiler; [EOL] } <line_num>: 115,117
ConcreteScope(ConcreteScope parent) { [EOL]     this.parent = parent; [EOL]     this.slots = Maps.newHashMap(); [EOL]     this.actions = Lists.newArrayList(); [EOL] } <line_num>: 181,185
ConcreteSlot(ConcreteScope scope, String name) { [EOL]     this.scope = scope; [EOL]     this.name = name; [EOL]     this.type = ConcreteType.NONE; [EOL] } <line_num>: 269,273
Assignment(ConcreteSlot slot, ConcreteType type) { [EOL]     this.slot = slot; [EOL]     this.type = type; [EOL]     Preconditions.checkNotNull(slot); [EOL]     Preconditions.checkNotNull(type); [EOL] } <line_num>: 327,333
VariableAssignAction(ConcreteSlot slot, Node expr) { [EOL]     this.slot = slot; [EOL]     this.expression = expr; [EOL]     Preconditions.checkNotNull(slot); [EOL]     Preconditions.checkNotNull(expr); [EOL] } <line_num>: 341,347
PropertyAssignAction(Node receiver, Node expr) { [EOL]     this.receiver = receiver; [EOL]     this.propName = receiver.getNext().getString(); [EOL]     this.expression = expr; [EOL]     Preconditions.checkNotNull(receiver); [EOL]     Preconditions.checkNotNull(propName); [EOL]     Preconditions.checkNotNull(expr); [EOL] } <line_num>: 362,370
FunctionCallBuilder(Node receiver, Node firstArgument) { [EOL]     this.receiver = receiver; [EOL]     this.firstArgument = firstArgument; [EOL] } <line_num>: 400,403
ExternFunctionCall(Node receiver, ConcreteType thisType, List<ConcreteType> argTypes) { [EOL]     this.receiver = receiver; [EOL]     this.thisType = thisType; [EOL]     this.argTypes = argTypes; [EOL] } <line_num>: 472,477
FunctionCall(boolean isNewCall, Node receiver, String propName, Node firstArgument) { [EOL]     this.isNewCall = isNewCall; [EOL]     this.receiver = receiver; [EOL]     this.propName = propName; [EOL]     this.firstArgument = firstArgument; [EOL]     Preconditions.checkNotNull(receiver); [EOL] } <line_num>: 497,505
NativeCallFunctionCall(Node receiver, String propName, Node firstArgument) { [EOL]     this.receiver = receiver; [EOL]     this.propName = propName; [EOL]     this.firstArgument = firstArgument; [EOL]     Preconditions.checkNotNull(receiver); [EOL] } <line_num>: 556,562
CreateScope(ConcreteScope scope, boolean inExterns) { [EOL]     this.scope = scope; [EOL]     this.inExterns = inExterns; [EOL] } <line_num>: 591,594
ConcreteJSTypePair(ConcreteType concrete, JSType jstype) { [EOL]     this.concrete = concrete; [EOL]     this.jstype = jstype; [EOL]     this.hashcode = concrete.hashCode() + getJSTypeHashCode(); [EOL] } <line_num>: 1379,1383
ConcreteScope getTopScope() { [EOL]     return topScope; [EOL] } <line_num>: 120,120
@Override [EOL] public JSTypeRegistry getTypeRegistry() { [EOL]     return compiler.getTypeRegistry(); [EOL] } <line_num>: 123,124
@Override [EOL] public void process(Node externRoot, Node jsRoot) { [EOL]     topScope = new ConcreteScope(null); [EOL]     topScope.initForExternRoot(externRoot); [EOL]     topScope.initForScopeRoot(jsRoot); [EOL]     long maxIterations = 1000; [EOL]     long iterations = 0; [EOL]     Set<ConcreteScope> workSet = Sets.newHashSet(topScope); [EOL]     List<ConcreteScope> workList = Lists.newArrayList(topScope); [EOL]     boolean changed; [EOL]     do { [EOL]         changed = false; [EOL]         for (int i = 0; i < workList.size(); ++i) { [EOL]             ConcreteScope scope = workList.get(i); [EOL]             for (Action action : scope.getActions()) { [EOL]                 for (Assignment assign : action.getAssignments(scope)) { [EOL]                     if (assign.slot.addConcreteType(assign.type)) { [EOL]                         changed = true; [EOL]                         ConcreteScope varScope = assign.slot.getScope(); [EOL]                         if ((varScope != scope) && !workSet.contains(varScope)) { [EOL]                             workSet.add(varScope); [EOL]                             workList.add(varScope); [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         Preconditions.checkState(++iterations != maxIterations, NON_HALTING_ERROR_MSG); [EOL]     } while (changed); [EOL] } <line_num>: 129,169
@Override [EOL] public Node getRootNode() { [EOL]     return null; [EOL] } <line_num>: 187,188
@Override [EOL] public StaticScope<ConcreteType> getParentScope() { [EOL]     return parent; [EOL] } <line_num>: 190,191
@Override [EOL] public StaticSlot<ConcreteType> getOwnSlot(String name) { [EOL]     return slots.get(name); [EOL] } <line_num>: 193,196
@Override [EOL] public StaticSlot<ConcreteType> getSlot(String name) { [EOL]     StaticSlot<ConcreteType> var = getOwnSlot(name); [EOL]     if (var != null) { [EOL]         return var; [EOL]     } else if (parent != null) { [EOL]         return parent.getSlot(name); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] } <line_num>: 198,208
Collection<ConcreteSlot> getSlots() { [EOL]     return slots.values(); [EOL] } <line_num>: 211,211
@Override [EOL] public ConcreteType getTypeOfThis() { [EOL]     ConcreteSlot thisVar = slots.get(ConcreteFunctionType.THIS_SLOT_NAME); [EOL]     return (thisVar != null) ? thisVar.getType() : ConcreteType.NONE; [EOL] } <line_num>: 213,219
void declareSlot(String name, Node declaration) { [EOL]     slots.put(name, new ConcreteSlot(this, name)); [EOL] } <line_num>: 222,224
void declareSlot(String name, Node declaration, ConcreteType type) { [EOL]     ConcreteSlot var = new ConcreteSlot(this, name); [EOL]     var.addConcreteType(type); [EOL]     slots.put(name, var); [EOL] } <line_num>: 227,231
List<Action> getActions() { [EOL]     return actions; [EOL] } <line_num>: 234,234
void initForScopeRoot(Node decl) { [EOL]     Preconditions.checkNotNull(decl); [EOL]     if (decl.isFunction()) { [EOL]         decl = decl.getLastChild(); [EOL]     } [EOL]     Preconditions.checkArgument(decl.isBlock()); [EOL]     NodeTraversal.traverse(compiler, decl, new CreateScope(this, false)); [EOL] } <line_num>: 237,245
void initForExternRoot(Node decl) { [EOL]     Preconditions.checkNotNull(decl); [EOL]     Preconditions.checkArgument(decl.isBlock()); [EOL]     NodeTraversal.traverse(compiler, decl, new CreateScope(this, true)); [EOL] } <line_num>: 248,253
void addAction(Action action) { [EOL]     actions.add(action); [EOL] } <line_num>: 256,256
@Override [EOL] public String toString() { [EOL]     return getTypeOfThis().toString() + " " + getSlots(); [EOL] } <line_num>: 258,260
ConcreteScope getScope() { [EOL]     return scope; [EOL] } <line_num>: 276,276
@Override [EOL] public String getName() { [EOL]     return name; [EOL] } <line_num>: 279,279
@Override [EOL] public ConcreteType getType() { [EOL]     return type; [EOL] } <line_num>: 281,281
@Override [EOL] public boolean isTypeInferred() { [EOL]     return true; [EOL] } <line_num>: 284,284
@Override [EOL] public StaticReference<ConcreteType> getDeclaration() { [EOL]     return null; [EOL] } <line_num>: 286,288
@Override [EOL] public JSDocInfo getJSDocInfo() { [EOL]     return null; [EOL] } <line_num>: 290,292
boolean addConcreteType(ConcreteType type) { [EOL]     ConcreteType origType = this.type; [EOL]     this.type = origType.unionWith(type); [EOL]     return !this.type.equals(origType); [EOL] } <line_num>: 298,302
@Override [EOL] public String toString() { [EOL]     return getName() + ": " + getType(); [EOL] } <line_num>: 304,306
Collection<Assignment> getAssignments(ConcreteScope scope); <line_num>: 319,319
@Override [EOL] public Collection<Assignment> getAssignments(ConcreteScope scope) { [EOL]     return Lists.newArrayList(new Assignment(slot, inferConcreteType(scope, expression))); [EOL] } <line_num>: 349,353
@Override [EOL] public Collection<Assignment> getAssignments(ConcreteScope scope) { [EOL]     ConcreteType recvType = inferConcreteType(scope, receiver); [EOL]     ConcreteType exprType = inferConcreteType(scope, expression); [EOL]     List<Assignment> assigns = Lists.newArrayList(); [EOL]     for (StaticSlot<ConcreteType> prop : recvType.getPropertySlots(propName)) { [EOL]         assigns.add(new Assignment((ConcreteSlot) prop, exprType)); [EOL]     } [EOL]     return assigns; [EOL] } <line_num>: 378,389
FunctionCallBuilder setPropName(String propName) { [EOL]     this.propName = propName; [EOL]     return this; [EOL] } <line_num>: 405,408
FunctionCallBuilder setIsNewCall(boolean isNew) { [EOL]     Preconditions.checkState(!(isCallFunction && isNew), "A function call cannot be of the form: new Object.call()"); [EOL]     isNewCall = isNew; [EOL]     return this; [EOL] } <line_num>: 411,417
FunctionCallBuilder setIsCallFunction() { [EOL]     Preconditions.checkState(!isNewCall, "A function call cannot be of the form: new Object.call()"); [EOL]     isCallFunction = true; [EOL]     return this; [EOL] } <line_num>: 423,429
Action build() { [EOL]     if (isCallFunction) { [EOL]         return new NativeCallFunctionCall(receiver, propName, firstArgument); [EOL]     } else { [EOL]         return new FunctionCall(isNewCall, receiver, propName, firstArgument); [EOL]     } [EOL] } <line_num>: 431,437
private List<Assignment> getFunctionCallAssignments(ConcreteType recvType, ConcreteType thisType, List<ConcreteType> argTypes) { [EOL]     List<Assignment> assigns = Lists.newArrayList(); [EOL]     for (ConcreteFunctionType fType : recvType.getFunctions()) { [EOL]         assigns.add(new Assignment((ConcreteSlot) fType.getCallSlot(), fType)); [EOL]         assigns.add(new Assignment((ConcreteSlot) fType.getThisSlot(), thisType)); [EOL]         for (int i = 0; i < argTypes.size(); ++i) { [EOL]             ConcreteSlot variable = (ConcreteSlot) fType.getParameterSlot(i); [EOL]             if (variable != null) { [EOL]                 assigns.add(new Assignment(variable, argTypes.get(i))); [EOL]             } [EOL]         } [EOL]     } [EOL]     return assigns; [EOL] } <line_num>: 444,460
@Override [EOL] public Collection<Assignment> getAssignments(ConcreteScope scope) { [EOL]     return getFunctionCallAssignments(inferConcreteType(scope, receiver), thisType, argTypes); [EOL] } <line_num>: 479,483
@Override [EOL] public Collection<Assignment> getAssignments(ConcreteScope scope) { [EOL]     ConcreteType thisType = ConcreteType.NONE; [EOL]     ConcreteType recvType = inferConcreteType(scope, receiver); [EOL]     if (propName != null) { [EOL]         thisType = recvType; [EOL]         recvType = thisType.getPropertyType(propName); [EOL]     } [EOL]     if (recvType.isAll()) { [EOL]         throw new AssertionError("Found call on all type, which makes tighten types useless."); [EOL]     } [EOL]     if (isNewCall) { [EOL]         thisType = ConcreteType.NONE; [EOL]         for (ConcreteInstanceType instType : recvType.getFunctionInstanceTypes()) { [EOL]             thisType = thisType.unionWith(instType); [EOL]         } [EOL]         boolean added = allInstantiatedTypes.add(thisType); [EOL]         if (added) { [EOL]             typeIntersectionMemos.clear(); [EOL]         } [EOL]     } [EOL]     List<ConcreteType> argTypes = Lists.newArrayList(); [EOL]     for (Node arg = firstArgument; arg != null; arg = arg.getNext()) { [EOL]         argTypes.add(inferConcreteType(scope, arg)); [EOL]     } [EOL]     return getFunctionCallAssignments(recvType, thisType, argTypes); [EOL] } <line_num>: 507,547
@Override [EOL] public Collection<Assignment> getAssignments(ConcreteScope scope) { [EOL]     ConcreteType thisType = (firstArgument != null) ? inferConcreteType(scope, firstArgument) : getTopScope().getTypeOfThis(); [EOL]     ConcreteType recvType = inferConcreteType(scope, receiver); [EOL]     if (recvType instanceof ConcreteInstanceType && ((ConcreteInstanceType) recvType).isFunctionPrototype()) { [EOL]         recvType = thisType.getPropertyType(propName); [EOL]     } [EOL]     List<ConcreteType> argTypes = Lists.newArrayList(); [EOL]     for (Node arg = firstArgument.getNext(); arg != null; arg = arg.getNext()) { [EOL]         argTypes.add(inferConcreteType(scope, arg)); [EOL]     } [EOL]     return getFunctionCallAssignments(recvType, thisType, argTypes); [EOL] } <line_num>: 564,583
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     switch(n.getType()) { [EOL]         case Token.VAR: [EOL]             Node name; [EOL]             for (name = n.getFirstChild(); name != null; name = name.getNext()) { [EOL]                 if (inExterns) { [EOL]                     scope.declareSlot(name.getString(), n, createType(name, scope)); [EOL]                 } else { [EOL]                     scope.declareSlot(name.getString(), n); [EOL]                     if (name.getFirstChild() != null) { [EOL]                         addActions(createAssignmentActions(name, name.getFirstChild(), n)); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Token.GETPROP: [EOL]             if (inExterns) { [EOL]                 ConcreteType type = inferConcreteType(getTopScope(), n); [EOL]                 if (type.isNone()) { [EOL]                     ConcreteScope scope = (ConcreteScope) inferConcreteType(getTopScope(), n.getFirstChild()).getScope(); [EOL]                     if (scope != null) { [EOL]                         type = createType(n.getJSType()); [EOL]                         if (type.isNone() || type.isAll()) { [EOL]                             break; [EOL]                         } [EOL]                         type = createUnionWithSubTypes(type); [EOL]                         Node nameNode = n.getLastChild(); [EOL]                         scope.declareSlot(nameNode.getString(), n, type); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Token.FUNCTION: [EOL]             if (NodeUtil.isFunctionDeclaration(n)) { [EOL]                 if (!n.getJSType().isNoObjectType()) { [EOL]                     ConcreteFunctionType type = createConcreteFunction(n, scope); [EOL]                     scope.declareSlot(n.getFirstChild().getString(), n, type); [EOL]                     if (inExterns && type.getInstanceType() != null) { [EOL]                         allInstantiatedTypes.add(type.getInstanceType()); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Token.ASSIGN: [EOL]             Node lhs = n.getFirstChild(); [EOL]             if (inExterns) { [EOL]                 ConcreteScope scope; [EOL]                 if (lhs.isGetProp()) { [EOL]                     ConcreteType type = inferConcreteType(getTopScope(), lhs.getFirstChild()); [EOL]                     scope = (ConcreteScope) type.getScope(); [EOL]                 } else { [EOL]                     scope = getTopScope(); [EOL]                 } [EOL]                 if (scope == null) [EOL]                     break; [EOL]                 ConcreteType type = inferConcreteType(getTopScope(), n); [EOL]                 if (type.isNone() || type.isAll()) { [EOL]                     break; [EOL]                 } [EOL]                 if (type.isFunction()) { [EOL]                     JSType lhsType = lhs.getJSType(); [EOL]                     if (lhsType == null) { [EOL]                         break; [EOL]                     } [EOL]                     FunctionType funType = lhsType.restrictByNotNullOrUndefined().toMaybeFunctionType(); [EOL]                     if (funType == null) { [EOL]                         break; [EOL]                     } [EOL]                     ConcreteType retType = createType(funType.getReturnType()); [EOL]                     retType = createUnionWithSubTypes(retType); [EOL]                     ConcreteType newret = type.toFunction().getReturnSlot().getType().unionWith(retType); [EOL]                     ((ConcreteScope) type.getScope()).declareSlot(ConcreteFunctionType.RETURN_SLOT_NAME, n, newret); [EOL]                 } [EOL]                 scope.declareSlot(lhs.getLastChild().getString(), n, type); [EOL]             } else { [EOL]                 addActions(createAssignmentActions(lhs, n.getLastChild(), n)); [EOL]             } [EOL]             break; [EOL]         case Token.NEW: [EOL]         case Token.CALL: [EOL]             Node receiver = n.getFirstChild(); [EOL]             if (receiver.isGetProp()) { [EOL]                 Node first = receiver.getFirstChild(); [EOL]                 if ("call".equals(first.getNext().getString())) { [EOL]                     if (first.isGetProp()) { [EOL]                         addAction(new FunctionCallBuilder(first, receiver.getNext()).setPropName(first.getFirstChild().getNext().getString()).setIsCallFunction().build()); [EOL]                     } else { [EOL]                         addAction(new FunctionCallBuilder(first, receiver.getNext()).setIsCallFunction().build()); [EOL]                     } [EOL]                 } else { [EOL]                     addAction(new FunctionCallBuilder(first, receiver.getNext()).setPropName(first.getNext().getString()).build()); [EOL]                 } [EOL]             } else { [EOL]                 addAction(new FunctionCallBuilder(receiver, receiver.getNext()).setIsNewCall(n.isNew()).build()); [EOL]             } [EOL]             break; [EOL]         case Token.NAME: [EOL]             if (parent.isCatch() && parent.getFirstChild() == n) { [EOL]                 scope.declareSlot(n.getString(), n, createUnionWithSubTypes(createType(getTypeRegistry().getType("Error")).toInstance())); [EOL]             } [EOL]             break; [EOL]         case Token.RETURN: [EOL]             if (n.getFirstChild() != null) { [EOL]                 addAction(new VariableAssignAction((ConcreteSlot) scope.getOwnSlot(ConcreteFunctionType.RETURN_SLOT_NAME), n.getFirstChild())); [EOL]             } [EOL]             break; [EOL]     } [EOL]     Collection<Action> actions = getImplicitActions(n); [EOL]     if (actions != null) { [EOL]         for (Action action : actions) { [EOL]             addAction(action); [EOL]         } [EOL]     } [EOL] } <line_num>: 597,762
private void addAction(Action action) { [EOL]     Preconditions.checkState(!inExterns, "Unexpected action in externs."); [EOL]     scope.addAction(action); [EOL] } <line_num>: 765,768
private void addActions(List<Action> actions) { [EOL]     Preconditions.checkState(!inExterns, "Unexpected action in externs."); [EOL]     for (Action action : actions) { [EOL]         scope.addAction(action); [EOL]     } [EOL] } <line_num>: 771,776
private List<Action> createAssignmentActions(Node lhs, Node rhs, Node parent) { [EOL]     switch(lhs.getType()) { [EOL]         case Token.NAME: [EOL]             ConcreteSlot var = (ConcreteSlot) scope.getSlot(lhs.getString()); [EOL]             Preconditions.checkState(var != null, "Type tightener could not find variable with name %s", lhs.getString()); [EOL]             return Lists.<Action>newArrayList(new VariableAssignAction(var, rhs)); [EOL]         case Token.GETPROP: [EOL]             Node receiver = lhs.getFirstChild(); [EOL]             return Lists.<Action>newArrayList(new PropertyAssignAction(receiver, rhs)); [EOL]         case Token.GETELEM: [EOL]             return Lists.newArrayList(); [EOL]         default: [EOL]             throw new AssertionError("Bad LHS for assignment: " + parent.toStringTree()); [EOL]     } [EOL] } <line_num>: 782,805
private ExternFunctionCall createExternFunctionCall(Node receiver, JSType jsThisType, FunctionType fun) { [EOL]     List<ConcreteType> argTypes = Lists.newArrayList(); [EOL]     ConcreteType thisType; [EOL]     if (fun != null) { [EOL]         thisType = createType(jsThisType); [EOL]         for (Node arg : fun.getParameters()) { [EOL]             argTypes.add(createType(arg, scope)); [EOL]         } [EOL]     } else { [EOL]         thisType = ConcreteType.NONE; [EOL]     } [EOL]     return new ExternFunctionCall(receiver, thisType, argTypes); [EOL] } <line_num>: 807,820
private JSType getJSType(Node n) { [EOL]     if (n.getJSType() != null) { [EOL]         return n.getJSType(); [EOL]     } else { [EOL]         return getTypeRegistry().getNativeType(UNKNOWN_TYPE); [EOL]     } [EOL] } <line_num>: 822,828
private Collection<Action> getImplicitActions(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.CALL: [EOL]             Node receiver = n.getFirstChild(); [EOL]             if (!inExterns && receiver.isGetProp()) { [EOL]                 return getImplicitActionsFromCall(n, receiver.getJSType()); [EOL]             } [EOL]             break; [EOL]         case Token.ASSIGN: [EOL]             Node lhs = n.getFirstChild(); [EOL]             if (!inExterns && lhs.isGetProp()) { [EOL]                 return getImplicitActionsFromProp(lhs.getFirstChild().getJSType(), lhs.getLastChild().getString(), n.getLastChild()); [EOL]             } [EOL]             break; [EOL]     } [EOL]     return null; [EOL] } <line_num>: 834,859
private Collection<Action> getImplicitActionsFromCall(Node n, JSType recvType) { [EOL]     Node receiver = n.getFirstChild(); [EOL]     if (recvType.isUnionType()) { [EOL]         List<Action> actions = Lists.newArrayList(); [EOL]         for (JSType alt : recvType.toMaybeUnionType().getAlternates()) { [EOL]             actions.addAll(getImplicitActionsFromCall(n, alt)); [EOL]         } [EOL]         return actions; [EOL]     } else if (!(recvType.isFunctionType())) { [EOL]         return Lists.<Action>newArrayList(); [EOL]     } [EOL]     ObjectType objType = ObjectType.cast(getJSType(receiver.getFirstChild()).restrictByNotNullOrUndefined()); [EOL]     String prop = receiver.getLastChild().getString(); [EOL]     if (objType != null && (objType.isPropertyInExterns(prop)) && (recvType.toMaybeFunctionType()).getParameters() != null) { [EOL]         List<Action> actions = Lists.newArrayList(); [EOL]         Iterator<Node> paramIter = (recvType.toMaybeFunctionType()).getParameters().iterator(); [EOL]         Iterator<Node> argumentIter = n.children().iterator(); [EOL]         argumentIter.next(); [EOL]         while (paramIter.hasNext() && argumentIter.hasNext()) { [EOL]             Node arg = argumentIter.next(); [EOL]             Node param = paramIter.next(); [EOL]             if (arg.getJSType() != null && arg.getJSType().isFunctionType()) { [EOL]                 actions.addAll(getImplicitActionsFromArgument(arg, arg.getJSType().toMaybeFunctionType().getTypeOfThis().toObjectType(), param.getJSType())); [EOL]             } [EOL]         } [EOL]         return actions; [EOL]     } [EOL]     return Lists.<Action>newArrayList(); [EOL] } <line_num>: 861,902
private Collection<Action> getImplicitActionsFromArgument(Node arg, ObjectType thisType, JSType paramType) { [EOL]     if (paramType.isUnionType()) { [EOL]         List<Action> actions = Lists.newArrayList(); [EOL]         for (JSType paramAlt : paramType.toMaybeUnionType().getAlternates()) { [EOL]             actions.addAll(getImplicitActionsFromArgument(arg, thisType, paramAlt)); [EOL]         } [EOL]         return actions; [EOL]     } else if (paramType.isFunctionType()) { [EOL]         return Lists.<Action>newArrayList(createExternFunctionCall(arg, thisType, paramType.toMaybeFunctionType())); [EOL]     } else { [EOL]         return Lists.<Action>newArrayList(createExternFunctionCall(arg, thisType, null)); [EOL]     } [EOL] } <line_num>: 904,920
private Collection<Action> getImplicitActionsFromProp(JSType jsType, String prop, Node fnNode) { [EOL]     List<Action> actions = Lists.newArrayList(); [EOL]     if (jsType.isUnionType()) { [EOL]         boolean found = false; [EOL]         for (JSType alt : jsType.toMaybeUnionType().getAlternates()) { [EOL]             ObjectType altObj = ObjectType.cast(alt); [EOL]             if (altObj != null) { [EOL]                 actions.addAll(getImplicitActionsFromPropNonUnion(altObj, prop, fnNode)); [EOL]                 if (altObj.hasProperty(prop)) { [EOL]                     found = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (found) { [EOL]             return actions; [EOL]         } [EOL]     } else { [EOL]         ObjectType objType = ObjectType.cast(jsType); [EOL]         if (objType != null && !objType.isUnknownType() && objType.hasProperty(prop)) { [EOL]             return getImplicitActionsFromPropNonUnion(objType, prop, fnNode); [EOL]         } [EOL]     } [EOL]     for (ObjectType type : getTypeRegistry().getEachReferenceTypeWithProperty(prop)) { [EOL]         actions.addAll(getImplicitActionsFromPropNonUnion(type, prop, fnNode)); [EOL]     } [EOL]     return actions; [EOL] } <line_num>: 922,957
private Collection<Action> getImplicitActionsFromPropNonUnion(ObjectType jsType, String prop, Node fnNode) { [EOL]     JSType propType = jsType.getPropertyType(prop).restrictByNotNullOrUndefined(); [EOL]     if (jsType.isPropertyInExterns(prop) && propType.isFunctionType()) { [EOL]         ObjectType thisType = jsType; [EOL]         if (jsType.isFunctionPrototypeType()) { [EOL]             thisType = thisType.getOwnerFunction().getInstanceType(); [EOL]         } [EOL]         FunctionType callType = propType.toMaybeFunctionType(); [EOL]         Action action = createExternFunctionCall(fnNode, thisType, callType); [EOL]         return Lists.<Action>newArrayList(action); [EOL]     } [EOL]     return Lists.<Action>newArrayList(); [EOL] } <line_num>: 959,974
private ConcreteType createType(Node name, ConcreteScope scope) { [EOL]     Preconditions.checkNotNull(name); [EOL]     Preconditions.checkArgument(name.isName()); [EOL]     if (name.getJSType() == null) { [EOL]         return ConcreteType.ALL; [EOL]     } [EOL]     if ((name.getFirstChild() != null) && (name.getFirstChild().isFunction())) { [EOL]         return createConcreteFunction(name.getFirstChild(), scope); [EOL]     } [EOL]     return createType(name.getJSType()); [EOL] } <line_num>: 978,992
private ConcreteType createType(JSType jsType) { [EOL]     if (jsType.isUnknownType() || jsType.isEmptyType()) { [EOL]         return ConcreteType.ALL; [EOL]     } [EOL]     if (jsType.isUnionType()) { [EOL]         ConcreteType type = ConcreteType.NONE; [EOL]         for (JSType alt : jsType.toMaybeUnionType().getAlternates()) { [EOL]             type = type.unionWith(createType(alt)); [EOL]         } [EOL]         return type; [EOL]     } [EOL]     if (jsType.isFunctionType()) { [EOL]         if (getConcreteFunction(jsType.toMaybeFunctionType()) != null) { [EOL]             return getConcreteFunction(jsType.toMaybeFunctionType()); [EOL]         } [EOL]         return ConcreteType.ALL; [EOL]     } [EOL]     if (jsType.isObject()) { [EOL]         return createConcreteInstance(jsType.toObjectType()); [EOL]     } [EOL]     return ConcreteType.NONE; [EOL] } <line_num>: 995,1021
private ConcreteType createTypeWithSubTypes(JSType jsType) { [EOL]     ConcreteType ret = ConcreteType.NONE; [EOL]     if (jsType.isUnionType()) { [EOL]         for (JSType alt : jsType.toMaybeUnionType().getAlternates()) { [EOL]             ret = ret.unionWith(createTypeWithSubTypes(alt)); [EOL]         } [EOL]     } else { [EOL]         ObjectType instType = ObjectType.cast(jsType); [EOL]         if (instType != null && instType.getConstructor() != null && instType.getConstructor().isInterface()) { [EOL]             Collection<FunctionType> implementors = getTypeRegistry().getDirectImplementors(instType); [EOL]             for (FunctionType implementor : implementors) { [EOL]                 ret = ret.unionWith(createTypeWithSubTypes(implementor.getInstanceType())); [EOL]             } [EOL]         } else { [EOL]             ret = ret.unionWith(createUnionWithSubTypes(createType(jsType))); [EOL]         } [EOL]     } [EOL]     return ret; [EOL] } <line_num>: 1027,1050
ConcreteType inferConcreteType(ConcreteScope scope, Node expr) { [EOL]     Preconditions.checkNotNull(scope); [EOL]     Preconditions.checkNotNull(expr); [EOL]     ConcreteType ret; [EOL]     switch(expr.getType()) { [EOL]         case Token.NAME: [EOL]             StaticSlot<ConcreteType> slot = scope.getSlot(expr.getString()); [EOL]             if (slot != null) { [EOL]                 ret = slot.getType(); [EOL]             } else { [EOL]                 ret = ConcreteType.ALL; [EOL]             } [EOL]             break; [EOL]         case Token.THIS: [EOL]             ret = scope.getTypeOfThis(); [EOL]             break; [EOL]         case Token.ASSIGN: [EOL]             ret = inferConcreteType(scope, expr.getLastChild()); [EOL]             break; [EOL]         case Token.COMMA: [EOL]             ret = inferConcreteType(scope, expr.getLastChild()); [EOL]             break; [EOL]         case Token.AND: [EOL]             ret = inferConcreteType(scope, expr.getLastChild()); [EOL]             break; [EOL]         case Token.OR: [EOL]             ret = inferConcreteType(scope, expr.getFirstChild()).unionWith(inferConcreteType(scope, expr.getLastChild())); [EOL]             break; [EOL]         case Token.HOOK: [EOL]             ret = inferConcreteType(scope, expr.getFirstChild().getNext()).unionWith(inferConcreteType(scope, expr.getLastChild())); [EOL]             break; [EOL]         case Token.GETPROP: [EOL]             ConcreteType recvType = inferConcreteType(scope, expr.getFirstChild()); [EOL]             if (recvType.isAll()) { [EOL]                 ret = recvType; [EOL]                 break; [EOL]             } [EOL]             Node prop = expr.getLastChild(); [EOL]             String propName = prop.getString(); [EOL]             ConcreteType type = recvType.getPropertyType(propName); [EOL]             if ("prototype".equals(propName)) { [EOL]                 for (ConcreteFunctionType funType : recvType.getFunctions()) { [EOL]                     type = type.unionWith(funType.getPrototypeType()); [EOL]                 } [EOL]             } else if (compiler.getCodingConvention().isSuperClassReference(propName)) { [EOL]                 for (ConcreteFunctionType superType : recvType.getSuperclassTypes()) { [EOL]                     type = type.unionWith(superType.getPrototypeType()); [EOL]                 } [EOL]             } else if ("call".equals(propName)) { [EOL]                 type = recvType; [EOL]             } [EOL]             ret = type; [EOL]             break; [EOL]         case Token.GETELEM: [EOL]             ret = ConcreteType.ALL; [EOL]             break; [EOL]         case Token.CALL: [EOL]             ConcreteType targetType = inferConcreteType(scope, expr.getFirstChild()); [EOL]             if (targetType.isAll()) { [EOL]                 ret = targetType; [EOL]                 break; [EOL]             } [EOL]             ret = ConcreteType.NONE; [EOL]             for (ConcreteFunctionType funType : targetType.getFunctions()) { [EOL]                 ret = ret.unionWith(funType.getReturnSlot().getType()); [EOL]             } [EOL]             break; [EOL]         case Token.NEW: [EOL]             ConcreteType constructorType = inferConcreteType(scope, expr.getFirstChild()); [EOL]             if (constructorType.isAll()) { [EOL]                 throw new AssertionError("Attempted new call on all type!"); [EOL]             } [EOL]             ret = ConcreteType.NONE; [EOL]             for (ConcreteInstanceType instType : constructorType.getFunctionInstanceTypes()) { [EOL]                 ret = ret.unionWith(instType); [EOL]             } [EOL]             allInstantiatedTypes.add(ret); [EOL]             break; [EOL]         case Token.FUNCTION: [EOL]             ret = createConcreteFunction(expr, scope); [EOL]             break; [EOL]         case Token.OBJECTLIT: [EOL]             if ((expr.getJSType() != null) && !expr.getJSType().isUnknownType()) { [EOL]                 JSType exprType = expr.getJSType().restrictByNotNullOrUndefined(); [EOL]                 ConcreteType inst = createConcreteInstance(exprType.toObjectType()); [EOL]                 allInstantiatedTypes.add(inst); [EOL]                 ret = inst; [EOL]             } else { [EOL]                 ret = ConcreteType.ALL; [EOL]             } [EOL]             break; [EOL]         case Token.ARRAYLIT: [EOL]             ObjectType arrayType = (ObjectType) getTypeRegistry().getNativeType(JSTypeNative.ARRAY_TYPE); [EOL]             ConcreteInstanceType inst = createConcreteInstance(arrayType); [EOL]             allInstantiatedTypes.add(inst); [EOL]             ret = inst; [EOL]             break; [EOL]         default: [EOL]             ret = ConcreteType.NONE; [EOL]     } [EOL]     return createTypeIntersection(ret, expr.getJSType()); [EOL] } <line_num>: 1053,1185
private ConcreteType createTypeIntersection(ConcreteType concreteType, JSType jsType) { [EOL]     ConcreteJSTypePair key = new ConcreteJSTypePair(concreteType, jsType); [EOL]     ConcreteType ret = typeIntersectionMemos.get(key); [EOL]     if (ret != null) { [EOL]         return ret; [EOL]     } [EOL]     if (jsType == null || jsType.isUnknownType() || concreteType.isNone()) { [EOL]         ret = concreteType; [EOL]     } else if (concreteType.isUnion() || concreteType.isSingleton()) { [EOL]         ret = concreteType.intersectWith(createTypeWithSubTypes(jsType)); [EOL]     } else { [EOL]         Preconditions.checkState(concreteType.isAll()); [EOL]         ret = createTypeWithSubTypes(jsType); [EOL]     } [EOL]     ret = ret.intersectWith(ConcreteType.createForTypes(allInstantiatedTypes)); [EOL]     for (ConcreteFunctionType functionType : concreteType.getFunctions()) { [EOL]         ret = ret.unionWith(functionType); [EOL]     } [EOL]     for (ConcreteInstanceType prototype : concreteType.getPrototypeTypes()) { [EOL]         ret = ret.unionWith(prototype); [EOL]     } [EOL]     for (ConcreteInstanceType instance : concreteType.getInstances()) { [EOL]         if (!instance.instanceType.isInstanceType() && !instance.isFunctionPrototype()) { [EOL]             ret = ret.unionWith(instance); [EOL]         } [EOL]     } [EOL]     typeIntersectionMemos.put(key, ret); [EOL]     return ret; [EOL] } <line_num>: 1187,1233
@Override [EOL] public ConcreteFunctionType createConcreteFunction(Node decl, StaticScope<ConcreteType> parent) { [EOL]     ConcreteFunctionType funType = functionFromDeclaration.get(decl); [EOL]     if (funType == null) { [EOL]         functionFromDeclaration.put(decl, funType = new ConcreteFunctionType(this, decl, parent)); [EOL]         if (decl.getJSType() != null) { [EOL]             functionFromJSType.put(decl.getJSType().toMaybeFunctionType(), funType); [EOL]         } [EOL]     } [EOL]     return funType; [EOL] } <line_num>: 1235,1247
@Override [EOL] public ConcreteInstanceType createConcreteInstance(ObjectType instanceType) { [EOL]     Preconditions.checkArgument(!instanceType.isFunctionType() || instanceType == getTypeRegistry().getNativeType(U2U_CONSTRUCTOR_TYPE)); [EOL]     ConcreteInstanceType instType = instanceFromJSType.get(instanceType); [EOL]     if (instType == null) { [EOL]         instanceFromJSType.put(instanceType, instType = new ConcreteInstanceType(this, instanceType)); [EOL]     } [EOL]     return instType; [EOL] } <line_num>: 1249,1261
ConcreteFunctionType getConcreteFunction(Node decl) { [EOL]     return functionFromDeclaration.get(decl); [EOL] } <line_num>: 1264,1266
@Override [EOL] public ConcreteFunctionType getConcreteFunction(FunctionType functionType) { [EOL]     return functionFromJSType.get(functionType); [EOL] } <line_num>: 1269,1272
@Override [EOL] public ConcreteInstanceType getConcreteInstance(ObjectType instanceType) { [EOL]     return instanceFromJSType.get(instanceType); [EOL] } <line_num>: 1275,1278
@Override [EOL] public StaticScope<ConcreteType> createFunctionScope(Node decl, StaticScope<ConcreteType> parent) { [EOL]     ConcreteScope scope = new ConcreteScope((ConcreteScope) parent); [EOL]     scope.declareSlot(ConcreteFunctionType.CALL_SLOT_NAME, decl); [EOL]     scope.declareSlot(ConcreteFunctionType.THIS_SLOT_NAME, decl); [EOL]     scope.declareSlot(ConcreteFunctionType.RETURN_SLOT_NAME, decl); [EOL]     for (Node n = decl.getFirstChild().getNext().getFirstChild(); n != null; n = n.getNext()) { [EOL]         scope.declareSlot(n.getString(), n); [EOL]     } [EOL]     scope.initForScopeRoot(decl.getLastChild()); [EOL]     return scope; [EOL] } <line_num>: 1280,1296
@Override [EOL] public StaticScope<ConcreteType> createInstanceScope(ObjectType instanceType) { [EOL]     ConcreteScope parentScope = null; [EOL]     ObjectType implicitProto = instanceType.getImplicitPrototype(); [EOL]     if (implicitProto != null && !implicitProto.isUnknownType()) { [EOL]         ConcreteInstanceType prototype = createConcreteInstance(implicitProto); [EOL]         parentScope = (ConcreteScope) prototype.getScope(); [EOL]     } [EOL]     ConcreteScope scope = new ConcreteScope(parentScope); [EOL]     for (String propName : instanceType.getOwnPropertyNames()) { [EOL]         scope.declareSlot(propName, null); [EOL]     } [EOL]     return scope; [EOL] } <line_num>: 1298,1312
ConcreteType createUnionWithSubTypes(ConcreteType type) { [EOL]     Set<ConcreteType> set = null; [EOL]     if (type.isInstance()) { [EOL]         set = getSubTypes(type.toInstance()); [EOL]     } [EOL]     return ConcreteType.createForTypes(set).unionWith(type); [EOL] } <line_num>: 1320,1327
private Set<ConcreteType> getSubTypes(ConcreteInstanceType type) { [EOL]     if (type.getConstructorType() == null) { [EOL]         return null; [EOL]     } [EOL]     Set<ConcreteType> set = Sets.newHashSet(); [EOL]     getSubTypes(type.getConstructorType().getJSType(), set); [EOL]     return set; [EOL] } <line_num>: 1330,1338
private boolean getSubTypes(FunctionType type, Set<ConcreteType> set) { [EOL]     if (type.getSubTypes() != null) { [EOL]         for (FunctionType sub : type.getSubTypes()) { [EOL]             ConcreteType concrete = createType(sub); [EOL]             if (concrete.isFunction() && concrete.toFunction().getInstanceType() != null) { [EOL]                 concrete = concrete.toFunction().getInstanceType(); [EOL]                 if (!set.contains(concrete)) { [EOL]                     set.add(concrete); [EOL]                     if (!getSubTypes(sub, set)) { [EOL]                         return false; [EOL]                     } [EOL]                 } [EOL]             } else { [EOL]                 set.clear(); [EOL]                 set.add(ConcreteType.ALL); [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 1344,1368
private int getJSTypeHashCode() { [EOL]     return jstype != null ? jstype.hashCode() : 0; [EOL] } <line_num>: 1385,1387
private boolean equalsJSType(JSType jsType) { [EOL]     if (jsType == null || jstype == null) { [EOL]         return jstype == jsType; [EOL]     } else { [EOL]         return jsType.equals(this.jstype); [EOL]     } [EOL] } <line_num>: 1389,1395
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o instanceof ConcreteJSTypePair) { [EOL]         ConcreteJSTypePair pair = (ConcreteJSTypePair) o; [EOL]         if ((pair.concrete.equals(this.concrete) && equalsJSType(pair.jstype))) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1397,1407
@Override [EOL] public int hashCode() { [EOL]     return hashcode; [EOL] } <line_num>: 1409,1412
