public SideEffectsAnalysis(AbstractCompiler compiler, LocationAbstractionMode locationAbstractionMode) { [EOL]     this.compiler = compiler; [EOL]     this.locationAbstractionIdentifier = locationAbstractionMode; [EOL] } <line_num>: 90,95
public SideEffectsAnalysis(AbstractCompiler compiler) { [EOL]     this(compiler, LocationAbstractionMode.DEGENERATE); [EOL] } <line_num>: 97,99
public IntraproceduralMotionEnvironment(ControlFlowGraph<Node> controlFlowGraph, Node cfgSource, Node cfgDestination) { [EOL] } <line_num>: 446,451
public CrossModuleMotionEnvironment(Node sourceNode, JSModule sourceModule, Node destinationNode, JSModule destinationModule, JSModuleGraph moduleGraph) { [EOL] } <line_num>: 478,484
public RawMotionEnvironment(Set<Node> environment) { [EOL]     this.environment = environment; [EOL] } <line_num>: 501,503
public LocationSummary(EffectLocation modSet, EffectLocation refSet) { [EOL]     this.modSet = modSet; [EOL]     this.refSet = refSet; [EOL] } <line_num>: 522,525
private VisibilityLocationAbstraction(AbstractCompiler compiler, VariableVisibilityAnalysis variableVisibilityAnalysis, VariableUseDeclarationMap variableUseMap) { [EOL]     this.compiler = compiler; [EOL]     this.variableVisibilityAnalysis = variableVisibilityAnalysis; [EOL]     this.variableUseMap = variableUseMap; [EOL] } <line_num>: 730,736
public VisibilityBasedEffectLocation(int visibilityMask) { [EOL]     this.visibilityMask = visibilityMask; [EOL] } <line_num>: 902,904
public VariableUseDeclarationMap(AbstractCompiler compiler) { [EOL]     this.compiler = compiler; [EOL] } <line_num>: 948,950
@Override [EOL] public boolean apply(Node input) { [EOL]     return !input.isFunction(); [EOL] } <line_num>: 67,70
@Override [EOL] public void process(Node externs, Node root) { [EOL]     switch(locationAbstractionIdentifier) { [EOL]         case DEGENERATE: [EOL]             locationAbstraction = new DegenerateLocationAbstraction(); [EOL]             break; [EOL]         case VISIBILITY_BASED: [EOL]             locationAbstraction = createVisibilityAbstraction(externs, root); [EOL]             break; [EOL]         default: [EOL]             throw new IllegalStateException("Unrecognized location abstraction " + "identifier: " + locationAbstractionIdentifier); [EOL]     } [EOL] } <line_num>: 101,119
private LocationAbstraction createVisibilityAbstraction(Node externs, Node root) { [EOL]     VariableVisibilityAnalysis variableVisibility = new VariableVisibilityAnalysis(compiler); [EOL]     variableVisibility.process(externs, root); [EOL]     VariableUseDeclarationMap variableMap = new VariableUseDeclarationMap(compiler); [EOL]     variableMap.mapUses(root); [EOL]     return new VisibilityLocationAbstraction(compiler, variableVisibility, variableMap); [EOL] } <line_num>: 121,135
public boolean safeToMoveBefore(Node source, AbstractMotionEnvironment environment, Node destination) { [EOL]     Preconditions.checkNotNull(locationAbstraction); [EOL]     Preconditions.checkArgument(!nodeHasAncestor(destination, source)); [EOL]     if (isPure(source)) { [EOL]         return true; [EOL]     } [EOL]     if (nodeHasCall(source)) { [EOL]         return false; [EOL]     } [EOL]     LocationSummary sourceLocationSummary = locationAbstraction.calculateLocationSummary(source); [EOL]     EffectLocation sourceModSet = sourceLocationSummary.getModSet(); [EOL]     if (!sourceModSet.isEmpty() && !nodesHaveSameControlFlow(source, destination)) { [EOL]         return false; [EOL]     } [EOL]     EffectLocation sourceRefSet = sourceLocationSummary.getRefSet(); [EOL]     Set<Node> environmentNodes = environment.calculateEnvironment(); [EOL]     for (Node environmentNode : environmentNodes) { [EOL]         if (nodeHasCall(environmentNode)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     LocationSummary environmentLocationSummary = locationAbstraction.calculateLocationSummary(environmentNodes); [EOL]     EffectLocation environmentModSet = environmentLocationSummary.getModSet(); [EOL]     EffectLocation environmentRefSet = environmentLocationSummary.getRefSet(); [EOL]     if (!environmentModSet.intersectsLocation(sourceRefSet) && !environmentRefSet.intersectsLocation(sourceModSet) && !environmentModSet.intersectsLocation(sourceModSet)) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 154,216
private boolean isPure(Node node) { [EOL]     return false; [EOL] } <line_num>: 222,226
@Override [EOL] public boolean apply(Node input) { [EOL]     int nodeType = input.getType(); [EOL]     return nodeType == Token.RETURN || nodeType == Token.BREAK || nodeType == Token.CONTINUE; [EOL] } <line_num>: 300,307
private static boolean nodesHaveSameControlFlow(Node node1, Node node2) { [EOL]     Node node1DeepestControlDependentBlock = closestControlDependentAncestor(node1); [EOL]     Node node2DeepestControlDependentBlock = closestControlDependentAncestor(node2); [EOL]     if (node1DeepestControlDependentBlock == node2DeepestControlDependentBlock) { [EOL]         if (node2DeepestControlDependentBlock != null) { [EOL]             if (node2DeepestControlDependentBlock.isCase()) { [EOL]                 return false; [EOL]             } [EOL]             Predicate<Node> isEarlyExitPredicate = new Predicate<Node>() { [EOL]  [EOL]                 @Override [EOL]                 public boolean apply(Node input) { [EOL]                     int nodeType = input.getType(); [EOL]                     return nodeType == Token.RETURN || nodeType == Token.BREAK || nodeType == Token.CONTINUE; [EOL]                 } [EOL]             }; [EOL]             return !NodeUtil.has(node2DeepestControlDependentBlock, isEarlyExitPredicate, NOT_FUNCTION_PREDICATE); [EOL]         } else { [EOL]             return true; [EOL]         } [EOL]     } else { [EOL]         return false; [EOL]     } [EOL] } <line_num>: 232,318
private static boolean isControlDependentChild(Node child) { [EOL]     Node parent = child.getParent(); [EOL]     if (parent == null) { [EOL]         return false; [EOL]     } [EOL]     ArrayList<Node> siblings = Lists.newArrayList(parent.children()); [EOL]     int indexOfChildInParent = siblings.indexOf(child); [EOL]     switch(parent.getType()) { [EOL]         case Token.IF: [EOL]         case Token.HOOK: [EOL]             return (indexOfChildInParent == 1 || indexOfChildInParent == 2); [EOL]         case Token.WHILE: [EOL]         case Token.DO: [EOL]             return true; [EOL]         case Token.FOR: [EOL]             return indexOfChildInParent != 0; [EOL]         case Token.SWITCH: [EOL]             return indexOfChildInParent > 0; [EOL]         case Token.AND: [EOL]             return true; [EOL]         case Token.OR: [EOL]             return true; [EOL]         case Token.FUNCTION: [EOL]             return true; [EOL]         default: [EOL]             return false; [EOL]     } [EOL] } <line_num>: 330,363
private static Node closestControlDependentAncestor(Node node) { [EOL]     if (isControlDependentChild(node)) { [EOL]         return node; [EOL]     } [EOL]     for (Node ancestor : node.getAncestors()) { [EOL]         if (isControlDependentChild(ancestor)) { [EOL]             return ancestor; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 365,378
private static boolean nodeHasAncestor(Node node, Node possibleAncestor) { [EOL]     for (Node ancestor : node.getAncestors()) { [EOL]         if (ancestor == possibleAncestor) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 384,394
@Override [EOL] public boolean apply(Node input) { [EOL]     return input.isCall() || input.isNew(); [EOL] } <line_num>: 401,404
private boolean nodeHasCall(Node node) { [EOL]     return NodeUtil.has(node, new Predicate<Node>() { [EOL]  [EOL]         @Override [EOL]         public boolean apply(Node input) { [EOL]             return input.isCall() || input.isNew(); [EOL]         } [EOL]     }, NOT_FUNCTION_PREDICATE); [EOL] } <line_num>: 399,406
public abstract Set<Node> calculateEnvironment(); <line_num>: 425,425
@Override [EOL] public Set<Node> calculateEnvironment() { [EOL]     return null; [EOL] } <line_num>: 453,457
@Override [EOL] public Set<Node> calculateEnvironment() { [EOL]     return null; [EOL] } <line_num>: 486,490
@Override [EOL] public Set<Node> calculateEnvironment() { [EOL]     return environment; [EOL] } <line_num>: 505,508
public EffectLocation getModSet() { [EOL]     return modSet; [EOL] } <line_num>: 527,529
public EffectLocation getRefSet() { [EOL]     return refSet; [EOL] } <line_num>: 531,533
public boolean intersectsLocation(EffectLocation otherLocation); <line_num>: 557,557
public EffectLocation join(EffectLocation otherLocation); <line_num>: 566,566
public boolean isEmpty(); <line_num>: 571,571
abstract LocationSummary calculateLocationSummary(Node node); <line_num>: 587,587
abstract EffectLocation getBottomLocation(); <line_num>: 596,596
public LocationSummary calculateLocationSummary(Set<Node> nodes) { [EOL]     EffectLocation modAccumulator = getBottomLocation(); [EOL]     EffectLocation refAccumulator = getBottomLocation(); [EOL]     for (Node node : nodes) { [EOL]         LocationSummary nodeLocationSummary = calculateLocationSummary(node); [EOL]         modAccumulator = modAccumulator.join(nodeLocationSummary.getModSet()); [EOL]         refAccumulator = refAccumulator.join(nodeLocationSummary.getRefSet()); [EOL]     } [EOL]     return new LocationSummary(modAccumulator, refAccumulator); [EOL] } <line_num>: 602,614
@Override [EOL] EffectLocation getBottomLocation() { [EOL]     return NO_LOCATION; [EOL] } <line_num>: 634,637
@Override [EOL] public LocationSummary calculateLocationSummary(Node node) { [EOL]     return new LocationSummary(calculateModSet(node), calculateRefSet(node)); [EOL] } <line_num>: 639,642
EffectLocation calculateRefSet(Node node) { [EOL]     if (NodeUtil.canBeSideEffected(node)) { [EOL]         return EVERY_LOCATION; [EOL]     } else { [EOL]         return NO_LOCATION; [EOL]     } [EOL] } <line_num>: 644,650
EffectLocation calculateModSet(Node node) { [EOL]     if (NodeUtil.mayHaveSideEffects(node)) { [EOL]         return EVERY_LOCATION; [EOL]     } else { [EOL]         return NO_LOCATION; [EOL]     } [EOL] } <line_num>: 652,658
@Override [EOL] public EffectLocation join(EffectLocation otherLocation) { [EOL]     if (otherLocation == EVERY_LOCATION) { [EOL]         return otherLocation; [EOL]     } else { [EOL]         return this; [EOL]     } [EOL] } <line_num>: 661,668
@Override [EOL] public boolean intersectsLocation(EffectLocation otherLocation) { [EOL]     return this == EVERY_LOCATION && otherLocation == EVERY_LOCATION; [EOL] } <line_num>: 670,673
@Override [EOL] public boolean isEmpty() { [EOL]     return this == NO_LOCATION; [EOL] } <line_num>: 675,678
@Override [EOL] LocationSummary calculateLocationSummary(Node node) { [EOL]     int visibilityRefLocations = VISIBILITY_LOCATION_NONE; [EOL]     int visibilityModLocations = VISIBILITY_LOCATION_NONE; [EOL]     for (Node reference : findStorageLocationReferences(node)) { [EOL]         int effectMask; [EOL]         if (reference.isName()) { [EOL]             effectMask = effectMaskForVariableReference(reference); [EOL]         } else { [EOL]             effectMask = HEAP_LOCATION_MASK; [EOL]         } [EOL]         if (storageNodeIsLValue(reference)) { [EOL]             visibilityModLocations |= effectMask; [EOL]         } [EOL]         if (storageNodeIsRValue(reference)) { [EOL]             visibilityRefLocations |= effectMask; [EOL]         } [EOL]     } [EOL]     VisibilityBasedEffectLocation modSet = new VisibilityBasedEffectLocation(visibilityModLocations); [EOL]     VisibilityBasedEffectLocation refSet = new VisibilityBasedEffectLocation(visibilityRefLocations); [EOL]     return new LocationSummary(modSet, refSet); [EOL] } <line_num>: 741,773
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (NodeUtil.isGet(n) || (n.isName() && !parent.isFunction())) { [EOL]         references.add(n); [EOL]     } [EOL] } <line_num>: 783,789
private Set<Node> findStorageLocationReferences(Node root) { [EOL]     final Set<Node> references = Sets.newHashSet(); [EOL]     NodeTraversal.traverse(compiler, root, new AbstractShallowCallback() { [EOL]  [EOL]         @Override [EOL]         public void visit(NodeTraversal t, Node n, Node parent) { [EOL]             if (NodeUtil.isGet(n) || (n.isName() && !parent.isFunction())) { [EOL]                 references.add(n); [EOL]             } [EOL]         } [EOL]     }); [EOL]     return references; [EOL] } <line_num>: 779,793
private int effectMaskForVariableReference(Node variableReference) { [EOL]     Preconditions.checkArgument(variableReference.isName()); [EOL]     int effectMask = VISIBILITY_LOCATION_NONE; [EOL]     Node declaringNameNode = variableUseMap.findDeclaringNameNodeForUse(variableReference); [EOL]     if (declaringNameNode != null) { [EOL]         VariableVisibility visibility = variableVisibilityAnalysis.getVariableVisibility(declaringNameNode); [EOL]         switch(visibility) { [EOL]             case LOCAL: [EOL]                 effectMask = LOCAL_VARIABLE_LOCATION_MASK; [EOL]                 break; [EOL]             case CAPTURED_LOCAL: [EOL]                 effectMask = CAPTURED_LOCAL_VARIABLE_LOCATION_MASK; [EOL]                 break; [EOL]             case PARAMETER: [EOL]                 effectMask = HEAP_LOCATION_MASK; [EOL]                 break; [EOL]             case GLOBAL: [EOL]                 effectMask = GLOBAL_VARIABLE_LOCATION_MASK; [EOL]                 break; [EOL]             default: [EOL]                 throw new IllegalStateException("Unrecognized variable" + " visibility: " + visibility); [EOL]         } [EOL]     } else { [EOL]         effectMask = UNKNOWN_LOCATION_MASK; [EOL]     } [EOL]     return effectMask; [EOL] } <line_num>: 798,835
@Override [EOL] EffectLocation getBottomLocation() { [EOL]     return new VisibilityBasedEffectLocation(VISIBILITY_LOCATION_NONE); [EOL] } <line_num>: 837,840
private static boolean isStorageNode(Node node) { [EOL]     return node.isName() || NodeUtil.isGet(node); [EOL] } <line_num>: 847,849
private static boolean storageNodeIsRValue(Node node) { [EOL]     Preconditions.checkArgument(isStorageNode(node)); [EOL]     Node parent = node.getParent(); [EOL]     if (storageNodeIsLValue(node)) { [EOL]         boolean nonSimpleAssign = NodeUtil.isAssignmentOp(parent) && !parent.isAssign(); [EOL]         return (nonSimpleAssign || parent.isDec() || parent.isInc()); [EOL]     } [EOL]     return true; [EOL] } <line_num>: 854,878
private static boolean storageNodeIsLValue(Node node) { [EOL]     Preconditions.checkArgument(isStorageNode(node)); [EOL]     return NodeUtil.isLValue(node); [EOL] } <line_num>: 883,886
@Override [EOL] public boolean intersectsLocation(EffectLocation otherLocation) { [EOL]     Preconditions.checkArgument(otherLocation instanceof VisibilityBasedEffectLocation); [EOL]     int otherMask = ((VisibilityBasedEffectLocation) otherLocation).visibilityMask; [EOL]     return (visibilityMask & otherMask) > 0; [EOL] } <line_num>: 906,915
@Override [EOL] public boolean isEmpty() { [EOL]     return visibilityMask == VISIBILITY_LOCATION_NONE; [EOL] } <line_num>: 917,920
@Override [EOL] public EffectLocation join(EffectLocation otherLocation) { [EOL]     Preconditions.checkArgument(otherLocation instanceof VisibilityBasedEffectLocation); [EOL]     int otherMask = ((VisibilityBasedEffectLocation) otherLocation).visibilityMask; [EOL]     int joinedMask = visibilityMask | otherMask; [EOL]     return new VisibilityBasedEffectLocation(joinedMask); [EOL] } <line_num>: 922,933
public void mapUses(Node root) { [EOL]     referencesByNameNode = Maps.newHashMap(); [EOL]     ReferenceCollectingCallback callback = new ReferenceCollectingCallback(compiler, ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR); [EOL]     NodeTraversal.traverse(compiler, root, callback); [EOL]     for (Var variable : callback.getAllSymbols()) { [EOL]         ReferenceCollection referenceCollection = callback.getReferences(variable); [EOL]         for (Reference reference : referenceCollection.references) { [EOL]             Node referenceNameNode = reference.getNode(); [EOL]             referencesByNameNode.put(referenceNameNode, variable.getNameNode()); [EOL]         } [EOL]     } [EOL] } <line_num>: 959,979
public Node findDeclaringNameNodeForUse(Node usingNameNode) { [EOL]     Preconditions.checkArgument(usingNameNode.isName()); [EOL]     return referencesByNameNode.get(usingNameNode); [EOL] } <line_num>: 986,990
