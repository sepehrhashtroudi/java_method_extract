public DefaultPassConfig(CompilerOptions options) { [EOL]     super(options); [EOL] } <line_num>: 135,137
GlobalTypeResolver(AbstractCompiler compiler) { [EOL]     this.compiler = compiler; [EOL] } <line_num>: 1250,1252
HotSwapPassFactory(String name, boolean isOneTimePass) { [EOL]     super(name, isOneTimePass); [EOL] } <line_num>: 2307,2309
@Override [EOL] protected State getIntermediateState() { [EOL]     return new State(cssNames == null ? null : Maps.newHashMap(cssNames), exportedNames == null ? null : Collections.unmodifiableSet(exportedNames), crossModuleIdGenerator, variableMap, propertyMap, anonymousFunctionNameMap, stringMap, functionNames, idGeneratorMap); [EOL] } <line_num>: 139,147
@Override [EOL] protected void setIntermediateState(State state) { [EOL]     this.cssNames = state.cssNames == null ? null : Maps.newHashMap(state.cssNames); [EOL]     this.exportedNames = state.exportedNames == null ? null : Sets.newHashSet(state.exportedNames); [EOL]     this.crossModuleIdGenerator = state.crossModuleIdGenerator; [EOL]     this.variableMap = state.variableMap; [EOL]     this.propertyMap = state.propertyMap; [EOL]     this.anonymousFunctionNameMap = state.anonymousFunctionNameMap; [EOL]     this.stringMap = state.stringMap; [EOL]     this.functionNames = state.functionNames; [EOL]     this.idGeneratorMap = state.idGeneratorMap; [EOL] } <line_num>: 149,162
GlobalNamespace getGlobalNamespace() { [EOL]     return namespaceForChecks; [EOL] } <line_num>: 164,166
PreprocessorSymbolTable getPreprocessorSymbolTable() { [EOL]     return preprocessorSymbolTable; [EOL] } <line_num>: 168,170
void maybeInitializePreprocessorSymbolTable(AbstractCompiler compiler) { [EOL]     if (options.ideMode) { [EOL]         Node root = compiler.getRoot(); [EOL]         if (preprocessorSymbolTable == null || preprocessorSymbolTable.getRootNode() != root) { [EOL]             preprocessorSymbolTable = new PreprocessorSymbolTable(root); [EOL]         } [EOL]     } [EOL] } <line_num>: 172,180
@Override [EOL] protected List<PassFactory> getChecks() { [EOL]     List<PassFactory> checks = Lists.newArrayList(); [EOL]     checks.add(createEmptyPass("beforeStandardChecks")); [EOL]     if (options.closurePass) { [EOL]         checks.add(closureGoogScopeAliases); [EOL]         checks.add(closureRewriteGoogClass); [EOL]     } [EOL]     if (options.nameAnonymousFunctionsOnly) { [EOL]         if (options.anonymousFunctionNaming == AnonymousFunctionNamingPolicy.MAPPED) { [EOL]             checks.add(nameMappedAnonymousFunctions); [EOL]         } else if (options.anonymousFunctionNaming == AnonymousFunctionNamingPolicy.UNMAPPED) { [EOL]             checks.add(nameUnmappedAnonymousFunctions); [EOL]         } [EOL]         return checks; [EOL]     } [EOL]     if (options.jqueryPass) { [EOL]         checks.add(jqueryAliases); [EOL]     } [EOL]     checks.add(checkSideEffects); [EOL]     if (options.checkSuspiciousCode || options.enables(DiagnosticGroups.GLOBAL_THIS) || options.enables(DiagnosticGroups.DEBUGGER_STATEMENT_PRESENT)) { [EOL]         checks.add(suspiciousCode); [EOL]     } [EOL]     if (options.checkControlStructures || options.enables(DiagnosticGroups.ES5_STRICT)) { [EOL]         checks.add(checkControlStructures); [EOL]     } [EOL]     if (options.checkRequires.isOn()) { [EOL]         checks.add(checkRequires); [EOL]     } [EOL]     if (options.checkProvides.isOn()) { [EOL]         checks.add(checkProvides); [EOL]     } [EOL]     if (options.generateExports) { [EOL]         checks.add(generateExports); [EOL]     } [EOL]     if (options.exportTestFunctions) { [EOL]         checks.add(exportTestFunctions); [EOL]     } [EOL]     if (options.closurePass) { [EOL]         checks.add(closurePrimitives); [EOL]     } [EOL]     if (options.closurePass && options.checkMissingGetCssNameLevel.isOn()) { [EOL]         checks.add(closureCheckGetCssName); [EOL]     } [EOL]     if (options.syntheticBlockStartMarker != null) { [EOL]         checks.add(createSyntheticBlocks); [EOL]     } [EOL]     checks.add(checkVars); [EOL]     if (options.computeFunctionSideEffects) { [EOL]         checks.add(checkRegExp); [EOL]     } [EOL]     if (options.aggressiveVarCheck.isOn()) { [EOL]         checks.add(checkVariableReferences); [EOL]     } [EOL]     if (options.processObjectPropertyString) { [EOL]         checks.add(objectPropertyStringPreprocess); [EOL]     } [EOL]     if (options.checkTypes || options.inferTypes) { [EOL]         checks.add(resolveTypes); [EOL]         checks.add(inferTypes); [EOL]         if (options.checkTypes) { [EOL]             checks.add(checkTypes); [EOL]         } else { [EOL]             checks.add(inferJsDocInfo); [EOL]         } [EOL]         if (!options.ideMode && !options.saveDataStructures) { [EOL]             checks.add(clearTypedScopePass); [EOL]         } [EOL]     } [EOL]     if (options.checkUnreachableCode.isOn() || (options.checkTypes && options.checkMissingReturn.isOn())) { [EOL]         checks.add(checkControlFlow); [EOL]     } [EOL]     if (options.checkTypes && (options.enables(DiagnosticGroups.ACCESS_CONTROLS) || options.enables(DiagnosticGroups.CONSTANT_PROPERTY))) { [EOL]         checks.add(checkAccessControls); [EOL]     } [EOL]     if (options.checkGlobalNamesLevel.isOn()) { [EOL]         checks.add(checkGlobalNames); [EOL]     } [EOL]     if (options.enables(DiagnosticGroups.ES5_STRICT) || options.checkCaja) { [EOL]         checks.add(checkStrictMode); [EOL]     } [EOL]     if (options.closurePass) { [EOL]         checks.add(closureReplaceGetCssName); [EOL]     } [EOL]     if (options.replaceMessagesWithChromeI18n) { [EOL]         checks.add(replaceMessagesForChrome); [EOL]     } else if (options.messageBundle != null) { [EOL]         checks.add(replaceMessages); [EOL]     } [EOL]     if (options.getTweakProcessing().isOn()) { [EOL]         checks.add(processTweaks); [EOL]     } [EOL]     checks.add(processDefines); [EOL]     if (options.instrumentationTemplate != null || options.recordFunctionInformation) { [EOL]         checks.add(computeFunctionNames); [EOL]     } [EOL]     if (options.nameReferenceGraphPath != null && !options.nameReferenceGraphPath.isEmpty()) { [EOL]         checks.add(printNameReferenceGraph); [EOL]     } [EOL]     if (options.nameReferenceReportPath != null && !options.nameReferenceReportPath.isEmpty()) { [EOL]         checks.add(printNameReferenceReport); [EOL]     } [EOL]     checks.add(createEmptyPass("afterStandardChecks")); [EOL]     assertAllOneTimePasses(checks); [EOL]     return checks; [EOL] } <line_num>: 182,345
@Override [EOL] protected List<PassFactory> getOptimizations() { [EOL]     List<PassFactory> passes = Lists.newArrayList(); [EOL]     passes.add(garbageCollectChecks); [EOL]     if (options.runtimeTypeCheck) { [EOL]         passes.add(runtimeTypeCheck); [EOL]     } [EOL]     passes.add(createEmptyPass("beforeStandardOptimizations")); [EOL]     if (options.replaceIdGenerators) { [EOL]         passes.add(replaceIdGenerators); [EOL]     } [EOL]     if (options.optimizeArgumentsArray) { [EOL]         passes.add(optimizeArgumentsArray); [EOL]     } [EOL]     if (options.closurePass && (options.removeAbstractMethods || options.removeClosureAsserts)) { [EOL]         passes.add(closureCodeRemoval); [EOL]     } [EOL]     if (options.collapseProperties) { [EOL]         passes.add(collapseProperties); [EOL]     } [EOL]     if (!options.replaceStringsFunctionDescriptions.isEmpty()) { [EOL]         passes.add(replaceStrings); [EOL]     } [EOL]     if (options.tightenTypes) { [EOL]         passes.add(tightenTypesBuilder); [EOL]     } [EOL]     if (options.disambiguateProperties) { [EOL]         passes.add(disambiguateProperties); [EOL]     } [EOL]     if (options.computeFunctionSideEffects) { [EOL]         passes.add(markPureFunctions); [EOL]     } else if (options.markNoSideEffectCalls) { [EOL]         passes.add(markNoSideEffectCalls); [EOL]     } [EOL]     if (options.chainCalls) { [EOL]         passes.add(chainCalls); [EOL]     } [EOL]     passes.add(checkConsts); [EOL]     if (options.ignoreCajaProperties) { [EOL]         passes.add(ignoreCajaProperties); [EOL]     } [EOL]     assertAllOneTimePasses(passes); [EOL]     if (options.smartNameRemoval || options.reportPath != null) { [EOL]         passes.addAll(getCodeRemovingPasses()); [EOL]         passes.add(smartNamePass); [EOL]     } [EOL]     if (options.closurePass) { [EOL]         passes.add(closureOptimizePrimitives); [EOL]     } [EOL]     if (options.crossModuleCodeMotion) { [EOL]         passes.add(crossModuleCodeMotion); [EOL]     } [EOL]     if (options.devirtualizePrototypeMethods) { [EOL]         passes.add(devirtualizePrototypeMethods); [EOL]     } [EOL]     if (options.customPasses != null) { [EOL]         passes.add(getCustomPasses(CustomPassExecutionTime.BEFORE_OPTIMIZATION_LOOP)); [EOL]     } [EOL]     passes.add(createEmptyPass("beforeMainOptimizations")); [EOL]     passes.addAll(getMainOptimizationLoop()); [EOL]     if (options.specializeInitialModule) { [EOL]         if (options.crossModuleCodeMotion) { [EOL]             passes.add(crossModuleCodeMotion); [EOL]         } [EOL]         if (options.crossModuleMethodMotion) { [EOL]             passes.add(crossModuleMethodMotion); [EOL]         } [EOL]         passes.add(specializeInitialModule); [EOL]         passes.addAll(getMainOptimizationLoop()); [EOL]     } [EOL]     passes.add(createEmptyPass("beforeModuleMotion")); [EOL]     if (options.crossModuleCodeMotion) { [EOL]         passes.add(crossModuleCodeMotion); [EOL]     } [EOL]     if (options.crossModuleMethodMotion) { [EOL]         passes.add(crossModuleMethodMotion); [EOL]     } [EOL]     passes.add(createEmptyPass("afterModuleMotion")); [EOL]     if (options.customPasses != null) { [EOL]         passes.add(getCustomPasses(CustomPassExecutionTime.AFTER_OPTIMIZATION_LOOP)); [EOL]     } [EOL]     if (options.flowSensitiveInlineVariables) { [EOL]         passes.add(flowSensitiveInlineVariables); [EOL]         if (options.removeUnusedVars || options.removeUnusedLocalVars) { [EOL]             passes.add(removeUnusedVars); [EOL]         } [EOL]     } [EOL]     if (options.smartNameRemoval) { [EOL]         passes.add(smartNamePass2); [EOL]     } [EOL]     if (options.collapseAnonymousFunctions) { [EOL]         passes.add(collapseAnonymousFunctions); [EOL]     } [EOL]     if (options.moveFunctionDeclarations || options.renamePrefixNamespace != null) { [EOL]         passes.add(moveFunctionDeclarations); [EOL]     } [EOL]     if (options.anonymousFunctionNaming == AnonymousFunctionNamingPolicy.MAPPED) { [EOL]         passes.add(nameMappedAnonymousFunctions); [EOL]     } [EOL]     if (options.extractPrototypeMemberDeclarations && (options.propertyRenaming != PropertyRenamingPolicy.HEURISTIC && options.propertyRenaming != PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC)) { [EOL]         passes.add(extractPrototypeMemberDeclarations); [EOL]     } [EOL]     if (options.ambiguateProperties && (options.propertyRenaming == PropertyRenamingPolicy.ALL_UNQUOTED)) { [EOL]         passes.add(ambiguateProperties); [EOL]     } [EOL]     if (options.propertyRenaming != PropertyRenamingPolicy.OFF) { [EOL]         passes.add(renameProperties); [EOL]     } [EOL]     if (options.reserveRawExports) { [EOL]         passes.add(gatherRawExports); [EOL]     } [EOL]     if (options.convertToDottedProperties) { [EOL]         passes.add(convertToDottedProperties); [EOL]     } [EOL]     if (options.rewriteFunctionExpressions) { [EOL]         passes.add(rewriteFunctionExpressions); [EOL]     } [EOL]     if (!options.aliasableStrings.isEmpty() || options.aliasAllStrings) { [EOL]         passes.add(aliasStrings); [EOL]     } [EOL]     if (options.aliasExternals) { [EOL]         passes.add(aliasExternals); [EOL]     } [EOL]     if (options.aliasKeywords) { [EOL]         passes.add(aliasKeywords); [EOL]     } [EOL]     passes.add(markUnnormalized); [EOL]     if (options.coalesceVariableNames) { [EOL]         passes.add(coalesceVariableNames); [EOL]         if (options.foldConstants) { [EOL]             passes.add(peepholeOptimizations); [EOL]         } [EOL]     } [EOL]     if (options.collapseVariableDeclarations) { [EOL]         passes.add(exploitAssign); [EOL]         passes.add(collapseVariableDeclarations); [EOL]     } [EOL]     passes.add(denormalize); [EOL]     if (options.instrumentationTemplate != null) { [EOL]         passes.add(instrumentFunctions); [EOL]     } [EOL]     if (options.variableRenaming != VariableRenamingPolicy.ALL) { [EOL]         passes.add(invertContextualRenaming); [EOL]     } [EOL]     if (options.variableRenaming != VariableRenamingPolicy.OFF) { [EOL]         passes.add(renameVars); [EOL]     } [EOL]     if (options.groupVariableDeclarations) { [EOL]         passes.add(groupVariableDeclarations); [EOL]     } [EOL]     if (options.processObjectPropertyString) { [EOL]         passes.add(objectPropertyStringPostprocess); [EOL]     } [EOL]     if (options.labelRenaming) { [EOL]         passes.add(renameLabels); [EOL]     } [EOL]     if (options.foldConstants) { [EOL]         passes.add(latePeepholeOptimizations); [EOL]     } [EOL]     if (options.anonymousFunctionNaming == AnonymousFunctionNamingPolicy.UNMAPPED) { [EOL]         passes.add(nameUnmappedAnonymousFunctions); [EOL]     } [EOL]     passes.add(stripSideEffectProtection); [EOL]     if (options.renamePrefixNamespace != null) { [EOL]         if (!GLOBAL_SYMBOL_NAMESPACE_PATTERN.matcher(options.renamePrefixNamespace).matches()) { [EOL]             throw new IllegalArgumentException("Illegal character in renamePrefixNamespace name: " + options.renamePrefixNamespace); [EOL]         } [EOL]         passes.add(rescopeGlobalSymbols); [EOL]     } [EOL]     passes.add(sanityCheckAst); [EOL]     passes.add(sanityCheckVars); [EOL]     return passes; [EOL] } <line_num>: 347,679
private List<PassFactory> getMainOptimizationLoop() { [EOL]     List<PassFactory> passes = Lists.newArrayList(); [EOL]     if (options.inlineGetters) { [EOL]         passes.add(inlineSimpleMethods); [EOL]     } [EOL]     passes.addAll(getCodeRemovingPasses()); [EOL]     if (options.inlineFunctions || options.inlineLocalFunctions) { [EOL]         passes.add(inlineFunctions); [EOL]     } [EOL]     if (options.inlineProperties) { [EOL]         passes.add(inlineProperties); [EOL]     } [EOL]     boolean runOptimizeCalls = options.optimizeCalls || options.optimizeParameters || options.optimizeReturns; [EOL]     if (options.removeUnusedVars || options.removeUnusedLocalVars) { [EOL]         if (options.deadAssignmentElimination) { [EOL]             passes.add(deadAssignmentsElimination); [EOL]         } [EOL]         if (!runOptimizeCalls) { [EOL]             passes.add(removeUnusedVars); [EOL]         } [EOL]     } [EOL]     if (runOptimizeCalls) { [EOL]         passes.add(optimizeCallsAndRemoveUnusedVars); [EOL]     } [EOL]     assertAllLoopablePasses(passes); [EOL]     return passes; [EOL] } <line_num>: 682,715
private List<PassFactory> getCodeRemovingPasses() { [EOL]     List<PassFactory> passes = Lists.newArrayList(); [EOL]     if (options.collapseObjectLiterals && !isInliningForbidden()) { [EOL]         passes.add(collapseObjectLiterals); [EOL]     } [EOL]     if (options.inlineVariables || options.inlineLocalVariables) { [EOL]         passes.add(inlineVariables); [EOL]     } else if (options.inlineConstantVars) { [EOL]         passes.add(inlineConstants); [EOL]     } [EOL]     if (options.foldConstants) { [EOL]         passes.add(minimizeExitPoints); [EOL]         passes.add(peepholeOptimizations); [EOL]     } [EOL]     if (options.removeDeadCode) { [EOL]         passes.add(removeUnreachableCode); [EOL]     } [EOL]     if (options.removeUnusedPrototypeProperties) { [EOL]         passes.add(removeUnusedPrototypeProperties); [EOL]     } [EOL]     if (options.removeUnusedClassProperties && !isInliningForbidden()) { [EOL]         passes.add(removeUnusedClassProperties); [EOL]     } [EOL]     assertAllLoopablePasses(passes); [EOL]     return passes; [EOL] } <line_num>: 718,750
@Override [EOL] protected HotSwapCompilerPass create(final AbstractCompiler compiler) { [EOL]     boolean protectHiddenSideEffects = options.protectHiddenSideEffects && !options.ideMode; [EOL]     return new CheckSideEffects(compiler, options.checkSuspiciousCode ? CheckLevel.WARNING : CheckLevel.OFF, protectHiddenSideEffects); [EOL] } <line_num>: 757,767
@Override [EOL] protected CompilerPass create(final AbstractCompiler compiler) { [EOL]     return new CheckSideEffects.StripProtection(compiler); [EOL] } <line_num>: 775,779
@Override [EOL] protected HotSwapCompilerPass create(final AbstractCompiler compiler) { [EOL]     List<Callback> sharedCallbacks = Lists.newArrayList(); [EOL]     if (options.checkSuspiciousCode) { [EOL]         sharedCallbacks.add(new CheckSuspiciousCode()); [EOL]     } [EOL]     if (options.enables(DiagnosticGroups.GLOBAL_THIS)) { [EOL]         sharedCallbacks.add(new CheckGlobalThis(compiler)); [EOL]     } [EOL]     if (options.enables(DiagnosticGroups.DEBUGGER_STATEMENT_PRESENT)) { [EOL]         sharedCallbacks.add(new CheckDebuggerStatement(compiler)); [EOL]     } [EOL]     return combineChecks(compiler, sharedCallbacks); [EOL] } <line_num>: 787,803
private void assertAllOneTimePasses(List<PassFactory> passes) { [EOL]     for (PassFactory pass : passes) { [EOL]         Preconditions.checkState(pass.isOneTimePass()); [EOL]     } [EOL] } <line_num>: 808,812
private void assertAllLoopablePasses(List<PassFactory> passes) { [EOL]     for (PassFactory pass : passes) { [EOL]         Preconditions.checkState(!pass.isOneTimePass()); [EOL]     } [EOL] } <line_num>: 815,819
@Override [EOL] protected HotSwapCompilerPass create(AbstractCompiler compiler) { [EOL]     return new ControlStructureCheck(compiler); [EOL] } <line_num>: 824,827
@Override [EOL] protected HotSwapCompilerPass create(AbstractCompiler compiler) { [EOL]     return new CheckRequiresForConstructors(compiler, options.checkRequires); [EOL] } <line_num>: 833,836
@Override [EOL] protected HotSwapCompilerPass create(AbstractCompiler compiler) { [EOL]     return new CheckProvides(compiler, options.checkProvides); [EOL] } <line_num>: 842,845
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     CodingConvention convention = compiler.getCodingConvention(); [EOL]     if (convention.getExportSymbolFunction() != null && convention.getExportPropertyFunction() != null) { [EOL]         return new GenerateExports(compiler, convention.getExportSymbolFunction(), convention.getExportPropertyFunction()); [EOL]     } else { [EOL]         return new ErrorPass(compiler, GENERATE_EXPORTS_ERROR); [EOL]     } [EOL] } <line_num>: 856,867
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     CodingConvention convention = compiler.getCodingConvention(); [EOL]     if (convention.getExportSymbolFunction() != null) { [EOL]         return new ExportTestFunctions(compiler, convention.getExportSymbolFunction(), convention.getExportPropertyFunction()); [EOL]     } else { [EOL]         return new ErrorPass(compiler, GENERATE_EXPORTS_ERROR); [EOL]     } [EOL] } <line_num>: 873,883
@Override [EOL] public void process(Node externs, Node root) { [EOL]     pass.process(externs, root); [EOL]     if (exportedNames == null) { [EOL]         exportedNames = Sets.newHashSet(); [EOL]     } [EOL]     exportedNames.addAll(pass.getExportedVariableNames()); [EOL] } <line_num>: 895,902
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     final GatherRawExports pass = new GatherRawExports(compiler); [EOL]     return new CompilerPass() { [EOL]  [EOL]         @Override [EOL]         public void process(Node externs, Node root) { [EOL]             pass.process(externs, root); [EOL]             if (exportedNames == null) { [EOL]                 exportedNames = Sets.newHashSet(); [EOL]             } [EOL]             exportedNames.addAll(pass.getExportedVariableNames()); [EOL]         } [EOL]     }; [EOL] } <line_num>: 889,904
@Override [EOL] public void process(Node externs, Node root) { [EOL]     pass.process(externs, root); [EOL]     exportedNames = pass.getExportedVariableNames(); [EOL] } <line_num>: 920,924
@Override [EOL] public void hotSwapScript(Node scriptRoot, Node originalRoot) { [EOL]     pass.hotSwapScript(scriptRoot, originalRoot); [EOL] } <line_num>: 925,928
@Override [EOL] protected HotSwapCompilerPass create(AbstractCompiler compiler) { [EOL]     maybeInitializePreprocessorSymbolTable(compiler); [EOL]     final ProcessClosurePrimitives pass = new ProcessClosurePrimitives(compiler, preprocessorSymbolTable, options.brokenClosureRequiresLevel); [EOL]     return new HotSwapCompilerPass() { [EOL]  [EOL]         @Override [EOL]         public void process(Node externs, Node root) { [EOL]             pass.process(externs, root); [EOL]             exportedNames = pass.getExportedVariableNames(); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void hotSwapScript(Node scriptRoot, Node originalRoot) { [EOL]             pass.hotSwapScript(scriptRoot, originalRoot); [EOL]         } [EOL]     }; [EOL] } <line_num>: 911,930
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new ExpandJqueryAliases(compiler); [EOL] } <line_num>: 935,938
@Override [EOL] protected CompilerPass create(final AbstractCompiler compiler) { [EOL]     return new ReplaceMessages(compiler, options.messageBundle, true, JsMessage.Style.getFromParams(true, false), false); [EOL] } <line_num>: 947,957
@Override [EOL] protected CompilerPass create(final AbstractCompiler compiler) { [EOL]     return new ReplaceMessagesForChrome(compiler, new GoogleJsMessageIdGenerator(options.tcProjectId), true, JsMessage.Style.getFromParams(true, false)); [EOL] } <line_num>: 962,970
@Override [EOL] protected HotSwapCompilerPass create(AbstractCompiler compiler) { [EOL]     maybeInitializePreprocessorSymbolTable(compiler); [EOL]     return new ScopedAliases(compiler, preprocessorSymbolTable, options.getAliasTransformationHandler()); [EOL] } <line_num>: 976,983
@Override [EOL] protected HotSwapCompilerPass create(AbstractCompiler compiler) { [EOL]     return new ClosureRewriteClass(compiler); [EOL] } <line_num>: 989,992
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     String blacklist = options.checkMissingGetCssNameBlacklist; [EOL]     Preconditions.checkState(blacklist != null && !blacklist.isEmpty(), "Not checking use of goog.getCssName because of empty blacklist."); [EOL]     return new CheckMissingGetCssName(compiler, options.checkMissingGetCssNameLevel, blacklist); [EOL] } <line_num>: 998,1005
@Override [EOL] public void process(Node externs, Node jsRoot) { [EOL]     Map<String, Integer> newCssNames = null; [EOL]     if (options.gatherCssNames) { [EOL]         newCssNames = Maps.newHashMap(); [EOL]     } [EOL]     ReplaceCssNames pass = new ReplaceCssNames(compiler, newCssNames, options.cssRenamingWhitelist); [EOL]     pass.process(externs, jsRoot); [EOL]     cssNames = newCssNames; [EOL] } <line_num>: 1018,1030
@Override [EOL] protected CompilerPass create(final AbstractCompiler compiler) { [EOL]     return new CompilerPass() { [EOL]  [EOL]         @Override [EOL]         public void process(Node externs, Node jsRoot) { [EOL]             Map<String, Integer> newCssNames = null; [EOL]             if (options.gatherCssNames) { [EOL]                 newCssNames = Maps.newHashMap(); [EOL]             } [EOL]             ReplaceCssNames pass = new ReplaceCssNames(compiler, newCssNames, options.cssRenamingWhitelist); [EOL]             pass.process(externs, jsRoot); [EOL]             cssNames = newCssNames; [EOL]         } [EOL]     }; [EOL] } <line_num>: 1015,1032
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new CreateSyntheticBlocks(compiler, options.syntheticBlockStartMarker, options.syntheticBlockEndMarker); [EOL] } <line_num>: 1041,1046
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     final boolean late = false; [EOL]     return new PeepholeOptimizationsPass(compiler, new PeepholeSubstituteAlternateSyntax(late), new PeepholeReplaceKnownMethods(late), new PeepholeRemoveDeadCode(), new PeepholeFoldConstants(late), new PeepholeCollectPropertyAssignments()); [EOL] } <line_num>: 1052,1061
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     final boolean late = true; [EOL]     return new PeepholeOptimizationsPass(compiler, new StatementFusion(), new PeepholeRemoveDeadCode(), new PeepholeSubstituteAlternateSyntax(late), new PeepholeReplaceKnownMethods(late), new PeepholeFoldConstants(late), new ReorderConstantExpression()); [EOL] } <line_num>: 1067,1077
@Override [EOL] protected HotSwapCompilerPass create(AbstractCompiler compiler) { [EOL]     return new VarCheck(compiler); [EOL] } <line_num>: 1083,1086
@Override [EOL] public void process(Node externs, Node root) { [EOL]     pass.process(externs, root); [EOL]     compiler.setHasRegExpGlobalReferences(pass.isGlobalRegExpPropertiesUsed()); [EOL] } <line_num>: 1097,1102
@Override [EOL] protected CompilerPass create(final AbstractCompiler compiler) { [EOL]     final CheckRegExp pass = new CheckRegExp(compiler); [EOL]     return new CompilerPass() { [EOL]  [EOL]         @Override [EOL]         public void process(Node externs, Node root) { [EOL]             pass.process(externs, root); [EOL]             compiler.setHasRegExpGlobalReferences(pass.isGlobalRegExpPropertiesUsed()); [EOL]         } [EOL]     }; [EOL] } <line_num>: 1092,1104
@Override [EOL] protected HotSwapCompilerPass create(AbstractCompiler compiler) { [EOL]     return new VariableReferenceCheck(compiler, options.aggressiveVarCheck); [EOL] } <line_num>: 1110,1114
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new ObjectPropertyStringPreprocess(compiler); [EOL] } <line_num>: 1120,1123
@Override [EOL] protected HotSwapCompilerPass create(AbstractCompiler compiler) { [EOL]     return new GlobalTypeResolver(compiler); [EOL] } <line_num>: 1129,1132
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new ClearTypedScope(); [EOL] } <line_num>: 1138,1141
@Override [EOL] public void process(Node externs, Node root) { [EOL]     Preconditions.checkNotNull(topScope); [EOL]     Preconditions.checkNotNull(getTypedScopeCreator()); [EOL]     makeTypeInference(compiler).process(externs, root); [EOL] } <line_num>: 1150,1156
@Override [EOL] public void hotSwapScript(Node scriptRoot, Node originalRoot) { [EOL]     makeTypeInference(compiler).inferAllScopes(scriptRoot); [EOL] } <line_num>: 1157,1160
@Override [EOL] protected HotSwapCompilerPass create(final AbstractCompiler compiler) { [EOL]     return new HotSwapCompilerPass() { [EOL]  [EOL]         @Override [EOL]         public void process(Node externs, Node root) { [EOL]             Preconditions.checkNotNull(topScope); [EOL]             Preconditions.checkNotNull(getTypedScopeCreator()); [EOL]             makeTypeInference(compiler).process(externs, root); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void hotSwapScript(Node scriptRoot, Node originalRoot) { [EOL]             makeTypeInference(compiler).inferAllScopes(scriptRoot); [EOL]         } [EOL]     }; [EOL] } <line_num>: 1147,1162
@Override [EOL] public void process(Node externs, Node root) { [EOL]     Preconditions.checkNotNull(topScope); [EOL]     Preconditions.checkNotNull(getTypedScopeCreator()); [EOL]     makeInferJsDocInfo(compiler).process(externs, root); [EOL] } <line_num>: 1170,1176
@Override [EOL] public void hotSwapScript(Node scriptRoot, Node originalRoot) { [EOL]     makeInferJsDocInfo(compiler).hotSwapScript(scriptRoot, originalRoot); [EOL] } <line_num>: 1177,1180
@Override [EOL] protected HotSwapCompilerPass create(final AbstractCompiler compiler) { [EOL]     return new HotSwapCompilerPass() { [EOL]  [EOL]         @Override [EOL]         public void process(Node externs, Node root) { [EOL]             Preconditions.checkNotNull(topScope); [EOL]             Preconditions.checkNotNull(getTypedScopeCreator()); [EOL]             makeInferJsDocInfo(compiler).process(externs, root); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void hotSwapScript(Node scriptRoot, Node originalRoot) { [EOL]             makeInferJsDocInfo(compiler).hotSwapScript(scriptRoot, originalRoot); [EOL]         } [EOL]     }; [EOL] } <line_num>: 1167,1182
@Override [EOL] public void process(Node externs, Node root) { [EOL]     Preconditions.checkNotNull(topScope); [EOL]     Preconditions.checkNotNull(getTypedScopeCreator()); [EOL]     TypeCheck check = makeTypeCheck(compiler); [EOL]     check.process(externs, root); [EOL]     compiler.getErrorManager().setTypedPercent(check.getTypedPercent()); [EOL] } <line_num>: 1191,1199
@Override [EOL] public void hotSwapScript(Node scriptRoot, Node originalRoot) { [EOL]     makeTypeCheck(compiler).check(scriptRoot, false); [EOL] } <line_num>: 1200,1203
@Override [EOL] protected HotSwapCompilerPass create(final AbstractCompiler compiler) { [EOL]     return new HotSwapCompilerPass() { [EOL]  [EOL]         @Override [EOL]         public void process(Node externs, Node root) { [EOL]             Preconditions.checkNotNull(topScope); [EOL]             Preconditions.checkNotNull(getTypedScopeCreator()); [EOL]             TypeCheck check = makeTypeCheck(compiler); [EOL]             check.process(externs, root); [EOL]             compiler.getErrorManager().setTypedPercent(check.getTypedPercent()); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void hotSwapScript(Node scriptRoot, Node originalRoot) { [EOL]             makeTypeCheck(compiler).check(scriptRoot, false); [EOL]         } [EOL]     }; [EOL] } <line_num>: 1188,1205
@Override [EOL] protected HotSwapCompilerPass create(AbstractCompiler compiler) { [EOL]     List<Callback> callbacks = Lists.newArrayList(); [EOL]     if (options.checkUnreachableCode.isOn()) { [EOL]         callbacks.add(new CheckUnreachableCode(compiler, options.checkUnreachableCode)); [EOL]     } [EOL]     if (options.checkMissingReturn.isOn() && options.checkTypes) { [EOL]         callbacks.add(new CheckMissingReturn(compiler, options.checkMissingReturn)); [EOL]     } [EOL]     return combineChecks(compiler, callbacks); [EOL] } <line_num>: 1214,1226
@Override [EOL] protected HotSwapCompilerPass create(AbstractCompiler compiler) { [EOL]     return new CheckAccessControls(compiler); [EOL] } <line_num>: 1232,1235
private static HotSwapCompilerPass combineChecks(AbstractCompiler compiler, List<Callback> callbacks) { [EOL]     Preconditions.checkArgument(callbacks.size() > 0); [EOL]     Callback[] array = callbacks.toArray(new Callback[callbacks.size()]); [EOL]     return new CombinedCompilerPass(compiler, array); [EOL] } <line_num>: 1239,1244
@Override [EOL] public void process(Node externs, Node root) { [EOL]     if (topScope == null) { [EOL]         regenerateGlobalTypedScope(compiler, root.getParent()); [EOL]     } else { [EOL]         compiler.getTypeRegistry().resolveTypesInScope(topScope); [EOL]     } [EOL] } <line_num>: 1254,1261
@Override [EOL] public void hotSwapScript(Node scriptRoot, Node originalRoot) { [EOL]     patchGlobalTypedScope(compiler, scriptRoot); [EOL] } <line_num>: 1262,1265
@Override [EOL] public void process(Node externs, Node root) { [EOL]     clearTypedScope(); [EOL] } <line_num>: 1270,1273
@Override [EOL] public void process(Node externs, Node jsRoot) { [EOL]     namespaceForChecks = new GlobalNamespace(compiler, externs, jsRoot); [EOL]     new CheckGlobalNames(compiler, options.checkGlobalNamesLevel).injectNamespace(namespaceForChecks).process(externs, jsRoot); [EOL] } <line_num>: 1282,1290
@Override [EOL] protected CompilerPass create(final AbstractCompiler compiler) { [EOL]     return new CompilerPass() { [EOL]  [EOL]         @Override [EOL]         public void process(Node externs, Node jsRoot) { [EOL]             namespaceForChecks = new GlobalNamespace(compiler, externs, jsRoot); [EOL]             new CheckGlobalNames(compiler, options.checkGlobalNamesLevel).injectNamespace(namespaceForChecks).process(externs, jsRoot); [EOL]         } [EOL]     }; [EOL] } <line_num>: 1279,1292
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new StrictModeCheck(compiler, !options.checkSymbols, !options.checkCaja); [EOL] } <line_num>: 1298,1303
@Override [EOL] public void process(Node externs, Node jsRoot) { [EOL]     new ProcessTweaks(compiler, options.getTweakProcessing().shouldStrip(), options.getTweakReplacements()).process(externs, jsRoot); [EOL] } <line_num>: 1311,1316
@Override [EOL] protected CompilerPass create(final AbstractCompiler compiler) { [EOL]     return new CompilerPass() { [EOL]  [EOL]         @Override [EOL]         public void process(Node externs, Node jsRoot) { [EOL]             new ProcessTweaks(compiler, options.getTweakProcessing().shouldStrip(), options.getTweakReplacements()).process(externs, jsRoot); [EOL]         } [EOL]     }; [EOL] } <line_num>: 1308,1318
@Override [EOL] public void process(Node externs, Node jsRoot) { [EOL]     Map<String, Node> replacements = getAdditionalReplacements(options); [EOL]     replacements.putAll(options.getDefineReplacements()); [EOL]     new ProcessDefines(compiler, replacements).injectNamespace(namespaceForChecks).process(externs, jsRoot); [EOL] } <line_num>: 1326,1333
@Override [EOL] protected CompilerPass create(final AbstractCompiler compiler) { [EOL]     return new CompilerPass() { [EOL]  [EOL]         @Override [EOL]         public void process(Node externs, Node jsRoot) { [EOL]             Map<String, Node> replacements = getAdditionalReplacements(options); [EOL]             replacements.putAll(options.getDefineReplacements()); [EOL]             new ProcessDefines(compiler, replacements).injectNamespace(namespaceForChecks).process(externs, jsRoot); [EOL]         } [EOL]     }; [EOL] } <line_num>: 1323,1335
@Override [EOL] public void process(Node externs, Node jsRoot) { [EOL]     namespaceForChecks = null; [EOL] } <line_num>: 1344,1349
@Override [EOL] public void hotSwapScript(Node scriptRoot, Node originalRoot) { [EOL]     process(null, null); [EOL] } <line_num>: 1351,1354
@Override [EOL] protected HotSwapCompilerPass create(final AbstractCompiler compiler) { [EOL]     return new HotSwapCompilerPass() { [EOL]  [EOL]         @Override [EOL]         public void process(Node externs, Node jsRoot) { [EOL]             namespaceForChecks = null; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void hotSwapScript(Node scriptRoot, Node originalRoot) { [EOL]             process(null, null); [EOL]         } [EOL]     }; [EOL] } <line_num>: 1341,1356
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new ConstCheck(compiler); [EOL] } <line_num>: 1361,1364
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return ((functionNames = new FunctionNames(compiler))); [EOL] } <line_num>: 1370,1373
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new IgnoreCajaProperties(compiler); [EOL] } <line_num>: 1379,1382
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new RuntimeTypeCheck(compiler, options.runtimeTypeCheckLogFunction); [EOL] } <line_num>: 1388,1392
@Override [EOL] public void process(Node externs, Node root) { [EOL]     ReplaceIdGenerators pass = new ReplaceIdGenerators(compiler, options.idGenerators, options.generatePseudoNames, options.idGeneratorsMapSerialized); [EOL]     pass.process(externs, root); [EOL]     idGeneratorMap = pass.getSerializedIdMappings(); [EOL] } <line_num>: 1401,1408
@Override [EOL] protected CompilerPass create(final AbstractCompiler compiler) { [EOL]     return new CompilerPass() { [EOL]  [EOL]         @Override [EOL]         public void process(Node externs, Node root) { [EOL]             ReplaceIdGenerators pass = new ReplaceIdGenerators(compiler, options.idGenerators, options.generatePseudoNames, options.idGeneratorsMapSerialized); [EOL]             pass.process(externs, root); [EOL]             idGeneratorMap = pass.getSerializedIdMappings(); [EOL]         } [EOL]     }; [EOL] } <line_num>: 1398,1410
@Override [EOL] public void process(Node externs, Node root) { [EOL]     ReplaceStrings pass = new ReplaceStrings(compiler, options.replaceStringsPlaceholderToken, options.replaceStringsFunctionDescriptions, options.replaceStringsReservedStrings, options.replaceStringsInputMap); [EOL]     pass.process(externs, root); [EOL]     stringMap = pass.getStringMap(); [EOL] } <line_num>: 1418,1427
@Override [EOL] protected CompilerPass create(final AbstractCompiler compiler) { [EOL]     return new CompilerPass() { [EOL]  [EOL]         @Override [EOL]         public void process(Node externs, Node root) { [EOL]             ReplaceStrings pass = new ReplaceStrings(compiler, options.replaceStringsPlaceholderToken, options.replaceStringsFunctionDescriptions, options.replaceStringsReservedStrings, options.replaceStringsInputMap); [EOL]             pass.process(externs, root); [EOL]             stringMap = pass.getStringMap(); [EOL]         } [EOL]     }; [EOL] } <line_num>: 1415,1429
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new OptimizeArgumentsArray(compiler); [EOL] } <line_num>: 1435,1438
@Override [EOL] protected CompilerPass create(final AbstractCompiler compiler) { [EOL]     return new ClosureCodeRemoval(compiler, options.removeAbstractMethods, options.removeClosureAsserts); [EOL] } <line_num>: 1444,1448
@Override [EOL] protected CompilerPass create(final AbstractCompiler compiler) { [EOL]     return new ClosureOptimizePrimitives(compiler); [EOL] } <line_num>: 1454,1457
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new RescopeGlobalSymbols(compiler, options.renamePrefixNamespace); [EOL] } <line_num>: 1463,1466
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new CollapseProperties(compiler, options.collapsePropertiesOnExternTypes, !isInliningForbidden()); [EOL] } <line_num>: 1472,1477
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new InlineObjectLiterals(compiler, compiler.getUniqueNameIdSupplier()); [EOL] } <line_num>: 1483,1487
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     if (!options.checkTypes) { [EOL]         return new ErrorPass(compiler, TIGHTEN_TYPES_WITHOUT_TYPE_CHECK); [EOL]     } [EOL]     tightenTypes = new TightenTypes(compiler); [EOL]     return tightenTypes; [EOL] } <line_num>: 1496,1503
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     if (tightenTypes == null) { [EOL]         return DisambiguateProperties.forJSTypeSystem(compiler, options.propertyInvalidationErrors); [EOL]     } else { [EOL]         return DisambiguateProperties.forConcreteTypeSystem(compiler, tightenTypes, options.propertyInvalidationErrors); [EOL]     } [EOL] } <line_num>: 1509,1518
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new ChainCalls(compiler); [EOL] } <line_num>: 1525,1528
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new DevirtualizePrototypeMethods(compiler); [EOL] } <line_num>: 1537,1540
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     OptimizeCalls passes = new OptimizeCalls(compiler); [EOL]     if (options.optimizeReturns) { [EOL]         passes.addPass(new OptimizeReturns(compiler)); [EOL]     } [EOL]     if (options.optimizeParameters) { [EOL]         passes.addPass(new OptimizeParameters(compiler)); [EOL]     } [EOL]     if (options.optimizeCalls) { [EOL]         boolean removeOnlyLocals = options.removeUnusedLocalVars && !options.removeUnusedVars; [EOL]         boolean preserveAnonymousFunctionNames = options.anonymousFunctionNaming != AnonymousFunctionNamingPolicy.OFF; [EOL]         passes.addPass(new RemoveUnusedVars(compiler, !removeOnlyLocals, preserveAnonymousFunctionNames, true)); [EOL]     } [EOL]     return passes; [EOL] } <line_num>: 1549,1573
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new PureFunctionIdentifier.Driver(compiler, options.debugFunctionSideEffectsPath, false); [EOL] } <line_num>: 1582,1586
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new MarkNoSideEffectCalls(compiler); [EOL] } <line_num>: 1595,1598
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     if (isInliningForbidden()) { [EOL]         return new ErrorPass(compiler, CANNOT_USE_PROTOTYPE_AND_VAR); [EOL]     } else { [EOL]         InlineVariables.Mode mode; [EOL]         if (options.inlineVariables) { [EOL]             mode = InlineVariables.Mode.ALL; [EOL]         } else if (options.inlineLocalVariables) { [EOL]             mode = InlineVariables.Mode.LOCALS_ONLY; [EOL]         } else { [EOL]             throw new IllegalStateException("No variable inlining option set."); [EOL]         } [EOL]         return new InlineVariables(compiler, mode, true); [EOL]     } [EOL] } <line_num>: 1604,1623
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new InlineVariables(compiler, InlineVariables.Mode.CONSTANTS_ONLY, true); [EOL] } <line_num>: 1629,1633
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new MinimizeExitPoints(compiler); [EOL] } <line_num>: 1641,1644
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new UnreachableCodeElimination(compiler, true); [EOL] } <line_num>: 1652,1655
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new RemoveUnusedPrototypeProperties(compiler, options.removeUnusedPrototypePropertiesInExterns, !options.removeUnusedVars); [EOL] } <line_num>: 1663,1668
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new RemoveUnusedClassProperties(compiler); [EOL] } <line_num>: 1676,1679
@Override [EOL] public void process(Node externs, Node root) { [EOL]     NameAnalyzer na = new NameAnalyzer(compiler, false); [EOL]     na.process(externs, root); [EOL]     String reportPath = options.reportPath; [EOL]     if (reportPath != null) { [EOL]         try { [EOL]             Files.write(na.getHtmlReport(), new File(reportPath), Charsets.UTF_8); [EOL]         } catch (IOException e) { [EOL]             compiler.report(JSError.make(REPORT_PATH_IO_ERROR, reportPath)); [EOL]         } [EOL]     } [EOL]     if (options.smartNameRemoval) { [EOL]         na.removeUnreferenced(); [EOL]     } [EOL] } <line_num>: 1690,1708
@Override [EOL] protected CompilerPass create(final AbstractCompiler compiler) { [EOL]     return new CompilerPass() { [EOL]  [EOL]         @Override [EOL]         public void process(Node externs, Node root) { [EOL]             NameAnalyzer na = new NameAnalyzer(compiler, false); [EOL]             na.process(externs, root); [EOL]             String reportPath = options.reportPath; [EOL]             if (reportPath != null) { [EOL]                 try { [EOL]                     Files.write(na.getHtmlReport(), new File(reportPath), Charsets.UTF_8); [EOL]                 } catch (IOException e) { [EOL]                     compiler.report(JSError.make(REPORT_PATH_IO_ERROR, reportPath)); [EOL]                 } [EOL]             } [EOL]             if (options.smartNameRemoval) { [EOL]                 na.removeUnreferenced(); [EOL]             } [EOL]         } [EOL]     }; [EOL] } <line_num>: 1687,1710
@Override [EOL] public void process(Node externs, Node root) { [EOL]     NameAnalyzer na = new NameAnalyzer(compiler, false); [EOL]     na.process(externs, root); [EOL]     na.removeUnreferenced(); [EOL] } <line_num>: 1721,1726
@Override [EOL] protected CompilerPass create(final AbstractCompiler compiler) { [EOL]     return new CompilerPass() { [EOL]  [EOL]         @Override [EOL]         public void process(Node externs, Node root) { [EOL]             NameAnalyzer na = new NameAnalyzer(compiler, false); [EOL]             na.process(externs, root); [EOL]             na.removeUnreferenced(); [EOL]         } [EOL]     }; [EOL] } <line_num>: 1718,1728
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new InlineSimpleMethods(compiler); [EOL] } <line_num>: 1734,1737
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new DeadAssignmentsElimination(compiler); [EOL] } <line_num>: 1743,1746
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     boolean enableBlockInlining = !isInliningForbidden(); [EOL]     return new InlineFunctions(compiler, compiler.getUniqueNameIdSupplier(), options.inlineFunctions, options.inlineLocalFunctions, enableBlockInlining, options.assumeStrictThis() || options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT, true); [EOL] } <line_num>: 1752,1764
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new InlineProperties(compiler); [EOL] } <line_num>: 1770,1773
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     boolean removeOnlyLocals = options.removeUnusedLocalVars && !options.removeUnusedVars; [EOL]     boolean preserveAnonymousFunctionNames = options.anonymousFunctionNaming != AnonymousFunctionNamingPolicy.OFF; [EOL]     return new RemoveUnusedVars(compiler, !removeOnlyLocals, preserveAnonymousFunctionNames, false); [EOL] } <line_num>: 1779,1790
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new CrossModuleCodeMotion(compiler, compiler.getModuleGraph()); [EOL] } <line_num>: 1798,1801
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new CrossModuleMethodMotion(compiler, crossModuleIdGenerator, options.removeUnusedPrototypePropertiesInExterns); [EOL] } <line_num>: 1809,1816
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new SpecializeModule(compiler, devirtualizePrototypeMethods, inlineFunctions, removeUnusedPrototypeProperties); [EOL] } <line_num>: 1824,1828
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new FlowSensitiveInlineVariables(compiler); [EOL] } <line_num>: 1834,1837
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new CoalesceVariableNames(compiler, options.generatePseudoNames); [EOL] } <line_num>: 1843,1846
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new PeepholeOptimizationsPass(compiler, new ExploitAssigns()); [EOL] } <line_num>: 1854,1858
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new CollapseVariableDeclarations(compiler); [EOL] } <line_num>: 1867,1870
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new GroupVariableDeclarations(compiler); [EOL] } <line_num>: 1878,1881
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new ExtractPrototypeMemberDeclarations(compiler, Pattern.USE_GLOBAL_TEMP); [EOL] } <line_num>: 1889,1893
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new FunctionRewriter(compiler); [EOL] } <line_num>: 1899,1902
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new CollapseAnonymousFunctions(compiler); [EOL] } <line_num>: 1908,1911
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new MoveFunctionDeclarations(compiler); [EOL] } <line_num>: 1917,1920
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new NameAnonymousFunctions(compiler); [EOL] } <line_num>: 1925,1928
@Override [EOL] public void process(Node externs, Node root) { [EOL]     NameAnonymousFunctionsMapped naf = new NameAnonymousFunctionsMapped(compiler, options.inputAnonymousFunctionNamingMap); [EOL]     naf.process(externs, root); [EOL]     anonymousFunctionNameMap = naf.getFunctionMap(); [EOL] } <line_num>: 1936,1942
@Override [EOL] protected CompilerPass create(final AbstractCompiler compiler) { [EOL]     return new CompilerPass() { [EOL]  [EOL]         @Override [EOL]         public void process(Node externs, Node root) { [EOL]             NameAnonymousFunctionsMapped naf = new NameAnonymousFunctionsMapped(compiler, options.inputAnonymousFunctionNamingMap); [EOL]             naf.process(externs, root); [EOL]             anonymousFunctionNameMap = naf.getFunctionMap(); [EOL]         } [EOL]     }; [EOL] } <line_num>: 1933,1944
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new AliasExternals(compiler, compiler.getModuleGraph(), options.unaliasableGlobals, options.aliasableGlobals); [EOL] } <line_num>: 1949,1953
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new AliasStrings(compiler, compiler.getModuleGraph(), options.aliasAllStrings ? null : options.aliasableStrings, options.aliasStringsBlacklist, options.outputJsStringUsage); [EOL] } <line_num>: 1961,1969
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new AliasKeywords(compiler); [EOL] } <line_num>: 1974,1977
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new ObjectPropertyStringPostprocess(compiler); [EOL] } <line_num>: 1983,1986
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new AmbiguateProperties(compiler, options.anonymousFunctionNaming.getReservedCharacters()); [EOL] } <line_num>: 1995,1999
@Override [EOL] public void process(Node externs, Node root) { [EOL]     compiler.setLifeCycleStage(LifeCycleStage.RAW); [EOL] } <line_num>: 2010,2012
@Override [EOL] protected CompilerPass create(final AbstractCompiler compiler) { [EOL]     return new CompilerPass() { [EOL]  [EOL]         @Override [EOL]         public void process(Node externs, Node root) { [EOL]             compiler.setLifeCycleStage(LifeCycleStage.RAW); [EOL]         } [EOL]     }; [EOL] } <line_num>: 2007,2014
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new Denormalize(compiler); [EOL] } <line_num>: 2019,2022
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return MakeDeclaredNamesUnique.getContextualRenameInverter(compiler); [EOL] } <line_num>: 2028,2031
@Override [EOL] public void process(Node externs, Node root) { [EOL]     propertyMap = runPropertyRenaming(compiler, prevPropertyMap, externs, root); [EOL] } <line_num>: 2043,2046
@Override [EOL] protected CompilerPass create(final AbstractCompiler compiler) { [EOL]     final VariableMap prevPropertyMap = options.inputPropertyMap; [EOL]     return new CompilerPass() { [EOL]  [EOL]         @Override [EOL]         public void process(Node externs, Node root) { [EOL]             propertyMap = runPropertyRenaming(compiler, prevPropertyMap, externs, root); [EOL]         } [EOL]     }; [EOL] } <line_num>: 2039,2048
private VariableMap runPropertyRenaming(AbstractCompiler compiler, VariableMap prevPropertyMap, Node externs, Node root) { [EOL]     char[] reservedChars = options.anonymousFunctionNaming.getReservedCharacters(); [EOL]     switch(options.propertyRenaming) { [EOL]         case HEURISTIC: [EOL]             RenamePrototypes rproto = new RenamePrototypes(compiler, false, reservedChars, prevPropertyMap); [EOL]             rproto.process(externs, root); [EOL]             return rproto.getPropertyMap(); [EOL]         case AGGRESSIVE_HEURISTIC: [EOL]             RenamePrototypes rproto2 = new RenamePrototypes(compiler, true, reservedChars, prevPropertyMap); [EOL]             rproto2.process(externs, root); [EOL]             return rproto2.getPropertyMap(); [EOL]         case ALL_UNQUOTED: [EOL]             RenameProperties rprop = new RenameProperties(compiler, options.propertyAffinity, options.generatePseudoNames, prevPropertyMap, reservedChars); [EOL]             rprop.process(externs, root); [EOL]             return rprop.getPropertyMap(); [EOL]         default: [EOL]             throw new IllegalStateException("Unrecognized property renaming policy"); [EOL]     } [EOL] } <line_num>: 2051,2080
@Override [EOL] public void process(Node externs, Node root) { [EOL]     variableMap = runVariableRenaming(compiler, prevVariableMap, externs, root); [EOL] } <line_num>: 2088,2091
@Override [EOL] protected CompilerPass create(final AbstractCompiler compiler) { [EOL]     final VariableMap prevVariableMap = options.inputVariableMap; [EOL]     return new CompilerPass() { [EOL]  [EOL]         @Override [EOL]         public void process(Node externs, Node root) { [EOL]             variableMap = runVariableRenaming(compiler, prevVariableMap, externs, root); [EOL]         } [EOL]     }; [EOL] } <line_num>: 2084,2093
private VariableMap runVariableRenaming(AbstractCompiler compiler, VariableMap prevVariableMap, Node externs, Node root) { [EOL]     char[] reservedChars = options.anonymousFunctionNaming.getReservedCharacters(); [EOL]     boolean preserveAnonymousFunctionNames = options.anonymousFunctionNaming != AnonymousFunctionNamingPolicy.OFF; [EOL]     Set<String> reservedNames = Sets.newHashSet(); [EOL]     if (exportedNames != null) { [EOL]         reservedNames.addAll(exportedNames); [EOL]     } [EOL]     reservedNames.addAll(ParserRunner.getReservedVars()); [EOL]     RenameVars rn = new RenameVars(compiler, options.renamePrefix, options.variableRenaming == VariableRenamingPolicy.LOCAL, preserveAnonymousFunctionNames, options.generatePseudoNames, options.shadowVariables, prevVariableMap, reservedChars, reservedNames); [EOL]     rn.process(externs, root); [EOL]     return rn.getVariableMap(); [EOL] } <line_num>: 2096,2120
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new RenameLabels(compiler); [EOL] } <line_num>: 2124,2127
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new ConvertToDottedProperties(compiler); [EOL] } <line_num>: 2133,2136
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new AstValidator(); [EOL] } <line_num>: 2141,2144
@Override [EOL] protected CompilerPass create(AbstractCompiler compiler) { [EOL]     return new VarCheck(compiler, true); [EOL] } <line_num>: 2149,2152
@Override [EOL] public void process(Node externs, Node root) { [EOL]     try { [EOL]         FileReader templateFile = new FileReader(options.instrumentationTemplate); [EOL]         (new InstrumentFunctions(compiler, functionNames, options.instrumentationTemplate, options.appNameStr, templateFile)).process(externs, root); [EOL]     } catch (IOException e) { [EOL]         compiler.report(JSError.make(AbstractCompiler.READ_ERROR, options.instrumentationTemplate)); [EOL]     } [EOL] } <line_num>: 2161,2175
@Override [EOL] protected CompilerPass create(final AbstractCompiler compiler) { [EOL]     return new CompilerPass() { [EOL]  [EOL]         @Override [EOL]         public void process(Node externs, Node root) { [EOL]             try { [EOL]                 FileReader templateFile = new FileReader(options.instrumentationTemplate); [EOL]                 (new InstrumentFunctions(compiler, functionNames, options.instrumentationTemplate, options.appNameStr, templateFile)).process(externs, root); [EOL]             } catch (IOException e) { [EOL]                 compiler.report(JSError.make(AbstractCompiler.READ_ERROR, options.instrumentationTemplate)); [EOL]             } [EOL]         } [EOL]     }; [EOL] } <line_num>: 2158,2177
@Override [EOL] protected CompilerPass create(final AbstractCompiler compiler) { [EOL]     return runInSerial(); [EOL] } <line_num>: 2185,2188
static PassFactory createEmptyPass(String name) { [EOL]     return new PassFactory(name, true) { [EOL]  [EOL]         @Override [EOL]         protected CompilerPass create(final AbstractCompiler compiler) { [EOL]             return runInSerial(); [EOL]         } [EOL]     }; [EOL] } <line_num>: 2183,2190
@Override [EOL] protected CompilerPass create(final AbstractCompiler compiler) { [EOL]     return runInSerial(options.customPasses.get(executionTime)); [EOL] } <line_num>: 2198,2201
private PassFactory getCustomPasses(final CustomPassExecutionTime executionTime) { [EOL]     return new PassFactory("runCustomPasses", true) { [EOL]  [EOL]         @Override [EOL]         protected CompilerPass create(final AbstractCompiler compiler) { [EOL]             return runInSerial(options.customPasses.get(executionTime)); [EOL]         } [EOL]     }; [EOL] } <line_num>: 2195,2203
private boolean isInliningForbidden() { [EOL]     return options.propertyRenaming == PropertyRenamingPolicy.HEURISTIC || options.propertyRenaming == PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC; [EOL] } <line_num>: 2209,2213
private static CompilerPass runInSerial(final CompilerPass... passes) { [EOL]     return runInSerial(Lists.newArrayList(passes)); [EOL] } <line_num>: 2216,2218
@Override [EOL] public void process(Node externs, Node root) { [EOL]     for (CompilerPass pass : passes) { [EOL]         pass.process(externs, root); [EOL]     } [EOL] } <line_num>: 2224,2228
private static CompilerPass runInSerial(final Collection<CompilerPass> passes) { [EOL]     return new CompilerPass() { [EOL]  [EOL]         @Override [EOL]         public void process(Node externs, Node root) { [EOL]             for (CompilerPass pass : passes) { [EOL]                 pass.process(externs, root); [EOL]             } [EOL]         } [EOL]     }; [EOL] } <line_num>: 2221,2230
@VisibleForTesting [EOL] static Map<String, Node> getAdditionalReplacements(CompilerOptions options) { [EOL]     Map<String, Node> additionalReplacements = Maps.newHashMap(); [EOL]     if (options.markAsCompiled || options.closurePass) { [EOL]         additionalReplacements.put(COMPILED_CONSTANT_NAME, IR.trueNode()); [EOL]     } [EOL]     if (options.closurePass && options.locale != null) { [EOL]         additionalReplacements.put(CLOSURE_LOCALE_CONSTANT_NAME, IR.string(options.locale)); [EOL]     } [EOL]     return additionalReplacements; [EOL] } <line_num>: 2232,2247
@Override [EOL] public void process(Node externs, Node jsRoot) { [EOL]     NameReferenceGraphConstruction gc = new NameReferenceGraphConstruction(compiler); [EOL]     gc.process(externs, jsRoot); [EOL]     String graphFileName = options.nameReferenceGraphPath; [EOL]     try { [EOL]         Files.write(DotFormatter.toDot(gc.getNameReferenceGraph()), new File(graphFileName), Charsets.UTF_8); [EOL]     } catch (IOException e) { [EOL]         compiler.report(JSError.make(NAME_REF_GRAPH_FILE_ERROR, e.getMessage(), graphFileName)); [EOL]     } [EOL] } <line_num>: 2254,2269
@Override [EOL] protected CompilerPass create(final AbstractCompiler compiler) { [EOL]     return new CompilerPass() { [EOL]  [EOL]         @Override [EOL]         public void process(Node externs, Node jsRoot) { [EOL]             NameReferenceGraphConstruction gc = new NameReferenceGraphConstruction(compiler); [EOL]             gc.process(externs, jsRoot); [EOL]             String graphFileName = options.nameReferenceGraphPath; [EOL]             try { [EOL]                 Files.write(DotFormatter.toDot(gc.getNameReferenceGraph()), new File(graphFileName), Charsets.UTF_8); [EOL]             } catch (IOException e) { [EOL]                 compiler.report(JSError.make(NAME_REF_GRAPH_FILE_ERROR, e.getMessage(), graphFileName)); [EOL]             } [EOL]         } [EOL]     }; [EOL] } <line_num>: 2251,2271
@Override [EOL] public void process(Node externs, Node jsRoot) { [EOL]     NameReferenceGraphConstruction gc = new NameReferenceGraphConstruction(compiler); [EOL]     String reportFileName = options.nameReferenceReportPath; [EOL]     try { [EOL]         NameReferenceGraphReport report = new NameReferenceGraphReport(gc.getNameReferenceGraph()); [EOL]         Files.write(report.getHtmlReport(), new File(reportFileName), Charsets.UTF_8); [EOL]     } catch (IOException e) { [EOL]         compiler.report(JSError.make(NAME_REF_REPORT_FILE_ERROR, e.getMessage(), reportFileName)); [EOL]     } [EOL] } <line_num>: 2279,2297
@Override [EOL] protected CompilerPass create(final AbstractCompiler compiler) { [EOL]     return new CompilerPass() { [EOL]  [EOL]         @Override [EOL]         public void process(Node externs, Node jsRoot) { [EOL]             NameReferenceGraphConstruction gc = new NameReferenceGraphConstruction(compiler); [EOL]             String reportFileName = options.nameReferenceReportPath; [EOL]             try { [EOL]                 NameReferenceGraphReport report = new NameReferenceGraphReport(gc.getNameReferenceGraph()); [EOL]                 Files.write(report.getHtmlReport(), new File(reportFileName), Charsets.UTF_8); [EOL]             } catch (IOException e) { [EOL]                 compiler.report(JSError.make(NAME_REF_REPORT_FILE_ERROR, e.getMessage(), reportFileName)); [EOL]             } [EOL]         } [EOL]     }; [EOL] } <line_num>: 2276,2299
@Override [EOL] protected abstract HotSwapCompilerPass create(AbstractCompiler compiler); <line_num>: 2311,2312
@Override [EOL] HotSwapCompilerPass getHotSwapPass(AbstractCompiler compiler) { [EOL]     return this.create(compiler); [EOL] } <line_num>: 2314,2317
