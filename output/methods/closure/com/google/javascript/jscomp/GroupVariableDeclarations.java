GroupVariableDeclarations(AbstractCompiler compiler) { [EOL]     this.compiler = compiler; [EOL] } <line_num>: 66,68
@Override [EOL] public void process(Node externs, Node root) { [EOL]     NodeTraversal.traverse(compiler, root, this); [EOL] } <line_num>: 70,73
@Override [EOL] public void enterScope(NodeTraversal t) { [EOL]     Set<Node> varNodes = Sets.newLinkedHashSet(); [EOL]     Iterator<Var> scopeVarIter = t.getScope().getVars(); [EOL]     while (scopeVarIter.hasNext()) { [EOL]         Node parentNode = scopeVarIter.next().getParentNode(); [EOL]         if (parentNode.isVar()) { [EOL]             varNodes.add(parentNode); [EOL]         } [EOL]     } [EOL]     if (varNodes.size() <= 1) { [EOL]         return; [EOL]     } [EOL]     Iterator<Node> varNodeIter = varNodes.iterator(); [EOL]     Node firstVarNode = varNodeIter.next(); [EOL]     while (varNodeIter.hasNext()) { [EOL]         Node varNode = varNodeIter.next(); [EOL]         applyGroupingToVar(firstVarNode, varNode); [EOL]     } [EOL] } <line_num>: 75,94
@Override [EOL] public void exitScope(NodeTraversal t) { [EOL] } <line_num>: 96,98
@Override [EOL] public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) { [EOL]     return true; [EOL] } <line_num>: 100,104
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL] } <line_num>: 106,108
private void applyGroupingToVar(Node firstVar, Node groupVar) { [EOL]     Node child = groupVar.getFirstChild(); [EOL]     Node initializedName = null; [EOL]     while (child != null) { [EOL]         if (child.hasChildren()) { [EOL]             if (initializedName != null) { [EOL]                 return; [EOL]             } [EOL]             initializedName = child; [EOL]         } [EOL]         child = child.getNext(); [EOL]     } [EOL]     Node groupVarParent = groupVar.getParent(); [EOL]     if (initializedName != null) { [EOL]         if (NodeUtil.isForIn(groupVarParent)) { [EOL]             return; [EOL]         } [EOL]         Node clone = initializedName.cloneNode(); [EOL]         groupVar.replaceChild(initializedName, clone); [EOL]         Node initializedVal = initializedName.removeFirstChild(); [EOL]         Node assignmentNode = IR.assign(initializedName, initializedVal); [EOL]         if (groupVarParent.isFor()) { [EOL]             groupVarParent.replaceChild(groupVar, assignmentNode); [EOL]         } else { [EOL]             Node exprNode = NodeUtil.newExpr(assignmentNode); [EOL]             groupVarParent.replaceChild(groupVar, exprNode); [EOL]         } [EOL]     } else { [EOL]         if (groupVarParent.isFor()) { [EOL]             if (NodeUtil.isForIn(groupVarParent)) { [EOL]                 Node nameNodeClone = groupVar.getFirstChild().cloneNode(); [EOL]                 groupVarParent.replaceChild(groupVar, nameNodeClone); [EOL]             } else { [EOL]                 Node emptyNode = IR.empty(); [EOL]                 groupVarParent.replaceChild(groupVar, emptyNode); [EOL]             } [EOL]         } else { [EOL]             groupVarParent.removeChild(groupVar); [EOL]         } [EOL]     } [EOL]     Node children = groupVar.removeChildren(); [EOL]     firstVar.addChildrenToBack(children); [EOL]     compiler.reportCodeChange(); [EOL] } <line_num>: 121,188
