AliasSet(String name1, String name2) { [EOL]     names.add(name1); [EOL]     names.add(name2); [EOL] } <line_num>: 151,154
JsNameRefNode(JsName name, Node node) { [EOL]     this.name = name; [EOL]     this.node = node; [EOL]     this.parent = node.getParent(); [EOL] } <line_num>: 302,306
PrototypeSetNode(JsName name, Node parent) { [EOL]     super(name, parent.getFirstChild()); [EOL]     Preconditions.checkState(parent.isAssign()); [EOL] } <line_num>: 353,357
SpecialReferenceNode(JsName name, Node node) { [EOL]     this.name = name; [EOL]     this.node = node; [EOL] } <line_num>: 388,391
ClassDefiningFunctionNode(JsName name, Node node) { [EOL]     super(name, node); [EOL]     Preconditions.checkState(node.isCall()); [EOL] } <line_num>: 420,423
InstanceOfCheckNode(JsName name, Node node) { [EOL]     super(name, node); [EOL]     Preconditions.checkState(node.isQualifiedName()); [EOL]     Preconditions.checkState(getParent().isInstanceOf()); [EOL] } <line_num>: 449,453
FindReferences() { [EOL]     nodesToKeep = Sets.newHashSet(); [EOL] } <line_num>: 756,758
NameAnalyzer(AbstractCompiler compiler, boolean removeUnreferenced) { [EOL]     this.compiler = compiler; [EOL]     this.removeUnreferenced = removeUnreferenced; [EOL]     this.globalNames = DEFAULT_GLOBAL_NAMES; [EOL]     this.changeProxy = new AstChangeProxy(); [EOL] } <line_num>: 1100,1105
@Override [EOL] public boolean traverseEdge(JsName from, RefType callSite, JsName to) { [EOL]     if (from.referenced && !to.referenced) { [EOL]         to.referenced = true; [EOL]         return true; [EOL]     } else { [EOL]         return false; [EOL]     } [EOL] } <line_num>: 172,182
@Override [EOL] public String toString() { [EOL]     StringBuilder out = new StringBuilder(); [EOL]     out.append(name); [EOL]     if (prototypeNames.size() > 0) { [EOL]         out.append(" (CLASS)\n"); [EOL]         out.append(" - FUNCTIONS: "); [EOL]         Iterator<String> pIter = prototypeNames.iterator(); [EOL]         while (pIter.hasNext()) { [EOL]             out.append(pIter.next()); [EOL]             if (pIter.hasNext()) { [EOL]                 out.append(", "); [EOL]             } [EOL]         } [EOL]     } [EOL]     return out.toString(); [EOL] } <line_num>: 239,257
@Override [EOL] public int compareTo(JsName rhs) { [EOL]     return this.name.compareTo(rhs.name); [EOL] } <line_num>: 259,262
JsName name(); <line_num>: 269,269
void remove(); <line_num>: 270,270
@Override [EOL] public JsName name() { [EOL]     return name; [EOL] } <line_num>: 308,311
@Override [EOL] public void remove() { [EOL]     Node containingNode = parent.getParent(); [EOL]     switch(parent.getType()) { [EOL]         case Token.VAR: [EOL]             Preconditions.checkState(parent.hasOneChild()); [EOL]             replaceWithRhs(containingNode, parent); [EOL]             break; [EOL]         case Token.FUNCTION: [EOL]             replaceWithRhs(containingNode, parent); [EOL]             break; [EOL]         case Token.ASSIGN: [EOL]             if (containingNode.isExprResult()) { [EOL]                 replaceWithRhs(containingNode.getParent(), containingNode); [EOL]             } else { [EOL]                 replaceWithRhs(containingNode, parent); [EOL]             } [EOL]             break; [EOL]         case Token.OBJECTLIT: [EOL]             break; [EOL]     } [EOL] } <line_num>: 313,339
@Override [EOL] public void remove() { [EOL]     Node gramps = parent.getParent(); [EOL]     if (gramps.isExprResult()) { [EOL]         changeProxy.removeChild(gramps.getParent(), gramps); [EOL]     } else { [EOL]         changeProxy.replaceWith(gramps, parent, parent.getLastChild().detachFromParent()); [EOL]     } [EOL] } <line_num>: 359,369
@Override [EOL] public JsName name() { [EOL]     return name; [EOL] } <line_num>: 393,396
Node getParent() { [EOL]     return node.getParent(); [EOL] } <line_num>: 398,400
Node getGramps() { [EOL]     return node.getParent() == null ? null : node.getParent().getParent(); [EOL] } <line_num>: 402,404
@Override [EOL] public void remove() { [EOL]     Preconditions.checkState(node.isCall()); [EOL]     Node parent = getParent(); [EOL]     if (parent.isExprResult()) { [EOL]         changeProxy.removeChild(getGramps(), parent); [EOL]     } else { [EOL]         changeProxy.replaceWith(parent, node, IR.voidNode(IR.number(0))); [EOL]     } [EOL] } <line_num>: 425,434
@Override [EOL] public void remove() { [EOL]     changeProxy.replaceWith(getGramps(), getParent(), IR.falseNode()); [EOL] } <line_num>: 455,458
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     NameInformation ns = null; [EOL]     if (NodeUtil.isVarDeclaration(n)) { [EOL]         ns = createNameInformation(t, n); [EOL]     } else if (NodeUtil.isFunctionDeclaration(n)) { [EOL]         ns = createNameInformation(t, n.getFirstChild()); [EOL]     } [EOL]     if (ns != null) { [EOL]         JsName jsName = getName(ns.name, true); [EOL]         jsName.externallyDefined = true; [EOL]         externalNames.add(ns.name); [EOL]     } [EOL] } <line_num>: 465,478
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (!t.inGlobalScope()) { [EOL]         return; [EOL]     } [EOL]     if (n.isAssign()) { [EOL]         recordAssignment(t, n, n); [EOL]         if (!NodeUtil.isImmutableResult(n.getLastChild())) { [EOL]             recordConsumers(t, n, n); [EOL]         } [EOL]     } else if (NodeUtil.isVarDeclaration(n)) { [EOL]         NameInformation ns = createNameInformation(t, n); [EOL]         recordDepScope(n, ns); [EOL]     } else if (NodeUtil.isFunctionDeclaration(n)) { [EOL]         NameInformation ns = createNameInformation(t, n.getFirstChild()); [EOL]         recordDepScope(n, ns); [EOL]     } else if (NodeUtil.isExprCall(n)) { [EOL]         Node callNode = n.getFirstChild(); [EOL]         Node nameNode = callNode.getFirstChild(); [EOL]         NameInformation ns = createNameInformation(t, nameNode); [EOL]         if (ns != null && ns.onlyAffectsClassDef) { [EOL]             recordDepScope(n, ns); [EOL]         } [EOL]     } [EOL] } <line_num>: 503,528
private void recordConsumers(NodeTraversal t, Node n, Node recordNode) { [EOL]     Node parent = n.getParent(); [EOL]     switch(parent.getType()) { [EOL]         case Token.ASSIGN: [EOL]             if (n == parent.getLastChild()) { [EOL]                 recordAssignment(t, parent, recordNode); [EOL]             } [EOL]             recordConsumers(t, parent, recordNode); [EOL]             break; [EOL]         case Token.NAME: [EOL]             NameInformation ns = createNameInformation(t, parent); [EOL]             recordDepScope(recordNode, ns); [EOL]             break; [EOL]         case Token.OR: [EOL]             recordConsumers(t, parent, recordNode); [EOL]             break; [EOL]         case Token.AND: [EOL]         case Token.COMMA: [EOL]         case Token.HOOK: [EOL]             if (n != parent.getFirstChild()) { [EOL]                 recordConsumers(t, parent, recordNode); [EOL]             } [EOL]             break; [EOL]     } [EOL] } <line_num>: 530,556
private void recordAssignment(NodeTraversal t, Node n, Node recordNode) { [EOL]     Node nameNode = n.getFirstChild(); [EOL]     Node parent = n.getParent(); [EOL]     NameInformation ns = createNameInformation(t, nameNode); [EOL]     if (ns != null) { [EOL]         if (parent.isFor() && !NodeUtil.isForIn(parent)) { [EOL]             if (parent.getFirstChild().getNext() != n) { [EOL]                 recordDepScope(recordNode, ns); [EOL]             } else { [EOL]                 recordDepScope(nameNode, ns); [EOL]             } [EOL]         } else { [EOL]             recordDepScope(recordNode, ns); [EOL]         } [EOL]     } [EOL] } <line_num>: 558,582
private void recordDepScope(Node node, NameInformation name) { [EOL]     Preconditions.checkNotNull(name); [EOL]     scopes.put(node, name); [EOL] } <line_num>: 587,590
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (NodeUtil.isVarDeclaration(n)) { [EOL]         NameInformation ns = createNameInformation(t, n); [EOL]         Preconditions.checkNotNull(ns, "NameInformation is null"); [EOL]         createName(ns.name); [EOL]     } else if (NodeUtil.isFunctionDeclaration(n)) { [EOL]         Node nameNode = n.getFirstChild(); [EOL]         NameInformation ns = createNameInformation(t, nameNode); [EOL]         Preconditions.checkNotNull(ns, "NameInformation is null"); [EOL]         createName(nameNode.getString()); [EOL]     } [EOL] } <line_num>: 602,614
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (t.inGlobalScope()) { [EOL]         if (NodeUtil.isVarDeclaration(n)) { [EOL]             NameInformation ns = createNameInformation(t, n); [EOL]             Preconditions.checkNotNull(ns); [EOL]             recordSet(ns.name, n); [EOL]         } else if (NodeUtil.isFunctionDeclaration(n)) { [EOL]             Node nameNode = n.getFirstChild(); [EOL]             NameInformation ns = createNameInformation(t, nameNode); [EOL]             if (ns != null) { [EOL]                 JsName nameInfo = getName(nameNode.getString(), true); [EOL]                 recordSet(nameInfo.name, nameNode); [EOL]             } [EOL]         } else if (NodeUtil.isObjectLitKey(n, parent)) { [EOL]             NameInformation ns = createNameInformation(t, n); [EOL]             if (ns != null) { [EOL]                 recordSet(ns.name, n); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (n.isAssign()) { [EOL]         Node nameNode = n.getFirstChild(); [EOL]         NameInformation ns = createNameInformation(t, nameNode); [EOL]         if (ns != null) { [EOL]             if (ns.isPrototype) { [EOL]                 recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n); [EOL]             } else { [EOL]                 recordSet(ns.name, nameNode); [EOL]             } [EOL]         } [EOL]     } else if (n.isCall()) { [EOL]         Node nameNode = n.getFirstChild(); [EOL]         NameInformation ns = createNameInformation(t, nameNode); [EOL]         if (ns != null && ns.onlyAffectsClassDef) { [EOL]             JsName name = getName(ns.name, true); [EOL]             refNodes.add(new ClassDefiningFunctionNode(name, n)); [EOL]         } [EOL]     } [EOL] } <line_num>: 627,671
private void recordSet(String name, Node node) { [EOL]     JsName jsn = getName(name, true); [EOL]     JsNameRefNode nameRefNode = new JsNameRefNode(jsn, node); [EOL]     refNodes.add(nameRefNode); [EOL]     if (node.isGetElem()) { [EOL]         recordWriteOnProperties(name); [EOL]     } else if (name.indexOf('.') != -1) { [EOL]         recordWriteOnProperties(name.substring(0, name.lastIndexOf('.'))); [EOL]     } [EOL] } <line_num>: 680,692
private void recordPrototypeSet(String className, String prototypeProperty, Node node) { [EOL]     JsName name = getName(className, true); [EOL]     name.prototypeNames.add(prototypeProperty); [EOL]     refNodes.add(new PrototypeSetNode(name, node)); [EOL]     recordWriteOnProperties(className); [EOL] } <line_num>: 702,708
private void recordWriteOnProperties(String parentName) { [EOL]     do { [EOL]         JsName parent = getName(parentName, true); [EOL]         if (parent.hasWrittenDescendants) { [EOL]             return; [EOL]         } else { [EOL]             parent.hasWrittenDescendants = true; [EOL]         } [EOL]         if (parentName.indexOf('.') == -1) { [EOL]             return; [EOL]         } [EOL]         parentName = parentName.substring(0, parentName.lastIndexOf('.')); [EOL]     } while (true); [EOL] } <line_num>: 713,729
@Override [EOL] public boolean apply(Node input) { [EOL]     if (input.isCall()) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } <line_num>: 734,743
private void addAllChildren(Node n) { [EOL]     nodesToKeep.add(n); [EOL]     for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { [EOL]         addAllChildren(child); [EOL]     } [EOL] } <line_num>: 760,767
private void addSimplifiedChildren(Node n) { [EOL]     NodeTraversal.traverse(compiler, n, new GatherSideEffectSubexpressionsCallback(compiler, new NodeAccumulator())); [EOL] } <line_num>: 769,774
private void addSimplifiedExpression(Node n, Node parent) { [EOL]     if (parent.isVar()) { [EOL]         Node value = n.getFirstChild(); [EOL]         if (value != null) { [EOL]             addSimplifiedChildren(value); [EOL]         } [EOL]     } else if (n.isAssign() && (parent.isExprResult() || parent.isFor() || parent.isReturn())) { [EOL]         for (Node child : n.children()) { [EOL]             addSimplifiedChildren(child); [EOL]         } [EOL]     } else if (n.isCall() && parent.isExprResult()) { [EOL]         addSimplifiedChildren(n); [EOL]     } else { [EOL]         addAllChildren(n); [EOL]     } [EOL] } <line_num>: 776,795
@Override [EOL] public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { [EOL]     if (parent == null) { [EOL]         return true; [EOL]     } [EOL]     if (n.isFor()) { [EOL]         if (!NodeUtil.isForIn(n)) { [EOL]             Node decl = n.getFirstChild(); [EOL]             Node pred = decl.getNext(); [EOL]             Node step = pred.getNext(); [EOL]             addSimplifiedExpression(decl, n); [EOL]             addSimplifiedExpression(pred, n); [EOL]             addSimplifiedExpression(step, n); [EOL]         } else { [EOL]             Node decl = n.getFirstChild(); [EOL]             Node iter = decl.getNext(); [EOL]             addAllChildren(decl); [EOL]             addAllChildren(iter); [EOL]         } [EOL]     } [EOL]     if (parent.isVar() || parent.isExprResult() || parent.isReturn() || parent.isThrow()) { [EOL]         addSimplifiedExpression(n, parent); [EOL]     } [EOL]     if ((parent.isIf() || parent.isWhile() || parent.isWith() || parent.isSwitch() || parent.isCase()) && parent.getFirstChild() == n) { [EOL]         addAllChildren(n); [EOL]     } [EOL]     if (parent.isDo() && parent.getLastChild() == n) { [EOL]         addAllChildren(n); [EOL]     } [EOL]     return true; [EOL] } <line_num>: 797,844
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (!(n.isName() || NodeUtil.isGet(n) && !parent.isGetProp())) { [EOL]         return; [EOL]     } [EOL]     NameInformation nameInfo = createNameInformation(t, n); [EOL]     if (nameInfo == null) { [EOL]         return; [EOL]     } [EOL]     if (nameInfo.onlyAffectsClassDef) { [EOL]         if (nameInfo.superclass != null) { [EOL]             recordReference(nameInfo.name, nameInfo.superclass, RefType.INHERITANCE); [EOL]         } [EOL]         String nodeName = n.getQualifiedName(); [EOL]         if (nodeName != null) { [EOL]             recordReference(nameInfo.name, nodeName, RefType.REGULAR); [EOL]         } [EOL]         return; [EOL]     } [EOL]     if (parent.isInstanceOf() && parent.getLastChild() == n && n.isQualifiedName()) { [EOL]         JsName checkedClass = getName(nameInfo.name, true); [EOL]         refNodes.add(new InstanceOfCheckNode(checkedClass, n)); [EOL]         checkedClass.hasInstanceOfReference = true; [EOL]         return; [EOL]     } [EOL]     List<NameInformation> referers = getDependencyScope(n); [EOL]     if (referers.isEmpty()) { [EOL]         maybeRecordReferenceOrAlias(t, n, parent, nameInfo, null); [EOL]     } else { [EOL]         for (NameInformation referring : referers) { [EOL]             maybeRecordReferenceOrAlias(t, n, parent, nameInfo, referring); [EOL]         } [EOL]         recordAliases(referers); [EOL]     } [EOL] } <line_num>: 846,901
private void maybeRecordReferenceOrAlias(NodeTraversal t, Node n, Node parent, NameInformation nameInfo, NameInformation referring) { [EOL]     String referringName = ""; [EOL]     if (referring != null) { [EOL]         referringName = referring.isPrototype ? referring.prototypeClass : referring.name; [EOL]     } [EOL]     String name = nameInfo.name; [EOL]     if (maybeHiddenAlias(name, n)) { [EOL]         recordAlias(name, WINDOW); [EOL]     } [EOL]     if (nameInfo.isExternallyReferenceable) { [EOL]         recordReference(WINDOW, name, RefType.REGULAR); [EOL]         maybeRecordAlias(name, parent, referring, referringName); [EOL]         return; [EOL]     } [EOL]     if (NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { [EOL]         if (referring != null) { [EOL]             recordReference(referringName, name, RefType.REGULAR); [EOL]         } [EOL]         return; [EOL]     } [EOL]     if (nodesToKeep.contains(n)) { [EOL]         List<NameInformation> functionScopes = getEnclosingFunctionDependencyScope(t); [EOL]         if (!functionScopes.isEmpty()) { [EOL]             for (NameInformation functionScope : functionScopes) { [EOL]                 recordReference(functionScope.name, name, RefType.REGULAR); [EOL]             } [EOL]         } else { [EOL]             recordReference(WINDOW, name, RefType.REGULAR); [EOL]             if (referring != null) { [EOL]                 maybeRecordAlias(name, parent, referring, referringName); [EOL]             } [EOL]         } [EOL]     } else if (referring != null) { [EOL]         if (!maybeRecordAlias(name, parent, referring, referringName)) { [EOL]             RefType depType = referring.onlyAffectsClassDef ? RefType.INHERITANCE : RefType.REGULAR; [EOL]             recordReference(referringName, name, depType); [EOL]         } [EOL]     } else { [EOL]         for (Node ancestor : n.getAncestors()) { [EOL]             if (NodeUtil.isAssignmentOp(ancestor) || ancestor.isFunction()) { [EOL]                 recordReference(WINDOW, name, RefType.REGULAR); [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 903,972
private void recordAliases(List<NameInformation> referers) { [EOL]     int size = referers.size(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         for (int j = i + 1; j < size; j++) { [EOL]             recordAlias(referers.get(i).name, referers.get(j).name); [EOL]             recordAlias(referers.get(j).name, referers.get(i).name); [EOL]         } [EOL]     } [EOL] } <line_num>: 974,982
private boolean maybeHiddenAlias(String name, Node n) { [EOL]     Node parent = n.getParent(); [EOL]     if (NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { [EOL]         Node rhs = (parent.isVar()) ? n.getFirstChild() : parent.getLastChild(); [EOL]         return (rhs != null && !NodeUtil.evaluatesToLocalValue(rhs, NON_LOCAL_RESULT_PREDICATE)); [EOL]     } [EOL]     return false; [EOL] } <line_num>: 990,999
private boolean maybeRecordAlias(String name, Node parent, NameInformation referring, String referringName) { [EOL]     boolean isPrototypePropAssignment = parent.isAssign() && NodeUtil.isPrototypeProperty(parent.getFirstChild()); [EOL]     if ((parent.isName() || parent.isAssign()) && !isPrototypePropAssignment && referring != null && scopes.get(parent).contains(referring)) { [EOL]         recordAlias(referringName, name); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1004,1036
@Override [EOL] public boolean classDefiningCallsHaveSideEffects() { [EOL]     return false; [EOL] } <line_num>: 1045,1048
@Override [EOL] public void keepSubTree(Node original) { [EOL]     addAllChildren(original); [EOL] } <line_num>: 1050,1053
@Override [EOL] public void keepSimplifiedShortCircuitExpression(Node original) { [EOL]     Node condition = original.getFirstChild(); [EOL]     Node thenBranch = condition.getNext(); [EOL]     addAllChildren(condition); [EOL]     addSimplifiedChildren(thenBranch); [EOL] } <line_num>: 1055,1061
@Override [EOL] public void keepSimplifiedHookExpression(Node hook, boolean thenHasSideEffects, boolean elseHasSideEffects) { [EOL]     Node condition = hook.getFirstChild(); [EOL]     Node thenBranch = condition.getNext(); [EOL]     Node elseBranch = thenBranch.getNext(); [EOL]     addAllChildren(condition); [EOL]     if (thenHasSideEffects) { [EOL]         addSimplifiedChildren(thenBranch); [EOL]     } [EOL]     if (elseHasSideEffects) { [EOL]         addSimplifiedChildren(elseBranch); [EOL]     } [EOL] } <line_num>: 1063,1077
@Override [EOL] public void nodeRemoved(Node n) { [EOL]     compiler.reportCodeChange(); [EOL] } <line_num>: 1082,1085
@Override [EOL] public void process(Node externs, Node root) { [EOL]     NodeTraversal.traverse(compiler, externs, new ProcessExternals()); [EOL]     NodeTraversal.traverse(compiler, root, new FindDependencyScopes()); [EOL]     NodeTraversal.traverse(compiler, root, new HoistVariableAndFunctionDeclarations()); [EOL]     NodeTraversal.traverse(compiler, root, new FindDeclarationsAndSetters()); [EOL]     NodeTraversal.traverse(compiler, root, new FindReferences()); [EOL]     referenceParentNames(); [EOL]     referenceAliases(); [EOL]     calculateReferences(); [EOL]     if (removeUnreferenced) { [EOL]         removeUnreferenced(); [EOL]     } [EOL] } <line_num>: 1107,1129
private void recordAlias(String fromName, String toName) { [EOL]     recordReference(fromName, toName, RefType.REGULAR); [EOL]     AliasSet toNameAliasSet = aliases.get(toName); [EOL]     AliasSet fromNameAliasSet = aliases.get(fromName); [EOL]     AliasSet resultSet = null; [EOL]     if (toNameAliasSet == null && fromNameAliasSet == null) { [EOL]         resultSet = new AliasSet(toName, fromName); [EOL]     } else if (toNameAliasSet != null && fromNameAliasSet != null) { [EOL]         resultSet = toNameAliasSet; [EOL]         resultSet.names.addAll(fromNameAliasSet.names); [EOL]         for (String name : fromNameAliasSet.names) { [EOL]             aliases.put(name, resultSet); [EOL]         } [EOL]     } else if (toNameAliasSet != null) { [EOL]         resultSet = toNameAliasSet; [EOL]         resultSet.names.add(fromName); [EOL]     } else { [EOL]         resultSet = fromNameAliasSet; [EOL]         resultSet.names.add(toName); [EOL]     } [EOL]     aliases.put(fromName, resultSet); [EOL]     aliases.put(toName, resultSet); [EOL] } <line_num>: 1134,1166
private void recordReference(String fromName, String toName, RefType depType) { [EOL]     if (fromName.equals(toName)) { [EOL]         return; [EOL]     } [EOL]     JsName from = getName(fromName, true); [EOL]     JsName to = getName(toName, true); [EOL]     referenceGraph.createNode(from); [EOL]     referenceGraph.createNode(to); [EOL]     if (!referenceGraph.isConnectedInDirection(from, depType, to)) { [EOL]         referenceGraph.connect(from, depType, to); [EOL]     } [EOL] } <line_num>: 1171,1185
void removeUnreferenced() { [EOL]     RemoveListener listener = new RemoveListener(); [EOL]     changeProxy.registerListener(listener); [EOL]     for (RefNode refNode : refNodes) { [EOL]         JsName name = refNode.name(); [EOL]         if (!name.referenced && !name.externallyDefined) { [EOL]             refNode.remove(); [EOL]         } [EOL]     } [EOL]     changeProxy.unregisterListener(listener); [EOL] } <line_num>: 1190,1202
String getHtmlReport() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append("<html><body><style type=\"text/css\">" + "body, td, p {font-family: Arial; font-size: 83%} " + "ul {margin-top:2px; margin-left:0px; padding-left:1em;} " + "li {margin-top:3px; margin-left:24px; padding-left:0px;" + "padding-bottom: 4px}</style>"); [EOL]     sb.append("OVERALL STATS<ul>"); [EOL]     appendListItem(sb, "Total Names: " + countOf(TriState.BOTH, TriState.BOTH)); [EOL]     appendListItem(sb, "Total Classes: " + countOf(TriState.TRUE, TriState.BOTH)); [EOL]     appendListItem(sb, "Total Static Functions: " + countOf(TriState.FALSE, TriState.BOTH)); [EOL]     appendListItem(sb, "Referenced Names: " + countOf(TriState.BOTH, TriState.TRUE)); [EOL]     appendListItem(sb, "Referenced Classes: " + countOf(TriState.TRUE, TriState.TRUE)); [EOL]     appendListItem(sb, "Referenced Functions: " + countOf(TriState.FALSE, TriState.TRUE)); [EOL]     sb.append("</ul>"); [EOL]     sb.append("ALL NAMES<ul>\n"); [EOL]     for (JsName node : allNames.values()) { [EOL]         sb.append("<li>" + nameAnchor(node.name) + "<ul>"); [EOL]         if (node.prototypeNames.size() > 0) { [EOL]             sb.append("<li>PROTOTYPES: "); [EOL]             Iterator<String> protoIter = node.prototypeNames.iterator(); [EOL]             while (protoIter.hasNext()) { [EOL]                 sb.append(protoIter.next()); [EOL]                 if (protoIter.hasNext()) { [EOL]                     sb.append(", "); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (referenceGraph.hasNode(node)) { [EOL]             List<DiGraphEdge<JsName, RefType>> refersTo = referenceGraph.getOutEdges(node); [EOL]             if (refersTo.size() > 0) { [EOL]                 sb.append("<li>REFERS TO: "); [EOL]                 Iterator<DiGraphEdge<JsName, RefType>> toIter = refersTo.iterator(); [EOL]                 while (toIter.hasNext()) { [EOL]                     sb.append(nameLink(toIter.next().getDestination().getValue().name)); [EOL]                     if (toIter.hasNext()) { [EOL]                         sb.append(", "); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             List<DiGraphEdge<JsName, RefType>> referencedBy = referenceGraph.getInEdges(node); [EOL]             if (referencedBy.size() > 0) { [EOL]                 sb.append("<li>REFERENCED BY: "); [EOL]                 Iterator<DiGraphEdge<JsName, RefType>> fromIter = refersTo.iterator(); [EOL]                 while (fromIter.hasNext()) { [EOL]                     sb.append(nameLink(fromIter.next().getDestination().getValue().name)); [EOL]                     if (fromIter.hasNext()) { [EOL]                         sb.append(", "); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         sb.append("</li>"); [EOL]         sb.append("</ul></li>"); [EOL]     } [EOL]     sb.append("</ul>"); [EOL]     sb.append("</body></html>"); [EOL]     return sb.toString(); [EOL] } <line_num>: 1209,1279
private void appendListItem(StringBuilder sb, String text) { [EOL]     sb.append("<li>" + text + "</li>\n"); [EOL] } <line_num>: 1281,1283
private String nameLink(String name) { [EOL]     return "<a href=\"#" + name + "\">" + name + "</a>"; [EOL] } <line_num>: 1285,1287
private String nameAnchor(String name) { [EOL]     return "<a name=\"" + name + "\">" + name + "</a>"; [EOL] } <line_num>: 1289,1291
private JsName getName(String name, boolean canCreate) { [EOL]     if (canCreate) { [EOL]         createName(name); [EOL]     } [EOL]     return allNames.get(name); [EOL] } <line_num>: 1302,1307
private void createName(String name) { [EOL]     JsName jsn = allNames.get(name); [EOL]     if (jsn == null) { [EOL]         jsn = new JsName(); [EOL]         jsn.name = name; [EOL]         allNames.put(name, jsn); [EOL]     } [EOL] } <line_num>: 1315,1322
private void referenceAliases() { [EOL]     for (Map.Entry<String, AliasSet> entry : aliases.entrySet()) { [EOL]         JsName name = getName(entry.getKey(), false); [EOL]         if (name.hasWrittenDescendants || name.hasInstanceOfReference) { [EOL]             for (String alias : entry.getValue().names) { [EOL]                 recordReference(alias, entry.getKey(), RefType.REGULAR); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 1349,1358
private void referenceParentNames() { [EOL]     Set<JsName> allNamesCopy = Sets.newHashSet(allNames.values()); [EOL]     for (JsName name : allNamesCopy) { [EOL]         String curName = name.name; [EOL]         JsName curJsName = name; [EOL]         while (curName.indexOf('.') != -1) { [EOL]             String parentName = curName.substring(0, curName.lastIndexOf('.')); [EOL]             if (!globalNames.contains(parentName)) { [EOL]                 JsName parentJsName = getName(parentName, true); [EOL]                 recordReference(curJsName.name, parentJsName.name, RefType.REGULAR); [EOL]                 recordReference(parentJsName.name, curJsName.name, RefType.REGULAR); [EOL]                 curJsName = parentJsName; [EOL]             } [EOL]             curName = parentName; [EOL]         } [EOL]     } [EOL] } <line_num>: 1364,1386
private NameInformation createNameInformation(NodeTraversal t, Node n) { [EOL]     Node parent = n.getParent(); [EOL]     String name = ""; [EOL]     Node rootNameNode = n; [EOL]     boolean bNameWasShortened = false; [EOL]     while (true) { [EOL]         if (NodeUtil.isGet(rootNameNode)) { [EOL]             Node prop = rootNameNode.getLastChild(); [EOL]             if (rootNameNode.isGetProp()) { [EOL]                 name = "." + prop.getString() + name; [EOL]             } else { [EOL]                 bNameWasShortened = true; [EOL]                 name = ""; [EOL]             } [EOL]             rootNameNode = rootNameNode.getFirstChild(); [EOL]         } else if (NodeUtil.isObjectLitKey(rootNameNode, rootNameNode.getParent())) { [EOL]             name = "." + rootNameNode.getString() + name; [EOL]             Node objLit = rootNameNode.getParent(); [EOL]             Node objLitParent = objLit.getParent(); [EOL]             if (objLitParent.isAssign()) { [EOL]                 rootNameNode = objLitParent.getFirstChild(); [EOL]             } else if (objLitParent.isName()) { [EOL]                 rootNameNode = objLitParent; [EOL]             } else if (objLitParent.isStringKey()) { [EOL]                 rootNameNode = objLitParent; [EOL]             } else { [EOL]                 return null; [EOL]             } [EOL]         } else { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (parent.isCall() && t.inGlobalScope()) { [EOL]         CodingConvention convention = compiler.getCodingConvention(); [EOL]         SubclassRelationship classes = convention.getClassesDefinedByCall(parent); [EOL]         if (classes != null) { [EOL]             NameInformation nameInfo = new NameInformation(); [EOL]             nameInfo.name = classes.subclassName; [EOL]             nameInfo.onlyAffectsClassDef = true; [EOL]             nameInfo.superclass = classes.superclassName; [EOL]             return nameInfo; [EOL]         } [EOL]         String singletonGetterClass = convention.getSingletonGetterClassName(parent); [EOL]         if (singletonGetterClass != null) { [EOL]             NameInformation nameInfo = new NameInformation(); [EOL]             nameInfo.name = singletonGetterClass; [EOL]             nameInfo.onlyAffectsClassDef = true; [EOL]             return nameInfo; [EOL]         } [EOL]     } [EOL]     switch(rootNameNode.getType()) { [EOL]         case Token.NAME: [EOL]             if (!bNameWasShortened && n.isGetProp() && parent.isAssign() && "prototype".equals(n.getLastChild().getString())) { [EOL]                 if (createNameInformation(t, n.getFirstChild()) != null) { [EOL]                     name = rootNameNode.getString() + name; [EOL]                     name = name.substring(0, name.length() - PROTOTYPE_SUFFIX_LEN); [EOL]                     NameInformation nameInfo = new NameInformation(); [EOL]                     nameInfo.name = name; [EOL]                     return nameInfo; [EOL]                 } else { [EOL]                     return null; [EOL]                 } [EOL]             } [EOL]             return createNameInformation(rootNameNode.getString() + name, t.getScope(), rootNameNode); [EOL]         case Token.THIS: [EOL]             if (t.inGlobalScope()) { [EOL]                 NameInformation nameInfo = new NameInformation(); [EOL]                 if (name.indexOf('.') == 0) { [EOL]                     nameInfo.name = name.substring(1); [EOL]                 } else { [EOL]                     nameInfo.name = name; [EOL]                 } [EOL]                 nameInfo.isExternallyReferenceable = true; [EOL]                 return nameInfo; [EOL]             } [EOL]             return null; [EOL]         default: [EOL]             return null; [EOL]     } [EOL] } <line_num>: 1396,1496
private NameInformation createNameInformation(String name, Scope scope, Node rootNameNode) { [EOL]     String rootName = rootNameNode.getString(); [EOL]     Var v = scope.getVar(rootName); [EOL]     boolean isExtern = (v == null && externalNames.contains(rootName)); [EOL]     boolean isGlobalRef = (v != null && v.isGlobal()) || isExtern || rootName.equals(WINDOW); [EOL]     if (!isGlobalRef) { [EOL]         return null; [EOL]     } [EOL]     NameInformation nameInfo = new NameInformation(); [EOL]     int idx = name.indexOf(PROTOTYPE_SUBSTRING); [EOL]     if (idx != -1) { [EOL]         nameInfo.isPrototype = true; [EOL]         nameInfo.prototypeClass = name.substring(0, idx); [EOL]         nameInfo.prototypeProperty = name.substring(idx + PROTOTYPE_SUBSTRING_LEN); [EOL]     } [EOL]     nameInfo.name = name; [EOL]     nameInfo.isExternallyReferenceable = isExtern || isExternallyReferenceable(scope, name); [EOL]     return nameInfo; [EOL] } <line_num>: 1508,1535
private boolean isExternallyReferenceable(Scope scope, String name) { [EOL]     if (compiler.getCodingConvention().isExported(name)) { [EOL]         return true; [EOL]     } [EOL]     if (scope.isLocal()) { [EOL]         return false; [EOL]     } [EOL]     for (String s : globalNames) { [EOL]         if (name.startsWith(s)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1545,1558
private List<NameInformation> getDependencyScope(Node n) { [EOL]     for (Node node : n.getAncestors()) { [EOL]         List<NameInformation> refs = scopes.get(node); [EOL]         if (!refs.isEmpty()) { [EOL]             return refs; [EOL]         } [EOL]     } [EOL]     return Collections.emptyList(); [EOL] } <line_num>: 1563,1572
private List<NameInformation> getEnclosingFunctionDependencyScope(NodeTraversal t) { [EOL]     Node function = t.getEnclosingFunction(); [EOL]     if (function == null) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     List<NameInformation> refs = scopes.get(function); [EOL]     if (!refs.isEmpty()) { [EOL]         return refs; [EOL]     } [EOL]     Node parent = function.getParent(); [EOL]     if (parent != null) { [EOL]         while (parent.isHook()) { [EOL]             parent = parent.getParent(); [EOL]         } [EOL]         if (parent.isName()) { [EOL]             return scopes.get(parent); [EOL]         } [EOL]         if (parent.isAssign()) { [EOL]             return scopes.get(parent); [EOL]         } [EOL]     } [EOL]     return Collections.emptyList(); [EOL] } <line_num>: 1580,1612
private void calculateReferences() { [EOL]     JsName window = getName(WINDOW, true); [EOL]     window.referenced = true; [EOL]     JsName function = getName(FUNCTION, true); [EOL]     function.referenced = true; [EOL]     FixedPointGraphTraversal.newTraversal(new ReferencePropagationCallback()).computeFixedPoint(referenceGraph); [EOL] } <line_num>: 1617,1626
private int countOf(TriState isClass, TriState referenced) { [EOL]     int count = 0; [EOL]     for (JsName name : allNames.values()) { [EOL]         boolean nodeIsClass = name.prototypeNames.size() > 0; [EOL]         boolean classMatch = isClass == TriState.BOTH || (nodeIsClass && isClass == TriState.TRUE) || (!nodeIsClass && isClass == TriState.FALSE); [EOL]         boolean referenceMatch = referenced == TriState.BOTH || (name.referenced && referenced == TriState.TRUE) || (!name.referenced && referenced == TriState.FALSE); [EOL]         if (classMatch && referenceMatch && !name.externallyDefined) { [EOL]             count++; [EOL]         } [EOL]     } [EOL]     return count; [EOL] } <line_num>: 1649,1668
private List<Node> getSideEffectNodes(Node n) { [EOL]     List<Node> subexpressions = Lists.newArrayList(); [EOL]     NodeTraversal.traverse(compiler, n, new GatherSideEffectSubexpressionsCallback(compiler, new GetReplacementSideEffectSubexpressions(compiler, subexpressions))); [EOL]     List<Node> replacements = Lists.newArrayListWithExpectedSize(subexpressions.size()); [EOL]     for (Node subexpression : subexpressions) { [EOL]         replacements.add(NodeUtil.newExpr(subexpression)); [EOL]     } [EOL]     return replacements; [EOL] } <line_num>: 1674,1689
private void replaceWithRhs(Node parent, Node n) { [EOL]     if (valueConsumedByParent(n, parent)) { [EOL]         List<Node> replacements = getRhsSubexpressions(n); [EOL]         List<Node> newReplacements = Lists.newArrayList(); [EOL]         for (int i = 0; i < replacements.size() - 1; i++) { [EOL]             newReplacements.addAll(getSideEffectNodes(replacements.get(i))); [EOL]         } [EOL]         Node valueExpr = replacements.get(replacements.size() - 1); [EOL]         valueExpr.detachFromParent(); [EOL]         newReplacements.add(valueExpr); [EOL]         changeProxy.replaceWith(parent, n, collapseReplacements(newReplacements)); [EOL]     } else if (n.isAssign() && !parent.isFor()) { [EOL]         Node replacement = n.getLastChild(); [EOL]         replacement.detachFromParent(); [EOL]         changeProxy.replaceWith(parent, n, replacement); [EOL]     } else { [EOL]         replaceTopLevelExpressionWithRhs(parent, n); [EOL]     } [EOL] } <line_num>: 1698,1724
private void replaceTopLevelExpressionWithRhs(Node parent, Node n) { [EOL]     switch(parent.getType()) { [EOL]         case Token.BLOCK: [EOL]         case Token.SCRIPT: [EOL]         case Token.FOR: [EOL]         case Token.LABEL: [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("Unsupported parent node type in replaceWithRhs " + Token.name(parent.getType())); [EOL]     } [EOL]     switch(n.getType()) { [EOL]         case Token.EXPR_RESULT: [EOL]         case Token.FUNCTION: [EOL]         case Token.VAR: [EOL]             break; [EOL]         case Token.ASSIGN: [EOL]             Preconditions.checkArgument(parent.isFor(), "Unsupported assignment in replaceWithRhs. parent: %s", Token.name(parent.getType())); [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("Unsupported node type in replaceWithRhs " + Token.name(n.getType())); [EOL]     } [EOL]     List<Node> replacements = Lists.newArrayList(); [EOL]     for (Node rhs : getRhsSubexpressions(n)) { [EOL]         replacements.addAll(getSideEffectNodes(rhs)); [EOL]     } [EOL]     if (parent.isFor()) { [EOL]         if (replacements.isEmpty()) { [EOL]             replacements.add(IR.empty()); [EOL]         } else { [EOL]             Node expr = collapseReplacements(replacements); [EOL]             replacements.clear(); [EOL]             replacements.add(expr); [EOL]         } [EOL]     } [EOL]     changeProxy.replaceWith(parent, n, replacements); [EOL] } <line_num>: 1730,1778
private boolean valueConsumedByParent(Node n, Node parent) { [EOL]     if (NodeUtil.isAssignmentOp(parent)) { [EOL]         return parent.getLastChild() == n; [EOL]     } [EOL]     switch(parent.getType()) { [EOL]         case Token.NAME: [EOL]         case Token.RETURN: [EOL]             return true; [EOL]         case Token.AND: [EOL]         case Token.OR: [EOL]         case Token.HOOK: [EOL]             return parent.getFirstChild() == n; [EOL]         case Token.FOR: [EOL]             return parent.getFirstChild().getNext() == n; [EOL]         case Token.IF: [EOL]         case Token.WHILE: [EOL]             return parent.getFirstChild() == n; [EOL]         case Token.DO: [EOL]             return parent.getLastChild() == n; [EOL]         default: [EOL]             return false; [EOL]     } [EOL] } <line_num>: 1795,1818
private Node collapseReplacements(List<Node> replacements) { [EOL]     Node expr = null; [EOL]     for (Node rep : replacements) { [EOL]         if (rep.isExprResult()) { [EOL]             rep = rep.getFirstChild(); [EOL]             rep.detachFromParent(); [EOL]         } [EOL]         if (expr == null) { [EOL]             expr = rep; [EOL]         } else { [EOL]             expr = IR.comma(expr, rep); [EOL]         } [EOL]     } [EOL]     return expr; [EOL] } <line_num>: 1824,1840
private List<Node> getRhsSubexpressions(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.EXPR_RESULT: [EOL]             return getRhsSubexpressions(n.getFirstChild()); [EOL]         case Token.FUNCTION: [EOL]             return Collections.emptyList(); [EOL]         case Token.NAME: [EOL]             { [EOL]                 Node rhs = n.getFirstChild(); [EOL]                 if (rhs != null) { [EOL]                     return Lists.newArrayList(rhs); [EOL]                 } else { [EOL]                     return Collections.emptyList(); [EOL]                 } [EOL]             } [EOL]         case Token.ASSIGN: [EOL]             { [EOL]                 Node lhs = n.getFirstChild(); [EOL]                 Node rhs = lhs.getNext(); [EOL]                 return Lists.newArrayList(lhs, rhs); [EOL]             } [EOL]         case Token.VAR: [EOL]             { [EOL]                 List<Node> nodes = Lists.newArrayList(); [EOL]                 for (Node child : n.children()) { [EOL]                     nodes.addAll(getRhsSubexpressions(child)); [EOL]                 } [EOL]                 return nodes; [EOL]             } [EOL]         default: [EOL]             throw new IllegalArgumentException("AstChangeProxy::getRhs " + n); [EOL]     } [EOL] } <line_num>: 1845,1882
