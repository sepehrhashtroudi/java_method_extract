TypeValidator(AbstractCompiler compiler) { [EOL]     this.compiler = compiler; [EOL]     this.typeRegistry = compiler.getTypeRegistry(); [EOL]     this.allValueTypes = typeRegistry.createUnionType(STRING_TYPE, NUMBER_TYPE, BOOLEAN_TYPE, NULL_TYPE, VOID_TYPE); [EOL]     this.nullOrUndefined = typeRegistry.createUnionType(NULL_TYPE, VOID_TYPE); [EOL] } <line_num>: 137,144
TypeMismatch(JSType a, JSType b, JSError src) { [EOL]     this.typeA = a; [EOL]     this.typeB = b; [EOL]     this.src = src; [EOL] } <line_num>: 805,809
Iterable<TypeMismatch> getMismatches() { [EOL]     return mismatches; [EOL] } <line_num>: 152,154
void setShouldReport(boolean report) { [EOL]     this.shouldReport = report; [EOL] } <line_num>: 156,158
void expectValidTypeofName(NodeTraversal t, Node n, String found) { [EOL]     report(JSError.make(t.getSourceName(), n, UNKNOWN_TYPEOF_VALUE, found)); [EOL] } <line_num>: 165,167
boolean expectObject(NodeTraversal t, Node n, JSType type, String msg) { [EOL]     if (!type.matchesObjectContext()) { [EOL]         mismatch(t, n, msg, type, OBJECT_TYPE); [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } <line_num>: 175,181
void expectActualObject(NodeTraversal t, Node n, JSType type, String msg) { [EOL]     if (!type.isObject()) { [EOL]         mismatch(t, n, msg, type, OBJECT_TYPE); [EOL]     } [EOL] } <line_num>: 187,191
void expectAnyObject(NodeTraversal t, Node n, JSType type, String msg) { [EOL]     JSType anyObjectType = getNativeType(NO_OBJECT_TYPE); [EOL]     if (!anyObjectType.isSubtype(type) && !type.isEmptyType()) { [EOL]         mismatch(t, n, msg, type, anyObjectType); [EOL]     } [EOL] } <line_num>: 197,202
void expectString(NodeTraversal t, Node n, JSType type, String msg) { [EOL]     if (!type.matchesStringContext()) { [EOL]         mismatch(t, n, msg, type, STRING_TYPE); [EOL]     } [EOL] } <line_num>: 209,213
void expectNumber(NodeTraversal t, Node n, JSType type, String msg) { [EOL]     if (!type.matchesNumberContext()) { [EOL]         mismatch(t, n, msg, type, NUMBER_TYPE); [EOL]     } [EOL] } <line_num>: 220,224
void expectBitwiseable(NodeTraversal t, Node n, JSType type, String msg) { [EOL]     if (!type.matchesNumberContext() && !type.isSubtype(allValueTypes)) { [EOL]         mismatch(t, n, msg, type, allValueTypes); [EOL]     } [EOL] } <line_num>: 231,235
void expectStringOrNumber(NodeTraversal t, Node n, JSType type, String msg) { [EOL]     if (!type.matchesNumberContext() && !type.matchesStringContext()) { [EOL]         mismatch(t, n, msg, type, NUMBER_STRING); [EOL]     } [EOL] } <line_num>: 242,247
boolean expectNotNullOrUndefined(NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) { [EOL]     if (!type.isNoType() && !type.isUnknownType() && type.isSubtype(nullOrUndefined) && !containsForwardDeclaredUnresolvedName(type)) { [EOL]         if (n.isGetProp() && !t.inGlobalScope() && type.isNullType()) { [EOL]             return true; [EOL]         } [EOL]         mismatch(t, n, msg, type, expectedType); [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } <line_num>: 256,282
private boolean containsForwardDeclaredUnresolvedName(JSType type) { [EOL]     if (type.isUnionType()) { [EOL]         for (JSType alt : type.toMaybeUnionType().getAlternates()) { [EOL]             if (containsForwardDeclaredUnresolvedName(alt)) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return type.isNoResolvedType(); [EOL] } <line_num>: 284,293
void expectSwitchMatchesCase(NodeTraversal t, Node n, JSType switchType, JSType caseType) { [EOL]     if (!switchType.canTestForShallowEqualityWith(caseType) && (caseType.autoboxesTo() == null || !caseType.autoboxesTo().isSubtype(switchType))) { [EOL]         mismatch(t, n.getFirstChild(), "case expression doesn't match switch", caseType, switchType); [EOL]     } [EOL] } <line_num>: 299,312
void expectIndexMatch(NodeTraversal t, Node n, JSType objType, JSType indexType) { [EOL]     Preconditions.checkState(n.isGetElem()); [EOL]     Node indexNode = n.getLastChild(); [EOL]     if (objType.isStruct()) { [EOL]         report(JSError.make(t.getSourceName(), indexNode, ILLEGAL_PROPERTY_ACCESS, "'[]'", "struct")); [EOL]     } [EOL]     if (objType.isUnknownType()) { [EOL]         expectStringOrNumber(t, indexNode, indexType, "property access"); [EOL]     } else { [EOL]         ObjectType dereferenced = objType.dereference(); [EOL]         if (dereferenced != null && dereferenced.getIndexType() != null) { [EOL]             expectCanAssignTo(t, indexNode, indexType, dereferenced.getIndexType(), "restricted index type"); [EOL]         } else if (dereferenced != null && dereferenced.isArrayType()) { [EOL]             expectNumber(t, indexNode, indexType, "array access"); [EOL]         } else if (objType.matchesObjectContext()) { [EOL]             expectString(t, indexNode, indexType, "property access"); [EOL]         } else { [EOL]             mismatch(t, n, "only arrays or objects can be accessed", objType, typeRegistry.createUnionType(ARRAY_TYPE, OBJECT_TYPE)); [EOL]         } [EOL]     } [EOL] } <line_num>: 324,349
boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) { [EOL]     if (!leftType.isNoType() && !rightType.isSubtype(leftType)) { [EOL]         JSType ownerType = getJSType(owner); [EOL]         if (ownerType.isFunctionPrototypeType()) { [EOL]             FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction(); [EOL]             if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         mismatch(t, n, "assignment to property " + propName + " of " + getReadableJSTypeName(owner, true), rightType, leftType); [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } <line_num>: 363,386
boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) { [EOL]     if (!rightType.isSubtype(leftType)) { [EOL]         mismatch(t, n, msg, rightType, leftType); [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } <line_num>: 399,406
void expectArgumentMatchesParameter(NodeTraversal t, Node n, JSType argType, JSType paramType, Node callNode, int ordinal) { [EOL]     if (!argType.isSubtype(paramType)) { [EOL]         mismatch(t, n, String.format("actual parameter %d of %s does not match " + "formal parameter", ordinal, getReadableJSTypeName(callNode.getFirstChild(), false)), argType, paramType); [EOL]     } [EOL] } <line_num>: 419,428
void expectCanOverride(NodeTraversal t, Node n, JSType overridingType, JSType hiddenType, String propertyName, JSType ownerType) { [EOL]     if (!overridingType.isSubtype(hiddenType)) { [EOL]         registerMismatch(overridingType, hiddenType, report(t.makeError(n, HIDDEN_PROPERTY_MISMATCH, propertyName, ownerType.toString(), hiddenType.toString(), overridingType.toString()))); [EOL]     } [EOL] } <line_num>: 443,451
void expectSuperType(NodeTraversal t, Node n, ObjectType superObject, ObjectType subObject) { [EOL]     FunctionType subCtor = subObject.getConstructor(); [EOL]     ObjectType implicitProto = subObject.getImplicitPrototype(); [EOL]     ObjectType declaredSuper = implicitProto == null ? null : implicitProto.getImplicitPrototype(); [EOL]     if (declaredSuper != null && !(superObject instanceof UnknownType) && !declaredSuper.isEquivalentTo(superObject)) { [EOL]         if (declaredSuper.isEquivalentTo(getNativeType(OBJECT_TYPE))) { [EOL]             registerMismatch(superObject, declaredSuper, report(t.makeError(n, MISSING_EXTENDS_TAG_WARNING, subObject.toString()))); [EOL]         } else { [EOL]             mismatch(t.getSourceName(), n, "mismatch in declaration of superclass type", superObject, declaredSuper); [EOL]         } [EOL]         if (!subCtor.hasCachedValues()) { [EOL]             subCtor.setPrototypeBasedOn(superObject); [EOL]         } [EOL]     } [EOL] } <line_num>: 461,484
void expectCanCast(NodeTraversal t, Node n, JSType castType, JSType type) { [EOL]     if (!type.canCastTo(castType)) { [EOL]         registerMismatch(type, castType, report(t.makeError(n, INVALID_CAST, type.toString(), castType.toString()))); [EOL]     } [EOL] } <line_num>: 495,500
Var expectUndeclaredVariable(String sourceName, CompilerInput input, Node n, Node parent, Var var, String variableName, JSType newType) { [EOL]     Var newVar = var; [EOL]     boolean allowDupe = false; [EOL]     if (n.isGetProp() || NodeUtil.isObjectLitKey(n, parent)) { [EOL]         JSDocInfo info = n.getJSDocInfo(); [EOL]         if (info == null) { [EOL]             info = parent.getJSDocInfo(); [EOL]         } [EOL]         allowDupe = info != null && info.getSuppressions().contains("duplicate"); [EOL]     } [EOL]     JSType varType = var.getType(); [EOL]     if (varType != null && varType != typeRegistry.getNativeType(UNKNOWN_TYPE) && newType != null && newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) { [EOL]         if (var.input == null) { [EOL]             Scope s = var.getScope(); [EOL]             s.undeclare(var); [EOL]             newVar = s.declare(variableName, n, varType, input, false); [EOL]             n.setJSType(varType); [EOL]             if (parent.isVar()) { [EOL]                 if (n.getFirstChild() != null) { [EOL]                     n.getFirstChild().setJSType(varType); [EOL]                 } [EOL]             } else { [EOL]                 Preconditions.checkState(parent.isFunction()); [EOL]                 parent.setJSType(varType); [EOL]             } [EOL]         } else { [EOL]             if (!(allowDupe || var.getParentNode().isExprResult()) || !newType.isEquivalentTo(varType)) { [EOL]                 report(JSError.make(sourceName, n, DUP_VAR_DECLARATION, variableName, newType.toString(), var.getInputName(), String.valueOf(var.nameNode.getLineno()), varType.toString())); [EOL]             } [EOL]         } [EOL]     } [EOL]     return newVar; [EOL] } <line_num>: 516,576
void expectAllInterfaceProperties(NodeTraversal t, Node n, FunctionType type) { [EOL]     ObjectType instance = type.getInstanceType(); [EOL]     for (ObjectType implemented : type.getAllImplementedInterfaces()) { [EOL]         if (implemented.getImplicitPrototype() != null) { [EOL]             for (String prop : implemented.getImplicitPrototype().getOwnPropertyNames()) { [EOL]                 expectInterfaceProperty(t, n, instance, implemented, prop); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 582,593
private void expectInterfaceProperty(NodeTraversal t, Node n, ObjectType instance, ObjectType implementedInterface, String prop) { [EOL]     StaticSlot<JSType> propSlot = instance.getSlot(prop); [EOL]     if (propSlot == null) { [EOL]         String sourceName = n.getSourceFileName(); [EOL]         sourceName = sourceName == null ? "" : sourceName; [EOL]         registerMismatch(instance, implementedInterface, report(JSError.make(sourceName, n, INTERFACE_METHOD_NOT_IMPLEMENTED, prop, implementedInterface.toString(), instance.toString()))); [EOL]     } else { [EOL]         Node propNode = propSlot.getDeclaration() == null ? null : propSlot.getDeclaration().getNode(); [EOL]         propNode = propNode == null ? n : propNode; [EOL]         JSType found = propSlot.getType(); [EOL]         JSType required = implementedInterface.getImplicitPrototype().getPropertyType(prop); [EOL]         found = found.restrictByNotNullOrUndefined(); [EOL]         required = required.restrictByNotNullOrUndefined(); [EOL]         if (!found.isSubtype(required)) { [EOL]             FunctionType constructor = implementedInterface.toObjectType().getConstructor(); [EOL]             registerMismatch(found, required, report(t.makeError(propNode, HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop, constructor.getTopMostDefiningType(prop).toString(), required.toString(), found.toString()))); [EOL]         } [EOL]     } [EOL] } <line_num>: 599,633
private void mismatch(NodeTraversal t, Node n, String msg, JSType found, JSType required) { [EOL]     mismatch(t.getSourceName(), n, msg, found, required); [EOL] } <line_num>: 638,641
private void mismatch(NodeTraversal t, Node n, String msg, JSType found, JSTypeNative required) { [EOL]     mismatch(t, n, msg, found, getNativeType(required)); [EOL] } <line_num>: 643,646
private void mismatch(String sourceName, Node n, String msg, JSType found, JSType required) { [EOL]     registerMismatch(found, required, report(JSError.make(sourceName, n, TYPE_MISMATCH_WARNING, formatFoundRequired(msg, found, required)))); [EOL] } <line_num>: 648,653
private void registerMismatch(JSType found, JSType required, JSError error) { [EOL]     found = found.restrictByNotNullOrUndefined(); [EOL]     required = required.restrictByNotNullOrUndefined(); [EOL]     if (found.isSubtype(required) || required.isSubtype(found)) { [EOL]         return; [EOL]     } [EOL]     mismatches.add(new TypeMismatch(found, required, error)); [EOL]     if (found.isFunctionType() && required.isFunctionType()) { [EOL]         FunctionType fnTypeA = found.toMaybeFunctionType(); [EOL]         FunctionType fnTypeB = required.toMaybeFunctionType(); [EOL]         Iterator<Node> paramItA = fnTypeA.getParameters().iterator(); [EOL]         Iterator<Node> paramItB = fnTypeB.getParameters().iterator(); [EOL]         while (paramItA.hasNext() && paramItB.hasNext()) { [EOL]             registerIfMismatch(paramItA.next().getJSType(), paramItB.next().getJSType(), error); [EOL]         } [EOL]         registerIfMismatch(fnTypeA.getReturnType(), fnTypeB.getReturnType(), error); [EOL]     } [EOL] } <line_num>: 655,679
private void registerIfMismatch(JSType found, JSType required, JSError error) { [EOL]     if (found != null && required != null && !found.isSubtype(required)) { [EOL]         registerMismatch(found, required, error); [EOL]     } [EOL] } <line_num>: 681,687
private String formatFoundRequired(String description, JSType found, JSType required) { [EOL]     return MessageFormat.format(FOUND_REQUIRED, description, found, required); [EOL] } <line_num>: 692,695
String getReadableJSTypeName(Node n, boolean dereference) { [EOL]     if (n.isGetProp()) { [EOL]         ObjectType objectType = getJSType(n.getFirstChild()).dereference(); [EOL]         if (objectType != null) { [EOL]             String propName = n.getLastChild().getString(); [EOL]             if (objectType.getConstructor() != null && objectType.getConstructor().isInterface()) { [EOL]                 objectType = FunctionType.getTopDefiningInterface(objectType, propName); [EOL]             } else { [EOL]                 while (objectType != null && !objectType.hasOwnProperty(propName)) { [EOL]                     objectType = objectType.getImplicitPrototype(); [EOL]                 } [EOL]             } [EOL]             if (objectType != null && (objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) { [EOL]                 return objectType.toString() + "." + propName; [EOL]             } [EOL]         } [EOL]     } [EOL]     JSType type = getJSType(n); [EOL]     if (dereference) { [EOL]         ObjectType dereferenced = type.dereference(); [EOL]         if (dereferenced != null) { [EOL]             type = dereferenced; [EOL]         } [EOL]     } [EOL]     String qualifiedName = n.getQualifiedName(); [EOL]     if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) { [EOL]         return type.toString(); [EOL]     } else if (qualifiedName != null) { [EOL]         return qualifiedName; [EOL]     } else if (type.isFunctionType()) { [EOL]         return "function"; [EOL]     } else { [EOL]         return type.toString(); [EOL]     } [EOL] } <line_num>: 708,758
private JSType getJSType(Node n) { [EOL]     JSType jsType = n.getJSType(); [EOL]     if (jsType == null) { [EOL]         return getNativeType(UNKNOWN_TYPE); [EOL]     } else { [EOL]         return jsType; [EOL]     } [EOL] } <line_num>: 764,775
private JSType getNativeType(JSTypeNative typeId) { [EOL]     return typeRegistry.getNativeType(typeId); [EOL] } <line_num>: 777,779
private JSError report(JSError error) { [EOL]     if (shouldReport) { [EOL]         compiler.report(error); [EOL]     } [EOL]     return error; [EOL] } <line_num>: 781,786
@Override [EOL] public boolean equals(Object object) { [EOL]     if (object instanceof TypeMismatch) { [EOL]         TypeMismatch that = (TypeMismatch) object; [EOL]         return (that.typeA.isEquivalentTo(this.typeA) && that.typeB.isEquivalentTo(this.typeB)) || (that.typeB.isEquivalentTo(this.typeA) && that.typeA.isEquivalentTo(this.typeB)); [EOL]     } [EOL]     return false; [EOL] } <line_num>: 811,820
@Override [EOL] public int hashCode() { [EOL]     return Objects.hashCode(typeA, typeB); [EOL] } <line_num>: 822,824
@Override [EOL] public String toString() { [EOL]     return "(" + typeA + ", " + typeB + ")"; [EOL] } <line_num>: 826,828
