ReplaceMessages(AbstractCompiler compiler, MessageBundle bundle, boolean checkDuplicatedMessages, JsMessage.Style style, boolean strictReplacement) { [EOL]     super(compiler, checkDuplicatedMessages, style, bundle.idGenerator()); [EOL]     this.bundle = bundle; [EOL]     this.strictReplacement = strictReplacement; [EOL] } <line_num>: 40,48
@Override [EOL] void processMessageFallback(Node callNode, JsMessage message1, JsMessage message2) { [EOL]     boolean isFirstMessageTranslated = (bundle.getMessage(message1.getId()) != null); [EOL]     boolean isSecondMessageTranslated = (bundle.getMessage(message2.getId()) != null); [EOL]     Node replacementNode = isSecondMessageTranslated && !isFirstMessageTranslated ? callNode.getChildAtIndex(2) : callNode.getChildAtIndex(1); [EOL]     callNode.getParent().replaceChild(callNode, replacementNode.detachFromParent()); [EOL] } <line_num>: 50,62
@Override [EOL] void processJsMessage(JsMessage message, JsMessageDefinition definition) { [EOL]     JsMessage replacement = bundle.getMessage(message.getId()); [EOL]     if (replacement == null) { [EOL]         if (strictReplacement) { [EOL]             compiler.report(JSError.make(message.getSourceName(), definition.getMessageNode(), BUNDLE_DOES_NOT_HAVE_THE_MESSAGE, message.getId())); [EOL]             return; [EOL]         } else { [EOL]             replacement = message; [EOL]         } [EOL]     } [EOL]     Node newValue; [EOL]     Node msgNode = definition.getMessageNode(); [EOL]     try { [EOL]         newValue = getNewValueNode(replacement, msgNode); [EOL]     } catch (MalformedException e) { [EOL]         compiler.report(JSError.make(message.getSourceName(), e.getNode(), MESSAGE_TREE_MALFORMED, e.getMessage())); [EOL]         newValue = msgNode; [EOL]     } [EOL]     if (newValue != msgNode) { [EOL]         newValue.copyInformationFromForTree(msgNode); [EOL]         definition.getMessageParentNode().replaceChild(msgNode, newValue); [EOL]         compiler.reportCodeChange(); [EOL]     } [EOL] } <line_num>: 64,100
private Node getNewValueNode(JsMessage message, Node origValueNode) throws MalformedException { [EOL]     switch(origValueNode.getType()) { [EOL]         case Token.FUNCTION: [EOL]             updateFunctionNode(message, origValueNode); [EOL]             return origValueNode; [EOL]         case Token.STRING: [EOL]             String newString = message.toString(); [EOL]             if (!origValueNode.getString().equals(newString)) { [EOL]                 origValueNode.setString(newString); [EOL]                 compiler.reportCodeChange(); [EOL]             } [EOL]             return origValueNode; [EOL]         case Token.ADD: [EOL]             return IR.string(message.toString()); [EOL]         case Token.CALL: [EOL]             return replaceCallNode(message, origValueNode); [EOL]         default: [EOL]             throw new MalformedException("Expected FUNCTION, STRING, or ADD node; found: " + origValueNode.getType(), origValueNode); [EOL]     } [EOL] } <line_num>: 114,140
private void updateFunctionNode(JsMessage message, Node functionNode) throws MalformedException { [EOL]     checkNode(functionNode, Token.FUNCTION); [EOL]     Node nameNode = functionNode.getFirstChild(); [EOL]     checkNode(nameNode, Token.NAME); [EOL]     Node argListNode = nameNode.getNext(); [EOL]     checkNode(argListNode, Token.PARAM_LIST); [EOL]     Node oldBlockNode = argListNode.getNext(); [EOL]     checkNode(oldBlockNode, Token.BLOCK); [EOL]     Iterator<CharSequence> iterator = message.parts().iterator(); [EOL]     Node valueNode = iterator.hasNext() ? constructAddOrStringNode(iterator, argListNode) : IR.string(""); [EOL]     Node newBlockNode = IR.block(IR.returnNode(valueNode)); [EOL]     if (newBlockNode.checkTreeEquals(oldBlockNode) != null) { [EOL]         newBlockNode.copyInformationFromForTree(oldBlockNode); [EOL]         functionNode.replaceChild(oldBlockNode, newBlockNode); [EOL]         compiler.reportCodeChange(); [EOL]     } [EOL] } <line_num>: 167,190
private Node constructAddOrStringNode(Iterator<CharSequence> partsIterator, Node argListNode) throws MalformedException { [EOL]     CharSequence part = partsIterator.next(); [EOL]     Node partNode = null; [EOL]     if (part instanceof JsMessage.PlaceholderReference) { [EOL]         JsMessage.PlaceholderReference phRef = (JsMessage.PlaceholderReference) part; [EOL]         for (Node node : argListNode.children()) { [EOL]             if (node.isName()) { [EOL]                 String arg = node.getString(); [EOL]                 if (arg.equalsIgnoreCase(phRef.getName())) { [EOL]                     partNode = IR.name(arg); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (partNode == null) { [EOL]             throw new MalformedException("Unrecognized message placeholder referenced: " + phRef.getName(), argListNode); [EOL]         } [EOL]     } else { [EOL]         partNode = IR.string(part.toString()); [EOL]     } [EOL]     if (partsIterator.hasNext()) { [EOL]         return IR.add(partNode, constructAddOrStringNode(partsIterator, argListNode)); [EOL]     } else { [EOL]         return partNode; [EOL]     } [EOL] } <line_num>: 206,244
private Node replaceCallNode(JsMessage message, Node callNode) throws MalformedException { [EOL]     checkNode(callNode, Token.CALL); [EOL]     Node getPropNode = callNode.getFirstChild(); [EOL]     checkNode(getPropNode, Token.GETPROP); [EOL]     Node stringExprNode = getPropNode.getNext(); [EOL]     checkStringExprNode(stringExprNode); [EOL]     Node objLitNode = stringExprNode.getNext(); [EOL]     return constructStringExprNode(message.parts().iterator(), objLitNode); [EOL] } <line_num>: 286,297
private Node constructStringExprNode(Iterator<CharSequence> parts, Node objLitNode) throws MalformedException { [EOL]     CharSequence part = parts.next(); [EOL]     Node partNode = null; [EOL]     if (part instanceof JsMessage.PlaceholderReference) { [EOL]         JsMessage.PlaceholderReference phRef = (JsMessage.PlaceholderReference) part; [EOL]         if (objLitNode == null) { [EOL]             throw new MalformedException("Empty placeholder value map " + "for a translated message with placeholders.", objLitNode); [EOL]         } [EOL]         for (Node key = objLitNode.getFirstChild(); key != null; key = key.getNext()) { [EOL]             if (key.getString().equals(phRef.getName())) { [EOL]                 Node valueNode = key.getFirstChild(); [EOL]                 partNode = valueNode.cloneTree(); [EOL]             } [EOL]         } [EOL]         if (partNode == null) { [EOL]             throw new MalformedException("Unrecognized message placeholder referenced: " + phRef.getName(), objLitNode); [EOL]         } [EOL]     } else { [EOL]         partNode = IR.string(part.toString()); [EOL]     } [EOL]     if (parts.hasNext()) { [EOL]         return IR.add(partNode, constructStringExprNode(parts, objLitNode)); [EOL]     } else { [EOL]         return partNode; [EOL]     } [EOL] } <line_num>: 312,351
private void checkStringExprNode(@Nullable Node node) { [EOL]     if (node == null) { [EOL]         throw new IllegalArgumentException("Expected a string; found: null"); [EOL]     } [EOL]     switch(node.getType()) { [EOL]         case Token.STRING: [EOL]             break; [EOL]         case Token.ADD: [EOL]             Node c = node.getFirstChild(); [EOL]             checkStringExprNode(c); [EOL]             checkStringExprNode(c.getNext()); [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("Expected a string; found: " + node.getType()); [EOL]     } [EOL] } <line_num>: 359,375
