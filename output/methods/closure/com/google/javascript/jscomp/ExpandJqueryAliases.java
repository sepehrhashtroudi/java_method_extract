ExpandJqueryAliases(AbstractCompiler compiler) { [EOL]     this.compiler = compiler; [EOL]     this.convention = compiler.getCodingConvention(); [EOL]     final boolean late = false; [EOL]     this.peepholePasses = new PeepholeOptimizationsPass(compiler, new PeepholeSubstituteAlternateSyntax(late), new PeepholeReplaceKnownMethods(late), new PeepholeRemoveDeadCode(), new PeepholeFoldConstants(late), new PeepholeCollectPropertyAssignments()); [EOL] } <line_num>: 75,89
FindCallbackArgumentReferences(Node functionRoot, List<Node> keyReferences, List<Node> valueReferences, boolean useArrayMode) { [EOL]     Preconditions.checkState(functionRoot.isFunction()); [EOL]     String keyString = null, valueString = null; [EOL]     Node callbackParams = NodeUtil.getFunctionParameters(functionRoot); [EOL]     Node param = callbackParams.getFirstChild(); [EOL]     if (param != null) { [EOL]         Preconditions.checkState(param.isName()); [EOL]         keyString = param.getString(); [EOL]         param = param.getNext(); [EOL]         if (param != null) { [EOL]             Preconditions.checkState(param.isName()); [EOL]             valueString = param.getString(); [EOL]         } [EOL]     } [EOL]     this.keyName = keyString; [EOL]     this.valueName = valueString; [EOL]     if (useArrayMode) { [EOL]         this.keyReferences = valueReferences; [EOL]         this.valueReferences = keyReferences; [EOL]     } else { [EOL]         this.keyReferences = keyReferences; [EOL]         this.valueReferences = valueReferences; [EOL]     } [EOL]     this.startingScope = null; [EOL] } <line_num>: 509,541
public static boolean isJqueryExtendCall(Node n, String qname, AbstractCompiler compiler) { [EOL]     if (JQUERY_EXTEND_NAMES.contains(qname)) { [EOL]         Node firstArgument = n.getNext(); [EOL]         if (firstArgument == null) { [EOL]             return false; [EOL]         } [EOL]         Node secondArgument = firstArgument.getNext(); [EOL]         if ((firstArgument.isObjectLit() && secondArgument == null) || (firstArgument.isName() || NodeUtil.isGet(firstArgument) && !NodeUtil.mayHaveSideEffects(firstArgument, compiler) && secondArgument != null && secondArgument.isObjectLit() && secondArgument.getNext() == null)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 97,115
public boolean isJqueryExpandedEachCall(Node call, String qName) { [EOL]     Preconditions.checkArgument(call.isCall()); [EOL]     if (call.getFirstChild() != null && JQUERY_EXPANDED_EACH_NAME.equals(qName)) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 117,124
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (n.isGetProp() && convention.isPrototypeAlias(n)) { [EOL]         maybeReplaceJqueryPrototypeAlias(n); [EOL]     } else if (n.isCall()) { [EOL]         Node callTarget = n.getFirstChild(); [EOL]         String qName = callTarget.getQualifiedName(); [EOL]         if (isJqueryExtendCall(callTarget, qName, this.compiler)) { [EOL]             maybeExpandJqueryExtendCall(n); [EOL]         } else if (isJqueryExpandedEachCall(n, qName)) { [EOL]             maybeExpandJqueryEachCall(t, n); [EOL]         } [EOL]     } [EOL] } <line_num>: 126,142
@Override [EOL] public void process(Node externs, Node root) { [EOL]     logger.fine("Expanding Jquery Aliases"); [EOL]     NodeTraversal.traverse(compiler, root, this); [EOL] } <line_num>: 144,149
private void maybeReplaceJqueryPrototypeAlias(Node n) { [EOL]     if (NodeUtil.isLValue(n)) { [EOL]         Node maybeAssign = n.getParent(); [EOL]         while (!NodeUtil.isStatement(maybeAssign) && !maybeAssign.isAssign()) { [EOL]             maybeAssign = maybeAssign.getParent(); [EOL]         } [EOL]         if (maybeAssign.isAssign()) { [EOL]             maybeAssign = maybeAssign.getParent(); [EOL]             if (maybeAssign.isBlock() || maybeAssign.isScript() || NodeUtil.isStatement(maybeAssign)) { [EOL]                 return; [EOL]             } [EOL]         } [EOL]     } [EOL]     Node fn = n.getLastChild(); [EOL]     if (fn != null) { [EOL]         n.replaceChild(fn, IR.string("prototype")); [EOL]         compiler.reportCodeChange(); [EOL]     } [EOL] } <line_num>: 151,174
private void maybeExpandJqueryExtendCall(Node n) { [EOL]     Node callTarget = n.getFirstChild(); [EOL]     Node objectToExtend = callTarget.getNext(); [EOL]     Node extendArg = objectToExtend.getNext(); [EOL]     boolean ensureObjectDefined = true; [EOL]     if (extendArg == null) { [EOL]         extendArg = objectToExtend; [EOL]         objectToExtend = callTarget.getFirstChild(); [EOL]         ensureObjectDefined = false; [EOL]     } else if (objectToExtend.isGetProp() && (objectToExtend.getLastChild().getString().equals("prototype") || convention.isPrototypeAlias(objectToExtend))) { [EOL]         ensureObjectDefined = false; [EOL]     } [EOL]     if (!extendArg.hasChildren()) { [EOL]         return; [EOL]     } [EOL]     Node fncBlock = IR.block().srcref(n); [EOL]     if (ensureObjectDefined) { [EOL]         Node assignVal = IR.or(objectToExtend.cloneTree(), IR.objectlit().srcref(n)).srcref(n); [EOL]         Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n); [EOL]         fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n)); [EOL]     } [EOL]     while (extendArg.hasChildren()) { [EOL]         Node currentProp = extendArg.removeFirstChild(); [EOL]         currentProp.setType(Token.STRING); [EOL]         Node propValue = currentProp.removeFirstChild(); [EOL]         Node newProp; [EOL]         if (currentProp.isQuotedString()) { [EOL]             newProp = IR.getelem(objectToExtend.cloneTree(), currentProp).srcref(currentProp); [EOL]         } else { [EOL]             newProp = IR.getprop(objectToExtend.cloneTree(), currentProp).srcref(currentProp); [EOL]         } [EOL]         Node assignNode = IR.assign(newProp, propValue).srcref(currentProp); [EOL]         fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp)); [EOL]     } [EOL]     if (n.getParent().isExprResult()) { [EOL]         Node parent = n.getParent(); [EOL]         parent.getParent().replaceChild(parent, fncBlock); [EOL]     } else { [EOL]         Node targetVal; [EOL]         if ("jQuery.prototype".equals(objectToExtend.getQualifiedName())) { [EOL]             targetVal = objectToExtend.removeFirstChild(); [EOL]         } else { [EOL]             targetVal = objectToExtend.detachFromParent(); [EOL]         } [EOL]         fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal)); [EOL]         Node fnc = IR.function(IR.name("").srcref(n), IR.paramList().srcref(n), fncBlock); [EOL]         n.replaceChild(callTarget, fnc); [EOL]         n.putBooleanProp(Node.FREE_CALL, true); [EOL]         while (fnc.getNext() != null) { [EOL]             n.removeChildAfter(fnc); [EOL]         } [EOL]     } [EOL]     compiler.reportCodeChange(); [EOL] } <line_num>: 182,263
private void maybeExpandJqueryEachCall(NodeTraversal t, Node n) { [EOL]     Node objectToLoopOver = n.getChildAtIndex(1); [EOL]     if (objectToLoopOver == null) { [EOL]         return; [EOL]     } [EOL]     Node callbackFunction = objectToLoopOver.getNext(); [EOL]     if (callbackFunction == null || !callbackFunction.isFunction()) { [EOL]         return; [EOL]     } [EOL]     peepholePasses.process(null, n.getChildAtIndex(1)); [EOL]     Node nClone = n.cloneTree(); [EOL]     objectToLoopOver = nClone.getChildAtIndex(1); [EOL]     if (!objectToLoopOver.isObjectLit() && !(objectToLoopOver.isArrayLit() && isArrayLitValidForExpansion(objectToLoopOver))) { [EOL]         t.report(n, JQUERY_UNABLE_TO_EXPAND_INVALID_LIT_ERROR, (String) null); [EOL]         return; [EOL]     } [EOL]     List<Node> keyNodeReferences = Lists.newArrayList(); [EOL]     List<Node> valueNodeReferences = Lists.newArrayList(); [EOL]     NodeTraversal.traverse(compiler, NodeUtil.getFunctionBody(callbackFunction), new FindCallbackArgumentReferences(callbackFunction, keyNodeReferences, valueNodeReferences, objectToLoopOver.isArrayLit())); [EOL]     if (keyNodeReferences.size() == 0) { [EOL]         t.report(n, JQUERY_USELESS_EACH_EXPANSION, (String) null); [EOL]         return; [EOL]     } [EOL]     Node fncBlock = tryExpandJqueryEachCall(t, nClone, callbackFunction, keyNodeReferences, valueNodeReferences); [EOL]     if (fncBlock != null && fncBlock.hasChildren()) { [EOL]         replaceOriginalJqueryEachCall(n, fncBlock); [EOL]     } else { [EOL]         t.report(n, JQUERY_USELESS_EACH_EXPANSION, (String) null); [EOL]     } [EOL] } <line_num>: 271,326
private Node tryExpandJqueryEachCall(NodeTraversal t, Node n, Node callbackFunction, List<Node> keyNodes, List<Node> valueNodes) { [EOL]     Node callTarget = n.getFirstChild(); [EOL]     Node objectToLoopOver = callTarget.getNext(); [EOL]     Node fncBlock = IR.block().srcref(callTarget); [EOL]     boolean isValidExpansion = true; [EOL]     Node key = objectToLoopOver.getFirstChild(), val = null; [EOL]     for (int i = 0; key != null; key = key.getNext(), i++) { [EOL]         if (key != null) { [EOL]             if (objectToLoopOver.isArrayLit()) { [EOL]                 val = IR.number(i).srcref(key); [EOL]             } else { [EOL]                 val = key.getFirstChild(); [EOL]             } [EOL]         } [EOL]         List<Node> newKeys = Lists.newArrayList(); [EOL]         List<Node> newValues = Lists.newArrayList(); [EOL]         List<Node> origGetElems = Lists.newArrayList(); [EOL]         List<Node> newGetProps = Lists.newArrayList(); [EOL]         for (int j = 0; j < keyNodes.size(); j++) { [EOL]             Node origNode = keyNodes.get(j); [EOL]             Node ancestor = origNode.getParent(); [EOL]             Node newNode = IR.string(key.getString()).srcref(key); [EOL]             newKeys.add(newNode); [EOL]             ancestor.replaceChild(origNode, newNode); [EOL]             while (ancestor != null && !NodeUtil.isStatement(ancestor) && !ancestor.isGetElem()) { [EOL]                 ancestor = ancestor.getParent(); [EOL]             } [EOL]             if (ancestor != null && ancestor.isGetElem()) { [EOL]                 Node propObject = ancestor; [EOL]                 while (propObject.isGetProp() || propObject.isGetElem()) { [EOL]                     propObject = propObject.getFirstChild(); [EOL]                 } [EOL]                 Node ancestorClone = ancestor.cloneTree(); [EOL]                 peepholePasses.process(null, ancestorClone.getChildAtIndex(1)); [EOL]                 Node prop = ancestorClone.getChildAtIndex(1); [EOL]                 if (prop.isString() && NodeUtil.isValidPropertyName(prop.getString())) { [EOL]                     Node target = ancestorClone.getFirstChild(); [EOL]                     Node newGetProp = IR.getprop(target.detachFromParent(), prop.detachFromParent()); [EOL]                     newGetProps.add(newGetProp); [EOL]                     origGetElems.add(ancestor); [EOL]                     ancestor.getParent().replaceChild(ancestor, newGetProp); [EOL]                 } else { [EOL]                     if (prop.isString() && !NodeUtil.isValidPropertyName(prop.getString())) { [EOL]                         t.report(n, JQUERY_UNABLE_TO_EXPAND_INVALID_NAME_ERROR, prop.getString()); [EOL]                     } [EOL]                     isValidExpansion = false; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (isValidExpansion) { [EOL]             for (int j = 0; val != null && j < valueNodes.size(); j++) { [EOL]                 Node origNode = valueNodes.get(j); [EOL]                 Node newNode = val.cloneTree(); [EOL]                 newValues.add(newNode); [EOL]                 origNode.getParent().replaceChild(origNode, newNode); [EOL]             } [EOL]             Node fnc = IR.function(IR.name("").srcref(key), IR.paramList().srcref(key), callbackFunction.getChildAtIndex(2).cloneTree()).srcref(key); [EOL]             Node call = IR.call(fnc).srcref(key); [EOL]             call.putBooleanProp(Node.FREE_CALL, true); [EOL]             fncBlock.addChildToBack(IR.exprResult(call).srcref(call)); [EOL]         } [EOL]         for (int j = 0; j < newGetProps.size(); j++) { [EOL]             newGetProps.get(j).getParent().replaceChild(newGetProps.get(j), origGetElems.get(j)); [EOL]         } [EOL]         for (int j = 0; j < newKeys.size(); j++) { [EOL]             newKeys.get(j).getParent().replaceChild(newKeys.get(j), keyNodes.get(j)); [EOL]         } [EOL]         for (int j = 0; j < newValues.size(); j++) { [EOL]             newValues.get(j).getParent().replaceChild(newValues.get(j), valueNodes.get(j)); [EOL]         } [EOL]         if (!isValidExpansion) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     return fncBlock; [EOL] } <line_num>: 328,445
private void replaceOriginalJqueryEachCall(Node n, Node expandedBlock) { [EOL]     if (n.getParent().isExprResult()) { [EOL]         Node parent = n.getParent(); [EOL]         Node grandparent = parent.getParent(); [EOL]         Node insertAfter = parent; [EOL]         while (expandedBlock.hasChildren()) { [EOL]             Node child = expandedBlock.getFirstChild().detachFromParent(); [EOL]             grandparent.addChildAfter(child, insertAfter); [EOL]             insertAfter = child; [EOL]         } [EOL]         grandparent.removeChild(parent); [EOL]     } else { [EOL]         Node callTarget = n.getFirstChild(); [EOL]         Node objectToLoopOver = callTarget.getNext(); [EOL]         objectToLoopOver.detachFromParent(); [EOL]         Node ret = IR.returnNode(objectToLoopOver).srcref(callTarget); [EOL]         expandedBlock.addChildToBack(ret); [EOL]         Node fnc = IR.function(IR.name("").srcref(callTarget), IR.paramList().srcref(callTarget), expandedBlock); [EOL]         n.replaceChild(callTarget, fnc); [EOL]         n.putBooleanProp(Node.FREE_CALL, true); [EOL]         while (fnc.getNext() != null) { [EOL]             n.removeChildAfter(fnc); [EOL]         } [EOL]     } [EOL]     compiler.reportCodeChange(); [EOL] } <line_num>: 447,483
private boolean isArrayLitValidForExpansion(Node n) { [EOL]     Iterator<Node> iter = n.children().iterator(); [EOL]     while (iter.hasNext()) { [EOL]         Node child = iter.next(); [EOL]         if (!child.isString()) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 485,494
private boolean isShadowed(String name, Scope scope) { [EOL]     Var nameVar = scope.getVar(name); [EOL]     return nameVar != null && nameVar.getScope() != this.startingScope; [EOL] } <line_num>: 543,547
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     boolean isThis = false; [EOL]     if (t.getScope() == this.startingScope) { [EOL]         isThis = n.isThis(); [EOL]     } [EOL]     if (isThis || n.isName() && !isShadowed(n.getString(), t.getScope())) { [EOL]         String nodeValue = isThis ? null : n.getString(); [EOL]         if (!isThis && keyName != null && nodeValue.equals(keyName)) { [EOL]             keyReferences.add(n); [EOL]         } else if (isThis || (valueName != null && nodeValue.equals(valueName))) { [EOL]             valueReferences.add(n); [EOL]         } [EOL]     } [EOL] } <line_num>: 549,566
@Override [EOL] public void enterScope(NodeTraversal t) { [EOL]     if (this.startingScope == null) { [EOL]         this.startingScope = t.getScope(); [EOL]     } [EOL] } <line_num>: 573,578
@Override [EOL] public void exitScope(NodeTraversal t) { [EOL] } <line_num>: 580,581
