GenerateExports(AbstractCompiler compiler, String exportSymbolFunction, String exportPropertyFunction) { [EOL]     Preconditions.checkNotNull(compiler); [EOL]     Preconditions.checkNotNull(exportSymbolFunction); [EOL]     Preconditions.checkNotNull(exportPropertyFunction); [EOL]     this.compiler = compiler; [EOL]     this.exportSymbolFunction = exportSymbolFunction; [EOL]     this.exportPropertyFunction = exportPropertyFunction; [EOL] } <line_num>: 45,54
@Override [EOL] public void process(Node externs, Node root) { [EOL]     FindExportableNodes findExportableNodes = new FindExportableNodes(compiler); [EOL]     NodeTraversal.traverse(compiler, root, findExportableNodes); [EOL]     Map<String, GenerateNodeContext> exports = findExportableNodes.getExports(); [EOL]     CodingConvention convention = compiler.getCodingConvention(); [EOL]     for (Map.Entry<String, GenerateNodeContext> entry : exports.entrySet()) { [EOL]         String export = entry.getKey(); [EOL]         GenerateNodeContext context = entry.getValue(); [EOL]         String parent = null; [EOL]         String grandparent = null; [EOL]         Node node = context.getNode().getFirstChild(); [EOL]         if (node.isGetProp()) { [EOL]             parent = node.getFirstChild().getQualifiedName(); [EOL]             if (node.getFirstChild().isGetProp() && getPropertyName(node.getFirstChild()).equals(PROTOTYPE_PROPERTY)) { [EOL]                 grandparent = node.getFirstChild().getFirstChild().getQualifiedName(); [EOL]             } [EOL]         } [EOL]         boolean useExportSymbol = true; [EOL]         if (grandparent != null && exports.containsKey(grandparent)) { [EOL]             useExportSymbol = false; [EOL]         } else if (parent != null && exports.containsKey(parent)) { [EOL]             useExportSymbol = false; [EOL]         } [EOL]         Node call; [EOL]         if (useExportSymbol) { [EOL]             call = IR.call(NodeUtil.newQualifiedNameNode(convention, exportSymbolFunction, context.getNode(), export), IR.string(export), NodeUtil.newQualifiedNameNode(convention, export, context.getNode(), export)); [EOL]         } else { [EOL]             String property = getPropertyName(node); [EOL]             call = IR.call(NodeUtil.newQualifiedNameNode(convention, exportPropertyFunction, context.getNode(), exportPropertyFunction), NodeUtil.newQualifiedNameNode(convention, parent, context.getNode(), exportPropertyFunction), IR.string(property), NodeUtil.newQualifiedNameNode(convention, export, context.getNode(), exportPropertyFunction)); [EOL]         } [EOL]         Node expression = IR.exprResult(call); [EOL]         annotate(expression); [EOL]         Node insertionPoint = context.getContextNode().getNext(); [EOL]         while (insertionPoint != null && NodeUtil.isExprCall(insertionPoint) && convention.getClassesDefinedByCall(insertionPoint.getFirstChild()) != null) { [EOL]             insertionPoint = insertionPoint.getNext(); [EOL]         } [EOL]         if (insertionPoint == null) { [EOL]             context.getScriptNode().addChildToBack(expression); [EOL]         } else { [EOL]             context.getScriptNode().addChildBefore(expression, insertionPoint); [EOL]         } [EOL]         compiler.reportCodeChange(); [EOL]     } [EOL] } <line_num>: 56,139
private void annotate(Node node) { [EOL]     NodeTraversal.traverse(compiler, node, new PrepareAst.PrepareAnnotations()); [EOL] } <line_num>: 141,144
private String getPropertyName(Node node) { [EOL]     Preconditions.checkArgument(node.isGetProp()); [EOL]     return node.getLastChild().getString(); [EOL] } <line_num>: 152,155
