Anchor(char type) { [EOL]     this.type = type; [EOL] } <line_num>: 634,634
WordBoundary(char type) { [EOL]     this.type = type; [EOL] } <line_num>: 670,672
BackReference(int groupIndex) { [EOL]     Preconditions.checkArgument(groupIndex >= 0 && groupIndex <= 99); [EOL]     this.groupIndex = groupIndex; [EOL] } <line_num>: 703,706
Text(String text) { [EOL]     this.text = text; [EOL] } <line_num>: 738,740
Repetition(RegExpTree body, int min, int max, boolean greedy) { [EOL]     this.body = body; [EOL]     this.min = min; [EOL]     this.max = max; [EOL]     this.greedy = greedy; [EOL] } <line_num>: 828,833
Alternation(List<? extends RegExpTree> alternatives) { [EOL]     this.alternatives = ImmutableList.copyOf(alternatives); [EOL] } <line_num>: 1011,1013
LookaheadAssertion(RegExpTree body, boolean positive) { [EOL]     this.body = body; [EOL]     this.positive = positive; [EOL] } <line_num>: 1163,1166
CapturingGroup(RegExpTree body) { [EOL]     this.body = body; [EOL] } <line_num>: 1227,1229
Charset(CharRanges ranges, CharRanges ieExplicits) { [EOL]     this.ranges = ranges; [EOL]     this.ieExplicits = ieExplicits; [EOL] } <line_num>: 1344,1347
DecomposedCharset(boolean inverted, CharRanges ranges, String namedGroups) { [EOL]     this.inverted = inverted; [EOL]     this.ranges = ranges; [EOL]     this.namedGroups = namedGroups; [EOL] } <line_num>: 1511,1516
Concatenation(RegExpTree a, RegExpTree b) { [EOL]     elements = ImmutableList.of(a, b); [EOL] } <line_num>: 1633,1635
Concatenation(List<? extends RegExpTree> elements) { [EOL]     this.elements = ImmutableList.copyOf(elements); [EOL] } <line_num>: 1637,1639
public abstract RegExpTree simplify(String flags); <line_num>: 42,42
public abstract boolean isCaseSensitive(); <line_num>: 48,48
public abstract boolean containsAnchor(); <line_num>: 53,53
public final boolean hasCapturingGroup() { [EOL]     return numCapturingGroups() != 0; [EOL] } <line_num>: 58,60
public abstract int numCapturingGroups(); <line_num>: 65,65
public abstract List<? extends RegExpTree> children(); <line_num>: 70,70
protected abstract void appendSourceCode(StringBuilder sb); <line_num>: 75,75
protected abstract void appendDebugInfo(StringBuilder sb); <line_num>: 77,77
@Override [EOL] public final String toString() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append('/'); [EOL]     appendSourceCode(sb); [EOL]     if (sb.length() == 1) { [EOL]         sb.append("(?:)"); [EOL]     } [EOL]     sb.append('/'); [EOL]     return sb.toString(); [EOL] } <line_num>: 79,90
public final String toDebugString() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     appendDebugString(sb); [EOL]     return sb.toString(); [EOL] } <line_num>: 92,96
private void appendDebugString(StringBuilder sb) { [EOL]     sb.append('(').append(getClass().getSimpleName()); [EOL]     int len = sb.length(); [EOL]     sb.append(' '); [EOL]     appendDebugInfo(sb); [EOL]     if (sb.length() == len + 1) { [EOL]         sb.setLength(len); [EOL]     } [EOL]     for (RegExpTree child : children()) { [EOL]         sb.append(' '); [EOL]         child.appendDebugString(sb); [EOL]     } [EOL]     sb.append(')'); [EOL] } <line_num>: 98,109
@Override [EOL] public abstract boolean equals(Object o); <line_num>: 111,112
@Override [EOL] public abstract int hashCode(); <line_num>: 114,115
RegExpTree parseTopLevel() { [EOL]     this.pos = 0; [EOL]     RegExpTree out = parse(); [EOL]     if (pos < limit) { [EOL]         throw new IllegalArgumentException(pattern.substring(pos)); [EOL]     } [EOL]     return out; [EOL] } <line_num>: 136,143
RegExpTree parse() { [EOL]     ImmutableList.Builder<RegExpTree> alternatives = null; [EOL]     RegExpTree preceder = null; [EOL]     topLoop: while (pos < limit) { [EOL]         char ch = pattern.charAt(pos); [EOL]         RegExpTree atom; [EOL]         switch(ch) { [EOL]             case '[': [EOL]                 atom = parseCharset(); [EOL]                 break; [EOL]             case '(': [EOL]                 atom = parseParenthetical(); [EOL]                 break; [EOL]             case ')': [EOL]                 break topLoop; [EOL]             case '\\': [EOL]                 atom = parseEscape(); [EOL]                 break; [EOL]             case '^': [EOL]             case '$': [EOL]                 atom = new Anchor(ch); [EOL]                 ++pos; [EOL]                 break; [EOL]             case '.': [EOL]                 atom = DOT_CHARSET; [EOL]                 ++pos; [EOL]                 break; [EOL]             case '|': [EOL]                 atom = Empty.INSTANCE; [EOL]                 break; [EOL]             default: [EOL]                 int start = pos; [EOL]                 int end = pos + 1; [EOL]                 charsLoop: while (end < limit) { [EOL]                     switch(pattern.charAt(end)) { [EOL]                         case '[': [EOL]                         case '(': [EOL]                         case ')': [EOL]                         case '\\': [EOL]                         case '^': [EOL]                         case '$': [EOL]                         case '|': [EOL]                         case '.': [EOL]                         case '*': [EOL]                         case '+': [EOL]                         case '?': [EOL]                         case '{': [EOL]                             break charsLoop; [EOL]                         default: [EOL]                             if (end + 1 >= limit || !isRepetitionStart(pattern.charAt(end + 1))) { [EOL]                                 ++end; [EOL]                             } else { [EOL]                                 break charsLoop; [EOL]                             } [EOL]                     } [EOL]                 } [EOL]                 atom = new Text(pattern.substring(start, end)); [EOL]                 pos = end; [EOL]                 break; [EOL]         } [EOL]         if (pos < limit && isRepetitionStart(pattern.charAt(pos))) { [EOL]             atom = parseRepetition(atom); [EOL]         } [EOL]         if (preceder == null) { [EOL]             preceder = atom; [EOL]         } else { [EOL]             preceder = new Concatenation(preceder, atom); [EOL]         } [EOL]         if (pos < limit && pattern.charAt(pos) == '|') { [EOL]             if (alternatives == null) { [EOL]                 alternatives = ImmutableList.builder(); [EOL]             } [EOL]             alternatives.add(preceder); [EOL]             preceder = null; [EOL]             ++pos; [EOL]         } [EOL]     } [EOL]     if (preceder == null) { [EOL]         preceder = Empty.INSTANCE; [EOL]     } [EOL]     if (alternatives != null) { [EOL]         alternatives.add(preceder); [EOL]         return new Alternation(alternatives.build()); [EOL]     } else { [EOL]         return preceder; [EOL]     } [EOL] } <line_num>: 145,248
private RegExpTree parseParenthetical() { [EOL]     Preconditions.checkState(pattern.charAt(pos) == '('); [EOL]     int start = pos; [EOL]     ++pos; [EOL]     boolean capturing = true; [EOL]     int type = 0; [EOL]     if (pos < limit && pattern.charAt(pos) == '?') { [EOL]         if (pos + 1 < limit) { [EOL]             capturing = false; [EOL]             char ch = pattern.charAt(pos + 1); [EOL]             switch(ch) { [EOL]                 case ':': [EOL]                     pos += 2; [EOL]                     break; [EOL]                 case '!': [EOL]                 case '=': [EOL]                     pos += 2; [EOL]                     type = ch; [EOL]                     break; [EOL]                 default: [EOL]                     throw new IllegalArgumentException("Malformed parenthetical: " + pattern.substring(start)); [EOL]             } [EOL]         } [EOL]     } [EOL]     RegExpTree body = parse(); [EOL]     if (pos < limit && pattern.charAt(pos) == ')') { [EOL]         ++pos; [EOL]     } else { [EOL]         throw new IllegalArgumentException("Unclosed parenthetical group: " + pattern.substring(start)); [EOL]     } [EOL]     if (capturing) { [EOL]         ++numCapturingGroups; [EOL]         return new CapturingGroup(body); [EOL]     } else if (type != 0) { [EOL]         return new LookaheadAssertion(body, type == '='); [EOL]     } else { [EOL]         return body; [EOL]     } [EOL] } <line_num>: 255,295
private RegExpTree parseCharset() { [EOL]     Preconditions.checkState(pattern.charAt(pos) == '['); [EOL]     ++pos; [EOL]     boolean isCaseInsensitive = flags.indexOf('i') >= 0; [EOL]     boolean inverse = pos < limit && pattern.charAt(pos) == '^'; [EOL]     if (inverse) { [EOL]         ++pos; [EOL]     } [EOL]     CharRanges ranges = CharRanges.EMPTY; [EOL]     CharRanges ieExplicits = CharRanges.EMPTY; [EOL]     while (pos < limit && pattern.charAt(pos) != ']') { [EOL]         char ch = pattern.charAt(pos); [EOL]         char start; [EOL]         if (ch == '\\') { [EOL]             ++pos; [EOL]             char possibleGroupName = pattern.charAt(pos); [EOL]             CharRanges group = NAMED_CHAR_GROUPS.get(possibleGroupName); [EOL]             if (group != null) { [EOL]                 ++pos; [EOL]                 ranges = ranges.union(group); [EOL]                 continue; [EOL]             } [EOL]             start = parseEscapeChar(); [EOL]         } else { [EOL]             start = ch; [EOL]             ++pos; [EOL]         } [EOL]         char end = start; [EOL]         if (pos + 1 < limit && pattern.charAt(pos) == '-' && pattern.charAt(pos + 1) != ']') { [EOL]             ++pos; [EOL]             ch = pattern.charAt(pos); [EOL]             if (ch == '\\') { [EOL]                 ++pos; [EOL]                 end = parseEscapeChar(); [EOL]             } else { [EOL]                 end = ch; [EOL]                 ++pos; [EOL]             } [EOL]         } [EOL]         CharRanges range = CharRanges.inclusive(start, end); [EOL]         ranges = ranges.union(range); [EOL]         if (IE_SPEC_ERRORS.contains(start) && IE_SPEC_ERRORS.contains(end)) { [EOL]             ieExplicits = ieExplicits.union(range.intersection(IE_SPEC_ERRORS)); [EOL]         } [EOL]         if (isCaseInsensitive) { [EOL]             ranges = CaseCanonicalize.expandToAllMatched(ranges); [EOL]         } [EOL]     } [EOL]     ++pos; [EOL]     if (inverse) { [EOL]         ranges = CharRanges.ALL_CODE_UNITS.difference(ranges); [EOL]     } [EOL]     return new Charset(ranges, ieExplicits); [EOL] } <line_num>: 302,370
private char parseEscapeChar() { [EOL]     char ch = pattern.charAt(pos++); [EOL]     switch(ch) { [EOL]         case 'b': [EOL]             return '\b'; [EOL]         case 'f': [EOL]             return '\f'; [EOL]         case 'n': [EOL]             return '\n'; [EOL]         case 'r': [EOL]             return '\r'; [EOL]         case 't': [EOL]             return '\t'; [EOL]         case 'u': [EOL]             return parseHex(4); [EOL]         case 'v': [EOL]             return '\u000b'; [EOL]         case 'x': [EOL]             return parseHex(2); [EOL]         default: [EOL]             if ('0' <= ch && ch <= '7') { [EOL]                 char codeUnit = (char) (ch - '0'); [EOL]                 int octLimit = Math.min(limit, pos + (ch <= '3' ? 2 : 1) + (ch == '0' ? 1 : 0)); [EOL]                 while (pos < octLimit) { [EOL]                     ch = pattern.charAt(pos); [EOL]                     if ('0' <= ch && ch <= '7') { [EOL]                         codeUnit = (char) ((codeUnit << 3) + (ch - '0')); [EOL]                         ++pos; [EOL]                     } else { [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 return codeUnit; [EOL]             } [EOL]             return ch; [EOL]     } [EOL] } <line_num>: 378,411
private RegExpTree parseEscape() { [EOL]     Preconditions.checkState(pattern.charAt(pos) == '\\'); [EOL]     ++pos; [EOL]     char ch = pattern.charAt(pos); [EOL]     if (ch == 'b' || ch == 'B') { [EOL]         ++pos; [EOL]         return new WordBoundary(ch); [EOL]     } else if ('1' <= ch && ch <= '9') { [EOL]         ++pos; [EOL]         int possibleGroupIndex = ch - '0'; [EOL]         if (numCapturingGroups >= possibleGroupIndex) { [EOL]             if (pos < limit) { [EOL]                 char next = pattern.charAt(pos); [EOL]                 if ('0' <= next && next <= '9') { [EOL]                     int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0'); [EOL]                     if (numCapturingGroups >= twoDigitGroupIndex) { [EOL]                         ++pos; [EOL]                         possibleGroupIndex = twoDigitGroupIndex; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             return new BackReference(possibleGroupIndex); [EOL]         } else { [EOL]             return new Text(Character.toString(possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch)); [EOL]         } [EOL]     } else { [EOL]         CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch); [EOL]         if (charGroup != null) { [EOL]             ++pos; [EOL]             return new Charset(charGroup, CharRanges.EMPTY); [EOL]         } [EOL]         return new Text("" + parseEscapeChar()); [EOL]     } [EOL] } <line_num>: 416,453
private char parseHex(int n) { [EOL]     if (pos + n > limit) { [EOL]         throw new IllegalArgumentException("Abbreviated hex escape " + pattern.substring(pos)); [EOL]     } [EOL]     int result = 0; [EOL]     while (--n >= 0) { [EOL]         char ch = pattern.charAt(pos); [EOL]         int digit; [EOL]         if ('0' <= ch && ch <= '9') { [EOL]             digit = ch - '0'; [EOL]         } else if ('a' <= ch && ch <= 'f') { [EOL]             digit = ch + (10 - 'a'); [EOL]         } else if ('A' <= ch && ch <= 'F') { [EOL]             digit = ch + (10 - 'A'); [EOL]         } else { [EOL]             throw new IllegalArgumentException(pattern.substring(pos)); [EOL]         } [EOL]         ++pos; [EOL]         result = (result << 4) | digit; [EOL]     } [EOL]     return (char) result; [EOL] } <line_num>: 458,480
private boolean isRepetitionStart(char ch) { [EOL]     switch(ch) { [EOL]         case '?': [EOL]         case '*': [EOL]         case '+': [EOL]         case '{': [EOL]             return true; [EOL]         default: [EOL]             return false; [EOL]     } [EOL] } <line_num>: 482,492
private RegExpTree parseRepetition(RegExpTree body) { [EOL]     if (pos == limit) { [EOL]         return body; [EOL]     } [EOL]     int min, max; [EOL]     switch(pattern.charAt(pos)) { [EOL]         case '+': [EOL]             ++pos; [EOL]             min = 1; [EOL]             max = Integer.MAX_VALUE; [EOL]             break; [EOL]         case '*': [EOL]             ++pos; [EOL]             min = 0; [EOL]             max = Integer.MAX_VALUE; [EOL]             break; [EOL]         case '?': [EOL]             ++pos; [EOL]             min = 0; [EOL]             max = 1; [EOL]             break; [EOL]         case '{': [EOL]             ++pos; [EOL]             int start = pos; [EOL]             int end = pattern.indexOf('}', start); [EOL]             if (end < 0) { [EOL]                 pos = start - 1; [EOL]                 return body; [EOL]             } [EOL]             String counts = pattern.substring(start, end); [EOL]             pos = end + 1; [EOL]             int comma = counts.indexOf(','); [EOL]             try { [EOL]                 min = Integer.parseInt(comma >= 0 ? counts.substring(0, comma) : counts); [EOL]                 max = comma >= 0 ? comma + 1 != counts.length() ? Integer.parseInt(counts.substring(comma + 1)) : Integer.MAX_VALUE : min; [EOL]             } catch (NumberFormatException ex) { [EOL]                 min = max = -1; [EOL]             } [EOL]             if (min < 0 || min > max) { [EOL]                 pos = start - 1; [EOL]                 return body; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             return body; [EOL]     } [EOL]     boolean greedy = true; [EOL]     if (pos < limit && pattern.charAt(pos) == '?') { [EOL]         greedy = false; [EOL]         ++pos; [EOL]     } [EOL]     return new Repetition(body, min, max, greedy); [EOL] } <line_num>: 498,554
public static RegExpTree parseRegExp(final String pattern, final String flags) { [EOL]     class Parser { [EOL]  [EOL]         int pos; [EOL]  [EOL]         int numCapturingGroups = 0; [EOL]  [EOL]         final int limit = pattern.length(); [EOL]  [EOL]         RegExpTree parseTopLevel() { [EOL]             this.pos = 0; [EOL]             RegExpTree out = parse(); [EOL]             if (pos < limit) { [EOL]                 throw new IllegalArgumentException(pattern.substring(pos)); [EOL]             } [EOL]             return out; [EOL]         } [EOL]  [EOL]         RegExpTree parse() { [EOL]             ImmutableList.Builder<RegExpTree> alternatives = null; [EOL]             RegExpTree preceder = null; [EOL]             topLoop: while (pos < limit) { [EOL]                 char ch = pattern.charAt(pos); [EOL]                 RegExpTree atom; [EOL]                 switch(ch) { [EOL]                     case '[': [EOL]                         atom = parseCharset(); [EOL]                         break; [EOL]                     case '(': [EOL]                         atom = parseParenthetical(); [EOL]                         break; [EOL]                     case ')': [EOL]                         break topLoop; [EOL]                     case '\\': [EOL]                         atom = parseEscape(); [EOL]                         break; [EOL]                     case '^': [EOL]                     case '$': [EOL]                         atom = new Anchor(ch); [EOL]                         ++pos; [EOL]                         break; [EOL]                     case '.': [EOL]                         atom = DOT_CHARSET; [EOL]                         ++pos; [EOL]                         break; [EOL]                     case '|': [EOL]                         atom = Empty.INSTANCE; [EOL]                         break; [EOL]                     default: [EOL]                         int start = pos; [EOL]                         int end = pos + 1; [EOL]                         charsLoop: while (end < limit) { [EOL]                             switch(pattern.charAt(end)) { [EOL]                                 case '[': [EOL]                                 case '(': [EOL]                                 case ')': [EOL]                                 case '\\': [EOL]                                 case '^': [EOL]                                 case '$': [EOL]                                 case '|': [EOL]                                 case '.': [EOL]                                 case '*': [EOL]                                 case '+': [EOL]                                 case '?': [EOL]                                 case '{': [EOL]                                     break charsLoop; [EOL]                                 default: [EOL]                                     if (end + 1 >= limit || !isRepetitionStart(pattern.charAt(end + 1))) { [EOL]                                         ++end; [EOL]                                     } else { [EOL]                                         break charsLoop; [EOL]                                     } [EOL]                             } [EOL]                         } [EOL]                         atom = new Text(pattern.substring(start, end)); [EOL]                         pos = end; [EOL]                         break; [EOL]                 } [EOL]                 if (pos < limit && isRepetitionStart(pattern.charAt(pos))) { [EOL]                     atom = parseRepetition(atom); [EOL]                 } [EOL]                 if (preceder == null) { [EOL]                     preceder = atom; [EOL]                 } else { [EOL]                     preceder = new Concatenation(preceder, atom); [EOL]                 } [EOL]                 if (pos < limit && pattern.charAt(pos) == '|') { [EOL]                     if (alternatives == null) { [EOL]                         alternatives = ImmutableList.builder(); [EOL]                     } [EOL]                     alternatives.add(preceder); [EOL]                     preceder = null; [EOL]                     ++pos; [EOL]                 } [EOL]             } [EOL]             if (preceder == null) { [EOL]                 preceder = Empty.INSTANCE; [EOL]             } [EOL]             if (alternatives != null) { [EOL]                 alternatives.add(preceder); [EOL]                 return new Alternation(alternatives.build()); [EOL]             } else { [EOL]                 return preceder; [EOL]             } [EOL]         } [EOL]  [EOL]         private RegExpTree parseParenthetical() { [EOL]             Preconditions.checkState(pattern.charAt(pos) == '('); [EOL]             int start = pos; [EOL]             ++pos; [EOL]             boolean capturing = true; [EOL]             int type = 0; [EOL]             if (pos < limit && pattern.charAt(pos) == '?') { [EOL]                 if (pos + 1 < limit) { [EOL]                     capturing = false; [EOL]                     char ch = pattern.charAt(pos + 1); [EOL]                     switch(ch) { [EOL]                         case ':': [EOL]                             pos += 2; [EOL]                             break; [EOL]                         case '!': [EOL]                         case '=': [EOL]                             pos += 2; [EOL]                             type = ch; [EOL]                             break; [EOL]                         default: [EOL]                             throw new IllegalArgumentException("Malformed parenthetical: " + pattern.substring(start)); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             RegExpTree body = parse(); [EOL]             if (pos < limit && pattern.charAt(pos) == ')') { [EOL]                 ++pos; [EOL]             } else { [EOL]                 throw new IllegalArgumentException("Unclosed parenthetical group: " + pattern.substring(start)); [EOL]             } [EOL]             if (capturing) { [EOL]                 ++numCapturingGroups; [EOL]                 return new CapturingGroup(body); [EOL]             } else if (type != 0) { [EOL]                 return new LookaheadAssertion(body, type == '='); [EOL]             } else { [EOL]                 return body; [EOL]             } [EOL]         } [EOL]  [EOL]         private RegExpTree parseCharset() { [EOL]             Preconditions.checkState(pattern.charAt(pos) == '['); [EOL]             ++pos; [EOL]             boolean isCaseInsensitive = flags.indexOf('i') >= 0; [EOL]             boolean inverse = pos < limit && pattern.charAt(pos) == '^'; [EOL]             if (inverse) { [EOL]                 ++pos; [EOL]             } [EOL]             CharRanges ranges = CharRanges.EMPTY; [EOL]             CharRanges ieExplicits = CharRanges.EMPTY; [EOL]             while (pos < limit && pattern.charAt(pos) != ']') { [EOL]                 char ch = pattern.charAt(pos); [EOL]                 char start; [EOL]                 if (ch == '\\') { [EOL]                     ++pos; [EOL]                     char possibleGroupName = pattern.charAt(pos); [EOL]                     CharRanges group = NAMED_CHAR_GROUPS.get(possibleGroupName); [EOL]                     if (group != null) { [EOL]                         ++pos; [EOL]                         ranges = ranges.union(group); [EOL]                         continue; [EOL]                     } [EOL]                     start = parseEscapeChar(); [EOL]                 } else { [EOL]                     start = ch; [EOL]                     ++pos; [EOL]                 } [EOL]                 char end = start; [EOL]                 if (pos + 1 < limit && pattern.charAt(pos) == '-' && pattern.charAt(pos + 1) != ']') { [EOL]                     ++pos; [EOL]                     ch = pattern.charAt(pos); [EOL]                     if (ch == '\\') { [EOL]                         ++pos; [EOL]                         end = parseEscapeChar(); [EOL]                     } else { [EOL]                         end = ch; [EOL]                         ++pos; [EOL]                     } [EOL]                 } [EOL]                 CharRanges range = CharRanges.inclusive(start, end); [EOL]                 ranges = ranges.union(range); [EOL]                 if (IE_SPEC_ERRORS.contains(start) && IE_SPEC_ERRORS.contains(end)) { [EOL]                     ieExplicits = ieExplicits.union(range.intersection(IE_SPEC_ERRORS)); [EOL]                 } [EOL]                 if (isCaseInsensitive) { [EOL]                     ranges = CaseCanonicalize.expandToAllMatched(ranges); [EOL]                 } [EOL]             } [EOL]             ++pos; [EOL]             if (inverse) { [EOL]                 ranges = CharRanges.ALL_CODE_UNITS.difference(ranges); [EOL]             } [EOL]             return new Charset(ranges, ieExplicits); [EOL]         } [EOL]  [EOL]         private char parseEscapeChar() { [EOL]             char ch = pattern.charAt(pos++); [EOL]             switch(ch) { [EOL]                 case 'b': [EOL]                     return '\b'; [EOL]                 case 'f': [EOL]                     return '\f'; [EOL]                 case 'n': [EOL]                     return '\n'; [EOL]                 case 'r': [EOL]                     return '\r'; [EOL]                 case 't': [EOL]                     return '\t'; [EOL]                 case 'u': [EOL]                     return parseHex(4); [EOL]                 case 'v': [EOL]                     return '\u000b'; [EOL]                 case 'x': [EOL]                     return parseHex(2); [EOL]                 default: [EOL]                     if ('0' <= ch && ch <= '7') { [EOL]                         char codeUnit = (char) (ch - '0'); [EOL]                         int octLimit = Math.min(limit, pos + (ch <= '3' ? 2 : 1) + (ch == '0' ? 1 : 0)); [EOL]                         while (pos < octLimit) { [EOL]                             ch = pattern.charAt(pos); [EOL]                             if ('0' <= ch && ch <= '7') { [EOL]                                 codeUnit = (char) ((codeUnit << 3) + (ch - '0')); [EOL]                                 ++pos; [EOL]                             } else { [EOL]                                 break; [EOL]                             } [EOL]                         } [EOL]                         return codeUnit; [EOL]                     } [EOL]                     return ch; [EOL]             } [EOL]         } [EOL]  [EOL]         private RegExpTree parseEscape() { [EOL]             Preconditions.checkState(pattern.charAt(pos) == '\\'); [EOL]             ++pos; [EOL]             char ch = pattern.charAt(pos); [EOL]             if (ch == 'b' || ch == 'B') { [EOL]                 ++pos; [EOL]                 return new WordBoundary(ch); [EOL]             } else if ('1' <= ch && ch <= '9') { [EOL]                 ++pos; [EOL]                 int possibleGroupIndex = ch - '0'; [EOL]                 if (numCapturingGroups >= possibleGroupIndex) { [EOL]                     if (pos < limit) { [EOL]                         char next = pattern.charAt(pos); [EOL]                         if ('0' <= next && next <= '9') { [EOL]                             int twoDigitGroupIndex = possibleGroupIndex * 10 + (next - '0'); [EOL]                             if (numCapturingGroups >= twoDigitGroupIndex) { [EOL]                                 ++pos; [EOL]                                 possibleGroupIndex = twoDigitGroupIndex; [EOL]                             } [EOL]                         } [EOL]                     } [EOL]                     return new BackReference(possibleGroupIndex); [EOL]                 } else { [EOL]                     return new Text(Character.toString(possibleGroupIndex <= 7 ? (char) possibleGroupIndex : ch)); [EOL]                 } [EOL]             } else { [EOL]                 CharRanges charGroup = NAMED_CHAR_GROUPS.get(ch); [EOL]                 if (charGroup != null) { [EOL]                     ++pos; [EOL]                     return new Charset(charGroup, CharRanges.EMPTY); [EOL]                 } [EOL]                 return new Text("" + parseEscapeChar()); [EOL]             } [EOL]         } [EOL]  [EOL]         private char parseHex(int n) { [EOL]             if (pos + n > limit) { [EOL]                 throw new IllegalArgumentException("Abbreviated hex escape " + pattern.substring(pos)); [EOL]             } [EOL]             int result = 0; [EOL]             while (--n >= 0) { [EOL]                 char ch = pattern.charAt(pos); [EOL]                 int digit; [EOL]                 if ('0' <= ch && ch <= '9') { [EOL]                     digit = ch - '0'; [EOL]                 } else if ('a' <= ch && ch <= 'f') { [EOL]                     digit = ch + (10 - 'a'); [EOL]                 } else if ('A' <= ch && ch <= 'F') { [EOL]                     digit = ch + (10 - 'A'); [EOL]                 } else { [EOL]                     throw new IllegalArgumentException(pattern.substring(pos)); [EOL]                 } [EOL]                 ++pos; [EOL]                 result = (result << 4) | digit; [EOL]             } [EOL]             return (char) result; [EOL]         } [EOL]  [EOL]         private boolean isRepetitionStart(char ch) { [EOL]             switch(ch) { [EOL]                 case '?': [EOL]                 case '*': [EOL]                 case '+': [EOL]                 case '{': [EOL]                     return true; [EOL]                 default: [EOL]                     return false; [EOL]             } [EOL]         } [EOL]  [EOL]         private RegExpTree parseRepetition(RegExpTree body) { [EOL]             if (pos == limit) { [EOL]                 return body; [EOL]             } [EOL]             int min, max; [EOL]             switch(pattern.charAt(pos)) { [EOL]                 case '+': [EOL]                     ++pos; [EOL]                     min = 1; [EOL]                     max = Integer.MAX_VALUE; [EOL]                     break; [EOL]                 case '*': [EOL]                     ++pos; [EOL]                     min = 0; [EOL]                     max = Integer.MAX_VALUE; [EOL]                     break; [EOL]                 case '?': [EOL]                     ++pos; [EOL]                     min = 0; [EOL]                     max = 1; [EOL]                     break; [EOL]                 case '{': [EOL]                     ++pos; [EOL]                     int start = pos; [EOL]                     int end = pattern.indexOf('}', start); [EOL]                     if (end < 0) { [EOL]                         pos = start - 1; [EOL]                         return body; [EOL]                     } [EOL]                     String counts = pattern.substring(start, end); [EOL]                     pos = end + 1; [EOL]                     int comma = counts.indexOf(','); [EOL]                     try { [EOL]                         min = Integer.parseInt(comma >= 0 ? counts.substring(0, comma) : counts); [EOL]                         max = comma >= 0 ? comma + 1 != counts.length() ? Integer.parseInt(counts.substring(comma + 1)) : Integer.MAX_VALUE : min; [EOL]                     } catch (NumberFormatException ex) { [EOL]                         min = max = -1; [EOL]                     } [EOL]                     if (min < 0 || min > max) { [EOL]                         pos = start - 1; [EOL]                         return body; [EOL]                     } [EOL]                     break; [EOL]                 default: [EOL]                     return body; [EOL]             } [EOL]             boolean greedy = true; [EOL]             if (pos < limit && pattern.charAt(pos) == '?') { [EOL]                 greedy = false; [EOL]                 ++pos; [EOL]             } [EOL]             return new Repetition(body, min, max, greedy); [EOL]         } [EOL]     } [EOL]     return new Parser().parseTopLevel(); [EOL] } <line_num>: 124,558
public static boolean matchesWholeInput(RegExpTree t, String flags) { [EOL]     if (flags.indexOf('m') >= 0) { [EOL]         return false; [EOL]     } [EOL]     if (!(t instanceof Concatenation)) { [EOL]         return false; [EOL]     } [EOL]     Concatenation c = (Concatenation) t; [EOL]     if (c.elements.isEmpty()) { [EOL]         return false; [EOL]     } [EOL]     RegExpTree first = c.elements.get(0), last = c.elements.get(c.elements.size() - 1); [EOL]     if (!(first instanceof Anchor && last instanceof Anchor)) { [EOL]         return false; [EOL]     } [EOL]     return ((Anchor) first).type == '^' && ((Anchor) last).type == '$'; [EOL] } <line_num>: 565,578
@Override [EOL] public boolean isCaseSensitive() { [EOL]     return false; [EOL] } <line_num>: 582,585
@Override [EOL] public boolean containsAnchor() { [EOL]     return false; [EOL] } <line_num>: 587,590
@Override [EOL] public final int numCapturingGroups() { [EOL]     return 0; [EOL] } <line_num>: 592,595
@Override [EOL] public final List<? extends RegExpTree> children() { [EOL]     return ImmutableList.of(); [EOL] } <line_num>: 597,600
@Override [EOL] public RegExpTree simplify(String flags) { [EOL]     return this; [EOL] } <line_num>: 606,609
@Override [EOL] protected void appendSourceCode(StringBuilder sb) { [EOL] } <line_num>: 611,614
@Override [EOL] protected void appendDebugInfo(StringBuilder sb) { [EOL] } <line_num>: 616,619
@Override [EOL] public boolean equals(Object o) { [EOL]     return o instanceof Empty; [EOL] } <line_num>: 621,624
@Override [EOL] public int hashCode() { [EOL]     return 0x7ee06141; [EOL] } <line_num>: 626,629
@Override [EOL] public RegExpTree simplify(String flags) { [EOL]     return this; [EOL] } <line_num>: 636,639
@Override [EOL] public boolean containsAnchor() { [EOL]     return true; [EOL] } <line_num>: 641,644
@Override [EOL] protected void appendSourceCode(StringBuilder sb) { [EOL]     sb.append(type); [EOL] } <line_num>: 646,649
@Override [EOL] protected void appendDebugInfo(StringBuilder sb) { [EOL]     sb.append(type); [EOL] } <line_num>: 651,654
@Override [EOL] public boolean equals(Object o) { [EOL]     return o instanceof Anchor && type == ((Anchor) o).type; [EOL] } <line_num>: 656,659
@Override [EOL] public int hashCode() { [EOL]     return type ^ 0xe85317ff; [EOL] } <line_num>: 661,664
@Override [EOL] public RegExpTree simplify(String flags) { [EOL]     return this; [EOL] } <line_num>: 674,677
@Override [EOL] protected void appendSourceCode(StringBuilder sb) { [EOL]     sb.append('\\').append(type); [EOL] } <line_num>: 679,682
@Override [EOL] protected void appendDebugInfo(StringBuilder sb) { [EOL]     sb.append(type); [EOL] } <line_num>: 684,687
@Override [EOL] public boolean equals(Object o) { [EOL]     return o instanceof WordBoundary && type == ((WordBoundary) o).type; [EOL] } <line_num>: 689,692
@Override [EOL] public int hashCode() { [EOL]     return 0x5673aa29 ^ type; [EOL] } <line_num>: 694,697
@Override [EOL] public RegExpTree simplify(String flags) { [EOL]     return this; [EOL] } <line_num>: 708,711
@Override [EOL] protected void appendSourceCode(StringBuilder sb) { [EOL]     sb.append('\\').append(groupIndex); [EOL] } <line_num>: 713,716
@Override [EOL] protected void appendDebugInfo(StringBuilder sb) { [EOL]     sb.append(groupIndex); [EOL] } <line_num>: 718,721
@Override [EOL] public boolean equals(Object o) { [EOL]     return o instanceof BackReference && groupIndex == ((BackReference) o).groupIndex; [EOL] } <line_num>: 723,727
@Override [EOL] public int hashCode() { [EOL]     return 0xff072663 ^ groupIndex; [EOL] } <line_num>: 729,732
private static void escapeRegularCharOnto(char ch, int next, StringBuilder sb) { [EOL]     switch(ch) { [EOL]         case '$': [EOL]         case '^': [EOL]         case '*': [EOL]         case '(': [EOL]         case ')': [EOL]         case '+': [EOL]         case '[': [EOL]         case '|': [EOL]         case '.': [EOL]         case '/': [EOL]         case '?': [EOL]             sb.append('\\').append(ch); [EOL]             break; [EOL]         case '{': [EOL]             if ('0' <= next && next <= '9') { [EOL]                 sb.append('\\'); [EOL]             } [EOL]             sb.append(ch); [EOL]             break; [EOL]         default: [EOL]             escapeCharOnto(ch, sb); [EOL]     } [EOL] } <line_num>: 746,773
@Override [EOL] public RegExpTree simplify(String flags) { [EOL]     int n = text.length(); [EOL]     if (n == 0) { [EOL]         return Empty.INSTANCE; [EOL]     } [EOL]     if (flags.indexOf('i') >= 0) { [EOL]         String canonicalized = CaseCanonicalize.caseCanonicalize(text); [EOL]         if (text != canonicalized) { [EOL]             return new Text(canonicalized); [EOL]         } [EOL]     } [EOL]     return this; [EOL] } <line_num>: 775,788
@Override [EOL] public boolean isCaseSensitive() { [EOL]     for (int i = 0, n = text.length(); i < n; ++i) { [EOL]         if (CaseCanonicalize.CASE_SENSITIVE.contains(text.charAt(i))) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 790,798
@Override [EOL] protected void appendSourceCode(StringBuilder sb) { [EOL]     for (int i = 0, n = text.length(); i < n; ++i) { [EOL]         escapeRegularCharOnto(text.charAt(i), i + 1 < n ? text.charAt(i + 1) : -1, sb); [EOL]     } [EOL] } <line_num>: 800,805
@Override [EOL] protected void appendDebugInfo(StringBuilder sb) { [EOL]     sb.append('`').append(text).append('`'); [EOL] } <line_num>: 807,810
@Override [EOL] public boolean equals(Object o) { [EOL]     return o instanceof Text && text.equals(((Text) o).text); [EOL] } <line_num>: 812,815
@Override [EOL] public int hashCode() { [EOL]     return text.hashCode() ^ 0x617e310; [EOL] } <line_num>: 817,820
@Override [EOL] public RegExpTree simplify(String flags) { [EOL]     RegExpTree body = this.body.simplify(flags); [EOL]     if (max == 0 && !body.hasCapturingGroup()) { [EOL]         return Empty.INSTANCE; [EOL]     } [EOL]     if (body instanceof Empty || NEVER_MATCHES.equals(body)) { [EOL]         return body; [EOL]     } [EOL]     int min = this.min; [EOL]     int max = this.max; [EOL]     if (body instanceof Repetition) { [EOL]         Repetition rbody = (Repetition) body; [EOL]         if (rbody.greedy == greedy) { [EOL]             long lmin = ((long) min) * rbody.min; [EOL]             long lmax = ((long) max) * rbody.max; [EOL]             if (lmin < Integer.MAX_VALUE) { [EOL]                 body = rbody.body; [EOL]                 min = (int) lmin; [EOL]                 max = lmax >= Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) lmax; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (min == 1 && max == 1) { [EOL]         return body; [EOL]     } [EOL]     boolean greedy = this.greedy || min == max; [EOL]     return body.equals(this.body) && min == this.min && max == this.max && greedy == this.greedy ? this : new Repetition(body, min, max, greedy).simplify(flags); [EOL] } <line_num>: 835,860
@Override [EOL] public boolean isCaseSensitive() { [EOL]     return body.isCaseSensitive(); [EOL] } <line_num>: 862,865
@Override [EOL] public boolean containsAnchor() { [EOL]     return body.containsAnchor(); [EOL] } <line_num>: 867,870
@Override [EOL] public int numCapturingGroups() { [EOL]     return body.numCapturingGroups(); [EOL] } <line_num>: 872,875
@Override [EOL] public List<? extends RegExpTree> children() { [EOL]     return ImmutableList.of(body); [EOL] } <line_num>: 877,880
private void appendBodySourceCode(StringBuilder sb) { [EOL]     if (body instanceof Alternation || body instanceof Concatenation || body instanceof Repetition || (body instanceof Text && ((Text) body).text.length() > 1)) { [EOL]         sb.append("(?:"); [EOL]         body.appendSourceCode(sb); [EOL]         sb.append(')'); [EOL]     } else { [EOL]         body.appendSourceCode(sb); [EOL]     } [EOL] } <line_num>: 882,892
private static int suffixLen(int min, int max) { [EOL]     if (max == Integer.MAX_VALUE) { [EOL]         switch(min) { [EOL]             case 0: [EOL]                 return 1; [EOL]             case 1: [EOL]                 return 1; [EOL]             default: [EOL]                 return 3 + numDecimalDigits(min); [EOL]         } [EOL]     } [EOL]     if (min == 0 && max == 1) { [EOL]         return 1; [EOL]     } [EOL]     if (min == max) { [EOL]         if (min == 1) { [EOL]             return 0; [EOL]         } [EOL]         return 2 + numDecimalDigits(min); [EOL]     } [EOL]     return 3 + numDecimalDigits(min) + numDecimalDigits(max); [EOL] } <line_num>: 894,913
private static int numDecimalDigits(int n) { [EOL]     if (n < 0) { [EOL]         throw new AssertionError(); [EOL]     } [EOL]     int nDigits = 1; [EOL]     while (n >= 10) { [EOL]         ++nDigits; [EOL]         n /= 10; [EOL]     } [EOL]     return nDigits; [EOL] } <line_num>: 915,928
@Override [EOL] protected void appendSourceCode(StringBuilder sb) { [EOL]     int bodyStart = sb.length(); [EOL]     appendBodySourceCode(sb); [EOL]     int bodyEnd = sb.length(); [EOL]     int bodyLen = bodyEnd - bodyStart; [EOL]     int min = this.min; [EOL]     int max = this.max; [EOL]     if (min >= 2 && max == Integer.MAX_VALUE || max - min <= 1) { [EOL]         int expanded = min == max || max == Integer.MAX_VALUE ? min - 1 : min; [EOL]         int expandedMin = min - expanded; [EOL]         int expandedMax = max == Integer.MAX_VALUE ? max : max - expanded; [EOL]         int suffixLen = suffixLen(min, max); [EOL]         int expandedSuffixLen = suffixLen(expandedMin, expandedMax); [EOL]         if (bodyLen * expanded + expandedSuffixLen < suffixLen && !body.hasCapturingGroup()) { [EOL]             while (--expanded >= 0) { [EOL]                 sb.append(sb, bodyStart, bodyEnd); [EOL]             } [EOL]             min = expandedMin; [EOL]             max = expandedMax; [EOL]         } [EOL]     } [EOL]     if (max == Integer.MAX_VALUE) { [EOL]         switch(min) { [EOL]             case 0: [EOL]                 sb.append('*'); [EOL]                 break; [EOL]             case 1: [EOL]                 sb.append('+'); [EOL]                 break; [EOL]             default: [EOL]                 sb.append('{').append(min).append(",}"); [EOL]         } [EOL]     } else if (min == 0 && max == 1) { [EOL]         sb.append('?'); [EOL]     } else if (min == max) { [EOL]         if (min != 1) { [EOL]             sb.append('{').append(min).append('}'); [EOL]         } [EOL]     } else { [EOL]         sb.append('{').append(min).append(',').append(max).append('}'); [EOL]     } [EOL]     if (!greedy) { [EOL]         sb.append('?'); [EOL]     } [EOL] } <line_num>: 930,984
@Override [EOL] protected void appendDebugInfo(StringBuilder sb) { [EOL]     sb.append(" min=").append(min).append(", max=").append(max); [EOL]     if (!greedy) { [EOL]         sb.append("  not_greedy"); [EOL]     } [EOL] } <line_num>: 986,990
@Override [EOL] public boolean equals(Object o) { [EOL]     if (!(o instanceof Repetition)) { [EOL]         return false; [EOL]     } [EOL]     Repetition that = (Repetition) o; [EOL]     return this.body.equals(that.body) && this.min == that.min && this.max == that.max && this.greedy == that.greedy; [EOL] } <line_num>: 992,1000
@Override [EOL] public int hashCode() { [EOL]     return min + 31 * (max + 31 * ((greedy ? 1 : 0) + 31 * body.hashCode())); [EOL] } <line_num>: 1002,1005
@Override [EOL] public RegExpTree simplify(String flags) { [EOL]     List<RegExpTree> alternatives = Lists.newArrayList(); [EOL]     for (RegExpTree alternative : this.alternatives) { [EOL]         alternative = alternative.simplify(flags); [EOL]         if (alternative instanceof Alternation) { [EOL]             alternatives.addAll(((Alternation) alternative).alternatives); [EOL]         } else { [EOL]             alternatives.add(alternative); [EOL]         } [EOL]     } [EOL]     RegExpTree last = null; [EOL]     for (Iterator<RegExpTree> it = alternatives.iterator(); it.hasNext(); ) { [EOL]         RegExpTree alternative = it.next(); [EOL]         if (alternative.equals(NEVER_MATCHES)) { [EOL]             continue; [EOL]         } [EOL]         if (alternative.equals(last) && !alternative.hasCapturingGroup()) { [EOL]             it.remove(); [EOL]         } else { [EOL]             last = alternative; [EOL]         } [EOL]     } [EOL]     for (int i = 0, n = alternatives.size(); i < n; ++i) { [EOL]         RegExpTree alternative = alternatives.get(i); [EOL]         if ((alternative instanceof Text && ((Text) alternative).text.length() == 1) || alternative instanceof Charset) { [EOL]             int end = i; [EOL]             int nCharsets = 0; [EOL]             while (end < n) { [EOL]                 RegExpTree follower = alternatives.get(end); [EOL]                 if (follower instanceof Charset) { [EOL]                     ++nCharsets; [EOL]                 } else if (!(follower instanceof Text && ((Text) follower).text.length() == 1)) { [EOL]                     break; [EOL]                 } [EOL]                 ++end; [EOL]             } [EOL]             if (end - i >= 3 || (nCharsets != 0 && end - i >= 2)) { [EOL]                 int[] members = new int[end - i - nCharsets]; [EOL]                 int memberIdx = 0; [EOL]                 CharRanges chars = CharRanges.EMPTY; [EOL]                 CharRanges ieExplicits = CharRanges.EMPTY; [EOL]                 List<RegExpTree> charAlternatives = alternatives.subList(i, end); [EOL]                 for (RegExpTree charAlternative : charAlternatives) { [EOL]                     if (charAlternative instanceof Text) { [EOL]                         char ch = ((Text) charAlternative).text.charAt(0); [EOL]                         members[memberIdx++] = ch; [EOL]                         if (IE_SPEC_ERRORS.contains(ch)) { [EOL]                             ieExplicits = ieExplicits.union(CharRanges.inclusive(ch, ch)); [EOL]                         } [EOL]                     } else if (charAlternative instanceof Charset) { [EOL]                         Charset cs = (Charset) charAlternative; [EOL]                         chars = chars.union(cs.ranges); [EOL]                         ieExplicits = ieExplicits.union(cs.ieExplicits); [EOL]                     } [EOL]                 } [EOL]                 chars = chars.union(CharRanges.withMembers(members)); [EOL]                 charAlternatives.clear(); [EOL]                 charAlternatives.add(new Charset(chars, ieExplicits).simplify(flags)); [EOL]                 n = alternatives.size(); [EOL]             } [EOL]         } [EOL]     } [EOL]     switch(alternatives.size()) { [EOL]         case 0: [EOL]             return Empty.INSTANCE; [EOL]         case 1: [EOL]             return alternatives.get(0); [EOL]         case 2: [EOL]             if (alternatives.get(1) instanceof Empty) { [EOL]                 return new Repetition(alternatives.get(0), 0, 1, true); [EOL]             } else if (alternatives.get(0) instanceof Empty) { [EOL]                 return new Repetition(alternatives.get(1), 0, 1, false); [EOL]             } [EOL]             break; [EOL]     } [EOL]     return alternatives.equals(this.alternatives) ? this : new Alternation(alternatives); [EOL] } <line_num>: 1015,1096
@Override [EOL] public boolean isCaseSensitive() { [EOL]     for (RegExpTree alternative : alternatives) { [EOL]         if (alternative.isCaseSensitive()) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1098,1104
@Override [EOL] public boolean containsAnchor() { [EOL]     for (RegExpTree alternative : alternatives) { [EOL]         if (alternative.containsAnchor()) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1106,1112
@Override [EOL] public int numCapturingGroups() { [EOL]     int n = 0; [EOL]     for (RegExpTree alternative : alternatives) { [EOL]         n += alternative.numCapturingGroups(); [EOL]     } [EOL]     return n; [EOL] } <line_num>: 1114,1121
@Override [EOL] public List<? extends RegExpTree> children() { [EOL]     return alternatives; [EOL] } <line_num>: 1123,1126
@Override [EOL] protected void appendSourceCode(StringBuilder sb) { [EOL]     for (int i = 0, n = alternatives.size(); i < n; ++i) { [EOL]         if (i != 0) { [EOL]             sb.append('|'); [EOL]         } [EOL]         alternatives.get(i).appendSourceCode(sb); [EOL]     } [EOL] } <line_num>: 1128,1136
@Override [EOL] protected void appendDebugInfo(StringBuilder sb) { [EOL] } <line_num>: 1138,1141
@Override [EOL] public boolean equals(Object o) { [EOL]     return this == o || ((o instanceof Alternation) && alternatives.equals(((Alternation) o).alternatives)); [EOL] } <line_num>: 1143,1148
@Override [EOL] public int hashCode() { [EOL]     return 0x51b57cd1 ^ alternatives.hashCode(); [EOL] } <line_num>: 1150,1153
@Override [EOL] public RegExpTree simplify(String flags) { [EOL]     RegExpTree simpleBody = body.simplify(flags); [EOL]     if (simpleBody instanceof Empty) { [EOL]         if (positive) { [EOL]             return simpleBody; [EOL]         } [EOL]     } [EOL]     return new LookaheadAssertion(simpleBody, positive); [EOL] } <line_num>: 1168,1177
@Override [EOL] public boolean isCaseSensitive() { [EOL]     return body.isCaseSensitive(); [EOL] } <line_num>: 1179,1182
@Override [EOL] public boolean containsAnchor() { [EOL]     return body.containsAnchor(); [EOL] } <line_num>: 1184,1187
@Override [EOL] public int numCapturingGroups() { [EOL]     return body.numCapturingGroups(); [EOL] } <line_num>: 1189,1192
@Override [EOL] public List<? extends RegExpTree> children() { [EOL]     return ImmutableList.of(body); [EOL] } <line_num>: 1194,1197
@Override [EOL] protected void appendSourceCode(StringBuilder sb) { [EOL]     sb.append(positive ? "(?=" : "(?!"); [EOL]     body.appendSourceCode(sb); [EOL]     sb.append(')'); [EOL] } <line_num>: 1199,1204
@Override [EOL] protected void appendDebugInfo(StringBuilder sb) { [EOL]     sb.append(positive ? "positive" : "negative"); [EOL] } <line_num>: 1206,1209
@Override [EOL] public boolean equals(Object o) { [EOL]     if (!(o instanceof LookaheadAssertion)) { [EOL]         return false; [EOL]     } [EOL]     LookaheadAssertion that = (LookaheadAssertion) o; [EOL]     return this.positive == that.positive && this.body.equals(that.body); [EOL] } <line_num>: 1211,1216
@Override [EOL] public int hashCode() { [EOL]     return 0x723aba9 ^ body.hashCode(); [EOL] } <line_num>: 1218,1221
@Override [EOL] public RegExpTree simplify(String flags) { [EOL]     return new CapturingGroup(body.simplify(flags)); [EOL] } <line_num>: 1231,1234
@Override [EOL] public boolean isCaseSensitive() { [EOL]     return body.isCaseSensitive(); [EOL] } <line_num>: 1236,1239
@Override [EOL] public boolean containsAnchor() { [EOL]     return body.containsAnchor(); [EOL] } <line_num>: 1241,1244
@Override [EOL] public int numCapturingGroups() { [EOL]     return 1; [EOL] } <line_num>: 1246,1249
@Override [EOL] public List<? extends RegExpTree> children() { [EOL]     return ImmutableList.of(body); [EOL] } <line_num>: 1251,1254
@Override [EOL] protected void appendSourceCode(StringBuilder sb) { [EOL]     sb.append('('); [EOL]     body.appendSourceCode(sb); [EOL]     sb.append(')'); [EOL] } <line_num>: 1256,1261
@Override [EOL] protected void appendDebugInfo(StringBuilder sb) { [EOL] } <line_num>: 1263,1266
@Override [EOL] public boolean equals(Object o) { [EOL]     return o instanceof CapturingGroup && body.equals(((CapturingGroup) o).body); [EOL] } <line_num>: 1268,1272
@Override [EOL] public int hashCode() { [EOL]     return 0x55781738 ^ body.hashCode(); [EOL] } <line_num>: 1274,1277
private static int complexityWordFolded(CharRanges ranges) { [EOL]     return Math.min(complexityWordFoldedHelper(ranges), 1 + complexityWordFoldedHelper(CharRanges.ALL_CODE_UNITS.difference(ranges))); [EOL] } <line_num>: 1349,1354
private static int complexityWordFoldedHelper(CharRanges ranges) { [EOL]     int complexity = DecomposedCharset.complexity(ranges); [EOL]     if (ranges.containsAll(WORD_CHARS)) { [EOL]         complexity = Math.min(complexity, 1 + DecomposedCharset.complexity(ranges.difference(WORD_CHARS))); [EOL]     } [EOL]     if (ranges.containsAll(INVERSE_WORD_CHARS)) { [EOL]         complexity = Math.min(complexity, 1 + DecomposedCharset.complexity(ranges.difference(INVERSE_WORD_CHARS))); [EOL]     } [EOL]     return complexity; [EOL] } <line_num>: 1356,1370
@Override [EOL] public RegExpTree simplify(String flags) { [EOL]     if (ranges.isEmpty()) { [EOL]         return NEVER_MATCHES; [EOL]     } [EOL]     CharRanges best = ranges; [EOL]     if (flags.indexOf('i') >= 0) { [EOL]         Set<CharRanges> options = Sets.newLinkedHashSet(); [EOL]         options.add(CaseCanonicalize.expandToAllMatched(ranges)); [EOL]         options.add(CaseCanonicalize.reduceToMinimum(ranges)); [EOL]         CharRanges lcaseLetters = ranges.intersection(LCASE_LETTERS); [EOL]         CharRanges ucaseLetters = ranges.intersection(UCASE_LETTERS); [EOL]         CharRanges lcaseLettersToUpper = lcaseLetters.shift(-32); [EOL]         CharRanges ucaseLettersToLower = ucaseLetters.shift(32); [EOL]         options.add(ranges.union(ucaseLettersToLower)); [EOL]         options.add(ranges.union(lcaseLettersToUpper)); [EOL]         options.add(ranges.union(lcaseLettersToUpper).union(ucaseLettersToLower)); [EOL]         options.add(ranges.union(ucaseLettersToLower).difference(ucaseLetters)); [EOL]         options.add(ranges.union(lcaseLettersToUpper).difference(lcaseLetters)); [EOL]         int bestComplexity = complexityWordFolded(ranges); [EOL]         for (CharRanges option : options) { [EOL]             int complexity = complexityWordFolded(option); [EOL]             if (complexity < bestComplexity) { [EOL]                 bestComplexity = complexity; [EOL]                 best = option; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (best.getNumRanges() == 1 && best.end(0) - best.start(0) == 1) { [EOL]         return new Text(Character.toString((char) best.start(0))); [EOL]     } [EOL]     if (!best.equals(ranges)) { [EOL]         return new Charset(best, ieExplicits); [EOL]     } [EOL]     return this; [EOL] } <line_num>: 1372,1418
@Override [EOL] public boolean isCaseSensitive() { [EOL]     CharRanges withoutNamedGroups = decompose().ranges; [EOL]     return !withoutNamedGroups.equals(CaseCanonicalize.expandToAllMatched(withoutNamedGroups)); [EOL] } <line_num>: 1420,1433
private DecomposedCharset decompose(CharRanges ranges, boolean inverted) { [EOL]     StringBuilder namedGroups = new StringBuilder(); [EOL]     CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits); [EOL]     while (true) { [EOL]         char groupName = 0; [EOL]         CharRanges simplest = null; [EOL]         int minComplexity = DecomposedCharset.complexity(ranges); [EOL]         for (Map.Entry<Character, CharRanges> namedGroup : NAMED_CHAR_GROUPS.entrySet()) { [EOL]             CharRanges group = namedGroup.getValue(); [EOL]             if (ranges.containsAll(group)) { [EOL]                 CharRanges withoutGroup = ranges.difference(group).union(rangesInterIeExplicits); [EOL]                 int complexity = DecomposedCharset.complexity(withoutGroup); [EOL]                 if (complexity < minComplexity) { [EOL]                     simplest = withoutGroup; [EOL]                     groupName = namedGroup.getKey().charValue(); [EOL]                     minComplexity = complexity; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (simplest != null) { [EOL]             namedGroups.append('\\').append(groupName); [EOL]             ranges = simplest; [EOL]         } else { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return new DecomposedCharset(inverted, ranges, namedGroups.toString()); [EOL] } <line_num>: 1435,1464
@Override [EOL] protected void appendSourceCode(StringBuilder sb) { [EOL]     if (DOT_CHARSET.ranges.equals(ranges)) { [EOL]         sb.append('.'); [EOL]         return; [EOL]     } [EOL]     decompose().appendSourceCode(sb); [EOL] } <line_num>: 1466,1473
DecomposedCharset decompose() { [EOL]     CharRanges negRanges = CharRanges.ALL_CODE_UNITS.difference(ranges); [EOL]     if (!ieExplicits.isEmpty()) { [EOL]         if (negRanges.intersection(ieExplicits).isEmpty()) { [EOL]             return decompose(ranges, false); [EOL]         } else if (ranges.intersection(ieExplicits).isEmpty()) { [EOL]             return decompose(negRanges, true); [EOL]         } [EOL]     } [EOL]     DecomposedCharset positive = decompose(ranges, false); [EOL]     DecomposedCharset negative = decompose(negRanges, true); [EOL]     return positive.complexity() <= negative.complexity() ? positive : negative; [EOL] } <line_num>: 1475,1488
@Override [EOL] protected void appendDebugInfo(StringBuilder sb) { [EOL]     sb.append(ranges); [EOL] } <line_num>: 1490,1493
@Override [EOL] public boolean equals(Object o) { [EOL]     return o instanceof Charset && ranges.equals(((Charset) o).ranges); [EOL] } <line_num>: 1495,1498
@Override [EOL] public int hashCode() { [EOL]     return ranges.hashCode() ^ 0xdede2246; [EOL] } <line_num>: 1500,1503
int complexity() { [EOL]     return (inverted ? 1 : 0) + namedGroups.length() + complexity(ranges); [EOL] } <line_num>: 1518,1520
void appendSourceCode(StringBuilder sb) { [EOL]     if (ranges.isEmpty()) { [EOL]         if (!inverted && namedGroups.length() == 2) { [EOL]             sb.append(namedGroups); [EOL]             return; [EOL]         } else if (ranges.isEmpty() && namedGroups.length() == 0) { [EOL]             sb.append(inverted ? "[\\S\\s]" : "(?!)"); [EOL]             return; [EOL]         } [EOL]     } [EOL]     sb.append('['); [EOL]     if (inverted) { [EOL]         sb.append('^'); [EOL]     } [EOL]     sb.append(namedGroups); [EOL]     boolean rangesStartCharset = !inverted && namedGroups.length() == 0; [EOL]     boolean emitDashAtEnd = false; [EOL]     for (int i = 0, n = ranges.getNumRanges(); i < n; ++i) { [EOL]         char start = (char) ranges.start(i); [EOL]         char end = (char) (ranges.end(i) - 1); [EOL]         switch(end - start) { [EOL]             case 0: [EOL]                 if (start == '-') { [EOL]                     emitDashAtEnd = true; [EOL]                 } else { [EOL]                     escapeRangeCharOnto(start, rangesStartCharset, i == 0, i + 1 == n, sb); [EOL]                 } [EOL]                 break; [EOL]             case 1: [EOL]                 escapeRangeCharOnto(start, rangesStartCharset, i == 0, false, sb); [EOL]                 escapeRangeCharOnto(end, rangesStartCharset, false, i + 1 == n, sb); [EOL]                 break; [EOL]             default: [EOL]                 escapeRangeCharOnto(start, rangesStartCharset, i == 0, false, sb); [EOL]                 sb.append('-'); [EOL]                 escapeRangeCharOnto(end, rangesStartCharset, false, true, sb); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     if (emitDashAtEnd) { [EOL]         sb.append('-'); [EOL]     } [EOL]     sb.append(']'); [EOL] } <line_num>: 1522,1564
static void escapeRangeCharOnto(char ch, boolean startIsFlush, boolean atStart, boolean atEnd, StringBuilder sb) { [EOL]     switch(ch) { [EOL]         case '\b': [EOL]             sb.append("\\b"); [EOL]             break; [EOL]         case '^': [EOL]             sb.append(atStart && startIsFlush ? "\\^" : "^"); [EOL]             break; [EOL]         case '-': [EOL]             sb.append(atStart || atEnd ? "-" : "\\-"); [EOL]             break; [EOL]         case '\\': [EOL]         case ']': [EOL]             sb.append('\\').append(ch); [EOL]             break; [EOL]         default: [EOL]             escapeCharOnto(ch, sb); [EOL]     } [EOL] } <line_num>: 1566,1586
static int complexity(CharRanges ranges) { [EOL]     int complexity = 0; [EOL]     for (int i = 0, n = ranges.getNumRanges(); i < n; ++i) { [EOL]         int start = ranges.start(i); [EOL]         int end = ranges.end(i) - 1; [EOL]         if (start < 0x20 || start >= 0x7f) { [EOL]             complexity += start >= 0x100 ? 6 : 4; [EOL]         } else { [EOL]             ++complexity; [EOL]         } [EOL]         switch(end - start) { [EOL]             case 0: [EOL]                 continue; [EOL]             case 1: [EOL]                 break; [EOL]             default: [EOL]                 complexity += 1; [EOL]         } [EOL]         if (end < 0x20 || end >= 0x7f) { [EOL]             complexity += end >= 0x100 ? 6 : 4; [EOL]         } else { [EOL]             ++complexity; [EOL]         } [EOL]     } [EOL]     return complexity; [EOL] } <line_num>: 1588,1610
@Override [EOL] public boolean equals(Object o) { [EOL]     if (!(o instanceof DecomposedCharset)) { [EOL]         return false; [EOL]     } [EOL]     DecomposedCharset that = (DecomposedCharset) o; [EOL]     return this.inverted = that.inverted && this.ranges.equals(that.ranges) && this.namedGroups.equals(that.namedGroups); [EOL] } <line_num>: 1612,1621
@Override [EOL] public int hashCode() { [EOL]     return ranges.hashCode() + 31 * (namedGroups.hashCode() + (inverted ? 1 : 0)); [EOL] } <line_num>: 1623,1627
void simplify(RegExpTree t) { [EOL]     if (t instanceof Concatenation) { [EOL]         for (RegExpTree child : ((Concatenation) t).elements) { [EOL]             simplify(child); [EOL]         } [EOL]     } else if (t instanceof Empty) { [EOL]     } else { [EOL]         int lastIndex = simplified.size() - 1; [EOL]         if (lastIndex >= 0) { [EOL]             RegExpTree pairwise = simplifyPairwise(simplified.get(lastIndex), t); [EOL]             if (pairwise != null) { [EOL]                 simplified.set(lastIndex, pairwise); [EOL]                 return; [EOL]             } [EOL]         } [EOL]         simplified.add(t); [EOL]     } [EOL] } <line_num>: 1646,1665
RegExpTree simplifyPairwise(RegExpTree before, RegExpTree after) { [EOL]     if (before instanceof Text && after instanceof Text) { [EOL]         return new Text(((Text) before).text + ((Text) after).text).simplify(flags); [EOL]     } [EOL]     int beforeMin = 1, beforeMax = 1; [EOL]     RegExpTree beforeBody = before; [EOL]     boolean beforeGreedy = false; [EOL]     if (before instanceof Repetition) { [EOL]         Repetition r = (Repetition) before; [EOL]         beforeMin = r.min; [EOL]         beforeMax = r.max; [EOL]         beforeBody = r.body; [EOL]         beforeGreedy = r.greedy; [EOL]     } [EOL]     int afterMin = 1, afterMax = 1; [EOL]     RegExpTree afterBody = after; [EOL]     boolean afterGreedy = false; [EOL]     if (after instanceof Repetition) { [EOL]         Repetition r = (Repetition) after; [EOL]         afterMin = r.min; [EOL]         afterMax = r.max; [EOL]         afterBody = r.body; [EOL]         afterGreedy = r.greedy; [EOL]     } [EOL]     if (beforeBody.equals(afterBody) && !beforeBody.hasCapturingGroup()) { [EOL]         long lmin = ((long) beforeMin) + afterMin; [EOL]         long lmax = ((long) beforeMax) + afterMax; [EOL]         if (lmin < Integer.MAX_VALUE) { [EOL]             int min = (int) lmin; [EOL]             int max = lmax >= Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) lmax; [EOL]             return new Repetition(beforeBody, min, max, beforeGreedy || afterGreedy || min == max); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 1667,1707
@Override [EOL] public RegExpTree simplify(final String flags) { [EOL]     class Simplifier { [EOL]  [EOL]         final List<RegExpTree> simplified = Lists.newArrayList(); [EOL]  [EOL]         void simplify(RegExpTree t) { [EOL]             if (t instanceof Concatenation) { [EOL]                 for (RegExpTree child : ((Concatenation) t).elements) { [EOL]                     simplify(child); [EOL]                 } [EOL]             } else if (t instanceof Empty) { [EOL]             } else { [EOL]                 int lastIndex = simplified.size() - 1; [EOL]                 if (lastIndex >= 0) { [EOL]                     RegExpTree pairwise = simplifyPairwise(simplified.get(lastIndex), t); [EOL]                     if (pairwise != null) { [EOL]                         simplified.set(lastIndex, pairwise); [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]                 simplified.add(t); [EOL]             } [EOL]         } [EOL]  [EOL]         RegExpTree simplifyPairwise(RegExpTree before, RegExpTree after) { [EOL]             if (before instanceof Text && after instanceof Text) { [EOL]                 return new Text(((Text) before).text + ((Text) after).text).simplify(flags); [EOL]             } [EOL]             int beforeMin = 1, beforeMax = 1; [EOL]             RegExpTree beforeBody = before; [EOL]             boolean beforeGreedy = false; [EOL]             if (before instanceof Repetition) { [EOL]                 Repetition r = (Repetition) before; [EOL]                 beforeMin = r.min; [EOL]                 beforeMax = r.max; [EOL]                 beforeBody = r.body; [EOL]                 beforeGreedy = r.greedy; [EOL]             } [EOL]             int afterMin = 1, afterMax = 1; [EOL]             RegExpTree afterBody = after; [EOL]             boolean afterGreedy = false; [EOL]             if (after instanceof Repetition) { [EOL]                 Repetition r = (Repetition) after; [EOL]                 afterMin = r.min; [EOL]                 afterMax = r.max; [EOL]                 afterBody = r.body; [EOL]                 afterGreedy = r.greedy; [EOL]             } [EOL]             if (beforeBody.equals(afterBody) && !beforeBody.hasCapturingGroup()) { [EOL]                 long lmin = ((long) beforeMin) + afterMin; [EOL]                 long lmax = ((long) beforeMax) + afterMax; [EOL]                 if (lmin < Integer.MAX_VALUE) { [EOL]                     int min = (int) lmin; [EOL]                     int max = lmax >= Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) lmax; [EOL]                     return new Repetition(beforeBody, min, max, beforeGreedy || afterGreedy || min == max); [EOL]                 } [EOL]             } [EOL]             return null; [EOL]         } [EOL]     } [EOL]     Simplifier s = new Simplifier(); [EOL]     for (RegExpTree element : elements) { [EOL]         s.simplify(element.simplify(flags)); [EOL]     } [EOL]     switch(s.simplified.size()) { [EOL]         case 0: [EOL]             return Empty.INSTANCE; [EOL]         case 1: [EOL]             return s.simplified.get(0); [EOL]         default: [EOL]             return new Concatenation(s.simplified); [EOL]     } [EOL] } <line_num>: 1641,1720
@Override [EOL] public boolean isCaseSensitive() { [EOL]     for (RegExpTree element : elements) { [EOL]         if (element.isCaseSensitive()) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1722,1730
@Override [EOL] public boolean containsAnchor() { [EOL]     for (RegExpTree element : elements) { [EOL]         if (element.containsAnchor()) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1732,1740
@Override [EOL] public int numCapturingGroups() { [EOL]     int n = 0; [EOL]     for (RegExpTree element : elements) { [EOL]         n += element.numCapturingGroups(); [EOL]     } [EOL]     return n; [EOL] } <line_num>: 1742,1749
@Override [EOL] public List<? extends RegExpTree> children() { [EOL]     return elements; [EOL] } <line_num>: 1751,1754
@Override [EOL] protected void appendSourceCode(StringBuilder sb) { [EOL]     boolean digitsMightBleed = false; [EOL]     for (RegExpTree element : elements) { [EOL]         boolean parenthesize = false; [EOL]         if (element instanceof Alternation || element instanceof Concatenation) { [EOL]             parenthesize = true; [EOL]         } [EOL]         if (parenthesize) { [EOL]             sb.append("(?:"); [EOL]             element.appendSourceCode(sb); [EOL]             sb.append(')'); [EOL]         } else { [EOL]             int start = sb.length(); [EOL]             element.appendSourceCode(sb); [EOL]             if (digitsMightBleed && sb.length() > start) { [EOL]                 char firstChar = sb.charAt(start); [EOL]                 if ('0' <= firstChar && firstChar <= '9') { [EOL]                     if (sb.charAt(start - 1) == '{') { [EOL]                         sb.insert(start - 1, '\\'); [EOL]                     } else { [EOL]                         sb.insert(start, "(?:").append(')'); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         digitsMightBleed = ((element instanceof BackReference && ((BackReference) element).groupIndex < 10) || (element instanceof Text && ((Text) element).text.endsWith("{"))); [EOL]     } [EOL] } <line_num>: 1756,1802
@Override [EOL] protected void appendDebugInfo(StringBuilder sb) { [EOL] } <line_num>: 1804,1807
@Override [EOL] public boolean equals(Object o) { [EOL]     return o instanceof Concatenation && elements.equals(((Concatenation) o).elements); [EOL] } <line_num>: 1809,1813
@Override [EOL] public int hashCode() { [EOL]     return 0x20997e3e ^ elements.hashCode(); [EOL] } <line_num>: 1815,1818
static void escapeCharOnto(char ch, StringBuilder sb) { [EOL]     switch(ch) { [EOL]         case '\u0000': [EOL]             sb.append("\\0"); [EOL]             break; [EOL]         case '\f': [EOL]             sb.append("\\f"); [EOL]             break; [EOL]         case '\t': [EOL]             sb.append("\\t"); [EOL]             break; [EOL]         case '\n': [EOL]             sb.append("\\n"); [EOL]             break; [EOL]         case '\r': [EOL]             sb.append("\\r"); [EOL]             break; [EOL]         case '\\': [EOL]             sb.append("\\\\"); [EOL]             break; [EOL]         default: [EOL]             if (ch < 0x20 || ch >= 0x7f) { [EOL]                 if (ch >= 0x100) { [EOL]                     sb.append("\\u"); [EOL]                     sb.append("0123456789abcdef".charAt((ch >> 12) & 0xf)); [EOL]                     sb.append("0123456789abcdef".charAt((ch >> 8) & 0xf)); [EOL]                     sb.append("0123456789abcdef".charAt((ch >> 4) & 0xf)); [EOL]                     sb.append("0123456789abcdef".charAt((ch) & 0xf)); [EOL]                 } else { [EOL]                     sb.append("\\x"); [EOL]                     sb.append("0123456789abcdef".charAt((ch >> 4) & 0xf)); [EOL]                     sb.append("0123456789abcdef".charAt((ch) & 0xf)); [EOL]                 } [EOL]             } else { [EOL]                 sb.append(ch); [EOL]             } [EOL]     } [EOL] } <line_num>: 1821,1858
