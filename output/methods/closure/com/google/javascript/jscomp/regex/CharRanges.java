private CharRanges(int[] ranges) { [EOL]     this.ranges = ranges; [EOL] } <line_num>: 72,74
public static CharRanges inclusive(int start, int end) { [EOL]     if (start > end) { [EOL]         throw new IndexOutOfBoundsException(start + " > " + end); [EOL]     } [EOL]     return new CharRanges(new int[] { start, end + 1 }); [EOL] } <line_num>: 42,47
public static CharRanges withMembers(int... members) { [EOL]     return new CharRanges(intArrayToRanges(members.clone())); [EOL] } <line_num>: 52,54
public static CharRanges withRanges(int... ranges) { [EOL]     ranges = ranges.clone(); [EOL]     if ((ranges.length & 1) != 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     for (int i = 1; i < ranges.length; ++i) { [EOL]         if (ranges[i] <= ranges[i - 1]) { [EOL]             throw new IllegalArgumentException(ranges[i] + " > " + ranges[i - 1]); [EOL]         } [EOL]     } [EOL]     return new CharRanges(ranges); [EOL] } <line_num>: 61,70
private static int[] intArrayToRanges(int[] members) { [EOL]     int nMembers = members.length; [EOL]     if (nMembers == 0) { [EOL]         return new int[0]; [EOL]     } [EOL]     Arrays.sort(members); [EOL]     int nRuns = 1; [EOL]     for (int i = 1; i < nMembers; ++i) { [EOL]         int current = members[i], last = members[i - 1]; [EOL]         if (current == last) { [EOL]             continue; [EOL]         } [EOL]         if (current != last + 1) { [EOL]             ++nRuns; [EOL]         } [EOL]     } [EOL]     int[] ranges = new int[nRuns * 2]; [EOL]     ranges[0] = members[0]; [EOL]     int k = 0; [EOL]     for (int i = 1; k + 2 < ranges.length; ++i) { [EOL]         int current = members[i], last = members[i - 1]; [EOL]         if (current == last) { [EOL]             continue; [EOL]         } [EOL]         if (current != last + 1) { [EOL]             ranges[++k] = last + 1; [EOL]             ranges[++k] = current; [EOL]         } [EOL]     } [EOL]     ranges[++k] = members[nMembers - 1] + 1; [EOL]     return ranges; [EOL] } <line_num>: 76,105
public boolean contains(int bit) { [EOL]     return (Arrays.binarySearch(ranges, bit) & 1) == 0; [EOL] } <line_num>: 107,139
public int minSetBit() { [EOL]     return ranges.length >= 0 ? ranges[0] : Integer.MIN_VALUE; [EOL] } <line_num>: 141,143
public boolean isEmpty() { [EOL]     return ranges.length == 0; [EOL] } <line_num>: 145,147
public int getNumRanges() { [EOL]     return ranges.length >> 1; [EOL] } <line_num>: 149,149
public int start(int i) { [EOL]     return ranges[i << 1]; [EOL] } <line_num>: 151,151
public int end(int i) { [EOL]     return ranges[(i << 1) | 1]; [EOL] } <line_num>: 153,153
public CharRanges union(CharRanges other) { [EOL]     int[] q = this.ranges, r = other.ranges; [EOL]     int m = q.length, n = r.length; [EOL]     if (m == 0) { [EOL]         return other; [EOL]     } [EOL]     if (n == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] out = new int[m + n]; [EOL]     int i = 0, j = 0, k = 0; [EOL]     while (i < m && j < n) { [EOL]         int a0 = q[i], a1 = q[i + 1], b0 = r[j], b1 = r[j + 1]; [EOL]         if (a1 < b0) { [EOL]             out[k++] = a0; [EOL]             out[k++] = a1; [EOL]             i += 2; [EOL]         } else if (b1 < a0) { [EOL]             out[k++] = b0; [EOL]             out[k++] = b1; [EOL]             j += 2; [EOL]         } else { [EOL]             int start = Math.min(a0, b0); [EOL]             int end = Math.max(a1, b1); [EOL]             i += 2; [EOL]             j += 2; [EOL]             while (i < m || j < n) { [EOL]                 if (i < m && q[i] <= end) { [EOL]                     end = Math.max(end, q[i + 1]); [EOL]                     i += 2; [EOL]                 } else if (j < n && r[j] <= end) { [EOL]                     end = Math.max(end, r[j + 1]); [EOL]                     j += 2; [EOL]                 } else { [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             out[k++] = start; [EOL]             out[k++] = end; [EOL]         } [EOL]     } [EOL]     if (i < m) { [EOL]         System.arraycopy(q, i, out, k, m - i); [EOL]         k += m - i; [EOL]     } else if (j < n) { [EOL]         System.arraycopy(r, j, out, k, n - j); [EOL]         k += n - j; [EOL]     } [EOL]     if (k != out.length) { [EOL]         int[] clipped = new int[k]; [EOL]         System.arraycopy(out, 0, clipped, 0, k); [EOL]         out = clipped; [EOL]     } [EOL]     return new CharRanges(out); [EOL] } <line_num>: 155,238
public CharRanges intersection(CharRanges other) { [EOL]     int[] aRanges = ranges, bRanges = other.ranges; [EOL]     int aLen = aRanges.length, bLen = bRanges.length; [EOL]     if (aLen == 0) { [EOL]         return this; [EOL]     } [EOL]     if (bLen == 0) { [EOL]         return other; [EOL]     } [EOL]     int aIdx = 0, bIdx = 0; [EOL]     int[] intersection = new int[Math.min(aLen, bLen)]; [EOL]     int intersectionIdx = 0; [EOL]     int pos = Math.min(aRanges[0], bRanges[0]); [EOL]     while (aIdx < aLen && bIdx < bLen) { [EOL]         if (aRanges[aIdx + 1] <= pos) { [EOL]             aIdx += 2; [EOL]         } else if (bRanges[bIdx + 1] <= pos) { [EOL]             bIdx += 2; [EOL]         } else { [EOL]             int start = Math.max(aRanges[aIdx], bRanges[bIdx]); [EOL]             if (pos < start) { [EOL]                 pos = start; [EOL]             } else { [EOL]                 int end = Math.min(aRanges[aIdx + 1], bRanges[bIdx + 1]); [EOL]                 if (intersectionIdx != 0 && pos == intersection[intersectionIdx - 1]) { [EOL]                     intersection[intersectionIdx - 1] = end; [EOL]                 } else { [EOL]                     if (intersectionIdx == intersection.length) { [EOL]                         int[] newArr = new int[intersectionIdx * 2]; [EOL]                         System.arraycopy(intersection, 0, newArr, 0, intersectionIdx); [EOL]                         intersection = newArr; [EOL]                     } [EOL]                     intersection[intersectionIdx++] = pos; [EOL]                     intersection[intersectionIdx++] = end; [EOL]                 } [EOL]                 pos = end; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (intersectionIdx != intersection.length) { [EOL]         int[] newArr = new int[intersectionIdx]; [EOL]         System.arraycopy(intersection, 0, newArr, 0, intersectionIdx); [EOL]         intersection = newArr; [EOL]     } [EOL]     return new CharRanges(intersection); [EOL] } <line_num>: 240,284
public CharRanges difference(CharRanges subtrahendRanges) { [EOL]     int[] minuend = this.ranges; [EOL]     int[] subtrahend = subtrahendRanges.ranges; [EOL]     int mn = minuend.length, sn = subtrahend.length; [EOL]     if (mn == 0 || sn == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] difference = new int[minuend.length]; [EOL]     int mIdx = 0, sIdx = 0, dIdx = 0; [EOL]     int pos = minuend[0]; [EOL]     while (mIdx < mn) { [EOL]         if (pos >= minuend[mIdx + 1]) { [EOL]             mIdx += 2; [EOL]         } else if (pos < minuend[mIdx]) { [EOL]             pos = minuend[mIdx]; [EOL]         } else if (sIdx < sn && pos >= subtrahend[sIdx]) { [EOL]             pos = subtrahend[sIdx + 1]; [EOL]             sIdx += 2; [EOL]         } else { [EOL]             int end = sIdx < sn ? Math.min(minuend[mIdx + 1], subtrahend[sIdx]) : minuend[mIdx + 1]; [EOL]             if (dIdx != 0 && difference[dIdx - 1] == pos) { [EOL]                 difference[dIdx - 1] = pos; [EOL]             } else { [EOL]                 if (dIdx == difference.length) { [EOL]                     int[] newArr = new int[dIdx * 2]; [EOL]                     System.arraycopy(difference, 0, newArr, 0, dIdx); [EOL]                     difference = newArr; [EOL]                 } [EOL]                 difference[dIdx++] = pos; [EOL]                 difference[dIdx++] = end; [EOL]             } [EOL]             pos = end; [EOL]         } [EOL]     } [EOL]     if (dIdx != difference.length) { [EOL]         int[] newArr = new int[dIdx]; [EOL]         System.arraycopy(difference, 0, newArr, 0, dIdx); [EOL]         difference = newArr; [EOL]     } [EOL]     return new CharRanges(difference); [EOL] } <line_num>: 286,337
public boolean containsAll(CharRanges sub) { [EOL]     int[] superRanges = this.ranges; [EOL]     int[] subRanges = sub.ranges; [EOL]     int superIdx = 0, subIdx = 0; [EOL]     int superLen = superRanges.length, subLen = subRanges.length; [EOL]     while (subIdx < subLen) { [EOL]         if (superIdx == superLen) { [EOL]             return false; [EOL]         } [EOL]         if (superRanges[superIdx + 1] <= subRanges[subIdx]) { [EOL]             superIdx += 2; [EOL]         } else if (superRanges[superIdx] > subRanges[subIdx]) { [EOL]             return false; [EOL]         } else if (superRanges[superIdx + 1] >= subRanges[subIdx + 1]) { [EOL]             subIdx += 2; [EOL]         } else { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return subIdx == subLen; [EOL] } <line_num>: 339,366
public CharRanges shift(int delta) { [EOL]     int n = ranges.length; [EOL]     if (delta == 0 || n == 0) { [EOL]         return this; [EOL]     } [EOL]     if (delta < 0) { [EOL]         long lmin = ranges[0] + delta; [EOL]         if (lmin < Integer.MIN_VALUE) { [EOL]             throw new IndexOutOfBoundsException(); [EOL]         } [EOL]     } else { [EOL]         long lmax = ranges[n - 1] + delta; [EOL]         if (lmax > Integer.MAX_VALUE) { [EOL]             throw new IndexOutOfBoundsException(); [EOL]         } [EOL]     } [EOL]     int[] shiftedRanges = new int[n]; [EOL]     for (int i = n; --i >= 0; ) { [EOL]         shiftedRanges[i] = ranges[i] + delta; [EOL]     } [EOL]     return new CharRanges(shiftedRanges); [EOL] } <line_num>: 379,396
@Override [EOL] public String toString() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append('['); [EOL]     for (int i = 0; i < ranges.length; ++i) { [EOL]         if ((i & 1) != 0 && ranges[i] == ranges[i - 1] + 1) { [EOL]             continue; [EOL]         } [EOL]         if (i != 0) { [EOL]             sb.append((i & 1) == 0 ? ' ' : '-'); [EOL]         } [EOL]         sb.append("0x").append(Integer.toString(ranges[i] - (i & 1), 16)); [EOL]     } [EOL]     sb.append(']'); [EOL]     return sb.toString(); [EOL] } <line_num>: 398,409
@Override [EOL] public boolean equals(Object o) { [EOL]     if (!(o instanceof CharRanges)) { [EOL]         return false; [EOL]     } [EOL]     return Arrays.equals(this.ranges, ((CharRanges) o).ranges); [EOL] } <line_num>: 411,415
@Override [EOL] public int hashCode() { [EOL]     int hc = 0; [EOL]     for (int i = 0, n = Math.min(16, ranges.length); i < n; ++i) { [EOL]         hc = (hc << 2) + ranges[i]; [EOL]     } [EOL]     return hc; [EOL] } <line_num>: 417,424
