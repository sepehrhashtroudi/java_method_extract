PrepareAst(AbstractCompiler compiler) { [EOL]     this(compiler, false); [EOL] } <line_num>: 39,41
PrepareAst(AbstractCompiler compiler, boolean checkOnly) { [EOL]     this.compiler = compiler; [EOL]     this.checkOnly = checkOnly; [EOL] } <line_num>: 43,46
PrepareAnnotations() { [EOL] } <line_num>: 121,122
private void reportChange() { [EOL]     if (checkOnly) { [EOL]         Preconditions.checkState(false, "normalizeNodeType constraints violated"); [EOL]     } [EOL] } <line_num>: 48,52
@Override [EOL] public void process(Node externs, Node root) { [EOL]     if (checkOnly) { [EOL]         normalizeNodeTypes(root); [EOL]     } else { [EOL]         if (externs != null) { [EOL]             NodeTraversal.traverse(compiler, externs, new PrepareAnnotations()); [EOL]         } [EOL]         if (root != null) { [EOL]             NodeTraversal.traverse(compiler, root, new PrepareAnnotations()); [EOL]         } [EOL]     } [EOL] } <line_num>: 54,72
private void normalizeNodeTypes(Node n) { [EOL]     normalizeBlocks(n); [EOL]     for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { [EOL]         Preconditions.checkState(child.getParent() == n); [EOL]         normalizeNodeTypes(child); [EOL]     } [EOL] } <line_num>: 77,88
private void normalizeBlocks(Node n) { [EOL]     if (NodeUtil.isControlStructure(n) && !n.isLabel() && !n.isSwitch()) { [EOL]         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { [EOL]             if (NodeUtil.isControlStructureCodeBlock(n, c) && !c.isBlock()) { [EOL]                 Node newBlock = IR.block().srcref(n); [EOL]                 n.replaceChild(c, newBlock); [EOL]                 if (!c.isEmpty()) { [EOL]                     newBlock.addChildrenToFront(c); [EOL]                 } else { [EOL]                     newBlock.setWasEmptyNode(true); [EOL]                 } [EOL]                 c = newBlock; [EOL]                 reportChange(); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 93,112
@Override [EOL] public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { [EOL]     if (n.isObjectLit()) { [EOL]         normalizeObjectLiteralAnnotations(n); [EOL]     } [EOL]     return true; [EOL] } <line_num>: 124,130
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     switch(n.getType()) { [EOL]         case Token.CALL: [EOL]             annotateCalls(n); [EOL]             break; [EOL]         case Token.FUNCTION: [EOL]             annotateDispatchers(n, parent); [EOL]             break; [EOL]     } [EOL] } <line_num>: 132,143
private void normalizeObjectLiteralAnnotations(Node objlit) { [EOL]     Preconditions.checkState(objlit.isObjectLit()); [EOL]     for (Node key = objlit.getFirstChild(); key != null; key = key.getNext()) { [EOL]         Node value = key.getFirstChild(); [EOL]         normalizeObjectLiteralKeyAnnotations(objlit, key, value); [EOL]     } [EOL] } <line_num>: 145,152
private void annotateCalls(Node n) { [EOL]     Preconditions.checkState(n.isCall()); [EOL]     Node first = n.getFirstChild(); [EOL]     if (!NodeUtil.isGet(first)) { [EOL]         n.putBooleanProp(Node.FREE_CALL, true); [EOL]     } [EOL]     if (first.isName() && "eval".equals(first.getString())) { [EOL]         first.putBooleanProp(Node.DIRECT_EVAL, true); [EOL]     } [EOL] } <line_num>: 158,174
private void annotateDispatchers(Node n, Node parent) { [EOL]     Preconditions.checkState(n.isFunction()); [EOL]     if (parent.getJSDocInfo() != null && parent.getJSDocInfo().isJavaDispatch()) { [EOL]         if (parent.isAssign()) { [EOL]             Preconditions.checkState(parent.getLastChild() == n); [EOL]             n.putBooleanProp(Node.IS_DISPATCHER, true); [EOL]         } [EOL]     } [EOL] } <line_num>: 179,188
private void normalizeObjectLiteralKeyAnnotations(Node objlit, Node key, Node value) { [EOL]     Preconditions.checkState(objlit.isObjectLit()); [EOL]     if (key.getJSDocInfo() != null && value.isFunction()) { [EOL]         value.setJSDocInfo(key.getJSDocInfo()); [EOL]     } [EOL] } <line_num>: 205,212
