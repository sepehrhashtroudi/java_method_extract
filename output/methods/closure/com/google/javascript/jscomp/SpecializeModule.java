public SpecializeModule(AbstractCompiler compiler, PassFactory... specializationPassFactories) { [EOL]     this.compiler = compiler; [EOL]     this.specializationPassFactories = specializationPassFactories; [EOL] } <line_num>: 97,101
public OriginalFunctionInformation(Node originalFunction) { [EOL]     name = NodeUtil.getFunctionName(originalFunction); [EOL]     originalFunctionCopy = originalFunction.cloneTree(); [EOL]     originalFunctionCopy.copyInformationFromForTree(originalFunction); [EOL]     Node originalParent = originalFunction.getParent(); [EOL]     isAssignFunction = originalParent.isAssign() || originalParent.isName(); [EOL]     assignHasVar = isAssignFunction && originalParent.getParent().isVar(); [EOL] } <line_num>: 455,468
public SpecializationState(SimpleFunctionAliasAnalysis initialModuleAliasAnalysis) { [EOL]     this.initialModuleAliasAnalysis = initialModuleAliasAnalysis; [EOL]     specializedFunctions = Sets.newLinkedHashSet(); [EOL]     removedFunctions = Sets.newLinkedHashSet(); [EOL]     removedFunctionToBlock = Maps.newLinkedHashMap(); [EOL] } <line_num>: 588,596
@Override [EOL] public void process(Node externs, Node root) { [EOL]     JSModuleGraph moduleGraph = compiler.getModuleGraph(); [EOL]     if (moduleGraph == null) { [EOL]         return; [EOL]     } [EOL]     JSModule module = moduleGraph.getRootModule(); [EOL]     Node fakeModuleRoot = copyModuleInputs(module); [EOL]     SimpleDefinitionFinder defFinder = new SimpleDefinitionFinder(compiler); [EOL]     defFinder.process(externs, fakeModuleRoot); [EOL]     SimpleFunctionAliasAnalysis initialModuleFunctionAliasAnalysis = new SimpleFunctionAliasAnalysis(); [EOL]     initialModuleFunctionAliasAnalysis.analyze(defFinder); [EOL]     specializationState = new SpecializationState(initialModuleFunctionAliasAnalysis); [EOL]     do { [EOL]         specializationState.resetHasChanged(); [EOL]         for (SpecializationAwareCompilerPass pass : createSpecializingPasses()) { [EOL]             pass.enableSpecialization(specializationState); [EOL]             pass.process(externs, fakeModuleRoot); [EOL]         } [EOL]     } while (specializationState.hasChanged()); [EOL]     addDummyVarDeclarationsToInitialModule(module); [EOL]     replaceOriginalModuleInputsWithSpecialized(); [EOL]     addOriginalFunctionVersionsToDependentModules(module); [EOL] } <line_num>: 127,165
private Collection<SpecializationAwareCompilerPass> createSpecializingPasses() { [EOL]     Collection<SpecializationAwareCompilerPass> passes = Lists.newLinkedList(); [EOL]     for (PassFactory passFactory : specializationPassFactories) { [EOL]         CompilerPass pass = passFactory.create(compiler); [EOL]         Preconditions.checkState(pass instanceof SpecializationAwareCompilerPass); [EOL]         passes.add((SpecializationAwareCompilerPass) pass); [EOL]     } [EOL]     return passes; [EOL] } <line_num>: 170,185
private Node copyModuleInputs(JSModule module) { [EOL]     specializedInputRootsByOriginal = Maps.newLinkedHashMap(); [EOL]     functionInfoBySpecializedFunctionNode = Maps.newLinkedHashMap(); [EOL]     Node syntheticModuleJsRoot = IR.block(); [EOL]     syntheticModuleJsRoot.setIsSyntheticBlock(true); [EOL]     for (CompilerInput input : module.getInputs()) { [EOL]         Node originalInputRoot = input.getAstRoot(compiler); [EOL]         Node copiedInputRoot = originalInputRoot.cloneTree(); [EOL]         copiedInputRoot.copyInformationFromForTree(originalInputRoot); [EOL]         specializedInputRootsByOriginal.put(originalInputRoot, copiedInputRoot); [EOL]         matchTopLevelFunctions(originalInputRoot, copiedInputRoot); [EOL]         syntheticModuleJsRoot.addChildToBack(copiedInputRoot); [EOL]     } [EOL]     Node syntheticExternsAndJsRoot = IR.block(); [EOL]     syntheticExternsAndJsRoot.addChildToBack(syntheticModuleJsRoot); [EOL]     return syntheticModuleJsRoot; [EOL] } <line_num>: 195,224
@Override [EOL] public void reportMatch(Node original, Node specialized) { [EOL]     if (original.isFunction()) { [EOL]         OriginalFunctionInformation functionInfo = new OriginalFunctionInformation(original); [EOL]         functionInfoBySpecializedFunctionNode.put(specialized, functionInfo); [EOL]     } [EOL] } <line_num>: 239,248
@Override [EOL] public boolean shouldTraverse(Node n1, Node n2) { [EOL]     return !n1.isFunction(); [EOL] } <line_num>: 250,253
private void matchTopLevelFunctions(Node original, Node toBeSpecialized) { [EOL]     new NodeMatcher() { [EOL]  [EOL]         @Override [EOL]         public void reportMatch(Node original, Node specialized) { [EOL]             if (original.isFunction()) { [EOL]                 OriginalFunctionInformation functionInfo = new OriginalFunctionInformation(original); [EOL]                 functionInfoBySpecializedFunctionNode.put(specialized, functionInfo); [EOL]             } [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean shouldTraverse(Node n1, Node n2) { [EOL]             return !n1.isFunction(); [EOL]         } [EOL]     }.match(original, toBeSpecialized); [EOL] } <line_num>: 237,255
private void replaceOriginalModuleInputsWithSpecialized() { [EOL]     for (Node original : specializedInputRootsByOriginal.keySet()) { [EOL]         Node specialized = specializedInputRootsByOriginal.get(original); [EOL]         original.removeChildren(); [EOL]         List<Node> specializedChildren = Lists.newLinkedList(); [EOL]         while (specialized.getFirstChild() != null) { [EOL]             original.addChildToBack(specialized.removeFirstChild()); [EOL]         } [EOL]     } [EOL] } <line_num>: 265,277
private void addDummyVarDeclarationsToInitialModule(JSModule module) { [EOL]     for (Node modifiedFunction : functionInfoBySpecializedFunctionNode.keySet()) { [EOL]         if (specializationState.getRemovedFunctions().contains(modifiedFunction)) { [EOL]             OriginalFunctionInformation originalInfo = functionInfoBySpecializedFunctionNode.get(modifiedFunction); [EOL]             if (originalInfo.name != null && originalInfo.originalWasDeclaration()) { [EOL]                 Node block = specializationState.removedFunctionToBlock.get(modifiedFunction); [EOL]                 if (block != null) { [EOL]                     Node originalRoot = specializedInputRootsByOriginal.get(block); [EOL]                     block.addChildrenToBack(originalInfo.generateDummyDeclaration()); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 289,311
private void addOriginalFunctionVersionsToDependentModules(JSModule module) { [EOL]     for (JSModule directDependent : getDirectDependents(module)) { [EOL]         CompilerInput firstInput = directDependent.getInputs().get(0); [EOL]         Node firstInputRootNode = firstInput.getAstRoot(compiler); [EOL]         List<Node> possiblyModifiedFunctions = Lists.newArrayList(functionInfoBySpecializedFunctionNode.keySet()); [EOL]         Collections.reverse(possiblyModifiedFunctions); [EOL]         for (Node modifiedFunction : possiblyModifiedFunctions) { [EOL]             boolean declarationWasSpecialized = specializationState.getSpecializedFunctions().contains(modifiedFunction); [EOL]             boolean declarationWasRemoved = specializationState.getRemovedFunctions().contains(modifiedFunction); [EOL]             if (declarationWasSpecialized || declarationWasRemoved) { [EOL]                 OriginalFunctionInformation originalInfo = functionInfoBySpecializedFunctionNode.get(modifiedFunction); [EOL]                 if (originalInfo.name != null) { [EOL]                     Node newDefinition = originalInfo.generateFixupDefinition(); [EOL]                     firstInputRootNode.addChildrenToFront(newDefinition); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 322,362
public Collection<JSModule> getDirectDependents(JSModule module) { [EOL]     Set<JSModule> directDependents = Sets.newHashSet(); [EOL]     for (JSModule possibleDependent : compiler.getModuleGraph().getAllModules()) { [EOL]         if (possibleDependent.getDependencies().contains(module)) { [EOL]             directDependents.add(possibleDependent); [EOL]         } [EOL]     } [EOL]     return directDependents; [EOL] } <line_num>: 369,380
public void match(Node ast1, Node ast2) { [EOL]     reportMatch(ast1, ast2); [EOL]     if (shouldTraverse(ast1, ast2)) { [EOL]         Node childOf1 = ast1.getFirstChild(); [EOL]         Node childOf2 = ast2.getFirstChild(); [EOL]         while (childOf1 != null) { [EOL]             match(childOf1, childOf2); [EOL]             childOf1 = childOf1.getNext(); [EOL]             childOf2 = childOf2.getNext(); [EOL]         } [EOL]     } [EOL] } <line_num>: 397,413
public abstract void reportMatch(Node n1, Node n2); <line_num>: 423,423
public boolean shouldTraverse(Node node1, Node n2) { [EOL]     return true; [EOL] } <line_num>: 429,431
private Node copiedOriginalFunction() { [EOL]     Node copy = originalFunctionCopy.cloneTree(); [EOL]     copy.copyInformationFromForTree(originalFunctionCopy); [EOL]     return copy; [EOL] } <line_num>: 470,476
private boolean originalWasDeclaration() { [EOL]     return (!isAssignFunction) || (assignHasVar); [EOL] } <line_num>: 483,485
private Node generateFixupDefinition() { [EOL]     Node functionCopy = copiedOriginalFunction(); [EOL]     Node nameNode; [EOL]     if (isAssignFunction) { [EOL]         nameNode = NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), name, functionCopy, name); [EOL]     } else { [EOL]         nameNode = functionCopy.getFirstChild(); [EOL]         functionCopy.replaceChild(nameNode, NodeUtil.newName(compiler.getCodingConvention(), "", nameNode)); [EOL]     } [EOL]     Node assignment = IR.assign(nameNode, functionCopy); [EOL]     assignment.copyInformationFrom(functionCopy); [EOL]     return NodeUtil.newExpr(assignment); [EOL] } <line_num>: 506,527
private Node generateDummyDeclaration() { [EOL]     Node declaration = NodeUtil.newVarNode(name, null); [EOL]     declaration.copyInformationFromForTree(originalFunctionCopy); [EOL]     return declaration; [EOL] } <line_num>: 535,540
private boolean hasChanged() { [EOL]     return hasChanged; [EOL] } <line_num>: 602,604
private void resetHasChanged() { [EOL]     hasChanged = false; [EOL] } <line_num>: 606,608
public Set<Node> getSpecializedFunctions() { [EOL]     return specializedFunctions; [EOL] } <line_num>: 613,615
public void reportSpecializedFunction(Node functionNode) { [EOL]     if (specializedFunctions.add(functionNode)) { [EOL]         hasChanged = true; [EOL]     } [EOL] } <line_num>: 622,626
public void reportSpecializedFunctionContainingNode(Node node) { [EOL]     Node containingFunction = containingFunction(node); [EOL]     if (containingFunction != null) { [EOL]         reportSpecializedFunction(containingFunction); [EOL]     } [EOL] } <line_num>: 631,637
public Set<Node> getRemovedFunctions() { [EOL]     return removedFunctions; [EOL] } <line_num>: 642,644
public void reportRemovedFunction(Node functionNode, Node declaringBlock) { [EOL]     if (removedFunctions.add(functionNode)) { [EOL]         hasChanged = true; [EOL]         removedFunctionToBlock.put(functionNode, declaringBlock); [EOL]     } [EOL] } <line_num>: 655,663
public boolean canFixupFunction(Node functionNode) { [EOL]     Preconditions.checkArgument(functionNode.isFunction()); [EOL]     if (!nodeIsInGlobalScope(functionNode) || initialModuleAliasAnalysis.isAliased(functionNode)) { [EOL]         return false; [EOL]     } [EOL]     if (NodeUtil.isStatement(functionNode)) { [EOL]         return true; [EOL]     } [EOL]     Node parent = functionNode.getParent(); [EOL]     Node gramps = parent.getParent(); [EOL]     if (parent.isName() && gramps.isVar()) { [EOL]         return true; [EOL]     } [EOL]     if (NodeUtil.isExprAssign(gramps) && parent.getChildAtIndex(1) == functionNode) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 687,716
public boolean canFixupSpecializedFunctionContainingNode(Node n) { [EOL]     Node containingFunction = containingFunction(n); [EOL]     if (containingFunction != null) { [EOL]         return canFixupFunction(containingFunction); [EOL]     } else { [EOL]         return true; [EOL]     } [EOL] } <line_num>: 723,731
private boolean nodeIsInGlobalScope(Node node) { [EOL]     return containingFunction(node) == null; [EOL] } <line_num>: 736,738
private Node containingFunction(Node node) { [EOL]     for (Node ancestor : node.getAncestors()) { [EOL]         if (ancestor.isFunction()) { [EOL]             return ancestor; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 743,751
