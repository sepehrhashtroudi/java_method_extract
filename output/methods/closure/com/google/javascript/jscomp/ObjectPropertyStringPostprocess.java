public ObjectPropertyStringPostprocess(AbstractCompiler compiler) { [EOL]     this.compiler = compiler; [EOL] } <line_num>: 43,45
@Override [EOL] public void process(Node externs, Node root) { [EOL]     NodeTraversal.traverse(compiler, root, new Callback()); [EOL] } <line_num>: 47,50
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (!n.isNew()) { [EOL]         return; [EOL]     } [EOL]     Node objectName = n.getFirstChild(); [EOL]     if (!ObjectPropertyStringPreprocess.EXTERN_OBJECT_PROPERTY_STRING.equals(objectName.getQualifiedName())) { [EOL]         return; [EOL]     } [EOL]     Node firstArgument = objectName.getNext(); [EOL]     Node secondArgument = firstArgument.getNext(); [EOL]     int secondArgumentType = secondArgument.getType(); [EOL]     if (secondArgumentType == Token.GETPROP) { [EOL]         Node newChild = secondArgument.getFirstChild(); [EOL]         secondArgument.removeChild(newChild); [EOL]         n.replaceChild(firstArgument, newChild); [EOL]         n.replaceChild(secondArgument, IR.string(secondArgument.getFirstChild().getString())); [EOL]     } else if (secondArgumentType == Token.GETELEM) { [EOL]         Node newFirstArgument = secondArgument.getFirstChild(); [EOL]         secondArgument.removeChild(newFirstArgument); [EOL]         Node newSecondArgument = secondArgument.getLastChild(); [EOL]         secondArgument.removeChild(newSecondArgument); [EOL]         n.replaceChild(firstArgument, newFirstArgument); [EOL]         n.replaceChild(secondArgument, newSecondArgument); [EOL]     } else { [EOL]         n.replaceChild(secondArgument, IR.string(secondArgument.getString())); [EOL]     } [EOL]     compiler.reportCodeChange(); [EOL] } <line_num>: 53,93
