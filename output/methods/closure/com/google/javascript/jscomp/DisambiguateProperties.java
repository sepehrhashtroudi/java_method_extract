Property(String name) { [EOL]     this.name = name; [EOL] } <line_num>: 143,145
private DisambiguateProperties(AbstractCompiler compiler, TypeSystem<T> typeSystem, Map<String, CheckLevel> propertiesToErrorFor) { [EOL]     this.compiler = compiler; [EOL]     this.typeSystem = typeSystem; [EOL]     this.propertiesToErrorFor = propertiesToErrorFor; [EOL]     if (!this.propertiesToErrorFor.isEmpty()) { [EOL]         this.invalidationMap = LinkedHashMultimap.create(); [EOL]     } else { [EOL]         this.invalidationMap = null; [EOL]     } [EOL] } <line_num>: 297,307
public JSTypeSystem(AbstractCompiler compiler) { [EOL]     registry = compiler.getTypeRegistry(); [EOL]     invalidatingTypes = Sets.newHashSet(registry.getNativeType(JSTypeNative.ALL_TYPE), registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE), registry.getNativeType(JSTypeNative.FUNCTION_PROTOTYPE), registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE), registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE), registry.getNativeType(JSTypeNative.TOP_LEVEL_PROTOTYPE), registry.getNativeType(JSTypeNative.UNKNOWN_TYPE)); [EOL] } <line_num>: 736,748
public ConcreteTypeSystem(TightenTypes tt, CodingConvention convention) { [EOL]     this.tt = tt; [EOL]     this.codingConvention = convention; [EOL] } <line_num>: 958,961
UnionFind<T> getTypes() { [EOL]     if (types == null) { [EOL]         types = new StandardUnionFind<T>(); [EOL]     } [EOL]     return types; [EOL] } <line_num>: 148,153
boolean addType(T type, T top, T relatedType) { [EOL]     checkState(!skipRenaming, "Attempt to record skipped property: %s", name); [EOL]     if (typeSystem.isInvalidatingType(top)) { [EOL]         invalidate(); [EOL]         return false; [EOL]     } else { [EOL]         if (typeSystem.isTypeToSkip(top)) { [EOL]             addTypeToSkip(top); [EOL]         } [EOL]         if (relatedType == null) { [EOL]             getTypes().add(top); [EOL]         } else { [EOL]             getTypes().union(top, relatedType); [EOL]         } [EOL]         typeSystem.recordInterfaces(type, top, this); [EOL]         return true; [EOL]     } [EOL] } <line_num>: 160,178
void addTypeToSkip(T type) { [EOL]     for (T skipType : typeSystem.getTypesToSkipForType(type)) { [EOL]         typesToSkip.add(skipType); [EOL]         getTypes().union(skipType, type); [EOL]     } [EOL] } <line_num>: 181,186
void expandTypesToSkip() { [EOL]     if (shouldRename()) { [EOL]         int count = 0; [EOL]         while (true) { [EOL]             checkState(++count < 10, "Stuck in loop expanding types to skip."); [EOL]             Set<T> rootTypesToSkip = Sets.newHashSet(); [EOL]             for (T subType : typesToSkip) { [EOL]                 rootTypesToSkip.add(types.find(subType)); [EOL]             } [EOL]             typesToSkip.addAll(rootTypesToSkip); [EOL]             Set<T> newTypesToSkip = Sets.newHashSet(); [EOL]             Set<T> allTypes = types.elements(); [EOL]             int originalTypesSize = allTypes.size(); [EOL]             for (T subType : allTypes) { [EOL]                 if (!typesToSkip.contains(subType) && typesToSkip.contains(types.find(subType))) { [EOL]                     newTypesToSkip.add(subType); [EOL]                 } [EOL]             } [EOL]             for (T newType : newTypesToSkip) { [EOL]                 addTypeToSkip(newType); [EOL]             } [EOL]             if (types.elements().size() == originalTypesSize) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 189,226
boolean shouldRename() { [EOL]     return !skipRenaming && types != null && types.allEquivalenceClasses().size() > 1; [EOL] } <line_num>: 229,232
boolean shouldRename(T type) { [EOL]     return !skipRenaming && !typesToSkip.contains(type); [EOL] } <line_num>: 239,241
boolean invalidate() { [EOL]     boolean changed = !skipRenaming; [EOL]     skipRenaming = true; [EOL]     types = null; [EOL]     return changed; [EOL] } <line_num>: 247,252
boolean scheduleRenaming(Node node, T type) { [EOL]     if (!skipRenaming) { [EOL]         if (typeSystem.isInvalidatingType(type)) { [EOL]             invalidate(); [EOL]             return false; [EOL]         } [EOL]         renameNodes.add(node); [EOL]         rootTypes.put(node, type); [EOL]     } [EOL]     return true; [EOL] } <line_num>: 263,273
static DisambiguateProperties<JSType> forJSTypeSystem(AbstractCompiler compiler, Map<String, CheckLevel> propertiesToErrorFor) { [EOL]     return new DisambiguateProperties<JSType>(compiler, new JSTypeSystem(compiler), propertiesToErrorFor); [EOL] } <line_num>: 278,283
static DisambiguateProperties<ConcreteType> forConcreteTypeSystem(AbstractCompiler compiler, TightenTypes tt, Map<String, CheckLevel> propertiesToErrorFor) { [EOL]     return new DisambiguateProperties<ConcreteType>(compiler, new ConcreteTypeSystem(tt, compiler.getCodingConvention()), propertiesToErrorFor); [EOL] } <line_num>: 285,291
@Override [EOL] public void process(Node externs, Node root) { [EOL]     Preconditions.checkState(compiler.getLifeCycleStage() == LifeCycleStage.NORMALIZED); [EOL]     for (TypeMismatch mis : compiler.getTypeValidator().getMismatches()) { [EOL]         addInvalidatingType(mis.typeA, mis.src); [EOL]         addInvalidatingType(mis.typeB, mis.src); [EOL]     } [EOL]     StaticScope<T> scope = typeSystem.getRootScope(); [EOL]     NodeTraversal.traverse(compiler, externs, new FindExternProperties()); [EOL]     NodeTraversal.traverse(compiler, root, new FindRenameableProperties()); [EOL]     renameProperties(); [EOL] } <line_num>: 309,322
private void recordInvalidationError(JSType t, JSError error) { [EOL]     if (!t.isObject()) { [EOL]         return; [EOL]     } [EOL]     if (invalidationMap != null) { [EOL]         invalidationMap.put(t, error); [EOL]     } [EOL] } <line_num>: 324,331
private void addInvalidatingType(JSType type, JSError error) { [EOL]     type = type.restrictByNotNullOrUndefined(); [EOL]     if (type.isUnionType()) { [EOL]         for (JSType alt : type.toMaybeUnionType().getAlternates()) { [EOL]             addInvalidatingType(alt, error); [EOL]         } [EOL]     } else if (type.isEnumElementType()) { [EOL]         addInvalidatingType(type.toMaybeEnumElementType().getPrimitiveType(), error); [EOL]     } else { [EOL]         typeSystem.addInvalidatingType(type); [EOL]         recordInvalidationError(type, error); [EOL]         ObjectType objType = ObjectType.cast(type); [EOL]         if (objType != null && objType.getImplicitPrototype() != null) { [EOL]             typeSystem.addInvalidatingType(objType.getImplicitPrototype()); [EOL]             recordInvalidationError(objType.getImplicitPrototype(), error); [EOL]         } [EOL]     } [EOL] } <line_num>: 336,354
protected Property getProperty(String name) { [EOL]     if (!properties.containsKey(name)) { [EOL]         properties.put(name, new Property(name)); [EOL]     } [EOL]     return properties.get(name); [EOL] } <line_num>: 358,363
T getTypeWithProperty(String field, T type) { [EOL]     return typeSystem.getTypeWithProperty(field, type); [EOL] } <line_num>: 366,368
@Override [EOL] public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { [EOL]     return true; [EOL] } <line_num>: 375,378
@Override [EOL] public void enterScope(NodeTraversal t) { [EOL]     if (t.inGlobalScope()) { [EOL]         scopes.push(typeSystem.getRootScope()); [EOL]     } else { [EOL]         scopes.push(typeSystem.getFunctionScope(t.getScopeRoot())); [EOL]     } [EOL] } <line_num>: 380,387
@Override [EOL] public void exitScope(NodeTraversal t) { [EOL]     scopes.pop(); [EOL] } <line_num>: 389,392
protected StaticScope<T> getScope() { [EOL]     return scopes.peek(); [EOL] } <line_num>: 395,397
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (n.isGetProp()) { [EOL]         String field = n.getLastChild().getString(); [EOL]         T type = typeSystem.getType(getScope(), n.getFirstChild(), field); [EOL]         Property prop = getProperty(field); [EOL]         if (typeSystem.isInvalidatingType(type)) { [EOL]             prop.invalidate(); [EOL]         } else { [EOL]             prop.addTypeToSkip(type); [EOL]             if ((type = typeSystem.getInstanceFromPrototype(type)) != null) { [EOL]                 prop.getTypes().add(type); [EOL]                 prop.typesToSkip.add(type); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 405,425
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (n.isGetProp()) { [EOL]         handleGetProp(t, n); [EOL]     } else if (n.isObjectLit()) { [EOL]         handleObjectLit(t, n); [EOL]     } [EOL] } <line_num>: 433,440
private void handleGetProp(NodeTraversal t, Node n) { [EOL]     String name = n.getLastChild().getString(); [EOL]     T type = typeSystem.getType(getScope(), n.getFirstChild(), name); [EOL]     Property prop = getProperty(name); [EOL]     if (!prop.scheduleRenaming(n.getLastChild(), processProperty(t, prop, type, null))) { [EOL]         if (propertiesToErrorFor.containsKey(name)) { [EOL]             String suggestion = ""; [EOL]             if (type instanceof JSType) { [EOL]                 JSType jsType = (JSType) type; [EOL]                 if (jsType.isAllType() || jsType.isUnknownType()) { [EOL]                     if (n.getFirstChild().isThis()) { [EOL]                         suggestion = "The \"this\" object is unknown in the function," + "consider using @this"; [EOL]                     } else { [EOL]                         String qName = n.getFirstChild().getQualifiedName(); [EOL]                         suggestion = "Consider casting " + qName + " if you know it's type."; [EOL]                     } [EOL]                 } else { [EOL]                     List<String> errors = Lists.newArrayList(); [EOL]                     printErrorLocations(errors, jsType); [EOL]                     if (!errors.isEmpty()) { [EOL]                         suggestion = "Consider fixing errors for the following types:\n"; [EOL]                         suggestion += Joiner.on("\n").join(errors); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             compiler.report(JSError.make(t.getSourceName(), n, propertiesToErrorFor.get(name), Warnings.INVALIDATION, name, (type == null ? "null" : type.toString()), n.toString(), suggestion)); [EOL]         } [EOL]     } [EOL] } <line_num>: 445,481
private void handleObjectLit(NodeTraversal t, Node n) { [EOL]     Node child = n.getFirstChild(); [EOL]     while (child != null) { [EOL]         String name = child.getString(); [EOL]         T type = typeSystem.getType(getScope(), n, name); [EOL]         Property prop = getProperty(name); [EOL]         if (!prop.scheduleRenaming(child, processProperty(t, prop, type, null))) { [EOL]             if (propertiesToErrorFor.containsKey(name)) { [EOL]                 compiler.report(JSError.make(t.getSourceName(), child, propertiesToErrorFor.get(name), Warnings.INVALIDATION, name, (type == null ? "null" : type.toString()), n.toString(), "")); [EOL]             } [EOL]         } [EOL]         child = child.getNext(); [EOL]     } [EOL] } <line_num>: 486,509
private void printErrorLocations(List<String> errors, JSType t) { [EOL]     if (!t.isObject() || t.isAllType()) { [EOL]         return; [EOL]     } [EOL]     if (t.isUnionType()) { [EOL]         for (JSType alt : t.toMaybeUnionType().getAlternates()) { [EOL]             printErrorLocations(errors, alt); [EOL]         } [EOL]         return; [EOL]     } [EOL]     for (JSError error : invalidationMap.get(t)) { [EOL]         if (errors.size() > MAX_INVALDIATION_WARNINGS_PER_PROPERTY) { [EOL]             return; [EOL]         } [EOL]         errors.add(t.toString() + " at " + error.sourceName + ":" + error.lineNumber); [EOL]     } [EOL] } <line_num>: 511,531
private T processProperty(NodeTraversal t, Property prop, T type, T relatedType) { [EOL]     type = typeSystem.restrictByNotNullOrUndefined(type); [EOL]     if (prop.skipRenaming || typeSystem.isInvalidatingType(type)) { [EOL]         return null; [EOL]     } [EOL]     Iterable<T> alternatives = typeSystem.getTypeAlternatives(type); [EOL]     if (alternatives != null) { [EOL]         T firstType = relatedType; [EOL]         for (T subType : alternatives) { [EOL]             T lastType = processProperty(t, prop, subType, firstType); [EOL]             if (lastType != null) { [EOL]                 firstType = firstType == null ? lastType : firstType; [EOL]             } [EOL]         } [EOL]         return firstType; [EOL]     } else { [EOL]         T topType = typeSystem.getTypeWithProperty(prop.name, type); [EOL]         if (typeSystem.isInvalidatingType(topType)) { [EOL]             return null; [EOL]         } [EOL]         prop.addType(type, topType, relatedType); [EOL]         return topType; [EOL]     } [EOL] } <line_num>: 540,565
void renameProperties() { [EOL]     int propsRenamed = 0, propsSkipped = 0, instancesRenamed = 0, instancesSkipped = 0, singleTypeProps = 0; [EOL]     for (Property prop : properties.values()) { [EOL]         if (prop.shouldRename()) { [EOL]             Map<T, String> propNames = buildPropNames(prop.getTypes(), prop.name); [EOL]             ++propsRenamed; [EOL]             prop.expandTypesToSkip(); [EOL]             UnionFind<T> types = prop.getTypes(); [EOL]             for (Node node : prop.renameNodes) { [EOL]                 T rootType = prop.rootTypes.get(node); [EOL]                 if (prop.shouldRename(rootType)) { [EOL]                     String newName = propNames.get(rootType); [EOL]                     node.setString(newName); [EOL]                     compiler.reportCodeChange(); [EOL]                     ++instancesRenamed; [EOL]                 } else { [EOL]                     ++instancesSkipped; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             if (prop.skipRenaming) { [EOL]                 ++propsSkipped; [EOL]             } else { [EOL]                 ++singleTypeProps; [EOL]             } [EOL]         } [EOL]     } [EOL]     logger.fine("Renamed " + instancesRenamed + " instances of " + propsRenamed + " properties."); [EOL]     logger.fine("Skipped renaming " + instancesSkipped + " invalidated " + "properties, " + propsSkipped + " instances of properties " + "that were skipped for specific types and " + singleTypeProps + " properties that were referenced from only one type."); [EOL] } <line_num>: 569,605
private Map<T, String> buildPropNames(UnionFind<T> types, String name) { [EOL]     Map<T, String> names = Maps.newHashMap(); [EOL]     for (Set<T> set : types.allEquivalenceClasses()) { [EOL]         checkState(!set.isEmpty()); [EOL]         String typeName = null; [EOL]         for (T type : set) { [EOL]             if (typeName == null || type.toString().compareTo(typeName) < 0) { [EOL]                 typeName = type.toString(); [EOL]             } [EOL]         } [EOL]         String newName; [EOL]         if ("{...}".equals(typeName)) { [EOL]             newName = name; [EOL]         } else { [EOL]             newName = typeName.replaceAll("[^\\w$]", "_") + "$" + name; [EOL]         } [EOL]         for (T type : set) { [EOL]             names.put(type, newName); [EOL]         } [EOL]     } [EOL]     return names; [EOL] } <line_num>: 611,635
Multimap<String, Collection<T>> getRenamedTypesForTesting() { [EOL]     Multimap<String, Collection<T>> ret = HashMultimap.create(); [EOL]     for (Map.Entry<String, Property> entry : properties.entrySet()) { [EOL]         Property prop = entry.getValue(); [EOL]         if (!prop.skipRenaming) { [EOL]             for (Collection<T> c : prop.getTypes().allEquivalenceClasses()) { [EOL]                 if (!c.isEmpty() && !prop.typesToSkip.contains(c.iterator().next())) { [EOL]                     ret.put(entry.getKey(), c); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return ret; [EOL] } <line_num>: 638,651
StaticScope<T> getRootScope(); <line_num>: 659,659
StaticScope<T> getFunctionScope(Node node); <line_num>: 662,662
T getType(StaticScope<T> scope, Node node, String prop); <line_num>: 672,672
boolean isInvalidatingType(T type); <line_num>: 680,680
void addInvalidatingType(JSType type); <line_num>: 686,686
ImmutableSet<T> getTypesToSkipForType(T type); <line_num>: 693,693
boolean isTypeToSkip(T type); <line_num>: 699,699
T restrictByNotNullOrUndefined(T type); <line_num>: 702,702
Iterable<T> getTypeAlternatives(T type); <line_num>: 709,709
T getTypeWithProperty(String field, T type); <line_num>: 715,715
T getInstanceFromPrototype(T type); <line_num>: 721,721
void recordInterfaces(T type, T relatedType, DisambiguateProperties<T>.Property p); <line_num>: 727,728
@Override [EOL] public void addInvalidatingType(JSType type) { [EOL]     checkState(!type.isUnionType()); [EOL]     invalidatingTypes.add(type); [EOL] } <line_num>: 750,753
@Override [EOL] public StaticScope<JSType> getRootScope() { [EOL]     return null; [EOL] } <line_num>: 755,755
@Override [EOL] public StaticScope<JSType> getFunctionScope(Node node) { [EOL]     return null; [EOL] } <line_num>: 757,759
@Override [EOL] public JSType getType(StaticScope<JSType> scope, Node node, String prop) { [EOL]     if (node.getJSType() == null) { [EOL]         return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE); [EOL]     } [EOL]     return node.getJSType(); [EOL] } <line_num>: 761,767
@Override [EOL] public boolean isInvalidatingType(JSType type) { [EOL]     if (type == null || invalidatingTypes.contains(type) || type.isUnknownType()) { [EOL]         return true; [EOL]     } [EOL]     ObjectType objType = ObjectType.cast(type); [EOL]     return objType != null && !objType.hasReferenceName(); [EOL] } <line_num>: 769,777
@Override [EOL] public ImmutableSet<JSType> getTypesToSkipForType(JSType type) { [EOL]     type = type.restrictByNotNullOrUndefined(); [EOL]     if (type.isUnionType()) { [EOL]         Set<JSType> types = Sets.newHashSet(type); [EOL]         for (JSType alt : type.toMaybeUnionType().getAlternates()) { [EOL]             types.addAll(getTypesToSkipForTypeNonUnion(type)); [EOL]         } [EOL]         return ImmutableSet.copyOf(types); [EOL]     } else if (type.isEnumElementType()) { [EOL]         return getTypesToSkipForType(type.toMaybeEnumElementType().getPrimitiveType()); [EOL]     } [EOL]     return ImmutableSet.copyOf(getTypesToSkipForTypeNonUnion(type)); [EOL] } <line_num>: 779,792
private Set<JSType> getTypesToSkipForTypeNonUnion(JSType type) { [EOL]     Set<JSType> types = Sets.newHashSet(); [EOL]     JSType skipType = type; [EOL]     while (skipType != null) { [EOL]         types.add(skipType); [EOL]         ObjectType objSkipType = skipType.toObjectType(); [EOL]         if (objSkipType != null) { [EOL]             skipType = objSkipType.getImplicitPrototype(); [EOL]         } else { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return types; [EOL] } <line_num>: 794,808
@Override [EOL] public boolean isTypeToSkip(JSType type) { [EOL]     return type.isEnumType() || (type.autoboxesTo() != null); [EOL] } <line_num>: 810,812
@Override [EOL] public JSType restrictByNotNullOrUndefined(JSType type) { [EOL]     return type.restrictByNotNullOrUndefined(); [EOL] } <line_num>: 814,816
@Override [EOL] public Iterable<JSType> getTypeAlternatives(JSType type) { [EOL]     if (type.isUnionType()) { [EOL]         return type.toMaybeUnionType().getAlternates(); [EOL]     } else { [EOL]         ObjectType objType = type.toObjectType(); [EOL]         if (objType != null && objType.getConstructor() != null && objType.getConstructor().isInterface()) { [EOL]             List<JSType> list = Lists.newArrayList(); [EOL]             for (FunctionType impl : registry.getDirectImplementors(objType)) { [EOL]                 list.add(impl.getInstanceType()); [EOL]             } [EOL]             return list; [EOL]         } else { [EOL]             return null; [EOL]         } [EOL]     } [EOL] } <line_num>: 818,836
@Override [EOL] public ObjectType getTypeWithProperty(String field, JSType type) { [EOL]     if (type == null) { [EOL]         return null; [EOL]     } [EOL]     if (type.isEnumElementType()) { [EOL]         return getTypeWithProperty(field, type.toMaybeEnumElementType().getPrimitiveType()); [EOL]     } [EOL]     if (!(type instanceof ObjectType)) { [EOL]         if (type.autoboxesTo() != null) { [EOL]             type = type.autoboxesTo(); [EOL]         } else { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     if ("prototype".equals(field)) { [EOL]         return null; [EOL]     } [EOL]     ObjectType foundType = null; [EOL]     ObjectType objType = ObjectType.cast(type); [EOL]     if (objType != null && objType.getConstructor() != null && objType.getConstructor().isInterface()) { [EOL]         ObjectType topInterface = FunctionType.getTopDefiningInterface(objType, field); [EOL]         if (topInterface != null && topInterface.getConstructor() != null) { [EOL]             foundType = topInterface.getConstructor().getPrototype(); [EOL]         } [EOL]     } else { [EOL]         while (objType != null && objType.getImplicitPrototype() != objType) { [EOL]             if (objType.hasOwnProperty(field)) { [EOL]                 foundType = objType; [EOL]             } [EOL]             objType = objType.getImplicitPrototype(); [EOL]         } [EOL]     } [EOL]     if (foundType == null) { [EOL]         ObjectType maybeType = ObjectType.cast(registry.getGreatestSubtypeWithProperty(type, field)); [EOL]         if (maybeType != null && maybeType.hasOwnProperty(field)) { [EOL]             foundType = maybeType; [EOL]         } [EOL]     } [EOL]     return foundType; [EOL] } <line_num>: 838,895
@Override [EOL] public JSType getInstanceFromPrototype(JSType type) { [EOL]     if (type.isFunctionPrototypeType()) { [EOL]         ObjectType prototype = (ObjectType) type; [EOL]         FunctionType owner = prototype.getOwnerFunction(); [EOL]         if (owner.isConstructor() || owner.isInterface()) { [EOL]             return prototype.getOwnerFunction().getInstanceType(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 897,906
@Override [EOL] public void recordInterfaces(JSType type, JSType relatedType, DisambiguateProperties<JSType>.Property p) { [EOL]     ObjectType objType = ObjectType.cast(type); [EOL]     if (objType != null) { [EOL]         FunctionType constructor; [EOL]         if (objType.isFunctionType()) { [EOL]             constructor = objType.toMaybeFunctionType(); [EOL]         } else if (objType.isFunctionPrototypeType()) { [EOL]             constructor = objType.getOwnerFunction(); [EOL]         } else { [EOL]             constructor = objType.getConstructor(); [EOL]         } [EOL]         while (constructor != null) { [EOL]             for (ObjectType itype : constructor.getImplementedInterfaces()) { [EOL]                 JSType top = getTypeWithProperty(p.name, itype); [EOL]                 if (top != null) { [EOL]                     p.addType(itype, top, relatedType); [EOL]                 } else { [EOL]                     recordInterfaces(itype, relatedType, p); [EOL]                 } [EOL]                 if (p.skipRenaming) [EOL]                     return; [EOL]             } [EOL]             if (constructor.isInterface() || constructor.isConstructor()) { [EOL]                 constructor = constructor.getSuperClassConstructor(); [EOL]             } else { [EOL]                 constructor = null; [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 908,940
@Override [EOL] public void addInvalidatingType(JSType type) { [EOL]     checkState(!type.isUnionType()); [EOL]     invalidatingTypes.add(type); [EOL] } <line_num>: 963,966
@Override [EOL] public StaticScope<ConcreteType> getRootScope() { [EOL]     return tt.getTopScope(); [EOL] } <line_num>: 968,970
@Override [EOL] public StaticScope<ConcreteType> getFunctionScope(Node decl) { [EOL]     ConcreteFunctionType func = tt.getConcreteFunction(decl); [EOL]     return (func != null) ? func.getScope() : (StaticScope<ConcreteType>) null; [EOL] } <line_num>: 972,976
@Override [EOL] public ConcreteType getType(StaticScope<ConcreteType> scope, Node node, String prop) { [EOL]     if (scope != null) { [EOL]         ConcreteType c = tt.inferConcreteType((TightenTypes.ConcreteScope) scope, node); [EOL]         return maybeAddAutoboxes(c, node, prop); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] } <line_num>: 978,988
private ConcreteType maybeAddAutoboxes(ConcreteType cType, Node node, String prop) { [EOL]     JSType jsType = node.getJSType(); [EOL]     if (jsType == null) { [EOL]         return cType; [EOL]     } else if (jsType.isUnknownType()) { [EOL]         for (JSTypeNative nativeType : nativeTypes) { [EOL]             ConcreteType concrete = tt.getConcreteInstance(tt.getTypeRegistry().getNativeObjectType(nativeType)); [EOL]             if (concrete != null && !concrete.getPropertyType(prop).isNone()) { [EOL]                 cType = cType.unionWith(concrete); [EOL]             } [EOL]         } [EOL]         return cType; [EOL]     } [EOL]     return maybeAddAutoboxes(cType, jsType, prop); [EOL] } <line_num>: 995,1012
private ConcreteType maybeAddAutoboxes(ConcreteType cType, JSType jsType, String prop) { [EOL]     jsType = jsType.restrictByNotNullOrUndefined(); [EOL]     if (jsType.isUnionType()) { [EOL]         for (JSType alt : jsType.toMaybeUnionType().getAlternates()) { [EOL]             cType = maybeAddAutoboxes(cType, alt, prop); [EOL]         } [EOL]         return cType; [EOL]     } else if (jsType.isEnumElementType()) { [EOL]         return maybeAddAutoboxes(cType, jsType.toMaybeEnumElementType().getPrimitiveType(), prop); [EOL]     } [EOL]     if (jsType.autoboxesTo() != null) { [EOL]         JSType autoboxed = jsType.autoboxesTo(); [EOL]         return cType.unionWith(tt.getConcreteInstance((ObjectType) autoboxed)); [EOL]     } else if (jsType.unboxesTo() != null) { [EOL]         return cType.unionWith(tt.getConcreteInstance((ObjectType) jsType)); [EOL]     } [EOL]     return cType; [EOL] } <line_num>: 1014,1035
@Override [EOL] public boolean isInvalidatingType(ConcreteType type) { [EOL]     return (type == null) || type.isAll() || type.isFunction() || (type.isInstance() && invalidatingTypes.contains(type.toInstance().instanceType)); [EOL] } <line_num>: 1037,1043
@Override [EOL] public ImmutableSet<ConcreteType> getTypesToSkipForType(ConcreteType type) { [EOL]     return ImmutableSet.of(type); [EOL] } <line_num>: 1045,1048
@Override [EOL] public boolean isTypeToSkip(ConcreteType type) { [EOL]     return type.isInstance() && !(type.toInstance().isFunctionPrototype() || type.toInstance().instanceType.isInstanceType()); [EOL] } <line_num>: 1050,1055
@Override [EOL] public ConcreteType restrictByNotNullOrUndefined(ConcreteType type) { [EOL]     return type; [EOL] } <line_num>: 1057,1061
@Override [EOL] public Iterable<ConcreteType> getTypeAlternatives(ConcreteType type) { [EOL]     if (type.isUnion()) { [EOL]         return ((ConcreteUnionType) type).getAlternatives(); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] } <line_num>: 1063,1070
@Override [EOL] public ConcreteType getTypeWithProperty(String field, ConcreteType type) { [EOL]     if (type.isInstance()) { [EOL]         ConcreteInstanceType instanceType = (ConcreteInstanceType) type; [EOL]         return instanceType.getInstanceTypeWithProperty(field); [EOL]     } else if (type.isFunction()) { [EOL]         if ("prototype".equals(field) || codingConvention.isSuperClassReference(field)) { [EOL]             return type; [EOL]         } [EOL]     } else if (type.isNone()) { [EOL]         return new ConcreteUniqueType(++nextUniqueId); [EOL]     } else if (type.isUnion()) { [EOL]         for (ConcreteType t : ((ConcreteUnionType) type).getAlternatives()) { [EOL]             ConcreteType ret = getTypeWithProperty(field, t); [EOL]             if (ret != null) { [EOL]                 return ret; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 1072,1097
@Override [EOL] public ConcreteType getInstanceFromPrototype(ConcreteType type) { [EOL]     if (type.isInstance()) { [EOL]         ConcreteInstanceType instanceType = (ConcreteInstanceType) type; [EOL]         if (instanceType.isFunctionPrototype()) { [EOL]             return instanceType.getConstructorType().getInstanceType(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 1099,1107
@Override [EOL] public void recordInterfaces(ConcreteType type, ConcreteType relatedType, DisambiguateProperties<ConcreteType>.Property p) { [EOL] } <line_num>: 1109,1113
