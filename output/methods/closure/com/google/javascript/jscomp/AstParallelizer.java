public AstParallelizer(Predicate<Node> shouldSplit, Predicate<Node> shouldTraverse, Supplier<Node> placeHolderProvider, Node root, boolean includeRoot) { [EOL]     this.shouldSplit = shouldSplit; [EOL]     this.placeHolderProvider = placeHolderProvider; [EOL]     this.root = root; [EOL]     this.includeRoot = includeRoot; [EOL]     this.forest = Lists.newLinkedList(); [EOL]     this.detachPointList = Lists.newLinkedList(); [EOL] } <line_num>: 65,77
private DetachPoint(Node placeHolder, Node before, Node original) { [EOL]     this.placeHolder = placeHolder; [EOL]     this.before = before; [EOL]     this.original = original; [EOL] } <line_num>: 213,217
@Override [EOL] public boolean apply(Node input) { [EOL]     return input.isFunction(); [EOL] } <line_num>: 84,87
@Override [EOL] public boolean apply(Node ignored) { [EOL]     return true; [EOL] } <line_num>: 92,95
@Override [EOL] public Node get() { [EOL]     return IR.function(IR.name(TEMP_NAME), IR.paramList(), IR.block()); [EOL] } <line_num>: 100,103
public static AstParallelizer createNewFunctionLevelAstParallelizer(Node root, boolean globalPass) { [EOL]     Predicate<Node> shouldSplit = new Predicate<Node>() { [EOL]  [EOL]         @Override [EOL]         public boolean apply(Node input) { [EOL]             return input.isFunction(); [EOL]         } [EOL]     }; [EOL]     Predicate<Node> shouldTraverse = new Predicate<Node>() { [EOL]  [EOL]         @Override [EOL]         public boolean apply(Node ignored) { [EOL]             return true; [EOL]         } [EOL]     }; [EOL]     Supplier<Node> placeHolders = new Supplier<Node>() { [EOL]  [EOL]         @Override [EOL]         public Node get() { [EOL]             return IR.function(IR.name(TEMP_NAME), IR.paramList(), IR.block()); [EOL]         } [EOL]     }; [EOL]     return new AstParallelizer(shouldSplit, shouldTraverse, placeHolders, root, globalPass); [EOL] } <line_num>: 79,107
@Override [EOL] public boolean apply(Node input) { [EOL]     return input.getSourceFileName() != null; [EOL] } <line_num>: 113,116
@Override [EOL] public Node get() { [EOL]     return NodeUtil.newExpr(IR.string(TEMP_NAME)); [EOL] } <line_num>: 121,124
@Override [EOL] public boolean apply(Node n) { [EOL]     return n.isBlock(); [EOL] } <line_num>: 129,132
public static AstParallelizer createNewFileLevelAstParallelizer(Node root) { [EOL]     Predicate<Node> shouldSplit = new Predicate<Node>() { [EOL]  [EOL]         @Override [EOL]         public boolean apply(Node input) { [EOL]             return input.getSourceFileName() != null; [EOL]         } [EOL]     }; [EOL]     Supplier<Node> placeHolders = new Supplier<Node>() { [EOL]  [EOL]         @Override [EOL]         public Node get() { [EOL]             return NodeUtil.newExpr(IR.string(TEMP_NAME)); [EOL]         } [EOL]     }; [EOL]     Predicate<Node> shouldTraverse = new Predicate<Node>() { [EOL]  [EOL]         @Override [EOL]         public boolean apply(Node n) { [EOL]             return n.isBlock(); [EOL]         } [EOL]     }; [EOL]     return new AstParallelizer(shouldSplit, shouldTraverse, placeHolders, root, false); [EOL] } <line_num>: 109,136
private void recordSplitPoint(Node placeHolder, Node before, Node original) { [EOL]     detachPointList.add(new DetachPoint(placeHolder, before, original)); [EOL] } <line_num>: 141,143
public List<Node> split() { [EOL]     if (includeRoot) { [EOL]         forest.add(root); [EOL]     } [EOL]     split(root); [EOL]     return forest; [EOL] } <line_num>: 150,156
private void split(Node n) { [EOL]     Node c = n.getFirstChild(); [EOL]     Node before = null; [EOL]     while (c != null) { [EOL]         Node next = c.getNext(); [EOL]         if (shouldSplit.apply(c)) { [EOL]             Node placeHolder = placeHolderProvider.get(); [EOL]             if (before == null) { [EOL]                 forest.add(n.removeFirstChild()); [EOL]                 n.addChildToFront(placeHolder); [EOL]             } else { [EOL]                 n.addChildAfter(placeHolder, c); [EOL]                 n.removeChildAfter(before); [EOL]                 forest.add(c); [EOL]             } [EOL]             recordSplitPoint(placeHolder, before, c); [EOL]             before = placeHolder; [EOL]         } else { [EOL]             split(c); [EOL]             before = c; [EOL]         } [EOL]         c = next; [EOL]     } [EOL] } <line_num>: 158,181
public void join() { [EOL]     while (!detachPointList.isEmpty()) { [EOL]         DetachPoint entry = detachPointList.remove(detachPointList.size() - 1); [EOL]         entry.reattach(); [EOL]     } [EOL] } <line_num>: 186,192
public void reattach() { [EOL]     if (placeHolder.getParent() != null) { [EOL]         if (before == null) { [EOL]             placeHolder.getParent().addChildrenToFront(original); [EOL]             placeHolder.getParent().removeChildAfter(original); [EOL]         } else { [EOL]             placeHolder.getParent().addChildAfter(original, before); [EOL]             placeHolder.getParent().removeChildAfter(original); [EOL]         } [EOL]     } [EOL] } <line_num>: 219,231
