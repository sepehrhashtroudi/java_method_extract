InlineVariables(AbstractCompiler compiler, Mode mode, boolean inlineAllStrings) { [EOL]     this.compiler = compiler; [EOL]     this.mode = mode; [EOL]     this.inlineAllStrings = inlineAllStrings; [EOL] } <line_num>: 73,80
AliasCandidate(Var alias, ReferenceCollection refInfo) { [EOL]     this.alias = alias; [EOL]     this.refInfo = refInfo; [EOL] } <line_num>: 131,134
@Override [EOL] public void process(Node externs, Node root) { [EOL]     ReferenceCollectingCallback callback = new ReferenceCollectingCallback(compiler, new InliningBehavior(), getFilterForMode()); [EOL]     callback.process(externs, root); [EOL] } <line_num>: 82,87
private Predicate<Var> getFilterForMode() { [EOL]     switch(mode) { [EOL]         case ALL: [EOL]             return Predicates.<Var>alwaysTrue(); [EOL]         case LOCALS_ONLY: [EOL]             return new IdentifyLocals(); [EOL]         case CONSTANTS_ONLY: [EOL]             return new IdentifyConstants(); [EOL]         default: [EOL]             throw new IllegalStateException(); [EOL]     } [EOL] } <line_num>: 89,100
@Override [EOL] public boolean apply(Var var) { [EOL]     return var.isConst(); [EOL] } <line_num>: 111,114
@Override [EOL] public boolean apply(Var var) { [EOL]     return var.scope.isLocal(); [EOL] } <line_num>: 121,124
@Override [EOL] public void afterExitScope(NodeTraversal t, ReferenceMap referenceMap) { [EOL]     collectAliasCandidates(t, referenceMap); [EOL]     doInlinesForScope(t, referenceMap); [EOL] } <line_num>: 157,161
private void collectAliasCandidates(NodeTraversal t, ReferenceMap referenceMap) { [EOL]     if (mode != Mode.CONSTANTS_ONLY) { [EOL]         for (Iterator<Var> it = t.getScope().getVars(); it.hasNext(); ) { [EOL]             Var v = it.next(); [EOL]             ReferenceCollection referenceInfo = referenceMap.getReferences(v); [EOL]             if (referenceInfo != null && referenceInfo.references.size() >= 2 && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) { [EOL]                 Reference init = referenceInfo.getInitializingReference(); [EOL]                 Node value = init.getAssignedValue(); [EOL]                 if (value != null && value.isName()) { [EOL]                     aliasCandidates.put(value, new AliasCandidate(v, referenceInfo)); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 167,188
private void doInlinesForScope(NodeTraversal t, ReferenceMap referenceMap) { [EOL]     boolean maybeModifiedArguments = maybeEscapedOrModifiedArguments(t.getScope(), referenceMap); [EOL]     for (Iterator<Var> it = t.getScope().getVars(); it.hasNext(); ) { [EOL]         Var v = it.next(); [EOL]         ReferenceCollection referenceInfo = referenceMap.getReferences(v); [EOL]         if (referenceInfo == null || isVarInlineForbidden(v)) { [EOL]             continue; [EOL]         } else if (isInlineableDeclaredConstant(v, referenceInfo)) { [EOL]             Reference init = referenceInfo.getInitializingReferenceForConstants(); [EOL]             Node value = init.getAssignedValue(); [EOL]             inlineDeclaredConstant(v, value, referenceInfo.references); [EOL]             staleVars.add(v); [EOL]         } else if (mode == Mode.CONSTANTS_ONLY) { [EOL]             continue; [EOL]         } else { [EOL]             inlineNonConstants(v, referenceInfo, maybeModifiedArguments); [EOL]         } [EOL]     } [EOL] } <line_num>: 194,222
private boolean maybeEscapedOrModifiedArguments(Scope scope, ReferenceMap referenceMap) { [EOL]     if (scope.isLocal()) { [EOL]         Var arguments = scope.getArgumentsVar(); [EOL]         ReferenceCollection refs = referenceMap.getReferences(arguments); [EOL]         if (refs != null && !refs.references.isEmpty()) { [EOL]             for (Reference ref : refs.references) { [EOL]                 Node refNode = ref.getNode(); [EOL]                 Node refParent = ref.getParent(); [EOL]                 if (!(NodeUtil.isGet(refParent) && refNode == ref.getParent().getFirstChild() && !isLValue(refParent))) { [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 224,244
private boolean isLValue(Node n) { [EOL]     Node parent = n.getParent(); [EOL]     return (parent.isInc() || parent.isDec() || (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)); [EOL] } <line_num>: 246,252
private void inlineNonConstants(Var v, ReferenceCollection referenceInfo, boolean maybeModifiedArguments) { [EOL]     int refCount = referenceInfo.references.size(); [EOL]     Reference declaration = referenceInfo.references.get(0); [EOL]     Reference init = referenceInfo.getInitializingReference(); [EOL]     int firstRefAfterInit = (declaration == init) ? 2 : 3; [EOL]     if (refCount > 1 && isImmutableAndWellDefinedVariable(v, referenceInfo)) { [EOL]         Node value; [EOL]         if (init != null) { [EOL]             value = init.getAssignedValue(); [EOL]         } else { [EOL]             Node srcLocation = declaration.getNode(); [EOL]             value = NodeUtil.newUndefinedNode(srcLocation); [EOL]         } [EOL]         Preconditions.checkNotNull(value); [EOL]         inlineWellDefinedVariable(v, value, referenceInfo.references); [EOL]         staleVars.add(v); [EOL]     } else if (refCount == firstRefAfterInit) { [EOL]         Reference reference = referenceInfo.references.get(firstRefAfterInit - 1); [EOL]         if (canInline(declaration, init, reference)) { [EOL]             inline(v, declaration, init, reference); [EOL]             staleVars.add(v); [EOL]         } [EOL]     } else if (declaration != init && refCount == 2) { [EOL]         if (isValidDeclaration(declaration) && isValidInitialization(init)) { [EOL]             Node value = init.getAssignedValue(); [EOL]             Preconditions.checkNotNull(value); [EOL]             inlineWellDefinedVariable(v, value, referenceInfo.references); [EOL]             staleVars.add(v); [EOL]         } [EOL]     } [EOL]     if (!maybeModifiedArguments && !staleVars.contains(v) && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) { [EOL]         List<Reference> refs = referenceInfo.references; [EOL]         for (int i = 1; i < refs.size(); i++) { [EOL]             Node nameNode = refs.get(i).getNode(); [EOL]             if (aliasCandidates.containsKey(nameNode)) { [EOL]                 AliasCandidate candidate = aliasCandidates.get(nameNode); [EOL]                 if (!staleVars.contains(candidate.alias) && !isVarInlineForbidden(candidate.alias)) { [EOL]                     Reference aliasInit; [EOL]                     aliasInit = candidate.refInfo.getInitializingReference(); [EOL]                     Node value = aliasInit.getAssignedValue(); [EOL]                     Preconditions.checkNotNull(value); [EOL]                     inlineWellDefinedVariable(candidate.alias, value, candidate.refInfo.references); [EOL]                     staleVars.add(candidate.alias); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 254,323
private void blacklistVarReferencesInTree(Node root, Scope scope) { [EOL]     for (Node c = root.getFirstChild(); c != null; c = c.getNext()) { [EOL]         blacklistVarReferencesInTree(c, scope); [EOL]     } [EOL]     if (root.isName()) { [EOL]         staleVars.add(scope.getVar(root.getString())); [EOL]     } [EOL] } <line_num>: 329,337
private boolean isVarInlineForbidden(Var var) { [EOL]     return var.isExtern() || compiler.getCodingConvention().isExported(var.name) || RenameProperties.RENAME_PROPERTY_FUNCTION_NAME.equals(var.name) || staleVars.contains(var); [EOL] } <line_num>: 342,353
private void inline(Var v, Reference declaration, Reference init, Reference reference) { [EOL]     Node value = init.getAssignedValue(); [EOL]     Preconditions.checkState(value != null); [EOL]     boolean isFunctionDeclaration = NodeUtil.isFunctionDeclaration(value); [EOL]     inlineValue(v, reference, value.detachFromParent()); [EOL]     if (declaration != init) { [EOL]         Node expressRoot = init.getGrandparent(); [EOL]         Preconditions.checkState(expressRoot.isExprResult()); [EOL]         NodeUtil.removeChild(expressRoot.getParent(), expressRoot); [EOL]     } [EOL]     if (!isFunctionDeclaration) { [EOL]         removeDeclaration(declaration); [EOL]     } else { [EOL]         compiler.reportCodeChange(); [EOL]     } [EOL] } <line_num>: 359,379
private void inlineWellDefinedVariable(Var v, Node value, List<Reference> refSet) { [EOL]     Reference decl = refSet.get(0); [EOL]     for (int i = 1; i < refSet.size(); i++) { [EOL]         inlineValue(v, refSet.get(i), value.cloneTree()); [EOL]     } [EOL]     removeDeclaration(decl); [EOL] } <line_num>: 384,391
private void inlineDeclaredConstant(Var v, Node value, List<Reference> refSet) { [EOL]     Reference decl = null; [EOL]     for (Reference r : refSet) { [EOL]         if (r.getNode() == v.getNameNode()) { [EOL]             decl = r; [EOL]         } else { [EOL]             inlineValue(v, r, value.cloneTree()); [EOL]         } [EOL]     } [EOL]     removeDeclaration(decl); [EOL] } <line_num>: 396,410
private void removeDeclaration(Reference declaration) { [EOL]     Node varNode = declaration.getParent(); [EOL]     Node grandparent = declaration.getGrandparent(); [EOL]     varNode.removeChild(declaration.getNode()); [EOL]     if (!varNode.hasChildren()) { [EOL]         Preconditions.checkState(varNode.isVar()); [EOL]         NodeUtil.removeChild(grandparent, varNode); [EOL]     } [EOL]     compiler.reportCodeChange(); [EOL] } <line_num>: 415,428
private void inlineValue(Var v, Reference ref, Node value) { [EOL]     if (ref.isSimpleAssignmentToName()) { [EOL]         ref.getGrandparent().replaceChild(ref.getParent(), value); [EOL]     } else { [EOL]         ref.getParent().replaceChild(ref.getNode(), value); [EOL]     } [EOL]     blacklistVarReferencesInTree(value, v.scope); [EOL]     compiler.reportCodeChange(); [EOL] } <line_num>: 438,448
private boolean isInlineableDeclaredConstant(Var var, ReferenceCollection refInfo) { [EOL]     if (!identifyConstants.apply(var)) { [EOL]         return false; [EOL]     } [EOL]     if (!refInfo.isAssignedOnceInLifetime()) { [EOL]         return false; [EOL]     } [EOL]     Reference init = refInfo.getInitializingReferenceForConstants(); [EOL]     if (init == null) { [EOL]         return false; [EOL]     } [EOL]     Node value = init.getAssignedValue(); [EOL]     if (value == null) { [EOL]         return false; [EOL]     } [EOL]     if (!NodeUtil.isImmutableValue(value)) { [EOL]         return false; [EOL]     } [EOL]     return !value.isString() || isStringWorthInlining(var, refInfo.references); [EOL] } <line_num>: 454,485
private boolean isStringWorthInlining(Var var, List<Reference> refs) { [EOL]     if (!inlineAllStrings && !var.isDefine()) { [EOL]         int len = var.getInitialValue().getString().length() + "''".length(); [EOL]         int noInlineBytes = "var xx=;".length() + len + 4 * (refs.size() - 1); [EOL]         int inlineBytes = (len - 1) * (refs.size() - 1); [EOL]         return noInlineBytes >= inlineBytes; [EOL]     } [EOL]     return true; [EOL] } <line_num>: 490,513
private boolean canInline(Reference declaration, Reference initialization, Reference reference) { [EOL]     if (!isValidDeclaration(declaration) || !isValidInitialization(initialization) || !isValidReference(reference)) { [EOL]         return false; [EOL]     } [EOL]     if (declaration != initialization && !initialization.getGrandparent().isExprResult()) { [EOL]         return false; [EOL]     } [EOL]     if (declaration.getBasicBlock() != initialization.getBasicBlock() || declaration.getBasicBlock() != reference.getBasicBlock()) { [EOL]         return false; [EOL]     } [EOL]     Node value = initialization.getAssignedValue(); [EOL]     Preconditions.checkState(value != null); [EOL]     if (value.isGetProp() && reference.getParent().isCall() && reference.getParent().getFirstChild() == reference.getNode()) { [EOL]         return false; [EOL]     } [EOL]     if (value.isFunction()) { [EOL]         Node callNode = reference.getParent(); [EOL]         if (reference.getParent().isCall()) { [EOL]             CodingConvention convention = compiler.getCodingConvention(); [EOL]             SubclassRelationship relationship = convention.getClassesDefinedByCall(callNode); [EOL]             if (relationship != null) { [EOL]                 return false; [EOL]             } [EOL]             if (convention.getSingletonGetterClassName(callNode) != null) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return canMoveAggressively(value) || canMoveModerately(initialization, reference); [EOL] } <line_num>: 519,583
private boolean canMoveAggressively(Node value) { [EOL]     return NodeUtil.isLiteralValue(value, true) || value.isFunction(); [EOL] } <line_num>: 588,593
private boolean canMoveModerately(Reference initialization, Reference reference) { [EOL]     Iterator<Node> it; [EOL]     if (initialization.getParent().isVar()) { [EOL]         it = NodeIterators.LocalVarMotion.forVar(initialization.getNode(), initialization.getParent(), initialization.getGrandparent()); [EOL]     } else if (initialization.getParent().isAssign()) { [EOL]         Preconditions.checkState(initialization.getGrandparent().isExprResult()); [EOL]         it = NodeIterators.LocalVarMotion.forAssign(initialization.getNode(), initialization.getParent(), initialization.getGrandparent(), initialization.getGrandparent().getParent()); [EOL]     } else { [EOL]         throw new IllegalStateException("Unexpected initialization parent " + initialization.getParent().toStringTree()); [EOL]     } [EOL]     Node targetName = reference.getNode(); [EOL]     while (it.hasNext()) { [EOL]         Node curNode = it.next(); [EOL]         if (curNode == targetName) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 600,632
private boolean isValidDeclaration(Reference declaration) { [EOL]     return (declaration.getParent().isVar() && !declaration.getGrandparent().isFor()) || NodeUtil.isFunctionDeclaration(declaration.getParent()); [EOL] } <line_num>: 637,641
private boolean isValidInitialization(Reference initialization) { [EOL]     if (initialization == null) { [EOL]         return false; [EOL]     } else if (initialization.isDeclaration()) { [EOL]         if (!NodeUtil.isFunctionDeclaration(initialization.getParent()) && initialization.getNode().getFirstChild() == null) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         Node parent = initialization.getParent(); [EOL]         Preconditions.checkState(parent.isAssign() && parent.getFirstChild() == initialization.getNode()); [EOL]     } [EOL]     Node n = initialization.getAssignedValue(); [EOL]     if (n.isFunction()) { [EOL]         return compiler.getCodingConvention().isInlinableFunction(n); [EOL]     } [EOL]     return true; [EOL] } <line_num>: 646,669
private boolean isValidReference(Reference reference) { [EOL]     return !reference.isDeclaration() && !reference.isLvalue(); [EOL] } <line_num>: 674,676
private boolean isImmutableAndWellDefinedVariable(Var v, ReferenceCollection refInfo) { [EOL]     List<Reference> refSet = refInfo.references; [EOL]     int startingReadRef = 1; [EOL]     Reference refDecl = refSet.get(0); [EOL]     if (!isValidDeclaration(refDecl)) { [EOL]         return false; [EOL]     } [EOL]     boolean isNeverAssigned = refInfo.isNeverAssigned(); [EOL]     if (!isNeverAssigned) { [EOL]         Reference refInit = refInfo.getInitializingReference(); [EOL]         if (!isValidInitialization(refInit)) { [EOL]             return false; [EOL]         } [EOL]         if (refDecl != refInit) { [EOL]             Preconditions.checkState(refInit == refSet.get(1)); [EOL]             startingReadRef = 2; [EOL]         } [EOL]         if (!refInfo.isWellDefined()) { [EOL]             return false; [EOL]         } [EOL]         Node value = refInit.getAssignedValue(); [EOL]         Preconditions.checkNotNull(value); [EOL]         boolean isImmutableValueWorthInlining = NodeUtil.isImmutableValue(value) && (!value.isString() || isStringWorthInlining(v, refInfo.references)); [EOL]         boolean isInlinableThisAlias = value.isThis() && !refInfo.isEscaped(); [EOL]         if (!isImmutableValueWorthInlining && !isInlinableThisAlias) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     for (int i = startingReadRef; i < refSet.size(); i++) { [EOL]         Reference ref = refSet.get(i); [EOL]         if (!isValidReference(ref)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 683,733
