MarkNoSideEffectCalls(AbstractCompiler compiler) { [EOL]     this.compiler = compiler; [EOL]     this.noSideEffectFunctionNames = Sets.newHashSet(); [EOL] } <line_num>: 52,55
GatherNoSideEffectFunctions(boolean inExterns) { [EOL]     this.inExterns = inExterns; [EOL] } <line_num>: 115,117
SetNoSideEffectCallProperty(SimpleDefinitionFinder defFinder) { [EOL]     this.defFinder = defFinder; [EOL] } <line_num>: 171,173
@Override [EOL] public void process(Node externs, Node root) { [EOL]     SimpleDefinitionFinder defFinder = new SimpleDefinitionFinder(compiler); [EOL]     defFinder.process(externs, root); [EOL]     NodeTraversal.traverse(compiler, externs, new GatherNoSideEffectFunctions(true)); [EOL]     NodeTraversal.traverse(compiler, root, new GatherNoSideEffectFunctions(false)); [EOL]     NodeTraversal.traverse(compiler, root, new SetNoSideEffectCallProperty(defFinder)); [EOL] } <line_num>: 57,71
private static boolean definitionTypeContainsFunctionType(Definition def) { [EOL]     Node rhs = def.getRValue(); [EOL]     if (rhs == null) { [EOL]         return true; [EOL]     } [EOL]     switch(rhs.getType()) { [EOL]         case Token.ASSIGN: [EOL]         case Token.AND: [EOL]         case Token.CALL: [EOL]         case Token.GETPROP: [EOL]         case Token.GETELEM: [EOL]         case Token.FUNCTION: [EOL]         case Token.HOOK: [EOL]         case Token.NAME: [EOL]         case Token.NEW: [EOL]         case Token.OR: [EOL]             return true; [EOL]         default: [EOL]             return false; [EOL]     } [EOL] } <line_num>: 77,98
private static boolean hasNoSideEffectsAnnotation(Node node) { [EOL]     JSDocInfo docInfo = node.getJSDocInfo(); [EOL]     return docInfo != null && docInfo.isNoSideEffects(); [EOL] } <line_num>: 104,107
@Override [EOL] public void visit(NodeTraversal traversal, Node node, Node parent) { [EOL]     if (!inExterns && hasNoSideEffectsAnnotation(node)) { [EOL]         traversal.report(node, INVALID_NO_SIDE_EFFECT_ANNOTATION); [EOL]     } [EOL]     if (node.isGetProp()) { [EOL]         if (parent.isExprResult() && hasNoSideEffectsAnnotation(node)) { [EOL]             noSideEffectFunctionNames.add(node); [EOL]         } [EOL]     } else if (node.isFunction()) { [EOL]         boolean hasAnnotation = hasNoSideEffectsAnnotation(node); [EOL]         List<Node> nameNodes = Lists.newArrayList(); [EOL]         nameNodes.add(node.getFirstChild()); [EOL]         Node nameNode = null; [EOL]         if (parent.isName()) { [EOL]             Node gramp = parent.getParent(); [EOL]             if (gramp.isVar() && gramp.hasOneChild() && hasNoSideEffectsAnnotation(gramp)) { [EOL]                 hasAnnotation = true; [EOL]             } [EOL]             nameNodes.add(parent); [EOL]         } else if (parent.isAssign()) { [EOL]             if (hasNoSideEffectsAnnotation(parent)) { [EOL]                 hasAnnotation = true; [EOL]             } [EOL]             nameNodes.add(parent.getFirstChild()); [EOL]         } [EOL]         if (hasAnnotation) { [EOL]             noSideEffectFunctionNames.addAll(nameNodes); [EOL]         } [EOL]     } [EOL] } <line_num>: 119,161
@Override [EOL] public void visit(NodeTraversal traversal, Node node, Node parent) { [EOL]     if (!node.isCall() && !node.isNew()) { [EOL]         return; [EOL]     } [EOL]     Collection<Definition> definitions = defFinder.getDefinitionsReferencedAt(node.getFirstChild()); [EOL]     if (definitions == null) { [EOL]         return; [EOL]     } [EOL]     for (Definition def : definitions) { [EOL]         Node lValue = def.getLValue(); [EOL]         Preconditions.checkNotNull(lValue); [EOL]         if (!noSideEffectFunctionNames.contains(lValue) && definitionTypeContainsFunctionType(def)) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     node.setSideEffectFlags(Node.NO_SIDE_EFFECTS); [EOL] } <line_num>: 175,197
