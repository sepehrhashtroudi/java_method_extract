CheckGlobalNames(AbstractCompiler compiler, CheckLevel level) { [EOL]     this.compiler = compiler; [EOL]     this.convention = compiler.getCodingConvention(); [EOL]     this.level = level; [EOL] } <line_num>: 63,67
CheckGlobalNames injectNamespace(GlobalNamespace namespace) { [EOL]     Preconditions.checkArgument(namespace.hasExternsRoot()); [EOL]     this.namespace = namespace; [EOL]     return this; [EOL] } <line_num>: 73,77
@Override [EOL] public void process(Node externs, Node root) { [EOL]     if (namespace == null) { [EOL]         namespace = new GlobalNamespace(compiler, externs, root); [EOL]     } [EOL]     Preconditions.checkState(namespace.hasExternsRoot()); [EOL]     findPrototypeProps("Object", objectPrototypeProps); [EOL]     findPrototypeProps("Function", functionPrototypeProps); [EOL]     objectPrototypeProps.addAll(convention.getIndirectlyDeclaredProperties()); [EOL]     for (Name name : namespace.getNameForest()) { [EOL]         if (name.inExterns) { [EOL]             continue; [EOL]         } [EOL]         checkDescendantNames(name, name.globalSets + name.localSets > 0); [EOL]     } [EOL] } <line_num>: 79,104
private void findPrototypeProps(String type, Set<String> props) { [EOL]     Name slot = namespace.getSlot(type); [EOL]     if (slot != null) { [EOL]         for (Ref ref : slot.getRefs()) { [EOL]             if (ref.type == Ref.Type.PROTOTYPE_GET) { [EOL]                 Node fullName = ref.getNode().getParent().getParent(); [EOL]                 if (fullName.isGetProp()) { [EOL]                     props.add(fullName.getLastChild().getString()); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 106,118
private void checkDescendantNames(Name name, boolean nameIsDefined) { [EOL]     if (name.props != null) { [EOL]         for (Name prop : name.props) { [EOL]             boolean propIsDefined = false; [EOL]             if (nameIsDefined) { [EOL]                 propIsDefined = (!propertyMustBeInitializedByFullName(prop) || prop.globalSets + prop.localSets > 0); [EOL]             } [EOL]             validateName(prop, propIsDefined); [EOL]             checkDescendantNames(prop, propIsDefined); [EOL]         } [EOL]     } [EOL] } <line_num>: 128,145
private void validateName(Name name, boolean isDefined) { [EOL]     Ref declaration = name.getDeclaration(); [EOL]     Name parent = name.parent; [EOL]     JSModuleGraph moduleGraph = compiler.getModuleGraph(); [EOL]     for (Ref ref : name.getRefs()) { [EOL]         boolean isGlobalExpr = ref.getNode().getParent().isExprResult(); [EOL]         if (!isDefined && !isTypedef(ref)) { [EOL]             if (!isGlobalExpr) { [EOL]                 reportRefToUndefinedName(name, ref); [EOL]             } [EOL]         } else if (declaration != null && ref.getModule() != declaration.getModule() && !moduleGraph.dependsOn(ref.getModule(), declaration.getModule())) { [EOL]             reportBadModuleReference(name, ref); [EOL]         } else { [EOL]             if (ref.scope.isGlobal()) { [EOL]                 boolean isPrototypeGet = (ref.type == Ref.Type.PROTOTYPE_GET); [EOL]                 Name owner = isPrototypeGet ? name : parent; [EOL]                 boolean singleGlobalParentDecl = owner != null && owner.getDeclaration() != null && owner.localSets == 0; [EOL]                 if (singleGlobalParentDecl && owner.getDeclaration().preOrderIndex > ref.preOrderIndex) { [EOL]                     String refName = isPrototypeGet ? name.getFullName() + ".prototype" : name.getFullName(); [EOL]                     compiler.report(JSError.make(ref.source.getName(), ref.node, NAME_DEFINED_LATE_WARNING, refName, owner.getFullName(), owner.getDeclaration().source.getName(), String.valueOf(owner.getDeclaration().node.getLineno()))); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 147,195
private boolean isTypedef(Ref ref) { [EOL]     Node parent = ref.node.getParent(); [EOL]     if (parent.isExprResult()) { [EOL]         JSDocInfo info = ref.node.getJSDocInfo(); [EOL]         if (info != null && info.hasTypedefType()) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 197,207
private void reportBadModuleReference(Name name, Ref ref) { [EOL]     compiler.report(JSError.make(ref.source.getName(), ref.node, STRICT_MODULE_DEP_QNAME, ref.getModule().getName(), name.getDeclaration().getModule().getName(), name.getFullName())); [EOL] } <line_num>: 209,215
private void reportRefToUndefinedName(Name name, Ref ref) { [EOL]     while (name.parent != null && name.parent.globalSets + name.parent.localSets == 0) { [EOL]         name = name.parent; [EOL]     } [EOL]     compiler.report(JSError.make(ref.getSourceName(), ref.node, level, UNDEFINED_NAME_WARNING, name.getFullName())); [EOL] } <line_num>: 217,227
private boolean propertyMustBeInitializedByFullName(Name name) { [EOL]     if (name.parent == null) { [EOL]         return false; [EOL]     } [EOL]     boolean parentIsAliased = false; [EOL]     if (name.parent.aliasingGets > 0) { [EOL]         for (Ref ref : name.parent.getRefs()) { [EOL]             if (ref.type == Ref.Type.ALIASING_GET) { [EOL]                 Node aliaser = ref.getNode().getParent(); [EOL]                 boolean isKnownAlias = aliaser.isCall() && (convention.getClassesDefinedByCall(aliaser) != null || convention.getSingletonGetterClassName(aliaser) != null); [EOL]                 if (!isKnownAlias) { [EOL]                     parentIsAliased = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (parentIsAliased) { [EOL]         return false; [EOL]     } [EOL]     if (objectPrototypeProps.contains(name.getBaseName())) { [EOL]         return false; [EOL]     } [EOL]     if (name.parent.type == Name.Type.OBJECTLIT) { [EOL]         return true; [EOL]     } [EOL]     if (name.parent.type == Name.Type.FUNCTION && name.parent.isDeclaredType() && !functionPrototypeProps.contains(name.getBaseName())) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 233,287
