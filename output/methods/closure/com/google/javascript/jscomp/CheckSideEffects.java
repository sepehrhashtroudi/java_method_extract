CheckSideEffects(AbstractCompiler compiler, CheckLevel level, boolean protectSideEffectFreeCode) { [EOL]     this.compiler = compiler; [EOL]     this.level = level; [EOL]     this.protectSideEffectFreeCode = protectSideEffectFreeCode; [EOL] } <line_num>: 57,62
StripProtection(AbstractCompiler compiler) { [EOL]     this.compiler = compiler; [EOL] } <line_num>: 173,175
@Override [EOL] public void process(Node externs, Node root) { [EOL]     NodeTraversal.traverse(compiler, root, this); [EOL]     if (protectSideEffectFreeCode) { [EOL]         protectSideEffects(); [EOL]     } [EOL] } <line_num>: 64,76
@Override [EOL] public void hotSwapScript(Node scriptRoot, Node originalRoot) { [EOL]     NodeTraversal.traverse(compiler, scriptRoot, this); [EOL] } <line_num>: 78,81
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (n.isEmpty() || n.isComma()) { [EOL]         return; [EOL]     } [EOL]     if (parent == null) { [EOL]         return; [EOL]     } [EOL]     if (n.isExprResult() || n.isBlock()) { [EOL]         return; [EOL]     } [EOL]     if (n.isQualifiedName() && n.getJSDocInfo() != null) { [EOL]         return; [EOL]     } [EOL]     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); [EOL]     boolean isSimpleOp = NodeUtil.isSimpleOperator(n); [EOL]     if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { [EOL]         String msg = "This code lacks side-effects. Is there a bug?"; [EOL]         if (n.isString()) { [EOL]             msg = "Is there a missing '+' on the previous line?"; [EOL]         } else if (isSimpleOp) { [EOL]             msg = "The result of the '" + Token.name(n.getType()).toLowerCase() + "' operator is not being used."; [EOL]         } [EOL]         t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg)); [EOL]         if (!NodeUtil.isStatement(n)) { [EOL]             problemNodes.add(n); [EOL]         } [EOL]     } [EOL] } <line_num>: 83,131
private void protectSideEffects() { [EOL]     if (!problemNodes.isEmpty()) { [EOL]         addExtern(); [EOL]         for (Node n : problemNodes) { [EOL]             Node name = IR.name(PROTECTOR_FN).srcref(n); [EOL]             name.putBooleanProp(Node.IS_CONSTANT_NAME, true); [EOL]             Node replacement = IR.call(name).srcref(n); [EOL]             replacement.putBooleanProp(Node.FREE_CALL, true); [EOL]             n.getParent().replaceChild(n, replacement); [EOL]             replacement.addChildToBack(n); [EOL]         } [EOL]         compiler.reportCodeChange(); [EOL]     } [EOL] } <line_num>: 138,151
private void addExtern() { [EOL]     Node name = IR.name(PROTECTOR_FN); [EOL]     name.putBooleanProp(Node.IS_CONSTANT_NAME, true); [EOL]     Node var = IR.var(name); [EOL]     JSDocInfoBuilder builder = new JSDocInfoBuilder(false); [EOL]     builder.recordNoAlias(); [EOL]     var.setJSDocInfo(builder.build(var)); [EOL]     CompilerInput input = compiler.getSynthesizedExternsInput(); [EOL]     input.getAstRoot(compiler).addChildrenToBack(var); [EOL]     compiler.reportCodeChange(); [EOL] } <line_num>: 153,164
@Override [EOL] public void process(Node externs, Node root) { [EOL]     NodeTraversal.traverse(compiler, root, this); [EOL] } <line_num>: 177,180
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (n.isCall()) { [EOL]         Node target = n.getFirstChild(); [EOL]         if (target.isName() && target.getString().equals(PROTECTOR_FN)) { [EOL]             Node expr = n.getLastChild(); [EOL]             n.detachChildren(); [EOL]             parent.replaceChild(n, expr); [EOL]         } [EOL]     } [EOL] } <line_num>: 182,194
