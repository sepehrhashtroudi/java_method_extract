JsMessageVisitor(AbstractCompiler compiler, boolean needToCheckDuplications, JsMessage.Style style, JsMessage.IdGenerator idGenerator) { [EOL]     this.compiler = compiler; [EOL]     this.needToCheckDuplications = needToCheckDuplications; [EOL]     this.style = style; [EOL]     this.idGenerator = idGenerator; [EOL]     checkLevel = (style == JsMessage.Style.CLOSURE) ? CheckLevel.ERROR : CheckLevel.WARNING; [EOL] } <line_num>: 154,169
MalformedException(String message, Node node) { [EOL]     super(message); [EOL]     this.node = node; [EOL] } <line_num>: 924,927
private MessageLocation(JsMessage message, Node messageNode) { [EOL]     this.message = message; [EOL]     this.messageNode = messageNode; [EOL] } <line_num>: 938,941
@Override [EOL] public void process(Node externs, Node root) { [EOL]     NodeTraversal.traverse(compiler, root, this); [EOL]     for (Map.Entry<Node, String> msgNode : googMsgNodes.entrySet()) { [EOL]         compiler.report(JSError.make(msgNode.getValue(), msgNode.getKey(), checkLevel, MESSAGE_NODE_IS_ORPHANED)); [EOL]     } [EOL] } <line_num>: 171,179
@Override [EOL] public void visit(NodeTraversal traversal, Node node, Node parent) { [EOL]     String messageKey; [EOL]     boolean isVar; [EOL]     Node msgNode, msgNodeParent; [EOL]     switch(node.getType()) { [EOL]         case Token.NAME: [EOL]             if ((parent != null) && (parent.isVar())) { [EOL]                 messageKey = node.getString(); [EOL]                 isVar = true; [EOL]             } else { [EOL]                 return; [EOL]             } [EOL]             msgNode = node.getFirstChild(); [EOL]             msgNodeParent = node; [EOL]             break; [EOL]         case Token.ASSIGN: [EOL]             isVar = false; [EOL]             Node getProp = node.getFirstChild(); [EOL]             if (!getProp.isGetProp()) { [EOL]                 return; [EOL]             } [EOL]             Node propNode = getProp.getLastChild(); [EOL]             messageKey = propNode.getString(); [EOL]             msgNode = node.getLastChild(); [EOL]             msgNodeParent = node; [EOL]             break; [EOL]         case Token.CALL: [EOL]             String fnName = node.getFirstChild().getQualifiedName(); [EOL]             if (MSG_FUNCTION_NAME.equals(fnName)) { [EOL]                 googMsgNodes.put(node, traversal.getSourceName()); [EOL]             } else if (MSG_FALLBACK_FUNCTION_NAME.equals(fnName)) { [EOL]                 visitFallbackFunctionCall(traversal, node); [EOL]             } [EOL]             return; [EOL]         default: [EOL]             return; [EOL]     } [EOL]     boolean isNewStyleMessage = msgNode != null && msgNode.isCall(); [EOL]     if (!isMessageName(messageKey, isNewStyleMessage)) { [EOL]         return; [EOL]     } [EOL]     if (msgNode == null) { [EOL]         compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_VALUE, messageKey)); [EOL]         return; [EOL]     } [EOL]     if (isNewStyleMessage) { [EOL]         googMsgNodes.remove(msgNode); [EOL]     } else if (style != JsMessage.Style.LEGACY) { [EOL]         compiler.report(traversal.makeError(node, checkLevel, MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX)); [EOL]     } [EOL]     boolean isUnnamedMsg = isUnnamedMessageName(messageKey); [EOL]     Builder builder = new Builder(isUnnamedMsg ? null : messageKey); [EOL]     builder.setSourceName(traversal.getSourceName()); [EOL]     try { [EOL]         if (isVar) { [EOL]             extractMessageFromVariable(builder, node, parent, parent.getParent()); [EOL]         } else { [EOL]             extractMessageFromProperty(builder, node.getFirstChild(), node); [EOL]         } [EOL]     } catch (MalformedException ex) { [EOL]         compiler.report(traversal.makeError(ex.getNode(), MESSAGE_TREE_MALFORMED, ex.getMessage())); [EOL]         return; [EOL]     } [EOL]     JsMessage extractedMessage = builder.build(idGenerator); [EOL]     if (needToCheckDuplications && !isUnnamedMsg && !extractedMessage.isExternal()) { [EOL]         checkIfMessageDuplicated(messageKey, msgNode); [EOL]     } [EOL]     trackMessage(traversal, extractedMessage, messageKey, msgNode, isUnnamedMsg); [EOL]     if (extractedMessage.isEmpty()) { [EOL]         compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_TEXT, messageKey)); [EOL]     } [EOL]     String desc = extractedMessage.getDesc(); [EOL]     if (isNewStyleMessage && (desc == null || desc.trim().isEmpty()) && !extractedMessage.isExternal()) { [EOL]         compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_DESCRIPTION, messageKey)); [EOL]     } [EOL]     JsMessageDefinition msgDefinition = new JsMessageDefinition(node, msgNode, msgNodeParent); [EOL]     processJsMessage(extractedMessage, msgDefinition); [EOL] } <line_num>: 181,300
private void trackMessage(NodeTraversal t, JsMessage message, String msgName, Node msgNode, boolean isUnnamedMessage) { [EOL]     if (!isUnnamedMessage) { [EOL]         MessageLocation location = new MessageLocation(message, msgNode); [EOL]         messageNames.put(msgName, location); [EOL]     } else if (msgNode.isName()) { [EOL]         Var var = t.getScope().getVar(msgName); [EOL]         if (var != null) { [EOL]             unnamedMessages.put(var, message); [EOL]         } [EOL]     } [EOL] } <line_num>: 310,322
private JsMessage getTrackedMessage(NodeTraversal t, String msgName) { [EOL]     boolean isUnnamedMessage = isUnnamedMessageName(msgName); [EOL]     if (!isUnnamedMessage) { [EOL]         MessageLocation location = messageNames.get(msgName); [EOL]         return location == null ? null : location.message; [EOL]     } else { [EOL]         Var var = t.getScope().getVar(msgName); [EOL]         if (var != null) { [EOL]             return unnamedMessages.get(var); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 325,337
private void checkIfMessageDuplicated(String msgName, Node msgNode) { [EOL]     if (messageNames.containsKey(msgName)) { [EOL]         MessageLocation location = messageNames.get(msgName); [EOL]         compiler.report(JSError.make(msgNode, MESSAGE_DUPLICATE_KEY, msgName, location.messageNode.getSourceFileName(), Integer.toString(location.messageNode.getLineno()))); [EOL]     } [EOL] } <line_num>: 346,353
private void extractMessageFromVariable(Builder builder, Node nameNode, Node parentNode, @Nullable Node grandParentNode) throws MalformedException { [EOL]     Node valueNode = nameNode.getFirstChild(); [EOL]     switch(valueNode.getType()) { [EOL]         case Token.STRING: [EOL]         case Token.ADD: [EOL]             maybeInitMetaDataFromJsDocOrHelpVar(builder, parentNode, grandParentNode); [EOL]             builder.appendStringPart(extractStringFromStringExprNode(valueNode)); [EOL]             break; [EOL]         case Token.FUNCTION: [EOL]             maybeInitMetaDataFromJsDocOrHelpVar(builder, parentNode, grandParentNode); [EOL]             extractFromFunctionNode(builder, valueNode); [EOL]             break; [EOL]         case Token.CALL: [EOL]             maybeInitMetaDataFromJsDoc(builder, parentNode); [EOL]             extractFromCallNode(builder, valueNode); [EOL]             break; [EOL]         default: [EOL]             throw new MalformedException("Cannot parse value of message " + builder.getKey(), valueNode); [EOL]     } [EOL] } <line_num>: 369,395
private void extractMessageFromProperty(Builder builder, Node getPropNode, Node assignNode) throws MalformedException { [EOL]     Node callNode = getPropNode.getNext(); [EOL]     maybeInitMetaDataFromJsDoc(builder, assignNode); [EOL]     extractFromCallNode(builder, callNode); [EOL] } <line_num>: 407,413
private void maybeInitMetaDataFromJsDocOrHelpVar(Builder builder, Node varNode, @Nullable Node parentOfVarNode) throws MalformedException { [EOL]     if (maybeInitMetaDataFromJsDoc(builder, varNode)) { [EOL]         return; [EOL]     } [EOL]     if ((parentOfVarNode != null) && maybeInitMetaDataFromHelpVar(builder, parentOfVarNode.getChildBefore(varNode))) { [EOL]         return; [EOL]     } [EOL]     maybeInitMetaDataFromHelpVar(builder, varNode.getNext()); [EOL] } <line_num>: 423,441
private boolean maybeInitMetaDataFromHelpVar(Builder builder, @Nullable Node sibling) throws MalformedException { [EOL]     if ((sibling != null) && (sibling.isVar())) { [EOL]         Node nameNode = sibling.getFirstChild(); [EOL]         String name = nameNode.getString(); [EOL]         if (name.equals(builder.getKey() + DESC_SUFFIX)) { [EOL]             Node valueNode = nameNode.getFirstChild(); [EOL]             String desc = extractStringFromStringExprNode(valueNode); [EOL]             if (desc.startsWith(HIDDEN_DESC_PREFIX)) { [EOL]                 builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim()); [EOL]                 builder.setIsHidden(true); [EOL]             } else { [EOL]                 builder.setDesc(desc); [EOL]             } [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 451,469
private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node) { [EOL]     boolean messageHasDesc = false; [EOL]     JSDocInfo info = node.getJSDocInfo(); [EOL]     if (info != null) { [EOL]         String desc = info.getDescription(); [EOL]         if (desc != null) { [EOL]             builder.setDesc(desc); [EOL]             messageHasDesc = true; [EOL]         } [EOL]         if (info.isHidden()) { [EOL]             builder.setIsHidden(true); [EOL]         } [EOL]         if (info.getMeaning() != null) { [EOL]             builder.setMeaning(info.getMeaning()); [EOL]         } [EOL]     } [EOL]     return messageHasDesc; [EOL] } <line_num>: 480,498
private static String extractStringFromStringExprNode(Node node) throws MalformedException { [EOL]     switch(node.getType()) { [EOL]         case Token.STRING: [EOL]             return node.getString(); [EOL]         case Token.ADD: [EOL]             StringBuilder sb = new StringBuilder(); [EOL]             for (Node child : node.children()) { [EOL]                 sb.append(extractStringFromStringExprNode(child)); [EOL]             } [EOL]             return sb.toString(); [EOL]         default: [EOL]             throw new MalformedException("STRING or ADD node expected; found: " + getReadableTokenName(node), node); [EOL]     } [EOL] } <line_num>: 509,524
private void extractFromFunctionNode(Builder builder, Node node) throws MalformedException { [EOL]     Set<String> phNames = Sets.newHashSet(); [EOL]     for (Node fnChild : node.children()) { [EOL]         switch(fnChild.getType()) { [EOL]             case Token.NAME: [EOL]                 break; [EOL]             case Token.PARAM_LIST: [EOL]                 for (Node argumentNode : fnChild.children()) { [EOL]                     if (argumentNode.isName()) { [EOL]                         String phName = argumentNode.getString(); [EOL]                         if (phNames.contains(phName)) { [EOL]                             throw new MalformedException("Duplicate placeholder name: " + phName, argumentNode); [EOL]                         } else { [EOL]                             phNames.add(phName); [EOL]                         } [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case Token.BLOCK: [EOL]                 Node returnNode = fnChild.getFirstChild(); [EOL]                 if (!returnNode.isReturn()) { [EOL]                     throw new MalformedException("RETURN node expected; found: " + getReadableTokenName(returnNode), returnNode); [EOL]                 } [EOL]                 for (Node child : returnNode.children()) { [EOL]                     extractFromReturnDescendant(builder, child); [EOL]                 } [EOL]                 for (String phName : builder.getPlaceholders()) { [EOL]                     if (!phNames.contains(phName)) { [EOL]                         throw new MalformedException("Unrecognized message placeholder referenced: " + phName, returnNode); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 throw new MalformedException("NAME, LP, or BLOCK node expected; found: " + getReadableTokenName(node), fnChild); [EOL]         } [EOL]     } [EOL] } <line_num>: 550,600
private void extractFromReturnDescendant(Builder builder, Node node) throws MalformedException { [EOL]     switch(node.getType()) { [EOL]         case Token.STRING: [EOL]             builder.appendStringPart(node.getString()); [EOL]             break; [EOL]         case Token.NAME: [EOL]             builder.appendPlaceholderReference(node.getString()); [EOL]             break; [EOL]         case Token.ADD: [EOL]             for (Node child : node.children()) { [EOL]                 extractFromReturnDescendant(builder, child); [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw new MalformedException("STRING, NAME, or ADD node expected; found: " + getReadableTokenName(node), node); [EOL]     } [EOL] } <line_num>: 610,630
private void extractFromCallNode(Builder builder, Node node) throws MalformedException { [EOL]     if (!node.isCall()) { [EOL]         throw new MalformedException("Message must be initialized using " + MSG_FUNCTION_NAME + " function.", node); [EOL]     } [EOL]     Node fnNameNode = node.getFirstChild(); [EOL]     if (!MSG_FUNCTION_NAME.equals(fnNameNode.getQualifiedName())) { [EOL]         throw new MalformedException("Message initialized using unrecognized function. " + "Please use " + MSG_FUNCTION_NAME + "() instead.", fnNameNode); [EOL]     } [EOL]     Node stringLiteralNode = fnNameNode.getNext(); [EOL]     if (stringLiteralNode == null) { [EOL]         throw new MalformedException("Message string literal expected", stringLiteralNode); [EOL]     } [EOL]     parseMessageTextNode(builder, stringLiteralNode); [EOL]     Node objLitNode = stringLiteralNode.getNext(); [EOL]     Set<String> phNames = Sets.newHashSet(); [EOL]     if (objLitNode != null) { [EOL]         if (!objLitNode.isObjectLit()) { [EOL]             throw new MalformedException("OBJLIT node expected", objLitNode); [EOL]         } [EOL]         for (Node aNode = objLitNode.getFirstChild(); aNode != null; aNode = aNode.getNext()) { [EOL]             if (!aNode.isStringKey()) { [EOL]                 throw new MalformedException("STRING_KEY node expected as OBJLIT key", aNode); [EOL]             } [EOL]             String phName = aNode.getString(); [EOL]             if (!isLowerCamelCaseWithNumericSuffixes(phName)) { [EOL]                 throw new MalformedException("Placeholder name not in lowerCamelCase: " + phName, aNode); [EOL]             } [EOL]             if (phNames.contains(phName)) { [EOL]                 throw new MalformedException("Duplicate placeholder name: " + phName, aNode); [EOL]             } [EOL]             phNames.add(phName); [EOL]         } [EOL]     } [EOL]     Set<String> usedPlaceholders = builder.getPlaceholders(); [EOL]     for (String phName : usedPlaceholders) { [EOL]         if (!phNames.contains(phName)) { [EOL]             throw new MalformedException("Unrecognized message placeholder referenced: " + phName, objLitNode); [EOL]         } [EOL]     } [EOL]     for (String phName : phNames) { [EOL]         if (!usedPlaceholders.contains(phName)) { [EOL]             throw new MalformedException("Unused message placeholder: " + phName, objLitNode); [EOL]         } [EOL]     } [EOL] } <line_num>: 656,729
private void parseMessageTextNode(Builder builder, Node node) throws MalformedException { [EOL]     String value = extractStringFromStringExprNode(node); [EOL]     while (true) { [EOL]         int phBegin = value.indexOf(PH_JS_PREFIX); [EOL]         if (phBegin < 0) { [EOL]             builder.appendStringPart(value); [EOL]             return; [EOL]         } else { [EOL]             if (phBegin > 0) { [EOL]                 builder.appendStringPart(value.substring(0, phBegin)); [EOL]             } [EOL]             int phEnd = value.indexOf(PH_JS_SUFFIX, phBegin); [EOL]             if (phEnd < 0) { [EOL]                 throw new MalformedException("Placeholder incorrectly formatted in: " + builder.getKey(), node); [EOL]             } [EOL]             String phName = value.substring(phBegin + PH_JS_PREFIX.length(), phEnd); [EOL]             builder.appendPlaceholderReference(phName); [EOL]             int nextPos = phEnd + PH_JS_SUFFIX.length(); [EOL]             if (nextPos < value.length()) { [EOL]                 value = value.substring(nextPos); [EOL]             } else { [EOL]                 return; [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 740,777
private void visitFallbackFunctionCall(NodeTraversal t, Node call) { [EOL]     if (call.getChildCount() != 3 || !call.getChildAtIndex(1).isName() || !call.getChildAtIndex(2).isName()) { [EOL]         compiler.report(t.makeError(call, BAD_FALLBACK_SYNTAX)); [EOL]         return; [EOL]     } [EOL]     Node firstArg = call.getChildAtIndex(1); [EOL]     JsMessage firstMessage = getTrackedMessage(t, firstArg.getString()); [EOL]     if (firstMessage == null) { [EOL]         compiler.report(t.makeError(firstArg, FALLBACK_ARG_ERROR, firstArg.getString())); [EOL]         return; [EOL]     } [EOL]     Node secondArg = firstArg.getNext(); [EOL]     JsMessage secondMessage = getTrackedMessage(t, call.getChildAtIndex(2).getString()); [EOL]     if (secondMessage == null) { [EOL]         compiler.report(t.makeError(secondArg, FALLBACK_ARG_ERROR, secondArg.getString())); [EOL]         return; [EOL]     } [EOL]     processMessageFallback(call, firstMessage, secondMessage); [EOL] } <line_num>: 780,808
abstract void processJsMessage(JsMessage message, JsMessageDefinition definition); <line_num>: 825,826
void processMessageFallback(Node callNode, JsMessage message1, JsMessage message2) { [EOL] } <line_num>: 834,835
boolean isMessageName(String identifier, boolean isNewStyleMessage) { [EOL]     return identifier.startsWith(MSG_PREFIX) && (style == JsMessage.Style.CLOSURE || isNewStyleMessage || !identifier.endsWith(DESC_SUFFIX)); [EOL] } <line_num>: 840,844
private static boolean isUnnamedMessageName(String identifier) { [EOL]     return MSG_UNNAMED_PATTERN.matcher(identifier).matches(); [EOL] } <line_num>: 849,851
static boolean isLowerCamelCaseWithNumericSuffixes(String input) { [EOL]     return CAMELCASE_PATTERN.matcher(input).matches(); [EOL] } <line_num>: 857,859
private static String getReadableTokenName(Node node) { [EOL]     return Token.name(node.getType()); [EOL] } <line_num>: 864,866
static String toLowerCamelCaseWithNumericSuffixes(String input) { [EOL]     int suffixStart = input.length(); [EOL]     while (suffixStart > 0) { [EOL]         char ch = '\0'; [EOL]         int numberStart = suffixStart; [EOL]         while (numberStart > 0) { [EOL]             ch = input.charAt(numberStart - 1); [EOL]             if (Character.isDigit(ch)) { [EOL]                 numberStart--; [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if ((numberStart > 0) && (numberStart < suffixStart) && (ch == '_')) { [EOL]             suffixStart = numberStart - 1; [EOL]         } else { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (suffixStart == input.length()) { [EOL]         return CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL, input); [EOL]     } else { [EOL]         return CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL, input.substring(0, suffixStart)) + input.substring(suffixStart); [EOL]     } [EOL] } <line_num>: 873,901
protected void checkNode(@Nullable Node node, int type) throws MalformedException { [EOL]     if (node == null) { [EOL]         throw new MalformedException("Expected node type " + type + "; found: null", node); [EOL]     } [EOL]     if (node.getType() != type) { [EOL]         throw new MalformedException("Expected node type " + type + "; found: " + node.getType(), node); [EOL]     } [EOL] } <line_num>: 908,917
Node getNode() { [EOL]     return node; [EOL] } <line_num>: 929,931
