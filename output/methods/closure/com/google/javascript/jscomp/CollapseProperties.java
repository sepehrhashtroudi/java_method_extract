CollapseProperties(AbstractCompiler compiler, boolean collapsePropertiesOnExternTypes, boolean inlineAliases) { [EOL]     this.compiler = compiler; [EOL]     this.collapsePropertiesOnExternTypes = collapsePropertiesOnExternTypes; [EOL]     this.inlineAliases = inlineAliases; [EOL] } <line_num>: 111,116
@Override [EOL] public void process(Node externs, Node root) { [EOL]     GlobalNamespace namespace; [EOL]     if (collapsePropertiesOnExternTypes) { [EOL]         namespace = new GlobalNamespace(compiler, externs, root); [EOL]     } else { [EOL]         namespace = new GlobalNamespace(compiler, root); [EOL]     } [EOL]     if (inlineAliases) { [EOL]         inlineAliases(namespace); [EOL]     } [EOL]     nameMap = namespace.getNameIndex(); [EOL]     globalNames = namespace.getNameForest(); [EOL]     checkNamespaces(); [EOL]     for (Name n : globalNames) { [EOL]         flattenReferencesToCollapsibleDescendantNames(n, n.getBaseName()); [EOL]     } [EOL]     for (Name n : globalNames) { [EOL]         collapseDeclarationOfNameAndDescendants(n, n.getBaseName()); [EOL]     } [EOL] } <line_num>: 118,144
private void inlineAliases(GlobalNamespace namespace) { [EOL]     Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest()); [EOL]     while (!workList.isEmpty()) { [EOL]         Name name = workList.pop(); [EOL]         if (name.type == Name.Type.GET || name.type == Name.Type.SET) { [EOL]             continue; [EOL]         } [EOL]         if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) { [EOL]             List<Ref> refs = Lists.newArrayList(name.getRefs()); [EOL]             for (Ref ref : refs) { [EOL]                 if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) { [EOL]                     if (inlineAliasIfPossible(ref, namespace)) { [EOL]                         name.removeRef(ref); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props != null) { [EOL]             workList.addAll(name.props); [EOL]         } [EOL]     } [EOL] } <line_num>: 161,197
private boolean inlineAliasIfPossible(Ref alias, GlobalNamespace namespace) { [EOL]     Node aliasParent = alias.node.getParent(); [EOL]     if (aliasParent.isName()) { [EOL]         Scope scope = alias.scope; [EOL]         Var aliasVar = scope.getVar(aliasParent.getString()); [EOL]         ReferenceCollectingCallback collector = new ReferenceCollectingCallback(compiler, ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR, Predicates.<Var>equalTo(aliasVar)); [EOL]         (new NodeTraversal(compiler, collector)).traverseAtScope(scope); [EOL]         ReferenceCollection aliasRefs = collector.getReferences(aliasVar); [EOL]         if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) { [EOL]             int size = aliasRefs.references.size(); [EOL]             Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1); [EOL]             for (int i = 1; i < size; i++) { [EOL]                 ReferenceCollectingCallback.Reference aliasRef = aliasRefs.references.get(i); [EOL]                 Node newNode = alias.node.cloneTree(); [EOL]                 aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode); [EOL]                 newNodes.add(newNode); [EOL]             } [EOL]             aliasParent.replaceChild(alias.node, IR.nullNode()); [EOL]             compiler.reportCodeChange(); [EOL]             namespace.scanNewNodes(alias.scope, newNodes); [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 199,243
private void checkNamespaces() { [EOL]     for (Name name : nameMap.values()) { [EOL]         if (name.isNamespace() && (name.aliasingGets > 0 || name.localSets + name.globalSets > 1 || name.deleteProps > 0)) { [EOL]             boolean initialized = name.getDeclaration() != null; [EOL]             for (Ref ref : name.getRefs()) { [EOL]                 if (ref == name.getDeclaration()) { [EOL]                     continue; [EOL]                 } [EOL]                 if (ref.type == Ref.Type.DELETE_PROP) { [EOL]                     if (initialized) { [EOL]                         warnAboutNamespaceRedefinition(name, ref); [EOL]                     } [EOL]                 } else if (ref.type == Ref.Type.SET_FROM_GLOBAL || ref.type == Ref.Type.SET_FROM_LOCAL) { [EOL]                     if (initialized) { [EOL]                         warnAboutNamespaceRedefinition(name, ref); [EOL]                     } [EOL]                     initialized = true; [EOL]                 } else if (ref.type == Ref.Type.ALIASING_GET) { [EOL]                     warnAboutNamespaceAliasing(name, ref); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 249,278
private void warnAboutNamespaceAliasing(Name nameObj, Ref ref) { [EOL]     compiler.report(JSError.make(ref.getSourceName(), ref.node, UNSAFE_NAMESPACE_WARNING, nameObj.getFullName())); [EOL] } <line_num>: 286,290
private void warnAboutNamespaceRedefinition(Name nameObj, Ref ref) { [EOL]     compiler.report(JSError.make(ref.getSourceName(), ref.node, NAMESPACE_REDEFINED_WARNING, nameObj.getFullName())); [EOL] } <line_num>: 298,302
private void flattenReferencesToCollapsibleDescendantNames(Name n, String alias) { [EOL]     if (n.props == null) [EOL]         return; [EOL]     for (Name p : n.props) { [EOL]         String propAlias = appendPropForAlias(alias, p.getBaseName()); [EOL]         if (p.canCollapse()) { [EOL]             flattenReferencesTo(p, propAlias); [EOL]         } else if (p.isSimpleStubDeclaration()) { [EOL]             flattenSimpleStubDeclaration(p, propAlias); [EOL]         } [EOL]         flattenReferencesToCollapsibleDescendantNames(p, propAlias); [EOL]     } [EOL] } <line_num>: 311,326
private void flattenSimpleStubDeclaration(Name name, String alias) { [EOL]     Ref ref = Iterables.getOnlyElement(name.getRefs()); [EOL]     Node nameNode = NodeUtil.newName(compiler.getCodingConvention(), alias, ref.node, name.getFullName()); [EOL]     Node varNode = IR.var(nameNode).copyInformationFrom(nameNode); [EOL]     Preconditions.checkState(ref.node.getParent().isExprResult()); [EOL]     Node parent = ref.node.getParent(); [EOL]     Node gramps = parent.getParent(); [EOL]     gramps.replaceChild(parent, varNode); [EOL]     compiler.reportCodeChange(); [EOL] } <line_num>: 333,346
private void flattenReferencesTo(Name n, String alias) { [EOL]     String originalName = n.getFullName(); [EOL]     for (Ref r : n.getRefs()) { [EOL]         if (r == n.getDeclaration()) { [EOL]             continue; [EOL]         } [EOL]         Node rParent = r.node.getParent(); [EOL]         if (!NodeUtil.isObjectLitKey(r.node, rParent) && (r.getTwin() == null || r.isSet())) { [EOL]             flattenNameRef(alias, r.node, rParent, originalName); [EOL]         } [EOL]     } [EOL]     if (n.props != null) { [EOL]         for (Name p : n.props) { [EOL]             flattenPrefixes(alias, p, 1); [EOL]         } [EOL]     } [EOL] } <line_num>: 356,385
private void flattenPrefixes(String alias, Name n, int depth) { [EOL]     String originalName = n.getFullName(); [EOL]     Ref decl = n.getDeclaration(); [EOL]     if (decl != null && decl.node != null && decl.node.isGetProp()) { [EOL]         flattenNameRefAtDepth(alias, decl.node, depth, originalName); [EOL]     } [EOL]     for (Ref r : n.getRefs()) { [EOL]         if (r == decl) { [EOL]             continue; [EOL]         } [EOL]         if (r.getTwin() == null || r.isSet()) { [EOL]             flattenNameRefAtDepth(alias, r.node, depth, originalName); [EOL]         } [EOL]     } [EOL]     if (n.props != null) { [EOL]         for (Name p : n.props) { [EOL]             flattenPrefixes(alias, p, depth + 1); [EOL]         } [EOL]     } [EOL] } <line_num>: 396,424
private void flattenNameRefAtDepth(String alias, Node n, int depth, String originalName) { [EOL]     int nType = n.getType(); [EOL]     boolean isQName = nType == Token.NAME || nType == Token.GETPROP; [EOL]     boolean isObjKey = NodeUtil.isObjectLitKey(n, n.getParent()); [EOL]     Preconditions.checkState(isObjKey || isQName); [EOL]     if (isQName) { [EOL]         for (int i = 1; i < depth && n.hasChildren(); i++) { [EOL]             n = n.getFirstChild(); [EOL]         } [EOL]         if (n.hasChildren()) { [EOL]             flattenNameRef(alias, n.getFirstChild(), n, originalName); [EOL]         } [EOL]     } [EOL] } <line_num>: 435,452
private void flattenNameRef(String alias, Node n, Node parent, String originalName) { [EOL]     Node ref = NodeUtil.newName(compiler.getCodingConvention(), alias, n, originalName); [EOL]     NodeUtil.copyNameAnnotations(n.getLastChild(), ref); [EOL]     if (parent.isCall() && n == parent.getFirstChild()) { [EOL]         parent.putBooleanProp(Node.FREE_CALL, true); [EOL]     } [EOL]     JSType type = n.getJSType(); [EOL]     if (type != null) { [EOL]         ref.setJSType(type); [EOL]     } [EOL]     parent.replaceChild(n, ref); [EOL]     compiler.reportCodeChange(); [EOL] } <line_num>: 462,487
private void collapseDeclarationOfNameAndDescendants(Name n, String alias) { [EOL]     boolean canCollapseChildNames = n.canCollapseUnannotatedChildNames(); [EOL]     if (n.canCollapse()) { [EOL]         updateObjLitOrFunctionDeclaration(n, alias, canCollapseChildNames); [EOL]     } [EOL]     if (n.props != null) { [EOL]         for (Name p : n.props) { [EOL]             collapseDeclarationOfNameAndDescendants(p, appendPropForAlias(alias, p.getBaseName())); [EOL]             if (!p.inExterns && canCollapseChildNames && p.getDeclaration() != null && p.canCollapse() && p.getDeclaration().node != null && p.getDeclaration().node.getParent() != null && p.getDeclaration().node.getParent().isAssign()) { [EOL]                 updateSimpleDeclaration(appendPropForAlias(alias, p.getBaseName()), p, p.getDeclaration()); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 497,522
private void updateSimpleDeclaration(String alias, Name refName, Ref ref) { [EOL]     Node rvalue = ref.node.getNext(); [EOL]     Node parent = ref.node.getParent(); [EOL]     Node gramps = parent.getParent(); [EOL]     Node greatGramps = gramps.getParent(); [EOL]     Node greatGreatGramps = greatGramps.getParent(); [EOL]     if (rvalue != null && rvalue.isFunction()) { [EOL]         checkForHosedThisReferences(rvalue, refName.docInfo, refName); [EOL]     } [EOL]     Node nameNode = NodeUtil.newName(compiler.getCodingConvention(), alias, gramps.getFirstChild(), refName.getFullName()); [EOL]     NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode); [EOL]     if (gramps.isExprResult()) { [EOL]         parent.removeChild(rvalue); [EOL]         nameNode.addChildToFront(rvalue); [EOL]         Node varNode = IR.var(nameNode); [EOL]         greatGramps.replaceChild(gramps, varNode); [EOL]     } else { [EOL]         Preconditions.checkNotNull(ref.getTwin()); [EOL]         Node current = gramps; [EOL]         Node currentParent = gramps.getParent(); [EOL]         for (; !currentParent.isScript() && !currentParent.isBlock(); current = currentParent, currentParent = currentParent.getParent()) { [EOL]         } [EOL]         Node stubVar = IR.var(nameNode.cloneTree()).copyInformationFrom(nameNode); [EOL]         currentParent.addChildBefore(stubVar, current); [EOL]         parent.replaceChild(ref.node, nameNode); [EOL]     } [EOL]     compiler.reportCodeChange(); [EOL] } <line_num>: 535,601
private void updateObjLitOrFunctionDeclaration(Name n, String alias, boolean canCollapseChildNames) { [EOL]     Ref decl = n.getDeclaration(); [EOL]     if (decl == null) { [EOL]         return; [EOL]     } [EOL]     if (decl.getTwin() != null) { [EOL]         return; [EOL]     } [EOL]     switch(decl.node.getParent().getType()) { [EOL]         case Token.ASSIGN: [EOL]             updateObjLitOrFunctionDeclarationAtAssignNode(n, alias, canCollapseChildNames); [EOL]             break; [EOL]         case Token.VAR: [EOL]             updateObjLitOrFunctionDeclarationAtVarNode(n, canCollapseChildNames); [EOL]             break; [EOL]         case Token.FUNCTION: [EOL]             updateFunctionDeclarationAtFunctionNode(n, canCollapseChildNames); [EOL]             break; [EOL]     } [EOL] } <line_num>: 622,649
private void updateObjLitOrFunctionDeclarationAtAssignNode(Name n, String alias, boolean canCollapseChildNames) { [EOL]     Ref ref = n.getDeclaration(); [EOL]     Node rvalue = ref.node.getNext(); [EOL]     Node varNode = new Node(Token.VAR); [EOL]     Node varParent = ref.node.getAncestor(3); [EOL]     Node gramps = ref.node.getAncestor(2); [EOL]     boolean isObjLit = rvalue.isObjectLit(); [EOL]     boolean insertedVarNode = false; [EOL]     if (isObjLit && n.canEliminate()) { [EOL]         varParent.replaceChild(gramps, varNode); [EOL]         ref.node = null; [EOL]         insertedVarNode = true; [EOL]     } else if (!n.isSimpleName()) { [EOL]         if (rvalue.isFunction()) { [EOL]             checkForHosedThisReferences(rvalue, n.docInfo, n); [EOL]         } [EOL]         ref.node.getParent().removeChild(rvalue); [EOL]         Node nameNode = NodeUtil.newName(compiler.getCodingConvention(), alias, ref.node.getAncestor(2), n.getFullName()); [EOL]         JSDocInfo info = ref.node.getParent().getJSDocInfo(); [EOL]         if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME) || (info != null && info.isConstant())) { [EOL]             nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); [EOL]         } [EOL]         if (info != null) { [EOL]             varNode.setJSDocInfo(info); [EOL]         } [EOL]         varNode.addChildToBack(nameNode); [EOL]         nameNode.addChildToFront(rvalue); [EOL]         varParent.replaceChild(gramps, varNode); [EOL]         ref.node = nameNode; [EOL]         insertedVarNode = true; [EOL]     } [EOL]     if (canCollapseChildNames) { [EOL]         if (isObjLit) { [EOL]             declareVarsForObjLitValues(n, alias, rvalue, varNode, varParent.getChildBefore(varNode), varParent); [EOL]         } [EOL]         addStubsForUndeclaredProperties(n, alias, varParent, varNode); [EOL]     } [EOL]     if (insertedVarNode) { [EOL]         if (!varNode.hasChildren()) { [EOL]             varParent.removeChild(varNode); [EOL]         } [EOL]         compiler.reportCodeChange(); [EOL]     } [EOL] } <line_num>: 659,725
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (n.isThis()) { [EOL]         compiler.report(JSError.make(name.getDeclaration().getSourceName(), n, UNSAFE_THIS, name.getFullName())); [EOL]     } [EOL] } <line_num>: 739,746
private void checkForHosedThisReferences(Node function, JSDocInfo docInfo, final Name name) { [EOL]     if (docInfo == null || (!docInfo.isConstructor() && !docInfo.hasThisType())) { [EOL]         NodeTraversal.traverse(compiler, function.getLastChild(), new NodeTraversal.AbstractShallowCallback() { [EOL]  [EOL]             @Override [EOL]             public void visit(NodeTraversal t, Node n, Node parent) { [EOL]                 if (n.isThis()) { [EOL]                     compiler.report(JSError.make(name.getDeclaration().getSourceName(), n, UNSAFE_THIS, name.getFullName())); [EOL]                 } [EOL]             } [EOL]         }); [EOL]     } [EOL] } <line_num>: 731,749
private void updateObjLitOrFunctionDeclarationAtVarNode(Name n, boolean canCollapseChildNames) { [EOL]     if (!canCollapseChildNames) { [EOL]         return; [EOL]     } [EOL]     Ref ref = n.getDeclaration(); [EOL]     String name = ref.node.getString(); [EOL]     Node rvalue = ref.node.getFirstChild(); [EOL]     Node varNode = ref.node.getParent(); [EOL]     Node gramps = varNode.getParent(); [EOL]     boolean isObjLit = rvalue.isObjectLit(); [EOL]     int numChanges = 0; [EOL]     if (isObjLit) { [EOL]         numChanges += declareVarsForObjLitValues(n, name, rvalue, varNode, gramps.getChildBefore(varNode), gramps); [EOL]     } [EOL]     numChanges += addStubsForUndeclaredProperties(n, name, gramps, varNode); [EOL]     if (isObjLit && n.canEliminate()) { [EOL]         varNode.removeChild(ref.node); [EOL]         if (!varNode.hasChildren()) { [EOL]             gramps.removeChild(varNode); [EOL]         } [EOL]         numChanges++; [EOL]         ref.node = null; [EOL]     } [EOL]     if (numChanges > 0) { [EOL]         compiler.reportCodeChange(); [EOL]     } [EOL] } <line_num>: 758,796
private void updateFunctionDeclarationAtFunctionNode(Name n, boolean canCollapseChildNames) { [EOL]     if (!canCollapseChildNames) { [EOL]         return; [EOL]     } [EOL]     Ref ref = n.getDeclaration(); [EOL]     String fnName = ref.node.getString(); [EOL]     addStubsForUndeclaredProperties(n, fnName, ref.node.getAncestor(2), ref.node.getParent()); [EOL] } <line_num>: 805,815
private int declareVarsForObjLitValues(Name objlitName, String alias, Node objlit, Node varNode, Node nameToAddAfter, Node varParent) { [EOL]     int numVars = 0; [EOL]     int arbitraryNameCounter = 0; [EOL]     boolean discardKeys = !objlitName.shouldKeepKeys(); [EOL]     for (Node key = objlit.getFirstChild(), nextKey; key != null; key = nextKey) { [EOL]         Node value = key.getFirstChild(); [EOL]         nextKey = key.getNext(); [EOL]         if (key.isGetterDef() || key.isSetterDef()) { [EOL]             continue; [EOL]         } [EOL]         boolean isJsIdentifier = !key.isNumber() && TokenStream.isJSIdentifier(key.getString()); [EOL]         String propName = isJsIdentifier ? key.getString() : String.valueOf(++arbitraryNameCounter); [EOL]         String qName = objlitName.getFullName() + '.' + propName; [EOL]         Name p = nameMap.get(qName); [EOL]         if (p != null && !p.canCollapse()) { [EOL]             continue; [EOL]         } [EOL]         String propAlias = appendPropForAlias(alias, propName); [EOL]         Node refNode = null; [EOL]         if (discardKeys) { [EOL]             objlit.removeChild(key); [EOL]             value.detachFromParent(); [EOL]         } else { [EOL]             refNode = IR.name(propAlias); [EOL]             if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) { [EOL]                 refNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); [EOL]             } [EOL]             key.replaceChild(value, refNode); [EOL]         } [EOL]         Node nameNode = IR.name(propAlias); [EOL]         nameNode.addChildToFront(value); [EOL]         if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) { [EOL]             nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); [EOL]         } [EOL]         Node newVar = IR.var(nameNode).copyInformationFromForTree(key); [EOL]         if (nameToAddAfter != null) { [EOL]             varParent.addChildAfter(newVar, nameToAddAfter); [EOL]         } else { [EOL]             varParent.addChildBefore(newVar, varNode); [EOL]         } [EOL]         compiler.reportCodeChange(); [EOL]         nameToAddAfter = newVar; [EOL]         if (isJsIdentifier && p != null) { [EOL]             if (!discardKeys) { [EOL]                 Ref newAlias = p.getDeclaration().cloneAndReclassify(Ref.Type.ALIASING_GET); [EOL]                 newAlias.node = refNode; [EOL]                 p.addRef(newAlias); [EOL]             } [EOL]             p.getDeclaration().node = nameNode; [EOL]             if (value.isFunction()) { [EOL]                 checkForHosedThisReferences(value, value.getJSDocInfo(), p); [EOL]             } [EOL]         } [EOL]         numVars++; [EOL]     } [EOL]     return numVars; [EOL] } <line_num>: 830,916
private int addStubsForUndeclaredProperties(Name n, String alias, Node parent, Node addAfter) { [EOL]     Preconditions.checkState(n.canCollapseUnannotatedChildNames()); [EOL]     Preconditions.checkArgument(NodeUtil.isStatementBlock(parent)); [EOL]     Preconditions.checkNotNull(addAfter); [EOL]     int numStubs = 0; [EOL]     if (n.props != null) { [EOL]         for (Name p : n.props) { [EOL]             if (p.needsToBeStubbed()) { [EOL]                 String propAlias = appendPropForAlias(alias, p.getBaseName()); [EOL]                 Node nameNode = IR.name(propAlias); [EOL]                 Node newVar = IR.var(nameNode).copyInformationFromForTree(addAfter); [EOL]                 parent.addChildAfter(newVar, addAfter); [EOL]                 addAfter = newVar; [EOL]                 numStubs++; [EOL]                 compiler.reportCodeChange(); [EOL]                 if (p.getRefs().get(0).node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) { [EOL]                     nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return numStubs; [EOL] } <line_num>: 931,959
private static String appendPropForAlias(String root, String prop) { [EOL]     if (prop.indexOf('$') != -1) { [EOL]         prop = prop.replace("$", "$0"); [EOL]     } [EOL]     return root + '$' + prop; [EOL] } <line_num>: 961,969
