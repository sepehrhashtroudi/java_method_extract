GlobalNamespace(AbstractCompiler compiler, Node root) { [EOL]     this(compiler, null, root); [EOL] } <line_num>: 81,83
GlobalNamespace(AbstractCompiler compiler, Node externsRoot, Node root) { [EOL]     this.compiler = compiler; [EOL]     this.externsRoot = externsRoot; [EOL]     this.root = root; [EOL] } <line_num>: 96,100
NodeFilter(Set<Node> newNodes) { [EOL]     this.newNodes = newNodes; [EOL] } <line_num>: 192,194
BuildGlobalNamespace() { [EOL]     this(null); [EOL] } <line_num>: 288,290
BuildGlobalNamespace(Predicate<Node> nodeFilter) { [EOL]     this.nodeFilter = nodeFilter; [EOL] } <line_num>: 296,298
Name(String name, Name parent, boolean inExterns) { [EOL]     this.baseName = name; [EOL]     this.parent = parent; [EOL]     this.type = Type.OTHER; [EOL]     this.inExterns = inExterns; [EOL] } <line_num>: 887,892
Ref(NodeTraversal t, Node node, Name name, Type type, int index) { [EOL]     this.node = node; [EOL]     this.name = name; [EOL]     this.module = t.getInput() == null ? null : t.getInput().getModule(); [EOL]     this.source = node.getStaticSourceFile(); [EOL]     this.type = type; [EOL]     this.scope = t.getScope(); [EOL]     this.preOrderIndex = index; [EOL] } <line_num>: 1196,1204
private Ref(Ref original, Type type, int index) { [EOL]     this.node = original.node; [EOL]     this.name = original.name; [EOL]     this.module = original.module; [EOL]     this.source = original.source; [EOL]     this.type = type; [EOL]     this.scope = original.scope; [EOL]     this.preOrderIndex = index; [EOL] } <line_num>: 1206,1214
private Ref(Type type, int index) { [EOL]     this.type = type; [EOL]     this.module = null; [EOL]     this.source = null; [EOL]     this.scope = null; [EOL]     this.name = null; [EOL]     this.preOrderIndex = index; [EOL] } <line_num>: 1216,1223
Tracker(AbstractCompiler compiler, PrintStream stream, Predicate<String> isInterestingSymbol) { [EOL]     this.compiler = compiler; [EOL]     this.stream = stream; [EOL]     this.isInterestingSymbol = isInterestingSymbol; [EOL] } <line_num>: 1298,1303
boolean hasExternsRoot() { [EOL]     return externsRoot != null; [EOL] } <line_num>: 102,104
@Override [EOL] public Node getRootNode() { [EOL]     return root.getParent(); [EOL] } <line_num>: 106,109
@Override [EOL] public StaticScope<JSType> getParentScope() { [EOL]     return null; [EOL] } <line_num>: 111,114
@Override [EOL] public Name getSlot(String name) { [EOL]     return getOwnSlot(name); [EOL] } <line_num>: 116,119
@Override [EOL] public Name getOwnSlot(String name) { [EOL]     ensureGenerated(); [EOL]     return nameMap.get(name); [EOL] } <line_num>: 121,125
@Override [EOL] public JSType getTypeOfThis() { [EOL]     return compiler.getTypeRegistry().getNativeObjectType(GLOBAL_THIS); [EOL] } <line_num>: 127,130
@Override [EOL] public Iterable<Ref> getReferences(Name slot) { [EOL]     ensureGenerated(); [EOL]     return Collections.unmodifiableList(slot.getRefs()); [EOL] } <line_num>: 132,136
@Override [EOL] public StaticScope<JSType> getScope(Name slot) { [EOL]     return this; [EOL] } <line_num>: 138,141
@Override [EOL] public Iterable<Name> getAllSymbols() { [EOL]     ensureGenerated(); [EOL]     return Collections.unmodifiableCollection(getNameIndex().values()); [EOL] } <line_num>: 143,147
private void ensureGenerated() { [EOL]     if (!generated) { [EOL]         process(); [EOL]     } [EOL] } <line_num>: 149,153
List<Name> getNameForest() { [EOL]     ensureGenerated(); [EOL]     return globalNames; [EOL] } <line_num>: 159,162
Map<String, Name> getNameIndex() { [EOL]     ensureGenerated(); [EOL]     return nameMap; [EOL] } <line_num>: 168,171
void scanNewNodes(Scope scope, Set<Node> newNodes) { [EOL]     NodeTraversal t = new NodeTraversal(compiler, new BuildGlobalNamespace(new NodeFilter(newNodes))); [EOL]     t.traverseAtScope(scope); [EOL] } <line_num>: 179,183
@Override [EOL] public boolean apply(Node n) { [EOL]     if (!n.isQualifiedName()) { [EOL]         return false; [EOL]     } [EOL]     Node current; [EOL]     for (current = n; current.isGetProp(); current = current.getFirstChild()) { [EOL]         if (newNodes.contains(current)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return current.isName() && newNodes.contains(current); [EOL] } <line_num>: 196,212
private void process() { [EOL]     if (externsRoot != null) { [EOL]         inExterns = true; [EOL]         NodeTraversal.traverse(compiler, externsRoot, new BuildGlobalNamespace()); [EOL]     } [EOL]     inExterns = false; [EOL]     NodeTraversal.traverse(compiler, root, new BuildGlobalNamespace()); [EOL]     generated = true; [EOL] } <line_num>: 218,227
private boolean isGlobalNameReference(String name, Scope s) { [EOL]     String topVarName = getTopVarName(name); [EOL]     return isGlobalVarReference(topVarName, s); [EOL] } <line_num>: 237,240
private String getTopVarName(String name) { [EOL]     int firstDotIndex = name.indexOf('.'); [EOL]     return firstDotIndex == -1 ? name : name.substring(0, firstDotIndex); [EOL] } <line_num>: 248,251
private boolean isGlobalVarReference(String name, Scope s) { [EOL]     Scope.Var v = s.getVar(name); [EOL]     if (v == null && externsScope != null) { [EOL]         v = externsScope.getVar(name); [EOL]     } [EOL]     return v != null && !v.isLocal(); [EOL] } <line_num>: 261,267
private boolean isGlobalScope(Scope s) { [EOL]     return s.getParent() == null; [EOL] } <line_num>: 275,277
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL] } <line_num>: 300,301
@Override [EOL] public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { [EOL]     collect(t, n, parent); [EOL]     return true; [EOL] } <line_num>: 304,308
public void collect(NodeTraversal t, Node n, Node parent) { [EOL]     if (nodeFilter != null && !nodeFilter.apply(n)) { [EOL]         return; [EOL]     } [EOL]     if (externsRoot != null && n == externsRoot) { [EOL]         externsScope = t.getScope(); [EOL]     } [EOL]     String name; [EOL]     boolean isSet = false; [EOL]     Name.Type type = Name.Type.OTHER; [EOL]     boolean isPropAssign = false; [EOL]     switch(n.getType()) { [EOL]         case Token.GETTER_DEF: [EOL]         case Token.SETTER_DEF: [EOL]         case Token.STRING_KEY: [EOL]             name = null; [EOL]             if (parent != null && parent.isObjectLit()) { [EOL]                 name = getNameForObjLitKey(n); [EOL]             } [EOL]             if (name == null) [EOL]                 return; [EOL]             isSet = true; [EOL]             switch(n.getType()) { [EOL]                 case Token.STRING_KEY: [EOL]                     type = getValueType(n.getFirstChild()); [EOL]                     break; [EOL]                 case Token.GETTER_DEF: [EOL]                     type = Name.Type.GET; [EOL]                     break; [EOL]                 case Token.SETTER_DEF: [EOL]                     type = Name.Type.SET; [EOL]                     break; [EOL]                 default: [EOL]                     throw new IllegalStateException("unexpected:" + n); [EOL]             } [EOL]             break; [EOL]         case Token.NAME: [EOL]             if (parent != null) { [EOL]                 switch(parent.getType()) { [EOL]                     case Token.VAR: [EOL]                         isSet = true; [EOL]                         Node rvalue = n.getFirstChild(); [EOL]                         type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue); [EOL]                         break; [EOL]                     case Token.ASSIGN: [EOL]                         if (parent.getFirstChild() == n) { [EOL]                             isSet = true; [EOL]                             type = getValueType(n.getNext()); [EOL]                         } [EOL]                         break; [EOL]                     case Token.GETPROP: [EOL]                         return; [EOL]                     case Token.FUNCTION: [EOL]                         Node gramps = parent.getParent(); [EOL]                         if (gramps == null || NodeUtil.isFunctionExpression(parent)) [EOL]                             return; [EOL]                         isSet = true; [EOL]                         type = Name.Type.FUNCTION; [EOL]                         break; [EOL]                     case Token.INC: [EOL]                     case Token.DEC: [EOL]                         isSet = true; [EOL]                         type = Name.Type.OTHER; [EOL]                         break; [EOL]                     default: [EOL]                         if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) { [EOL]                             isSet = true; [EOL]                             type = Name.Type.OTHER; [EOL]                         } [EOL]                 } [EOL]             } [EOL]             name = n.getString(); [EOL]             break; [EOL]         case Token.GETPROP: [EOL]             if (parent != null) { [EOL]                 switch(parent.getType()) { [EOL]                     case Token.ASSIGN: [EOL]                         if (parent.getFirstChild() == n) { [EOL]                             isSet = true; [EOL]                             type = getValueType(n.getNext()); [EOL]                             isPropAssign = true; [EOL]                         } [EOL]                         break; [EOL]                     case Token.INC: [EOL]                     case Token.DEC: [EOL]                         isSet = true; [EOL]                         type = Name.Type.OTHER; [EOL]                         break; [EOL]                     case Token.GETPROP: [EOL]                         return; [EOL]                     default: [EOL]                         if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) { [EOL]                             isSet = true; [EOL]                             type = Name.Type.OTHER; [EOL]                         } [EOL]                 } [EOL]             } [EOL]             name = n.getQualifiedName(); [EOL]             if (name == null) [EOL]                 return; [EOL]             break; [EOL]         default: [EOL]             return; [EOL]     } [EOL]     Scope scope = t.getScope(); [EOL]     if (!isGlobalNameReference(name, scope)) { [EOL]         return; [EOL]     } [EOL]     if (isSet) { [EOL]         if (isGlobalScope(scope)) { [EOL]             handleSetFromGlobal(t, n, parent, name, isPropAssign, type); [EOL]         } else { [EOL]             handleSetFromLocal(t, n, parent, name); [EOL]         } [EOL]     } else { [EOL]         handleGet(t, n, parent, name); [EOL]     } [EOL] } <line_num>: 310,438
String getNameForObjLitKey(Node n) { [EOL]     Node parent = n.getParent(); [EOL]     Preconditions.checkState(parent.isObjectLit()); [EOL]     Node gramps = parent.getParent(); [EOL]     if (gramps == null) { [EOL]         return null; [EOL]     } [EOL]     Node greatGramps = gramps.getParent(); [EOL]     String name; [EOL]     switch(gramps.getType()) { [EOL]         case Token.NAME: [EOL]             if (greatGramps == null || !greatGramps.isVar()) { [EOL]                 return null; [EOL]             } [EOL]             name = gramps.getString(); [EOL]             break; [EOL]         case Token.ASSIGN: [EOL]             Node lvalue = gramps.getFirstChild(); [EOL]             name = lvalue.getQualifiedName(); [EOL]             break; [EOL]         case Token.STRING_KEY: [EOL]             if (greatGramps != null && greatGramps.isObjectLit()) { [EOL]                 name = getNameForObjLitKey(gramps); [EOL]             } else { [EOL]                 return null; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             return null; [EOL]     } [EOL]     if (name != null) { [EOL]         String key = n.getString(); [EOL]         if (TokenStream.isJSIdentifier(key)) { [EOL]             return name + '.' + key; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 456,508
Name.Type getValueType(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.OBJECTLIT: [EOL]             return Name.Type.OBJECTLIT; [EOL]         case Token.FUNCTION: [EOL]             return Name.Type.FUNCTION; [EOL]         case Token.OR: [EOL]             return getValueType(n.getLastChild()); [EOL]         case Token.HOOK: [EOL]             Node second = n.getFirstChild().getNext(); [EOL]             Name.Type t = getValueType(second); [EOL]             if (t != Name.Type.OTHER) [EOL]                 return t; [EOL]             Node third = second.getNext(); [EOL]             return getValueType(third); [EOL]     } [EOL]     return Name.Type.OTHER; [EOL] } <line_num>: 516,538
void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name, boolean isPropAssign, Name.Type type) { [EOL]     if (maybeHandlePrototypePrefix(t, n, parent, name)) [EOL]         return; [EOL]     Name nameObj = getOrCreateName(name); [EOL]     nameObj.type = type; [EOL]     Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL, currentPreOrderIndex++); [EOL]     nameObj.addRef(set); [EOL]     if (isNestedAssign(parent)) { [EOL]         Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET, currentPreOrderIndex++); [EOL]         nameObj.addRef(get); [EOL]         Ref.markTwins(set, get); [EOL]     } else if (isTypeDeclaration(n, parent)) { [EOL]         nameObj.setDeclaredType(); [EOL]     } [EOL] } <line_num>: 552,573
private boolean isTypeDeclaration(Node n, Node parent) { [EOL]     Node valueNode = NodeUtil.getRValueOfLValue(n); [EOL]     JSDocInfo info = NodeUtil.getBestJSDocInfo(n); [EOL]     return info != null && valueNode != null && (info.isConstructor() && valueNode.isFunction() || info.isInterface() && valueNode.isFunction() || info.hasEnumParameterType() && valueNode.isObjectLit()); [EOL] } <line_num>: 585,593
void handleSetFromLocal(NodeTraversal t, Node n, Node parent, String name) { [EOL]     if (maybeHandlePrototypePrefix(t, n, parent, name)) [EOL]         return; [EOL]     Name nameObj = getOrCreateName(name); [EOL]     Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_LOCAL, currentPreOrderIndex++); [EOL]     nameObj.addRef(set); [EOL]     if (isNestedAssign(parent)) { [EOL]         Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET, currentPreOrderIndex++); [EOL]         nameObj.addRef(get); [EOL]         Ref.markTwins(set, get); [EOL]     } [EOL] } <line_num>: 604,620
void handleGet(NodeTraversal t, Node n, Node parent, String name) { [EOL]     if (maybeHandlePrototypePrefix(t, n, parent, name)) [EOL]         return; [EOL]     Ref.Type type = Ref.Type.DIRECT_GET; [EOL]     if (parent != null) { [EOL]         switch(parent.getType()) { [EOL]             case Token.IF: [EOL]             case Token.TYPEOF: [EOL]             case Token.VOID: [EOL]             case Token.NOT: [EOL]             case Token.BITNOT: [EOL]             case Token.POS: [EOL]             case Token.NEG: [EOL]                 break; [EOL]             case Token.CALL: [EOL]                 type = n == parent.getFirstChild() ? Ref.Type.CALL_GET : Ref.Type.ALIASING_GET; [EOL]                 break; [EOL]             case Token.NEW: [EOL]                 type = n == parent.getFirstChild() ? Ref.Type.DIRECT_GET : Ref.Type.ALIASING_GET; [EOL]                 break; [EOL]             case Token.OR: [EOL]             case Token.AND: [EOL]                 type = determineGetTypeForHookOrBooleanExpr(t, parent, name); [EOL]                 break; [EOL]             case Token.HOOK: [EOL]                 if (n != parent.getFirstChild()) { [EOL]                     type = determineGetTypeForHookOrBooleanExpr(t, parent, name); [EOL]                 } [EOL]                 break; [EOL]             case Token.DELPROP: [EOL]                 type = Ref.Type.DELETE_PROP; [EOL]                 break; [EOL]             default: [EOL]                 type = Ref.Type.ALIASING_GET; [EOL]                 break; [EOL]         } [EOL]     } [EOL]     handleGet(t, n, parent, name, type); [EOL] } <line_num>: 631,681
Ref.Type determineGetTypeForHookOrBooleanExpr(NodeTraversal t, Node parent, String name) { [EOL]     Node prev = parent; [EOL]     for (Node anc : parent.getAncestors()) { [EOL]         switch(anc.getType()) { [EOL]             case Token.EXPR_RESULT: [EOL]             case Token.VAR: [EOL]             case Token.IF: [EOL]             case Token.WHILE: [EOL]             case Token.FOR: [EOL]             case Token.TYPEOF: [EOL]             case Token.VOID: [EOL]             case Token.NOT: [EOL]             case Token.BITNOT: [EOL]             case Token.POS: [EOL]             case Token.NEG: [EOL]                 return Ref.Type.DIRECT_GET; [EOL]             case Token.HOOK: [EOL]                 if (anc.getFirstChild() == prev) { [EOL]                     return Ref.Type.DIRECT_GET; [EOL]                 } [EOL]                 break; [EOL]             case Token.ASSIGN: [EOL]                 if (!name.equals(anc.getFirstChild().getQualifiedName())) { [EOL]                     return Ref.Type.ALIASING_GET; [EOL]                 } [EOL]                 break; [EOL]             case Token.NAME: [EOL]                 if (!name.equals(anc.getString())) { [EOL]                     return Ref.Type.ALIASING_GET; [EOL]                 } [EOL]                 break; [EOL]             case Token.CALL: [EOL]                 if (anc.getFirstChild() != prev) { [EOL]                     return Ref.Type.ALIASING_GET; [EOL]                 } [EOL]                 break; [EOL]             case Token.DELPROP: [EOL]                 return Ref.Type.DELETE_PROP; [EOL]         } [EOL]         prev = anc; [EOL]     } [EOL]     return Ref.Type.ALIASING_GET; [EOL] } <line_num>: 695,738
void handleGet(NodeTraversal t, Node n, Node parent, String name, Ref.Type type) { [EOL]     Name nameObj = getOrCreateName(name); [EOL]     nameObj.addRef(new Ref(t, n, nameObj, type, currentPreOrderIndex++)); [EOL] } <line_num>: 750,756
boolean maybeHandlePrototypePrefix(NodeTraversal t, Node n, Node parent, String name) { [EOL]     int numLevelsToRemove; [EOL]     String prefix; [EOL]     if (name.endsWith(".prototype")) { [EOL]         numLevelsToRemove = 1; [EOL]         prefix = name.substring(0, name.length() - 10); [EOL]     } else { [EOL]         int i = name.indexOf(".prototype."); [EOL]         if (i == -1) { [EOL]             return false; [EOL]         } [EOL]         prefix = name.substring(0, i); [EOL]         numLevelsToRemove = 2; [EOL]         i = name.indexOf('.', i + 11); [EOL]         while (i >= 0) { [EOL]             numLevelsToRemove++; [EOL]             i = name.indexOf('.', i + 1); [EOL]         } [EOL]     } [EOL]     if (parent != null && NodeUtil.isObjectLitKey(n, parent)) { [EOL]         return true; [EOL]     } [EOL]     for (int i = 0; i < numLevelsToRemove; i++) { [EOL]         parent = n; [EOL]         n = n.getFirstChild(); [EOL]     } [EOL]     handleGet(t, n, parent, prefix, Ref.Type.PROTOTYPE_GET); [EOL]     return true; [EOL] } <line_num>: 769,807
boolean isNestedAssign(Node parent) { [EOL]     return parent.isAssign() && !parent.getParent().isExprResult(); [EOL] } <line_num>: 817,820
Name getOrCreateName(String name) { [EOL]     Name node = nameMap.get(name); [EOL]     if (node == null) { [EOL]         int i = name.lastIndexOf('.'); [EOL]         if (i >= 0) { [EOL]             String parentName = name.substring(0, i); [EOL]             Name parent = getOrCreateName(parentName); [EOL]             node = parent.addProperty(name.substring(i + 1), inExterns); [EOL]         } else { [EOL]             node = new Name(name, null, inExterns); [EOL]             globalNames.add(node); [EOL]         } [EOL]         nameMap.put(name, node); [EOL]     } [EOL]     return node; [EOL] } <line_num>: 829,844
Name addProperty(String name, boolean inExterns) { [EOL]     if (props == null) { [EOL]         props = new ArrayList<Name>(); [EOL]     } [EOL]     Name node = new Name(name, this, inExterns); [EOL]     props.add(node); [EOL]     return node; [EOL] } <line_num>: 894,901
String getBaseName() { [EOL]     return baseName; [EOL] } <line_num>: 903,905
@Override [EOL] public String getName() { [EOL]     return getFullName(); [EOL] } <line_num>: 907,910
String getFullName() { [EOL]     return parent == null ? baseName : parent.getFullName() + '.' + baseName; [EOL] } <line_num>: 912,914
@Override [EOL] public Ref getDeclaration() { [EOL]     return declaration; [EOL] } <line_num>: 916,919
@Override [EOL] public boolean isTypeInferred() { [EOL]     return false; [EOL] } <line_num>: 921,924
@Override [EOL] public JSType getType() { [EOL]     return null; [EOL] } <line_num>: 926,929
void addRef(Ref ref) { [EOL]     addRefInternal(ref); [EOL]     switch(ref.type) { [EOL]         case SET_FROM_GLOBAL: [EOL]             if (declaration == null) { [EOL]                 declaration = ref; [EOL]                 docInfo = getDocInfoForDeclaration(ref); [EOL]             } [EOL]             globalSets++; [EOL]             break; [EOL]         case SET_FROM_LOCAL: [EOL]             localSets++; [EOL]             break; [EOL]         case PROTOTYPE_GET: [EOL]         case DIRECT_GET: [EOL]             totalGets++; [EOL]             break; [EOL]         case ALIASING_GET: [EOL]             aliasingGets++; [EOL]             totalGets++; [EOL]             break; [EOL]         case CALL_GET: [EOL]             callGets++; [EOL]             totalGets++; [EOL]             break; [EOL]         case DELETE_PROP: [EOL]             deleteProps++; [EOL]             break; [EOL]         default: [EOL]             throw new IllegalStateException(); [EOL]     } [EOL] } <line_num>: 931,962
void removeRef(Ref ref) { [EOL]     if (refs != null && refs.remove(ref)) { [EOL]         if (ref == declaration) { [EOL]             declaration = null; [EOL]             if (refs != null) { [EOL]                 for (Ref maybeNewDecl : refs) { [EOL]                     if (maybeNewDecl.type == Ref.Type.SET_FROM_GLOBAL) { [EOL]                         declaration = maybeNewDecl; [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         switch(ref.type) { [EOL]             case SET_FROM_GLOBAL: [EOL]                 globalSets--; [EOL]                 break; [EOL]             case SET_FROM_LOCAL: [EOL]                 localSets--; [EOL]                 break; [EOL]             case PROTOTYPE_GET: [EOL]             case DIRECT_GET: [EOL]                 totalGets--; [EOL]                 break; [EOL]             case ALIASING_GET: [EOL]                 aliasingGets--; [EOL]                 totalGets--; [EOL]                 break; [EOL]             case CALL_GET: [EOL]                 callGets--; [EOL]                 totalGets--; [EOL]                 break; [EOL]             case DELETE_PROP: [EOL]                 deleteProps--; [EOL]                 break; [EOL]             default: [EOL]                 throw new IllegalStateException(); [EOL]         } [EOL]     } [EOL] } <line_num>: 964,1004
List<Ref> getRefs() { [EOL]     return refs == null ? ImmutableList.<Ref>of() : refs; [EOL] } <line_num>: 1006,1008
void addRefInternal(Ref ref) { [EOL]     if (refs == null) { [EOL]         refs = Lists.newArrayList(); [EOL]     } [EOL]     refs.add(ref); [EOL] } <line_num>: 1010,1015
boolean canEliminate() { [EOL]     if (!canCollapseUnannotatedChildNames() || totalGets > 0) { [EOL]         return false; [EOL]     } [EOL]     if (props != null) { [EOL]         for (Name n : props) { [EOL]             if (!n.canCollapse()) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 1017,1030
boolean isSimpleStubDeclaration() { [EOL]     if (getRefs().size() == 1) { [EOL]         Ref ref = refs.get(0); [EOL]         JSDocInfo info = ref.node.getJSDocInfo(); [EOL]         if (ref.node.getParent() != null && ref.node.getParent().isExprResult()) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 1032,1042
boolean canCollapse() { [EOL]     return !inExterns && !isGetOrSetDefinition() && (declaredType || (parent == null || parent.canCollapseUnannotatedChildNames()) && (globalSets > 0 || localSets > 0) && deleteProps == 0); [EOL] } <line_num>: 1044,1049
boolean isGetOrSetDefinition() { [EOL]     return this.type == Type.GET || this.type == Type.SET; [EOL] } <line_num>: 1051,1053
boolean canCollapseUnannotatedChildNames() { [EOL]     if (type == Type.OTHER || isGetOrSetDefinition() || globalSets != 1 || localSets != 0 || deleteProps != 0) { [EOL]         return false; [EOL]     } [EOL]     Preconditions.checkNotNull(declaration); [EOL]     if (declaration.getTwin() != null) { [EOL]         return false; [EOL]     } [EOL]     if (declaredType) { [EOL]         return true; [EOL]     } [EOL]     if (parent != null && parent.shouldKeepKeys()) { [EOL]         return false; [EOL]     } [EOL]     if (aliasingGets > 0) { [EOL]         return false; [EOL]     } [EOL]     return (parent == null || parent.canCollapseUnannotatedChildNames()); [EOL] } <line_num>: 1055,1085
boolean shouldKeepKeys() { [EOL]     return type == Type.OBJECTLIT && aliasingGets > 0; [EOL] } <line_num>: 1088,1090
boolean needsToBeStubbed() { [EOL]     return globalSets == 0 && localSets > 0; [EOL] } <line_num>: 1092,1094
void setDeclaredType() { [EOL]     declaredType = true; [EOL]     for (Name ancestor = parent; ancestor != null; ancestor = ancestor.parent) { [EOL]         ancestor.hasDeclaredTypeDescendant = true; [EOL]     } [EOL] } <line_num>: 1096,1102
boolean isDeclaredType() { [EOL]     return declaredType; [EOL] } <line_num>: 1104,1106
boolean isNamespace() { [EOL]     return hasDeclaredTypeDescendant && type == Type.OBJECTLIT; [EOL] } <line_num>: 1116,1118
boolean isSimpleName() { [EOL]     return parent == null; [EOL] } <line_num>: 1124,1126
@Override [EOL] public String toString() { [EOL]     return getFullName() + " (" + type + "): globalSets=" + globalSets + ", localSets=" + localSets + ", totalGets=" + totalGets + ", aliasingGets=" + aliasingGets + ", callGets=" + callGets; [EOL] } <line_num>: 1128,1132
@Override [EOL] public JSDocInfo getJSDocInfo() { [EOL]     return docInfo; [EOL] } <line_num>: 1134,1137
private static JSDocInfo getDocInfoForDeclaration(Ref ref) { [EOL]     if (ref.node != null) { [EOL]         Node refParent = ref.node.getParent(); [EOL]         switch(refParent.getType()) { [EOL]             case Token.FUNCTION: [EOL]             case Token.ASSIGN: [EOL]                 return refParent.getJSDocInfo(); [EOL]             case Token.VAR: [EOL]                 return ref.node == refParent.getFirstChild() ? refParent.getJSDocInfo() : ref.node.getJSDocInfo(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 1142,1156
@Override [EOL] public Node getNode() { [EOL]     return node; [EOL] } <line_num>: 1225,1228
@Override [EOL] public StaticSourceFile getSourceFile() { [EOL]     return source; [EOL] } <line_num>: 1230,1233
@Override [EOL] public StaticSlot<JSType> getSymbol() { [EOL]     return name; [EOL] } <line_num>: 1235,1238
JSModule getModule() { [EOL]     return module; [EOL] } <line_num>: 1240,1242
String getSourceName() { [EOL]     return source == null ? "" : source.getName(); [EOL] } <line_num>: 1244,1246
Ref getTwin() { [EOL]     return twin; [EOL] } <line_num>: 1248,1250
boolean isSet() { [EOL]     return type == Type.SET_FROM_GLOBAL || type == Type.SET_FROM_LOCAL; [EOL] } <line_num>: 1252,1254
static void markTwins(Ref a, Ref b) { [EOL]     Preconditions.checkArgument((a.type == Type.ALIASING_GET || b.type == Type.ALIASING_GET) && (a.type == Type.SET_FROM_GLOBAL || a.type == Type.SET_FROM_LOCAL || b.type == Type.SET_FROM_GLOBAL || b.type == Type.SET_FROM_LOCAL)); [EOL]     a.twin = b; [EOL]     b.twin = a; [EOL] } <line_num>: 1256,1263
Ref cloneAndReclassify(Type type) { [EOL]     return new Ref(this, type, this.preOrderIndex); [EOL] } <line_num>: 1269,1271
static Ref createRefForTesting(Type type) { [EOL]     return new Ref(type, -1); [EOL] } <line_num>: 1273,1275
@Override [EOL] public void process(Node externs, Node root) { [EOL]     GlobalNamespace namespace = new GlobalNamespace(compiler, externs, root); [EOL]     Set<String> currentSymbols = Sets.newTreeSet(); [EOL]     for (String name : namespace.getNameIndex().keySet()) { [EOL]         if (isInterestingSymbol.apply(name)) { [EOL]             currentSymbols.add(name); [EOL]         } [EOL]     } [EOL]     String passName = compiler.getLastPassName(); [EOL]     if (passName == null) { [EOL]         passName = "[Unknown pass]"; [EOL]     } [EOL]     for (String sym : currentSymbols) { [EOL]         if (!previousSymbolsInTree.contains(sym)) { [EOL]             stream.println(String.format("%s: Added by %s", sym, passName)); [EOL]         } [EOL]     } [EOL]     for (String sym : previousSymbolsInTree) { [EOL]         if (!currentSymbols.contains(sym)) { [EOL]             stream.println(String.format("%s: Removed by %s", sym, passName)); [EOL]         } [EOL]     } [EOL]     previousSymbolsInTree = currentSymbols; [EOL] } <line_num>: 1305,1333
