RuntimeTypeCheck(AbstractCompiler compiler, @Nullable String logFunction) { [EOL]     this.compiler = compiler; [EOL]     this.logFunction = logFunction; [EOL] } <line_num>: 75,78
private AddMarkers(AbstractCompiler compiler) { [EOL]     this.compiler = compiler; [EOL] } <line_num>: 104,106
private AddChecks() { [EOL] } <line_num>: 215,216
@Override [EOL] public int compare(JSType t1, JSType t2) { [EOL]     return getName(t1).compareTo(getName(t2)); [EOL] } <line_num>: 51,54
private String getName(JSType type) { [EOL]     if (type.isInstanceType()) { [EOL]         return ((ObjectType) type).getReferenceName(); [EOL]     } else if (type.isNullType() || type.isBooleanValueType() || type.isNumberValueType() || type.isStringValueType() || type.isVoidType()) { [EOL]         return type.toString(); [EOL]     } else { [EOL]         return ""; [EOL]     } [EOL] } <line_num>: 56,69
@Override [EOL] public void process(Node externs, Node root) { [EOL]     NodeTraversal.traverse(compiler, root, new AddMarkers(compiler)); [EOL]     NodeTraversal.traverse(compiler, root, new AddChecks()); [EOL]     addBoilerplateCode(); [EOL] } <line_num>: 80,85
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (n.isFunction()) { [EOL]         visitFunction(t, n); [EOL]     } [EOL] } <line_num>: 108,113
private void visitFunction(NodeTraversal t, Node n) { [EOL]     FunctionType funType = n.getJSType().toMaybeFunctionType(); [EOL]     if (funType != null && !funType.isConstructor()) { [EOL]         return; [EOL]     } [EOL]     Node nodeToInsertAfter = findNodeToInsertAfter(n); [EOL]     nodeToInsertAfter = addMarker(funType, nodeToInsertAfter, null); [EOL]     TreeSet<ObjectType> stuff = Sets.newTreeSet(ALPHA); [EOL]     Iterables.addAll(stuff, funType.getAllImplementedInterfaces()); [EOL]     for (ObjectType interfaceType : stuff) { [EOL]         nodeToInsertAfter = addMarker(funType, nodeToInsertAfter, interfaceType); [EOL]     } [EOL] } <line_num>: 115,131
private Node addMarker(FunctionType funType, Node nodeToInsertAfter, @Nullable ObjectType interfaceType) { [EOL]     if (funType.getSource() == null) { [EOL]         return nodeToInsertAfter; [EOL]     } [EOL]     String className = NodeUtil.getFunctionName(funType.getSource()); [EOL]     if (className == null) { [EOL]         return nodeToInsertAfter; [EOL]     } [EOL]     Node classNode = NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), className); [EOL]     Node marker = IR.string(interfaceType == null ? "instance_of__" + className : "implements__" + interfaceType.getReferenceName()); [EOL]     Node assign = IR.exprResult(IR.assign(IR.getelem(IR.getprop(classNode, IR.string("prototype")), marker), IR.trueNode())); [EOL]     nodeToInsertAfter.getParent().addChildAfter(assign, nodeToInsertAfter); [EOL]     compiler.reportCodeChange(); [EOL]     nodeToInsertAfter = assign; [EOL]     return nodeToInsertAfter; [EOL] } <line_num>: 133,169
private Node findNodeToInsertAfter(Node n) { [EOL]     Node nodeToInsertAfter = findEnclosingConstructorDeclaration(n); [EOL]     Node next = nodeToInsertAfter.getNext(); [EOL]     while (next != null && isClassDefiningCall(next)) { [EOL]         nodeToInsertAfter = next; [EOL]         next = nodeToInsertAfter.getNext(); [EOL]     } [EOL]     return nodeToInsertAfter; [EOL] } <line_num>: 179,189
private Node findEnclosingConstructorDeclaration(Node n) { [EOL]     while (!n.getParent().isScript() && !n.getParent().isBlock()) { [EOL]         n = n.getParent(); [EOL]     } [EOL]     return n; [EOL] } <line_num>: 191,196
private boolean isClassDefiningCall(Node next) { [EOL]     return NodeUtil.isExprCall(next) && compiler.getCodingConvention().getClassesDefinedByCall(next.getFirstChild()) != null; [EOL] } <line_num>: 198,202
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (n.isFunction()) { [EOL]         visitFunction(t, n); [EOL]     } else if (n.isReturn()) { [EOL]         visitReturn(t, n); [EOL]     } [EOL] } <line_num>: 218,225
private void visitFunction(NodeTraversal t, Node n) { [EOL]     FunctionType funType = JSType.toMaybeFunctionType(n.getJSType()); [EOL]     Node block = n.getLastChild(); [EOL]     Node paramName = NodeUtil.getFunctionParameters(n).getFirstChild(); [EOL]     Node insertionPoint = null; [EOL]     for (Node next = block.getFirstChild(); next != null && NodeUtil.isFunctionDeclaration(next); next = next.getNext()) { [EOL]         insertionPoint = next; [EOL]     } [EOL]     for (Node paramType : funType.getParameters()) { [EOL]         if (paramName == null) { [EOL]             return; [EOL]         } [EOL]         Node checkNode = createCheckTypeCallNode(paramType.getJSType(), paramName.cloneTree()); [EOL]         if (checkNode == null) { [EOL]             paramName = paramName.getNext(); [EOL]             continue; [EOL]         } [EOL]         checkNode = IR.exprResult(checkNode); [EOL]         if (insertionPoint == null) { [EOL]             block.addChildToFront(checkNode); [EOL]         } else { [EOL]             block.addChildAfter(checkNode, insertionPoint); [EOL]         } [EOL]         compiler.reportCodeChange(); [EOL]         paramName = paramName.getNext(); [EOL]         insertionPoint = checkNode; [EOL]     } [EOL] } <line_num>: 230,270
private void visitReturn(NodeTraversal t, Node n) { [EOL]     Node function = t.getEnclosingFunction(); [EOL]     FunctionType funType = function.getJSType().toMaybeFunctionType(); [EOL]     Node retValue = n.getFirstChild(); [EOL]     if (retValue == null) { [EOL]         return; [EOL]     } [EOL]     Node checkNode = createCheckTypeCallNode(funType.getReturnType(), retValue.cloneTree()); [EOL]     if (checkNode == null) { [EOL]         return; [EOL]     } [EOL]     n.replaceChild(retValue, checkNode); [EOL]     compiler.reportCodeChange(); [EOL] } <line_num>: 272,290
private Node createCheckTypeCallNode(JSType type, Node expr) { [EOL]     Node arrayNode = IR.arraylit(); [EOL]     Collection<JSType> alternates; [EOL]     if (type.isUnionType()) { [EOL]         alternates = Sets.newTreeSet(ALPHA); [EOL]         Iterables.addAll(alternates, type.toMaybeUnionType().getAlternates()); [EOL]     } else { [EOL]         alternates = ImmutableList.of(type); [EOL]     } [EOL]     for (JSType alternate : alternates) { [EOL]         Node checkerNode = createCheckerNode(alternate); [EOL]         if (checkerNode == null) { [EOL]             return null; [EOL]         } [EOL]         arrayNode.addChildToBack(checkerNode); [EOL]     } [EOL]     return IR.call(jsCode("checkType"), expr, arrayNode); [EOL] } <line_num>: 301,318
private Node createCheckerNode(JSType type) { [EOL]     if (type.isNullType()) { [EOL]         return jsCode("nullChecker"); [EOL]     } else if (type.isBooleanValueType() || type.isNumberValueType() || type.isStringValueType() || type.isVoidType()) { [EOL]         return IR.call(jsCode("valueChecker"), IR.string(type.toString())); [EOL]     } else if (type.isInstanceType()) { [EOL]         ObjectType objType = (ObjectType) type; [EOL]         String refName = objType.getReferenceName(); [EOL]         StaticSourceFile sourceFile = NodeUtil.getSourceFile(objType.getConstructor().getSource()); [EOL]         if (sourceFile == null || sourceFile.isExtern()) { [EOL]             return IR.call(jsCode("externClassChecker"), IR.string(refName)); [EOL]         } [EOL]         return IR.call(jsCode(objType.getConstructor().isInterface() ? "interfaceChecker" : "classChecker"), IR.string(refName)); [EOL]     } else { [EOL]         return null; [EOL]     } [EOL] } <line_num>: 327,361
private void addBoilerplateCode() { [EOL]     Node newNode = compiler.ensureLibraryInjected("runtime_type_check"); [EOL]     if (newNode != null && logFunction != null) { [EOL]         Node logOverride = IR.exprResult(IR.assign(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), "$jscomp.typecheck.log"), NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), logFunction))); [EOL]         newNode.getParent().addChildAfter(logOverride, newNode); [EOL]         compiler.reportCodeChange(); [EOL]     } [EOL] } <line_num>: 364,379
private Node jsCode(String prop) { [EOL]     return NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), "$jscomp.typecheck." + prop); [EOL] } <line_num>: 381,384
