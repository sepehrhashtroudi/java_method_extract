private FunctionArgumentInjector() { [EOL] } <line_num>: 43,45
ReferencedAfterSideEffect(Set<String> parameters, Set<String> locals) { [EOL]     this.parameters = parameters; [EOL]     this.locals = locals; [EOL] } <line_num>: 369,372
static Node inject(AbstractCompiler compiler, Node node, Node parent, Map<String, Node> replacements) { [EOL]     return inject(compiler, node, parent, replacements, true); [EOL] } <line_num>: 56,59
static Node inject(AbstractCompiler compiler, Node node, Node parent, Map<String, Node> replacements, boolean replaceThis) { [EOL]     if (node.isName()) { [EOL]         Node replacementTemplate = replacements.get(node.getString()); [EOL]         if (replacementTemplate != null) { [EOL]             Preconditions.checkState(!parent.isFunction() || !parent.isVar() || !parent.isCatch()); [EOL]             Node replacement = replacementTemplate.cloneTree(); [EOL]             parent.replaceChild(node, replacement); [EOL]             return replacement; [EOL]         } [EOL]     } else if (replaceThis && node.isThis()) { [EOL]         Node replacementTemplate = replacements.get(THIS_MARKER); [EOL]         Preconditions.checkNotNull(replacementTemplate); [EOL]         if (!replacementTemplate.isThis()) { [EOL]             Node replacement = replacementTemplate.cloneTree(); [EOL]             parent.replaceChild(node, replacement); [EOL]             if (NodeUtil.mayHaveSideEffects(replacementTemplate, compiler)) { [EOL]                 replacements.remove(THIS_MARKER); [EOL]             } [EOL]             return replacement; [EOL]         } [EOL]     } else if (node.isFunction()) { [EOL]         replaceThis = false; [EOL]     } [EOL]     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) { [EOL]         c = inject(compiler, c, node, replacements, replaceThis); [EOL]     } [EOL]     return node; [EOL] } <line_num>: 61,107
static LinkedHashMap<String, Node> getFunctionCallParameterMap(Node fnNode, Node callNode, Supplier<String> safeNameIdSupplier) { [EOL]     LinkedHashMap<String, Node> argMap = Maps.newLinkedHashMap(); [EOL]     Node cArg = callNode.getFirstChild().getNext(); [EOL]     if (cArg != null && NodeUtil.isFunctionObjectCall(callNode)) { [EOL]         argMap.put(THIS_MARKER, cArg); [EOL]         cArg = cArg.getNext(); [EOL]     } else { [EOL]         Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode)); [EOL]         argMap.put(THIS_MARKER, NodeUtil.newUndefinedNode(callNode)); [EOL]     } [EOL]     for (Node fnArg : NodeUtil.getFunctionParameters(fnNode).children()) { [EOL]         if (cArg != null) { [EOL]             argMap.put(fnArg.getString(), cArg); [EOL]             cArg = cArg.getNext(); [EOL]         } else { [EOL]             Node srcLocation = callNode; [EOL]             argMap.put(fnArg.getString(), NodeUtil.newUndefinedNode(srcLocation)); [EOL]         } [EOL]     } [EOL]     int anonArg = 0; [EOL]     while (cArg != null) { [EOL]         String uniquePlaceholder = getUniqueAnonymousParameterName(safeNameIdSupplier); [EOL]         argMap.put(uniquePlaceholder, cArg); [EOL]         cArg = cArg.getNext(); [EOL]     } [EOL]     return argMap; [EOL] } <line_num>: 112,150
private static String getUniqueAnonymousParameterName(Supplier<String> safeNameIdSupplier) { [EOL]     return "JSCompiler_inline_anon_param_" + safeNameIdSupplier.get(); [EOL] } <line_num>: 155,158
static Set<String> findModifiedParameters(Node fnNode) { [EOL]     Set<String> names = getFunctionParameterSet(fnNode); [EOL]     Set<String> unsafeNames = Sets.newHashSet(); [EOL]     return findModifiedParameters(fnNode.getLastChild(), null, names, unsafeNames, false); [EOL] } <line_num>: 169,174
private static Set<String> findModifiedParameters(Node n, Node parent, Set<String> names, Set<String> unsafe, boolean inInnerFunction) { [EOL]     Preconditions.checkArgument(unsafe != null); [EOL]     if (n.isName()) { [EOL]         if (names.contains(n.getString())) { [EOL]             if (inInnerFunction || canNameValueChange(n, parent)) { [EOL]                 unsafe.add(n.getString()); [EOL]             } [EOL]         } [EOL]     } else if (n.isFunction()) { [EOL]         inInnerFunction = true; [EOL]     } [EOL]     for (Node c : n.children()) { [EOL]         findModifiedParameters(c, n, names, unsafe, inInnerFunction); [EOL]     } [EOL]     return unsafe; [EOL] } <line_num>: 195,219
private static boolean canNameValueChange(Node n, Node parent) { [EOL]     int type = parent.getType(); [EOL]     return (type == Token.VAR || type == Token.INC || type == Token.DEC || (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)); [EOL] } <line_num>: 232,236
static void maybeAddTempsForCallArguments(Node fnNode, Map<String, Node> argMap, Set<String> namesNeedingTemps, CodingConvention convention) { [EOL]     if (argMap.isEmpty()) { [EOL]         return; [EOL]     } [EOL]     Preconditions.checkArgument(fnNode.isFunction()); [EOL]     Node block = fnNode.getLastChild(); [EOL]     Set<String> parameters = argMap.keySet(); [EOL]     Set<String> namesAfterSideEffects = findParametersReferencedAfterSideEffect(parameters, block); [EOL]     for (Map.Entry<String, Node> entry : argMap.entrySet()) { [EOL]         String argName = entry.getKey(); [EOL]         if (namesNeedingTemps.contains(argName)) { [EOL]             continue; [EOL]         } [EOL]         Node cArg = entry.getValue(); [EOL]         boolean safe = true; [EOL]         int references = NodeUtil.getNameReferenceCount(block, argName); [EOL]         if (NodeUtil.mayEffectMutableState(cArg) && references > 0) { [EOL]             safe = false; [EOL]         } else if (NodeUtil.mayHaveSideEffects(cArg)) { [EOL]             safe = false; [EOL]         } else if (NodeUtil.canBeSideEffected(cArg) && namesAfterSideEffects.contains(argName)) { [EOL]             safe = false; [EOL]         } else if (references > 1) { [EOL]             switch(cArg.getType()) { [EOL]                 case Token.NAME: [EOL]                     String name = cArg.getString(); [EOL]                     safe = !(convention.isExported(name)); [EOL]                     break; [EOL]                 case Token.THIS: [EOL]                     safe = true; [EOL]                     break; [EOL]                 case Token.STRING: [EOL]                     safe = (cArg.getString().length() < 2); [EOL]                     break; [EOL]                 default: [EOL]                     safe = NodeUtil.isImmutableValue(cArg); [EOL]                     break; [EOL]             } [EOL]         } [EOL]         if (!safe) { [EOL]             namesNeedingTemps.add(argName); [EOL]         } [EOL]     } [EOL] } <line_num>: 245,314
private static Set<String> findParametersReferencedAfterSideEffect(Set<String> parameters, Node root) { [EOL]     Set<String> locals = Sets.newHashSet(parameters); [EOL]     gatherLocalNames(root, locals); [EOL]     ReferencedAfterSideEffect collector = new ReferencedAfterSideEffect(parameters, locals); [EOL]     NodeUtil.visitPostOrder(root, collector, collector); [EOL]     return collector.getResults(); [EOL] } <line_num>: 325,339
Set<String> getResults() { [EOL]     return parametersReferenced; [EOL] } <line_num>: 374,376
@Override [EOL] public boolean apply(Node node) { [EOL]     if (NodeUtil.isLoopStructure(node)) { [EOL]         loopsEntered++; [EOL]     } [EOL]     return !(sideEffectSeen && parameters.size() == parametersReferenced.size()); [EOL] } <line_num>: 378,389
boolean inLoop() { [EOL]     return loopsEntered != 0; [EOL] } <line_num>: 391,393
@Override [EOL] public void visit(Node n) { [EOL]     if (NodeUtil.isLoopStructure(n)) { [EOL]         loopsEntered--; [EOL]         if (!inLoop() && !sideEffectSeen) { [EOL]             parametersReferenced.clear(); [EOL]         } [EOL]     } [EOL]     if (!sideEffectSeen) { [EOL]         if (hasNonLocalSideEffect(n)) { [EOL]             sideEffectSeen = true; [EOL]         } [EOL]     } [EOL]     if (inLoop() || sideEffectSeen) { [EOL]         if (n.isName()) { [EOL]             String name = n.getString(); [EOL]             if (parameters.contains(name)) { [EOL]                 parametersReferenced.add(name); [EOL]             } [EOL]         } else if (n.isThis()) { [EOL]             parametersReferenced.add(THIS_MARKER); [EOL]         } [EOL]     } [EOL] } <line_num>: 395,428
private boolean hasNonLocalSideEffect(Node n) { [EOL]     boolean sideEffect = false; [EOL]     int type = n.getType(); [EOL]     if (NodeUtil.isAssignmentOp(n) || type == Token.INC || type == Token.DEC) { [EOL]         Node lhs = n.getFirstChild(); [EOL]         if (!isLocalName(lhs)) { [EOL]             sideEffect = true; [EOL]         } [EOL]     } else if (type == Token.CALL) { [EOL]         sideEffect = NodeUtil.functionCallHasSideEffects(n); [EOL]     } else if (type == Token.NEW) { [EOL]         sideEffect = NodeUtil.constructorCallHasSideEffects(n); [EOL]     } else if (type == Token.DELPROP) { [EOL]         sideEffect = true; [EOL]     } [EOL]     return sideEffect; [EOL] } <line_num>: 433,455
private boolean isLocalName(Node node) { [EOL]     if (node.isName()) { [EOL]         String name = node.getString(); [EOL]         return locals.contains(name); [EOL]     } [EOL]     return false; [EOL] } <line_num>: 460,466
private static void gatherLocalNames(Node n, Set<String> names) { [EOL]     if (n.isFunction()) { [EOL]         if (NodeUtil.isFunctionDeclaration(n)) { [EOL]             names.add(n.getFirstChild().getString()); [EOL]         } [EOL]         return; [EOL]     } else if (n.isName()) { [EOL]         switch(n.getParent().getType()) { [EOL]             case Token.VAR: [EOL]             case Token.CATCH: [EOL]                 names.add(n.getString()); [EOL]         } [EOL]     } [EOL]     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { [EOL]         gatherLocalNames(c, names); [EOL]     } [EOL] } <line_num>: 472,490
private static Set<String> getFunctionParameterSet(Node fnNode) { [EOL]     Set<String> set = Sets.newHashSet(); [EOL]     for (Node n : NodeUtil.getFunctionParameters(fnNode).children()) { [EOL]         set.add(n.getString()); [EOL]     } [EOL]     return set; [EOL] } <line_num>: 495,501
