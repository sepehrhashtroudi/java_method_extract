NameGenerator(Set<String> reservedNames, String prefix, @Nullable char[] reservedCharacters) { [EOL]     this.reservedNames = reservedNames; [EOL]     this.prefix = prefix; [EOL]     this.firstChars = reserveCharacters(FIRST_CHAR, reservedCharacters); [EOL]     this.nonFirstChars = reserveCharacters(NONFIRST_CHAR, reservedCharacters); [EOL]     checkPrefix(prefix); [EOL] } <line_num>: 59,69
static char[] reserveCharacters(char[] chars, char[] reservedCharacters) { [EOL]     if (reservedCharacters == null || reservedCharacters.length == 0) { [EOL]         return chars; [EOL]     } [EOL]     Set<Character> charSet = Sets.newLinkedHashSet(Chars.asList(chars)); [EOL]     for (char reservedCharacter : reservedCharacters) { [EOL]         charSet.remove(reservedCharacter); [EOL]     } [EOL]     return Chars.toArray(charSet); [EOL] } <line_num>: 78,87
private void checkPrefix(String prefix) { [EOL]     if (prefix.length() > 0) { [EOL]         if (!contains(firstChars, prefix.charAt(0))) { [EOL]             throw new IllegalArgumentException("prefix must start with one of: " + Arrays.toString(firstChars)); [EOL]         } [EOL]         for (int pos = 1; pos < prefix.length(); ++pos) { [EOL]             if (!contains(nonFirstChars, prefix.charAt(pos))) { [EOL]                 throw new IllegalArgumentException("prefix has invalid characters, " + "must be one of: " + Arrays.toString(nonFirstChars)); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 90,105
private boolean contains(char[] arr, char c) { [EOL]     for (int i = 0; i < arr.length; i++) { [EOL]         if (arr[i] == c) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 107,114
String generateNextName() { [EOL]     while (true) { [EOL]         String name = prefix; [EOL]         int i = nameCount; [EOL]         if (name.isEmpty()) { [EOL]             int pos = i % firstChars.length; [EOL]             name += firstChars[pos]; [EOL]             i /= firstChars.length; [EOL]         } [EOL]         while (i > 0) { [EOL]             i--; [EOL]             int pos = i % nonFirstChars.length; [EOL]             name += nonFirstChars[pos]; [EOL]             i /= nonFirstChars.length; [EOL]         } [EOL]         nameCount++; [EOL]         if (TokenStream.isKeyword(name) || reservedNames.contains(name)) { [EOL]             continue; [EOL]         } [EOL]         return name; [EOL]     } [EOL] } <line_num>: 119,147
