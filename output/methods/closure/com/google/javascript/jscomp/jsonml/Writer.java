public JsonML processAst(Node root) { [EOL]     Preconditions.checkNotNull(root); [EOL]     Preconditions.checkArgument(root.getType() == Token.BLOCK || root.getType() == Token.SCRIPT); [EOL]     JsonML rootElement = new JsonML(TagType.BlockStmt); [EOL]     if (root.getType() == Token.SCRIPT) { [EOL]         processNode(root, rootElement); [EOL]         return rootElement.getChild(0); [EOL]     } else { [EOL]         Node child = root.getFirstChild(); [EOL]         while (child != null) { [EOL]             processNode(child, rootElement); [EOL]             child = child.getNext(); [EOL]         } [EOL]         return rootElement.getChild(0); [EOL]     } [EOL] } <line_num>: 38,56
private void processNode(Node node, JsonML currentParent) { [EOL]     switch(node.getType()) { [EOL]         case Token.RETURN: [EOL]             processReturn(node, currentParent); [EOL]             break; [EOL]         case Token.BITOR: [EOL]             processBinaryExpr(node, currentParent, "|"); [EOL]             break; [EOL]         case Token.BITXOR: [EOL]             processBinaryExpr(node, currentParent, "^"); [EOL]             break; [EOL]         case Token.BITAND: [EOL]             processBinaryExpr(node, currentParent, "&"); [EOL]             break; [EOL]         case Token.EQ: [EOL]             processBinaryExpr(node, currentParent, "=="); [EOL]             break; [EOL]         case Token.NE: [EOL]             processBinaryExpr(node, currentParent, "!="); [EOL]             break; [EOL]         case Token.LT: [EOL]             processBinaryExpr(node, currentParent, "<"); [EOL]             break; [EOL]         case Token.LE: [EOL]             processBinaryExpr(node, currentParent, "<="); [EOL]             break; [EOL]         case Token.GT: [EOL]             processBinaryExpr(node, currentParent, ">"); [EOL]             break; [EOL]         case Token.GE: [EOL]             processBinaryExpr(node, currentParent, ">="); [EOL]             break; [EOL]         case Token.LSH: [EOL]             processBinaryExpr(node, currentParent, "<<"); [EOL]             break; [EOL]         case Token.RSH: [EOL]             processBinaryExpr(node, currentParent, ">>"); [EOL]             break; [EOL]         case Token.URSH: [EOL]             processBinaryExpr(node, currentParent, ">>>"); [EOL]             break; [EOL]         case Token.ADD: [EOL]             processBinaryExpr(node, currentParent, "+"); [EOL]             break; [EOL]         case Token.SUB: [EOL]             processBinaryExpr(node, currentParent, "-"); [EOL]             break; [EOL]         case Token.MUL: [EOL]             processBinaryExpr(node, currentParent, "*"); [EOL]             break; [EOL]         case Token.DIV: [EOL]             processBinaryExpr(node, currentParent, "/"); [EOL]             break; [EOL]         case Token.MOD: [EOL]             processBinaryExpr(node, currentParent, "%"); [EOL]             break; [EOL]         case Token.NOT: [EOL]             processUnaryExpr(node, currentParent, "!"); [EOL]             break; [EOL]         case Token.BITNOT: [EOL]             processUnaryExpr(node, currentParent, "~"); [EOL]             break; [EOL]         case Token.POS: [EOL]             processUnaryExpr(node, currentParent, "+"); [EOL]             break; [EOL]         case Token.NEG: [EOL]             processUnaryExpr(node, currentParent, "-"); [EOL]             break; [EOL]         case Token.NEW: [EOL]             processNew(node, currentParent, TagType.NewExpr); [EOL]             break; [EOL]         case Token.DELPROP: [EOL]             processOneArgExpr(node, currentParent, TagType.DeleteExpr); [EOL]             break; [EOL]         case Token.TYPEOF: [EOL]             processOneArgExpr(node, currentParent, TagType.TypeofExpr); [EOL]             break; [EOL]         case Token.GETPROP: [EOL]             processMemberExpr(node, currentParent, "."); [EOL]             break; [EOL]         case Token.GETELEM: [EOL]             processMemberExpr(node, currentParent, "[]"); [EOL]             break; [EOL]         case Token.CALL: [EOL]             processCall(node, currentParent); [EOL]             break; [EOL]         case Token.NAME: [EOL]             processName(node, currentParent); [EOL]             break; [EOL]         case Token.NUMBER: [EOL]         case Token.STRING: [EOL]         case Token.NULL: [EOL]         case Token.FALSE: [EOL]         case Token.TRUE: [EOL]             processLiteral(node, currentParent); [EOL]             break; [EOL]         case Token.THIS: [EOL]             processThis(node, currentParent); [EOL]             break; [EOL]         case Token.SHEQ: [EOL]             processBinaryExpr(node, currentParent, "==="); [EOL]             break; [EOL]         case Token.SHNE: [EOL]             processBinaryExpr(node, currentParent, "!=="); [EOL]             break; [EOL]         case Token.REGEXP: [EOL]             processRegExp(node, currentParent); [EOL]             break; [EOL]         case Token.THROW: [EOL]             processThrow(node, currentParent); [EOL]             break; [EOL]         case Token.IN: [EOL]             processBinaryExpr(node, currentParent, "in"); [EOL]             break; [EOL]         case Token.INSTANCEOF: [EOL]             processBinaryExpr(node, currentParent, "instanceof"); [EOL]             break; [EOL]         case Token.ARRAYLIT: [EOL]             processArrayLiteral(node, currentParent); [EOL]             break; [EOL]         case Token.OBJECTLIT: [EOL]             processObjectLiteral(node, currentParent); [EOL]             break; [EOL]         case Token.TRY: [EOL]             processTry(node, currentParent); [EOL]             break; [EOL]         case Token.COMMA: [EOL]             processBinaryExpr(node, currentParent, ","); [EOL]             break; [EOL]         case Token.ASSIGN: [EOL]             processAssignExpr(node, currentParent, "="); [EOL]             break; [EOL]         case Token.ASSIGN_BITOR: [EOL]             processAssignExpr(node, currentParent, "|="); [EOL]             break; [EOL]         case Token.ASSIGN_BITXOR: [EOL]             processAssignExpr(node, currentParent, "^="); [EOL]             break; [EOL]         case Token.ASSIGN_BITAND: [EOL]             processAssignExpr(node, currentParent, "&="); [EOL]             break; [EOL]         case Token.ASSIGN_LSH: [EOL]             processAssignExpr(node, currentParent, "<<="); [EOL]             break; [EOL]         case Token.ASSIGN_RSH: [EOL]             processAssignExpr(node, currentParent, ">>="); [EOL]             break; [EOL]         case Token.ASSIGN_URSH: [EOL]             processAssignExpr(node, currentParent, ">>>="); [EOL]             break; [EOL]         case Token.ASSIGN_ADD: [EOL]             processAssignExpr(node, currentParent, "+="); [EOL]             break; [EOL]         case Token.ASSIGN_SUB: [EOL]             processAssignExpr(node, currentParent, "-="); [EOL]             break; [EOL]         case Token.ASSIGN_MUL: [EOL]             processAssignExpr(node, currentParent, "*="); [EOL]             break; [EOL]         case Token.ASSIGN_DIV: [EOL]             processAssignExpr(node, currentParent, "/="); [EOL]             break; [EOL]         case Token.ASSIGN_MOD: [EOL]             processAssignExpr(node, currentParent, "%="); [EOL]             break; [EOL]         case Token.HOOK: [EOL]             processHook(node, currentParent); [EOL]             break; [EOL]         case Token.OR: [EOL]             processLogicalExpr(node, currentParent, "||"); [EOL]             break; [EOL]         case Token.AND: [EOL]             processLogicalExpr(node, currentParent, "&&"); [EOL]             break; [EOL]         case Token.INC: [EOL]             processIncrDecrExpr(node, currentParent, "++"); [EOL]             break; [EOL]         case Token.DEC: [EOL]             processIncrDecrExpr(node, currentParent, "--"); [EOL]             break; [EOL]         case Token.FUNCTION: [EOL]             processFunction(node, currentParent); [EOL]             break; [EOL]         case Token.IF: [EOL]             processIf(node, currentParent); [EOL]             break; [EOL]         case Token.SWITCH: [EOL]             processSwitch(node, currentParent); [EOL]             break; [EOL]         case Token.CASE: [EOL]             processCase(node, currentParent, TagType.Case); [EOL]             break; [EOL]         case Token.DEFAULT_CASE: [EOL]             processCase(node, currentParent, TagType.DefaultCase); [EOL]             break; [EOL]         case Token.WHILE: [EOL]             processLoop(node, currentParent, TagType.WhileStmt); [EOL]             break; [EOL]         case Token.DO: [EOL]             processLoop(node, currentParent, TagType.DoWhileStmt); [EOL]             break; [EOL]         case Token.FOR: [EOL]             processForLoop(node, currentParent); [EOL]             break; [EOL]         case Token.BREAK: [EOL]             processJmp(node, currentParent, TagType.BreakStmt); [EOL]             break; [EOL]         case Token.CONTINUE: [EOL]             processJmp(node, currentParent, TagType.ContinueStmt); [EOL]             break; [EOL]         case Token.VAR: [EOL]             processVar(node, currentParent); [EOL]             break; [EOL]         case Token.WITH: [EOL]             processWith(node, currentParent); [EOL]             break; [EOL]         case Token.CATCH: [EOL]             processCatch(node, currentParent); [EOL]             break; [EOL]         case Token.VOID: [EOL]             processUnaryExpr(node, currentParent, "void"); [EOL]             break; [EOL]         case Token.EMPTY: [EOL]             processEmpty(node, currentParent); [EOL]             break; [EOL]         case Token.BLOCK: [EOL]             processBlock(node, currentParent); [EOL]             break; [EOL]         case Token.LABEL: [EOL]             processLabel(node, currentParent); [EOL]             break; [EOL]         case Token.EXPR_RESULT: [EOL]             processExprResult(node, currentParent); [EOL]             break; [EOL]         case Token.SCRIPT: [EOL]             processScript(node, currentParent); [EOL]             break; [EOL]     } [EOL] } <line_num>: 64,302
private void processAssignExpr(Node node, JsonML currentParent, String op) { [EOL]     processTwoArgExpr(node, currentParent, TagType.AssignExpr, op); [EOL] } <line_num>: 304,306
private void processArrayLiteral(Node node, JsonML currentParent) { [EOL]     JsonML element = new JsonML(TagType.ArrayExpr); [EOL]     currentParent.appendChild(element); [EOL]     Iterator<Node> it = node.children().iterator(); [EOL]     while (it.hasNext()) { [EOL]         processNode(it.next(), element); [EOL]     } [EOL] } <line_num>: 308,315
private void processBinaryExpr(Node node, JsonML currentParent, String op) { [EOL]     processTwoArgExpr(node, currentParent, TagType.BinaryExpr, op); [EOL] } <line_num>: 317,320
private void processBlock(Node node, JsonML currentParent) { [EOL]     JsonML element = new JsonML(TagType.BlockStmt); [EOL]     if (currentParent != null) { [EOL]         currentParent.appendChild(element); [EOL]     } [EOL]     processDirectives(node, element); [EOL]     for (Node child : node.children()) { [EOL]         processNode(child, element); [EOL]     } [EOL] } <line_num>: 322,333
private void processCall(Node node, JsonML currentParent) { [EOL]     Iterator<Node> it = node.children().iterator(); [EOL]     Node child = it.next(); [EOL]     JsonML element; [EOL]     switch(child.getType()) { [EOL]         case Token.GETPROP: [EOL]         case Token.GETELEM: [EOL]             element = new JsonML(TagType.InvokeExpr); [EOL]             element.setAttribute(TagAttr.OP, child.getType() == Token.GETPROP ? "." : "[]"); [EOL]             currentParent.appendChild(element); [EOL]             Node grandchild = child.getFirstChild(); [EOL]             processNode(grandchild, element); [EOL]             processNode(grandchild.getNext(), element); [EOL]             break; [EOL]         case Token.NAME: [EOL]             if (child.getString().equals("eval")) { [EOL]                 element = new JsonML(TagType.EvalExpr); [EOL]             } else { [EOL]                 element = new JsonML(TagType.IdExpr); [EOL]                 element.setAttribute(TagAttr.NAME, child.getString()); [EOL]                 element = new JsonML(TagType.CallExpr, element); [EOL]             } [EOL]             currentParent.appendChild(element); [EOL]             break; [EOL]         default: [EOL]             element = new JsonML(TagType.CallExpr); [EOL]             currentParent.appendChild(element); [EOL]             processNode(child, element); [EOL]             break; [EOL]     } [EOL]     while (it.hasNext()) { [EOL]         processNode(it.next(), element); [EOL]     } [EOL] } <line_num>: 335,386
private void processCase(Node node, JsonML currentParent, TagType type) { [EOL]     JsonML element = new JsonML(type); [EOL]     currentParent.appendChild(element); [EOL]     Node child = node.getFirstChild(); [EOL]     if (type == TagType.Case) { [EOL]         processNode(child, element); [EOL]         child = child.getNext(); [EOL]     } [EOL]     Preconditions.checkNotNull(child); [EOL]     Preconditions.checkState(child.getType() == Token.BLOCK); [EOL]     child = child.getFirstChild(); [EOL]     while (child != null) { [EOL]         processNode(child, element); [EOL]         child = child.getNext(); [EOL]     } [EOL] } <line_num>: 388,409
private void processCatch(Node node, JsonML currentParent) { [EOL]     JsonML element = new JsonML(TagType.CatchClause); [EOL]     currentParent.appendChild(element); [EOL]     Node child = node.getFirstChild(); [EOL]     JsonML patt = new JsonML(TagType.IdPatt); [EOL]     patt.setAttribute(TagAttr.NAME, child.getString()); [EOL]     element.appendChild(patt); [EOL]     child = child.getNext(); [EOL]     processNode(child, element); [EOL] } <line_num>: 411,424
private void processEmpty(Node node, JsonML currentParent) { [EOL]     if (currentParent.getType() == TagType.ArrayExpr) { [EOL]         currentParent.appendChild(new JsonML(TagType.Empty)); [EOL]     } else { [EOL]         currentParent.appendChild(new JsonML(TagType.EmptyStmt)); [EOL]     } [EOL] } <line_num>: 426,433
private void processExprResult(Node node, JsonML currentParent) { [EOL]     processNode(node.getFirstChild(), currentParent); [EOL] } <line_num>: 435,438
private void processForLoop(Node node, JsonML currentParent) { [EOL]     if (NodeUtil.isForIn(node)) { [EOL]         processLoop(node, currentParent, TagType.ForInStmt); [EOL]     } else { [EOL]         processLoop(node, currentParent, TagType.ForStmt); [EOL]     } [EOL] } <line_num>: 440,446
private void processFunction(Node node, JsonML currentParent) { [EOL]     JsonML element; [EOL]     if (NodeUtil.isFunctionDeclaration(node)) { [EOL]         element = new JsonML(TagType.FunctionDecl); [EOL]     } else { [EOL]         element = new JsonML(TagType.FunctionExpr); [EOL]     } [EOL]     currentParent.appendChild(element); [EOL]     Node child = node.getFirstChild(); [EOL]     String name = child.getString(); [EOL]     if (!name.equals("")) { [EOL]         JsonML nameElement = new JsonML(TagType.IdPatt); [EOL]         nameElement.setAttribute(TagAttr.NAME, name); [EOL]         element.appendChild(nameElement); [EOL]     } else { [EOL]         element.appendChild(new JsonML(TagType.Empty)); [EOL]     } [EOL]     child = child.getNext(); [EOL]     JsonML params = new JsonML(TagType.ParamDecl); [EOL]     element.appendChild(params); [EOL]     Iterator<Node> it = child.children().iterator(); [EOL]     while (it.hasNext()) { [EOL]         JsonML param = new JsonML(TagType.IdPatt); [EOL]         Node nameNode = it.next(); [EOL]         param.setAttribute(TagAttr.NAME, nameNode.getString()); [EOL]         params.appendChild(param); [EOL]     } [EOL]     child = child.getNext(); [EOL]     processDirectives(child, element); [EOL]     it = child.children().iterator(); [EOL]     while (it.hasNext()) { [EOL]         processNode(it.next(), element); [EOL]     } [EOL] } <line_num>: 448,490
private void processHook(Node node, JsonML currentParent) { [EOL]     JsonML element = new JsonML(TagType.ConditionalExpr); [EOL]     currentParent.appendChild(element); [EOL]     processChildren(node, element); [EOL] } <line_num>: 492,496
private void processIf(Node node, JsonML currentParent) { [EOL]     JsonML element = new JsonML(TagType.IfStmt); [EOL]     currentParent.appendChild(element); [EOL]     Iterator<Node> it = node.children().iterator(); [EOL]     while (it.hasNext()) { [EOL]         processNode(it.next(), element); [EOL]     } [EOL]     int childCount = node.getChildCount(); [EOL]     Preconditions.checkState(childCount >= 2); [EOL]     if (childCount < 3) { [EOL]         element.appendChild(new JsonML(TagType.EmptyStmt)); [EOL]     } [EOL] } <line_num>: 498,513
private void processIncrDecrExpr(Node node, JsonML currentParent, String op) { [EOL]     JsonML element = new JsonML(TagType.CountExpr); [EOL]     currentParent.appendChild(element); [EOL]     if (op.equals("++")) { [EOL]         element.setAttribute(TagAttr.OP, "++"); [EOL]     } else { [EOL]         element.setAttribute(TagAttr.OP, "--"); [EOL]     } [EOL]     if (node.getIntProp(Node.INCRDECR_PROP) == 1) { [EOL]         element.setAttribute(TagAttr.IS_PREFIX, false); [EOL]     } else { [EOL]         element.setAttribute(TagAttr.IS_PREFIX, true); [EOL]     } [EOL]     processNode(node.getFirstChild(), element); [EOL] } <line_num>: 515,533
private void processJmp(Node node, JsonML currentParent, TagType type) { [EOL]     JsonML element = new JsonML(type); [EOL]     currentParent.appendChild(element); [EOL]     Node child = node.getFirstChild(); [EOL]     if (child != null) { [EOL]         element.setAttribute(TagAttr.LABEL, child.getString()); [EOL]     } [EOL] } <line_num>: 535,545
private void processLabel(Node node, JsonML currentParent) { [EOL]     JsonML element = new JsonML(TagType.LabelledStmt); [EOL]     currentParent.appendChild(element); [EOL]     Node child = node.getFirstChild(); [EOL]     element.setAttribute(TagAttr.LABEL, child.getString()); [EOL]     child = child.getNext(); [EOL]     processNode(child, element); [EOL] } <line_num>: 547,558
private void processLiteral(Node node, JsonML currentParent) { [EOL]     JsonML element = new JsonML(TagType.LiteralExpr); [EOL]     switch(node.getType()) { [EOL]         case Token.NUMBER: [EOL]             element.setAttribute(TagAttr.TYPE, "number"); [EOL]             element.setAttribute(TagAttr.VALUE, node.getDouble()); [EOL]             break; [EOL]         case Token.STRING: [EOL]             element.setAttribute(TagAttr.TYPE, "string"); [EOL]             element.setAttribute(TagAttr.VALUE, node.getString()); [EOL]             break; [EOL]         case Token.NULL: [EOL]             element.setAttribute(TagAttr.TYPE, "null"); [EOL]             element.setAttribute(TagAttr.VALUE, null); [EOL]             break; [EOL]         case Token.TRUE: [EOL]             element.setAttribute(TagAttr.TYPE, "boolean"); [EOL]             element.setAttribute(TagAttr.VALUE, true); [EOL]             break; [EOL]         case Token.FALSE: [EOL]             element.setAttribute(TagAttr.TYPE, "boolean"); [EOL]             element.setAttribute(TagAttr.VALUE, false); [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("Illegal type of node."); [EOL]     } [EOL]     currentParent.appendChild(element); [EOL] } <line_num>: 560,587
private void processLogicalExpr(Node node, JsonML currentParent, String op) { [EOL]     if (op.equals("||")) { [EOL]         processTwoArgExpr(node, currentParent, TagType.LogicalOrExpr); [EOL]     } else if (op.endsWith("&&")) { [EOL]         processTwoArgExpr(node, currentParent, TagType.LogicalAndExpr); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Unsupported value of op argument."); [EOL]     } [EOL] } <line_num>: 589,598
private void processLoop(Node node, JsonML currentParent, TagType type) { [EOL]     JsonML element = new JsonML(type); [EOL]     currentParent.appendChild(element); [EOL]     processChildren(node, element); [EOL] } <line_num>: 600,605
private void processMemberExpr(Node node, JsonML currentParent, String op) { [EOL]     JsonML element = new JsonML(TagType.MemberExpr); [EOL]     element.setAttribute(TagAttr.OP, op); [EOL]     currentParent.appendChild(element); [EOL]     Node child = node.getFirstChild(); [EOL]     processNode(child, element); [EOL]     processNode(child.getNext(), element); [EOL] } <line_num>: 607,617
private void processName(Node node, JsonML currentParent) { [EOL]     Preconditions.checkState(!node.hasChildren()); [EOL]     JsonML element = new JsonML(TagType.IdExpr); [EOL]     element.setAttribute(TagAttr.NAME, node.getString()); [EOL]     currentParent.appendChild(element); [EOL] } <line_num>: 619,625
private void processNew(Node node, JsonML currentParent, TagType type) { [EOL]     JsonML element = new JsonML(type); [EOL]     currentParent.appendChild(element); [EOL]     processChildren(node, element); [EOL] } <line_num>: 627,632
private void processObjectLiteral(Node node, JsonML currentParent) { [EOL]     JsonML element = new JsonML(TagType.ObjectExpr); [EOL]     currentParent.appendChild(element); [EOL]     for (Node key : node.children()) { [EOL]         Node value = key.getFirstChild(); [EOL]         JsonML item; [EOL]         Object name; [EOL]         switch(key.getType()) { [EOL]             case Token.STRING_KEY: [EOL]                 item = new JsonML(TagType.DataProp); [EOL]                 name = key.getString(); [EOL]                 break; [EOL]             case Token.GETTER_DEF: [EOL]                 item = new JsonML(TagType.GetterProp); [EOL]                 name = key.getString(); [EOL]                 break; [EOL]             case Token.SETTER_DEF: [EOL]                 item = new JsonML(TagType.SetterProp); [EOL]                 name = key.getString(); [EOL]                 break; [EOL]             default: [EOL]                 throw new IllegalArgumentException("Illegal type of node."); [EOL]         } [EOL]         item.setAttribute(TagAttr.NAME, name); [EOL]         processNode(value, item); [EOL]         element.appendChild(item); [EOL]     } [EOL] } <line_num>: 634,661
private void processRegExp(Node node, JsonML currentParent) { [EOL]     JsonML element = new JsonML(TagType.RegExpExpr); [EOL]     currentParent.appendChild(element); [EOL]     Node child = node.getFirstChild(); [EOL]     element.setAttribute(TagAttr.BODY, child.getString()); [EOL]     String flags = ""; [EOL]     child = child.getNext(); [EOL]     if (child != null) { [EOL]         flags = child.getString(); [EOL]     } [EOL]     element.setAttribute(TagAttr.FLAGS, flags); [EOL] } <line_num>: 663,678
private void processSwitch(Node node, JsonML currentParent) { [EOL]     JsonML element = new JsonML(TagType.SwitchStmt); [EOL]     currentParent.appendChild(element); [EOL]     Node child = node.getFirstChild(); [EOL]     processNode(child, element); [EOL]     for (Node c = child.getNext(); c != null; c = c.getNext()) { [EOL]         processNode(c, element); [EOL]     } [EOL] } <line_num>: 680,692
private void processThis(Node node, JsonML currentParent) { [EOL]     currentParent.appendChild(new JsonML(TagType.ThisExpr)); [EOL] } <line_num>: 694,696
private void processThrow(Node node, JsonML currentParent) { [EOL]     JsonML element = new JsonML(TagType.ThrowStmt); [EOL]     currentParent.appendChild(element); [EOL]     processNode(node.getFirstChild(), element); [EOL] } <line_num>: 698,704
private void processTry(Node node, JsonML currentParent) { [EOL]     JsonML element = new JsonML(TagType.TryStmt); [EOL]     currentParent.appendChild(element); [EOL]     Node child = node.getFirstChild(); [EOL]     processNode(child, element); [EOL]     child = child.getNext(); [EOL]     if (child.hasChildren()) { [EOL]         processNode(child.getFirstChild(), element); [EOL]     } else { [EOL]         element.appendChild(new JsonML(TagType.Empty)); [EOL]     } [EOL]     child = child.getNext(); [EOL]     if (child != null) { [EOL]         processNode(child, element); [EOL]     } [EOL] } <line_num>: 706,727
private void processTwoArgExpr(Node node, JsonML currentParent, TagType type) { [EOL]     processTwoArgExpr(node, currentParent, type, null); [EOL] } <line_num>: 729,732
private void processTwoArgExpr(Node node, JsonML currentParent, TagType type, String op) { [EOL]     JsonML element = new JsonML(type); [EOL]     if (op != null) { [EOL]         element.setAttribute(TagAttr.OP, op); [EOL]     } [EOL]     currentParent.appendChild(element); [EOL]     Preconditions.checkState(node.getChildCount() == 2); [EOL]     Node child = node.getFirstChild(); [EOL]     processNode(child, element); [EOL]     processNode(child.getNext(), element); [EOL] } <line_num>: 734,746
private void processUnaryExpr(Node node, JsonML currentParent, String op) { [EOL]     JsonML element = new JsonML(TagType.UnaryExpr); [EOL]     element.setAttribute(TagAttr.OP, op); [EOL]     currentParent.appendChild(element); [EOL]     processNode(node.getFirstChild(), element); [EOL] } <line_num>: 753,760
private void processVar(Node node, JsonML currentParent) { [EOL]     JsonML element = new JsonML(TagType.VarDecl); [EOL]     currentParent.appendChild(element); [EOL]     Iterator<Node> it = node.children().iterator(); [EOL]     while (it.hasNext()) { [EOL]         Node child = it.next(); [EOL]         JsonML id = new JsonML(TagType.IdPatt); [EOL]         id.setAttribute(TagAttr.NAME, child.getString()); [EOL]         if (child.hasChildren()) { [EOL]             JsonML patt = new JsonML(TagType.InitPatt); [EOL]             element.appendChild(patt); [EOL]             patt.appendChild(id); [EOL]             processNode(child.getFirstChild(), patt); [EOL]         } else { [EOL]             element.appendChild(id); [EOL]         } [EOL]     } [EOL] } <line_num>: 762,784
private void processReturn(Node currentNode, JsonML currentParent) { [EOL]     JsonML element = new JsonML(TagType.ReturnStmt); [EOL]     currentParent.appendChild(element); [EOL]     if (currentNode.hasChildren()) { [EOL]         processNode(currentNode.getFirstChild(), element); [EOL]     } [EOL] } <line_num>: 786,794
private void processScript(Node node, JsonML currentParent) { [EOL]     JsonML element = new JsonML(TagType.Program); [EOL]     currentParent.appendChild(element); [EOL]     processDirectives(node, element); [EOL]     processChildren(node, element); [EOL] } <line_num>: 796,803
private void processWith(Node node, JsonML currentParent) { [EOL]     JsonML element = new JsonML(TagType.WithStmt); [EOL]     currentParent.appendChild(element); [EOL]     Node child = node.getFirstChild(); [EOL]     processNode(child, element); [EOL]     child = child.getNext(); [EOL]     processNode(child, element); [EOL] } <line_num>: 805,816
private void processChildren(Node node, JsonML currentParent) { [EOL]     for (Node child : node.children()) { [EOL]         processNode(child, currentParent); [EOL]     } [EOL] } <line_num>: 818,822
private void processDirectives(Node node, JsonML currentParent) { [EOL]     Set<String> directives = node.getDirectives(); [EOL]     if (directives == null) { [EOL]         return; [EOL]     } [EOL]     for (String directive : directives) { [EOL]         JsonML element = new JsonML(TagType.PrologueDecl); [EOL]         element.setAttribute(TagAttr.DIRECTIVE, directive); [EOL]         element.setAttribute(TagAttr.VALUE, directive); [EOL]         currentParent.appendChild(element); [EOL]     } [EOL] } <line_num>: 824,837
private void processOneArgExpr(Node node, JsonML currentParent, TagType type) { [EOL]     JsonML element = new JsonML(type); [EOL]     currentParent.appendChild(element); [EOL]     processNode(node.getFirstChild(), element); [EOL] } <line_num>: 839,846
