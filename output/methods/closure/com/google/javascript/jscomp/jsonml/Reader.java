ErrorReporter(AbstractCompiler compiler) { [EOL]     this.compiler = compiler; [EOL] } <line_num>: 66,68
private Operator(String name) { [EOL]     this.name = name; [EOL] } <line_num>: 1333,1335
private Type(String name) { [EOL]     this.name = name; [EOL] } <line_num>: 1557,1559
private void report(JsonML element, String... arguments) throws JsonMLException { [EOL]     report(JSONML_SYNTAX, element, arguments); [EOL] } <line_num>: 70,73
private void report(DiagnosticType type, JsonML element, String... arguments) throws JsonMLException { [EOL]     int lineno = nodeIndex; [EOL]     int charno = -1; [EOL]     report(JSError.make(sourceName, lineno, charno, type, arguments)); [EOL] } <line_num>: 75,83
private void report(JSError error) throws JsonMLException { [EOL]     report(error, true); [EOL] } <line_num>: 89,91
private void report(JSError error, boolean terminal) throws JsonMLException { [EOL]     compiler.report(error); [EOL]     if (terminal) { [EOL]         throw new JsonMLException(); [EOL]     } [EOL] } <line_num>: 99,105
public void setRootElement(JsonML rootElement) { [EOL]     this.rootElement = rootElement; [EOL] } <line_num>: 116,118
public Node parse(AbstractCompiler compiler) throws JsonMLException { [EOL]     if (compiler == null) { [EOL]         return null; [EOL]     } [EOL]     errorReporter = this.new ErrorReporter(compiler); [EOL]     Node root = IR.block(); [EOL]     nodeIndex = -1; [EOL]     Preconditions.checkState(rootElement.getType() == TagType.Program); [EOL]     transformElement(rootElement, root); [EOL]     return root.removeFirstChild(); [EOL] } <line_num>: 125,139
private <T> T getOptionalAttribute(JsonML element, TagAttr attr, Class<T> type) throws JsonMLException { [EOL]     return getAttribute(element, attr, type, true); [EOL] } <line_num>: 148,151
private <T> T getAttribute(JsonML element, TagAttr attr, Class<T> type) throws JsonMLException { [EOL]     return getAttribute(element, attr, type, false); [EOL] } <line_num>: 160,163
private <T> T getAttribute(JsonML element, TagAttr attr, Class<T> type, boolean optional) throws JsonMLException { [EOL]     Object value = element.getAttribute(attr); [EOL]     if (value == null) { [EOL]         if (type == null || optional) { [EOL]             return null; [EOL]         } [EOL]         throw new JsonMLException("Missing " + attr.name() + " attribute for " + element.getType().name() + " element."); [EOL]     } [EOL]     if (type.equals(Double.class)) { [EOL]         if (value instanceof Number) { [EOL]             return type.cast(((Number) value).doubleValue()); [EOL]         } [EOL]         if (value instanceof String) { [EOL]             return type.cast(Double.valueOf((String) value)); [EOL]         } [EOL]         throw new JsonMLException("Wrong type of " + attr.name() + " attribute. " + "Received: " + value.getClass() + ". Expected: " + type.getName()); [EOL]     } [EOL]     if (type.isInstance(value)) { [EOL]         return type.cast(value); [EOL]     } [EOL]     throw new JsonMLException("Wrong type of " + attr.name() + "attribute. " + "Received: " + value.getClass() + ". Expected: " + type.getName()); [EOL] } <line_num>: 165,201
private Object getObjectAttribute(JsonML element, TagAttr attr) throws JsonMLException { [EOL]     return getAttribute(element, attr, Object.class); [EOL] } <line_num>: 206,209
private String getStringAttribute(JsonML element, TagAttr attr) throws JsonMLException { [EOL]     return getAttribute(element, attr, String.class); [EOL] } <line_num>: 214,217
private void validate(JsonML element) throws JsonMLException { [EOL]     String errorMessage = Validator.validate(element); [EOL]     if (errorMessage != null) { [EOL]         errorReporter.report(element, errorMessage); [EOL]     } [EOL] } <line_num>: 219,224
private void transformElement(JsonML element, Node parent) throws JsonMLException { [EOL]     nodeIndex++; [EOL]     validate(element); [EOL]     if (insertExprResultState && JsonMLUtil.isExpression(element)) { [EOL]         transformExpr(element, parent); [EOL]         return; [EOL]     } [EOL]     switch(element.getType()) { [EOL]         case ArrayExpr: [EOL]             transformArrayExpr(element, parent); [EOL]             break; [EOL]         case AssignExpr: [EOL]             transformAssignExpr(element, parent); [EOL]             break; [EOL]         case BinaryExpr: [EOL]             transformBinaryExpr(element, parent); [EOL]             break; [EOL]         case BlockStmt: [EOL]             transformBlock(element, parent); [EOL]             break; [EOL]         case BreakStmt: [EOL]             transformBreakStmt(element, parent); [EOL]             break; [EOL]         case CallExpr: [EOL]             transformCallExpr(element, parent); [EOL]             break; [EOL]         case Case: [EOL]             transformCase(element, parent); [EOL]             break; [EOL]         case CatchClause: [EOL]             transformCatchClause(element, parent); [EOL]             break; [EOL]         case ConditionalExpr: [EOL]             transformConditionalExpr(element, parent); [EOL]             break; [EOL]         case ContinueStmt: [EOL]             transformContinueStmt(element, parent); [EOL]             break; [EOL]         case CountExpr: [EOL]             transformCountExpr(element, parent); [EOL]             break; [EOL]         case DataProp: [EOL]             transformDataProp(element, parent); [EOL]             break; [EOL]         case GetterProp: [EOL]             transformGetterProp(element, parent); [EOL]             break; [EOL]         case SetterProp: [EOL]             transformSetterProp(element, parent); [EOL]             break; [EOL]         case DefaultCase: [EOL]             transformDefaultCase(element, parent); [EOL]             break; [EOL]         case DeleteExpr: [EOL]             transformDeleteExpr(element, parent); [EOL]             break; [EOL]         case DoWhileStmt: [EOL]             transformDoWhileStmt(element, parent); [EOL]             break; [EOL]         case Empty: [EOL]             transformEmpty(element, parent); [EOL]             break; [EOL]         case EmptyStmt: [EOL]             transformEmptyStmt(element, parent); [EOL]             break; [EOL]         case EvalExpr: [EOL]             transformEvalExpr(element, parent); [EOL]             break; [EOL]         case ForInStmt: [EOL]             transformForInStmt(element, parent); [EOL]             break; [EOL]         case ForStmt: [EOL]             transformForStmt(element, parent); [EOL]             break; [EOL]         case FunctionDecl: [EOL]             transformFunctionDecl(element, parent); [EOL]             break; [EOL]         case FunctionExpr: [EOL]             transformFunctionExpr(element, parent); [EOL]             break; [EOL]         case IdExpr: [EOL]             transformIdExpr(element, parent); [EOL]             break; [EOL]         case IdPatt: [EOL]             transformIdPatt(element, parent); [EOL]             break; [EOL]         case IfStmt: [EOL]             transformIfStmt(element, parent); [EOL]             break; [EOL]         case InitPatt: [EOL]             transformInitPatt(element, parent); [EOL]             break; [EOL]         case InvokeExpr: [EOL]             transformInvokeExpr(element, parent); [EOL]             break; [EOL]         case LabelledStmt: [EOL]             transformLabelledStmt(element, parent); [EOL]             break; [EOL]         case LiteralExpr: [EOL]             transformLiteralExpr(element, parent); [EOL]             break; [EOL]         case LogicalAndExpr: [EOL]             transformLogicalAndExpr(element, parent); [EOL]             break; [EOL]         case LogicalOrExpr: [EOL]             transformLogicalOrExpr(element, parent); [EOL]             break; [EOL]         case MemberExpr: [EOL]             transformMemberExpr(element, parent); [EOL]             break; [EOL]         case NewExpr: [EOL]             transformNewExpr(element, parent); [EOL]             break; [EOL]         case ObjectExpr: [EOL]             transformObjectExpr(element, parent); [EOL]             break; [EOL]         case ParamDecl: [EOL]             transformParamDecl(element, parent); [EOL]             break; [EOL]         case Program: [EOL]             transformProgram(element, parent); [EOL]             break; [EOL]         case PrologueDecl: [EOL]             transformPrologueDecl(element, parent); [EOL]             break; [EOL]         case RegExpExpr: [EOL]             transformRegExpExpr(element, parent); [EOL]             break; [EOL]         case ReturnStmt: [EOL]             transformReturnStmt(element, parent); [EOL]             break; [EOL]         case SwitchStmt: [EOL]             transformSwitchStmt(element, parent); [EOL]             break; [EOL]         case ThisExpr: [EOL]             transformThisExpr(element, parent); [EOL]             break; [EOL]         case ThrowStmt: [EOL]             transformThrowStmt(element, parent); [EOL]             break; [EOL]         case TryStmt: [EOL]             transformTryStmt(element, parent); [EOL]             break; [EOL]         case TypeofExpr: [EOL]             transformTypeofExpr(element, parent); [EOL]             break; [EOL]         case UnaryExpr: [EOL]             transformUnaryExpr(element, parent); [EOL]             break; [EOL]         case VarDecl: [EOL]             transformVarDecl(element, parent); [EOL]             break; [EOL]         case WhileStmt: [EOL]             transformWhileStmt(element, parent); [EOL]             break; [EOL]         case WithStmt: [EOL]             transformWithStmt(element, parent); [EOL]             break; [EOL]     } [EOL] } <line_num>: 234,400
private void transformAllChildren(JsonML element, Node parent, boolean newState) throws JsonMLException { [EOL]     transformElements(element.getChildren(), parent, newState); [EOL] } <line_num>: 407,410
private void transformAllChildren(JsonML element, Node parent) throws JsonMLException { [EOL]     transformElements(element.getChildren(), parent); [EOL] } <line_num>: 412,415
private void transformAllChildrenFromIndex(JsonML element, Node parent, int fromIndex, boolean newState) throws JsonMLException { [EOL]     transformElements(element.getChildren().subList(fromIndex, element.childrenSize()), parent, newState); [EOL] } <line_num>: 417,421
private void transformElements(List<JsonML> elements, Node parent, boolean newState) throws JsonMLException { [EOL]     boolean oldState = insertExprResultState; [EOL]     insertExprResultState = newState; [EOL]     transformElements(elements, parent); [EOL]     insertExprResultState = oldState; [EOL] } <line_num>: 423,429
private void transformElements(List<JsonML> elements, Node parent) throws JsonMLException { [EOL]     for (JsonML element : elements) { [EOL]         transformElement(element, parent); [EOL]     } [EOL] } <line_num>: 431,436
private boolean transformExpr(JsonML element, Node parent) throws JsonMLException { [EOL]     boolean result = false; [EOL]     if (insertExprResultState) { [EOL]         Node node = new Node(Token.EXPR_RESULT); [EOL]         parent.addChildToBack(node); [EOL]         insertExprResultState = false; [EOL]         nodeIndex--; [EOL]         transformElement(element, node); [EOL]         insertExprResultState = true; [EOL]         result = true; [EOL]     } [EOL]     return result; [EOL] } <line_num>: 441,454
private void transformForLoop(JsonML element, Node parent, int childno) throws JsonMLException { [EOL]     Preconditions.checkState(insertExprResultState == true); [EOL]     insertExprResultState = false; [EOL]     Node node = createNode(Token.FOR, element); [EOL]     parent.addChildToBack(node); [EOL]     JsonML child; [EOL]     for (int i = 0; i < childno; ++i) { [EOL]         child = element.getChild(i); [EOL]         if (child.getType() == TagType.EmptyStmt || child.getType() == TagType.Empty) { [EOL]             nodeIndex++; [EOL]             node.addChildToBack(IR.empty()); [EOL]         } else { [EOL]             transformElement(child, node); [EOL]         } [EOL]     } [EOL]     transformPotentiallyUnwrappedBlock(element.getChild(childno), node); [EOL]     insertExprResultState = true; [EOL] } <line_num>: 460,482
private void transformJumpStmt(JsonML element, Node parent, int type) throws JsonMLException { [EOL]     Node node = createNode(type, element); [EOL]     parent.addChildToBack(node); [EOL]     String label = getOptionalAttribute(element, TagAttr.LABEL, String.class); [EOL]     if (label != null) { [EOL]         node.addChildToBack(IR.labelName(label)); [EOL]     } [EOL] } <line_num>: 488,497
private void transformLogicalExpr(JsonML element, Node parent, int type) throws JsonMLException { [EOL]     transformTwoArgumentExpr(element, parent, type); [EOL] } <line_num>: 503,506
private void transformTwoArgumentExpr(JsonML element, Node parent, int type) throws JsonMLException { [EOL]     Node node = createNode(type, element); [EOL]     parent.addChildToBack(node); [EOL]     transformAllChildren(element, node); [EOL] } <line_num>: 512,517
private void transformPotentiallyUnwrappedBlock(JsonML element, Node parent) throws JsonMLException { [EOL]     if (element.getType() == TagType.EmptyStmt || element.getType() == TagType.Empty) { [EOL]         nodeIndex++; [EOL]         Node block = IR.block(); [EOL]         parent.addChildToBack(block); [EOL]         block.putBooleanProp(Node.EMPTY_BLOCK, true); [EOL]     } else if (element.getType() != TagType.BlockStmt) { [EOL]         Node block = IR.block(); [EOL]         parent.addChildToBack(block); [EOL]         boolean state = insertExprResultState; [EOL]         insertExprResultState = true; [EOL]         transformElement(element, block); [EOL]         insertExprResultState = state; [EOL]     } else { [EOL]         nodeIndex++; [EOL]         transformBlock(element, parent); [EOL]     } [EOL] } <line_num>: 524,547
private void transformArrayExpr(JsonML element, Node parent) throws JsonMLException { [EOL]     Node node = createNode(Token.ARRAYLIT, element); [EOL]     parent.addChildToBack(node); [EOL]     for (JsonML child : element.getChildren()) { [EOL]         transformElement(child, node); [EOL]     } [EOL] } <line_num>: 556,566
private void transformAssignExpr(JsonML element, Node parent) throws JsonMLException { [EOL]     String op = getStringAttribute(element, TagAttr.OP); [EOL]     int type = Operator.getNodeTypeForAssignOp(op); [EOL]     transformTwoArgumentExpr(element, parent, type); [EOL] } <line_num>: 568,573
private void transformBinaryExpr(JsonML element, Node parent) throws JsonMLException { [EOL]     String op = getStringAttribute(element, TagAttr.OP); [EOL]     int type = Operator.getNodeTypeForBinaryOp(op); [EOL]     transformTwoArgumentExpr(element, parent, type); [EOL] } <line_num>: 575,580
private void transformBlock(JsonML element, Node parent) throws JsonMLException { [EOL]     transformBlock(element, parent, 0, element.childrenSize()); [EOL] } <line_num>: 582,585
private void transformBlock(JsonML element, Node parent, int start) throws JsonMLException { [EOL]     transformBlock(element, parent, start, element.childrenSize()); [EOL] } <line_num>: 587,590
private void transformBlock(JsonML element, Node parent, int start, int end) throws JsonMLException { [EOL]     Node node = createNode(Token.BLOCK, element); [EOL]     parent.addChildToBack(node); [EOL]     transformElements(element.getChildren(start, end), node, true); [EOL] } <line_num>: 592,597
private void transformBreakStmt(JsonML element, Node parent) throws JsonMLException { [EOL]     transformJumpStmt(element, parent, Token.BREAK); [EOL] } <line_num>: 599,602
private void transformCallExpr(JsonML element, Node parent) throws JsonMLException { [EOL]     Node node = createNode(Token.CALL, element); [EOL]     parent.addChildToBack(node); [EOL]     transformAllChildren(element, node); [EOL]     Node first = node.getFirstChild(); [EOL]     if (first.getType() != Token.GETPROP && first.getType() != Token.GETELEM) { [EOL]         node.putBooleanProp(Node.FREE_CALL, true); [EOL]     } [EOL] } <line_num>: 604,618
private void transformCase(JsonML element, Node parent) throws JsonMLException { [EOL]     Node node = createNode(Token.CASE, element); [EOL]     parent.addChildToBack(node); [EOL]     JsonML child = element.getChild(0); [EOL]     transformElement(child, node); [EOL]     Node block = IR.block(); [EOL]     block.setIsSyntheticBlock(true); [EOL]     node.addChildToBack(block); [EOL]     transformAllChildrenFromIndex(element, block, 1, true); [EOL] } <line_num>: 620,636
private void transformCatchClause(JsonML element, Node parent) throws JsonMLException { [EOL]     Node node = createNode(Token.CATCH, element); [EOL]     parent.addChildToBack(node); [EOL]     JsonML child = element.getChild(0); [EOL]     transformElement(child, node); [EOL]     child = element.getChild(1); [EOL]     transformElement(child, node); [EOL] } <line_num>: 638,650
private void transformConditionalExpr(JsonML element, Node parent) throws JsonMLException { [EOL]     Node node = createNode(Token.HOOK, element); [EOL]     parent.addChildToBack(node); [EOL]     transformAllChildren(element, node); [EOL] } <line_num>: 652,658
private void transformContinueStmt(JsonML element, Node parent) throws JsonMLException { [EOL]     transformJumpStmt(element, parent, Token.CONTINUE); [EOL] } <line_num>: 660,663
private void transformCountExpr(JsonML element, Node parent) throws JsonMLException { [EOL]     String op = getStringAttribute(element, TagAttr.OP); [EOL]     int type = Operator.getNodeTypeForCountOp(op); [EOL]     Boolean isPrefix = getAttribute(element, TagAttr.IS_PREFIX, Boolean.class); [EOL]     Node node = createNode(type, element); [EOL]     node.putIntProp(Node.INCRDECR_PROP, isPrefix ? 0 : 1); [EOL]     parent.addChildToBack(node); [EOL]     transformElement(element.getChild(0), node); [EOL] } <line_num>: 668,680
private void transformDataProp(JsonML element, Node parent) throws JsonMLException { [EOL]     Object name = getObjectAttribute(element, TagAttr.NAME); [EOL]     Node node = null; [EOL]     if (name instanceof Number) { [EOL]         node = IR.stringKey(getStringValue(((Number) name).doubleValue())); [EOL]     } else if (name instanceof String) { [EOL]         node = IR.stringKey((String) name); [EOL]     } else { [EOL]         throw new IllegalStateException("The name of the property has invalid type."); [EOL]     } [EOL]     setPosition(node); [EOL]     parent.addChildToBack(node); [EOL]     transformElement(element.getChild(0), node); [EOL] } <line_num>: 688,706
private static String getStringValue(double value) { [EOL]     long longValue = (long) value; [EOL]     if (longValue == value) { [EOL]         return Long.toString(longValue); [EOL]     } else { [EOL]         return Double.toString(value); [EOL]     } [EOL] } <line_num>: 708,717
private void transformGetterProp(JsonML element, Node parent) throws JsonMLException { [EOL]     transformProp(Token.GETTER_DEF, element, parent); [EOL] } <line_num>: 723,726
private void transformSetterProp(JsonML element, Node parent) throws JsonMLException { [EOL]     transformProp(Token.SETTER_DEF, element, parent); [EOL] } <line_num>: 732,735
private void transformProp(int tokenType, JsonML element, Node parent) throws JsonMLException { [EOL]     Object name = getObjectAttribute(element, TagAttr.NAME); [EOL]     Node node = null; [EOL]     if (name instanceof Number) { [EOL]         throw new IllegalStateException("Not yet supported."); [EOL]     } else if (name instanceof String) { [EOL]         node = Node.newString(tokenType, (String) name); [EOL]     } else { [EOL]         throw new IllegalStateException("The name of the property has invalid type."); [EOL]     } [EOL]     setPosition(node); [EOL]     parent.addChildToBack(node); [EOL]     transformElement(element.getChild(0), node); [EOL] } <line_num>: 737,757
private void transformDefaultCase(JsonML element, Node parent) throws JsonMLException { [EOL]     Node node = createNode(Token.DEFAULT_CASE, element); [EOL]     parent.addChildToBack(node); [EOL]     Node block = IR.block(); [EOL]     block.setIsSyntheticBlock(true); [EOL]     node.addChildToBack(block); [EOL]     transformAllChildren(element, block, true); [EOL] } <line_num>: 760,771
private void transformDeleteExpr(JsonML element, Node parent) throws JsonMLException { [EOL]     Node node = createNode(Token.DELPROP, element); [EOL]     parent.addChildToBack(node); [EOL]     transformElement(element.getChild(0), node); [EOL] } <line_num>: 773,780
private void transformDoWhileStmt(JsonML element, Node parent) throws JsonMLException { [EOL]     Preconditions.checkState(insertExprResultState == true); [EOL]     insertExprResultState = false; [EOL]     Node node = createNode(Token.DO, element); [EOL]     parent.addChildToBack(node); [EOL]     JsonML child = element.getChild(0); [EOL]     transformPotentiallyUnwrappedBlock(child, node); [EOL]     child = element.getChild(1); [EOL]     transformElement(child, node); [EOL]     insertExprResultState = true; [EOL] } <line_num>: 782,799
private void transformEmpty(JsonML element, Node parent) { [EOL]     switch(parent.getType()) { [EOL]         case Token.ARRAYLIT: [EOL]             parent.addChildToBack(IR.empty()); [EOL]             break; [EOL]         case Token.FUNCTION: [EOL]             parent.addChildToBack(IR.name("")); [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("Unexpected Empty element."); [EOL]     } [EOL] } <line_num>: 801,812
private void transformEmptyStmt(JsonML element, Node parent) { [EOL]     Preconditions.checkState(parent.getType() == Token.BLOCK || parent.getType() == Token.SCRIPT); [EOL]     parent.addChildToBack(IR.empty()); [EOL] } <line_num>: 814,818
private void transformEvalExpr(JsonML element, Node parent) throws JsonMLException { [EOL]     Node node = createNode(Token.CALL, element); [EOL]     node.putBooleanProp(Node.FREE_CALL, true); [EOL]     parent.addChildToBack(node); [EOL]     Node child = IR.name("eval"); [EOL]     child.putBooleanProp(Node.DIRECT_EVAL, true); [EOL]     node.addChildToBack(child); [EOL]     transformAllChildren(element, node); [EOL] } <line_num>: 820,832
private void transformForInStmt(JsonML element, Node parent) throws JsonMLException { [EOL]     transformForLoop(element, parent, 2); [EOL] } <line_num>: 834,837
private void transformForStmt(JsonML element, Node parent) throws JsonMLException { [EOL]     transformForLoop(element, parent, 3); [EOL] } <line_num>: 839,842
private void transformFunction(JsonML element, Node parent, boolean needsName) throws JsonMLException { [EOL]     Node node = createNode(Token.FUNCTION, element); [EOL]     parent.addChildToBack(node); [EOL]     JsonML child = element.getChild(0); [EOL]     String name = ""; [EOL]     transformElement(element.getChild(0), node); [EOL]     transformElement(element.getChild(1), node); [EOL]     transformBlock(element, node, 2); [EOL] } <line_num>: 844,861
private void transformFunctionDecl(JsonML element, Node parent) throws JsonMLException { [EOL]     transformFunction(element, parent, true); [EOL] } <line_num>: 863,866
private void transformFunctionExpr(JsonML element, Node parent) throws JsonMLException { [EOL]     transformFunction(element, parent, false); [EOL] } <line_num>: 868,871
private void transformIdExpr(JsonML element, Node parent) throws JsonMLException { [EOL]     String name = getStringAttribute(element, TagAttr.NAME); [EOL]     Node node = IR.name(name); [EOL]     setPosition(node); [EOL]     parent.addChildToBack(node); [EOL] } <line_num>: 873,879
private void transformInitPatt(JsonML element, Node parent) throws JsonMLException { [EOL]     JsonML child = element.getChild(0); [EOL]     nodeIndex++; [EOL]     Node node = IR.name(getAttribute(child, TagAttr.NAME, String.class)); [EOL]     setPosition(node); [EOL]     parent.addChildToBack(node); [EOL]     child = element.getChild(1); [EOL]     transformElement(child, node); [EOL] } <line_num>: 885,896
private void transformIdPatt(JsonML element, Node parent) throws JsonMLException { [EOL]     Node node = IR.name(getStringAttribute(element, TagAttr.NAME)); [EOL]     setPosition(node); [EOL]     parent.addChildToBack(node); [EOL] } <line_num>: 898,904
private void transformIfStmt(JsonML element, Node parent) throws JsonMLException { [EOL]     Preconditions.checkState(insertExprResultState == true); [EOL]     insertExprResultState = false; [EOL]     Node node = createNode(Token.IF, element); [EOL]     parent.addChildToBack(node); [EOL]     JsonML child = element.getChild(0); [EOL]     transformElement(child, node); [EOL]     child = element.getChild(1); [EOL]     transformPotentiallyUnwrappedBlock(child, node); [EOL]     child = element.getChild(2); [EOL]     if (child.getType() != TagType.EmptyStmt && child.getType() != TagType.Empty) { [EOL]         transformPotentiallyUnwrappedBlock(child, node); [EOL]     } else { [EOL]         nodeIndex++; [EOL]     } [EOL]     insertExprResultState = true; [EOL] } <line_num>: 906,931
private void transformInvokeExpr(JsonML element, Node parent) throws JsonMLException { [EOL]     Node node = createNode(Token.CALL, element); [EOL]     parent.addChildToBack(node); [EOL]     transformMemberExpr(element, node); [EOL]     transformElements(element.getChildren(2, element.childrenSize()), node); [EOL] } <line_num>: 933,941
private void transformLabelledStmt(JsonML element, Node parent) throws JsonMLException { [EOL]     String label = getStringAttribute(element, TagAttr.LABEL); [EOL]     Node node = createNode(Token.LABEL, element); [EOL]     node.addChildToBack(IR.labelName(label)); [EOL]     parent.addChildToBack(node); [EOL]     JsonML child = element.getChild(0); [EOL]     if (child.getType() == TagType.EmptyStmt) { [EOL]         nodeIndex++; [EOL]         node.addChildToBack(IR.empty()); [EOL]     } else { [EOL]         transformElement(element.getChild(0), node); [EOL]     } [EOL] } <line_num>: 943,957
private void transformLiteralExpr(JsonML element, Node parent) throws JsonMLException { [EOL]     Node node = null; [EOL]     Type type = Type.get(getStringAttribute(element, TagAttr.TYPE)); [EOL]     switch(type) { [EOL]         case BOOLEAN: [EOL]             { [EOL]                 Boolean value = getAttribute(element, TagAttr.VALUE, Boolean.class); [EOL]                 if (value) { [EOL]                     node = IR.trueNode(); [EOL]                 } else { [EOL]                     node = IR.falseNode(); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         case NULL: [EOL]             { [EOL]                 getAttribute(element, TagAttr.VALUE, null); [EOL]                 node = IR.nullNode(); [EOL]                 break; [EOL]             } [EOL]         case NUMBER: [EOL]             { [EOL]                 Double value = getAttribute(element, TagAttr.VALUE, Double.class); [EOL]                 node = IR.number(value); [EOL]                 break; [EOL]             } [EOL]         case STRING: [EOL]             { [EOL]                 String value = getStringAttribute(element, TagAttr.VALUE); [EOL]                 node = IR.string(value); [EOL]                 break; [EOL]             } [EOL]         default: [EOL]             throw new JsonMLException("Unrecognized type attribute."); [EOL]     } [EOL]     setPosition(node); [EOL]     parent.addChildToBack(node); [EOL] } <line_num>: 959,1000
private void transformLogicalAndExpr(JsonML element, Node parent) throws JsonMLException { [EOL]     transformLogicalExpr(element, parent, Token.AND); [EOL] } <line_num>: 1002,1005
private void transformLogicalOrExpr(JsonML element, Node parent) throws JsonMLException { [EOL]     transformLogicalExpr(element, parent, Token.OR); [EOL] } <line_num>: 1007,1010
private void transformMemberExpr(JsonML element, Node parent) throws JsonMLException { [EOL]     String op = getAttribute(element, TagAttr.OP, String.class); [EOL]     int type; [EOL]     if (op.equals(".")) { [EOL]         type = Token.GETPROP; [EOL]     } else if (op.equals("[]")) { [EOL]         type = Token.GETELEM; [EOL]     } else { [EOL]         throw new JsonMLException("Invalid OP argument: " + op); [EOL]     } [EOL]     Node node = createNode(type, element); [EOL]     parent.addChildToBack(node); [EOL]     transformElement(element.getChild(0), node); [EOL]     transformElement(element.getChild(1), node); [EOL] } <line_num>: 1012,1030
private void transformNewExpr(JsonML element, Node parent) throws JsonMLException { [EOL]     Node node = createNode(Token.NEW, element); [EOL]     parent.addChildToBack(node); [EOL]     transformAllChildren(element, node); [EOL] } <line_num>: 1032,1037
private void transformObjectExpr(JsonML element, Node parent) throws JsonMLException { [EOL]     Node node = createNode(Token.OBJECTLIT, element); [EOL]     parent.addChildToBack(node); [EOL]     transformAllChildren(element, node); [EOL] } <line_num>: 1039,1045
private void transformParamDecl(JsonML element, Node parent) throws JsonMLException { [EOL]     Node node = createNode(Token.PARAM_LIST, element); [EOL]     parent.addChildToBack(node); [EOL]     transformAllChildren(element, node); [EOL] } <line_num>: 1047,1054
private void transformProgram(JsonML element, Node parent) throws JsonMLException { [EOL]     Preconditions.checkNotNull(parent); [EOL]     insertExprResultState = true; [EOL]     Node script = IR.script(); [EOL]     parent.addChildToBack(script); [EOL]     for (JsonML child : element.getChildren()) { [EOL]         transformElement(child, script); [EOL]     } [EOL] } <line_num>: 1056,1067
private void transformPrologueDecl(JsonML element, Node parent) throws JsonMLException { [EOL]     String directive = getStringAttribute(element, TagAttr.DIRECTIVE); [EOL]     if (ALLOWED_DIRECTIVES.contains(directive)) { [EOL]         Set<String> directives = parent.getDirectives(); [EOL]         if (directives == null) { [EOL]             directives = Sets.newHashSet(); [EOL]         } [EOL]         directives.add(directive); [EOL]         parent.setDirectives(directives); [EOL]     } else { [EOL]         Node node = IR.exprResult(IR.string(directive)); [EOL]         parent.addChildToBack(node); [EOL]     } [EOL] } <line_num>: 1069,1085
private void transformRegExpExpr(JsonML element, Node parent) throws JsonMLException { [EOL]     Node node = createNode(Token.REGEXP, element); [EOL]     parent.addChildToBack(node); [EOL]     String body = getStringAttribute(element, TagAttr.BODY); [EOL]     node.addChildToBack(IR.string(body)); [EOL]     String flags = getStringAttribute(element, TagAttr.FLAGS); [EOL]     if (!(flags.equals(""))) { [EOL]         node.addChildToBack(IR.string(flags)); [EOL]     } [EOL] } <line_num>: 1087,1099
private void transformReturnStmt(JsonML element, Node parent) throws JsonMLException { [EOL]     Preconditions.checkState(insertExprResultState == true); [EOL]     Node node = createNode(Token.RETURN, element); [EOL]     parent.addChildToBack(node); [EOL]     if (element.hasChildren()) { [EOL]         insertExprResultState = false; [EOL]         transformElement(element.getChild(0), node); [EOL]         insertExprResultState = true; [EOL]     } [EOL] } <line_num>: 1101,1112
private void transformSwitchStmt(JsonML element, Node parent) throws JsonMLException { [EOL]     Preconditions.checkState(insertExprResultState == true); [EOL]     insertExprResultState = false; [EOL]     Node node = createNode(Token.SWITCH, element); [EOL]     parent.addChildToBack(node); [EOL]     JsonML child = element.getChild(0); [EOL]     transformElement(child, node); [EOL]     for (int i = 1; i < element.childrenSize(); ++i) { [EOL]         child = element.getChild(i); [EOL]         transformElement(child, node); [EOL]     } [EOL]     insertExprResultState = true; [EOL] } <line_num>: 1114,1135
private void transformThisExpr(JsonML element, Node parent) throws JsonMLException { [EOL]     parent.addChildToBack(createNode(Token.THIS, element)); [EOL] } <line_num>: 1140,1143
private void transformThrowStmt(JsonML element, Node parent) throws JsonMLException { [EOL]     Preconditions.checkState(insertExprResultState == true); [EOL]     Node node = createNode(Token.THROW, element); [EOL]     parent.addChildToBack(node); [EOL]     insertExprResultState = false; [EOL]     transformElement(element.getChild(0), node); [EOL]     insertExprResultState = true; [EOL] } <line_num>: 1145,1154
private void transformTryStmt(JsonML element, Node parent) throws JsonMLException { [EOL]     Preconditions.checkState(insertExprResultState == true); [EOL]     Node node = createNode(Token.TRY, element); [EOL]     parent.addChildToBack(node); [EOL]     JsonML child = element.getChild(0); [EOL]     transformElement(child, node); [EOL]     Node block = IR.block(); [EOL]     node.addChildToBack(block); [EOL]     child = element.getChild(1); [EOL]     if (child.getType() == TagType.CatchClause) { [EOL]         transformElement(child, block); [EOL]     } else { [EOL]         nodeIndex++; [EOL]     } [EOL]     if (element.childrenSize() == 3) { [EOL]         child = element.getChild(2); [EOL]         transformElement(child, node); [EOL]     } [EOL] } <line_num>: 1156,1183
private void transformTypeofExpr(JsonML element, Node parent) throws JsonMLException { [EOL]     Node node = createNode(Token.TYPEOF, element); [EOL]     parent.addChildToBack(node); [EOL]     transformElement(element.getChild(0), node); [EOL] } <line_num>: 1185,1190
private void transformUnaryExpr(JsonML element, Node parent) throws JsonMLException { [EOL]     String op = getStringAttribute(element, TagAttr.OP); [EOL]     int type = Operator.getNodeTypeForUnaryOp(op); [EOL]     Node node = createNode(type, element); [EOL]     parent.addChildToBack(node); [EOL]     transformAllChildren(element, node); [EOL] } <line_num>: 1192,1201
private void transformVarDecl(JsonML element, Node parent) throws JsonMLException { [EOL]     Node node = createNode(Token.VAR, element); [EOL]     parent.addChildToBack(node); [EOL]     transformAllChildren(element, node, false); [EOL] } <line_num>: 1203,1209
private void transformWhileStmt(JsonML element, Node parent) throws JsonMLException { [EOL]     Preconditions.checkState(insertExprResultState == true); [EOL]     insertExprResultState = false; [EOL]     Node node = createNode(Token.WHILE, element); [EOL]     parent.addChildToBack(node); [EOL]     JsonML child = element.getChild(0); [EOL]     transformElement(child, node); [EOL]     child = element.getChild(1); [EOL]     transformPotentiallyUnwrappedBlock(child, node); [EOL]     insertExprResultState = true; [EOL] } <line_num>: 1211,1228
private void transformWithStmt(JsonML element, Node parent) throws JsonMLException { [EOL]     Preconditions.checkState(insertExprResultState == true); [EOL]     insertExprResultState = false; [EOL]     Node node = createNode(Token.WITH, element); [EOL]     parent.addChildToBack(node); [EOL]     JsonML child = element.getChild(0); [EOL]     transformElement(child, node); [EOL]     child = element.getChild(1); [EOL]     transformPotentiallyUnwrappedBlock(child, node); [EOL]     insertExprResultState = true; [EOL] } <line_num>: 1230,1247
private Node createNode(int type, JsonML element) { [EOL]     return new Node(type, nodeIndex, -1); [EOL] } <line_num>: 1252,1254
private void setPosition(Node node) { [EOL]     node.setLineno(nodeIndex); [EOL] } <line_num>: 1261,1263
private String getName() { [EOL]     return this.name; [EOL] } <line_num>: 1329,1331
private static Operator get(String name) { [EOL]     return lookup.get(name); [EOL] } <line_num>: 1337,1339
private static int getNodeTypeForAssignOp(String name) { [EOL]     Operator op = get(name); [EOL]     if (op == null) { [EOL]         return Token.ERROR; [EOL]     } [EOL]     int type; [EOL]     switch(op) { [EOL]         case ASSIGN: [EOL]             type = Token.ASSIGN; [EOL]             break; [EOL]         case ASSIGN_BITOR: [EOL]             type = Token.ASSIGN_BITOR; [EOL]             break; [EOL]         case ASSIGN_BITXOR: [EOL]             type = Token.ASSIGN_BITXOR; [EOL]             break; [EOL]         case ASSIGN_BITAND: [EOL]             type = Token.ASSIGN_BITAND; [EOL]             break; [EOL]         case ASSIGN_LSH: [EOL]             type = Token.ASSIGN_LSH; [EOL]             break; [EOL]         case ASSIGN_RSH: [EOL]             type = Token.ASSIGN_RSH; [EOL]             break; [EOL]         case ASSIGN_URSH: [EOL]             type = Token.ASSIGN_URSH; [EOL]             break; [EOL]         case ASSIGN_ADD: [EOL]             type = Token.ASSIGN_ADD; [EOL]             break; [EOL]         case ASSIGN_SUB: [EOL]             type = Token.ASSIGN_SUB; [EOL]             break; [EOL]         case ASSIGN_MUL: [EOL]             type = Token.ASSIGN_MUL; [EOL]             break; [EOL]         case ASSIGN_DIV: [EOL]             type = Token.ASSIGN_DIV; [EOL]             break; [EOL]         case ASSIGN_MOD: [EOL]             type = Token.ASSIGN_MOD; [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("" + "Invalid type of assign expression."); [EOL]     } [EOL]     return type; [EOL] } <line_num>: 1344,1393
private static int getNodeTypeForBinaryOp(String name) { [EOL]     Operator op = get(name); [EOL]     int type; [EOL]     switch(op) { [EOL]         case BITOR: [EOL]             type = Token.BITOR; [EOL]             break; [EOL]         case BITXOR: [EOL]             type = Token.BITXOR; [EOL]             break; [EOL]         case BITAND: [EOL]             type = Token.BITAND; [EOL]             break; [EOL]         case EQ: [EOL]             type = Token.EQ; [EOL]             break; [EOL]         case NE: [EOL]             type = Token.NE; [EOL]             break; [EOL]         case LT: [EOL]             type = Token.LT; [EOL]             break; [EOL]         case LE: [EOL]             type = Token.LE; [EOL]             break; [EOL]         case GT: [EOL]             type = Token.GT; [EOL]             break; [EOL]         case GE: [EOL]             type = Token.GE; [EOL]             break; [EOL]         case LSH: [EOL]             type = Token.LSH; [EOL]             break; [EOL]         case RSH: [EOL]             type = Token.RSH; [EOL]             break; [EOL]         case URSH: [EOL]             type = Token.URSH; [EOL]             break; [EOL]         case ADD: [EOL]             type = Token.ADD; [EOL]             break; [EOL]         case SUB: [EOL]             type = Token.SUB; [EOL]             break; [EOL]         case MUL: [EOL]             type = Token.MUL; [EOL]             break; [EOL]         case DIV: [EOL]             type = Token.DIV; [EOL]             break; [EOL]         case MOD: [EOL]             type = Token.MOD; [EOL]             break; [EOL]         case SHEQ: [EOL]             type = Token.SHEQ; [EOL]             break; [EOL]         case SHNE: [EOL]             type = Token.SHNE; [EOL]             break; [EOL]         case COMMA: [EOL]             type = Token.COMMA; [EOL]             break; [EOL]         case INSTANCEOF: [EOL]             type = Token.INSTANCEOF; [EOL]             break; [EOL]         case IN: [EOL]             type = Token.IN; [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("" + "Invalid type of binary expression."); [EOL]     } [EOL]     return type; [EOL] } <line_num>: 1398,1474
private static int getNodeTypeForCountOp(String name) { [EOL]     Operator op = get(name); [EOL]     if (op == null) { [EOL]         return Token.ERROR; [EOL]     } [EOL]     int type; [EOL]     switch(op) { [EOL]         case DEC: [EOL]             type = Token.DEC; [EOL]             break; [EOL]         case INC: [EOL]             type = Token.INC; [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("" + "Invalid type of count expression."); [EOL]     } [EOL]     return type; [EOL] } <line_num>: 1479,1498
private static int getNodeTypeForUnaryOp(String name) { [EOL]     String realName = new String(name); [EOL]     if (name.equals("+") || name.equals("-")) { [EOL]         realName += "_unary"; [EOL]     } [EOL]     Operator op = get(realName); [EOL]     int type; [EOL]     switch(op) { [EOL]         case NOT: [EOL]             type = Token.NOT; [EOL]             break; [EOL]         case BITNOT: [EOL]             type = Token.BITNOT; [EOL]             break; [EOL]         case POS: [EOL]             type = Token.POS; [EOL]             break; [EOL]         case NEG: [EOL]             type = Token.NEG; [EOL]             break; [EOL]         case VOID: [EOL]             type = Token.VOID; [EOL]             break; [EOL]         default: [EOL]             throw new IllegalArgumentException("" + "Invalid type of unary expression."); [EOL]     } [EOL]     return type; [EOL] } <line_num>: 1503,1532
private String getName() { [EOL]     return this.name; [EOL] } <line_num>: 1553,1555
private static Type get(String name) { [EOL]     return lookup.get(name); [EOL] } <line_num>: 1561,1563
