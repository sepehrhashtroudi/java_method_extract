private Validator() { [EOL]     b = new StringBuilder(); [EOL]     error = false; [EOL] } <line_num>: 58,61
public static String validate(JsonML element) { [EOL]     return (new Validator()).doValidate(element); [EOL] } <line_num>: 69,71
private String doValidate(JsonML element) { [EOL]     String message; [EOL]     switch(element.getType()) { [EOL]         case AssignExpr: [EOL]             validateAssignExpr(element); [EOL]             break; [EOL]         case BinaryExpr: [EOL]             validateBinaryExpr(element); [EOL]             break; [EOL]         case BreakStmt: [EOL]         case ContinueStmt: [EOL]             validateJmpStmt(element); [EOL]             break; [EOL]         case Case: [EOL]             validateCase(element); [EOL]             break; [EOL]         case CatchClause: [EOL]             validateCatchClause(element); [EOL]             break; [EOL]         case ConditionalExpr: [EOL]             validateConditionalExpr(element); [EOL]             break; [EOL]         case CountExpr: [EOL]             validateCountExpr(element); [EOL]             break; [EOL]         case DataProp: [EOL]             validateProp(element); [EOL]             break; [EOL]         case GetterProp: [EOL]             validateProp(element); [EOL]             break; [EOL]         case SetterProp: [EOL]             validateProp(element); [EOL]             break; [EOL]         case DeleteExpr: [EOL]             validateDeleteExpr(element); [EOL]             break; [EOL]         case DoWhileStmt: [EOL]             validateDoWhileStmt(element); [EOL]             break; [EOL]         case EmptyStmt: [EOL]             validateEmptyStmt(element); [EOL]             break; [EOL]         case ForInStmt: [EOL]             validateForInStmt(element); [EOL]             break; [EOL]         case ForStmt: [EOL]             validateForStmt(element); [EOL]             break; [EOL]         case FunctionDecl: [EOL]             validateFunctionDecl(element); [EOL]             break; [EOL]         case FunctionExpr: [EOL]             validateFunctionExpr(element); [EOL]             break; [EOL]         case IdExpr: [EOL]             validateIdExpr(element); [EOL]             break; [EOL]         case IdPatt: [EOL]             validateIdPatt(element); [EOL]             break; [EOL]         case IfStmt: [EOL]             validateIfStmt(element); [EOL]             break; [EOL]         case InvokeExpr: [EOL]             validateInvokeExpr(element); [EOL]             break; [EOL]         case LabelledStmt: [EOL]             validateLabelledStmt(element); [EOL]             break; [EOL]         case LiteralExpr: [EOL]             validateLiteralExpr(element); [EOL]             break; [EOL]         case LogicalAndExpr: [EOL]         case LogicalOrExpr: [EOL]             validateLogicalExpr(element); [EOL]             break; [EOL]         case MemberExpr: [EOL]             validateMemberExpr(element); [EOL]             break; [EOL]         case NewExpr: [EOL]             validateNewExpr(element); [EOL]             break; [EOL]         case ObjectExpr: [EOL]             validateObjectExpr(element); [EOL]             break; [EOL]         case ParamDecl: [EOL]             validateParamDecl(element); [EOL]             break; [EOL]         case RegExpExpr: [EOL]             validateRegExpExpr(element); [EOL]             break; [EOL]         case ReturnStmt: [EOL]             validateReturnStmt(element); [EOL]             break; [EOL]         case SwitchStmt: [EOL]             validateSwitchStmt(element); [EOL]             break; [EOL]         case ThisExpr: [EOL]             validateThisExpr(element); [EOL]             break; [EOL]         case ThrowStmt: [EOL]             validateThrowStmt(element); [EOL]             break; [EOL]         case TryStmt: [EOL]             validateTryStmt(element); [EOL]             break; [EOL]         case TypeofExpr: [EOL]             validateTypeofExpr(element); [EOL]             break; [EOL]         case UnaryExpr: [EOL]             validateUnaryExpr(element); [EOL]             break; [EOL]         case VarDecl: [EOL]             validateVarDecl(element); [EOL]             break; [EOL]         case WhileStmt: [EOL]             validateWhileStmt(element); [EOL]             break; [EOL]         case WithStmt: [EOL]             validateWithStmt(element); [EOL]             break; [EOL]     } [EOL]     return b.length() != 0 ? b.toString() : null; [EOL] } <line_num>: 76,200
private void validateAssignExpr(JsonML element) { [EOL]     validateChildrenSize(element, 2); [EOL]     validateArgument(element, TagAttr.OP); [EOL] } <line_num>: 202,205
private void validateBinaryExpr(JsonML element) { [EOL]     validateChildrenSize(element, 2); [EOL]     validateArgument(element, TagAttr.OP); [EOL] } <line_num>: 207,210
private void validateCase(JsonML element) { [EOL]     validateMinChildrenSize(element, 1); [EOL]     if (!error) { [EOL]         validateIsChildExpression(element, 0); [EOL]     } [EOL] } <line_num>: 212,217
private void validateCatchClause(JsonML element) { [EOL]     validateChildrenSize(element, 2); [EOL]     if (!error) { [EOL]         validateChildType(element, TagType.IdPatt, 0); [EOL]         validateChildType(element, TagType.BlockStmt, 1); [EOL]     } [EOL] } <line_num>: 219,225
private void validateConditionalExpr(JsonML element) { [EOL]     validateChildrenSize(element, 3); [EOL] } <line_num>: 227,229
private void validateCountExpr(JsonML element) { [EOL]     validateChildrenSize(element, 1); [EOL]     validateArgument(element, TagAttr.IS_PREFIX); [EOL]     validateArgument(element, TagAttr.OP); [EOL] } <line_num>: 231,235
private void validateProp(JsonML element) { [EOL]     validateChildrenSize(element, 1); [EOL]     if (!error) { [EOL]         validateArgument(element, TagAttr.NAME); [EOL]     } [EOL] } <line_num>: 237,242
private void validateDeleteExpr(JsonML element) { [EOL]     validateChildrenSize(element, 1); [EOL] } <line_num>: 244,247
private void validateDoWhileStmt(JsonML element) { [EOL]     validateChildrenSize(element, 2); [EOL] } <line_num>: 249,252
private void validateEmptyStmt(JsonML element) { [EOL]     validateChildrenSize(element, 0); [EOL] } <line_num>: 254,256
private void validateForInStmt(JsonML element) { [EOL]     validateChildrenSize(element, 3); [EOL] } <line_num>: 258,260
private void validateForStmt(JsonML element) { [EOL]     validateChildrenSize(element, 4); [EOL] } <line_num>: 262,264
private void validateFunctionDecl(JsonML element) { [EOL]     validateFunction(element, true); [EOL] } <line_num>: 266,268
private void validateFunctionExpr(JsonML element) { [EOL]     validateFunction(element, false); [EOL] } <line_num>: 270,272
private void validateIdExpr(JsonML element) { [EOL]     validateChildrenSize(element, 0); [EOL]     if (!error) { [EOL]         validateArgument(element, TagAttr.NAME); [EOL]     } [EOL] } <line_num>: 274,279
private void validateIdPatt(JsonML element) { [EOL]     validateChildrenSize(element, 0); [EOL]     validateArgument(element, TagAttr.NAME); [EOL] } <line_num>: 281,284
private void validateIfStmt(JsonML element) { [EOL]     validateChildrenSize(element, 3); [EOL]     if (!error) { [EOL]     } [EOL] } <line_num>: 286,291
private void validateInvokeExpr(JsonML element) { [EOL]     validateMinChildrenSize(element, 2); [EOL]     validateArgument(element, TagAttr.OP); [EOL] } <line_num>: 293,296
private void validateJmpStmt(JsonML element) { [EOL]     validateChildrenSize(element, 0); [EOL] } <line_num>: 298,301
private void validateLabelledStmt(JsonML element) { [EOL]     validateChildrenSize(element, 1); [EOL]     validateArgument(element, TagAttr.LABEL); [EOL] } <line_num>: 303,306
private void validateLiteralExpr(JsonML element) { [EOL]     validateChildrenSize(element, 0); [EOL]     validateArgument(element, TagAttr.TYPE); [EOL]     validateArgument(element, TagAttr.VALUE); [EOL] } <line_num>: 308,312
private void validateLogicalExpr(JsonML element) { [EOL]     validateChildrenSize(element, 2); [EOL] } <line_num>: 314,316
private void validateMemberExpr(JsonML element) { [EOL]     validateChildrenSize(element, 2); [EOL]     validateArgument(element, TagAttr.OP); [EOL] } <line_num>: 318,321
private void validateNewExpr(JsonML element) { [EOL]     validateMinChildrenSize(element, 1); [EOL] } <line_num>: 323,325
private void validateObjectExpr(JsonML element) { [EOL]     TagType[] expected = { TagType.DataProp, TagType.GetterProp, TagType.SetterProp }; [EOL]     for (int i = 0; i < element.childrenSize(); ++i) { [EOL]         validateChildType(element, expected, i); [EOL]     } [EOL] } <line_num>: 327,333
private void validateParamDecl(JsonML element) { [EOL]     for (int i = 0; i < element.childrenSize(); ++i) { [EOL]         validateChildType(element, TagType.IdPatt, i); [EOL]     } [EOL] } <line_num>: 335,339
private void validateRegExpExpr(JsonML element) { [EOL]     validateChildrenSize(element, 0); [EOL]     validateArgument(element, TagAttr.BODY); [EOL]     validateArgument(element, TagAttr.FLAGS); [EOL] } <line_num>: 341,345
private void validateReturnStmt(JsonML element) { [EOL]     validateMaxChildrenSize(element, 1); [EOL] } <line_num>: 347,349
private void validateSwitchStmt(JsonML element) { [EOL]     validateMinChildrenSize(element, 1); [EOL]     boolean defaultStmt = false; [EOL]     for (int i = 1; i < element.childrenSize(); ++i) { [EOL]         if (!defaultStmt) { [EOL]             validateChildType(element, new TagType[] { TagType.Case, TagType.DefaultCase }, i); [EOL]         } else { [EOL]             validateChildType(element, TagType.Case, i); [EOL]         } [EOL]         if (error) { [EOL]             break; [EOL]         } [EOL]         if (element.getChild(i).getType() == TagType.DefaultCase) { [EOL]             defaultStmt = true; [EOL]         } [EOL]     } [EOL] } <line_num>: 351,370
private void validateThisExpr(JsonML element) { [EOL]     validateChildrenSize(element, 0); [EOL] } <line_num>: 372,374
private void validateThrowStmt(JsonML element) { [EOL]     validateChildrenSize(element, 1); [EOL] } <line_num>: 376,378
private void validateTryStmt(JsonML element) { [EOL]     validateChildrenSize(element, 2, 3); [EOL]     if (error) { [EOL]         return; [EOL]     } [EOL]     validateChildType(element, TagType.BlockStmt, 0); [EOL]     TagType[] types = new TagType[] { TagType.CatchClause, TagType.Empty }; [EOL]     validateChildType(element, types, 1); [EOL]     if (element.childrenSize() > 2) { [EOL]         validateChildType(element, TagType.BlockStmt, 2); [EOL]     } [EOL] } <line_num>: 380,395
private void validateFunction(JsonML element, boolean needsName) { [EOL]     validateMinChildrenSize(element, 2); [EOL]     if (error) { [EOL]         return; [EOL]     } [EOL]     if (needsName) { [EOL]         validateChildType(element, new TagType[] { TagType.IdPatt }, 0); [EOL]     } else { [EOL]         validateChildType(element, new TagType[] { TagType.IdPatt, TagType.Empty }, 0); [EOL]     } [EOL]     validateChildType(element, TagType.ParamDecl, 1); [EOL] } <line_num>: 397,413
private void validateTypeofExpr(JsonML element) { [EOL]     validateChildrenSize(element, 1); [EOL] } <line_num>: 415,417
private void validateUnaryExpr(JsonML element) { [EOL]     validateChildrenSize(element, 1); [EOL]     if (!error) { [EOL]         validateArgument(element, TagAttr.OP); [EOL]     } [EOL] } <line_num>: 419,424
private void validateVarDecl(JsonML element) { [EOL]     validateMinChildrenSize(element, 1); [EOL]     TagType[] types = new TagType[] { TagType.InitPatt, TagType.IdPatt }; [EOL]     for (int i = 0; i < element.childrenSize(); ++i) { [EOL]         validateChildType(element, types, i); [EOL]     } [EOL] } <line_num>: 426,433
private void validateWhileStmt(JsonML element) { [EOL]     validateChildrenSize(element, 2); [EOL] } <line_num>: 435,438
private void validateWithStmt(JsonML element) { [EOL]     validateChildrenSize(element, 2); [EOL] } <line_num>: 440,443
private void validateArgument(JsonML element, TagAttr attr) { [EOL]     Object value = element.getAttribute(attr); [EOL]     if (value == null) { [EOL]         String type; [EOL]         if ((type = (String) element.getAttribute(TagAttr.TYPE)) != null && type.equals("null")) { [EOL]             return; [EOL]         } [EOL]         error = true; [EOL]         appendLine(String.format(MISSING_ARGUMENT, attr, element.getType())); [EOL]     } [EOL] } <line_num>: 445,462
private void validateChildrenSize(JsonML element, int expected) { [EOL]     validateChildrenSize(element, expected, expected); [EOL] } <line_num>: 464,466
private void validateChildrenSize(JsonML element, int min, int max) { [EOL]     validateMinChildrenSize(element, min); [EOL]     if (!error) { [EOL]         validateMaxChildrenSize(element, max); [EOL]     } [EOL] } <line_num>: 468,473
private void validateMinChildrenSize(JsonML element, int min) { [EOL]     int size = element.childrenSize(); [EOL]     if (size < min) { [EOL]         appendLine(String.format(NOT_ENOUGH_CHILDREN_FMT, element.getType(), min, size)); [EOL]         error = true; [EOL]     } [EOL] } <line_num>: 475,483
private void validateMaxChildrenSize(JsonML element, int max) { [EOL]     int size = element.childrenSize(); [EOL]     if (size > max) { [EOL]         appendLine(String.format(TOO_MANY_CHILDREN_FMT, element.getType().toString(), max, size)); [EOL]         error = true; [EOL]     } [EOL] } <line_num>: 485,493
private void validateIsChildExpression(JsonML element, int index) { [EOL]     validateChildType(element, exprTypes, index); [EOL] } <line_num>: 495,497
private void validateChildType(JsonML element, TagType expected, int index) { [EOL]     TagType[] types = { expected }; [EOL]     validateChildType(element, types, index); [EOL] } <line_num>: 499,503
private void validateChildType(JsonML element, TagType[] expected, int index) { [EOL]     TagType type = element.getChild(index).getType(); [EOL]     if (!Arrays.asList(expected).contains(type)) { [EOL]         appendLine(String.format(WRONG_CHILD_TYPE_FMT, index, element.getType(), printList(expected), type)); [EOL]         error = true; [EOL]     } [EOL] } <line_num>: 505,514
private void appendLine(String line) { [EOL]     b.append(String.format("%s", line)); [EOL] } <line_num>: 516,518
public static String printList(Object[] list) { [EOL]     StringBuilder builder = new StringBuilder(""); [EOL]     if (list.length == 1) { [EOL]         builder.append(list[0].toString()); [EOL]     } else if (list.length > 1) { [EOL]         builder.append('['); [EOL]         for (int i = 0; i < list.length; ++i) { [EOL]             builder.append(list[i].toString()); [EOL]             if (i < list.length - 1) { [EOL]                 builder.append(", "); [EOL]             } [EOL]         } [EOL]         builder.append("]"); [EOL]     } [EOL]     return builder.toString(); [EOL] } <line_num>: 521,536
