@Override [EOL] Node optimizeSubtree(Node subtree) { [EOL]     switch(subtree.getType()) { [EOL]         case Token.ASSIGN: [EOL]             return tryFoldAssignment(subtree); [EOL]         case Token.COMMA: [EOL]             return tryFoldComma(subtree); [EOL]         case Token.SCRIPT: [EOL]         case Token.BLOCK: [EOL]             return tryOptimizeBlock(subtree); [EOL]         case Token.EXPR_RESULT: [EOL]             subtree = tryFoldExpr(subtree); [EOL]             return subtree; [EOL]         case Token.HOOK: [EOL]             return tryFoldHook(subtree); [EOL]         case Token.SWITCH: [EOL]             return tryOptimizeSwitch(subtree); [EOL]         case Token.IF: [EOL]             return tryFoldIf(subtree); [EOL]         case Token.WHILE: [EOL]             return tryFoldWhile(subtree); [EOL]         case Token.FOR: [EOL]             { [EOL]                 Node condition = NodeUtil.getConditionExpression(subtree); [EOL]                 if (condition != null) { [EOL]                     tryFoldForCondition(condition); [EOL]                 } [EOL]             } [EOL]             return tryFoldFor(subtree); [EOL]         case Token.DO: [EOL]             return tryFoldDo(subtree); [EOL]         case Token.TRY: [EOL]             return tryFoldTry(subtree); [EOL]         default: [EOL]             return subtree; [EOL]     } [EOL] } <line_num>: 40,75
private Node tryFoldTry(Node n) { [EOL]     Preconditions.checkState(n.isTry()); [EOL]     Node body = n.getFirstChild(); [EOL]     Node catchBlock = body.getNext(); [EOL]     Node finallyBlock = catchBlock.getNext(); [EOL]     if (!catchBlock.hasChildren() && (finallyBlock == null || !finallyBlock.hasChildren())) { [EOL]         n.removeChild(body); [EOL]         n.getParent().replaceChild(n, body); [EOL]         reportCodeChange(); [EOL]         return body; [EOL]     } [EOL]     if (!body.hasChildren()) { [EOL]         NodeUtil.redeclareVarsInsideBranch(catchBlock); [EOL]         if (finallyBlock != null) { [EOL]             n.removeChild(finallyBlock); [EOL]             n.getParent().replaceChild(n, finallyBlock); [EOL]         } else { [EOL]             n.getParent().removeChild(n); [EOL]         } [EOL]         reportCodeChange(); [EOL]         return finallyBlock; [EOL]     } [EOL]     return n; [EOL] } <line_num>: 83,112
private Node tryFoldAssignment(Node subtree) { [EOL]     Preconditions.checkState(subtree.isAssign()); [EOL]     Node left = subtree.getFirstChild(); [EOL]     Node right = subtree.getLastChild(); [EOL]     if (left.isName() && right.isName() && left.getString().equals(right.getString())) { [EOL]         subtree.getParent().replaceChild(subtree, right.detachFromParent()); [EOL]         reportCodeChange(); [EOL]         return right; [EOL]     } [EOL]     return subtree; [EOL] } <line_num>: 118,131
private Node tryFoldExpr(Node subtree) { [EOL]     Node result = trySimplifyUnusedResult(subtree.getFirstChild()); [EOL]     if (result == null) { [EOL]         Node parent = subtree.getParent(); [EOL]         if (parent.isLabel()) { [EOL]             Node replacement = IR.block().srcref(subtree); [EOL]             parent.replaceChild(subtree, replacement); [EOL]             subtree = replacement; [EOL]         } else { [EOL]             subtree.detachFromParent(); [EOL]             subtree = null; [EOL]         } [EOL]     } [EOL]     return subtree; [EOL] } <line_num>: 137,152
private Node trySimplifyUnusedResult(Node n) { [EOL]     return trySimplifyUnusedResult(n, true); [EOL] } <line_num>: 159,161
private Node trySimplifyUnusedResult(Node n, boolean removeUnused) { [EOL]     Node result = n; [EOL]     switch(n.getType()) { [EOL]         case Token.HOOK: [EOL]             Node trueNode = trySimplifyUnusedResult(n.getFirstChild().getNext()); [EOL]             Node falseNode = trySimplifyUnusedResult(n.getLastChild()); [EOL]             if (trueNode == null && falseNode != null) { [EOL]                 n.setType(Token.OR); [EOL]                 Preconditions.checkState(n.getChildCount() == 2); [EOL]             } else if (trueNode != null && falseNode == null) { [EOL]                 n.setType(Token.AND); [EOL]                 Preconditions.checkState(n.getChildCount() == 2); [EOL]             } else if (trueNode == null && falseNode == null) { [EOL]                 result = trySimplifyUnusedResult(n.getFirstChild()); [EOL]             } else { [EOL]                 result = n; [EOL]             } [EOL]             break; [EOL]         case Token.AND: [EOL]         case Token.OR: [EOL]             Node conditionalResultNode = trySimplifyUnusedResult(n.getLastChild()); [EOL]             if (conditionalResultNode == null) { [EOL]                 Preconditions.checkState(n.hasOneChild()); [EOL]                 result = trySimplifyUnusedResult(n.getFirstChild()); [EOL]             } [EOL]             break; [EOL]         case Token.FUNCTION: [EOL]             result = null; [EOL]             break; [EOL]         case Token.COMMA: [EOL]             Node left = trySimplifyUnusedResult(n.getFirstChild()); [EOL]             Node right = trySimplifyUnusedResult(n.getLastChild()); [EOL]             if (left == null && right == null) { [EOL]                 result = null; [EOL]             } else if (left == null) { [EOL]                 result = right; [EOL]             } else if (right == null) { [EOL]                 result = left; [EOL]             } else { [EOL]                 result = n; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             if (!nodeTypeMayHaveSideEffects(n)) { [EOL]                 Node resultList = null; [EOL]                 for (Node next, c = n.getFirstChild(); c != null; c = next) { [EOL]                     next = c.getNext(); [EOL]                     c = trySimplifyUnusedResult(c); [EOL]                     if (c != null) { [EOL]                         c.detachFromParent(); [EOL]                         if (resultList == null) { [EOL]                             resultList = c; [EOL]                         } else { [EOL]                             resultList = IR.comma(resultList, c).srcref(c); [EOL]                         } [EOL]                     } [EOL]                 } [EOL]                 result = resultList; [EOL]             } [EOL]     } [EOL]     if (n != result) { [EOL]         Node parent = n.getParent(); [EOL]         if (result == null) { [EOL]             if (removeUnused) { [EOL]                 parent.removeChild(n); [EOL]             } else { [EOL]                 result = IR.empty().srcref(n); [EOL]                 parent.replaceChild(n, result); [EOL]             } [EOL]         } else { [EOL]             if (result.getParent() != null) { [EOL]                 result.detachFromParent(); [EOL]             } [EOL]             n.getParent().replaceChild(n, result); [EOL]         } [EOL]         reportCodeChange(); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 170,279
private Node tryOptimizeSwitch(Node n) { [EOL]     Preconditions.checkState(n.isSwitch()); [EOL]     Node defaultCase = tryOptimizeDefaultCase(n); [EOL]     if (defaultCase == null) { [EOL]         Node cond = n.getFirstChild(), prev = null, next = null, cur; [EOL]         for (cur = cond.getNext(); cur != null; cur = next) { [EOL]             next = cur.getNext(); [EOL]             if (!mayHaveSideEffects(cur.getFirstChild()) && isUselessCase(cur, prev)) { [EOL]                 removeCase(n, cur); [EOL]             } else { [EOL]                 prev = cur; [EOL]             } [EOL]         } [EOL]         if (NodeUtil.isLiteralValue(cond, false)) { [EOL]             Node caseLabel; [EOL]             TernaryValue caseMatches = TernaryValue.TRUE; [EOL]             for (cur = cond.getNext(); cur != null; cur = next) { [EOL]                 next = cur.getNext(); [EOL]                 caseLabel = cur.getFirstChild(); [EOL]                 caseMatches = PeepholeFoldConstants.evaluateComparison(Token.SHEQ, cond, caseLabel); [EOL]                 if (caseMatches == TernaryValue.TRUE) { [EOL]                     break; [EOL]                 } else if (caseMatches == TernaryValue.UNKNOWN) { [EOL]                     break; [EOL]                 } else { [EOL]                     removeCase(n, cur); [EOL]                 } [EOL]             } [EOL]             if (caseMatches != TernaryValue.UNKNOWN) { [EOL]                 Node block, lastStm; [EOL]                 while (cur != null) { [EOL]                     block = cur.getLastChild(); [EOL]                     lastStm = block.getLastChild(); [EOL]                     cur = cur.getNext(); [EOL]                     if (lastStm != null && lastStm.isBreak()) { [EOL]                         block.removeChild(lastStm); [EOL]                         reportCodeChange(); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 for (; cur != null; cur = next) { [EOL]                     next = cur.getNext(); [EOL]                     removeCase(n, cur); [EOL]                 } [EOL]                 cur = cond.getNext(); [EOL]                 if (cur != null && cur.getNext() == null) { [EOL]                     block = cur.getLastChild(); [EOL]                     if (!(NodeUtil.containsType(block, Token.BREAK, NodeUtil.MATCH_NOT_FUNCTION))) { [EOL]                         cur.removeChild(block); [EOL]                         n.getParent().replaceChild(n, block); [EOL]                         reportCodeChange(); [EOL]                         return block; [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (n.hasOneChild()) { [EOL]         Node condition = n.removeFirstChild(); [EOL]         Node replacement = IR.exprResult(condition).srcref(n); [EOL]         n.getParent().replaceChild(n, replacement); [EOL]         reportCodeChange(); [EOL]         return replacement; [EOL]     } [EOL]     return null; [EOL] } <line_num>: 284,365
private Node tryOptimizeDefaultCase(Node n) { [EOL]     Preconditions.checkState(n.isSwitch()); [EOL]     Node lastNonRemovable = n.getFirstChild(); [EOL]     for (Node c = n.getFirstChild().getNext(); c != null; c = c.getNext()) { [EOL]         if (c.isDefaultCase()) { [EOL]             Node caseToRemove = lastNonRemovable.getNext(); [EOL]             for (Node next; caseToRemove != c; caseToRemove = next) { [EOL]                 next = caseToRemove.getNext(); [EOL]                 removeCase(n, caseToRemove); [EOL]             } [EOL]             Node prevCase = (lastNonRemovable == n.getFirstChild()) ? null : lastNonRemovable; [EOL]             if (isUselessCase(c, prevCase)) { [EOL]                 removeCase(n, c); [EOL]                 return null; [EOL]             } [EOL]             return c; [EOL]         } else { [EOL]             Preconditions.checkState(c.isCase()); [EOL]             if (c.getLastChild().hasChildren() || mayHaveSideEffects(c.getFirstChild())) { [EOL]                 lastNonRemovable = c; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 371,405
private void removeCase(Node switchNode, Node caseNode) { [EOL]     NodeUtil.redeclareVarsInsideBranch(caseNode); [EOL]     switchNode.removeChild(caseNode); [EOL]     reportCodeChange(); [EOL] } <line_num>: 411,415
private boolean isUselessCase(Node caseNode, @Nullable Node previousCase) { [EOL]     Preconditions.checkState(previousCase == null || previousCase.getNext() == caseNode); [EOL]     Node switchNode = caseNode.getParent(); [EOL]     if (switchNode.getLastChild() != caseNode && previousCase != null) { [EOL]         Node previousBlock = previousCase.getLastChild(); [EOL]         if (!previousBlock.hasChildren() || !isExit(previousBlock.getLastChild())) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     Node executingCase = caseNode; [EOL]     while (executingCase != null) { [EOL]         Preconditions.checkState(executingCase.isDefaultCase() || executingCase.isCase()); [EOL]         Preconditions.checkState(caseNode == executingCase || !executingCase.isDefaultCase()); [EOL]         Node block = executingCase.getLastChild(); [EOL]         Preconditions.checkState(block.isBlock()); [EOL]         if (block.hasChildren()) { [EOL]             for (Node blockChild : block.children()) { [EOL]                 switch(blockChild.getType()) { [EOL]                     case Token.BREAK: [EOL]                         return blockChild.getFirstChild() == null; [EOL]                     case Token.VAR: [EOL]                         if (blockChild.hasOneChild() && blockChild.getFirstChild().getFirstChild() == null) { [EOL]                             continue; [EOL]                         } [EOL]                         return false; [EOL]                     default: [EOL]                         return false; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             executingCase = executingCase.getNext(); [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 422,472
private boolean isExit(Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.BREAK: [EOL]         case Token.CONTINUE: [EOL]         case Token.RETURN: [EOL]         case Token.THROW: [EOL]             return true; [EOL]         default: [EOL]             return false; [EOL]     } [EOL] } <line_num>: 477,487
private Node tryFoldComma(Node n) { [EOL]     Node parent = n.getParent(); [EOL]     Node left = n.getFirstChild(); [EOL]     Node right = left.getNext(); [EOL]     left = trySimplifyUnusedResult(left); [EOL]     if (left == null || !mayHaveSideEffects(left)) { [EOL]         n.removeChild(right); [EOL]         parent.replaceChild(n, right); [EOL]         reportCodeChange(); [EOL]         return right; [EOL]     } [EOL]     return n; [EOL] } <line_num>: 489,504
Node tryOptimizeBlock(Node n) { [EOL]     for (Node c = n.getFirstChild(); c != null; ) { [EOL]         Node next = c.getNext(); [EOL]         if (!isUnremovableNode(c) && !mayHaveSideEffects(c)) { [EOL]             n.removeChild(c); [EOL]             reportCodeChange(); [EOL]         } else { [EOL]             tryOptimizeConditionalAfterAssign(c); [EOL]         } [EOL]         c = next; [EOL]     } [EOL]     if (n.isSyntheticBlock() || n.getParent() == null) { [EOL]         return n; [EOL]     } [EOL]     if (NodeUtil.tryMergeBlock(n)) { [EOL]         reportCodeChange(); [EOL]         return null; [EOL]     } [EOL]     return n; [EOL] } <line_num>: 509,536
private boolean isUnremovableNode(Node n) { [EOL]     return (n.isBlock() && n.isSyntheticBlock()) || n.isScript(); [EOL] } <line_num>: 541,543
private void tryOptimizeConditionalAfterAssign(Node n) { [EOL]     Node next = n.getNext(); [EOL]     if (isSimpleAssignment(n) && isConditionalStatement(next)) { [EOL]         Node lhsAssign = getSimpleAssignmentName(n); [EOL]         Node condition = getConditionalStatementCondition(next); [EOL]         if (lhsAssign.isName() && condition.isName() && lhsAssign.getString().equals(condition.getString())) { [EOL]             Node rhsAssign = getSimpleAssignmentValue(n); [EOL]             TernaryValue value = NodeUtil.getImpureBooleanValue(rhsAssign); [EOL]             if (value != TernaryValue.UNKNOWN) { [EOL]                 Node replacementConditionNode = NodeUtil.booleanNode(value.toBoolean(true)); [EOL]                 condition.getParent().replaceChild(condition, replacementConditionNode); [EOL]                 reportCodeChange(); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 550,591
private boolean isSimpleAssignment(Node n) { [EOL]     if (NodeUtil.isExprAssign(n) && n.getFirstChild().getFirstChild().isName()) { [EOL]         return true; [EOL]     } else if (n.isVar() && n.hasOneChild() && n.getFirstChild().getFirstChild() != null) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 597,609
private Node getSimpleAssignmentName(Node n) { [EOL]     Preconditions.checkState(isSimpleAssignment(n)); [EOL]     if (NodeUtil.isExprAssign(n)) { [EOL]         return n.getFirstChild().getFirstChild(); [EOL]     } else { [EOL]         return n.getFirstChild(); [EOL]     } [EOL] } <line_num>: 614,622
private Node getSimpleAssignmentValue(Node n) { [EOL]     Preconditions.checkState(isSimpleAssignment(n)); [EOL]     return n.getFirstChild().getLastChild(); [EOL] } <line_num>: 627,630
private boolean isConditionalStatement(Node n) { [EOL]     return n != null && (n.isIf() || isExprConditional(n)); [EOL] } <line_num>: 635,639
private boolean isExprConditional(Node n) { [EOL]     if (n.isExprResult()) { [EOL]         switch(n.getFirstChild().getType()) { [EOL]             case Token.HOOK: [EOL]             case Token.AND: [EOL]             case Token.OR: [EOL]                 return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 644,654
private Node getConditionalStatementCondition(Node n) { [EOL]     if (n.isIf()) { [EOL]         return NodeUtil.getConditionExpression(n); [EOL]     } else { [EOL]         Preconditions.checkState(isExprConditional(n)); [EOL]         return n.getFirstChild().getFirstChild(); [EOL]     } [EOL] } <line_num>: 659,666
private Node tryFoldIf(Node n) { [EOL]     Preconditions.checkState(n.isIf()); [EOL]     Node parent = n.getParent(); [EOL]     Preconditions.checkNotNull(parent); [EOL]     int type = n.getType(); [EOL]     Node cond = n.getFirstChild(); [EOL]     Node thenBody = cond.getNext(); [EOL]     Node elseBody = thenBody.getNext(); [EOL]     if (elseBody != null && !mayHaveSideEffects(elseBody)) { [EOL]         n.removeChild(elseBody); [EOL]         elseBody = null; [EOL]         reportCodeChange(); [EOL]     } [EOL]     if (!mayHaveSideEffects(thenBody) && elseBody != null) { [EOL]         n.removeChild(elseBody); [EOL]         n.replaceChild(thenBody, elseBody); [EOL]         Node notCond = new Node(Token.NOT); [EOL]         n.replaceChild(cond, notCond); [EOL]         notCond.addChildToFront(cond); [EOL]         cond = notCond; [EOL]         thenBody = cond.getNext(); [EOL]         elseBody = null; [EOL]         reportCodeChange(); [EOL]     } [EOL]     if (!mayHaveSideEffects(thenBody) && elseBody == null) { [EOL]         if (mayHaveSideEffects(cond)) { [EOL]             n.removeChild(cond); [EOL]             Node replacement = NodeUtil.newExpr(cond); [EOL]             parent.replaceChild(n, replacement); [EOL]             reportCodeChange(); [EOL]             return replacement; [EOL]         } else { [EOL]             NodeUtil.removeChild(parent, n); [EOL]             reportCodeChange(); [EOL]             return null; [EOL]         } [EOL]     } [EOL]     TernaryValue condValue = NodeUtil.getImpureBooleanValue(cond); [EOL]     if (condValue == TernaryValue.UNKNOWN) { [EOL]         return n; [EOL]     } [EOL]     if (mayHaveSideEffects(cond)) { [EOL]         boolean newConditionValue = condValue == TernaryValue.TRUE; [EOL]         if (!newConditionValue && elseBody == null) { [EOL]             elseBody = IR.block().srcref(n); [EOL]             n.addChildToBack(elseBody); [EOL]         } [EOL]         Node newCond = NodeUtil.booleanNode(newConditionValue); [EOL]         n.replaceChild(cond, newCond); [EOL]         Node branchToKeep = newConditionValue ? thenBody : elseBody; [EOL]         branchToKeep.addChildToFront(IR.exprResult(cond).srcref(cond)); [EOL]         reportCodeChange(); [EOL]         cond = newCond; [EOL]     } [EOL]     boolean condTrue = condValue.toBoolean(true); [EOL]     if (n.getChildCount() == 2) { [EOL]         Preconditions.checkState(type == Token.IF); [EOL]         if (condTrue) { [EOL]             Node thenStmt = n.getFirstChild().getNext(); [EOL]             n.removeChild(thenStmt); [EOL]             parent.replaceChild(n, thenStmt); [EOL]             reportCodeChange(); [EOL]             return thenStmt; [EOL]         } else { [EOL]             NodeUtil.redeclareVarsInsideBranch(n); [EOL]             NodeUtil.removeChild(parent, n); [EOL]             reportCodeChange(); [EOL]             return null; [EOL]         } [EOL]     } else { [EOL]         Node trueBranch = n.getFirstChild().getNext(); [EOL]         Node falseBranch = trueBranch.getNext(); [EOL]         Node branchToKeep = condTrue ? trueBranch : falseBranch; [EOL]         Node branchToRemove = condTrue ? falseBranch : trueBranch; [EOL]         NodeUtil.redeclareVarsInsideBranch(branchToRemove); [EOL]         n.removeChild(branchToKeep); [EOL]         parent.replaceChild(n, branchToKeep); [EOL]         reportCodeChange(); [EOL]         return branchToKeep; [EOL]     } [EOL] } <line_num>: 672,771
private Node tryFoldHook(Node n) { [EOL]     Preconditions.checkState(n.isHook()); [EOL]     Node parent = n.getParent(); [EOL]     Preconditions.checkNotNull(parent); [EOL]     Node cond = n.getFirstChild(); [EOL]     Node thenBody = cond.getNext(); [EOL]     Node elseBody = thenBody.getNext(); [EOL]     TernaryValue condValue = NodeUtil.getImpureBooleanValue(cond); [EOL]     if (condValue == TernaryValue.UNKNOWN) { [EOL]         if (!areNodesEqualForInlining(thenBody, elseBody)) { [EOL]             return n; [EOL]         } [EOL]     } [EOL]     n.detachChildren(); [EOL]     Node branchToKeep = condValue.toBoolean(true) ? thenBody : elseBody; [EOL]     Node replacement; [EOL]     if (mayHaveSideEffects(cond)) { [EOL]         replacement = IR.comma(cond, branchToKeep).srcref(n); [EOL]     } else { [EOL]         replacement = branchToKeep; [EOL]     } [EOL]     parent.replaceChild(n, replacement); [EOL]     reportCodeChange(); [EOL]     return replacement; [EOL] } <line_num>: 777,807
Node tryFoldWhile(Node n) { [EOL]     Preconditions.checkArgument(n.isWhile()); [EOL]     Node cond = NodeUtil.getConditionExpression(n); [EOL]     if (NodeUtil.getPureBooleanValue(cond) != TernaryValue.FALSE) { [EOL]         return n; [EOL]     } [EOL]     NodeUtil.redeclareVarsInsideBranch(n); [EOL]     NodeUtil.removeChild(n.getParent(), n); [EOL]     reportCodeChange(); [EOL]     return null; [EOL] } <line_num>: 812,823
Node tryFoldFor(Node n) { [EOL]     Preconditions.checkArgument(n.isFor()); [EOL]     if (NodeUtil.isForIn(n)) { [EOL]         return n; [EOL]     } [EOL]     Node init = n.getFirstChild(); [EOL]     Node cond = init.getNext(); [EOL]     Node increment = cond.getNext(); [EOL]     if (!init.isEmpty() && !init.isVar()) { [EOL]         init = trySimplifyUnusedResult(init, false); [EOL]     } [EOL]     if (!increment.isEmpty()) { [EOL]         increment = trySimplifyUnusedResult(increment, false); [EOL]     } [EOL]     if (!n.getFirstChild().isEmpty()) { [EOL]         return n; [EOL]     } [EOL]     if (NodeUtil.getImpureBooleanValue(cond) != TernaryValue.FALSE) { [EOL]         return n; [EOL]     } [EOL]     NodeUtil.redeclareVarsInsideBranch(n); [EOL]     if (!mayHaveSideEffects(cond)) { [EOL]         NodeUtil.removeChild(n.getParent(), n); [EOL]     } else { [EOL]         Node statement = IR.exprResult(cond.detachFromParent()).copyInformationFrom(cond); [EOL]         n.getParent().replaceChild(n, statement); [EOL]     } [EOL]     reportCodeChange(); [EOL]     return null; [EOL] } <line_num>: 828,866
Node tryFoldDo(Node n) { [EOL]     Preconditions.checkArgument(n.isDo()); [EOL]     Node cond = NodeUtil.getConditionExpression(n); [EOL]     if (NodeUtil.getImpureBooleanValue(cond) != TernaryValue.FALSE) { [EOL]         return n; [EOL]     } [EOL]     if (hasBreakOrContinue(n)) { [EOL]         return n; [EOL]     } [EOL]     Preconditions.checkState(NodeUtil.isControlStructureCodeBlock(n, n.getFirstChild())); [EOL]     Node block = n.removeFirstChild(); [EOL]     Node parent = n.getParent(); [EOL]     parent.replaceChild(n, block); [EOL]     if (mayHaveSideEffects(cond)) { [EOL]         Node condStatement = IR.exprResult(cond.detachFromParent()).srcref(cond); [EOL]         parent.addChildAfter(condStatement, block); [EOL]     } [EOL]     reportCodeChange(); [EOL]     return n; [EOL] } <line_num>: 873,901
boolean hasBreakOrContinue(Node n) { [EOL]     return NodeUtil.has(n, Predicates.<Node>or(new NodeUtil.MatchNodeType(Token.BREAK), new NodeUtil.MatchNodeType(Token.CONTINUE)), NodeUtil.MATCH_NOT_FUNCTION); [EOL] } <line_num>: 906,916
private void tryFoldForCondition(Node forCondition) { [EOL]     if (NodeUtil.getPureBooleanValue(forCondition) == TernaryValue.TRUE) { [EOL]         forCondition.getParent().replaceChild(forCondition, IR.empty()); [EOL]         reportCodeChange(); [EOL]     } [EOL] } <line_num>: 921,927
