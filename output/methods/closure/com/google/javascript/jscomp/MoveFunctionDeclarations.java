MoveFunctionDeclarations(AbstractCompiler compiler) { [EOL]     this.compiler = compiler; [EOL]     functions = Maps.newHashMap(); [EOL] } <line_num>: 51,54
@Override [EOL] public void process(Node externs, Node root) { [EOL]     NodeTraversal.traverse(compiler, root, this); [EOL]     for (Entry<JSModule, List<Node>> entry : functions.entrySet()) { [EOL]         JSModule module = entry.getKey(); [EOL]         Node addingRoot = compiler.getNodeForCodeInsertion(module); [EOL]         for (Node n : Lists.reverse(entry.getValue())) { [EOL]             addingRoot.addChildToFront(n); [EOL]         } [EOL]     } [EOL] } <line_num>: 56,66
@Override [EOL] public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { [EOL]     Node gramps = n.getAncestor(2); [EOL]     return gramps == null || !gramps.isScript(); [EOL] } <line_num>: 68,72
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (parent == null || !parent.isScript()) { [EOL]         return; [EOL]     } [EOL]     if (NodeUtil.isFunctionDeclaration(n)) { [EOL]         parent.removeChild(n); [EOL]         compiler.reportCodeChange(); [EOL]         JSModule module = t.getModule(); [EOL]         List<Node> moduleFunctions = functions.get(module); [EOL]         if (moduleFunctions == null) { [EOL]             moduleFunctions = Lists.newArrayList(); [EOL]             functions.put(module, moduleFunctions); [EOL]         } [EOL]         moduleFunctions.add(n); [EOL]     } [EOL] } <line_num>: 74,92
