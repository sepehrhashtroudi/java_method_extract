public FunctionInjector(AbstractCompiler compiler, Supplier<String> safeNameIdSupplier, boolean allowDecomposition, boolean assumeStrictThis, boolean assumeMinimumCapture) { [EOL]     Preconditions.checkNotNull(compiler); [EOL]     Preconditions.checkNotNull(safeNameIdSupplier); [EOL]     this.compiler = compiler; [EOL]     this.safeNameIdSupplier = safeNameIdSupplier; [EOL]     this.allowDecomposition = allowDecomposition; [EOL]     this.assumeStrictThis = assumeStrictThis; [EOL]     this.assumeMinimumCapture = assumeMinimumCapture; [EOL] } <line_num>: 52,65
Reference(Node callNode, JSModule module, InliningMode mode) { [EOL]     this.callNode = callNode; [EOL]     this.module = module; [EOL]     this.mode = mode; [EOL] } <line_num>: 88,92
@Override [EOL] public boolean apply(Node n) { [EOL]     if (n.isName()) { [EOL]         return n.getString().equals("eval") || (!fnName.isEmpty() && n.getString().equals(fnName)) || (!fnRecursionName.isEmpty() && n.getString().equals(fnRecursionName)); [EOL]     } [EOL]     return false; [EOL] } <line_num>: 144,154
boolean doesFunctionMeetMinimumRequirements(final String fnName, Node fnNode) { [EOL]     Node block = NodeUtil.getFunctionBody(fnNode); [EOL]     if (!compiler.getCodingConvention().isInlinableFunction(fnNode)) { [EOL]         return false; [EOL]     } [EOL]     final String fnRecursionName = fnNode.getFirstChild().getString(); [EOL]     Preconditions.checkState(fnRecursionName != null); [EOL]     boolean referencesArguments = NodeUtil.isNameReferenced(block, "arguments", NodeUtil.MATCH_NOT_FUNCTION); [EOL]     Predicate<Node> p = new Predicate<Node>() { [EOL]  [EOL]         @Override [EOL]         public boolean apply(Node n) { [EOL]             if (n.isName()) { [EOL]                 return n.getString().equals("eval") || (!fnName.isEmpty() && n.getString().equals(fnName)) || (!fnRecursionName.isEmpty() && n.getString().equals(fnRecursionName)); [EOL]             } [EOL]             return false; [EOL]         } [EOL]     }; [EOL]     return !referencesArguments && !NodeUtil.has(block, p, Predicates.<Node>alwaysTrue()); [EOL] } <line_num>: 119,159
CanInlineResult canInlineReferenceToFunction(NodeTraversal t, Node callNode, Node fnNode, Set<String> needAliases, InliningMode mode, boolean referencesThis, boolean containsFunctions) { [EOL]     if (!isSupportedCallType(callNode)) { [EOL]         return CanInlineResult.NO; [EOL]     } [EOL]     if (containsFunctions) { [EOL]         if (!assumeMinimumCapture && !t.inGlobalScope()) { [EOL]             return CanInlineResult.NO; [EOL]         } else if (NodeUtil.isWithinLoop(callNode)) { [EOL]             return CanInlineResult.NO; [EOL]         } [EOL]     } [EOL]     if (referencesThis && !NodeUtil.isFunctionObjectCall(callNode)) { [EOL]         return CanInlineResult.NO; [EOL]     } [EOL]     if (mode == InliningMode.DIRECT) { [EOL]         return canInlineReferenceDirectly(callNode, fnNode); [EOL]     } else { [EOL]         return canInlineReferenceAsStatementBlock(t, callNode, fnNode, needAliases); [EOL]     } [EOL] } <line_num>: 173,213
private boolean isSupportedCallType(Node callNode) { [EOL]     if (!callNode.getFirstChild().isName()) { [EOL]         if (NodeUtil.isFunctionObjectCall(callNode)) { [EOL]             if (!assumeStrictThis) { [EOL]                 Node thisValue = callNode.getFirstChild().getNext(); [EOL]                 if (thisValue == null || !thisValue.isThis()) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]         } else if (NodeUtil.isFunctionObjectApply(callNode)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 220,235
Node inline(NodeTraversal t, Node callNode, String fnName, Node fnNode, InliningMode mode) { [EOL]     Preconditions.checkState(compiler.getLifeCycleStage().isNormalized()); [EOL]     if (mode == InliningMode.DIRECT) { [EOL]         return inlineReturnValue(callNode, fnNode); [EOL]     } else { [EOL]         return inlineFunction(callNode, fnNode, fnName); [EOL]     } [EOL] } <line_num>: 240,250
private Node inlineReturnValue(Node callNode, Node fnNode) { [EOL]     Node block = fnNode.getLastChild(); [EOL]     Node callParentNode = callNode.getParent(); [EOL]     Map<String, Node> argMap = FunctionArgumentInjector.getFunctionCallParameterMap(fnNode, callNode, this.safeNameIdSupplier); [EOL]     Node newExpression; [EOL]     if (!block.hasChildren()) { [EOL]         Node srcLocation = block; [EOL]         newExpression = NodeUtil.newUndefinedNode(srcLocation); [EOL]     } else { [EOL]         Node returnNode = block.getFirstChild(); [EOL]         Preconditions.checkArgument(returnNode.isReturn()); [EOL]         Node safeReturnNode = returnNode.cloneTree(); [EOL]         Node inlineResult = FunctionArgumentInjector.inject(null, safeReturnNode, null, argMap); [EOL]         Preconditions.checkArgument(safeReturnNode == inlineResult); [EOL]         newExpression = safeReturnNode.removeFirstChild(); [EOL]     } [EOL]     callParentNode.replaceChild(callNode, newExpression); [EOL]     return newExpression; [EOL] } <line_num>: 257,288
@Override [EOL] public void prepare(FunctionInjector injector, Node callNode) { [EOL]     throw new IllegalStateException("unexpected"); [EOL] } <line_num>: 300,303
@Override [EOL] public void prepare(FunctionInjector injector, Node callNode) { [EOL] } <line_num>: 312,315
@Override [EOL] public void prepare(FunctionInjector injector, Node callNode) { [EOL] } <line_num>: 327,330
@Override [EOL] public void prepare(FunctionInjector injector, Node callNode) { [EOL] } <line_num>: 342,345
@Override [EOL] public void prepare(FunctionInjector injector, Node callNode) { [EOL]     injector.getDecomposer().moveExpression(callNode); [EOL]     CallSiteType callSiteType = injector.classifyCallSite(callNode); [EOL]     Preconditions.checkState(this != callSiteType); [EOL]     callSiteType.prepare(injector, callNode); [EOL] } <line_num>: 361,369
@Override [EOL] public void prepare(FunctionInjector injector, Node callNode) { [EOL]     injector.getDecomposer().maybeExposeExpression(callNode); [EOL]     CallSiteType callSiteType = injector.classifyCallSite(callNode); [EOL]     Preconditions.checkState(this != callSiteType); [EOL]     callSiteType.prepare(injector, callNode); [EOL] } <line_num>: 378,386
public abstract void prepare(FunctionInjector injector, Node callNode); <line_num>: 389,389
private CallSiteType classifyCallSite(Node callNode) { [EOL]     Node parent = callNode.getParent(); [EOL]     Node grandParent = parent.getParent(); [EOL]     if (NodeUtil.isExprCall(parent)) { [EOL]         return CallSiteType.SIMPLE_CALL; [EOL]     } else if (NodeUtil.isExprAssign(grandParent) && !NodeUtil.isVarOrSimpleAssignLhs(callNode, parent) && parent.getFirstChild().isName() && !NodeUtil.isConstantName(parent.getFirstChild())) { [EOL]         return CallSiteType.SIMPLE_ASSIGNMENT; [EOL]     } else if (parent.isName() && !NodeUtil.isConstantName(parent) && grandParent.isVar() && grandParent.hasOneChild()) { [EOL]         return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT; [EOL]     } else { [EOL]         Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode); [EOL]         if (expressionRoot != null) { [EOL]             ExpressionDecomposer decomposer = new ExpressionDecomposer(compiler, safeNameIdSupplier, knownConstants); [EOL]             DecompositionType type = decomposer.canExposeExpression(callNode); [EOL]             if (type == DecompositionType.MOVABLE) { [EOL]                 return CallSiteType.EXPRESSION; [EOL]             } else if (type == DecompositionType.DECOMPOSABLE) { [EOL]                 return CallSiteType.DECOMPOSABLE_EXPRESSION; [EOL]             } else { [EOL]                 Preconditions.checkState(type == DecompositionType.UNDECOMPOSABLE); [EOL]             } [EOL]         } [EOL]     } [EOL]     return CallSiteType.UNSUPPORTED; [EOL] } <line_num>: 395,435
private ExpressionDecomposer getDecomposer() { [EOL]     return new ExpressionDecomposer(compiler, safeNameIdSupplier, knownConstants); [EOL] } <line_num>: 437,440
void maybePrepareCall(Node callNode) { [EOL]     CallSiteType callSiteType = classifyCallSite(callNode); [EOL]     callSiteType.prepare(this, callNode); [EOL] } <line_num>: 446,449
private Node inlineFunction(Node callNode, Node fnNode, String fnName) { [EOL]     Node parent = callNode.getParent(); [EOL]     Node grandParent = parent.getParent(); [EOL]     CallSiteType callSiteType = classifyCallSite(callNode); [EOL]     Preconditions.checkArgument(callSiteType != CallSiteType.UNSUPPORTED); [EOL]     boolean isCallInLoop = NodeUtil.isWithinLoop(callNode); [EOL]     String resultName = null; [EOL]     boolean needsDefaultReturnResult = true; [EOL]     switch(callSiteType) { [EOL]         case SIMPLE_ASSIGNMENT: [EOL]             resultName = parent.getFirstChild().getString(); [EOL]             break; [EOL]         case VAR_DECL_SIMPLE_ASSIGNMENT: [EOL]             resultName = parent.getString(); [EOL]             break; [EOL]         case SIMPLE_CALL: [EOL]             resultName = null; [EOL]             needsDefaultReturnResult = false; [EOL]             break; [EOL]         case EXPRESSION: [EOL]             throw new IllegalStateException("Movable expressions must be moved before inlining."); [EOL]         case DECOMPOSABLE_EXPRESSION: [EOL]             throw new IllegalStateException("Decomposable expressions must be decomposed before inlining."); [EOL]         default: [EOL]             throw new IllegalStateException("Unexpected call site type."); [EOL]     } [EOL]     FunctionToBlockMutator mutator = new FunctionToBlockMutator(compiler, this.safeNameIdSupplier); [EOL]     Node newBlock = mutator.mutate(fnName, fnNode, callNode, resultName, needsDefaultReturnResult, isCallInLoop); [EOL]     Node greatGrandParent = grandParent.getParent(); [EOL]     switch(callSiteType) { [EOL]         case VAR_DECL_SIMPLE_ASSIGNMENT: [EOL]             parent.removeChild(parent.getFirstChild()); [EOL]             Preconditions.checkState(parent.getFirstChild() == null); [EOL]             greatGrandParent.addChildAfter(newBlock, grandParent); [EOL]             break; [EOL]         case SIMPLE_ASSIGNMENT: [EOL]             Preconditions.checkState(grandParent.isExprResult()); [EOL]             greatGrandParent.replaceChild(grandParent, newBlock); [EOL]             break; [EOL]         case SIMPLE_CALL: [EOL]             Preconditions.checkState(parent.isExprResult()); [EOL]             grandParent.replaceChild(parent, newBlock); [EOL]             break; [EOL]         default: [EOL]             throw new IllegalStateException("Unexpected call site type."); [EOL]     } [EOL]     return newBlock; [EOL] } <line_num>: 456,537
boolean isDirectCallNodeReplacementPossible(Node fnNode) { [EOL]     Node block = NodeUtil.getFunctionBody(fnNode); [EOL]     if (!block.hasChildren()) { [EOL]         return true; [EOL]     } else if (block.hasOneChild()) { [EOL]         if (block.getFirstChild().isReturn() && block.getFirstChild().getFirstChild() != null) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 543,561
private CanInlineResult canInlineReferenceAsStatementBlock(NodeTraversal t, Node callNode, Node fnNode, Set<String> namesToAlias) { [EOL]     CallSiteType callSiteType = classifyCallSite(callNode); [EOL]     if (callSiteType == CallSiteType.UNSUPPORTED) { [EOL]         return CanInlineResult.NO; [EOL]     } [EOL]     if (!allowDecomposition && (callSiteType == CallSiteType.DECOMPOSABLE_EXPRESSION || callSiteType == CallSiteType.EXPRESSION)) { [EOL]         return CanInlineResult.NO; [EOL]     } [EOL]     if (!callMeetsBlockInliningRequirements(t, callNode, fnNode, namesToAlias)) { [EOL]         return CanInlineResult.NO; [EOL]     } [EOL]     if (callSiteType == CallSiteType.DECOMPOSABLE_EXPRESSION || callSiteType == CallSiteType.EXPRESSION) { [EOL]         return CanInlineResult.AFTER_PREPARATION; [EOL]     } else { [EOL]         return CanInlineResult.YES; [EOL]     } [EOL] } <line_num>: 580,604
@Override [EOL] public boolean apply(Node n) { [EOL]     if (n.isName()) { [EOL]         return n.getString().equals("eval"); [EOL]     } [EOL]     if (!assumeMinimumCapture && n.isFunction()) { [EOL]         return n != fnNode; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 638,647
private boolean callMeetsBlockInliningRequirements(NodeTraversal t, Node callNode, final Node fnNode, Set<String> namesToAlias) { [EOL]     final boolean assumeMinimumCapture = this.assumeMinimumCapture; [EOL]     boolean fnContainsVars = NodeUtil.has(NodeUtil.getFunctionBody(fnNode), new NodeUtil.MatchDeclaration(), new NodeUtil.MatchShallowStatement()); [EOL]     boolean forbidTemps = false; [EOL]     if (!t.inGlobalScope()) { [EOL]         Node fnCaller = t.getScopeRoot(); [EOL]         Node fnCallerBody = fnCaller.getLastChild(); [EOL]         Predicate<Node> match = new Predicate<Node>() { [EOL]  [EOL]             @Override [EOL]             public boolean apply(Node n) { [EOL]                 if (n.isName()) { [EOL]                     return n.getString().equals("eval"); [EOL]                 } [EOL]                 if (!assumeMinimumCapture && n.isFunction()) { [EOL]                     return n != fnNode; [EOL]                 } [EOL]                 return false; [EOL]             } [EOL]         }; [EOL]         forbidTemps = NodeUtil.has(fnCallerBody, match, NodeUtil.MATCH_NOT_FUNCTION); [EOL]     } [EOL]     if (fnContainsVars && forbidTemps) { [EOL]         return false; [EOL]     } [EOL]     if (forbidTemps) { [EOL]         Map<String, Node> args = FunctionArgumentInjector.getFunctionCallParameterMap(fnNode, callNode, this.safeNameIdSupplier); [EOL]         boolean hasArgs = !args.isEmpty(); [EOL]         if (hasArgs) { [EOL]             Set<String> allNamesToAlias = Sets.newHashSet(namesToAlias); [EOL]             FunctionArgumentInjector.maybeAddTempsForCallArguments(fnNode, args, allNamesToAlias, compiler.getCodingConvention()); [EOL]             if (!allNamesToAlias.isEmpty()) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] } <line_num>: 611,676
private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) { [EOL]     if (!isDirectCallNodeReplacementPossible(fnNode)) { [EOL]         return CanInlineResult.NO; [EOL]     } [EOL]     Node block = fnNode.getLastChild(); [EOL]     Node cArg = callNode.getFirstChild().getNext(); [EOL]     if (!callNode.getFirstChild().isName()) { [EOL]         if (NodeUtil.isFunctionObjectCall(callNode)) { [EOL]             if (cArg == null || !cArg.isThis()) { [EOL]                 return CanInlineResult.NO; [EOL]             } [EOL]             cArg = cArg.getNext(); [EOL]         } else { [EOL]             Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode)); [EOL]         } [EOL]     } [EOL]     Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); [EOL]     while (cArg != null || fnParam != null) { [EOL]         if (fnParam != null) { [EOL]             if (cArg != null) { [EOL]                 if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) { [EOL]                     return CanInlineResult.NO; [EOL]                 } [EOL]             } [EOL]             fnParam = fnParam.getNext(); [EOL]         } [EOL]         if (cArg != null) { [EOL]             if (NodeUtil.mayHaveSideEffects(cArg, compiler)) { [EOL]                 return CanInlineResult.NO; [EOL]             } [EOL]             cArg = cArg.getNext(); [EOL]         } [EOL]     } [EOL]     return CanInlineResult.YES; [EOL] } <line_num>: 690,748
boolean inliningLowersCost(JSModule fnModule, Node fnNode, Collection<? extends Reference> refs, Set<String> namesToAlias, boolean isRemovable, boolean referencesThis) { [EOL]     int referenceCount = refs.size(); [EOL]     if (referenceCount == 0) { [EOL]         return true; [EOL]     } [EOL]     int referencesUsingBlockInlining = 0; [EOL]     boolean checkModules = isRemovable && fnModule != null; [EOL]     JSModuleGraph moduleGraph = compiler.getModuleGraph(); [EOL]     for (Reference ref : refs) { [EOL]         if (ref.mode == InliningMode.BLOCK) { [EOL]             referencesUsingBlockInlining++; [EOL]         } [EOL]         if (checkModules && ref.module != null) { [EOL]             if (ref.module != fnModule && !moduleGraph.dependsOn(ref.module, fnModule)) { [EOL]                 isRemovable = false; [EOL]                 checkModules = false; [EOL]             } [EOL]         } [EOL]     } [EOL]     int referencesUsingDirectInlining = referenceCount - referencesUsingBlockInlining; [EOL]     if (referenceCount == 1 && isRemovable && referencesUsingDirectInlining == 1) { [EOL]         return true; [EOL]     } [EOL]     int callCost = estimateCallCost(fnNode, referencesThis); [EOL]     int overallCallCost = callCost * referenceCount; [EOL]     int costDeltaDirect = inlineCostDelta(fnNode, namesToAlias, InliningMode.DIRECT); [EOL]     int costDeltaBlock = inlineCostDelta(fnNode, namesToAlias, InliningMode.BLOCK); [EOL]     return doesLowerCost(fnNode, overallCallCost, referencesUsingDirectInlining, costDeltaDirect, referencesUsingBlockInlining, costDeltaBlock, isRemovable); [EOL] } <line_num>: 754,810
private boolean doesLowerCost(Node fnNode, int callCost, int directInlines, int costDeltaDirect, int blockInlines, int costDeltaBlock, boolean removable) { [EOL]     int fnInstanceCount = directInlines + blockInlines - (removable ? 1 : 0); [EOL]     if (fnInstanceCount == 0) { [EOL]         if (blockInlines > 0 && costDeltaBlock > 0) { [EOL]             return false; [EOL]         } [EOL]         return true; [EOL]     } [EOL]     int costDelta = (directInlines * costDeltaDirect) + (blockInlines * costDeltaBlock); [EOL]     int threshold = (callCost - costDelta) / fnInstanceCount; [EOL]     return InlineCostEstimator.getCost(fnNode, threshold + 1) <= threshold; [EOL] } <line_num>: 815,843
private static int estimateCallCost(Node fnNode, boolean referencesThis) { [EOL]     Node argsNode = NodeUtil.getFunctionParameters(fnNode); [EOL]     int numArgs = argsNode.getChildCount(); [EOL]     int callCost = NAME_COST_ESTIMATE + PAREN_COST; [EOL]     if (numArgs > 0) { [EOL]         callCost += (numArgs * NAME_COST_ESTIMATE) + ((numArgs - 1) * COMMA_COST); [EOL]     } [EOL]     if (referencesThis) { [EOL]         callCost += 5 + 5; [EOL]     } [EOL]     return callCost; [EOL] } <line_num>: 850,868
private static int inlineCostDelta(Node fnNode, Set<String> namesToAlias, InliningMode mode) { [EOL]     int paramCount = NodeUtil.getFunctionParameters(fnNode).getChildCount(); [EOL]     int commaCount = (paramCount > 1) ? paramCount - 1 : 0; [EOL]     int costDeltaFunctionOverhead = 15 + commaCount + (paramCount * InlineCostEstimator.ESTIMATED_IDENTIFIER_COST); [EOL]     Node block = fnNode.getLastChild(); [EOL]     if (!block.hasChildren()) { [EOL]         return -costDeltaFunctionOverhead; [EOL]     } [EOL]     if (mode == InliningMode.DIRECT) { [EOL]         return -(costDeltaFunctionOverhead + 7); [EOL]     } else { [EOL]         int aliasCount = namesToAlias.size(); [EOL]         final int INLINE_BLOCK_OVERHEAD = 4; [EOL]         final int PER_RETURN_OVERHEAD = 2; [EOL]         final int PER_RETURN_RESULT_OVERHEAD = 3; [EOL]         final int PER_ALIAS_OVERHEAD = 3; [EOL]         int returnCount = NodeUtil.getNodeTypeReferenceCount(block, Token.RETURN, new NodeUtil.MatchShallowStatement()); [EOL]         int resultCount = (returnCount > 0) ? returnCount - 1 : 0; [EOL]         int baseOverhead = (returnCount > 0) ? INLINE_BLOCK_OVERHEAD : 0; [EOL]         int overhead = baseOverhead + returnCount * PER_RETURN_OVERHEAD + resultCount * PER_RETURN_RESULT_OVERHEAD + aliasCount * PER_ALIAS_OVERHEAD; [EOL]         return (overhead - costDeltaFunctionOverhead); [EOL]     } [EOL] } <line_num>: 874,925
public void setKnownConstants(Set<String> knownConstants) { [EOL]     Preconditions.checkState(this.knownConstants.isEmpty()); [EOL]     this.knownConstants = knownConstants; [EOL] } <line_num>: 931,936
