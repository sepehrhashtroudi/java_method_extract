CrossModuleCodeMotion(AbstractCompiler compiler, JSModuleGraph graph) { [EOL]     this.compiler = compiler; [EOL]     this.graph = graph; [EOL] } <line_num>: 67,70
Declaration(JSModule module, Node node, Node parent, Node gramps) { [EOL]     this.module = module; [EOL]     this.node = node; [EOL] } <line_num>: 191,194
@Override [EOL] public void process(Node externs, Node root) { [EOL]     logger.fine("Moving functions + variable into deeper modules"); [EOL]     if (graph != null && graph.getModuleCount() > 1) { [EOL]         NodeTraversal.traverse(compiler, root, this); [EOL]         moveCode(); [EOL]     } [EOL] } <line_num>: 72,85
private void moveCode() { [EOL]     for (NamedInfo info : namedInfo.values()) { [EOL]         JSModule deepestDependency = info.deepestModule; [EOL]         if (info.allowMove && deepestDependency != null) { [EOL]             Iterator<Declaration> it = info.declarationIterator(); [EOL]             JSModuleGraph moduleGraph = compiler.getModuleGraph(); [EOL]             while (it.hasNext()) { [EOL]                 Declaration decl = it.next(); [EOL]                 if (decl.module != null && moduleGraph.dependsOn(deepestDependency, decl.module)) { [EOL]                     Node destParent = moduleVarParentMap.get(deepestDependency); [EOL]                     if (destParent == null) { [EOL]                         destParent = compiler.getNodeForCodeInsertion(deepestDependency); [EOL]                         moduleVarParentMap.put(deepestDependency, destParent); [EOL]                     } [EOL]                     Node declParent = decl.node.getParent(); [EOL]                     Preconditions.checkState(!declParent.isVar() || declParent.hasOneChild(), "AST not normalized."); [EOL]                     declParent.detachFromParent(); [EOL]                     destParent.addChildToFront(declParent); [EOL]                     compiler.reportCodeChange(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 88,130
void addUsedModule(JSModule m) { [EOL]     if (!allowMove) { [EOL]         return; [EOL]     } [EOL]     if (deepestModule == null) { [EOL]         deepestModule = m; [EOL]     } else { [EOL]         deepestModule = graph.getDeepestCommonDependencyInclusive(m, deepestModule); [EOL]     } [EOL] } <line_num>: 147,161
boolean addDeclaration(Declaration d) { [EOL]     if (declModule != null && d.module != declModule) { [EOL]         return false; [EOL]     } [EOL]     declarations.push(d); [EOL]     declModule = d.module; [EOL]     return true; [EOL] } <line_num>: 168,176
Iterator<Declaration> declarationIterator() { [EOL]     return declarations.iterator(); [EOL] } <line_num>: 182,184
private boolean hasConditionalAncestor(Node n) { [EOL]     for (Node ancestor : n.getAncestors()) { [EOL]         switch(ancestor.getType()) { [EOL]             case Token.DO: [EOL]             case Token.FOR: [EOL]             case Token.HOOK: [EOL]             case Token.IF: [EOL]             case Token.SWITCH: [EOL]             case Token.WHILE: [EOL]             case Token.FUNCTION: [EOL]                 return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 202,216
private NamedInfo getNamedInfo(Var v) { [EOL]     NamedInfo info = namedInfo.get(v); [EOL]     if (info == null) { [EOL]         info = new NamedInfo(); [EOL]         namedInfo.put(v, info); [EOL]     } [EOL]     return info; [EOL] } <line_num>: 221,228
private void processReference(NodeTraversal t, NamedInfo info, String name) { [EOL]     boolean recursive = false; [EOL]     Node rootNode = t.getScope().getRootNode(); [EOL]     if (rootNode.isFunction()) { [EOL]         String scopeFuncName = rootNode.getFirstChild().getString(); [EOL]         Node scopeFuncParent = rootNode.getParent(); [EOL]         if (scopeFuncName.equals(name)) { [EOL]             recursive = true; [EOL]         } else if (scopeFuncParent.isName() && scopeFuncParent.getString().equals(name)) { [EOL]             recursive = true; [EOL]         } else { [EOL]             for (Scope s = t.getScope(); s.getParent() != null; s = s.getParent()) { [EOL]                 Node curRoot = s.getRootNode(); [EOL]                 if (curRoot.getParent().isAssign()) { [EOL]                     Node owner = curRoot.getParent().getFirstChild(); [EOL]                     while (owner.isGetProp()) { [EOL]                         owner = owner.getFirstChild(); [EOL]                     } [EOL]                     if (owner.isName() && owner.getString().equals(name)) { [EOL]                         recursive = true; [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (!recursive) { [EOL]         info.addUsedModule(t.getModule()); [EOL]     } [EOL] } <line_num>: 233,276
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     if (!n.isName()) { [EOL]         return; [EOL]     } [EOL]     String name = n.getString(); [EOL]     if (name.isEmpty() || compiler.getCodingConvention().isExported(name)) { [EOL]         return; [EOL]     } [EOL]     Var v = t.getScope().getVar(name); [EOL]     if (v == null || !v.isGlobal()) { [EOL]         return; [EOL]     } [EOL]     NamedInfo info = getNamedInfo(v); [EOL]     if (info.allowMove) { [EOL]         if (maybeProcessDeclaration(t, n, parent, info)) { [EOL]             if (hasConditionalAncestor(parent.getParent())) { [EOL]                 info.allowMove = false; [EOL]             } [EOL]         } else { [EOL]             processReference(t, info, name); [EOL]         } [EOL]     } [EOL] } <line_num>: 278,314
private boolean maybeProcessDeclaration(NodeTraversal t, Node name, Node parent, NamedInfo info) { [EOL]     Node gramps = parent.getParent(); [EOL]     switch(parent.getType()) { [EOL]         case Token.VAR: [EOL]             if (canMoveValue(name.getFirstChild())) { [EOL]                 return info.addDeclaration(new Declaration(t.getModule(), name, parent, gramps)); [EOL]             } [EOL]             return false; [EOL]         case Token.FUNCTION: [EOL]             if (NodeUtil.isFunctionDeclaration(parent)) { [EOL]                 return info.addDeclaration(new Declaration(t.getModule(), name, parent, gramps)); [EOL]             } [EOL]             return false; [EOL]         case Token.ASSIGN: [EOL]         case Token.GETPROP: [EOL]             Node child = name; [EOL]             for (Node current : name.getAncestors()) { [EOL]                 if (current.isGetProp()) { [EOL]                 } else if (current.isAssign() && current.getFirstChild() == child) { [EOL]                     Node currentParent = current.getParent(); [EOL]                     if (currentParent.isExprResult() && canMoveValue(current.getLastChild())) { [EOL]                         return info.addDeclaration(new Declaration(t.getModule(), current, currentParent, currentParent.getParent())); [EOL]                     } [EOL]                 } else { [EOL]                     return false; [EOL]                 } [EOL]                 child = current; [EOL]             } [EOL]             return false; [EOL]         case Token.CALL: [EOL]             if (NodeUtil.isExprCall(gramps)) { [EOL]                 SubclassRelationship relationship = compiler.getCodingConvention().getClassesDefinedByCall(parent); [EOL]                 if (relationship != null && name.getString().equals(relationship.subclassName)) { [EOL]                     return info.addDeclaration(new Declaration(t.getModule(), parent, gramps, gramps.getParent())); [EOL]                 } [EOL]             } [EOL]             return false; [EOL]         default: [EOL]             return false; [EOL]     } [EOL] } <line_num>: 331,391
private boolean canMoveValue(Node n) { [EOL]     if (n == null || NodeUtil.isLiteralValue(n, true) || n.isFunction()) { [EOL]         return true; [EOL]     } else if (n.isCall()) { [EOL]         Node functionName = n.getFirstChild(); [EOL]         return functionName.isName() && (functionName.getString().equals(CrossModuleMethodMotion.STUB_METHOD_NAME) || functionName.getString().equals(CrossModuleMethodMotion.UNSTUB_METHOD_NAME)); [EOL]     } else if (n.isArrayLit() || n.isObjectLit()) { [EOL]         boolean isObjectLit = n.isObjectLit(); [EOL]         for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { [EOL]             if (!canMoveValue(isObjectLit ? child.getFirstChild() : child)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 396,426
