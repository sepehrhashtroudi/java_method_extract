MethodCompilerPass(AbstractCompiler compiler) { [EOL]     this.compiler = compiler; [EOL] } <line_num>: 64,66
public void reset(); <line_num>: 58,58
public void addSignature(String functionName, Node functionNode, String sourceFile); <line_num>: 59,60
public void removeSignature(String functionName); <line_num>: 61,61
@Override [EOL] public void process(Node externs, Node root) { [EOL]     externMethods.clear(); [EOL]     externMethodsWithoutSignatures.clear(); [EOL]     getSignatureStore().reset(); [EOL]     methodDefinitions.clear(); [EOL]     if (externs != null) { [EOL]         NodeTraversal.traverse(compiler, externs, new GetExternMethods()); [EOL]     } [EOL]     List<Node> externsAndJs = Lists.newArrayList(externs, root); [EOL]     NodeTraversal.traverseRoots(compiler, Lists.newArrayList(externs, root), new GatherSignatures()); [EOL]     NodeTraversal.traverseRoots(compiler, externsAndJs, getActingCallback()); [EOL] } <line_num>: 68,85
abstract Callback getActingCallback(); <line_num>: 91,91
abstract SignatureStore getSignatureStore(); <line_num>: 97,97
private void addPossibleSignature(String name, Node node, NodeTraversal t) { [EOL]     if (node.isFunction()) { [EOL]         addSignature(name, node, t.getSourceName()); [EOL]     } else { [EOL]         nonMethodProperties.add(name); [EOL]     } [EOL] } <line_num>: 103,110
private void addSignature(String name, Node function, String fnSourceName) { [EOL]     if (externMethodsWithoutSignatures.contains(name)) { [EOL]         return; [EOL]     } [EOL]     getSignatureStore().addSignature(name, function, fnSourceName); [EOL]     methodDefinitions.put(name, function); [EOL] } <line_num>: 112,119
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     switch(n.getType()) { [EOL]         case Token.GETPROP: [EOL]         case Token.GETELEM: [EOL]             { [EOL]                 Node dest = n.getFirstChild().getNext(); [EOL]                 if (!dest.isString()) { [EOL]                     return; [EOL]                 } [EOL]                 String name = dest.getString(); [EOL]                 if (parent.isAssign() && parent.getFirstChild() == n && n.getNext().isFunction()) { [EOL]                     addSignature(name, n.getNext(), t.getSourceName()); [EOL]                 } else { [EOL]                     getSignatureStore().removeSignature(name); [EOL]                     externMethodsWithoutSignatures.add(name); [EOL]                 } [EOL]                 externMethods.add(name); [EOL]             } [EOL]             break; [EOL]         case Token.OBJECTLIT: [EOL]             { [EOL]                 for (Node key = n.getFirstChild(); key != null; key = key.getNext()) { [EOL]                     Node value = key.getFirstChild(); [EOL]                     String name = key.getString(); [EOL]                     if (key.isStringKey() && value.isFunction()) { [EOL]                         addSignature(name, value, t.getSourceName()); [EOL]                     } else { [EOL]                         getSignatureStore().removeSignature(name); [EOL]                         externMethodsWithoutSignatures.add(name); [EOL]                     } [EOL]                     externMethods.add(name); [EOL]                 } [EOL]             } [EOL]             break; [EOL]     } [EOL] } <line_num>: 128,174
@Override [EOL] public void visit(NodeTraversal t, Node n, Node parent) { [EOL]     switch(n.getType()) { [EOL]         case Token.GETPROP: [EOL]         case Token.GETELEM: [EOL]             Node dest = n.getFirstChild().getNext(); [EOL]             if (dest.isString()) { [EOL]                 if (dest.getString().equals("prototype")) { [EOL]                     processPrototypeParent(t, parent); [EOL]                 } else { [EOL]                     if (parent.isAssign() && parent.getFirstChild() == n) { [EOL]                         addPossibleSignature(dest.getString(), n.getNext(), t); [EOL]                     } [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case Token.OBJECTLIT: [EOL]             for (Node key = n.getFirstChild(); key != null; key = key.getNext()) { [EOL]                 switch(key.getType()) { [EOL]                     case Token.STRING_KEY: [EOL]                         addPossibleSignature(key.getString(), key.getFirstChild(), t); [EOL]                         break; [EOL]                     case Token.SETTER_DEF: [EOL]                     case Token.GETTER_DEF: [EOL]                         nonMethodProperties.add(key.getString()); [EOL]                         break; [EOL]                     default: [EOL]                         throw new IllegalStateException("unexpect OBJECTLIT key: " + key); [EOL]                 } [EOL]             } [EOL]             break; [EOL]     } [EOL] } <line_num>: 182,226
private void processPrototypeParent(NodeTraversal t, Node n) { [EOL]     switch(n.getType()) { [EOL]         case Token.GETPROP: [EOL]         case Token.GETELEM: [EOL]             Node dest = n.getFirstChild().getNext(); [EOL]             Node parent = n.getParent().getParent(); [EOL]             if (dest.isString() && parent.isAssign()) { [EOL]                 Node assignee = parent.getFirstChild().getNext(); [EOL]                 addPossibleSignature(dest.getString(), assignee, t); [EOL]             } [EOL]             break; [EOL]     } [EOL] } <line_num>: 233,258
