public <T extends Comparable<T>> T getFoobar() { [EOL]     return null; [EOL] } <line_num>: 64,64
public void testSimpleTypes() { [EOL]     Class<?>[] classes = new Class<?>[] { boolean.class, byte.class, char.class, short.class, int.class, long.class, float.class, double.class, Boolean.class, Byte.class, Character.class, Short.class, Integer.class, Long.class, Float.class, Double.class, String.class, Object.class, Calendar.class, Date.class }; [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     for (Class<?> clz : classes) { [EOL]         assertSame(clz, tf.constructType(clz).getRawClass()); [EOL]         assertSame(clz, tf.constructType(clz).getRawClass()); [EOL]     } [EOL] } <line_num>: 84,107
public void testArrays() { [EOL]     Class<?>[] classes = new Class<?>[] { boolean[].class, byte[].class, char[].class, short[].class, int[].class, long[].class, float[].class, double[].class, String[].class, Object[].class, Calendar[].class }; [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     for (Class<?> clz : classes) { [EOL]         assertSame(clz, tf.constructType(clz).getRawClass()); [EOL]         Class<?> elemType = clz.getComponentType(); [EOL]         assertSame(clz, tf.constructArrayType(elemType).getRawClass()); [EOL]     } [EOL] } <line_num>: 109,126
public void testCollections() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(ArrayList.class); [EOL]     assertEquals(CollectionType.class, t.getClass()); [EOL]     assertSame(ArrayList.class, t.getRawClass()); [EOL]     t = tf.constructType(new TypeReference<ArrayList<String>>() { [EOL]     }); [EOL]     assertEquals(CollectionType.class, t.getClass()); [EOL]     assertSame(ArrayList.class, t.getRawClass()); [EOL]     JavaType elemType = ((CollectionType) t).getContentType(); [EOL]     assertNotNull(elemType); [EOL]     assertSame(SimpleType.class, elemType.getClass()); [EOL]     assertSame(String.class, elemType.getRawClass()); [EOL]     t = tf.constructCollectionType(ArrayList.class, String.class); [EOL]     assertEquals(CollectionType.class, t.getClass()); [EOL]     assertSame(String.class, ((CollectionType) t).getContentType().getRawClass()); [EOL] } <line_num>: 128,150
public void testMaps() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(HashMap.class); [EOL]     assertEquals(MapType.class, t.getClass()); [EOL]     assertSame(HashMap.class, t.getRawClass()); [EOL]     t = tf.constructMapType(TreeMap.class, String.class, Integer.class); [EOL]     assertEquals(MapType.class, t.getClass()); [EOL]     assertSame(String.class, ((MapType) t).getKeyType().getRawClass()); [EOL]     assertSame(Integer.class, ((MapType) t).getContentType().getRawClass()); [EOL]     t = tf.constructType(new TypeReference<HashMap<String, Integer>>() { [EOL]     }); [EOL]     assertEquals(MapType.class, t.getClass()); [EOL]     assertSame(HashMap.class, t.getRawClass()); [EOL]     MapType mt = (MapType) t; [EOL]     assertEquals(tf.constructType(String.class), mt.getKeyType()); [EOL]     assertEquals(tf.constructType(Integer.class), mt.getContentType()); [EOL]     t = tf.constructType(new TypeReference<LongValuedMap<Boolean>>() { [EOL]     }); [EOL]     assertEquals(MapType.class, t.getClass()); [EOL]     assertSame(LongValuedMap.class, t.getRawClass()); [EOL]     mt = (MapType) t; [EOL]     assertEquals(tf.constructType(Boolean.class), mt.getKeyType()); [EOL]     assertEquals(tf.constructType(Long.class), mt.getContentType()); [EOL] } <line_num>: 152,180
public void testIterator() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(new TypeReference<Iterator<String>>() { [EOL]     }); [EOL]     assertEquals(SimpleType.class, t.getClass()); [EOL]     assertSame(Iterator.class, t.getRawClass()); [EOL]     assertEquals(1, t.containedTypeCount()); [EOL]     assertEquals(tf.constructType(String.class), t.containedType(0)); [EOL]     assertNull(t.containedType(1)); [EOL] } <line_num>: 182,191
public void testParametricTypes() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructParametricType(ArrayList.class, String.class); [EOL]     assertEquals(CollectionType.class, t.getClass()); [EOL]     JavaType strC = tf.constructType(String.class); [EOL]     assertEquals(1, t.containedTypeCount()); [EOL]     assertEquals(strC, t.containedType(0)); [EOL]     assertNull(t.containedType(1)); [EOL]     JavaType t2 = tf.constructParametricType(Map.class, strC, t); [EOL]     assertEquals(MapType.class, t2.getClass()); [EOL]     assertEquals(2, t2.containedTypeCount()); [EOL]     assertEquals(strC, t2.containedType(0)); [EOL]     assertEquals(t, t2.containedType(1)); [EOL]     assertNull(t2.containedType(2)); [EOL]     JavaType custom = tf.constructParametricType(SingleArgGeneric.class, String.class); [EOL]     assertEquals(SimpleType.class, custom.getClass()); [EOL]     assertEquals(1, custom.containedTypeCount()); [EOL]     assertEquals(strC, custom.containedType(0)); [EOL]     assertNull(custom.containedType(1)); [EOL]     assertEquals("X", custom.containedTypeName(0)); [EOL]     try { [EOL]         tf.constructParametricType(Map.class, strC); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "Need exactly 2 parameter types for Map types"); [EOL]     } [EOL]     try { [EOL]         tf.constructParametricType(SingleArgGeneric.class, strC, strC); [EOL]     } catch (IllegalArgumentException e) { [EOL]         verifyException(e, "expected 1 parameters, was given 2"); [EOL]     } [EOL] } <line_num>: 199,242
public void testCanonicalNames() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(java.util.Calendar.class); [EOL]     String can = t.toCanonical(); [EOL]     assertEquals("java.util.Calendar", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.ArrayList.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.ArrayList<java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.TreeMap.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL] } <line_num>: 247,273
public void testSuperTypeDetectionClass() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     HierarchicType sub = tf._findSuperTypeChain(MyStringIntMap.class, HashMap.class); [EOL]     assertNotNull(sub); [EOL]     assertEquals(2, _countSupers(sub)); [EOL]     assertSame(MyStringIntMap.class, sub.getRawClass()); [EOL]     HierarchicType sup = sub.getSuperType(); [EOL]     assertSame(MyStringXMap.class, sup.getRawClass()); [EOL]     HierarchicType sup2 = sup.getSuperType(); [EOL]     assertSame(HashMap.class, sup2.getRawClass()); [EOL]     assertNull(sup2.getSuperType()); [EOL] } <line_num>: 284,296
public void testSuperTypeDetectionInterface() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     HierarchicType sub = tf._findSuperTypeChain(MyList.class, List.class); [EOL]     assertNotNull(sub); [EOL]     assertEquals(2, _countSupers(sub)); [EOL]     assertSame(MyList.class, sub.getRawClass()); [EOL]     HierarchicType sup = sub.getSuperType(); [EOL]     assertSame(IntermediateList.class, sup.getRawClass()); [EOL]     HierarchicType sup2 = sup.getSuperType(); [EOL]     assertSame(List.class, sup2.getRawClass()); [EOL]     assertNull(sup2.getSuperType()); [EOL]     sub = tf._findSuperTypeChain(MyMap.class, Map.class); [EOL]     assertNotNull(sub); [EOL]     assertEquals(2, _countSupers(sub)); [EOL]     assertSame(MyMap.class, sub.getRawClass()); [EOL]     sup = sub.getSuperType(); [EOL]     assertSame(IntermediateMap.class, sup.getRawClass()); [EOL]     sup2 = sup.getSuperType(); [EOL]     assertSame(Map.class, sup2.getRawClass()); [EOL]     assertNull(sup2.getSuperType()); [EOL] } <line_num>: 301,325
public void testAtomicArrayRefParameterDetection() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(new TypeReference<AtomicReference<long[]>>() { [EOL]     }); [EOL]     HierarchicType sub = tf._findSuperTypeChain(type.getRawClass(), AtomicReference.class); [EOL]     assertNotNull(sub); [EOL]     assertEquals(0, _countSupers(sub)); [EOL]     assertTrue(AtomicReference.class.isAssignableFrom(type.getRawClass())); [EOL]     assertNull(sub.getSuperType()); [EOL] } <line_num>: 330,339
private int _countSupers(HierarchicType t) { [EOL]     int depth = 0; [EOL]     for (HierarchicType sup = t.getSuperType(); sup != null; sup = sup.getSuperType()) { [EOL]         ++depth; [EOL]     } [EOL]     return depth; [EOL] } <line_num>: 341,348
public void testMapTypesSimple() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(new TypeReference<Map<String, Boolean>>() { [EOL]     }); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(String.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Boolean.class), mapType.getContentType()); [EOL] } <line_num>: 359,366
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] } <line_num>: 371,378
public void testMapTypesAdvanced() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(MyMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(String.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Long.class), mapType.getContentType()); [EOL]     type = tf.constructType(MapInterface.class); [EOL]     mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(String.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Integer.class), mapType.getContentType()); [EOL]     type = tf.constructType(MyStringIntMap.class); [EOL]     mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(String.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Integer.class), mapType.getContentType()); [EOL] } <line_num>: 383,400
public void testMapTypesSneaky() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(IntLongMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Integer.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Long.class), mapType.getContentType()); [EOL] } <line_num>: 408,415
public void testSneakyFieldTypes() throws Exception { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     Field field = SneakyBean.class.getDeclaredField("intMap"); [EOL]     JavaType type = tf.constructType(field.getGenericType()); [EOL]     assertTrue(type instanceof MapType); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Integer.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Long.class), mapType.getContentType()); [EOL]     field = SneakyBean.class.getDeclaredField("longList"); [EOL]     type = tf.constructType(field.getGenericType()); [EOL]     assertTrue(type instanceof CollectionType); [EOL]     CollectionType collectionType = (CollectionType) type; [EOL]     assertEquals(tf.constructType(Long.class), collectionType.getContentType()); [EOL] } <line_num>: 422,437
public void testSneakyBeanProperties() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     StringLongMapBean bean = mapper.readValue("{\"value\":{\"a\":123}}", StringLongMapBean.class); [EOL]     assertNotNull(bean); [EOL]     Map<String, Long> map = bean.value; [EOL]     assertEquals(1, map.size()); [EOL]     assertEquals(Long.valueOf(123), map.get("a")); [EOL]     StringListBean bean2 = mapper.readValue("{\"value\":[\"...\"]}", StringListBean.class); [EOL]     assertNotNull(bean2); [EOL]     List<String> list = bean2.value; [EOL]     assertSame(GenericList.class, list.getClass()); [EOL]     assertEquals(1, list.size()); [EOL]     assertEquals("...", list.get(0)); [EOL] } <line_num>: 444,459
public void testAtomicArrayRefParameters() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(new TypeReference<AtomicReference<long[]>>() { [EOL]     }); [EOL]     JavaType[] params = tf.findTypeParameters(type, AtomicReference.class); [EOL]     assertNotNull(params); [EOL]     assertEquals(1, params.length); [EOL]     assertEquals(tf.constructType(long[].class), params[0]); [EOL] } <line_num>: 461,469
public void testSneakySelfRefs() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(new SneakyBean2()); [EOL]     assertEquals("{\"foobar\":null}", json); [EOL] } <line_num>: 471,476
public void testRawCollections() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructRawCollectionType(ArrayList.class); [EOL]     assertTrue(type.isContainerType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getContentType()); [EOL]     type = tf.constructRawCollectionLikeType(String.class); [EOL]     assertTrue(type.isCollectionLikeType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getContentType()); [EOL] } <line_num>: 484,494
public void testRawMaps() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructRawMapType(HashMap.class); [EOL]     assertTrue(type.isContainerType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getKeyType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getContentType()); [EOL]     type = tf.constructRawMapLikeType(String.class); [EOL]     assertTrue(type.isMapLikeType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getKeyType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getContentType()); [EOL] } <line_num>: 496,508
public void testMoreSpecificType() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t1 = tf.constructCollectionType(Collection.class, Object.class); [EOL]     JavaType t2 = tf.constructCollectionType(List.class, Object.class); [EOL]     assertSame(t2, tf.moreSpecificType(t1, t2)); [EOL]     assertSame(t2, tf.moreSpecificType(t2, t1)); [EOL]     t1 = tf.constructType(Double.class); [EOL]     t2 = tf.constructType(Number.class); [EOL]     assertSame(t1, tf.moreSpecificType(t1, t2)); [EOL]     assertSame(t1, tf.moreSpecificType(t2, t1)); [EOL]     t1 = tf.constructType(Double.class); [EOL]     t2 = tf.constructType(String.class); [EOL]     assertSame(t1, tf.moreSpecificType(t1, t2)); [EOL]     assertSame(t2, tf.moreSpecificType(t2, t1)); [EOL] } <line_num>: 516,535
