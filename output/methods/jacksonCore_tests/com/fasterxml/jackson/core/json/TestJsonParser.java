public void testConfig() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ ]"); [EOL]     jp.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.disable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, true); [EOL]     assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, false); [EOL]     assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL]     jp.close(); [EOL] } <line_num>: 16,29
public void testInterningWithStreams() throws Exception { [EOL]     _testIntern(true, true, "a"); [EOL]     _testIntern(true, false, "b"); [EOL] } <line_num>: 31,35
public void testInterningWithReaders() throws Exception { [EOL]     _testIntern(false, true, "c"); [EOL]     _testIntern(false, false, "d"); [EOL] } <line_num>: 37,41
private void _testIntern(boolean useStream, boolean enableIntern, String expName) throws IOException { [EOL]     JsonFactory f = new JsonFactory(); [EOL]     f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, enableIntern); [EOL]     assertEquals(enableIntern, f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL]     final String JSON = "{ \"" + expName + "\" : 1}"; [EOL]     JsonParser jp = useStream ? createParserUsingStream(f, JSON, "UTF-8") : createParserUsingReader(f, JSON); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     String actName = jp.getCurrentName(); [EOL]     assertEquals(expName, actName); [EOL]     if (enableIntern) { [EOL]         assertSame(expName, actName); [EOL]     } else { [EOL]         assertNotSame(expName, actName); [EOL]     } [EOL]     jp.close(); [EOL] } <line_num>: 43,63
public void testSpecExampleSkipping() throws Exception { [EOL]     doTestSpec(false); [EOL] } <line_num>: 70,74
public void testSpecExampleFully() throws Exception { [EOL]     doTestSpec(true); [EOL] } <line_num>: 81,85
public void testKeywords() throws Exception { [EOL]     final String DOC = "{\n" + "\"key1\" : null,\n" + "\"key2\" : true,\n" + "\"key3\" : false,\n" + "\"key4\" : [ false, null, true ]\n" + "}"; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     JsonStreamContext ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertFalse(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertFalse(jp.hasCurrentToken()); [EOL]     assertNull(jp.getText()); [EOL]     assertNull(jp.getTextCharacters()); [EOL]     assertEquals(0, jp.getTextLength()); [EOL]     assertEquals(0, jp.getTextOffset()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertTrue(jp.hasCurrentToken()); [EOL]     JsonLocation loc = jp.getTokenLocation(); [EOL]     assertNotNull(loc); [EOL]     assertEquals(1, loc.getLineNr()); [EOL]     assertEquals(1, loc.getColumnNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(0, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key1"); [EOL]     assertEquals(2, jp.getTokenLocation().getLineNr()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertFalse(ctxt.inRoot()); [EOL]     assertFalse(ctxt.inArray()); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertEquals("key1", ctxt.getCurrentName()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(1, ctxt.getEntryCount()); [EOL]     assertEquals(0, ctxt.getCurrentIndex()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key2"); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertEquals(2, ctxt.getEntryCount()); [EOL]     assertEquals(1, ctxt.getCurrentIndex()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals("key2", ctxt.getCurrentName()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key3"); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]     verifyFieldName(jp, "key4"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inArray()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     assertEquals("key4", ctxt.getParent().getCurrentName()); [EOL]     assertToken(JsonToken.VALUE_FALSE, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inObject()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     ctxt = jp.getParsingContext(); [EOL]     assertTrue(ctxt.inRoot()); [EOL]     assertNull(ctxt.getCurrentName()); [EOL]     jp.close(); [EOL] } <line_num>: 91,192
public void testSkipping() throws Exception { [EOL]     String DOC = "[ 1, 3, [ true, null ], 3, { \"a\":\"b\" }, [ [ ] ], { } ]"; [EOL]     ; [EOL]     JsonParser jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertEquals(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     JsonToken t = jp.nextToken(); [EOL]     if (t != null) { [EOL]         fail("Expected null at end of doc, got " + t); [EOL]     } [EOL]     jp.close(); [EOL]     jp = createParserUsingStream(DOC, "UTF-8"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_ARRAY, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     jp.skipChildren(); [EOL]     assertToken(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] } <line_num>: 194,244
public void testNameEscaping() throws IOException { [EOL]     _testNameEscaping(false); [EOL]     _testNameEscaping(true); [EOL] } <line_num>: 246,250
private void _testNameEscaping(boolean useStream) throws IOException { [EOL]     final Map<String, String> NAME_MAP = new LinkedHashMap<String, String>(); [EOL]     NAME_MAP.put("", ""); [EOL]     NAME_MAP.put("\\\"funny\\\"", "\"funny\""); [EOL]     NAME_MAP.put("\\\\", "\\"); [EOL]     NAME_MAP.put("\\r", "\r"); [EOL]     NAME_MAP.put("\\n", "\n"); [EOL]     NAME_MAP.put("\\t", "\t"); [EOL]     NAME_MAP.put("\\r\\n", "\r\n"); [EOL]     NAME_MAP.put("\\\"\\\"", "\"\""); [EOL]     NAME_MAP.put("Line\\nfeed", "Line\nfeed"); [EOL]     NAME_MAP.put("Yet even longer \\\"name\\\"!", "Yet even longer \"name\"!"); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     int entry = 0; [EOL]     for (Map.Entry<String, String> en : NAME_MAP.entrySet()) { [EOL]         ++entry; [EOL]         String input = en.getKey(); [EOL]         String expResult = en.getValue(); [EOL]         final String DOC = "{ \"" + input + "\":null}"; [EOL]         JsonParser jp = useStream ? jf.createParser(new ByteArrayInputStream(DOC.getBytes("UTF-8"))) : jf.createParser(new StringReader(DOC)); [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         String act = jp.getCurrentName(); [EOL]         assertEquals(act, getAndVerifyText(jp)); [EOL]         if (!expResult.equals(act)) { [EOL]             String msg = "Failed for name #" + entry + "/" + NAME_MAP.size(); [EOL]             if (expResult.length() != act.length()) { [EOL]                 fail(msg + ": exp length " + expResult.length() + ", actual " + act.length()); [EOL]             } [EOL]             assertEquals(msg, expResult, act); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] } <line_num>: 252,293
@SuppressWarnings("resource") [EOL] public void testLongText() throws Exception { [EOL]     final int LEN = 96000; [EOL]     StringBuilder sb = new StringBuilder(LEN + 100); [EOL]     Random r = new Random(99); [EOL]     while (sb.length() < LEN) { [EOL]         sb.append(r.nextInt()); [EOL]         sb.append(" xyz foo"); [EOL]         if (r.nextBoolean()) { [EOL]             sb.append(" and \"bar\""); [EOL]         } else if (r.nextBoolean()) { [EOL]             sb.append(" [whatever].... "); [EOL]         } else { [EOL]             sb.append(" UTF-8-fu: try this {\u00E2/\u0BF8/\uA123!} (look funny?)"); [EOL]         } [EOL]         if (r.nextBoolean()) { [EOL]             if (r.nextBoolean()) { [EOL]                 sb.append('\n'); [EOL]             } else if (r.nextBoolean()) { [EOL]                 sb.append('\r'); [EOL]             } else { [EOL]                 sb.append("\r\n"); [EOL]             } [EOL]         } [EOL]     } [EOL]     final String VALUE = sb.toString(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     StringWriter sw = new StringWriter(LEN + (LEN >> 2)); [EOL]     JsonGenerator jg = jf.createGenerator(sw); [EOL]     jg.writeStartObject(); [EOL]     jg.writeFieldName("doc"); [EOL]     jg.writeString(VALUE); [EOL]     jg.writeEndObject(); [EOL]     jg.close(); [EOL]     final String DOC = sw.toString(); [EOL]     for (int type = 0; type < 3; ++type) { [EOL]         JsonParser jp; [EOL]         switch(type) { [EOL]             default: [EOL]                 jp = jf.createParser(DOC.getBytes("UTF-8")); [EOL]                 break; [EOL]             case 1: [EOL]                 jp = jf.createParser(DOC); [EOL]                 break; [EOL]             case 2: [EOL]                 jp = jf.createParser(encodeInUTF32BE(DOC)); [EOL]                 break; [EOL]         } [EOL]         assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]         assertToken(JsonToken.FIELD_NAME, jp.nextToken()); [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]         String act = getAndVerifyText(jp); [EOL]         if (act.length() != VALUE.length()) { [EOL]             fail("Expected length " + VALUE.length() + ", got " + act.length()); [EOL]         } [EOL]         if (!act.equals(VALUE)) { [EOL]             fail("Long text differs"); [EOL]         } [EOL]         assertEquals("doc", jp.getCurrentName()); [EOL]         assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]         assertNull(jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] } <line_num>: 300,375
public void testBytesAsSource() throws Exception { [EOL]     String JSON = "[ 1, 2, 3, 4 ]"; [EOL]     byte[] b = JSON.getBytes("UTF-8"); [EOL]     int offset = 50; [EOL]     int len = b.length; [EOL]     byte[] src = new byte[offset + len + offset]; [EOL]     System.arraycopy(b, 0, src, offset, len); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonParser jp = jf.createParser(src, offset, len); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(1, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(2, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(3, jp.getIntValue()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(4, jp.getIntValue()); [EOL]     assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     assertNull(jp.nextToken()); [EOL]     jp.close(); [EOL] } <line_num>: 381,407
public void testUtf8BOMHandling() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     bytes.write(0xEF); [EOL]     bytes.write(0xBB); [EOL]     bytes.write(0xBF); [EOL]     bytes.write("[ 1 ]".getBytes("UTF-8")); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonParser jp = jf.createParser(bytes.toByteArray()); [EOL]     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     jp.close(); [EOL] } <line_num>: 410,428
public void testSpacesInURL() throws Exception { [EOL]     File f = File.createTempFile("pre fix&stuff", ".txt"); [EOL]     BufferedWriter w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(f), "UTF-8")); [EOL]     w.write("{ }"); [EOL]     w.close(); [EOL]     URL url = f.toURI().toURL(); [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     JsonParser jp = jf.createParser(url); [EOL]     assertToken(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     assertToken(JsonToken.END_OBJECT, jp.nextToken()); [EOL]     jp.close(); [EOL] } <line_num>: 432,445
private void doTestSpec(boolean verify) throws IOException { [EOL]     doTestSpecIndividual(null, verify); [EOL]     doTestSpecIndividual("UTF-8", verify); [EOL]     doTestSpecIndividual("UTF-16BE", verify); [EOL]     doTestSpecIndividual("UTF-16LE", verify); [EOL]     doTestSpecIndividual("UTF-32", verify); [EOL] } <line_num>: 453,468
private void doTestSpecIndividual(String enc, boolean verify) throws IOException { [EOL]     String doc = SAMPLE_DOC_JSON_SPEC; [EOL]     JsonParser jp; [EOL]     if (enc == null) { [EOL]         jp = createParserUsingReader(doc); [EOL]     } else { [EOL]         jp = createParserUsingStream(doc, enc); [EOL]     } [EOL]     verifyJsonSpecSampleDoc(jp, verify); [EOL]     jp.close(); [EOL] } <line_num>: 470,483
