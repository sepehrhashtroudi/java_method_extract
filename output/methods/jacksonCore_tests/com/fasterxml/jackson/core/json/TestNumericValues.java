public void testSimpleBoolean() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ true ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_TRUE, jp.nextToken()); [EOL]     assertEquals(true, jp.getBooleanValue()); [EOL]     jp.close(); [EOL] } <line_num>: 15,22
public void testSimpleInt() throws Exception { [EOL]     int EXP_I = 1234; [EOL]     JsonParser jp = createParserUsingReader("[ " + EXP_I + " ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonParser.NumberType.INT, jp.getNumberType()); [EOL]     assertEquals("" + EXP_I, jp.getText()); [EOL]     assertEquals(EXP_I, jp.getIntValue()); [EOL]     assertEquals((long) EXP_I, jp.getLongValue()); [EOL]     assertEquals((double) EXP_I, jp.getDoubleValue()); [EOL]     assertEquals(BigDecimal.valueOf((long) EXP_I), jp.getDecimalValue()); [EOL]     jp.close(); [EOL] } <line_num>: 24,39
public void testIntRange() throws Exception { [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         String input = "[ " + Integer.MAX_VALUE + "," + Integer.MIN_VALUE + " ]"; [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.INT, jp.getNumberType()); [EOL]         assertEquals(Integer.MAX_VALUE, jp.getIntValue()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.INT, jp.getNumberType()); [EOL]         assertEquals(Integer.MIN_VALUE, jp.getIntValue()); [EOL]         jp.close(); [EOL]     } [EOL] } <line_num>: 41,62
public void testSimpleLong() throws Exception { [EOL]     long EXP_L = 12345678907L; [EOL]     JsonParser jp = createParserUsingReader("[ " + EXP_L + " ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]     assertEquals(JsonParser.NumberType.LONG, jp.getNumberType()); [EOL]     assertEquals("" + EXP_L, jp.getText()); [EOL]     assertEquals(EXP_L, jp.getLongValue()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, "out of range"); [EOL]     } [EOL]     assertEquals((double) EXP_L, jp.getDoubleValue()); [EOL]     assertEquals(BigDecimal.valueOf((long) EXP_L), jp.getDecimalValue()); [EOL]     jp.close(); [EOL] } <line_num>: 64,86
public void testLongRange() throws Exception { [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         long belowMinInt = -1L + Integer.MIN_VALUE; [EOL]         long aboveMaxInt = 1L + Integer.MAX_VALUE; [EOL]         String input = "[ " + Long.MAX_VALUE + "," + Long.MIN_VALUE + "," + aboveMaxInt + ", " + belowMinInt + " ]"; [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.LONG, jp.getNumberType()); [EOL]         assertEquals(Long.MAX_VALUE, jp.getLongValue()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.LONG, jp.getNumberType()); [EOL]         assertEquals(Long.MIN_VALUE, jp.getLongValue()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.LONG, jp.getNumberType()); [EOL]         assertEquals(aboveMaxInt, jp.getLongValue()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.LONG, jp.getNumberType()); [EOL]         assertEquals(belowMinInt, jp.getLongValue()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] } <line_num>: 88,122
public void testBigDecimalRange() throws Exception { [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         BigInteger small = new BigDecimal(Long.MIN_VALUE).toBigInteger(); [EOL]         small = small.subtract(BigInteger.ONE); [EOL]         BigInteger big = new BigDecimal(Long.MAX_VALUE).toBigInteger(); [EOL]         big = big.add(BigInteger.ONE); [EOL]         String input = "[ " + small + "  ,  " + big + "]"; [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(input); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(input, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(small, jp.getBigIntegerValue()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(big, jp.getBigIntegerValue()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] } <line_num>: 124,150
public void testBigNumbers() throws Exception { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < 520; ++i) { [EOL]         sb.append('1'); [EOL]     } [EOL]     final String NUMBER_STR = sb.toString(); [EOL]     BigInteger biggie = new BigInteger(NUMBER_STR); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp; [EOL]         if (i == 0) { [EOL]             jp = createParserUsingReader(NUMBER_STR); [EOL]         } else { [EOL]             jp = this.createParserUsingStream(NUMBER_STR, "UTF-8"); [EOL]         } [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType()); [EOL]         assertEquals(NUMBER_STR, jp.getText()); [EOL]         assertEquals(biggie, jp.getBigIntegerValue()); [EOL]         jp.close(); [EOL]     } [EOL] } <line_num>: 153,175
public void testSimpleDouble() throws Exception { [EOL]     final String[] INPUTS = new String[] { "1234.00", "2.1101567E-16", "1.0e5", "2.5e+5", "9e4", "-12e-3", "0.25" }; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         for (int i = 0; i < INPUTS.length; ++i) { [EOL]             String STR = INPUTS[i]; [EOL]             double EXP_D = Double.parseDouble(STR); [EOL]             String DOC = "[" + STR + "]"; [EOL]             JsonParser jp; [EOL]             if (input == 0) { [EOL]                 jp = createParserUsingStream(DOC, "UTF-8"); [EOL]             } else { [EOL]                 jp = createParserUsingReader(DOC); [EOL]             } [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]             assertEquals(STR, jp.getText()); [EOL]             assertEquals(EXP_D, jp.getDoubleValue()); [EOL]             assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]             jp.close(); [EOL]         } [EOL]     } [EOL] } <line_num>: 177,208
public void testNumbers() throws Exception { [EOL]     final String DOC = "[ -13, 8100200300, 13.5, 0.00010, -2.033 ]"; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(-13, jp.getIntValue()); [EOL]         assertEquals(-13L, jp.getLongValue()); [EOL]         assertEquals(-13., jp.getDoubleValue()); [EOL]         assertEquals("-13", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]         assertEquals(8100200300L, jp.getLongValue()); [EOL]         try { [EOL]             jp.getIntValue(); [EOL]             fail("Expected an exception for overflow"); [EOL]         } catch (Exception e) { [EOL]             verifyException(e, "out of range of int"); [EOL]         } [EOL]         assertEquals(8100200300., jp.getDoubleValue()); [EOL]         assertEquals("8100200300", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(13, jp.getIntValue()); [EOL]         assertEquals(13L, jp.getLongValue()); [EOL]         assertEquals(13.5, jp.getDoubleValue()); [EOL]         assertEquals("13.5", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(0, jp.getIntValue()); [EOL]         assertEquals(0L, jp.getLongValue()); [EOL]         assertEquals(0.00010, jp.getDoubleValue()); [EOL]         assertEquals("0.00010", jp.getText()); [EOL]         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]         assertEquals(-2, jp.getIntValue()); [EOL]         assertEquals(-2L, jp.getLongValue()); [EOL]         assertEquals(-2.033, jp.getDoubleValue()); [EOL]         assertEquals("-2.033", jp.getText()); [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] } <line_num>: 210,265
@SuppressWarnings("resource") [EOL] public void testLongOverflow() throws Exception { [EOL]     BigInteger below = BigInteger.valueOf(Long.MIN_VALUE); [EOL]     below = below.subtract(BigInteger.ONE); [EOL]     BigInteger above = BigInteger.valueOf(Long.MAX_VALUE); [EOL]     above = above.add(BigInteger.ONE); [EOL]     String DOC_BELOW = below.toString() + " "; [EOL]     String DOC_ABOVE = below.toString() + " "; [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC_BELOW, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC_BELOW); [EOL]         } [EOL]         jp.nextToken(); [EOL]         try { [EOL]             long x = jp.getLongValue(); [EOL]             fail("Expected an exception for underflow (input " + jp.getText() + "): instead, got long value: " + x); [EOL]         } catch (JsonParseException e) { [EOL]             verifyException(e, "out of range of long"); [EOL]         } [EOL]         jp.close(); [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC_ABOVE, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC_ABOVE); [EOL]         } [EOL]         jp.nextToken(); [EOL]         try { [EOL]             long x = jp.getLongValue(); [EOL]             fail("Expected an exception for underflow (input " + jp.getText() + "): instead, got long value: " + x); [EOL]         } catch (JsonParseException e) { [EOL]             verifyException(e, "out of range of long"); [EOL]         } [EOL]         jp.close(); [EOL]     } [EOL] } <line_num>: 267,309
public void testParsingOfLongerSequences() throws Exception { [EOL]     double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 }; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     for (int i = 0; i < values.length; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(values[i]); [EOL]     } [EOL]     String segment = sb.toString(); [EOL]     int COUNT = 1000; [EOL]     sb = new StringBuilder(COUNT * segment.length() + 20); [EOL]     sb.append("["); [EOL]     for (int i = 0; i < COUNT; ++i) { [EOL]         if (i > 0) { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(segment); [EOL]         sb.append('\n'); [EOL]         int x = (i & 3); [EOL]         if (i > 300) { [EOL]             x += i % 5; [EOL]         } [EOL]         while (--x > 0) { [EOL]             sb.append(' '); [EOL]         } [EOL]     } [EOL]     sb.append("]"); [EOL]     String DOC = sb.toString(); [EOL]     for (int input = 0; input < 2; ++input) { [EOL]         JsonParser jp; [EOL]         if (input == 0) { [EOL]             jp = createParserUsingStream(DOC, "UTF-8"); [EOL]         } else { [EOL]             jp = createParserUsingReader(DOC); [EOL]         } [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < COUNT; ++i) { [EOL]             for (double d : values) { [EOL]                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); [EOL]                 assertEquals(d, jp.getDoubleValue()); [EOL]             } [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]         jp.close(); [EOL]     } [EOL] } <line_num>: 315,369
public void testInvalidBooleanAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getBooleanValue(); [EOL]         fail("Expected error trying to call getBooleanValue on non-boolean value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "not of boolean type"); [EOL]     } [EOL]     jp.close(); [EOL] } <line_num>: 377,390
public void testInvalidIntAccess() throws Exception { [EOL]     JsonParser jp = createParserUsingReader("[ \"abc\" ]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     try { [EOL]         jp.getIntValue(); [EOL]         fail("Expected error trying to call getIntValue on non-numeric value"); [EOL]     } catch (JsonParseException e) { [EOL]         verifyException(e, "can not use numeric value accessors"); [EOL]     } [EOL]     jp.close(); [EOL] } <line_num>: 392,404
