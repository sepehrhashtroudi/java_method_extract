@Override [EOL] public int[] getEscapeCodesForAscii() { [EOL]     return ascii; [EOL] } <line_num>: 24,27
@Override [EOL] public SerializableString getEscapeSequence(int ch) { [EOL]     throw new UnsupportedOperationException("Not implemented for test"); [EOL] } <line_num>: 29,32
public void testMissingEscaping() throws Exception { [EOL]     final String DOC = "[" + "\"Linefeed: \n.\"" + "]"; [EOL]     JsonParser jp = createParserUsingReader(DOC); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     try { [EOL]         JsonToken t = jp.nextToken(); [EOL]         assertToken(JsonToken.VALUE_STRING, t); [EOL]         jp.getText(); [EOL]         fail("Expected an exception for un-escaped linefeed in string value"); [EOL]     } catch (JsonParseException jex) { [EOL]         verifyException(jex, "has to be escaped"); [EOL]     } [EOL]     jp.close(); [EOL] } <line_num>: 40,60
public void testSimpleEscaping() throws Exception { [EOL]     String DOC = "[" + "\"LF=\\n\"" + "]"; [EOL]     JsonParser jp = createParserUsingReader(DOC); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("LF=\n", jp.getText()); [EOL]     jp.close(); [EOL]     DOC = "[\"NULL:\\u0000!\"]"; [EOL]     jp = createParserUsingReader(DOC); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("NULL:\0!", jp.getText()); [EOL]     jp.close(); [EOL]     jp = createParserUsingReader("[\"\\u0123\"]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("\u0123", jp.getText()); [EOL]     jp.close(); [EOL]     jp = createParserUsingReader("[\"\\u0041\\u0043\"]"); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("AC", jp.getText()); [EOL]     jp.close(); [EOL] } <line_num>: 62,100
public void testInvalid() throws Exception { [EOL]     String DOC = "[\"\\u41=A\"]"; [EOL]     JsonParser jp = createParserUsingReader(DOC); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     try { [EOL]         jp.nextToken(); [EOL]         jp.getText(); [EOL]         fail("Expected an exception for unclosed ARRAY"); [EOL]     } catch (JsonParseException jpe) { [EOL]         verifyException(jpe, "for character escape"); [EOL]     } [EOL]     jp.close(); [EOL] } <line_num>: 102,117
public void test8DigitSequence() throws Exception { [EOL]     String DOC = "[\"\\u00411234\"]"; [EOL]     JsonParser jp = createParserUsingReader(DOC); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     assertToken(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]     assertEquals("A1234", jp.getText()); [EOL]     jp.close(); [EOL] } <line_num>: 123,132
public void testWriteLongCustomEscapes() throws Exception { [EOL]     JsonFactory jf = new JsonFactory(); [EOL]     jf.setCharacterEscapes(ESC_627); [EOL]     StringBuilder longString = new StringBuilder(); [EOL]     while (longString.length() < 2000) { [EOL]         longString.append("\u65e5\u672c\u8a9e"); [EOL]     } [EOL]     StringWriter writer = new StringWriter(); [EOL]     JsonGenerator jgen = jf.createGenerator(writer); [EOL]     jgen.setHighestNonEscapedChar(127); [EOL]     jgen.writeString(longString.toString()); [EOL]     jgen.close(); [EOL] } <line_num>: 135,150
