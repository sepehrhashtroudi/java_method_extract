public void testProps() { [EOL]     Base64Variant std = Base64Variants.MIME; [EOL]     assertEquals("MIME", std.getName()); [EOL]     assertEquals("MIME", std.toString()); [EOL]     assertTrue(std.usesPadding()); [EOL]     assertFalse(std.usesPaddingChar('X')); [EOL]     assertEquals('=', std.getPaddingChar()); [EOL]     assertTrue(std.usesPaddingChar('=')); [EOL]     assertEquals((byte) '=', std.getPaddingByte()); [EOL]     assertEquals(76, std.getMaxLineLength()); [EOL] } <line_num>: 10,22
public void testCharEncoding() throws Exception { [EOL]     Base64Variant std = Base64Variants.MIME; [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char('?')); [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char((int) '?')); [EOL]     assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char((byte) '?')); [EOL]     assertEquals(0, std.decodeBase64Char('A')); [EOL]     assertEquals(1, std.decodeBase64Char((int) 'B')); [EOL]     assertEquals(2, std.decodeBase64Char((byte) 'C')); [EOL]     assertEquals('/', std.encodeBase64BitsAsChar(63)); [EOL]     assertEquals((byte) 'b', std.encodeBase64BitsAsByte(27)); [EOL]     String EXP_STR = "HwdJ"; [EOL]     int TRIPLET = 0x1F0749; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     std.encodeBase64Chunk(sb, TRIPLET); [EOL]     assertEquals(EXP_STR, sb.toString()); [EOL]     byte[] exp = EXP_STR.getBytes("UTF-8"); [EOL]     byte[] act = new byte[exp.length]; [EOL]     std.encodeBase64Chunk(TRIPLET, act, 0); [EOL]     Assert.assertArrayEquals(exp, act); [EOL] } <line_num>: 24,48
@SuppressWarnings("unused") [EOL] public void testErrors() throws Exception { [EOL]     try { [EOL]         Base64Variant b = new Base64Variant("foobar", "xyz", false, '!', 24); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         verifyException(iae, "length must be exactly"); [EOL]     } [EOL] } <line_num>: 50,58
