public BackgroundInitializerTestImpl() { [EOL]     super(); [EOL] } <line_num>: 281,283
public BackgroundInitializerTestImpl(final ExecutorService exec) { [EOL]     super(exec); [EOL] } <line_num>: 285,287
private void checkInitialize(final BackgroundInitializerTestImpl init) { [EOL]     try { [EOL]         final Integer result = init.get(); [EOL]         assertEquals("Wrong result", 1, result.intValue()); [EOL]         assertEquals("Wrong number of invocations", 1, init.initializeCalls); [EOL]         assertNotNull("No future", init.getFuture()); [EOL]     } catch (final ConcurrentException cex) { [EOL]         fail("Unexpected exception: " + cex); [EOL]     } [EOL] } <line_num>: 34,43
@Test [EOL] public void testInitialize() { [EOL]     final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(); [EOL]     init.start(); [EOL]     checkInitialize(init); [EOL] } <line_num>: 48,53
@Test [EOL] public void testGetActiveExecutorBeforeStart() { [EOL]     final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(); [EOL]     assertNull("Got an executor", init.getActiveExecutor()); [EOL] } <line_num>: 59,63
@Test [EOL] public void testGetActiveExecutorExternal() { [EOL]     final ExecutorService exec = Executors.newSingleThreadExecutor(); [EOL]     try { [EOL]         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(exec); [EOL]         init.start(); [EOL]         assertSame("Wrong executor", exec, init.getActiveExecutor()); [EOL]         checkInitialize(init); [EOL]     } finally { [EOL]         exec.shutdown(); [EOL]     } [EOL] } <line_num>: 68,80
@Test [EOL] public void testGetActiveExecutorTemp() { [EOL]     final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(); [EOL]     init.start(); [EOL]     assertNotNull("No active executor", init.getActiveExecutor()); [EOL]     checkInitialize(init); [EOL] } <line_num>: 85,91
@Test [EOL] public void testInitializeTempExecutor() { [EOL]     final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(); [EOL]     assertTrue("Wrong result of start()", init.start()); [EOL]     checkInitialize(init); [EOL]     assertTrue("Executor not shutdown", init.getActiveExecutor().isShutdown()); [EOL] } <line_num>: 97,104
@Test [EOL] public void testSetExternalExecutor() throws Exception { [EOL]     final ExecutorService exec = Executors.newCachedThreadPool(); [EOL]     try { [EOL]         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(); [EOL]         init.setExternalExecutor(exec); [EOL]         assertEquals("Wrong executor service", exec, init.getExternalExecutor()); [EOL]         assertTrue("Wrong result of start()", init.start()); [EOL]         assertSame("Wrong active executor", exec, init.getActiveExecutor()); [EOL]         checkInitialize(init); [EOL]         assertFalse("Executor was shutdown", exec.isShutdown()); [EOL]     } finally { [EOL]         exec.shutdown(); [EOL]     } [EOL] } <line_num>: 110,125
@Test [EOL] public void testSetExternalExecutorAfterStart() throws ConcurrentException { [EOL]     final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(); [EOL]     init.start(); [EOL]     try { [EOL]         init.setExternalExecutor(Executors.newSingleThreadExecutor()); [EOL]         fail("Could set executor after start()!"); [EOL]     } catch (final IllegalStateException istex) { [EOL]         init.get(); [EOL]     } [EOL] } <line_num>: 130,140
@Test [EOL] public void testStartMultipleTimes() { [EOL]     final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(); [EOL]     assertTrue("Wrong result for start()", init.start()); [EOL]     for (int i = 0; i < 10; i++) { [EOL]         assertFalse("Could start again", init.start()); [EOL]     } [EOL]     checkInitialize(init); [EOL] } <line_num>: 146,154
@Test(expected = IllegalStateException.class) [EOL] public void testGetBeforeStart() throws ConcurrentException { [EOL]     final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(); [EOL]     init.get(); [EOL] } <line_num>: 159,163
@Test [EOL] public void testGetRuntimeException() throws Exception { [EOL]     final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(); [EOL]     final RuntimeException rex = new RuntimeException(); [EOL]     init.ex = rex; [EOL]     init.start(); [EOL]     try { [EOL]         init.get(); [EOL]         fail("Exception not thrown!"); [EOL]     } catch (final Exception ex) { [EOL]         assertEquals("Runtime exception not thrown", rex, ex); [EOL]     } [EOL] } <line_num>: 169,181
@Test [EOL] public void testGetCheckedException() throws Exception { [EOL]     final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(); [EOL]     final Exception ex = new Exception(); [EOL]     init.ex = ex; [EOL]     init.start(); [EOL]     try { [EOL]         init.get(); [EOL]         fail("Exception not thrown!"); [EOL]     } catch (final ConcurrentException cex) { [EOL]         assertEquals("Exception not thrown", ex, cex.getCause()); [EOL]     } [EOL] } <line_num>: 187,199
@Override [EOL] public void run() { [EOL]     try { [EOL]         init.get(); [EOL]     } catch (final ConcurrentException cex) { [EOL]         if (cex.getCause() instanceof InterruptedException) { [EOL]             iex.set((InterruptedException) cex.getCause()); [EOL]         } [EOL]     } finally { [EOL]         assertTrue("Thread not interrupted", isInterrupted()); [EOL]         latch1.countDown(); [EOL]     } [EOL] } <line_num>: 214,226
@Test [EOL] public void testGetInterruptedException() throws Exception { [EOL]     final ExecutorService exec = Executors.newSingleThreadExecutor(); [EOL]     final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(exec); [EOL]     final CountDownLatch latch1 = new CountDownLatch(1); [EOL]     init.shouldSleep = true; [EOL]     init.start(); [EOL]     final AtomicReference<InterruptedException> iex = new AtomicReference<InterruptedException>(); [EOL]     final Thread getThread = new Thread() { [EOL]  [EOL]         @Override [EOL]         public void run() { [EOL]             try { [EOL]                 init.get(); [EOL]             } catch (final ConcurrentException cex) { [EOL]                 if (cex.getCause() instanceof InterruptedException) { [EOL]                     iex.set((InterruptedException) cex.getCause()); [EOL]                 } [EOL]             } finally { [EOL]                 assertTrue("Thread not interrupted", isInterrupted()); [EOL]                 latch1.countDown(); [EOL]             } [EOL]         } [EOL]     }; [EOL]     getThread.start(); [EOL]     getThread.interrupt(); [EOL]     latch1.await(); [EOL]     exec.shutdownNow(); [EOL]     exec.awaitTermination(Long.MAX_VALUE, TimeUnit.MILLISECONDS); [EOL]     assertNotNull("No interrupted exception", iex.get()); [EOL] } <line_num>: 204,234
@Test [EOL] public void testIsStartedFalse() { [EOL]     final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(); [EOL]     assertFalse("Already started", init.isStarted()); [EOL] } <line_num>: 239,243
@Test [EOL] public void testIsStartedTrue() { [EOL]     final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(); [EOL]     init.start(); [EOL]     assertTrue("Not started", init.isStarted()); [EOL] } <line_num>: 248,253
@Test [EOL] public void testIsStartedAfterGet() { [EOL]     final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(); [EOL]     init.start(); [EOL]     checkInitialize(init); [EOL]     assertTrue("Not started", init.isStarted()); [EOL] } <line_num>: 258,264
@Override [EOL] protected Integer initialize() throws Exception { [EOL]     if (ex != null) { [EOL]         throw ex; [EOL]     } [EOL]     if (shouldSleep) { [EOL]         Thread.sleep(60000L); [EOL]     } [EOL]     return Integer.valueOf(++initializeCalls); [EOL] } <line_num>: 293,302
