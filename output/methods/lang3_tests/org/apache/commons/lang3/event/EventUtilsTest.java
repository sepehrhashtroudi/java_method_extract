@Test [EOL] public void testConstructor() { [EOL]     assertNotNull(new EventUtils()); [EOL]     final Constructor<?>[] cons = EventUtils.class.getDeclaredConstructors(); [EOL]     assertEquals(1, cons.length); [EOL]     assertTrue(Modifier.isPublic(cons[0].getModifiers())); [EOL]     assertTrue(Modifier.isPublic(EventUtils.class.getModifiers())); [EOL]     assertFalse(Modifier.isFinal(EventUtils.class.getModifiers())); [EOL] } <line_num>: 48,56
@Test [EOL] public void testAddEventListener() { [EOL]     final PropertyChangeSource src = new PropertyChangeSource(); [EOL]     final EventCountingInvociationHandler handler = new EventCountingInvociationHandler(); [EOL]     final PropertyChangeListener listener = handler.createListener(PropertyChangeListener.class); [EOL]     assertEquals(0, handler.getEventCount("propertyChange")); [EOL]     EventUtils.addEventListener(src, PropertyChangeListener.class, listener); [EOL]     assertEquals(0, handler.getEventCount("propertyChange")); [EOL]     src.setProperty("newValue"); [EOL]     assertEquals(1, handler.getEventCount("propertyChange")); [EOL] } <line_num>: 58,69
@Test [EOL] public void testAddEventListenerWithNoAddMethod() { [EOL]     final PropertyChangeSource src = new PropertyChangeSource(); [EOL]     final EventCountingInvociationHandler handler = new EventCountingInvociationHandler(); [EOL]     final ObjectChangeListener listener = handler.createListener(ObjectChangeListener.class); [EOL]     try { [EOL]         EventUtils.addEventListener(src, ObjectChangeListener.class, listener); [EOL]         fail("Should not be allowed to add a listener to an object that doesn't support it."); [EOL]     } catch (final IllegalArgumentException e) { [EOL]         assertEquals("Class " + src.getClass().getName() + " does not have a public add" + ObjectChangeListener.class.getSimpleName() + " method which takes a parameter of type " + ObjectChangeListener.class.getName() + ".", e.getMessage()); [EOL]     } [EOL] } <line_num>: 71,86
@Override [EOL] public void propertyChange(final PropertyChangeEvent e) { [EOL] } <line_num>: 96,100
@Test [EOL] public void testAddEventListenerThrowsException() { [EOL]     final ExceptionEventSource src = new ExceptionEventSource(); [EOL]     try { [EOL]         EventUtils.addEventListener(src, PropertyChangeListener.class, new PropertyChangeListener() { [EOL]  [EOL]             @Override [EOL]             public void propertyChange(final PropertyChangeEvent e) { [EOL]             } [EOL]         }); [EOL]         fail("Add method should have thrown an exception, so method should fail."); [EOL]     } catch (final RuntimeException e) { [EOL]     } [EOL] } <line_num>: 88,108
@Test [EOL] public void testAddEventListenerWithPrivateAddMethod() { [EOL]     final PropertyChangeSource src = new PropertyChangeSource(); [EOL]     final EventCountingInvociationHandler handler = new EventCountingInvociationHandler(); [EOL]     final VetoableChangeListener listener = handler.createListener(VetoableChangeListener.class); [EOL]     try { [EOL]         EventUtils.addEventListener(src, VetoableChangeListener.class, listener); [EOL]         fail("Should not be allowed to add a listener to an object that doesn't support it."); [EOL]     } catch (final IllegalArgumentException e) { [EOL]         assertEquals("Class " + src.getClass().getName() + " does not have a public add" + VetoableChangeListener.class.getSimpleName() + " method which takes a parameter of type " + VetoableChangeListener.class.getName() + ".", e.getMessage()); [EOL]     } [EOL] } <line_num>: 110,125
@Test [EOL] public void testBindEventsToMethod() { [EOL]     final PropertyChangeSource src = new PropertyChangeSource(); [EOL]     final EventCounter counter = new EventCounter(); [EOL]     EventUtils.bindEventsToMethod(counter, "eventOccurred", src, PropertyChangeListener.class); [EOL]     assertEquals(0, counter.getCount()); [EOL]     src.setProperty("newValue"); [EOL]     assertEquals(1, counter.getCount()); [EOL] } <line_num>: 127,136
@Test [EOL] public void testBindEventsToMethodWithEvent() { [EOL]     final PropertyChangeSource src = new PropertyChangeSource(); [EOL]     final EventCounterWithEvent counter = new EventCounterWithEvent(); [EOL]     EventUtils.bindEventsToMethod(counter, "eventOccurred", src, PropertyChangeListener.class); [EOL]     assertEquals(0, counter.getCount()); [EOL]     src.setProperty("newValue"); [EOL]     assertEquals(1, counter.getCount()); [EOL] } <line_num>: 139,148
@Test [EOL] public void testBindFilteredEventsToMethod() { [EOL]     final MultipleEventSource src = new MultipleEventSource(); [EOL]     final EventCounter counter = new EventCounter(); [EOL]     EventUtils.bindEventsToMethod(counter, "eventOccurred", src, MultipleEventListener.class, "event1"); [EOL]     assertEquals(0, counter.getCount()); [EOL]     src.listeners.fire().event1(new PropertyChangeEvent(new Date(), "Day", Integer.valueOf(0), Integer.valueOf(1))); [EOL]     assertEquals(1, counter.getCount()); [EOL]     src.listeners.fire().event2(new PropertyChangeEvent(new Date(), "Day", Integer.valueOf(1), Integer.valueOf(2))); [EOL]     assertEquals(1, counter.getCount()); [EOL] } <line_num>: 151,162
public void event1(PropertyChangeEvent e); <line_num>: 166,166
public void event2(PropertyChangeEvent e); <line_num>: 168,168
public void eventOccurred() { [EOL]     count++; [EOL] } <line_num>: 175,178
public int getCount() { [EOL]     return count; [EOL] } <line_num>: 180,183
public void eventOccurred(final PropertyChangeEvent e) { [EOL]     count++; [EOL] } <line_num>: 190,193
public int getCount() { [EOL]     return count; [EOL] } <line_num>: 195,198
public <L> L createListener(final Class<L> listenerType) { [EOL]     return listenerType.cast(Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class[] { listenerType }, this)); [EOL] } <line_num>: 206,211
public int getEventCount(final String eventName) { [EOL]     final Integer count = eventCounts.get(eventName); [EOL]     return count == null ? 0 : count.intValue(); [EOL] } <line_num>: 213,217
@Override [EOL] public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable { [EOL]     final Integer count = eventCounts.get(method.getName()); [EOL]     if (count == null) { [EOL]         eventCounts.put(method.getName(), Integer.valueOf(1)); [EOL]     } else { [EOL]         eventCounts.put(method.getName(), Integer.valueOf(count.intValue() + 1)); [EOL]     } [EOL]     return null; [EOL] } <line_num>: 219,232
public void addMultipleEventListener(final MultipleEventListener listener) { [EOL]     listeners.addListener(listener); [EOL] } <line_num>: 239,242
public void addPropertyChangeListener(final PropertyChangeListener listener) { [EOL]     throw new RuntimeException(); [EOL] } <line_num>: 247,250
public void setProperty(final String property) { [EOL]     final String oldValue = this.property; [EOL]     this.property = property; [EOL]     listeners.fire().propertyChange(new PropertyChangeEvent(this, "property", oldValue, property)); [EOL] } <line_num>: 259,264
protected void addVetoableChangeListener(final VetoableChangeListener listener) { [EOL] } <line_num>: 266,269
public void addPropertyChangeListener(final PropertyChangeListener listener) { [EOL]     listeners.addListener(listener); [EOL] } <line_num>: 271,274
public void removePropertyChangeListener(final PropertyChangeListener listener) { [EOL]     listeners.removeListener(listener); [EOL] } <line_num>: 276,279
