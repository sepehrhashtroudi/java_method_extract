public OtherExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry) { [EOL]     super(pattern, locale, registry); [EOL] } <line_num>: 446,449
@Before [EOL] public void setUp() throws Exception { [EOL]     registry.put("lower", new LowerCaseFormatFactory()); [EOL]     registry.put("upper", new UpperCaseFormatFactory()); [EOL] } <line_num>: 51,55
@Test [EOL] public void testExtendedFormats() { [EOL]     final String pattern = "Lower: {0,lower} Upper: {1,upper}"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertPatternsEqual("TOPATTERN", pattern, emf.toPattern()); [EOL]     assertEquals("Lower: foo Upper: BAR", emf.format(new Object[] { "foo", "bar" })); [EOL]     assertEquals("Lower: foo Upper: BAR", emf.format(new Object[] { "Foo", "Bar" })); [EOL]     assertEquals("Lower: foo Upper: BAR", emf.format(new Object[] { "FOO", "BAR" })); [EOL]     assertEquals("Lower: foo Upper: BAR", emf.format(new Object[] { "FOO", "bar" })); [EOL]     assertEquals("Lower: foo Upper: BAR", emf.format(new Object[] { "foo", "BAR" })); [EOL] } <line_num>: 60,70
@Test [EOL] public void testEscapedQuote_LANG_477() { [EOL]     final String pattern = "it''s a {0,lower} 'test'!"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); [EOL]     assertEquals("it's a dummy test!", emf.format(new Object[] { "DUMMY" })); [EOL] } <line_num>: 75,80
@Test [EOL] public void testExtendedAndBuiltInFormats() { [EOL]     final Calendar cal = Calendar.getInstance(); [EOL]     cal.set(2007, Calendar.JANUARY, 23, 18, 33, 05); [EOL]     final Object[] args = new Object[] { "John Doe", cal.getTime(), Double.valueOf("12345.67") }; [EOL]     final String builtinsPattern = "DOB: {1,date,short} Salary: {2,number,currency}"; [EOL]     final String extendedPattern = "Name: {0,upper} "; [EOL]     final String pattern = extendedPattern + builtinsPattern; [EOL]     final HashSet<Locale> testLocales = new HashSet<Locale>(); [EOL]     testLocales.addAll(Arrays.asList(DateFormat.getAvailableLocales())); [EOL]     testLocales.retainAll(Arrays.asList(NumberFormat.getAvailableLocales())); [EOL]     testLocales.add(null); [EOL]     for (final Locale locale : testLocales) { [EOL]         final MessageFormat builtins = createMessageFormat(builtinsPattern, locale); [EOL]         final String expectedPattern = extendedPattern + builtins.toPattern(); [EOL]         DateFormat df = null; [EOL]         NumberFormat nf = null; [EOL]         ExtendedMessageFormat emf = null; [EOL]         if (locale == null) { [EOL]             df = DateFormat.getDateInstance(DateFormat.SHORT); [EOL]             nf = NumberFormat.getCurrencyInstance(); [EOL]             emf = new ExtendedMessageFormat(pattern, registry); [EOL]         } else { [EOL]             df = DateFormat.getDateInstance(DateFormat.SHORT, locale); [EOL]             nf = NumberFormat.getCurrencyInstance(locale); [EOL]             emf = new ExtendedMessageFormat(pattern, locale, registry); [EOL]         } [EOL]         final StringBuilder expected = new StringBuilder(); [EOL]         expected.append("Name: "); [EOL]         expected.append(args[0].toString().toUpperCase()); [EOL]         expected.append(" DOB: "); [EOL]         expected.append(df.format(args[1])); [EOL]         expected.append(" Salary: "); [EOL]         expected.append(nf.format(args[2])); [EOL]         assertPatternsEqual("pattern comparison for locale " + locale, expectedPattern, emf.toPattern()); [EOL]         assertEquals(String.valueOf(locale), expected.toString(), emf.format(args)); [EOL]     } [EOL] } <line_num>: 85,124
@Test [EOL] public void testBuiltInChoiceFormat() { [EOL]     final Object[] values = new Number[] { Integer.valueOf(1), Double.valueOf("2.2"), Double.valueOf("1234.5") }; [EOL]     String choicePattern = null; [EOL]     final Locale[] availableLocales = ChoiceFormat.getAvailableLocales(); [EOL]     choicePattern = "{0,choice,1#One|2#Two|3#Many {0,number}}"; [EOL]     for (final Object value : values) { [EOL]         checkBuiltInFormat(value + ": " + choicePattern, new Object[] { value }, availableLocales); [EOL]     } [EOL]     choicePattern = "{0,choice,1#''One''|2#\"Two\"|3#''{Many}'' {0,number}}"; [EOL]     for (final Object value : values) { [EOL]         checkBuiltInFormat(value + ": " + choicePattern, new Object[] { value }, availableLocales); [EOL]     } [EOL] } <line_num>: 184,199
@Test [EOL] public void testBuiltInDateTimeFormat() { [EOL]     final Calendar cal = Calendar.getInstance(); [EOL]     cal.set(2007, Calendar.JANUARY, 23, 18, 33, 05); [EOL]     final Object[] args = new Object[] { cal.getTime() }; [EOL]     final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]     checkBuiltInFormat("1: {0,date,short}", args, availableLocales); [EOL]     checkBuiltInFormat("2: {0,date,medium}", args, availableLocales); [EOL]     checkBuiltInFormat("3: {0,date,long}", args, availableLocales); [EOL]     checkBuiltInFormat("4: {0,date,full}", args, availableLocales); [EOL]     checkBuiltInFormat("5: {0,date,d MMM yy}", args, availableLocales); [EOL]     checkBuiltInFormat("6: {0,time,short}", args, availableLocales); [EOL]     checkBuiltInFormat("7: {0,time,medium}", args, availableLocales); [EOL]     checkBuiltInFormat("8: {0,time,long}", args, availableLocales); [EOL]     checkBuiltInFormat("9: {0,time,full}", args, availableLocales); [EOL]     checkBuiltInFormat("10: {0,time,HH:mm}", args, availableLocales); [EOL]     checkBuiltInFormat("11: {0,date}", args, availableLocales); [EOL]     checkBuiltInFormat("12: {0,time}", args, availableLocales); [EOL] } <line_num>: 204,223
@Test [EOL] public void testOverriddenBuiltinFormat() { [EOL]     final Calendar cal = Calendar.getInstance(); [EOL]     cal.set(2007, Calendar.JANUARY, 23); [EOL]     final Object[] args = new Object[] { cal.getTime() }; [EOL]     final Locale[] availableLocales = DateFormat.getAvailableLocales(); [EOL]     final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("date", new OverrideShortDateFormatFactory()); [EOL]     checkBuiltInFormat("1: {0,date}", registry, args, availableLocales); [EOL]     checkBuiltInFormat("2: {0,date,medium}", registry, args, availableLocales); [EOL]     checkBuiltInFormat("3: {0,date,long}", registry, args, availableLocales); [EOL]     checkBuiltInFormat("4: {0,date,full}", registry, args, availableLocales); [EOL]     checkBuiltInFormat("5: {0,date,d MMM yy}", registry, args, availableLocales); [EOL]     for (int i = -1; i < availableLocales.length; i++) { [EOL]         final Locale locale = i < 0 ? null : availableLocales[i]; [EOL]         final MessageFormat dateDefault = createMessageFormat("{0,date}", locale); [EOL]         final String pattern = "{0,date,short}"; [EOL]         final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry); [EOL]         assertEquals("overridden date,short format", dateDefault.format(args), dateShort.format(args)); [EOL]         assertEquals("overridden date,short pattern", pattern, dateShort.toPattern()); [EOL]     } [EOL] } <line_num>: 225,249
@Test [EOL] public void testBuiltInNumberFormat() { [EOL]     final Object[] args = new Object[] { Double.valueOf("6543.21") }; [EOL]     final Locale[] availableLocales = NumberFormat.getAvailableLocales(); [EOL]     checkBuiltInFormat("1: {0,number}", args, availableLocales); [EOL]     checkBuiltInFormat("2: {0,number,integer}", args, availableLocales); [EOL]     checkBuiltInFormat("3: {0,number,currency}", args, availableLocales); [EOL]     checkBuiltInFormat("4: {0,number,percent}", args, availableLocales); [EOL]     checkBuiltInFormat("5: {0,number,00000.000}", args, availableLocales); [EOL] } <line_num>: 254,263
@Test [EOL] public void testEqualsHashcode() { [EOL]     final Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory()); [EOL]     final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory()); [EOL]     final String pattern = "Pattern: {0,testfmt}"; [EOL]     final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]     ExtendedMessageFormat other = null; [EOL]     assertTrue("same, equals()", emf.equals(emf)); [EOL]     assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode()); [EOL]     other = new ExtendedMessageFormat(pattern, Locale.US, registry); [EOL]     assertTrue("equal, equals()", emf.equals(other)); [EOL]     assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode()); [EOL]     other = new OtherExtendedMessageFormat(pattern, Locale.US, registry); [EOL]     assertFalse("class, equals()", emf.equals(other)); [EOL]     assertTrue("class, hashcode()", emf.hashCode() == other.hashCode()); [EOL]     other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry); [EOL]     assertFalse("pattern, equals()", emf.equals(other)); [EOL]     assertFalse("pattern, hashcode()", emf.hashCode() == other.hashCode()); [EOL]     other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry); [EOL]     assertFalse("registry, equals()", emf.equals(other)); [EOL]     assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode()); [EOL]     other = new ExtendedMessageFormat(pattern, Locale.FRANCE, registry); [EOL]     assertFalse("locale, equals()", emf.equals(other)); [EOL]     assertTrue("locale, hashcode()", emf.hashCode() == other.hashCode()); [EOL] } <line_num>: 268,306
private void checkBuiltInFormat(final String pattern, final Object[] args, final Locale[] locales) { [EOL]     checkBuiltInFormat(pattern, null, args, locales); [EOL] } <line_num>: 314,316
private void checkBuiltInFormat(final String pattern, final Map<String, ?> registry, final Object[] args, final Locale[] locales) { [EOL]     checkBuiltInFormat(pattern, registry, args, (Locale) null); [EOL]     for (final Locale locale : locales) { [EOL]         checkBuiltInFormat(pattern, registry, args, locale); [EOL]     } [EOL] } <line_num>: 325,330
private void checkBuiltInFormat(final String pattern, final Map<String, ?> registry, final Object[] args, final Locale locale) { [EOL]     final StringBuilder buffer = new StringBuilder(); [EOL]     buffer.append("Pattern=["); [EOL]     buffer.append(pattern); [EOL]     buffer.append("], locale=["); [EOL]     buffer.append(locale); [EOL]     buffer.append("]"); [EOL]     final MessageFormat mf = createMessageFormat(pattern, locale); [EOL]     ExtendedMessageFormat emf = null; [EOL]     if (locale == null) { [EOL]         emf = new ExtendedMessageFormat(pattern); [EOL]     } else { [EOL]         emf = new ExtendedMessageFormat(pattern, locale); [EOL]     } [EOL]     assertEquals("format " + buffer.toString(), mf.format(args), emf.format(args)); [EOL]     assertPatternsEqual("toPattern " + buffer.toString(), mf.toPattern(), emf.toPattern()); [EOL] } <line_num>: 340,357
private void assertPatternsEqual(final String message, final String expected, final String actual) { [EOL]     if (SystemUtils.isJavaVersionAtLeast(JAVA_1_4)) { [EOL]         assertEquals(message, expected, actual); [EOL]     } [EOL] } <line_num>: 360,364
private MessageFormat createMessageFormat(final String pattern, final Locale locale) { [EOL]     final MessageFormat result = new MessageFormat(pattern); [EOL]     if (locale != null) { [EOL]         result.setLocale(locale); [EOL]         result.applyPattern(pattern); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 372,379
@Override [EOL] public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) { [EOL]     return toAppendTo.append(((String) obj).toLowerCase()); [EOL] } <line_num>: 387,390
@Override [EOL] public Object parseObject(final String source, final ParsePosition pos) { [EOL]     throw new UnsupportedOperationException(); [EOL] } <line_num>: 391,392
@Override [EOL] public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) { [EOL]     return toAppendTo.append(((String) obj).toUpperCase()); [EOL] } <line_num>: 399,402
@Override [EOL] public Object parseObject(final String source, final ParsePosition pos) { [EOL]     throw new UnsupportedOperationException(); [EOL] } <line_num>: 403,404
@Override [EOL] public Format getFormat(final String name, final String arguments, final Locale locale) { [EOL]     return LOWER_INSTANCE; [EOL] } <line_num>: 414,417
@Override [EOL] public Format getFormat(final String name, final String arguments, final Locale locale) { [EOL]     return UPPER_INSTANCE; [EOL] } <line_num>: 424,427
@Override [EOL] public Format getFormat(final String name, final String arguments, final Locale locale) { [EOL]     return !"short".equals(arguments) ? null : locale == null ? DateFormat.getDateInstance(DateFormat.DEFAULT) : DateFormat.getDateInstance(DateFormat.DEFAULT, locale); [EOL] } <line_num>: 433,439
