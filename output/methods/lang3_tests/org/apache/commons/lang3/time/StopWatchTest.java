@Test [EOL] public void testStopWatchSimple() { [EOL]     final StopWatch watch = new StopWatch(); [EOL]     watch.start(); [EOL]     try { [EOL]         Thread.sleep(550); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.stop(); [EOL]     final long time = watch.getTime(); [EOL]     assertEquals(time, watch.getTime()); [EOL]     assertTrue(time >= 500); [EOL]     assertTrue(time < 700); [EOL]     watch.reset(); [EOL]     assertEquals(0, watch.getTime()); [EOL] } <line_num>: 34,48
@Test [EOL] public void testStopWatchSimpleGet() { [EOL]     final StopWatch watch = new StopWatch(); [EOL]     assertEquals(0, watch.getTime()); [EOL]     assertEquals("0:00:00.000", watch.toString()); [EOL]     watch.start(); [EOL]     try { [EOL]         Thread.sleep(500); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     assertTrue(watch.getTime() < 2000); [EOL] } <line_num>: 50,59
@Test [EOL] public void testStopWatchSplit() { [EOL]     final StopWatch watch = new StopWatch(); [EOL]     watch.start(); [EOL]     try { [EOL]         Thread.sleep(550); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.split(); [EOL]     final long splitTime = watch.getSplitTime(); [EOL]     final String splitStr = watch.toSplitString(); [EOL]     try { [EOL]         Thread.sleep(550); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.unsplit(); [EOL]     try { [EOL]         Thread.sleep(550); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.stop(); [EOL]     final long totalTime = watch.getTime(); [EOL]     assertEquals("Formatted split string not the correct length", splitStr.length(), 11); [EOL]     assertTrue(splitTime >= 500); [EOL]     assertTrue(splitTime < 700); [EOL]     assertTrue(totalTime >= 1500); [EOL]     assertTrue(totalTime < 1900); [EOL] } <line_num>: 61,81
@Test [EOL] public void testStopWatchSuspend() { [EOL]     final StopWatch watch = new StopWatch(); [EOL]     watch.start(); [EOL]     try { [EOL]         Thread.sleep(550); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.suspend(); [EOL]     final long suspendTime = watch.getTime(); [EOL]     try { [EOL]         Thread.sleep(550); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.resume(); [EOL]     try { [EOL]         Thread.sleep(550); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.stop(); [EOL]     final long totalTime = watch.getTime(); [EOL]     assertTrue(suspendTime >= 500); [EOL]     assertTrue(suspendTime < 700); [EOL]     assertTrue(totalTime >= 1000); [EOL]     assertTrue(totalTime < 1300); [EOL] } <line_num>: 83,100
@Test [EOL] public void testLang315() { [EOL]     final StopWatch watch = new StopWatch(); [EOL]     watch.start(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.suspend(); [EOL]     final long suspendTime = watch.getTime(); [EOL]     try { [EOL]         Thread.sleep(200); [EOL]     } catch (final InterruptedException ex) { [EOL]     } [EOL]     watch.stop(); [EOL]     final long totalTime = watch.getTime(); [EOL]     assertTrue(suspendTime == totalTime); [EOL] } <line_num>: 102,113
@Test [EOL] public void testBadStates() { [EOL]     final StopWatch watch = new StopWatch(); [EOL]     try { [EOL]         watch.stop(); [EOL]         fail("Calling stop on an unstarted StopWatch should throw an exception. "); [EOL]     } catch (final IllegalStateException ise) { [EOL]     } [EOL]     try { [EOL]         watch.stop(); [EOL]         fail("Calling stop on an unstarted StopWatch should throw an exception. "); [EOL]     } catch (final IllegalStateException ise) { [EOL]     } [EOL]     try { [EOL]         watch.suspend(); [EOL]         fail("Calling suspend on an unstarted StopWatch should throw an exception. "); [EOL]     } catch (final IllegalStateException ise) { [EOL]     } [EOL]     try { [EOL]         watch.split(); [EOL]         fail("Calling split on a non-running StopWatch should throw an exception. "); [EOL]     } catch (final IllegalStateException ise) { [EOL]     } [EOL]     try { [EOL]         watch.unsplit(); [EOL]         fail("Calling unsplit on an unsplit StopWatch should throw an exception. "); [EOL]     } catch (final IllegalStateException ise) { [EOL]     } [EOL]     try { [EOL]         watch.resume(); [EOL]         fail("Calling resume on an unsuspended StopWatch should throw an exception. "); [EOL]     } catch (final IllegalStateException ise) { [EOL]     } [EOL]     watch.start(); [EOL]     try { [EOL]         watch.start(); [EOL]         fail("Calling start on a started StopWatch should throw an exception. "); [EOL]     } catch (final IllegalStateException ise) { [EOL]     } [EOL]     try { [EOL]         watch.unsplit(); [EOL]         fail("Calling unsplit on an unsplit StopWatch should throw an exception. "); [EOL]     } catch (final IllegalStateException ise) { [EOL]     } [EOL]     try { [EOL]         watch.getSplitTime(); [EOL]         fail("Calling getSplitTime on an unsplit StopWatch should throw an exception. "); [EOL]     } catch (final IllegalStateException ise) { [EOL]     } [EOL]     try { [EOL]         watch.resume(); [EOL]         fail("Calling resume on an unsuspended StopWatch should throw an exception. "); [EOL]     } catch (final IllegalStateException ise) { [EOL]     } [EOL]     watch.stop(); [EOL]     try { [EOL]         watch.start(); [EOL]         fail("Calling start on a stopped StopWatch should throw an exception as it needs to be reset. "); [EOL]     } catch (final IllegalStateException ise) { [EOL]     } [EOL] } <line_num>: 116,199
@Test [EOL] public void testGetStartTime() { [EOL]     final long beforeStopWatch = System.currentTimeMillis(); [EOL]     final StopWatch watch = new StopWatch(); [EOL]     try { [EOL]         watch.getStartTime(); [EOL]         fail("Calling getStartTime on an unstarted StopWatch should throw an exception"); [EOL]     } catch (final IllegalStateException expected) { [EOL]     } [EOL]     watch.start(); [EOL]     try { [EOL]         watch.getStartTime(); [EOL]         Assert.assertTrue(watch.getStartTime() >= beforeStopWatch); [EOL]     } catch (final IllegalStateException ex) { [EOL]         fail("Start time should be available: " + ex.getMessage()); [EOL]     } [EOL]     watch.reset(); [EOL]     try { [EOL]         watch.getStartTime(); [EOL]         fail("Calling getStartTime on a reset, but unstarted StopWatch should throw an exception"); [EOL]     } catch (final IllegalStateException expected) { [EOL]     } [EOL] } <line_num>: 201,225
