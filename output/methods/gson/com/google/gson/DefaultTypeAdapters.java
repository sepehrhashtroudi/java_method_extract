DefaultDateTypeAdapter() { [EOL]     this.format = DateFormat.getDateTimeInstance(); [EOL] } <line_num>: 246,248
DefaultDateTypeAdapter(final String datePattern) { [EOL]     this.format = new SimpleDateFormat(datePattern); [EOL] } <line_num>: 250,252
DefaultDateTypeAdapter(final int style) { [EOL]     this.format = DateFormat.getDateInstance(style); [EOL] } <line_num>: 254,256
public DefaultDateTypeAdapter(final int dateStyle, final int timeStyle) { [EOL]     this.format = DateFormat.getDateTimeInstance(dateStyle, timeStyle); [EOL] } <line_num>: 258,260
DefaultJavaSqlDateTypeAdapter() { [EOL]     this.format = new SimpleDateFormat("MMM d, yyyy"); [EOL] } <line_num>: 297,299
DefaultTimeTypeAdapter() { [EOL]     this.format = new SimpleDateFormat("hh:mm:ss a"); [EOL] } <line_num>: 334,336
private LongSerializer(LongSerializationPolicy longSerializationPolicy) { [EOL]     this.longSerializationPolicy = longSerializationPolicy; [EOL] } <line_num>: 684,686
FloatSerializer(boolean serializeSpecialDoubleValues) { [EOL]     this.serializeSpecialFloatingPointValues = serializeSpecialDoubleValues; [EOL] } <line_num>: 763,765
DoubleSerializer(boolean serializeSpecialDoubleValues) { [EOL]     this.serializeSpecialFloatingPointValues = serializeSpecialDoubleValues; [EOL] } <line_num>: 794,796
private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers() { [EOL]     ParameterizedTypeHandlerMap<JsonSerializer<?>> map = new ParameterizedTypeHandlerMap<JsonSerializer<?>>(); [EOL]     map.registerForTypeHierarchy(Enum.class, ENUM_TYPE_ADAPTER); [EOL]     map.register(URL.class, URL_TYPE_ADAPTER); [EOL]     map.register(URI.class, URI_TYPE_ADAPTER); [EOL]     map.register(UUID.class, UUUID_TYPE_ADAPTER); [EOL]     map.register(Locale.class, LOCALE_TYPE_ADAPTER); [EOL]     map.registerForTypeHierarchy(Collection.class, COLLECTION_TYPE_ADAPTER); [EOL]     map.registerForTypeHierarchy(Map.class, MAP_TYPE_ADAPTER); [EOL]     map.register(Date.class, DATE_TYPE_ADAPTER); [EOL]     map.register(java.sql.Date.class, JAVA_SQL_DATE_TYPE_ADAPTER); [EOL]     map.register(Timestamp.class, DATE_TYPE_ADAPTER); [EOL]     map.register(Time.class, TIME_TYPE_ADAPTER); [EOL]     map.register(Calendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER); [EOL]     map.register(GregorianCalendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER); [EOL]     map.register(BigDecimal.class, BIG_DECIMAL_TYPE_ADAPTER); [EOL]     map.register(BigInteger.class, BIG_INTEGER_TYPE_ADAPTER); [EOL]     map.register(Boolean.class, BOOLEAN_TYPE_ADAPTER); [EOL]     map.register(boolean.class, BOOLEAN_TYPE_ADAPTER); [EOL]     map.register(Byte.class, BYTE_TYPE_ADAPTER); [EOL]     map.register(byte.class, BYTE_TYPE_ADAPTER); [EOL]     map.register(Character.class, CHARACTER_TYPE_ADAPTER); [EOL]     map.register(char.class, CHARACTER_TYPE_ADAPTER); [EOL]     map.register(Integer.class, INTEGER_TYPE_ADAPTER); [EOL]     map.register(int.class, INTEGER_TYPE_ADAPTER); [EOL]     map.register(Number.class, NUMBER_TYPE_ADAPTER); [EOL]     map.register(Short.class, SHORT_TYPE_ADAPTER); [EOL]     map.register(short.class, SHORT_TYPE_ADAPTER); [EOL]     map.register(String.class, STRING_TYPE_ADAPTER); [EOL]     map.makeUnmodifiable(); [EOL]     return map; [EOL] } <line_num>: 103,139
private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers() { [EOL]     ParameterizedTypeHandlerMap<JsonDeserializer<?>> map = new ParameterizedTypeHandlerMap<JsonDeserializer<?>>(); [EOL]     map.registerForTypeHierarchy(Enum.class, wrapDeserializer(ENUM_TYPE_ADAPTER)); [EOL]     map.register(URL.class, wrapDeserializer(URL_TYPE_ADAPTER)); [EOL]     map.register(URI.class, wrapDeserializer(URI_TYPE_ADAPTER)); [EOL]     map.register(UUID.class, wrapDeserializer(UUUID_TYPE_ADAPTER)); [EOL]     map.register(Locale.class, wrapDeserializer(LOCALE_TYPE_ADAPTER)); [EOL]     map.registerForTypeHierarchy(Collection.class, wrapDeserializer(COLLECTION_TYPE_ADAPTER)); [EOL]     map.registerForTypeHierarchy(Map.class, wrapDeserializer(MAP_TYPE_ADAPTER)); [EOL]     map.register(Date.class, wrapDeserializer(DATE_TYPE_ADAPTER)); [EOL]     map.register(java.sql.Date.class, wrapDeserializer(JAVA_SQL_DATE_TYPE_ADAPTER)); [EOL]     map.register(Timestamp.class, wrapDeserializer(TIMESTAMP_DESERIALIZER)); [EOL]     map.register(Time.class, wrapDeserializer(TIME_TYPE_ADAPTER)); [EOL]     map.register(Calendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER); [EOL]     map.register(GregorianCalendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER); [EOL]     map.register(BigDecimal.class, wrapDeserializer(BIG_DECIMAL_TYPE_ADAPTER)); [EOL]     map.register(BigInteger.class, wrapDeserializer(BIG_INTEGER_TYPE_ADAPTER)); [EOL]     map.register(Boolean.class, wrapDeserializer(BOOLEAN_TYPE_ADAPTER)); [EOL]     map.register(boolean.class, wrapDeserializer(BOOLEAN_TYPE_ADAPTER)); [EOL]     map.register(Byte.class, wrapDeserializer(BYTE_TYPE_ADAPTER)); [EOL]     map.register(byte.class, wrapDeserializer(BYTE_TYPE_ADAPTER)); [EOL]     map.register(Character.class, wrapDeserializer(CHARACTER_TYPE_ADAPTER)); [EOL]     map.register(char.class, wrapDeserializer(CHARACTER_TYPE_ADAPTER)); [EOL]     map.register(Double.class, wrapDeserializer(DOUBLE_TYPE_ADAPTER)); [EOL]     map.register(double.class, wrapDeserializer(DOUBLE_TYPE_ADAPTER)); [EOL]     map.register(Float.class, wrapDeserializer(FLOAT_TYPE_ADAPTER)); [EOL]     map.register(float.class, wrapDeserializer(FLOAT_TYPE_ADAPTER)); [EOL]     map.register(Integer.class, wrapDeserializer(INTEGER_TYPE_ADAPTER)); [EOL]     map.register(int.class, wrapDeserializer(INTEGER_TYPE_ADAPTER)); [EOL]     map.register(Long.class, wrapDeserializer(LONG_DESERIALIZER)); [EOL]     map.register(long.class, wrapDeserializer(LONG_DESERIALIZER)); [EOL]     map.register(Number.class, wrapDeserializer(NUMBER_TYPE_ADAPTER)); [EOL]     map.register(Short.class, wrapDeserializer(SHORT_TYPE_ADAPTER)); [EOL]     map.register(short.class, wrapDeserializer(SHORT_TYPE_ADAPTER)); [EOL]     map.register(String.class, wrapDeserializer(STRING_TYPE_ADAPTER)); [EOL]     map.makeUnmodifiable(); [EOL]     return map; [EOL] } <line_num>: 141,182
private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators() { [EOL]     ParameterizedTypeHandlerMap<InstanceCreator<?>> map = new ParameterizedTypeHandlerMap<InstanceCreator<?>>(); [EOL]     map.registerForTypeHierarchy(Map.class, MAP_TYPE_ADAPTER); [EOL]     map.registerForTypeHierarchy(Collection.class, COLLECTION_TYPE_ADAPTER); [EOL]     map.registerForTypeHierarchy(Set.class, HASH_SET_CREATOR); [EOL]     map.registerForTypeHierarchy(SortedSet.class, TREE_SET_CREATOR); [EOL]     map.register(Properties.class, PROPERTIES_CREATOR); [EOL]     map.makeUnmodifiable(); [EOL]     return map; [EOL] } <line_num>: 184,197
@SuppressWarnings({ "unchecked", "rawtypes" }) [EOL] private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer) { [EOL]     return new JsonDeserializerExceptionWrapper(deserializer); [EOL] } <line_num>: 199,202
static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers() { [EOL]     return getDefaultSerializers(false, LongSerializationPolicy.DEFAULT); [EOL] } <line_num>: 204,206
static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(boolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy) { [EOL]     ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers = new ParameterizedTypeHandlerMap<JsonSerializer<?>>(); [EOL]     DefaultTypeAdapters.DoubleSerializer doubleSerializer = new DefaultTypeAdapters.DoubleSerializer(serializeSpecialFloatingPointValues); [EOL]     serializers.registerIfAbsent(Double.class, doubleSerializer); [EOL]     serializers.registerIfAbsent(double.class, doubleSerializer); [EOL]     DefaultTypeAdapters.FloatSerializer floatSerializer = new DefaultTypeAdapters.FloatSerializer(serializeSpecialFloatingPointValues); [EOL]     serializers.registerIfAbsent(Float.class, floatSerializer); [EOL]     serializers.registerIfAbsent(float.class, floatSerializer); [EOL]     DefaultTypeAdapters.LongSerializer longSerializer = new DefaultTypeAdapters.LongSerializer(longSerializationPolicy); [EOL]     serializers.registerIfAbsent(Long.class, longSerializer); [EOL]     serializers.registerIfAbsent(long.class, longSerializer); [EOL]     serializers.registerIfAbsent(DEFAULT_SERIALIZERS); [EOL]     return serializers; [EOL] } <line_num>: 208,233
static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers() { [EOL]     return DEFAULT_DESERIALIZERS; [EOL] } <line_num>: 235,237
static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators() { [EOL]     return DEFAULT_INSTANCE_CREATORS; [EOL] } <line_num>: 239,241
public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     synchronized (format) { [EOL]         String dateFormatAsString = format.format(src); [EOL]         return new JsonPrimitive(dateFormatAsString); [EOL]     } [EOL] } <line_num>: 264,269
public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (!(json instanceof JsonPrimitive)) { [EOL]         throw new JsonParseException("The date should be a string value"); [EOL]     } [EOL]     try { [EOL]         synchronized (format) { [EOL]             return format.parse(json.getAsString()); [EOL]         } [EOL]     } catch (ParseException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] } <line_num>: 271,283
@Override [EOL] public String toString() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append(DefaultDateTypeAdapter.class.getSimpleName()); [EOL]     sb.append('(').append(format.getClass().getSimpleName()).append(')'); [EOL]     return sb.toString(); [EOL] } <line_num>: 285,291
public JsonElement serialize(java.sql.Date src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     synchronized (format) { [EOL]         String dateFormatAsString = format.format(src); [EOL]         return new JsonPrimitive(dateFormatAsString); [EOL]     } [EOL] } <line_num>: 301,307
public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (!(json instanceof JsonPrimitive)) { [EOL]         throw new JsonParseException("The date should be a string value"); [EOL]     } [EOL]     try { [EOL]         synchronized (format) { [EOL]             Date date = format.parse(json.getAsString()); [EOL]             return new java.sql.Date(date.getTime()); [EOL]         } [EOL]     } catch (ParseException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] } <line_num>: 308,321
public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     Date date = context.deserialize(json, Date.class); [EOL]     return new Timestamp(date.getTime()); [EOL] } <line_num>: 325,329
public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     synchronized (format) { [EOL]         String dateFormatAsString = format.format(src); [EOL]         return new JsonPrimitive(dateFormatAsString); [EOL]     } [EOL] } <line_num>: 337,342
public Time deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (!(json instanceof JsonPrimitive)) { [EOL]         throw new JsonParseException("The date should be a string value"); [EOL]     } [EOL]     try { [EOL]         synchronized (format) { [EOL]             Date date = format.parse(json.getAsString()); [EOL]             return new Time(date.getTime()); [EOL]         } [EOL]     } catch (ParseException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] } <line_num>: 343,356
public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     JsonObject obj = new JsonObject(); [EOL]     obj.addProperty(YEAR, src.get(Calendar.YEAR)); [EOL]     obj.addProperty(MONTH, src.get(Calendar.MONTH)); [EOL]     obj.addProperty(DAY_OF_MONTH, src.get(Calendar.DAY_OF_MONTH)); [EOL]     obj.addProperty(HOUR_OF_DAY, src.get(Calendar.HOUR_OF_DAY)); [EOL]     obj.addProperty(MINUTE, src.get(Calendar.MINUTE)); [EOL]     obj.addProperty(SECOND, src.get(Calendar.SECOND)); [EOL]     return obj; [EOL] } <line_num>: 369,379
public GregorianCalendar deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     JsonObject obj = json.getAsJsonObject(); [EOL]     int year = obj.get(YEAR).getAsInt(); [EOL]     int month = obj.get(MONTH).getAsInt(); [EOL]     int dayOfMonth = obj.get(DAY_OF_MONTH).getAsInt(); [EOL]     int hourOfDay = obj.get(HOUR_OF_DAY).getAsInt(); [EOL]     int minute = obj.get(MINUTE).getAsInt(); [EOL]     int second = obj.get(SECOND).getAsInt(); [EOL]     return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second); [EOL] } <line_num>: 381,391
@Override [EOL] public String toString() { [EOL]     return GregorianCalendarTypeAdapter.class.getSimpleName(); [EOL] } <line_num>: 393,396
public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src.name()); [EOL] } <line_num>: 402,404
@SuppressWarnings("cast") [EOL] public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return (T) Enum.valueOf((Class<T>) classOfT, json.getAsString()); [EOL] } <line_num>: 406,410
@Override [EOL] public String toString() { [EOL]     return EnumTypeAdapter.class.getSimpleName(); [EOL] } <line_num>: 412,415
public JsonElement serialize(URL src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src.toExternalForm()); [EOL] } <line_num>: 419,421
public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     try { [EOL]         return new URL(json.getAsString()); [EOL]     } catch (MalformedURLException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] } <line_num>: 423,430
@Override [EOL] public String toString() { [EOL]     return UrlTypeAdapter.class.getSimpleName(); [EOL] } <line_num>: 432,435
public JsonElement serialize(URI src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src.toASCIIString()); [EOL] } <line_num>: 439,441
public URI deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     try { [EOL]         return new URI(json.getAsString()); [EOL]     } catch (URISyntaxException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] } <line_num>: 442,449
@Override [EOL] public String toString() { [EOL]     return UriTypeAdapter.class.getSimpleName(); [EOL] } <line_num>: 450,453
public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src.toString()); [EOL] } <line_num>: 457,459
public UUID deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return UUID.fromString(json.getAsString()); [EOL] } <line_num>: 461,464
@Override [EOL] public String toString() { [EOL]     return UuidTypeAdapter.class.getSimpleName(); [EOL] } <line_num>: 466,469
public JsonElement serialize(Locale src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src.toString()); [EOL] } <line_num>: 474,476
public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     String locale = json.getAsString(); [EOL]     StringTokenizer tokenizer = new StringTokenizer(locale, "_"); [EOL]     String language = null; [EOL]     String country = null; [EOL]     String variant = null; [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         language = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         country = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         variant = tokenizer.nextToken(); [EOL]     } [EOL]     if (country == null && variant == null) { [EOL]         return new Locale(language); [EOL]     } else if (variant == null) { [EOL]         return new Locale(language, country); [EOL]     } else { [EOL]         return new Locale(language, country, variant); [EOL]     } [EOL] } <line_num>: 478,501
@Override [EOL] public String toString() { [EOL]     return LocaleTypeAdapter.class.getSimpleName(); [EOL] } <line_num>: 503,506
public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (src == null) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } [EOL]     JsonArray array = new JsonArray(); [EOL]     Type childGenericType = null; [EOL]     if (typeOfSrc instanceof ParameterizedType) { [EOL]         childGenericType = new TypeInfoCollection(typeOfSrc).getElementType(); [EOL]     } [EOL]     for (Object child : src) { [EOL]         if (child == null) { [EOL]             array.add(JsonNull.createJsonNull()); [EOL]         } else { [EOL]             Type childType = (childGenericType == null || childGenericType == Object.class) ? child.getClass() : childGenericType; [EOL]             JsonElement element = context.serialize(child, childType); [EOL]             array.add(element); [EOL]         } [EOL]     } [EOL]     return array; [EOL] } <line_num>: 512,532
public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (json.isJsonNull()) { [EOL]         return null; [EOL]     } [EOL]     Collection collection = constructCollectionType(typeOfT, context); [EOL]     Type childType = new TypeInfoCollection(typeOfT).getElementType(); [EOL]     for (JsonElement childElement : json.getAsJsonArray()) { [EOL]         if (childElement == null || childElement.isJsonNull()) { [EOL]             collection.add(null); [EOL]         } else { [EOL]             Object value = context.deserialize(childElement, childType); [EOL]             collection.add(value); [EOL]         } [EOL]     } [EOL]     return collection; [EOL] } <line_num>: 534,552
private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context) { [EOL]     JsonDeserializationContextDefault contextImpl = (JsonDeserializationContextDefault) context; [EOL]     ObjectConstructor objectConstructor = contextImpl.getObjectConstructor(); [EOL]     return (Collection) objectConstructor.construct(collectionType); [EOL] } <line_num>: 554,559
public Collection createInstance(Type type) { [EOL]     return new LinkedList(); [EOL] } <line_num>: 561,563
public Properties createInstance(Type type) { [EOL]     return new Properties(); [EOL] } <line_num>: 567,569
public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     JsonObject map = new JsonObject(); [EOL]     Type childGenericType = null; [EOL]     if (typeOfSrc instanceof ParameterizedType) { [EOL]         childGenericType = new TypeInfoMap(typeOfSrc).getValueType(); [EOL]     } [EOL]     for (Map.Entry entry : (Set<Map.Entry>) src.entrySet()) { [EOL]         Object value = entry.getValue(); [EOL]         JsonElement valueElement; [EOL]         if (value == null) { [EOL]             valueElement = JsonNull.createJsonNull(); [EOL]         } else { [EOL]             Type childType = (childGenericType == null) ? value.getClass() : childGenericType; [EOL]             valueElement = context.serialize(value, childType); [EOL]         } [EOL]         map.add(String.valueOf(entry.getKey()), valueElement); [EOL]     } [EOL]     return map; [EOL] } <line_num>: 576,597
public Map deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     Map<Object, Object> map = constructMapType(typeOfT, context); [EOL]     TypeInfoMap mapTypeInfo = new TypeInfoMap(typeOfT); [EOL]     for (Map.Entry<String, JsonElement> entry : json.getAsJsonObject().entrySet()) { [EOL]         Object key = context.deserialize(new JsonPrimitive(entry.getKey()), mapTypeInfo.getKeyType()); [EOL]         Object value = context.deserialize(entry.getValue(), mapTypeInfo.getValueType()); [EOL]         map.put(key, value); [EOL]     } [EOL]     return map; [EOL] } <line_num>: 599,611
private Map constructMapType(Type mapType, JsonDeserializationContext context) { [EOL]     JsonDeserializationContextDefault contextImpl = (JsonDeserializationContextDefault) context; [EOL]     ObjectConstructor objectConstructor = contextImpl.getObjectConstructor(); [EOL]     return (Map) objectConstructor.construct(mapType); [EOL] } <line_num>: 613,617
public Map createInstance(Type type) { [EOL]     return new LinkedHashMap(); [EOL] } <line_num>: 619,621
@Override [EOL] public String toString() { [EOL]     return MapTypeAdapter.class.getSimpleName(); [EOL] } <line_num>: 623,626
public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src); [EOL] } <line_num>: 631,633
public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsBigDecimal(); [EOL] } <line_num>: 635,638
@Override [EOL] public String toString() { [EOL]     return BigDecimalTypeAdapter.class.getSimpleName(); [EOL] } <line_num>: 640,643
public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src); [EOL] } <line_num>: 649,651
public BigInteger deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsBigInteger(); [EOL] } <line_num>: 653,656
@Override [EOL] public String toString() { [EOL]     return BigIntegerTypeAdapter.class.getSimpleName(); [EOL] } <line_num>: 658,661
public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src); [EOL] } <line_num>: 666,668
public Number deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsNumber(); [EOL] } <line_num>: 670,673
@Override [EOL] public String toString() { [EOL]     return NumberTypeAdapter.class.getSimpleName(); [EOL] } <line_num>: 675,678
public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return longSerializationPolicy.serialize(src); [EOL] } <line_num>: 688,690
@Override [EOL] public String toString() { [EOL]     return LongSerializer.class.getSimpleName(); [EOL] } <line_num>: 692,695
public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsLong(); [EOL] } <line_num>: 699,702
@Override [EOL] public String toString() { [EOL]     return LongDeserializer.class.getSimpleName(); [EOL] } <line_num>: 704,707
public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src); [EOL] } <line_num>: 712,714
public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsInt(); [EOL] } <line_num>: 716,719
@Override [EOL] public String toString() { [EOL]     return IntegerTypeAdapter.class.getSimpleName(); [EOL] } <line_num>: 721,724
public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src); [EOL] } <line_num>: 729,731
public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsShort(); [EOL] } <line_num>: 733,736
@Override [EOL] public String toString() { [EOL]     return ShortTypeAdapter.class.getSimpleName(); [EOL] } <line_num>: 738,741
public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src); [EOL] } <line_num>: 745,747
public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsByte(); [EOL] } <line_num>: 749,752
@Override [EOL] public String toString() { [EOL]     return ByteTypeAdapter.class.getSimpleName(); [EOL] } <line_num>: 754,757
public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (!serializeSpecialFloatingPointValues) { [EOL]         if (Float.isNaN(src) || Float.isInfinite(src)) { [EOL]             throw new IllegalArgumentException(src + " is not a valid float value as per JSON specification. To override this" + " behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method."); [EOL]         } [EOL]     } [EOL]     return new JsonPrimitive(src); [EOL] } <line_num>: 767,776
public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsFloat(); [EOL] } <line_num>: 780,783
@Override [EOL] public String toString() { [EOL]     return FloatDeserializer.class.getSimpleName(); [EOL] } <line_num>: 785,788
public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (!serializeSpecialFloatingPointValues) { [EOL]         if (Double.isNaN(src) || Double.isInfinite(src)) { [EOL]             throw new IllegalArgumentException(src + " is not a valid double value as per JSON specification. To override this" + " behavior, use GsonBuilder.serializeSpecialDoubleValues() method."); [EOL]         } [EOL]     } [EOL]     return new JsonPrimitive(src); [EOL] } <line_num>: 798,807
public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsDouble(); [EOL] } <line_num>: 811,814
@Override [EOL] public String toString() { [EOL]     return DoubleDeserializer.class.getSimpleName(); [EOL] } <line_num>: 816,819
public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src); [EOL] } <line_num>: 824,826
public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsCharacter(); [EOL] } <line_num>: 828,831
@Override [EOL] public String toString() { [EOL]     return CharacterTypeAdapter.class.getSimpleName(); [EOL] } <line_num>: 833,836
public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src); [EOL] } <line_num>: 841,843
public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsString(); [EOL] } <line_num>: 845,848
@Override [EOL] public String toString() { [EOL]     return StringTypeAdapter.class.getSimpleName(); [EOL] } <line_num>: 850,853
public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src); [EOL] } <line_num>: 858,860
public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsBoolean(); [EOL] } <line_num>: 862,865
@Override [EOL] public String toString() { [EOL]     return BooleanTypeAdapter.class.getSimpleName(); [EOL] } <line_num>: 867,870
public TreeSet<?> createInstance(Type type) { [EOL]     return new TreeSet<Object>(); [EOL] } <line_num>: 874,876
@Override [EOL] public String toString() { [EOL]     return TreeSetCreator.class.getSimpleName(); [EOL] } <line_num>: 877,880
public HashSet<?> createInstance(Type type) { [EOL]     return new HashSet<Object>(); [EOL] } <line_num>: 884,886
@Override [EOL] public String toString() { [EOL]     return HashSetCreator.class.getSimpleName(); [EOL] } <line_num>: 887,890
