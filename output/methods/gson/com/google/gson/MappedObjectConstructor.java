public MappedObjectConstructor(ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators) { [EOL]     instanceCreatorMap = instanceCreators; [EOL] } <line_num>: 42,45
@SuppressWarnings("unchecked") [EOL] public <T> T construct(Type typeOfT) { [EOL]     InstanceCreator<T> creator = (InstanceCreator<T>) instanceCreatorMap.getHandlerFor(typeOfT); [EOL]     if (creator != null) { [EOL]         return creator.createInstance(typeOfT); [EOL]     } [EOL]     return (T) constructWithNoArgConstructor(typeOfT); [EOL] } <line_num>: 47,54
public Object constructArray(Type type, int length) { [EOL]     return Array.newInstance(TypeUtils.toRawClass(type), length); [EOL] } <line_num>: 56,58
private <T> T constructWithNoArgConstructor(Type typeOfT) { [EOL]     try { [EOL]         Constructor<T> constructor = getNoArgsConstructor(typeOfT); [EOL]         if (constructor == null) { [EOL]             throw new RuntimeException(("No-args constructor for " + typeOfT + " does not exist. " + "Register an InstanceCreator with Gson for this type to fix this problem.")); [EOL]         } [EOL]         return constructor.newInstance(); [EOL]     } catch (InstantiationException e) { [EOL]         throw new RuntimeException(("Unable to invoke no-args constructor for " + typeOfT + ". " + "Register an InstanceCreator with Gson for this type may fix this problem."), e); [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(("Unable to invoke no-args constructor for " + typeOfT + ". " + "Register an InstanceCreator with Gson for this type may fix this problem."), e); [EOL]     } catch (InvocationTargetException e) { [EOL]         throw new RuntimeException(("Unable to invoke no-args constructor for " + typeOfT + ". " + "Register an InstanceCreator with Gson for this type may fix this problem."), e); [EOL]     } [EOL] } <line_num>: 60,78
@SuppressWarnings({ "unchecked", "cast" }) [EOL] private <T> Constructor<T> getNoArgsConstructor(Type typeOfT) { [EOL]     TypeInfo typeInfo = new TypeInfo(typeOfT); [EOL]     Class<T> clazz = (Class<T>) typeInfo.getRawClass(); [EOL]     Constructor<T>[] declaredConstructors = (Constructor<T>[]) clazz.getDeclaredConstructors(); [EOL]     AccessibleObject.setAccessible(declaredConstructors, true); [EOL]     for (Constructor<T> constructor : declaredConstructors) { [EOL]         if (constructor.getParameterTypes().length == 0) { [EOL]             return constructor; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 80,92
<T> void register(Type typeOfT, InstanceCreator<? extends T> creator) { [EOL]     if (instanceCreatorMap.hasSpecificHandlerFor(typeOfT)) { [EOL]         log.log(Level.WARNING, "Overriding the existing InstanceCreator for {0}", typeOfT); [EOL]     } [EOL]     instanceCreatorMap.register(typeOfT, creator); [EOL] } <line_num>: 101,106
@Override [EOL] public String toString() { [EOL]     return instanceCreatorMap.toString(); [EOL] } <line_num>: 108,111
