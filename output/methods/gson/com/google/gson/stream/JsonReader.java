public JsonReader(Reader in) { [EOL]     if (in == null) { [EOL]         throw new NullPointerException("in == null"); [EOL]     } [EOL]     this.in = in; [EOL] } <line_num>: 238,243
public void setLenient(boolean lenient) { [EOL]     this.lenient = lenient; [EOL] } <line_num>: 274,276
public boolean isLenient() { [EOL]     return lenient; [EOL] } <line_num>: 281,283
public void beginArray() throws IOException { [EOL]     expect(JsonToken.BEGIN_ARRAY); [EOL] } <line_num>: 289,291
public void endArray() throws IOException { [EOL]     expect(JsonToken.END_ARRAY); [EOL] } <line_num>: 297,299
public void beginObject() throws IOException { [EOL]     expect(JsonToken.BEGIN_OBJECT); [EOL] } <line_num>: 305,307
public void endObject() throws IOException { [EOL]     expect(JsonToken.END_OBJECT); [EOL] } <line_num>: 313,315
private void expect(JsonToken expected) throws IOException { [EOL]     quickPeek(); [EOL]     if (token != expected) { [EOL]         throw new IllegalStateException("Expected " + expected + " but was " + peek()); [EOL]     } [EOL]     advance(); [EOL] } <line_num>: 320,326
public boolean hasNext() throws IOException { [EOL]     quickPeek(); [EOL]     return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY; [EOL] } <line_num>: 331,334
public JsonToken peek() throws IOException { [EOL]     quickPeek(); [EOL]     if (token == null) { [EOL]         decodeLiteral(); [EOL]     } [EOL]     return token; [EOL] } <line_num>: 339,347
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } <line_num>: 354,396
private void consumeNonExecutePrefix() throws IOException { [EOL]     nextNonWhitespace(); [EOL]     pos--; [EOL]     if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) { [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) { [EOL]         if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     pos += NON_EXECUTE_PREFIX.length; [EOL] } <line_num>: 401,418
private JsonToken advance() throws IOException { [EOL]     quickPeek(); [EOL]     JsonToken result = token; [EOL]     hasToken = false; [EOL]     token = null; [EOL]     value = null; [EOL]     name = null; [EOL]     return result; [EOL] } <line_num>: 423,432
public String nextName() throws IOException { [EOL]     quickPeek(); [EOL]     if (token != JsonToken.NAME) { [EOL]         throw new IllegalStateException("Expected a name but was " + peek()); [EOL]     } [EOL]     String result = name; [EOL]     advance(); [EOL]     return result; [EOL] } <line_num>: 441,449
public String nextString() throws IOException { [EOL]     peek(); [EOL]     if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) { [EOL]         throw new IllegalStateException("Expected a string but was " + peek()); [EOL]     } [EOL]     String result = value; [EOL]     advance(); [EOL]     return result; [EOL] } <line_num>: 459,468
public boolean nextBoolean() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null || token == JsonToken.STRING) { [EOL]         throw new IllegalStateException("Expected a boolean but was " + peek()); [EOL]     } [EOL]     boolean result; [EOL]     if (value.equalsIgnoreCase("true")) { [EOL]         result = true; [EOL]     } else if (value.equalsIgnoreCase("false")) { [EOL]         result = false; [EOL]     } else { [EOL]         throw new IllegalStateException("Not a boolean: " + value); [EOL]     } [EOL]     advance(); [EOL]     return result; [EOL] } <line_num>: 477,494
public void nextNull() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null || token == JsonToken.STRING) { [EOL]         throw new IllegalStateException("Expected null but was " + peek()); [EOL]     } [EOL]     if (!value.equalsIgnoreCase("null")) { [EOL]         throw new IllegalStateException("Not a null: " + value); [EOL]     } [EOL]     advance(); [EOL] } <line_num>: 503,514
public double nextDouble() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null) { [EOL]         throw new IllegalStateException("Expected a double but was " + peek()); [EOL]     } [EOL]     double result = Double.parseDouble(value); [EOL]     if ((result >= 1.0d && value.startsWith("0"))) { [EOL]         throw new NumberFormatException("JSON forbids octal prefixes: " + value); [EOL]     } [EOL]     if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) { [EOL]         throw new NumberFormatException("JSON forbids NaN and infinities: " + value); [EOL]     } [EOL]     advance(); [EOL]     return result; [EOL] } <line_num>: 525,543
public long nextLong() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null) { [EOL]         throw new IllegalStateException("Expected a long but was " + peek()); [EOL]     } [EOL]     long result; [EOL]     try { [EOL]         result = Long.parseLong(value); [EOL]     } catch (NumberFormatException ignored) { [EOL]         double asDouble = Double.parseDouble(value); [EOL]         result = (long) asDouble; [EOL]         if ((double) result != asDouble) { [EOL]             throw new NumberFormatException(value); [EOL]         } [EOL]     } [EOL]     if (result >= 1L && value.startsWith("0")) { [EOL]         throw new NumberFormatException("JSON forbids octal prefixes: " + value); [EOL]     } [EOL]     advance(); [EOL]     return result; [EOL] } <line_num>: 555,578
public int nextInt() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null) { [EOL]         throw new IllegalStateException("Expected an int but was " + peek()); [EOL]     } [EOL]     int result; [EOL]     try { [EOL]         result = Integer.parseInt(value); [EOL]     } catch (NumberFormatException ignored) { [EOL]         double asDouble = Double.parseDouble(value); [EOL]         result = (int) asDouble; [EOL]         if ((double) result != asDouble) { [EOL]             throw new NumberFormatException(value); [EOL]         } [EOL]     } [EOL]     if (result >= 1L && value.startsWith("0")) { [EOL]         throw new NumberFormatException("JSON forbids octal prefixes: " + value); [EOL]     } [EOL]     advance(); [EOL]     return result; [EOL] } <line_num>: 590,613
public void close() throws IOException { [EOL]     hasToken = false; [EOL]     value = null; [EOL]     token = null; [EOL]     stack.clear(); [EOL]     stack.add(JsonScope.CLOSED); [EOL]     in.close(); [EOL] } <line_num>: 618,625
public void skipValue() throws IOException { [EOL]     skipping = true; [EOL]     try { [EOL]         int count = 0; [EOL]         do { [EOL]             JsonToken token = advance(); [EOL]             if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) { [EOL]                 count++; [EOL]             } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) { [EOL]                 count--; [EOL]             } [EOL]         } while (count != 0); [EOL]     } finally { [EOL]         skipping = false; [EOL]     } [EOL] } <line_num>: 632,647
private JsonScope peekStack() { [EOL]     return stack.get(stack.size() - 1); [EOL] } <line_num>: 649,651
private JsonScope pop() { [EOL]     return stack.remove(stack.size() - 1); [EOL] } <line_num>: 653,655
private void push(JsonScope newTop) { [EOL]     stack.add(newTop); [EOL] } <line_num>: 657,659
private void replaceTop(JsonScope newTop) { [EOL]     stack.set(stack.size() - 1, newTop); [EOL] } <line_num>: 664,666
private JsonToken nextInArray(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case ']': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             case ';': [EOL]                 checkLenient(); [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated array"); [EOL]         } [EOL]     } [EOL]     switch(nextNonWhitespace()) { [EOL]         case ']': [EOL]             if (firstElement) { [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             } [EOL]         case ';': [EOL]         case ',': [EOL]             checkLenient(); [EOL]             pos--; [EOL]             hasToken = true; [EOL]             value = "null"; [EOL]             return token = JsonToken.NULL; [EOL]         default: [EOL]             pos--; [EOL]             return nextValue(); [EOL]     } [EOL] } <line_num>: 668,707
private JsonToken nextInObject(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             default: [EOL]                 pos--; [EOL]         } [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             case ';': [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated object"); [EOL]         } [EOL]     } [EOL]     int quote = nextNonWhitespace(); [EOL]     switch(quote) { [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             name = nextString((char) quote); [EOL]             break; [EOL]         default: [EOL]             checkLenient(); [EOL]             pos--; [EOL]             name = nextLiteral(); [EOL]             if (name.length() == 0) { [EOL]                 throw syntaxError("Expected name"); [EOL]             } [EOL]     } [EOL]     replaceTop(JsonScope.DANGLING_NAME); [EOL]     hasToken = true; [EOL]     return token = JsonToken.NAME; [EOL] } <line_num>: 709,759
private JsonToken objectValue() throws IOException { [EOL]     switch(nextNonWhitespace()) { [EOL]         case ':': [EOL]             break; [EOL]         case '=': [EOL]             checkLenient(); [EOL]             if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') { [EOL]                 pos++; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw syntaxError("Expected ':'"); [EOL]     } [EOL]     replaceTop(JsonScope.NONEMPTY_OBJECT); [EOL]     return nextValue(); [EOL] } <line_num>: 761,781
private JsonToken nextValue() throws IOException { [EOL]     int c = nextNonWhitespace(); [EOL]     switch(c) { [EOL]         case '{': [EOL]             push(JsonScope.EMPTY_OBJECT); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_OBJECT; [EOL]         case '[': [EOL]             push(JsonScope.EMPTY_ARRAY); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_ARRAY; [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             value = nextString((char) c); [EOL]             hasToken = true; [EOL]             return token = JsonToken.STRING; [EOL]         default: [EOL]             pos--; [EOL]             return readLiteral(); [EOL]     } [EOL] } <line_num>: 783,807
private boolean fillBuffer(int minimum) throws IOException { [EOL]     if (limit != pos) { [EOL]         limit -= pos; [EOL]         System.arraycopy(buffer, pos, buffer, 0, limit); [EOL]     } else { [EOL]         limit = 0; [EOL]     } [EOL]     pos = 0; [EOL]     int total; [EOL]     while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) { [EOL]         limit += total; [EOL]         if (limit >= minimum) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 814,831
private int nextNonWhitespace() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         int c = buffer[pos++]; [EOL]         switch(c) { [EOL]             case '\t': [EOL]             case ' ': [EOL]             case '\n': [EOL]             case '\r': [EOL]                 continue; [EOL]             case '/': [EOL]                 if (pos == limit && !fillBuffer(1)) { [EOL]                     return c; [EOL]                 } [EOL]                 checkLenient(); [EOL]                 char peek = buffer[pos]; [EOL]                 switch(peek) { [EOL]                     case '*': [EOL]                         pos++; [EOL]                         if (!skipTo("*/")) { [EOL]                             throw syntaxError("Unterminated comment"); [EOL]                         } [EOL]                         pos += 2; [EOL]                         continue; [EOL]                     case '/': [EOL]                         pos++; [EOL]                         skipToEndOfLine(); [EOL]                         continue; [EOL]                     default: [EOL]                         return c; [EOL]                 } [EOL]             case '#': [EOL]                 checkLenient(); [EOL]                 skipToEndOfLine(); [EOL]                 continue; [EOL]             default: [EOL]                 return c; [EOL]         } [EOL]     } [EOL]     throw new EOFException("End of input"); [EOL] } <line_num>: 833,885
private void checkLenient() throws IOException { [EOL]     if (!lenient) { [EOL]         throw syntaxError("Use JsonReader.setLenient(true) to accept malformed JSON"); [EOL]     } [EOL] } <line_num>: 887,891
private void skipToEndOfLine() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         char c = buffer[pos++]; [EOL]         if (c == '\r' || c == '\n') { [EOL]             break; [EOL]         } [EOL]     } [EOL] } <line_num>: 898,905
private boolean skipTo(String toFind) throws IOException { [EOL]     outer: for (; pos + toFind.length() < limit || fillBuffer(toFind.length()); pos++) { [EOL]         for (int c = 0; c < toFind.length(); c++) { [EOL]             if (buffer[pos + c] != toFind.charAt(c)) { [EOL]                 continue outer; [EOL]             } [EOL]         } [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 907,918
private String nextString(char quote) throws IOException { [EOL]     StringBuilder builder = null; [EOL]     do { [EOL]         int start = pos; [EOL]         while (pos < limit) { [EOL]             int c = buffer[pos++]; [EOL]             if (c == quote) { [EOL]                 if (skipping) { [EOL]                     return "skipped!"; [EOL]                 } else if (builder == null) { [EOL]                     return new String(buffer, start, pos - start - 1); [EOL]                 } else { [EOL]                     builder.append(buffer, start, pos - start - 1); [EOL]                     return builder.toString(); [EOL]                 } [EOL]             } else if (c == '\\') { [EOL]                 if (builder == null) { [EOL]                     builder = new StringBuilder(); [EOL]                 } [EOL]                 builder.append(buffer, start, pos - start - 1); [EOL]                 builder.append(readEscapeCharacter()); [EOL]                 start = pos; [EOL]             } [EOL]         } [EOL]         if (builder == null) { [EOL]             builder = new StringBuilder(); [EOL]         } [EOL]         builder.append(buffer, start, pos - start); [EOL]     } while (fillBuffer(1)); [EOL]     throw syntaxError("Unterminated string"); [EOL] } <line_num>: 930,965
private String nextLiteral() throws IOException { [EOL]     StringBuilder builder = null; [EOL]     do { [EOL]         int start = pos; [EOL]         while (pos < limit) { [EOL]             int c = buffer[pos++]; [EOL]             switch(c) { [EOL]                 case '/': [EOL]                 case '\\': [EOL]                 case ';': [EOL]                 case '#': [EOL]                 case '=': [EOL]                     checkLenient(); [EOL]                 case '{': [EOL]                 case '}': [EOL]                 case '[': [EOL]                 case ']': [EOL]                 case ':': [EOL]                 case ',': [EOL]                 case ' ': [EOL]                 case '\t': [EOL]                 case '\f': [EOL]                 case '\r': [EOL]                 case '\n': [EOL]                     pos--; [EOL]                     if (skipping) { [EOL]                         return "skipped!"; [EOL]                     } else if (builder == null) { [EOL]                         return new String(buffer, start, pos - start); [EOL]                     } else { [EOL]                         builder.append(buffer, start, pos - start); [EOL]                         return builder.toString(); [EOL]                     } [EOL]             } [EOL]         } [EOL]         if (builder == null) { [EOL]             builder = new StringBuilder(); [EOL]         } [EOL]         builder.append(buffer, start, pos - start); [EOL]     } while (fillBuffer(1)); [EOL]     return builder.toString(); [EOL] } <line_num>: 971,1016
@Override [EOL] public String toString() { [EOL]     return getClass().getSimpleName() + " near " + getSnippet(); [EOL] } <line_num>: 1018,1020
private char readEscapeCharacter() throws IOException { [EOL]     if (pos == limit && !fillBuffer(1)) { [EOL]         throw syntaxError("Unterminated escape sequence"); [EOL]     } [EOL]     char escaped = buffer[pos++]; [EOL]     switch(escaped) { [EOL]         case 'u': [EOL]             if (pos + 4 > limit && !fillBuffer(4)) { [EOL]                 throw syntaxError("Unterminated escape sequence"); [EOL]             } [EOL]             String hex = new String(buffer, pos, 4); [EOL]             pos += 4; [EOL]             return (char) Integer.parseInt(hex, 16); [EOL]         case 't': [EOL]             return '\t'; [EOL]         case 'b': [EOL]             return '\b'; [EOL]         case 'n': [EOL]             return '\n'; [EOL]         case 'r': [EOL]             return '\r'; [EOL]         case 'f': [EOL]             return '\f'; [EOL]         case '\'': [EOL]         case '"': [EOL]         case '\\': [EOL]         default: [EOL]             return escaped; [EOL]     } [EOL] } <line_num>: 1031,1067
private JsonToken readLiteral() throws IOException { [EOL]     String literal = nextLiteral(); [EOL]     if (literal.length() == 0) { [EOL]         throw syntaxError("Expected literal value"); [EOL]     } [EOL]     value = literal; [EOL]     hasToken = true; [EOL]     return token = null; [EOL] } <line_num>: 1072,1080
private void decodeLiteral() throws IOException { [EOL]     if (value.equalsIgnoreCase("null")) { [EOL]         token = JsonToken.NULL; [EOL]     } else if (value.equalsIgnoreCase("true") || value.equalsIgnoreCase("false")) { [EOL]         token = JsonToken.BOOLEAN; [EOL]     } else { [EOL]         try { [EOL]             Double.parseDouble(value); [EOL]             token = JsonToken.NUMBER; [EOL]         } catch (NumberFormatException ignored) { [EOL]             checkLenient(); [EOL]             token = JsonToken.STRING; [EOL]         } [EOL]     } [EOL] } <line_num>: 1085,1100
private IOException syntaxError(String message) throws IOException { [EOL]     throw new MalformedJsonException(message + " near " + getSnippet()); [EOL] } <line_num>: 1106,1108
private CharSequence getSnippet() { [EOL]     StringBuilder snippet = new StringBuilder(); [EOL]     int beforePos = Math.min(pos, 20); [EOL]     snippet.append(buffer, pos - beforePos, beforePos); [EOL]     int afterPos = Math.min(limit - pos, 20); [EOL]     snippet.append(buffer, pos, afterPos); [EOL]     return snippet; [EOL] } <line_num>: 1110,1117
