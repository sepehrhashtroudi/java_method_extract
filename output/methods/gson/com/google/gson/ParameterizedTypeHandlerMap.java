public synchronized void registerForTypeHierarchy(Class<?> typeOfT, T value) { [EOL]     Pair<Class<?>, T> pair = new Pair<Class<?>, T>(typeOfT, value); [EOL]     registerForTypeHierarchy(pair); [EOL] } <line_num>: 43,46
public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) { [EOL]     if (!modifiable) { [EOL]         throw new IllegalStateException("Attempted to modify an unmodifiable map."); [EOL]     } [EOL]     int index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first); [EOL]     if (index >= 0) { [EOL]         logger.log(Level.WARNING, "Overriding the existing type handler for {0}", pair.first); [EOL]         typeHierarchyList.remove(index); [EOL]     } [EOL]     index = getIndexOfAnOverriddenHandler(pair.first); [EOL]     if (index >= 0) { [EOL]         throw new IllegalArgumentException("The specified type handler for type " + pair.first + " hides the previously registered type hierarchy handler for " + typeHierarchyList.get(index).first + ". Gson does not allow this."); [EOL]     } [EOL]     typeHierarchyList.add(0, pair); [EOL] } <line_num>: 48,66
private int getIndexOfAnOverriddenHandler(Class<?> type) { [EOL]     for (int i = typeHierarchyList.size() - 1; i >= 0; --i) { [EOL]         Pair<Class<?>, T> entry = typeHierarchyList.get(i); [EOL]         if (type.isAssignableFrom(entry.first)) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] } <line_num>: 68,76
public synchronized void register(Type typeOfT, T value) { [EOL]     if (!modifiable) { [EOL]         throw new IllegalStateException("Attempted to modify an unmodifiable map."); [EOL]     } [EOL]     if (hasSpecificHandlerFor(typeOfT)) { [EOL]         logger.log(Level.WARNING, "Overriding the existing type handler for {0}", typeOfT); [EOL]     } [EOL]     map.put(typeOfT, value); [EOL] } <line_num>: 78,86
public synchronized void registerIfAbsent(ParameterizedTypeHandlerMap<T> other) { [EOL]     if (!modifiable) { [EOL]         throw new IllegalStateException("Attempted to modify an unmodifiable map."); [EOL]     } [EOL]     for (Map.Entry<Type, T> entry : other.map.entrySet()) { [EOL]         if (!map.containsKey(entry.getKey())) { [EOL]             register(entry.getKey(), entry.getValue()); [EOL]         } [EOL]     } [EOL]     for (int i = other.typeHierarchyList.size() - 1; i >= 0; --i) { [EOL]         Pair<Class<?>, T> entry = other.typeHierarchyList.get(i); [EOL]         int index = getIndexOfSpecificHandlerForTypeHierarchy(entry.first); [EOL]         if (index < 0) { [EOL]             registerForTypeHierarchy(entry); [EOL]         } [EOL]     } [EOL] } <line_num>: 88,106
public synchronized void registerIfAbsent(Type typeOfT, T value) { [EOL]     if (!modifiable) { [EOL]         throw new IllegalStateException("Attempted to modify an unmodifiable map."); [EOL]     } [EOL]     if (!map.containsKey(typeOfT)) { [EOL]         register(typeOfT, value); [EOL]     } [EOL] } <line_num>: 108,115
public synchronized void makeUnmodifiable() { [EOL]     modifiable = false; [EOL] } <line_num>: 117,119
public synchronized T getHandlerFor(Type type) { [EOL]     T handler = map.get(type); [EOL]     if (handler == null) { [EOL]         Class<?> rawClass = TypeUtils.toRawClass(type); [EOL]         if (rawClass != type) { [EOL]             handler = getHandlerFor(rawClass); [EOL]         } [EOL]         if (handler == null) { [EOL]             handler = getHandlerForTypeHierarchy(rawClass); [EOL]         } [EOL]     } [EOL]     return handler; [EOL] } <line_num>: 121,134
private T getHandlerForTypeHierarchy(Class<?> type) { [EOL]     for (Pair<Class<?>, T> entry : typeHierarchyList) { [EOL]         if (entry.first.isAssignableFrom(type)) { [EOL]             return entry.second; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 136,143
public synchronized boolean hasSpecificHandlerFor(Type type) { [EOL]     return map.containsKey(type); [EOL] } <line_num>: 145,147
private synchronized int getIndexOfSpecificHandlerForTypeHierarchy(Class<?> type) { [EOL]     for (int i = typeHierarchyList.size() - 1; i >= 0; --i) { [EOL]         if (type.equals(typeHierarchyList.get(i).first)) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] } <line_num>: 149,156
public synchronized ParameterizedTypeHandlerMap<T> copyOf() { [EOL]     ParameterizedTypeHandlerMap<T> copy = new ParameterizedTypeHandlerMap<T>(); [EOL]     for (Map.Entry<Type, T> entry : map.entrySet()) { [EOL]         copy.register(entry.getKey(), entry.getValue()); [EOL]     } [EOL]     for (Pair<Class<?>, T> entry : typeHierarchyList) { [EOL]         copy.registerForTypeHierarchy(entry); [EOL]     } [EOL]     return copy; [EOL] } <line_num>: 158,167
@Override [EOL] public String toString() { [EOL]     StringBuilder sb = new StringBuilder("{mapForTypeHierarchy:{"); [EOL]     boolean first = true; [EOL]     for (Pair<Class<?>, T> entry : typeHierarchyList) { [EOL]         if (first) { [EOL]             first = false; [EOL]         } else { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(typeToString(entry.first)).append(':'); [EOL]         sb.append(entry.second); [EOL]     } [EOL]     sb.append("},map:{"); [EOL]     first = true; [EOL]     for (Map.Entry<Type, T> entry : map.entrySet()) { [EOL]         if (first) { [EOL]             first = false; [EOL]         } else { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append(typeToString(entry.getKey())).append(':'); [EOL]         sb.append(entry.getValue()); [EOL]     } [EOL]     sb.append("}"); [EOL]     return sb.toString(); [EOL] } <line_num>: 169,195
private String typeToString(Type type) { [EOL]     return TypeUtils.toRawClass(type).getSimpleName(); [EOL] } <line_num>: 197,199
