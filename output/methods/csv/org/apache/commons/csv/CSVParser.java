public CSVParser(Reader input) throws IOException { [EOL]     this(input, CSVFormat.DEFAULT); [EOL] } <line_num>: 80,82
public CSVParser(Reader input, CSVFormat format) throws IOException { [EOL]     format.validate(); [EOL]     this.lexer = new CSVLexer(format, new ExtendedBufferedReader(input)); [EOL]     this.headerMapping = initializeHeader(format); [EOL] } <line_num>: 91,97
public CSVParser(String input, CSVFormat format) throws IOException { [EOL]     this(new StringReader(input), format); [EOL] } <line_num>: 106,108
public List<CSVRecord> getRecords() throws IOException { [EOL]     List<CSVRecord> records = new ArrayList<CSVRecord>(); [EOL]     CSVRecord rec; [EOL]     while ((rec = getRecord()) != null) { [EOL]         records.add(rec); [EOL]     } [EOL]     return records; [EOL] } <line_num>: 120,127
CSVRecord getRecord() throws IOException { [EOL]     CSVRecord result = new CSVRecord(null, headerMapping); [EOL]     record.clear(); [EOL]     do { [EOL]         reusableToken.reset(); [EOL]         lexer.nextToken(reusableToken); [EOL]         switch(reusableToken.type) { [EOL]             case TOKEN: [EOL]                 record.add(reusableToken.content.toString()); [EOL]                 break; [EOL]             case EORECORD: [EOL]                 record.add(reusableToken.content.toString()); [EOL]                 break; [EOL]             case EOF: [EOL]                 if (reusableToken.isReady) { [EOL]                     record.add(reusableToken.content.toString()); [EOL]                 } else { [EOL]                     result = null; [EOL]                 } [EOL]                 break; [EOL]             case INVALID: [EOL]                 throw new IOException("(line " + getLineNumber() + ") invalid parse sequence"); [EOL]         } [EOL]     } while (reusableToken.type == TOKEN); [EOL]     if (!record.isEmpty()) { [EOL]         result = new CSVRecord(record.toArray(new String[record.size()]), headerMapping); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 135,164
private Map<String, Integer> initializeHeader(CSVFormat format) throws IOException { [EOL]     Map<String, Integer> hdrMap = null; [EOL]     if (format.getHeader() != null) { [EOL]         hdrMap = new HashMap<String, Integer>(); [EOL]         String[] header = null; [EOL]         if (format.getHeader().length == 0) { [EOL]             CSVRecord rec = getRecord(); [EOL]             if (rec != null) { [EOL]                 header = rec.values(); [EOL]             } [EOL]         } else { [EOL]             header = format.getHeader(); [EOL]         } [EOL]         if (header != null) { [EOL]             for (int i = 0; i < header.length; i++) { [EOL]                 hdrMap.put(header[i], Integer.valueOf(i)); [EOL]             } [EOL]         } [EOL]     } [EOL]     return hdrMap; [EOL] } <line_num>: 169,193
public boolean hasNext() { [EOL]     if (current == null) { [EOL]         current = getNextRecord(); [EOL]     } [EOL]     return current != null; [EOL] } <line_num>: 203,209
public CSVRecord next() { [EOL]     CSVRecord next = current; [EOL]     current = null; [EOL]     if (next == null) { [EOL]         next = getNextRecord(); [EOL]         if (next == null) { [EOL]             throw new NoSuchElementException("No more CSV records available"); [EOL]         } [EOL]     } [EOL]     return next; [EOL] } <line_num>: 211,224
private CSVRecord getNextRecord() { [EOL]     try { [EOL]         return getRecord(); [EOL]     } catch (IOException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL] } <line_num>: 226,232
public void remove() { [EOL]     throw new UnsupportedOperationException(); [EOL] } <line_num>: 234,236
public Iterator<CSVRecord> iterator() { [EOL]     return new Iterator<CSVRecord>() { [EOL]  [EOL]         private CSVRecord current; [EOL]  [EOL]         public boolean hasNext() { [EOL]             if (current == null) { [EOL]                 current = getNextRecord(); [EOL]             } [EOL]             return current != null; [EOL]         } [EOL]  [EOL]         public CSVRecord next() { [EOL]             CSVRecord next = current; [EOL]             current = null; [EOL]             if (next == null) { [EOL]                 next = getNextRecord(); [EOL]                 if (next == null) { [EOL]                     throw new NoSuchElementException("No more CSV records available"); [EOL]                 } [EOL]             } [EOL]             return next; [EOL]         } [EOL]  [EOL]         private CSVRecord getNextRecord() { [EOL]             try { [EOL]                 return getRecord(); [EOL]             } catch (IOException e) { [EOL]                 throw new RuntimeException(e); [EOL]             } [EOL]         } [EOL]  [EOL]         public void remove() { [EOL]             throw new UnsupportedOperationException(); [EOL]         } [EOL]     }; [EOL] } <line_num>: 199,238
public int getLineNumber() { [EOL]     return lexer.getLineNumber(); [EOL] } <line_num>: 248,250
