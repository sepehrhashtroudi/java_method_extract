public CSVLexer(CSVFormat format, ExtendedBufferedReader in) { [EOL]     super(format, in); [EOL] } <line_num>: 27,29
@Override [EOL] Token nextToken(Token tkn) throws IOException { [EOL]     int lastChar = in.readAgain(); [EOL]     int c = in.read(); [EOL]     boolean eol = isEndOfLine(c); [EOL]     c = in.readAgain(); [EOL]     if (emptyLinesIgnored) { [EOL]         while (eol && (lastChar == '\n' || lastChar == '\r' || lastChar == ExtendedBufferedReader.UNDEFINED) && !isEndOfFile(lastChar)) { [EOL]             lastChar = c; [EOL]             c = in.read(); [EOL]             eol = isEndOfLine(c); [EOL]             c = in.readAgain(); [EOL]             if (isEndOfFile(c)) { [EOL]                 tkn.type = EOF; [EOL]                 return tkn; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (isEndOfFile(lastChar) || (!isDelimiter(lastChar) && isEndOfFile(c))) { [EOL]         tkn.type = EOF; [EOL]         return tkn; [EOL]     } [EOL]     while (tkn.type == INVALID) { [EOL]         if (surroundingSpacesIgnored) { [EOL]             while (isWhitespace(c) && !eol) { [EOL]                 c = in.read(); [EOL]                 eol = isEndOfLine(c); [EOL]             } [EOL]         } [EOL]         if (isCommentStart(c)) { [EOL]             in.readLine(); [EOL]             tkn = nextToken(tkn.reset()); [EOL]         } else if (isDelimiter(c)) { [EOL]             tkn.type = TOKEN; [EOL]         } else if (eol) { [EOL]             tkn.type = EORECORD; [EOL]         } else if (isEncapsulator(c)) { [EOL]             encapsulatedTokenLexer(tkn, c); [EOL]         } else if (isEndOfFile(c)) { [EOL]             tkn.type = EOF; [EOL]             tkn.isReady = true; [EOL]         } else { [EOL]             simpleTokenLexer(tkn, c); [EOL]         } [EOL]     } [EOL]     return tkn; [EOL] } <line_num>: 40,118
private Token simpleTokenLexer(Token tkn, int c) throws IOException { [EOL]     while (true) { [EOL]         if (isEndOfLine(c)) { [EOL]             tkn.type = EORECORD; [EOL]             break; [EOL]         } else if (isEndOfFile(c)) { [EOL]             tkn.type = EOF; [EOL]             tkn.isReady = true; [EOL]             break; [EOL]         } else if (isDelimiter(c)) { [EOL]             tkn.type = TOKEN; [EOL]             break; [EOL]         } else if (isEscape(c)) { [EOL]             tkn.content.append((char) readEscape(c)); [EOL]         } else { [EOL]             tkn.content.append((char) c); [EOL]         } [EOL]         c = in.read(); [EOL]     } [EOL]     if (surroundingSpacesIgnored) { [EOL]         trimTrailingSpaces(tkn.content); [EOL]     } [EOL]     return tkn; [EOL] } <line_num>: 137,166
private Token encapsulatedTokenLexer(Token tkn, int c) throws IOException { [EOL]     int startLineNumber = getLineNumber(); [EOL]     while (true) { [EOL]         c = in.read(); [EOL]         if (isEscape(c)) { [EOL]             tkn.content.append((char) readEscape(c)); [EOL]         } else if (isEncapsulator(c)) { [EOL]             if (isEncapsulator(in.lookAhead())) { [EOL]                 c = in.read(); [EOL]                 tkn.content.append((char) c); [EOL]             } else { [EOL]                 while (true) { [EOL]                     c = in.read(); [EOL]                     if (isDelimiter(c)) { [EOL]                         tkn.type = TOKEN; [EOL]                         return tkn; [EOL]                     } else if (isEndOfFile(c)) { [EOL]                         tkn.type = EOF; [EOL]                         tkn.isReady = true; [EOL]                         return tkn; [EOL]                     } else if (isEndOfLine(c)) { [EOL]                         tkn.type = EORECORD; [EOL]                         return tkn; [EOL]                     } else if (!isWhitespace(c)) { [EOL]                         throw new IOException("(line " + getLineNumber() + ") invalid char between encapsulated token and delimiter"); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } else if (isEndOfFile(c)) { [EOL]             throw new IOException("(startline " + startLineNumber + ") EOF reached before encapsulated token finished"); [EOL]         } else { [EOL]             tkn.content.append((char) c); [EOL]         } [EOL]     } [EOL] } <line_num>: 181,225
