public TextNode(String v) { [EOL]     _value = v; [EOL] } <line_num>: 24,24
public static TextNode valueOf(String v) { [EOL]     if (v == null) { [EOL]         return null; [EOL]     } [EOL]     if (v.length() == 0) { [EOL]         return EMPTY_STRING_NODE; [EOL]     } [EOL]     return new TextNode(v); [EOL] } <line_num>: 35,44
@Override [EOL] public JsonNodeType getNodeType() { [EOL]     return JsonNodeType.STRING; [EOL] } <line_num>: 46,50
@Override [EOL] public JsonToken asToken() { [EOL]     return JsonToken.VALUE_STRING; [EOL] } <line_num>: 52,52
@Override [EOL] public String textValue() { [EOL]     return _value; [EOL] } <line_num>: 54,57
public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { [EOL]     @SuppressWarnings("resource") [EOL]     ByteArrayBuilder builder = new ByteArrayBuilder(100); [EOL]     final String str = _value; [EOL]     int ptr = 0; [EOL]     int len = str.length(); [EOL]     main_loop: while (ptr < len) { [EOL]         char ch; [EOL]         do { [EOL]             ch = str.charAt(ptr++); [EOL]             if (ptr >= len) { [EOL]                 break main_loop; [EOL]             } [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             _reportInvalidBase64(b64variant, ch, 0); [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (ptr >= len) { [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             _reportInvalidBase64(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (ptr >= len) { [EOL]             if (!b64variant.usesPadding()) { [EOL]                 decodedData >>= 4; [EOL]                 builder.append(decodedData); [EOL]                 break; [EOL]             } [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 _reportInvalidBase64(b64variant, ch, 2); [EOL]             } [EOL]             if (ptr >= len) { [EOL]                 _reportBase64EOF(); [EOL]             } [EOL]             ch = str.charAt(ptr++); [EOL]             if (!b64variant.usesPaddingChar(ch)) { [EOL]                 _reportInvalidBase64(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL]             } [EOL]             decodedData >>= 4; [EOL]             builder.append(decodedData); [EOL]             continue; [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (ptr >= len) { [EOL]             if (!b64variant.usesPadding()) { [EOL]                 decodedData >>= 2; [EOL]                 builder.appendTwoBytes(decodedData); [EOL]                 break; [EOL]             } [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 _reportInvalidBase64(b64variant, ch, 3); [EOL]             } [EOL]             decodedData >>= 2; [EOL]             builder.appendTwoBytes(decodedData); [EOL]         } else { [EOL]             decodedData = (decodedData << 6) | bits; [EOL]             builder.appendThreeBytes(decodedData); [EOL]         } [EOL]     } [EOL]     return builder.toByteArray(); [EOL] } <line_num>: 64,157
@Override [EOL] public byte[] binaryValue() throws IOException { [EOL]     return getBinaryValue(Base64Variants.getDefaultVariant()); [EOL] } <line_num>: 159,163
@Override [EOL] public String asText() { [EOL]     return _value; [EOL] } <line_num>: 171,174
@Override [EOL] public boolean asBoolean(boolean defaultValue) { [EOL]     if (_value != null) { [EOL]         if ("true".equals(_value.trim())) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return defaultValue; [EOL] } <line_num>: 178,186
@Override [EOL] public int asInt(int defaultValue) { [EOL]     return NumberInput.parseAsInt(_value, defaultValue); [EOL] } <line_num>: 188,191
@Override [EOL] public long asLong(long defaultValue) { [EOL]     return NumberInput.parseAsLong(_value, defaultValue); [EOL] } <line_num>: 193,196
@Override [EOL] public double asDouble(double defaultValue) { [EOL]     return NumberInput.parseAsDouble(_value, defaultValue); [EOL] } <line_num>: 198,201
@Override [EOL] public final void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException, JsonProcessingException { [EOL]     if (_value == null) { [EOL]         jg.writeNull(); [EOL]     } else { [EOL]         jg.writeString(_value); [EOL]     } [EOL] } <line_num>: 209,218
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return ((TextNode) o)._value.equals(_value); [EOL] } <line_num>: 226,235
@Override [EOL] public int hashCode() { [EOL]     return _value.hashCode(); [EOL] } <line_num>: 237,238
@Override [EOL] public String toString() { [EOL]     int len = _value.length(); [EOL]     len = len + 2 + (len >> 4); [EOL]     StringBuilder sb = new StringBuilder(len); [EOL]     appendQuoted(sb, _value); [EOL]     return sb.toString(); [EOL] } <line_num>: 243,251
protected static void appendQuoted(StringBuilder sb, String content) { [EOL]     sb.append('"'); [EOL]     CharTypes.appendQuoted(sb, content); [EOL]     sb.append('"'); [EOL] } <line_num>: 253,258
protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex) throws JsonParseException { [EOL]     _reportInvalidBase64(b64variant, ch, bindex, null); [EOL] } <line_num>: 266,270
protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException { [EOL]     String base; [EOL]     if (ch <= INT_SPACE) { [EOL]         base = "Illegal white space character (code 0x" + Integer.toHexString(ch) + ") as character #" + (bindex + 1) + " of 4-char base64 unit: can only used between units"; [EOL]     } else if (b64variant.usesPaddingChar(ch)) { [EOL]         base = "Unexpected padding character ('" + b64variant.getPaddingChar() + "') as character #" + (bindex + 1) + " of 4-char base64 unit: padding only legal as 3rd or 4th character"; [EOL]     } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) { [EOL]         base = "Illegal character (code 0x" + Integer.toHexString(ch) + ") in base64 content"; [EOL]     } else { [EOL]         base = "Illegal character '" + ch + "' (code 0x" + Integer.toHexString(ch) + ") in base64 content"; [EOL]     } [EOL]     if (msg != null) { [EOL]         base = base + ": " + msg; [EOL]     } [EOL]     throw new JsonParseException(base, JsonLocation.NA); [EOL] } <line_num>: 276,294
protected void _reportBase64EOF() throws JsonParseException { [EOL]     throw new JsonParseException("Unexpected end-of-String when base64 content", JsonLocation.NA); [EOL] } <line_num>: 296,300
