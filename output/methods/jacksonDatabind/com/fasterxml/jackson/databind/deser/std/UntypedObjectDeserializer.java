public UntypedObjectDeserializer() { [EOL]     super(Object.class); [EOL] } <line_num>: 37,37
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] } <line_num>: 45,92
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]         case START_OBJECT: [EOL]         case FIELD_NAME: [EOL]             return typeDeserializer.deserializeTypedFromAny(jp, ctxt); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] } <line_num>: 94,146
protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) { [EOL]         return mapArrayToArray(jp, ctxt); [EOL]     } [EOL]     if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]         return new ArrayList<Object>(4); [EOL]     } [EOL]     ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] values = buffer.resetAndStart(); [EOL]     int ptr = 0; [EOL]     int totalSize = 0; [EOL]     do { [EOL]         Object value = deserialize(jp, ctxt); [EOL]         ++totalSize; [EOL]         if (ptr >= values.length) { [EOL]             values = buffer.appendCompletedChunk(values); [EOL]             ptr = 0; [EOL]         } [EOL]         values[ptr++] = value; [EOL]     } while (jp.nextToken() != JsonToken.END_ARRAY); [EOL]     ArrayList<Object> result = new ArrayList<Object>(totalSize + (totalSize >> 3) + 1); [EOL]     buffer.completeAndClearBuffer(values, ptr, result); [EOL]     return result; [EOL] } <line_num>: 157,184
protected Object mapObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     if (t != JsonToken.FIELD_NAME) { [EOL]         return new LinkedHashMap<String, Object>(4); [EOL]     } [EOL]     String field1 = jp.getText(); [EOL]     jp.nextToken(); [EOL]     Object value1 = deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4); [EOL]         result.put(field1, value1); [EOL]         return result; [EOL]     } [EOL]     String field2 = jp.getText(); [EOL]     jp.nextToken(); [EOL]     Object value2 = deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4); [EOL]         result.put(field1, value1); [EOL]         result.put(field2, value2); [EOL]         return result; [EOL]     } [EOL]     LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(); [EOL]     result.put(field1, value1); [EOL]     result.put(field2, value2); [EOL]     do { [EOL]         String fieldName = jp.getText(); [EOL]         jp.nextToken(); [EOL]         result.put(fieldName, deserialize(jp, ctxt)); [EOL]     } while (jp.nextToken() != JsonToken.END_OBJECT); [EOL]     return result; [EOL] } <line_num>: 189,228
protected Object[] mapArrayToArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]         return NO_OBJECTS; [EOL]     } [EOL]     ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] values = buffer.resetAndStart(); [EOL]     int ptr = 0; [EOL]     do { [EOL]         Object value = deserialize(jp, ctxt); [EOL]         if (ptr >= values.length) { [EOL]             values = buffer.appendCompletedChunk(values); [EOL]             ptr = 0; [EOL]         } [EOL]         values[ptr++] = value; [EOL]     } while (jp.nextToken() != JsonToken.END_ARRAY); [EOL]     return buffer.completeAndClearBuffer(values, ptr); [EOL] } <line_num>: 233,252
