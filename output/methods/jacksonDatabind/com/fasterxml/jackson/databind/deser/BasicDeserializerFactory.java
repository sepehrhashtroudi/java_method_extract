protected BasicDeserializerFactory(DeserializerFactoryConfig config) { [EOL]     _factoryConfig = config; [EOL] } <line_num>: 112,114
public DeserializerFactoryConfig getFactoryConfig() { [EOL]     return _factoryConfig; [EOL] } <line_num>: 123,125
protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config); <line_num>: 127,127
@Override [EOL] public final DeserializerFactory withAdditionalDeserializers(Deserializers additional) { [EOL]     return withConfig(_factoryConfig.withAdditionalDeserializers(additional)); [EOL] } <line_num>: 139,142
@Override [EOL] public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional) { [EOL]     return withConfig(_factoryConfig.withAdditionalKeyDeserializers(additional)); [EOL] } <line_num>: 148,151
@Override [EOL] public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier) { [EOL]     return withConfig(_factoryConfig.withDeserializerModifier(modifier)); [EOL] } <line_num>: 157,160
@Override [EOL] public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver) { [EOL]     return withConfig(_factoryConfig.withAbstractTypeResolver(resolver)); [EOL] } <line_num>: 166,169
@Override [EOL] public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators) { [EOL]     return withConfig(_factoryConfig.withValueInstantiators(instantiators)); [EOL] } <line_num>: 175,178
@Override [EOL] public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException { [EOL]     while (true) { [EOL]         JavaType next = _mapAbstractType2(config, type); [EOL]         if (next == null) { [EOL]             return type; [EOL]         } [EOL]         Class<?> prevCls = type.getRawClass(); [EOL]         Class<?> nextCls = next.getRawClass(); [EOL]         if ((prevCls == nextCls) || !prevCls.isAssignableFrom(nextCls)) { [EOL]             throw new IllegalArgumentException("Invalid abstract type resolution from " + type + " to " + next + ": latter is not a subtype of former"); [EOL]         } [EOL]         type = next; [EOL]     } [EOL] } <line_num>: 186,207
private JavaType _mapAbstractType2(DeserializationConfig config, JavaType type) throws JsonMappingException { [EOL]     Class<?> currClass = type.getRawClass(); [EOL]     if (_factoryConfig.hasAbstractTypeResolvers()) { [EOL]         for (AbstractTypeResolver resolver : _factoryConfig.abstractTypeResolvers()) { [EOL]             JavaType concrete = resolver.findTypeMapping(config, type); [EOL]             if (concrete != null && concrete.getRawClass() != currClass) { [EOL]                 return concrete; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 213,226
@Override [EOL] public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     ValueInstantiator instantiator = null; [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac); [EOL]     if (instDef != null) { [EOL]         instantiator = _valueInstantiatorInstance(config, ac, instDef); [EOL]     } [EOL]     if (instantiator == null) { [EOL]         instantiator = _findStdValueInstantiator(config, beanDesc); [EOL]         if (instantiator == null) { [EOL]             instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasValueInstantiators()) { [EOL]         for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) { [EOL]             instantiator = insts.findValueInstantiator(config, beanDesc, instantiator); [EOL]             if (instantiator == null) { [EOL]                 throw new JsonMappingException("Broken registered ValueInstantiators (of type " + insts.getClass().getName() + "): returned null ValueInstantiator"); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (instantiator.getIncompleteParameter() != null) { [EOL]         final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter(); [EOL]         final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner(); [EOL]         throw new IllegalArgumentException("Argument #" + nonAnnotatedParam.getIndex() + " of constructor " + ctor + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator"); [EOL]     } [EOL]     return instantiator; [EOL] } <line_num>: 239,283
private ValueInstantiator _findStdValueInstantiator(DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     return JacksonDeserializers.findValueInstantiator(config, beanDesc); [EOL] } <line_num>: 285,290
protected ValueInstantiator _constructDefaultValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException { [EOL]     boolean fixAccess = ctxt.canOverrideAccessModifiers(); [EOL]     CreatorCollector creators = new CreatorCollector(beanDesc, fixAccess); [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     VisibilityChecker<?> vchecker = config.getDefaultVisibilityChecker(); [EOL]     vchecker = intr.findAutoDetectVisibility(beanDesc.getClassInfo(), vchecker); [EOL]     _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators); [EOL]     if (beanDesc.getType().isConcrete()) { [EOL]         _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators); [EOL]     } [EOL]     return creators.constructValueInstantiator(config); [EOL] } <line_num>: 296,318
public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException { [EOL]     if (instDef == null) { [EOL]         return null; [EOL]     } [EOL]     ValueInstantiator inst; [EOL]     if (instDef instanceof ValueInstantiator) { [EOL]         return (ValueInstantiator) instDef; [EOL]     } [EOL]     if (!(instDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + instDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]     } [EOL]     Class<?> instClass = (Class<?>) instDef; [EOL]     if (instClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!ValueInstantiator.class.isAssignableFrom(instClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + instClass.getName() + "; expected Class<ValueInstantiator>"); [EOL]     } [EOL]     HandlerInstantiator hi = config.getHandlerInstantiator(); [EOL]     if (hi != null) { [EOL]         inst = hi.valueInstantiatorInstance(config, annotated, instClass); [EOL]         if (inst != null) { [EOL]             return inst; [EOL]         } [EOL]     } [EOL]     return (ValueInstantiator) ClassUtil.createInstance(instClass, config.canOverrideAccessModifiers()); [EOL] } <line_num>: 320,355
protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException { [EOL]     AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor(); [EOL]     if (defaultCtor != null) { [EOL]         if (!creators.hasDefaultCreator() || intr.hasCreatorAnnotation(defaultCtor)) { [EOL]             creators.setDefaultCreator(defaultCtor); [EOL]         } [EOL]     } [EOL]     String[] ctorPropNames = null; [EOL]     AnnotatedConstructor propertyCtor = null; [EOL]     for (BeanPropertyDefinition propDef : beanDesc.findProperties()) { [EOL]         if (propDef.getConstructorParameter() != null) { [EOL]             AnnotatedParameter param = propDef.getConstructorParameter(); [EOL]             AnnotatedWithParams owner = param.getOwner(); [EOL]             if (owner instanceof AnnotatedConstructor) { [EOL]                 if (propertyCtor == null) { [EOL]                     propertyCtor = (AnnotatedConstructor) owner; [EOL]                     ctorPropNames = new String[propertyCtor.getParameterCount()]; [EOL]                 } [EOL]                 ctorPropNames[param.getIndex()] = propDef.getName(); [EOL]             } [EOL]         } [EOL]     } [EOL]     for (AnnotatedConstructor ctor : beanDesc.getConstructors()) { [EOL]         int argCount = ctor.getParameterCount(); [EOL]         boolean isCreator = intr.hasCreatorAnnotation(ctor) || ctor == propertyCtor; [EOL]         boolean isVisible = vchecker.isCreatorVisible(ctor); [EOL]         if (argCount == 1) { [EOL]             String name = ctor == propertyCtor ? ctorPropNames[0] : null; [EOL]             _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, isCreator, isVisible, name); [EOL]             continue; [EOL]         } [EOL]         if (!isCreator && !isVisible) { [EOL]             continue; [EOL]         } [EOL]         AnnotatedParameter nonAnnotatedParam = null; [EOL]         int namedCount = 0; [EOL]         int injectCount = 0; [EOL]         CreatorProperty[] properties = new CreatorProperty[argCount]; [EOL]         for (int i = 0; i < argCount; ++i) { [EOL]             AnnotatedParameter param = ctor.getParameter(i); [EOL]             String name = null; [EOL]             if (ctor == propertyCtor) { [EOL]                 name = ctorPropNames[i]; [EOL]             } [EOL]             if (name == null) { [EOL]                 PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]                 name = (pn == null) ? null : pn.getSimpleName(); [EOL]             } [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if (name != null && name.length() > 0) { [EOL]                 ++namedCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (injectId != null) { [EOL]                 ++injectCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (nonAnnotatedParam == null) { [EOL]                 nonAnnotatedParam = param; [EOL]             } [EOL]         } [EOL]         if (isCreator || namedCount > 0 || injectCount > 0) { [EOL]             if ((namedCount + injectCount) == argCount) { [EOL]                 creators.addPropertyCreator(ctor, properties); [EOL]             } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) { [EOL]                 creators.addDelegatingCreator(ctor, properties); [EOL]             } else { [EOL]                 creators.addIncompeteParameter(nonAnnotatedParam); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 357,448
protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedConstructor ctor, boolean isCreator, boolean isVisible, String name) throws JsonMappingException { [EOL]     AnnotatedParameter param = ctor.getParameter(0); [EOL]     if (name == null) { [EOL]         PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]         name = (pn == null) ? null : pn.getSimpleName(); [EOL]     } [EOL]     Object injectId = intr.findInjectableValueId(param); [EOL]     if ((injectId != null) || (name != null && name.length() > 0)) { [EOL]         CreatorProperty[] properties = new CreatorProperty[1]; [EOL]         properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, param, injectId); [EOL]         creators.addPropertyCreator(ctor, properties); [EOL]         return true; [EOL]     } [EOL]     Class<?> type = ctor.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addStringCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addIntCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addLongCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || isVisible) { [EOL]             creators.addDoubleCreator(ctor); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (isCreator) { [EOL]         creators.addDelegatingCreator(ctor, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 450,505
protected void _addDeserializerFactoryMethods(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]         boolean isCreator = intr.hasCreatorAnnotation(factory); [EOL]         int argCount = factory.getParameterCount(); [EOL]         if (argCount == 0) { [EOL]             if (isCreator) { [EOL]                 creators.setDefaultCreator(factory); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (argCount == 1) { [EOL]             AnnotatedParameter param = factory.getParameter(0); [EOL]             PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if ((injectId == null) && (name == null || name.length() == 0)) { [EOL]                 _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators, factory, isCreator); [EOL]                 continue; [EOL]             } [EOL]         } else { [EOL]             if (!intr.hasCreatorAnnotation(factory)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         AnnotatedParameter nonAnnotatedParam = null; [EOL]         CreatorProperty[] properties = new CreatorProperty[argCount]; [EOL]         int namedCount = 0; [EOL]         int injectCount = 0; [EOL]         for (int i = 0; i < argCount; ++i) { [EOL]             AnnotatedParameter param = factory.getParameter(i); [EOL]             PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             Object injectId = intr.findInjectableValueId(param); [EOL]             if (name != null && name.length() > 0) { [EOL]                 ++namedCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (injectId != null) { [EOL]                 ++injectCount; [EOL]                 properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); [EOL]             } else if (nonAnnotatedParam == null) { [EOL]                 nonAnnotatedParam = param; [EOL]             } [EOL]         } [EOL]         if (isCreator || namedCount > 0 || injectCount > 0) { [EOL]             if ((namedCount + injectCount) == argCount) { [EOL]                 creators.addPropertyCreator(factory, properties); [EOL]             } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) { [EOL]                 creators.addDelegatingCreator(factory, properties); [EOL]             } else { [EOL]                 throw new IllegalArgumentException("Argument #" + nonAnnotatedParam.getIndex() + " of factory method " + factory + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator"); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 507,578
protected boolean _handleSingleArgumentFactory(DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, AnnotatedMethod factory, boolean isCreator) throws JsonMappingException { [EOL]     Class<?> type = factory.getRawParameterType(0); [EOL]     if (type == String.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addStringCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == int.class || type == Integer.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addIntCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == long.class || type == Long.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addLongCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == double.class || type == Double.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addDoubleCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (type == boolean.class || type == Boolean.class) { [EOL]         if (isCreator || vchecker.isCreatorVisible(factory)) { [EOL]             creators.addBooleanCreator(factory); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     if (intr.hasCreatorAnnotation(factory)) { [EOL]         creators.addDelegatingCreator(factory, null); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 580,623
protected CreatorProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, String name, int index, AnnotatedParameter param, Object injectableValueId) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Boolean b = (intr == null) ? null : intr.hasRequiredMarker(param); [EOL]     boolean req = (b == null) ? false : b.booleanValue(); [EOL]     JavaType t0 = config.getTypeFactory().constructType(param.getParameterType(), beanDesc.bindingsForBeanType()); [EOL]     BeanProperty.Std property = new BeanProperty.Std(name, t0, intr.findWrapperName(param), beanDesc.getClassAnnotations(), param, req); [EOL]     JavaType type = resolveType(ctxt, beanDesc, t0, param); [EOL]     if (type != t0) { [EOL]         property = property.withType(type); [EOL]     } [EOL]     JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, param); [EOL]     type = modifyTypeByAnnotation(ctxt, param, type); [EOL]     TypeDeserializer typeDeser = (TypeDeserializer) type.getTypeHandler(); [EOL]     if (typeDeser == null) { [EOL]         typeDeser = findTypeDeserializer(config, type); [EOL]     } [EOL]     CreatorProperty prop = new CreatorProperty(name, type, property.getWrapperName(), typeDeser, beanDesc.getClassAnnotations(), param, index, injectableValueId, property.isRequired()); [EOL]     if (deser != null) { [EOL]         prop = prop.withValueDeserializer(deser); [EOL]     } [EOL]     return prop; [EOL] } <line_num>: 630,669
@Override [EOL] public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     JavaType elemType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = elemType.getValueHandler(); [EOL]     TypeDeserializer elemTypeDeser = elemType.getTypeHandler(); [EOL]     if (elemTypeDeser == null) { [EOL]         elemTypeDeser = findTypeDeserializer(config, elemType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomArrayDeserializer(type, config, beanDesc, elemTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         if (contentDeser == null) { [EOL]             Class<?> raw = elemType.getRawClass(); [EOL]             if (elemType.isPrimitive()) { [EOL]                 return PrimitiveArrayDeserializers.forType(raw); [EOL]             } else if (raw == String.class) { [EOL]                 return StringArrayDeserializer.instance; [EOL]             } [EOL]         } [EOL]         if (deser == null) { [EOL]             deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] } <line_num>: 677,716
protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException { [EOL]     for (Deserializers d : _factoryConfig.deserializers()) { [EOL]         JsonDeserializer<?> deser = d.findArrayDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 718,731
@Override [EOL] public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt, CollectionType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType contentType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = contentType.getValueHandler(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomCollectionDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         Class<?> collectionClass = type.getRawClass(); [EOL]         if (contentDeser == null) { [EOL]             if (EnumSet.class.isAssignableFrom(collectionClass)) { [EOL]                 deser = new EnumSetDeserializer(contentType, null); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isInterface() || type.isAbstract()) { [EOL]             CollectionType implType = _mapAbstractCollectionType(type, config); [EOL]             if (implType == null) { [EOL]                 throw new IllegalArgumentException("Can not find a deserializer for non-concrete Collection type " + type); [EOL]             } [EOL]             type = implType; [EOL]             beanDesc = config.introspectForCreation(type); [EOL]         } [EOL]         ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc); [EOL]         if (!inst.canCreateUsingDefault()) { [EOL]             if (type.getRawClass() == ArrayBlockingQueue.class) { [EOL]                 return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null); [EOL]             } [EOL]         } [EOL]         if (contentType.getRawClass() == String.class) { [EOL]             deser = new StringCollectionDeserializer(type, contentDeser, inst); [EOL]         } else { [EOL]             deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyCollectionDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] } <line_num>: 739,810
protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config) { [EOL]     Class<?> collectionClass = type.getRawClass(); [EOL]     collectionClass = _collectionFallbacks.get(collectionClass.getName()); [EOL]     if (collectionClass == null) { [EOL]         return null; [EOL]     } [EOL]     return (CollectionType) config.constructSpecializedType(type, collectionClass); [EOL] } <line_num>: 812,820
protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException { [EOL]     for (Deserializers d : _factoryConfig.deserializers()) { [EOL]         JsonDeserializer<?> deser = d.findCollectionDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 822,835
@Override [EOL] public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt, CollectionLikeType type, final BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType contentType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = contentType.getValueHandler(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomCollectionLikeDeserializer(type, config, beanDesc, contentTypeDeser, contentDeser); [EOL]     if (deser != null) { [EOL]         if (_factoryConfig.hasDeserializerModifiers()) { [EOL]             for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]                 deser = mod.modifyCollectionLikeDeserializer(config, type, beanDesc, deser); [EOL]             } [EOL]         } [EOL]     } [EOL]     return deser; [EOL] } <line_num>: 838,865
protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException { [EOL]     for (Deserializers d : _factoryConfig.deserializers()) { [EOL]         JsonDeserializer<?> deser = d.findCollectionLikeDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 867,880
@Override [EOL] public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt, MapType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     JavaType keyType = type.getKeyType(); [EOL]     JavaType contentType = type.getContentType(); [EOL]     @SuppressWarnings("unchecked") [EOL]     JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler(); [EOL]     KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomMapDeserializer(type, config, beanDesc, keyDes, contentTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         Class<?> mapClass = type.getRawClass(); [EOL]         if (EnumMap.class.isAssignableFrom(mapClass)) { [EOL]             Class<?> kt = keyType.getRawClass(); [EOL]             if (kt == null || !kt.isEnum()) { [EOL]                 throw new IllegalArgumentException("Can not construct EnumMap; generic (key) type not available"); [EOL]             } [EOL]             deser = new EnumMapDeserializer(type, null, contentDeser, contentTypeDeser); [EOL]         } [EOL]         if (deser == null) { [EOL]             if (type.isInterface() || type.isAbstract()) { [EOL]                 @SuppressWarnings("rawtypes") [EOL]                 Class<? extends Map> fallback = _mapFallbacks.get(mapClass.getName()); [EOL]                 if (fallback == null) { [EOL]                     throw new IllegalArgumentException("Can not find a deserializer for non-concrete Map type " + type); [EOL]                 } [EOL]                 mapClass = fallback; [EOL]                 type = (MapType) config.constructSpecializedType(type, mapClass); [EOL]                 beanDesc = config.introspectForCreation(type); [EOL]             } [EOL]             ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc); [EOL]             MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser); [EOL]             md.setIgnorableProperties(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo())); [EOL]             deser = md; [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyMapDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] } <line_num>: 888,961
@Override [EOL] public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt, MapLikeType type, final BeanDescription beanDesc) throws JsonMappingException { [EOL]     JavaType keyType = type.getKeyType(); [EOL]     JavaType contentType = type.getContentType(); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     @SuppressWarnings("unchecked") [EOL]     JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler(); [EOL]     KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler(); [EOL]     TypeDeserializer contentTypeDeser = contentType.getTypeHandler(); [EOL]     if (contentTypeDeser == null) { [EOL]         contentTypeDeser = findTypeDeserializer(config, contentType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomMapLikeDeserializer(type, config, beanDesc, keyDes, contentTypeDeser, contentDeser); [EOL]     if (deser != null) { [EOL]         if (_factoryConfig.hasDeserializerModifiers()) { [EOL]             for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]                 deser = mod.modifyMapLikeDeserializer(config, type, beanDesc, deser); [EOL]             } [EOL]         } [EOL]     } [EOL]     return deser; [EOL] } <line_num>: 964,1001
protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException { [EOL]     for (Deserializers d : _factoryConfig.deserializers()) { [EOL]         JsonDeserializer<?> deser = d.findMapDeserializer(type, config, beanDesc, keyDeserializer, elementTypeDeserializer, elementDeserializer); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 1003,1017
protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type, DeserializationConfig config, BeanDescription beanDesc, KeyDeserializer keyDeserializer, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException { [EOL]     for (Deserializers d : _factoryConfig.deserializers()) { [EOL]         JsonDeserializer<?> deser = d.findMapLikeDeserializer(type, config, beanDesc, keyDeserializer, elementTypeDeserializer, elementDeserializer); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 1019,1033
@Override [EOL] public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     final Class<?> enumClass = type.getRawClass(); [EOL]     JsonDeserializer<?> deser = _findCustomEnumDeserializer(enumClass, config, beanDesc); [EOL]     if (deser == null) { [EOL]         for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]             if (ctxt.getAnnotationIntrospector().hasCreatorAnnotation(factory)) { [EOL]                 int argCount = factory.getParameterCount(); [EOL]                 if (argCount == 1) { [EOL]                     Class<?> returnType = factory.getRawReturnType(); [EOL]                     if (returnType.isAssignableFrom(enumClass)) { [EOL]                         deser = EnumDeserializer.deserializerForCreator(config, enumClass, factory); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 throw new IllegalArgumentException("Unsuitable method (" + factory + ") decorated with @JsonCreator (for Enum type " + enumClass.getName() + ")"); [EOL]             } [EOL]         } [EOL]         if (deser == null) { [EOL]             deser = new EnumDeserializer(constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod())); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyEnumDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] } <line_num>: 1044,1083
protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     for (Deserializers d : _factoryConfig.deserializers()) { [EOL]         JsonDeserializer<?> deser = d.findEnumDeserializer(type, config, beanDesc); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 1085,1096
@Override [EOL] public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, JavaType nodeType, BeanDescription beanDesc) throws JsonMappingException { [EOL]     @SuppressWarnings("unchecked") [EOL]     Class<? extends JsonNode> nodeClass = (Class<? extends JsonNode>) nodeType.getRawClass(); [EOL]     JsonDeserializer<?> custom = _findCustomTreeNodeDeserializer(nodeClass, config, beanDesc); [EOL]     if (custom != null) { [EOL]         return custom; [EOL]     } [EOL]     return JsonNodeDeserializer.getDeserializer(nodeClass); [EOL] } <line_num>: 1104,1118
protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     for (Deserializers d : _factoryConfig.deserializers()) { [EOL]         JsonDeserializer<?> deser = d.findTreeNodeDeserializer(type, config, beanDesc); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 1120,1131
@Override [EOL] public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException { [EOL]     Class<?> cls = baseType.getRawClass(); [EOL]     BeanDescription bean = config.introspectClassAnnotations(cls); [EOL]     AnnotatedClass ac = bean.getClassInfo(); [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); [EOL]     Collection<NamedType> subtypes = null; [EOL]     if (b == null) { [EOL]         b = config.getDefaultTyper(baseType); [EOL]         if (b == null) { [EOL]             return null; [EOL]         } [EOL]     } else { [EOL]         subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(ac, config, ai); [EOL]     } [EOL]     if ((b.getDefaultImpl() == null) && baseType.isAbstract()) { [EOL]         JavaType defaultType = mapAbstractType(config, baseType); [EOL]         if (defaultType != null && defaultType.getRawClass() != baseType.getRawClass()) { [EOL]             b = b.defaultImpl(defaultType.getRawClass()); [EOL]         } [EOL]     } [EOL]     return b.buildTypeDeserializer(config, baseType, subtypes); [EOL] } <line_num>: 1139,1171
@Override [EOL] public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     KeyDeserializer deser = null; [EOL]     if (_factoryConfig.hasKeyDeserializers()) { [EOL]         BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass()); [EOL]         for (KeyDeserializers d : _factoryConfig.keyDeserializers()) { [EOL]             deser = d.findKeyDeserializer(type, config, beanDesc); [EOL]             if (deser != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isEnumType()) { [EOL]             return _createEnumKeyDeserializer(ctxt, type); [EOL]         } [EOL]         deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type); [EOL]     } [EOL]     if (deser != null) { [EOL]         if (_factoryConfig.hasDeserializerModifiers()) { [EOL]             for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]                 deser = mod.modifyKeyDeserializer(config, type, deser); [EOL]             } [EOL]         } [EOL]     } [EOL]     return deser; [EOL] } <line_num>: 1179,1212
private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<?> des = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (des != null) { [EOL]         return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des); [EOL]     } [EOL]     Class<?> enumClass = type.getRawClass(); [EOL]     JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc); [EOL]     if (custom != null) { [EOL]         return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des); [EOL]     } [EOL]     EnumResolver<?> enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod()); [EOL]     for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]         if (config.getAnnotationIntrospector().hasCreatorAnnotation(factory)) { [EOL]             int argCount = factory.getParameterCount(); [EOL]             if (argCount == 1) { [EOL]                 Class<?> returnType = factory.getRawReturnType(); [EOL]                 if (returnType.isAssignableFrom(enumClass)) { [EOL]                     if (factory.getGenericParameterType(0) != String.class) { [EOL]                         throw new IllegalArgumentException("Parameter #0 type for factory method (" + factory + ") not suitable, must be java.lang.String"); [EOL]                     } [EOL]                     if (config.canOverrideAccessModifiers()) { [EOL]                         ClassUtil.checkAndFixAccess(factory.getMember()); [EOL]                     } [EOL]                     return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory); [EOL]                 } [EOL]             } [EOL]             throw new IllegalArgumentException("Unsuitable method (" + factory + ") decorated with @JsonCreator (for Enum type " + enumClass.getName() + ")"); [EOL]         } [EOL]     } [EOL]     return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes); [EOL] } <line_num>: 1214,1256
public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType, AnnotatedMember annotated) throws JsonMappingException { [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, annotated, baseType); [EOL]     if (b == null) { [EOL]         return findTypeDeserializer(config, baseType); [EOL]     } [EOL]     Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(annotated, config, ai, baseType); [EOL]     return b.buildTypeDeserializer(config, baseType, subtypes); [EOL] } <line_num>: 1277,1291
public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType, AnnotatedMember propertyEntity) throws JsonMappingException { [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, propertyEntity, containerType); [EOL]     JavaType contentType = containerType.getContentType(); [EOL]     if (b == null) { [EOL]         return findTypeDeserializer(config, contentType); [EOL]     } [EOL]     Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(propertyEntity, config, ai, contentType); [EOL]     return b.buildTypeDeserializer(config, contentType, subtypes); [EOL] } <line_num>: 1304,1319
public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> rawType = type.getRawClass(); [EOL]     String clsName = rawType.getName(); [EOL]     if (rawType.isPrimitive() || clsName.startsWith("java.")) { [EOL]         if (rawType == CLASS_OBJECT) { [EOL]             return UntypedObjectDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) { [EOL]             return StringDeserializer.instance; [EOL]         } [EOL]         if (rawType == CLASS_ITERABLE) { [EOL]             TypeFactory tf = ctxt.getTypeFactory(); [EOL]             JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(0) : TypeFactory.unknownType(); [EOL]             CollectionType ct = tf.constructCollectionType(Collection.class, elemType); [EOL]             return createCollectionDeserializer(ctxt, ct, beanDesc); [EOL]         } [EOL]         JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName); [EOL]         if (deser == null) { [EOL]             deser = DateDeserializers.find(rawType, clsName); [EOL]             if (deser == null) { [EOL]                 deser = JdkDeserializers.find(rawType, clsName); [EOL]             } [EOL]         } [EOL]         return deser; [EOL]     } [EOL]     if (clsName.startsWith("com.fasterxml.")) { [EOL]         return JacksonDeserializers.find(rawType); [EOL]     } [EOL]     return null; [EOL] } <line_num>: 1328,1365
protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt, Annotated ann) throws JsonMappingException { [EOL]     Object deserDef = ctxt.getAnnotationIntrospector().findDeserializer(ann); [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     return ctxt.deserializerInstance(ann, deserDef); [EOL] } <line_num>: 1379,1388
@SuppressWarnings({ "unchecked" }) [EOL] protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = (T) type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = (T) ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]             if (kd != null) { [EOL]                 type = (T) ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = (T) type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef); [EOL]             if (cd != null) { [EOL]                 type = (T) type.withContentValueHandler(cd); [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] } <line_num>: 1406,1470
protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException { [EOL]     if (type.isContainerType()) { [EOL]         AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null) { [EOL]             Object kdDef = intr.findKeyDeserializer(member); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(member, kdDef); [EOL]             if (kd != null) { [EOL]                 type = ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Object cdDef = intr.findContentDeserializer(member); [EOL]         JsonDeserializer<?> cd = ctxt.deserializerInstance(member, cdDef); [EOL]         if (cd != null) { [EOL]             type = type.withContentValueHandler(cd); [EOL]         } [EOL]         if (member instanceof AnnotatedMember) { [EOL]             TypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(ctxt.getConfig(), type, (AnnotatedMember) member); [EOL]             if (contentTypeDeser != null) { [EOL]                 type = type.withContentTypeHandler(contentTypeDeser); [EOL]             } [EOL]         } [EOL]     } [EOL]     TypeDeserializer valueTypeDeser; [EOL]     if (member instanceof AnnotatedMember) { [EOL]         valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(), type, (AnnotatedMember) member); [EOL]     } else { [EOL]         valueTypeDeser = findTypeDeserializer(ctxt.getConfig(), type); [EOL]     } [EOL]     if (valueTypeDeser != null) { [EOL]         type = type.withTypeHandler(valueTypeDeser); [EOL]     } [EOL]     return type; [EOL] } <line_num>: 1479,1527
protected EnumResolver<?> constructEnumResolver(Class<?> enumClass, DeserializationConfig config, AnnotatedMethod jsonValueMethod) { [EOL]     if (jsonValueMethod != null) { [EOL]         Method accessor = jsonValueMethod.getAnnotated(); [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             ClassUtil.checkAndFixAccess(accessor); [EOL]         } [EOL]         return EnumResolver.constructUnsafeUsingMethod(enumClass, accessor); [EOL]     } [EOL]     if (config.isEnabled(DeserializationFeature.READ_ENUMS_USING_TO_STRING)) { [EOL]         return EnumResolver.constructUnsafeUsingToString(enumClass); [EOL]     } [EOL]     return EnumResolver.constructUnsafe(enumClass, config.getAnnotationIntrospector()); [EOL] } <line_num>: 1529,1544
protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType) { [EOL]     if (enumType == null) { [EOL]         return null; [EOL]     } [EOL]     BeanDescription beanDesc = config.introspect(enumType); [EOL]     return beanDesc.findJsonValueMethod(); [EOL] } <line_num>: 1546,1553
