public UUIDDeserializer() { [EOL]     super(UUID.class); [EOL] } <line_num>: 138,138
public URLDeserializer() { [EOL]     super(URL.class); [EOL] } <line_num>: 172,172
public URIDeserializer() { [EOL]     super(URI.class); [EOL] } <line_num>: 187,187
public CurrencyDeserializer() { [EOL]     super(Currency.class); [EOL] } <line_num>: 202,202
public PatternDeserializer() { [EOL]     super(Pattern.class); [EOL] } <line_num>: 218,218
public LocaleDeserializer() { [EOL]     super(Locale.class); [EOL] } <line_num>: 237,237
public InetAddressDeserializer() { [EOL]     super(InetAddress.class); [EOL] } <line_num>: 266,266
public CharsetDeserializer() { [EOL]     super(Charset.class); [EOL] } <line_num>: 282,282
public FileDeserializer() { [EOL]     super(File.class); [EOL] } <line_num>: 297,297
public AtomicReferenceDeserializer(JavaType referencedType) { [EOL]     this(referencedType, null); [EOL] } <line_num>: 326,328
public AtomicReferenceDeserializer(JavaType referencedType, JsonDeserializer<?> deser) { [EOL]     super(AtomicReference.class); [EOL]     _referencedType = referencedType; [EOL]     _valueDeserializer = deser; [EOL] } <line_num>: 330,336
public AtomicBooleanDeserializer() { [EOL]     super(AtomicBoolean.class); [EOL] } <line_num>: 363,363
public StackTraceElementDeserializer() { [EOL]     super(StackTraceElement.class); [EOL] } <line_num>: 385,385
@Deprecated [EOL] public static StdDeserializer<?>[] all() { [EOL]     return new StdDeserializer[] { UUIDDeserializer.instance, URLDeserializer.instance, URIDeserializer.instance, FileDeserializer.instance, CurrencyDeserializer.instance, PatternDeserializer.instance, LocaleDeserializer.instance, InetAddressDeserializer.instance, CharsetDeserializer.instance, AtomicBooleanDeserializer.instance, ClassDeserializer.instance, StackTraceElementDeserializer.instance }; [EOL] } <line_num>: 52,74
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] } <line_num>: 76,125
@Override [EOL] protected UUID _deserialize(String value, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return UUID.fromString(value); [EOL] } <line_num>: 140,145
@Override [EOL] protected UUID _deserializeEmbedded(Object ob, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (ob instanceof byte[]) { [EOL]         byte[] bytes = (byte[]) ob; [EOL]         if (bytes.length != 16) { [EOL]             ctxt.mappingException("Can only construct UUIDs from 16 byte arrays; got " + bytes.length + " bytes"); [EOL]         } [EOL]         DataInputStream in = new DataInputStream(new ByteArrayInputStream(bytes)); [EOL]         long l1 = in.readLong(); [EOL]         long l2 = in.readLong(); [EOL]         return new UUID(l1, l2); [EOL]     } [EOL]     super._deserializeEmbedded(ob, ctxt); [EOL]     return null; [EOL] } <line_num>: 147,164
@Override [EOL] protected URL _deserialize(String value, DeserializationContext ctxt) throws IOException { [EOL]     return new URL(value); [EOL] } <line_num>: 174,179
@Override [EOL] protected URI _deserialize(String value, DeserializationContext ctxt) throws IllegalArgumentException { [EOL]     return URI.create(value); [EOL] } <line_num>: 189,194
@Override [EOL] protected Currency _deserialize(String value, DeserializationContext ctxt) throws IllegalArgumentException { [EOL]     return Currency.getInstance(value); [EOL] } <line_num>: 204,210
@Override [EOL] protected Pattern _deserialize(String value, DeserializationContext ctxt) throws IllegalArgumentException { [EOL]     return Pattern.compile(value); [EOL] } <line_num>: 220,226
@Override [EOL] protected Locale _deserialize(String value, DeserializationContext ctxt) throws IOException { [EOL]     int ix = value.indexOf('_'); [EOL]     if (ix < 0) { [EOL]         return new Locale(value); [EOL]     } [EOL]     String first = value.substring(0, ix); [EOL]     value = value.substring(ix + 1); [EOL]     ix = value.indexOf('_'); [EOL]     if (ix < 0) { [EOL]         return new Locale(first, value); [EOL]     } [EOL]     String second = value.substring(0, ix); [EOL]     return new Locale(first, second, value.substring(ix + 1)); [EOL] } <line_num>: 239,255
@Override [EOL] protected InetAddress _deserialize(String value, DeserializationContext ctxt) throws IOException { [EOL]     return InetAddress.getByName(value); [EOL] } <line_num>: 268,273
@Override [EOL] protected Charset _deserialize(String value, DeserializationContext ctxt) throws IOException { [EOL]     return Charset.forName(value); [EOL] } <line_num>: 284,289
@Override [EOL] protected File _deserialize(String value, DeserializationContext ctxt) { [EOL]     return new File(value); [EOL] } <line_num>: 299,303
@Override [EOL] public AtomicReference<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return new AtomicReference<Object>(_valueDeserializer.deserialize(jp, ctxt)); [EOL] } <line_num>: 338,343
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> deser = _valueDeserializer; [EOL]     if (deser != null) { [EOL]         return this; [EOL]     } [EOL]     return new AtomicReferenceDeserializer(_referencedType, ctxt.findContextualValueDeserializer(_referencedType, property)); [EOL] } <line_num>: 345,355
@Override [EOL] public AtomicBoolean deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return new AtomicBoolean(_parseBooleanPrimitive(jp, ctxt)); [EOL] } <line_num>: 365,371
@Override [EOL] public StackTraceElement deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         String className = "", methodName = "", fileName = ""; [EOL]         int lineNumber = -1; [EOL]         while ((t = jp.nextValue()) != JsonToken.END_OBJECT) { [EOL]             String propName = jp.getCurrentName(); [EOL]             if ("className".equals(propName)) { [EOL]                 className = jp.getText(); [EOL]             } else if ("fileName".equals(propName)) { [EOL]                 fileName = jp.getText(); [EOL]             } else if ("lineNumber".equals(propName)) { [EOL]                 if (t.isNumeric()) { [EOL]                     lineNumber = jp.getIntValue(); [EOL]                 } else { [EOL]                     throw JsonMappingException.from(jp, "Non-numeric token (" + t + ") for property 'lineNumber'"); [EOL]                 } [EOL]             } else if ("methodName".equals(propName)) { [EOL]                 methodName = jp.getText(); [EOL]             } else if ("nativeMethod".equals(propName)) { [EOL]             } else { [EOL]                 handleUnknownProperty(jp, ctxt, _valueClass, propName); [EOL]             } [EOL]         } [EOL]         return new StackTraceElement(className, methodName, fileName, lineNumber); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] } <line_num>: 387,420
