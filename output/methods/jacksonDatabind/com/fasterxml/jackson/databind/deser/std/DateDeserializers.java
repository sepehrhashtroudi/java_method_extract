protected DateBasedDeserializer(Class<?> clz) { [EOL]     super(clz); [EOL]     _customFormat = null; [EOL]     _formatString = null; [EOL] } <line_num>: 112,116
protected DateBasedDeserializer(DateBasedDeserializer<T> base, DateFormat format, String formatStr) { [EOL]     super(base._valueClass); [EOL]     _customFormat = format; [EOL]     _formatString = formatStr; [EOL] } <line_num>: 118,123
public CalendarDeserializer() { [EOL]     super(Calendar.class); [EOL]     _calendarClass = null; [EOL] } <line_num>: 208,211
public CalendarDeserializer(Class<? extends Calendar> cc) { [EOL]     super(cc); [EOL]     _calendarClass = cc; [EOL] } <line_num>: 213,216
public CalendarDeserializer(CalendarDeserializer src, DateFormat df, String formatString) { [EOL]     super(src, df, formatString); [EOL]     _calendarClass = src._calendarClass; [EOL] } <line_num>: 218,221
public DateDeserializer() { [EOL]     super(Date.class); [EOL] } <line_num>: 265,265
public DateDeserializer(DateDeserializer base, DateFormat df, String formatString) { [EOL]     super(base, df, formatString); [EOL] } <line_num>: 266,268
public SqlDateDeserializer() { [EOL]     super(java.sql.Date.class); [EOL] } <line_num>: 292,292
public SqlDateDeserializer(SqlDateDeserializer src, DateFormat df, String formatString) { [EOL]     super(src, df, formatString); [EOL] } <line_num>: 293,295
public TimestampDeserializer() { [EOL]     super(Timestamp.class); [EOL] } <line_num>: 323,323
public TimestampDeserializer(TimestampDeserializer src, DateFormat df, String formatString) { [EOL]     super(src, df, formatString); [EOL] } <line_num>: 324,326
public TimeZoneDeserializer() { [EOL]     super(TimeZone.class); [EOL] } <line_num>: 355,355
@Deprecated [EOL] public static StdDeserializer<?>[] all() { [EOL]     return new StdDeserializer[] { CalendarDeserializer.instance, DateDeserializer.instance, CalendarDeserializer.gregorianInstance, SqlDateDeserializer.instance, TimestampDeserializer.instance, TimeZoneDeserializer.instance }; [EOL] } <line_num>: 47,61
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] } <line_num>: 63,89
protected abstract DateBasedDeserializer<T> withDateFormat(DateFormat df, String formatStr); <line_num>: 125,125
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = ctxt.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             TimeZone tz = format.getTimeZone(); [EOL]             String pattern = format.getPattern(); [EOL]             if (pattern.length() > 0) { [EOL]                 Locale loc = format.getLocale(); [EOL]                 if (loc == null) { [EOL]                     loc = ctxt.getLocale(); [EOL]                 } [EOL]                 SimpleDateFormat df = new SimpleDateFormat(pattern, loc); [EOL]                 if (tz == null) { [EOL]                     tz = ctxt.getTimeZone(); [EOL]                 } [EOL]                 df.setTimeZone(tz); [EOL]                 return withDateFormat(df, pattern); [EOL]             } [EOL]             if (tz != null) { [EOL]                 DateFormat df = ctxt.getConfig().getDateFormat(); [EOL]                 if (df.getClass() == StdDateFormat.class) { [EOL]                     df = ((StdDateFormat) df).withTimeZone(tz); [EOL]                 } else { [EOL]                     df = (DateFormat) df.clone(); [EOL]                     df.setTimeZone(tz); [EOL]                 } [EOL]                 return withDateFormat(df, pattern); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] } <line_num>: 127,165
@Override [EOL] protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_customFormat != null && jp.getCurrentToken() == JsonToken.VALUE_STRING) { [EOL]         String str = jp.getText().trim(); [EOL]         if (str.length() == 0) { [EOL]             return (Date) getEmptyValue(); [EOL]         } [EOL]         synchronized (_customFormat) { [EOL]             try { [EOL]                 return _customFormat.parse(str); [EOL]             } catch (ParseException e) { [EOL]                 throw new IllegalArgumentException("Failed to parse Date value '" + str + "' (format: \"" + _formatString + "\"): " + e.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]     return super._parseDate(jp, ctxt); [EOL] } <line_num>: 167,186
@Override [EOL] protected CalendarDeserializer withDateFormat(DateFormat df, String formatString) { [EOL]     return new CalendarDeserializer(this, df, formatString); [EOL] } <line_num>: 223,226
@Override [EOL] public Calendar deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Date d = _parseDate(jp, ctxt); [EOL]     if (d == null) { [EOL]         return null; [EOL]     } [EOL]     if (_calendarClass == null) { [EOL]         return ctxt.constructCalendar(d); [EOL]     } [EOL]     try { [EOL]         Calendar c = _calendarClass.newInstance(); [EOL]         c.setTimeInMillis(d.getTime()); [EOL]         TimeZone tz = ctxt.getTimeZone(); [EOL]         if (tz != null) { [EOL]             c.setTimeZone(tz); [EOL]         } [EOL]         return c; [EOL]     } catch (Exception e) { [EOL]         throw ctxt.instantiationException(_calendarClass, e); [EOL]     } [EOL] } <line_num>: 228,250
@Override [EOL] protected DateDeserializer withDateFormat(DateFormat df, String formatString) { [EOL]     return new DateDeserializer(this, df, formatString); [EOL] } <line_num>: 270,273
@Override [EOL] public java.util.Date deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _parseDate(jp, ctxt); [EOL] } <line_num>: 275,280
@Override [EOL] protected SqlDateDeserializer withDateFormat(DateFormat df, String formatString) { [EOL]     return new SqlDateDeserializer(this, df, formatString); [EOL] } <line_num>: 297,300
@Override [EOL] public java.sql.Date deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Date d = _parseDate(jp, ctxt); [EOL]     return (d == null) ? null : new java.sql.Date(d.getTime()); [EOL] } <line_num>: 302,308
@Override [EOL] protected TimestampDeserializer withDateFormat(DateFormat df, String formatString) { [EOL]     return new TimestampDeserializer(this, df, formatString); [EOL] } <line_num>: 328,331
@Override [EOL] public java.sql.Timestamp deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return new Timestamp(_parseDate(jp, ctxt).getTime()); [EOL] } <line_num>: 333,338
@Override [EOL] protected TimeZone _deserialize(String value, DeserializationContext ctxt) throws IOException { [EOL]     return TimeZone.getTimeZone(value); [EOL] } <line_num>: 357,362
