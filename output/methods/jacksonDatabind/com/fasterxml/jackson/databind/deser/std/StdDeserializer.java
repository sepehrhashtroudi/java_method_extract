protected StdDeserializer(Class<?> vc) { [EOL]     _valueClass = vc; [EOL] } <line_num>: 34,36
protected StdDeserializer(JavaType valueType) { [EOL]     _valueClass = (valueType == null) ? null : valueType.getRawClass(); [EOL] } <line_num>: 38,40
public Class<?> getValueClass() { [EOL]     return _valueClass; [EOL] } <line_num>: 48,48
public JavaType getValueType() { [EOL]     return null; [EOL] } <line_num>: 55,55
protected boolean isDefaultDeserializer(JsonDeserializer<?> deserializer) { [EOL]     return (deserializer != null && deserializer.getClass().getAnnotation(JacksonStdImpl.class) != null); [EOL] } <line_num>: 63,65
protected boolean isDefaultKeyDeserializer(KeyDeserializer keyDeser) { [EOL]     return (keyDeser != null && keyDeser.getClass().getAnnotation(JacksonStdImpl.class) != null); [EOL] } <line_num>: 67,69
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     return typeDeserializer.deserializeTypedFromAny(jp, ctxt); [EOL] } <line_num>: 82,88
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] } <line_num>: 98,132
protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         return Boolean.valueOf(_parseBooleanFromNumber(jp, ctxt)); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Boolean) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]         if ("false".equals(text)) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         if (text.length() == 0) { [EOL]             return (Boolean) getEmptyValue(); [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] } <line_num>: 134,171
protected final boolean _parseBooleanFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getNumberType() == NumberType.LONG) { [EOL]         return (jp.getLongValue() == 0L) ? Boolean.FALSE : Boolean.TRUE; [EOL]     } [EOL]     String str = jp.getText(); [EOL]     if ("0.0".equals(str) || "0".equals(str)) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     return Boolean.TRUE; [EOL] } <line_num>: 173,185
protected Byte _parseByte(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getByteValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Byte) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Byte value"); [EOL]         } [EOL]         if (value < Byte.MIN_VALUE || value > 255) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 8-bit value"); [EOL]         } [EOL]         return Byte.valueOf((byte) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Byte) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] } <line_num>: 187,217
protected Short _parseShort(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getShortValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Short) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Short value"); [EOL]         } [EOL]         if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 16-bit value"); [EOL]         } [EOL]         return Short.valueOf((short) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Short) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] } <line_num>: 219,248
protected final short _parseShortPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     int value = _parseIntPrimitive(jp, ctxt); [EOL]     if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) { [EOL]         throw ctxt.weirdStringException(String.valueOf(value), _valueClass, "overflow, value can not be represented as 16-bit value"); [EOL]     } [EOL]     return (short) value; [EOL] } <line_num>: 250,260
protected final int _parseIntPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getIntValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len > 9) { [EOL]                 long l = Long.parseLong(text); [EOL]                 if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { [EOL]                     throw ctxt.weirdStringException(text, _valueClass, "Overflow: numeric value (" + text + ") out of range of int (" + Integer.MIN_VALUE + " - " + Integer.MAX_VALUE + ")"); [EOL]                 } [EOL]                 return (int) l; [EOL]             } [EOL]             if (len == 0) { [EOL]                 return 0; [EOL]             } [EOL]             return NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid int value"); [EOL]         } [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] } <line_num>: 262,299
protected final Integer _parseInteger(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return Integer.valueOf(jp.getIntValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len > 9) { [EOL]                 long l = Long.parseLong(text); [EOL]                 if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { [EOL]                     throw ctxt.weirdStringException(text, _valueClass, "Overflow: numeric value (" + text + ") out of range of Integer (" + Integer.MIN_VALUE + " - " + Integer.MAX_VALUE + ")"); [EOL]                 } [EOL]                 return Integer.valueOf((int) l); [EOL]             } [EOL]             if (len == 0) { [EOL]                 return (Integer) getEmptyValue(); [EOL]             } [EOL]             return Integer.valueOf(NumberInput.parseInt(text)); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Integer value"); [EOL]         } [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Integer) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] } <line_num>: 301,333
protected final Long _parseLong(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getLongValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Long) getEmptyValue(); [EOL]         } [EOL]         try { [EOL]             return Long.valueOf(NumberInput.parseLong(text)); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Long value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Long) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] } <line_num>: 335,361
protected final long _parseLongPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getLongValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0L; [EOL]         } [EOL]         try { [EOL]             return NumberInput.parseLong(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid long value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0L; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] } <line_num>: 363,384
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] } <line_num>: 386,428
protected final float _parseFloatPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0f; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0f; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] } <line_num>: 430,470
protected final Double _parseDouble(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Double) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Double) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] } <line_num>: 472,512
protected final double _parseDoublePrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] } <line_num>: 514,556
protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         return new java.util.Date(jp.getLongValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (java.util.Date) getNullValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String value = null; [EOL]         try { [EOL]             value = jp.getText().trim(); [EOL]             if (value.length() == 0) { [EOL]                 return (Date) getEmptyValue(); [EOL]             } [EOL]             return ctxt.parseDate(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(value, _valueClass, "not a valid representation (error: " + iae.getMessage() + ")"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] } <line_num>: 558,583
protected final static double parseDouble(String numStr) throws NumberFormatException { [EOL]     if (NumberInput.NASTY_SMALL_DOUBLE.equals(numStr)) { [EOL]         return Double.MIN_VALUE; [EOL]     } [EOL]     return Double.parseDouble(numStr); [EOL] } <line_num>: 589,597
protected final String _parseString(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     String value = jp.getValueAsString(); [EOL]     if (value != null) { [EOL]         return value; [EOL]     } [EOL]     throw ctxt.mappingException(String.class, jp.getCurrentToken()); [EOL] } <line_num>: 605,613
protected JsonDeserializer<Object> findDeserializer(DeserializationContext ctxt, JavaType type, BeanProperty property) throws JsonMappingException { [EOL]     return ctxt.findContextualValueDeserializer(type, property); [EOL] } <line_num>: 630,635
protected JsonDeserializer<?> findConvertingContentDeserializer(DeserializationContext ctxt, BeanProperty prop, JsonDeserializer<?> existingDeserializer) throws JsonMappingException { [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     if (intr != null && prop != null) { [EOL]         Object convDef = intr.findDeserializationContentConverter(prop.getMember()); [EOL]         if (convDef != null) { [EOL]             Converter<Object, Object> conv = ctxt.converterInstance(prop.getMember(), convDef); [EOL]             JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL]             if (existingDeserializer == null) { [EOL]                 existingDeserializer = ctxt.findContextualValueDeserializer(delegateType, prop); [EOL]             } [EOL]             return new StdDelegatingDeserializer<Object>(conv, delegateType, existingDeserializer); [EOL]         } [EOL]     } [EOL]     return existingDeserializer; [EOL] } <line_num>: 653,670
protected void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt, Object instanceOrClass, String propName) throws IOException, JsonProcessingException { [EOL]     if (instanceOrClass == null) { [EOL]         instanceOrClass = getValueClass(); [EOL]     } [EOL]     if (ctxt.handleUnknownProperty(jp, this, instanceOrClass, propName)) { [EOL]         return; [EOL]     } [EOL]     ctxt.reportUnknownProperty(instanceOrClass, propName, this); [EOL]     jp.skipChildren(); [EOL] } <line_num>: 696,714
