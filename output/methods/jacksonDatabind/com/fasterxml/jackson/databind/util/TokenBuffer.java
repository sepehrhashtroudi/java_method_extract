public TokenBuffer(ObjectCodec codec) { [EOL]     _objectCodec = codec; [EOL]     _generatorFeatures = DEFAULT_PARSER_FEATURES; [EOL]     _writeContext = JsonWriteContext.createRootContext(); [EOL]     _first = _last = new Segment(); [EOL]     _appendOffset = 0; [EOL] } <line_num>: 98,106
public Parser(Segment firstSeg, ObjectCodec codec) { [EOL]     super(0); [EOL]     _segment = firstSeg; [EOL]     _segmentPtr = -1; [EOL]     _codec = codec; [EOL]     _parsingContext = JsonReadContext.createRootContext(-1, -1); [EOL] } <line_num>: 863,870
public Segment() { [EOL] } <line_num>: 1250,1250
@Override [EOL] public Version version() { [EOL]     return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; [EOL] } <line_num>: 108,111
public JsonParser asParser() { [EOL]     return asParser(_objectCodec); [EOL] } <line_num>: 123,126
public JsonParser asParser(ObjectCodec codec) { [EOL]     return new Parser(_first, codec); [EOL] } <line_num>: 141,144
public JsonParser asParser(JsonParser src) { [EOL]     Parser p = new Parser(_first, src.getCodec()); [EOL]     p.setLocation(src.getTokenLocation()); [EOL]     return p; [EOL] } <line_num>: 150,155
public JsonToken firstToken() { [EOL]     if (_first != null) { [EOL]         return _first.type(0); [EOL]     } [EOL]     return null; [EOL] } <line_num>: 163,168
public TokenBuffer append(TokenBuffer other) throws IOException, JsonGenerationException { [EOL]     JsonParser jp = other.asParser(); [EOL]     while (jp.nextToken() != null) { [EOL]         this.copyCurrentEvent(jp); [EOL]     } [EOL]     return this; [EOL] } <line_num>: 183,191
public void serialize(JsonGenerator jgen) throws IOException, JsonGenerationException { [EOL]     Segment segment = _first; [EOL]     int ptr = -1; [EOL]     while (true) { [EOL]         if (++ptr >= Segment.TOKENS_PER_SEGMENT) { [EOL]             ptr = 0; [EOL]             segment = segment.next(); [EOL]             if (segment == null) [EOL]                 break; [EOL]         } [EOL]         JsonToken t = segment.type(ptr); [EOL]         if (t == null) [EOL]             break; [EOL]         switch(t) { [EOL]             case START_OBJECT: [EOL]                 jgen.writeStartObject(); [EOL]                 break; [EOL]             case END_OBJECT: [EOL]                 jgen.writeEndObject(); [EOL]                 break; [EOL]             case START_ARRAY: [EOL]                 jgen.writeStartArray(); [EOL]                 break; [EOL]             case END_ARRAY: [EOL]                 jgen.writeEndArray(); [EOL]                 break; [EOL]             case FIELD_NAME: [EOL]                 { [EOL]                     Object ob = segment.get(ptr); [EOL]                     if (ob instanceof SerializableString) { [EOL]                         jgen.writeFieldName((SerializableString) ob); [EOL]                     } else { [EOL]                         jgen.writeFieldName((String) ob); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case VALUE_STRING: [EOL]                 { [EOL]                     Object ob = segment.get(ptr); [EOL]                     if (ob instanceof SerializableString) { [EOL]                         jgen.writeString((SerializableString) ob); [EOL]                     } else { [EOL]                         jgen.writeString((String) ob); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case VALUE_NUMBER_INT: [EOL]                 { [EOL]                     Object n = segment.get(ptr); [EOL]                     if (n instanceof Integer) { [EOL]                         jgen.writeNumber((Integer) n); [EOL]                     } else if (n instanceof BigInteger) { [EOL]                         jgen.writeNumber((BigInteger) n); [EOL]                     } else if (n instanceof Long) { [EOL]                         jgen.writeNumber((Long) n); [EOL]                     } else if (n instanceof Short) { [EOL]                         jgen.writeNumber((Short) n); [EOL]                     } else { [EOL]                         jgen.writeNumber(((Number) n).intValue()); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 { [EOL]                     Object n = segment.get(ptr); [EOL]                     if (n instanceof Double) { [EOL]                         jgen.writeNumber(((Double) n).doubleValue()); [EOL]                     } else if (n instanceof BigDecimal) { [EOL]                         jgen.writeNumber((BigDecimal) n); [EOL]                     } else if (n instanceof Float) { [EOL]                         jgen.writeNumber(((Float) n).floatValue()); [EOL]                     } else if (n == null) { [EOL]                         jgen.writeNull(); [EOL]                     } else if (n instanceof String) { [EOL]                         jgen.writeNumber((String) n); [EOL]                     } else { [EOL]                         throw new JsonGenerationException("Unrecognized value type for VALUE_NUMBER_FLOAT: " + n.getClass().getName() + ", can not serialize"); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case VALUE_TRUE: [EOL]                 jgen.writeBoolean(true); [EOL]                 break; [EOL]             case VALUE_FALSE: [EOL]                 jgen.writeBoolean(false); [EOL]                 break; [EOL]             case VALUE_NULL: [EOL]                 jgen.writeNull(); [EOL]                 break; [EOL]             case VALUE_EMBEDDED_OBJECT: [EOL]                 jgen.writeObject(segment.get(ptr)); [EOL]                 break; [EOL]             default: [EOL]                 throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]         } [EOL]     } [EOL] } <line_num>: 203,303
@Override [EOL] public String toString() { [EOL]     final int MAX_COUNT = 100; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append("[TokenBuffer: "); [EOL]     JsonParser jp = asParser(); [EOL]     int count = 0; [EOL]     while (true) { [EOL]         JsonToken t; [EOL]         try { [EOL]             t = jp.nextToken(); [EOL]             if (t == null) [EOL]                 break; [EOL]             if (count < MAX_COUNT) { [EOL]                 if (count > 0) { [EOL]                     sb.append(", "); [EOL]                 } [EOL]                 sb.append(t.toString()); [EOL]                 if (t == JsonToken.FIELD_NAME) { [EOL]                     sb.append('('); [EOL]                     sb.append(jp.getCurrentName()); [EOL]                     sb.append(')'); [EOL]                 } [EOL]             } [EOL]         } catch (IOException ioe) { [EOL]             throw new IllegalStateException(ioe); [EOL]         } [EOL]         ++count; [EOL]     } [EOL]     if (count >= MAX_COUNT) { [EOL]         sb.append(" ... (truncated ").append(count - MAX_COUNT).append(" entries)"); [EOL]     } [EOL]     sb.append(']'); [EOL]     return sb.toString(); [EOL] } <line_num>: 305,343
@Override [EOL] public JsonGenerator enable(Feature f) { [EOL]     _generatorFeatures |= f.getMask(); [EOL]     return this; [EOL] } <line_num>: 351,355
@Override [EOL] public JsonGenerator disable(Feature f) { [EOL]     _generatorFeatures &= ~f.getMask(); [EOL]     return this; [EOL] } <line_num>: 357,361
@Override [EOL] public boolean isEnabled(Feature f) { [EOL]     return (_generatorFeatures & f.getMask()) != 0; [EOL] } <line_num>: 365,368
@Override [EOL] public JsonGenerator useDefaultPrettyPrinter() { [EOL]     return this; [EOL] } <line_num>: 370,374
@Override [EOL] public JsonGenerator setCodec(ObjectCodec oc) { [EOL]     _objectCodec = oc; [EOL]     return this; [EOL] } <line_num>: 376,380
@Override [EOL] public ObjectCodec getCodec() { [EOL]     return _objectCodec; [EOL] } <line_num>: 382,383
@Override [EOL] public final JsonWriteContext getOutputContext() { [EOL]     return _writeContext; [EOL] } <line_num>: 385,386
@Override [EOL] public void flush() throws IOException { [EOL] } <line_num>: 394,395
@Override [EOL] public void close() throws IOException { [EOL]     _closed = true; [EOL] } <line_num>: 397,400
@Override [EOL] public boolean isClosed() { [EOL]     return _closed; [EOL] } <line_num>: 402,403
@Override [EOL] public final void writeStartArray() throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.START_ARRAY); [EOL]     _writeContext = _writeContext.createChildArrayContext(); [EOL] } <line_num>: 411,417
@Override [EOL] public final void writeEndArray() throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.END_ARRAY); [EOL]     JsonWriteContext c = _writeContext.getParent(); [EOL]     if (c != null) { [EOL]         _writeContext = c; [EOL]     } [EOL] } <line_num>: 419,429
@Override [EOL] public final void writeStartObject() throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.START_OBJECT); [EOL]     _writeContext = _writeContext.createChildObjectContext(); [EOL] } <line_num>: 431,437
@Override [EOL] public final void writeEndObject() throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.END_OBJECT); [EOL]     JsonWriteContext c = _writeContext.getParent(); [EOL]     if (c != null) { [EOL]         _writeContext = c; [EOL]     } [EOL] } <line_num>: 439,449
@Override [EOL] public final void writeFieldName(String name) throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.FIELD_NAME, name); [EOL]     _writeContext.writeFieldName(name); [EOL] } <line_num>: 451,457
@Override [EOL] public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.FIELD_NAME, name); [EOL]     _writeContext.writeFieldName(name.getValue()); [EOL] } <line_num>: 459,465
@Override [EOL] public void writeString(String text) throws IOException, JsonGenerationException { [EOL]     if (text == null) { [EOL]         writeNull(); [EOL]     } else { [EOL]         _append(JsonToken.VALUE_STRING, text); [EOL]     } [EOL] } <line_num>: 473,480
@Override [EOL] public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     writeString(new String(text, offset, len)); [EOL] } <line_num>: 482,485
@Override [EOL] public void writeString(SerializableString text) throws IOException, JsonGenerationException { [EOL]     if (text == null) { [EOL]         writeNull(); [EOL]     } else { [EOL]         _append(JsonToken.VALUE_STRING, text); [EOL]     } [EOL] } <line_num>: 487,494
@Override [EOL] public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException { [EOL]     _reportUnsupportedOperation(); [EOL] } <line_num>: 496,502
@Override [EOL] public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException { [EOL]     _reportUnsupportedOperation(); [EOL] } <line_num>: 504,510
@Override [EOL] public void writeRaw(String text) throws IOException, JsonGenerationException { [EOL]     _reportUnsupportedOperation(); [EOL] } <line_num>: 512,515
@Override [EOL] public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     _reportUnsupportedOperation(); [EOL] } <line_num>: 517,520
@Override [EOL] public void writeRaw(SerializableString text) throws IOException, JsonGenerationException { [EOL]     _reportUnsupportedOperation(); [EOL] } <line_num>: 522,525
@Override [EOL] public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     _reportUnsupportedOperation(); [EOL] } <line_num>: 527,530
@Override [EOL] public void writeRaw(char c) throws IOException, JsonGenerationException { [EOL]     _reportUnsupportedOperation(); [EOL] } <line_num>: 532,535
@Override [EOL] public void writeRawValue(String text) throws IOException, JsonGenerationException { [EOL]     _reportUnsupportedOperation(); [EOL] } <line_num>: 537,540
@Override [EOL] public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     _reportUnsupportedOperation(); [EOL] } <line_num>: 542,545
@Override [EOL] public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException { [EOL]     _reportUnsupportedOperation(); [EOL] } <line_num>: 547,550
@Override [EOL] public void writeNumber(short i) throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i)); [EOL] } <line_num>: 558,561
@Override [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i)); [EOL] } <line_num>: 563,566
@Override [EOL] public void writeNumber(long l) throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); [EOL] } <line_num>: 568,571
@Override [EOL] public void writeNumber(double d) throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); [EOL] } <line_num>: 573,576
@Override [EOL] public void writeNumber(float f) throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f)); [EOL] } <line_num>: 578,581
@Override [EOL] public void writeNumber(BigDecimal dec) throws IOException, JsonGenerationException { [EOL]     if (dec == null) { [EOL]         writeNull(); [EOL]     } else { [EOL]         _append(JsonToken.VALUE_NUMBER_FLOAT, dec); [EOL]     } [EOL] } <line_num>: 583,590
@Override [EOL] public void writeNumber(BigInteger v) throws IOException, JsonGenerationException { [EOL]     if (v == null) { [EOL]         writeNull(); [EOL]     } else { [EOL]         _append(JsonToken.VALUE_NUMBER_INT, v); [EOL]     } [EOL] } <line_num>: 592,599
@Override [EOL] public void writeNumber(String encodedValue) throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue); [EOL] } <line_num>: 601,607
@Override [EOL] public void writeBoolean(boolean state) throws IOException, JsonGenerationException { [EOL]     _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE); [EOL] } <line_num>: 609,612
@Override [EOL] public void writeNull() throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.VALUE_NULL); [EOL] } <line_num>: 614,617
@Override [EOL] public void writeObject(Object value) throws IOException, JsonProcessingException { [EOL]     _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); [EOL] } <line_num>: 625,631
@Override [EOL] public void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException { [EOL]     _append(JsonToken.VALUE_EMBEDDED_OBJECT, rootNode); [EOL] } <line_num>: 633,641
@Override [EOL] public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException { [EOL]     byte[] copy = new byte[len]; [EOL]     System.arraycopy(data, offset, copy, 0, len); [EOL]     writeObject(copy); [EOL] } <line_num>: 649,662
@Override [EOL] public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) { [EOL]     throw new UnsupportedOperationException(); [EOL] } <line_num>: 670,673
@Override [EOL] public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             break; [EOL]         case END_OBJECT: [EOL]             writeEndObject(); [EOL]             break; [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             break; [EOL]         case END_ARRAY: [EOL]             writeEndArray(); [EOL]             break; [EOL]         case FIELD_NAME: [EOL]             writeFieldName(jp.getCurrentName()); [EOL]             break; [EOL]         case VALUE_STRING: [EOL]             if (jp.hasTextCharacters()) { [EOL]                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength()); [EOL]             } else { [EOL]                 writeString(jp.getText()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case INT: [EOL]                     writeNumber(jp.getIntValue()); [EOL]                     break; [EOL]                 case BIG_INTEGER: [EOL]                     writeNumber(jp.getBigIntegerValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getLongValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             switch(jp.getNumberType()) { [EOL]                 case BIG_DECIMAL: [EOL]                     writeNumber(jp.getDecimalValue()); [EOL]                     break; [EOL]                 case FLOAT: [EOL]                     writeNumber(jp.getFloatValue()); [EOL]                     break; [EOL]                 default: [EOL]                     writeNumber(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             writeBoolean(true); [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             writeBoolean(false); [EOL]             break; [EOL]         case VALUE_NULL: [EOL]             writeNull(); [EOL]             break; [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             writeObject(jp.getEmbeddedObject()); [EOL]             break; [EOL]         default: [EOL]             throw new RuntimeException("Internal error: should never end up through this code path"); [EOL]     } [EOL] } <line_num>: 681,746
@Override [EOL] public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.FIELD_NAME) { [EOL]         writeFieldName(jp.getCurrentName()); [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     switch(t) { [EOL]         case START_ARRAY: [EOL]             writeStartArray(); [EOL]             while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndArray(); [EOL]             break; [EOL]         case START_OBJECT: [EOL]             writeStartObject(); [EOL]             while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]                 copyCurrentStructure(jp); [EOL]             } [EOL]             writeEndObject(); [EOL]             break; [EOL]         default: [EOL]             copyCurrentEvent(jp); [EOL]     } [EOL] } <line_num>: 748,777
protected final void _append(JsonToken type) { [EOL]     Segment next = _last.append(_appendOffset, type); [EOL]     if (next == null) { [EOL]         ++_appendOffset; [EOL]     } else { [EOL]         _last = next; [EOL]         _appendOffset = 1; [EOL]     } [EOL] } <line_num>: 784,792
protected final void _append(JsonToken type, Object value) { [EOL]     Segment next = _last.append(_appendOffset, type, value); [EOL]     if (next == null) { [EOL]         ++_appendOffset; [EOL]     } else { [EOL]         _last = next; [EOL]         _appendOffset = 1; [EOL]     } [EOL] } <line_num>: 794,802
protected final void _appendRaw(int rawType, Object value) { [EOL]     Segment next = _last.appendRaw(_appendOffset, rawType, value); [EOL]     if (next == null) { [EOL]         ++_appendOffset; [EOL]     } else { [EOL]         _last = next; [EOL]         _appendOffset = 1; [EOL]     } [EOL] } <line_num>: 804,812
protected void _reportUnsupportedOperation() { [EOL]     throw new UnsupportedOperationException("Called operation not supported for TokenBuffer"); [EOL] } <line_num>: 814,816
public void setLocation(JsonLocation l) { [EOL]     _location = l; [EOL] } <line_num>: 872,874
@Override [EOL] public ObjectCodec getCodec() { [EOL]     return _codec; [EOL] } <line_num>: 876,877
@Override [EOL] public void setCodec(ObjectCodec c) { [EOL]     _codec = c; [EOL] } <line_num>: 879,880
@Override [EOL] public Version version() { [EOL]     return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; [EOL] } <line_num>: 882,885
public JsonToken peekNextToken() throws IOException, JsonParseException { [EOL]     if (_closed) [EOL]         return null; [EOL]     Segment seg = _segment; [EOL]     int ptr = _segmentPtr + 1; [EOL]     if (ptr >= Segment.TOKENS_PER_SEGMENT) { [EOL]         ptr = 0; [EOL]         seg = (seg == null) ? null : seg.next(); [EOL]     } [EOL]     return (seg == null) ? null : seg.type(ptr); [EOL] } <line_num>: 893,905
@Override [EOL] public void close() throws IOException { [EOL]     if (!_closed) { [EOL]         _closed = true; [EOL]     } [EOL] } <line_num>: 913,918
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     if (_closed || (_segment == null)) [EOL]         return null; [EOL]     if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) { [EOL]         _segmentPtr = 0; [EOL]         _segment = _segment.next(); [EOL]         if (_segment == null) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     _currToken = _segment.type(_segmentPtr); [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         Object ob = _currentObject(); [EOL]         String name = (ob instanceof String) ? ((String) ob) : ob.toString(); [EOL]         _parsingContext.setCurrentName(name); [EOL]     } else if (_currToken == JsonToken.START_OBJECT) { [EOL]         _parsingContext = _parsingContext.createChildObjectContext(-1, -1); [EOL]     } else if (_currToken == JsonToken.START_ARRAY) { [EOL]         _parsingContext = _parsingContext.createChildArrayContext(-1, -1); [EOL]     } else if (_currToken == JsonToken.END_OBJECT || _currToken == JsonToken.END_ARRAY) { [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         if (_parsingContext == null) { [EOL]             _parsingContext = JsonReadContext.createRootContext(-1, -1); [EOL]         } [EOL]     } [EOL]     return _currToken; [EOL] } <line_num>: 926,960
@Override [EOL] public boolean isClosed() { [EOL]     return _closed; [EOL] } <line_num>: 962,963
@Override [EOL] public JsonStreamContext getParsingContext() { [EOL]     return _parsingContext; [EOL] } <line_num>: 971,972
@Override [EOL] public JsonLocation getTokenLocation() { [EOL]     return getCurrentLocation(); [EOL] } <line_num>: 974,975
@Override [EOL] public JsonLocation getCurrentLocation() { [EOL]     return (_location == null) ? JsonLocation.NA : _location; [EOL] } <line_num>: 977,980
@Override [EOL] public String getCurrentName() { [EOL]     return _parsingContext.getCurrentName(); [EOL] } <line_num>: 982,983
@Override [EOL] public void overrideCurrentName(String name) { [EOL]     JsonReadContext ctxt = _parsingContext; [EOL]     if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]         ctxt = ctxt.getParent(); [EOL]     } [EOL]     ctxt.setCurrentName(name); [EOL] } <line_num>: 985,994
@Override [EOL] public String getText() { [EOL]     if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) { [EOL]         Object ob = _currentObject(); [EOL]         if (ob instanceof String) { [EOL]             return (String) ob; [EOL]         } [EOL]         return (ob == null) ? null : ob.toString(); [EOL]     } [EOL]     if (_currToken == null) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             Object ob = _currentObject(); [EOL]             return (ob == null) ? null : ob.toString(); [EOL]         default: [EOL]             return _currToken.asString(); [EOL]     } [EOL] } <line_num>: 1002,1025
@Override [EOL] public char[] getTextCharacters() { [EOL]     String str = getText(); [EOL]     return (str == null) ? null : str.toCharArray(); [EOL] } <line_num>: 1027,1031
@Override [EOL] public int getTextLength() { [EOL]     String str = getText(); [EOL]     return (str == null) ? 0 : str.length(); [EOL] } <line_num>: 1033,1037
@Override [EOL] public int getTextOffset() { [EOL]     return 0; [EOL] } <line_num>: 1039,1040
@Override [EOL] public boolean hasTextCharacters() { [EOL]     return false; [EOL] } <line_num>: 1042,1046
@Override [EOL] public BigInteger getBigIntegerValue() throws IOException, JsonParseException { [EOL]     Number n = getNumberValue(); [EOL]     if (n instanceof BigInteger) { [EOL]         return (BigInteger) n; [EOL]     } [EOL]     if (getNumberType() == NumberType.BIG_DECIMAL) { [EOL]         return ((BigDecimal) n).toBigInteger(); [EOL]     } [EOL]     return BigInteger.valueOf(n.longValue()); [EOL] } <line_num>: 1054,1066
@Override [EOL] public BigDecimal getDecimalValue() throws IOException, JsonParseException { [EOL]     Number n = getNumberValue(); [EOL]     if (n instanceof BigDecimal) { [EOL]         return (BigDecimal) n; [EOL]     } [EOL]     switch(getNumberType()) { [EOL]         case INT: [EOL]         case LONG: [EOL]             return BigDecimal.valueOf(n.longValue()); [EOL]         case BIG_INTEGER: [EOL]             return new BigDecimal((BigInteger) n); [EOL]         default: [EOL]     } [EOL]     return BigDecimal.valueOf(n.doubleValue()); [EOL] } <line_num>: 1068,1085
@Override [EOL] public double getDoubleValue() throws IOException, JsonParseException { [EOL]     return getNumberValue().doubleValue(); [EOL] } <line_num>: 1087,1090
@Override [EOL] public float getFloatValue() throws IOException, JsonParseException { [EOL]     return getNumberValue().floatValue(); [EOL] } <line_num>: 1092,1095
@Override [EOL] public int getIntValue() throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         return ((Number) _currentObject()).intValue(); [EOL]     } [EOL]     return getNumberValue().intValue(); [EOL] } <line_num>: 1097,1105
@Override [EOL] public long getLongValue() throws IOException, JsonParseException { [EOL]     return getNumberValue().longValue(); [EOL] } <line_num>: 1107,1110
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     Number n = getNumberValue(); [EOL]     if (n instanceof Integer) [EOL]         return NumberType.INT; [EOL]     if (n instanceof Long) [EOL]         return NumberType.LONG; [EOL]     if (n instanceof Double) [EOL]         return NumberType.DOUBLE; [EOL]     if (n instanceof BigDecimal) [EOL]         return NumberType.BIG_DECIMAL; [EOL]     if (n instanceof BigInteger) [EOL]         return NumberType.BIG_INTEGER; [EOL]     if (n instanceof Float) [EOL]         return NumberType.FLOAT; [EOL]     if (n instanceof Short) [EOL]         return NumberType.INT; [EOL]     return null; [EOL] } <line_num>: 1112,1124
@Override [EOL] public final Number getNumberValue() throws IOException, JsonParseException { [EOL]     _checkIsNumber(); [EOL]     return (Number) _currentObject(); [EOL] } <line_num>: 1126,1130
@Override [EOL] public Object getEmbeddedObject() { [EOL]     if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         return _currentObject(); [EOL]     } [EOL]     return null; [EOL] } <line_num>: 1138,1145
@Override [EOL] public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = _currentObject(); [EOL]         if (ob instanceof byte[]) { [EOL]             return (byte[]) ob; [EOL]         } [EOL]     } [EOL]     if (_currToken != JsonToken.VALUE_STRING) { [EOL]         throw _constructError("Current token (" + _currToken + ") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary"); [EOL]     } [EOL]     final String str = getText(); [EOL]     if (str == null) { [EOL]         return null; [EOL]     } [EOL]     ByteArrayBuilder builder = _byteBuilder; [EOL]     if (builder == null) { [EOL]         _byteBuilder = builder = new ByteArrayBuilder(100); [EOL]     } else { [EOL]         _byteBuilder.reset(); [EOL]     } [EOL]     _decodeBase64(str, builder, b64variant); [EOL]     return builder.toByteArray(); [EOL] } <line_num>: 1147,1174
@Override [EOL] public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException { [EOL]     byte[] data = getBinaryValue(b64variant); [EOL]     if (data != null) { [EOL]         out.write(data, 0, data.length); [EOL]         return data.length; [EOL]     } [EOL]     return 0; [EOL] } <line_num>: 1176,1185
protected final Object _currentObject() { [EOL]     return _segment.get(_segmentPtr); [EOL] } <line_num>: 1193,1195
protected final void _checkIsNumber() throws JsonParseException { [EOL]     if (_currToken == null || !_currToken.isNumeric()) { [EOL]         throw _constructError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL]     } [EOL] } <line_num>: 1197,1202
@Override [EOL] protected void _handleEOF() throws JsonParseException { [EOL]     _throwInternal(); [EOL] } <line_num>: 1204,1207
public JsonToken type(int index) { [EOL]     long l = _tokenTypes; [EOL]     if (index > 0) { [EOL]         l >>= (index << 2); [EOL]     } [EOL]     int ix = ((int) l) & 0xF; [EOL]     return TOKEN_TYPES_BY_INDEX[ix]; [EOL] } <line_num>: 1254,1262
public int rawType(int index) { [EOL]     long l = _tokenTypes; [EOL]     if (index > 0) { [EOL]         l >>= (index << 2); [EOL]     } [EOL]     int ix = ((int) l) & 0xF; [EOL]     return ix; [EOL] } <line_num>: 1264,1272
public Object get(int index) { [EOL]     return _tokens[index]; [EOL] } <line_num>: 1274,1276
public Segment next() { [EOL]     return _next; [EOL] } <line_num>: 1278,1278
public Segment append(int index, JsonToken tokenType) { [EOL]     if (index < TOKENS_PER_SEGMENT) { [EOL]         set(index, tokenType); [EOL]         return null; [EOL]     } [EOL]     _next = new Segment(); [EOL]     _next.set(0, tokenType); [EOL]     return _next; [EOL] } <line_num>: 1282,1291
public Segment append(int index, JsonToken tokenType, Object value) { [EOL]     if (index < TOKENS_PER_SEGMENT) { [EOL]         set(index, tokenType, value); [EOL]         return null; [EOL]     } [EOL]     _next = new Segment(); [EOL]     _next.set(0, tokenType, value); [EOL]     return _next; [EOL] } <line_num>: 1293,1302
public Segment appendRaw(int index, int rawTokenType, Object value) { [EOL]     if (index < TOKENS_PER_SEGMENT) { [EOL]         set(index, rawTokenType, value); [EOL]         return null; [EOL]     } [EOL]     _next = new Segment(); [EOL]     _next.set(0, rawTokenType, value); [EOL]     return _next; [EOL] } <line_num>: 1304,1313
public void set(int index, JsonToken tokenType) { [EOL]     long typeCode = tokenType.ordinal(); [EOL]     if (index > 0) { [EOL]         typeCode <<= (index << 2); [EOL]     } [EOL]     _tokenTypes |= typeCode; [EOL] } <line_num>: 1315,1325
public void set(int index, JsonToken tokenType, Object value) { [EOL]     _tokens[index] = value; [EOL]     long typeCode = tokenType.ordinal(); [EOL]     if (index > 0) { [EOL]         typeCode <<= (index << 2); [EOL]     } [EOL]     _tokenTypes |= typeCode; [EOL] } <line_num>: 1327,1338
private void set(int index, int rawTokenType, Object value) { [EOL]     _tokens[index] = value; [EOL]     long typeCode = (long) rawTokenType; [EOL]     if (index > 0) { [EOL]         typeCode <<= (index << 2); [EOL]     } [EOL]     _tokenTypes |= typeCode; [EOL] } <line_num>: 1340,1348
