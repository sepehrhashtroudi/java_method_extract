private EnumTypeLocator() { [EOL]     enumSetTypeField = locateField(EnumSet.class, "elementType", Class.class); [EOL]     enumMapTypeField = locateField(EnumMap.class, "elementType", Class.class); [EOL] } <line_num>: 624,630
public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore) { [EOL]     return findSuperTypes(cls, endBefore, new ArrayList<Class<?>>(8)); [EOL] } <line_num>: 28,31
public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore, List<Class<?>> result) { [EOL]     _addSuperTypes(cls, endBefore, result, false); [EOL]     return result; [EOL] } <line_num>: 33,37
private static void _addSuperTypes(Class<?> cls, Class<?> endBefore, Collection<Class<?>> result, boolean addClassItself) { [EOL]     if (cls == endBefore || cls == null || cls == Object.class) { [EOL]         return; [EOL]     } [EOL]     if (addClassItself) { [EOL]         if (result.contains(cls)) { [EOL]             return; [EOL]         } [EOL]         result.add(cls); [EOL]     } [EOL]     for (Class<?> intCls : cls.getInterfaces()) { [EOL]         _addSuperTypes(intCls, endBefore, result, true); [EOL]     } [EOL]     _addSuperTypes(cls.getSuperclass(), endBefore, result, true); [EOL] } <line_num>: 39,54
public static String canBeABeanType(Class<?> type) { [EOL]     if (type.isAnnotation()) { [EOL]         return "annotation"; [EOL]     } [EOL]     if (type.isArray()) { [EOL]         return "array"; [EOL]     } [EOL]     if (type.isEnum()) { [EOL]         return "enum"; [EOL]     } [EOL]     if (type.isPrimitive()) { [EOL]         return "primitive"; [EOL]     } [EOL]     return null; [EOL] } <line_num>: 66,84
public static String isLocalType(Class<?> type, boolean allowNonStatic) { [EOL]     try { [EOL]         if (type.getEnclosingMethod() != null) { [EOL]             return "local/anonymous"; [EOL]         } [EOL]         if (!allowNonStatic) { [EOL]             if (type.getEnclosingClass() != null) { [EOL]                 if (!Modifier.isStatic(type.getModifiers())) { [EOL]                     return "non-static member class"; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } catch (SecurityException e) { [EOL]     } catch (NullPointerException e) { [EOL]     } [EOL]     return null; [EOL] } <line_num>: 86,113
public static Class<?> getOuterClass(Class<?> type) { [EOL]     try { [EOL]         if (type.getEnclosingMethod() != null) { [EOL]             return null; [EOL]         } [EOL]         if (!Modifier.isStatic(type.getModifiers())) { [EOL]             return type.getEnclosingClass(); [EOL]         } [EOL]     } catch (SecurityException e) { [EOL]     } catch (NullPointerException e) { [EOL]     } [EOL]     return null; [EOL] } <line_num>: 118,132
public static boolean isProxyType(Class<?> type) { [EOL]     String name = type.getName(); [EOL]     if (name.startsWith("net.sf.cglib.proxy.") || name.startsWith("org.hibernate.proxy.")) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 140,157
public static boolean isConcrete(Class<?> type) { [EOL]     int mod = type.getModifiers(); [EOL]     return (mod & (Modifier.INTERFACE | Modifier.ABSTRACT)) == 0; [EOL] } <line_num>: 163,167
public static boolean isConcrete(Member member) { [EOL]     int mod = member.getModifiers(); [EOL]     return (mod & (Modifier.INTERFACE | Modifier.ABSTRACT)) == 0; [EOL] } <line_num>: 169,173
public static boolean isCollectionMapOrArray(Class<?> type) { [EOL]     if (type.isArray()) [EOL]         return true; [EOL]     if (Collection.class.isAssignableFrom(type)) [EOL]         return true; [EOL]     if (Map.class.isAssignableFrom(type)) [EOL]         return true; [EOL]     return false; [EOL] } <line_num>: 175,181
public static String getClassDescription(Object classOrInstance) { [EOL]     if (classOrInstance == null) { [EOL]         return "unknown"; [EOL]     } [EOL]     Class<?> cls = (classOrInstance instanceof Class<?>) ? (Class<?>) classOrInstance : classOrInstance.getClass(); [EOL]     return cls.getName(); [EOL] } <line_num>: 194,202
public static Class<?> findClass(String className) throws ClassNotFoundException { [EOL]     if (className.indexOf('.') < 0) { [EOL]         if ("int".equals(className)) [EOL]             return Integer.TYPE; [EOL]         if ("long".equals(className)) [EOL]             return Long.TYPE; [EOL]         if ("float".equals(className)) [EOL]             return Float.TYPE; [EOL]         if ("double".equals(className)) [EOL]             return Double.TYPE; [EOL]         if ("boolean".equals(className)) [EOL]             return Boolean.TYPE; [EOL]         if ("byte".equals(className)) [EOL]             return Byte.TYPE; [EOL]         if ("char".equals(className)) [EOL]             return Character.TYPE; [EOL]         if ("short".equals(className)) [EOL]             return Short.TYPE; [EOL]         if ("void".equals(className)) [EOL]             return Void.TYPE; [EOL]     } [EOL]     Throwable prob = null; [EOL]     ClassLoader loader = Thread.currentThread().getContextClassLoader(); [EOL]     if (loader != null) { [EOL]         try { [EOL]             return Class.forName(className, true, loader); [EOL]         } catch (Exception e) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return Class.forName(className); [EOL]     } catch (Exception e) { [EOL]         if (prob == null) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     if (prob instanceof RuntimeException) { [EOL]         throw (RuntimeException) prob; [EOL]     } [EOL]     throw new ClassNotFoundException(prob.getMessage(), prob); [EOL] } <line_num>: 210,246
public static boolean hasGetterSignature(Method m) { [EOL]     if (Modifier.isStatic(m.getModifiers())) { [EOL]         return false; [EOL]     } [EOL]     Class<?>[] pts = m.getParameterTypes(); [EOL]     if (pts != null && pts.length != 0) { [EOL]         return false; [EOL]     } [EOL]     if (Void.TYPE == m.getReturnType()) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } <line_num>: 254,271
public static Throwable getRootCause(Throwable t) { [EOL]     while (t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     return t; [EOL] } <line_num>: 283,289
public static void throwRootCause(Throwable t) throws Exception { [EOL]     t = getRootCause(t); [EOL]     if (t instanceof Exception) { [EOL]         throw (Exception) t; [EOL]     } [EOL]     throw (Error) t; [EOL] } <line_num>: 297,304
public static void throwAsIAE(Throwable t) { [EOL]     throwAsIAE(t, t.getMessage()); [EOL] } <line_num>: 310,313
public static void throwAsIAE(Throwable t, String msg) { [EOL]     if (t instanceof RuntimeException) { [EOL]         throw (RuntimeException) t; [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     throw new IllegalArgumentException(msg, t); [EOL] } <line_num>: 320,329
public static void unwrapAndThrowAsIAE(Throwable t) { [EOL]     throwAsIAE(getRootCause(t)); [EOL] } <line_num>: 336,339
public static void unwrapAndThrowAsIAE(Throwable t, String msg) { [EOL]     throwAsIAE(getRootCause(t), msg); [EOL] } <line_num>: 346,349
public static <T> T createInstance(Class<T> cls, boolean canFixAccess) throws IllegalArgumentException { [EOL]     Constructor<T> ctor = findConstructor(cls, canFixAccess); [EOL]     if (ctor == null) { [EOL]         throw new IllegalArgumentException("Class " + cls.getName() + " has no default (no arg) constructor"); [EOL]     } [EOL]     try { [EOL]         return ctor.newInstance(); [EOL]     } catch (Exception e) { [EOL]         ClassUtil.unwrapAndThrowAsIAE(e, "Failed to instantiate class " + cls.getName() + ", problem: " + e.getMessage()); [EOL]         return null; [EOL]     } [EOL] } <line_num>: 370,383
public static <T> Constructor<T> findConstructor(Class<T> cls, boolean canFixAccess) throws IllegalArgumentException { [EOL]     try { [EOL]         Constructor<T> ctor = cls.getDeclaredConstructor(); [EOL]         if (canFixAccess) { [EOL]             checkAndFixAccess(ctor); [EOL]         } else { [EOL]             if (!Modifier.isPublic(ctor.getModifiers())) { [EOL]                 throw new IllegalArgumentException("Default constructor for " + cls.getName() + " is not accessible (non-public?): not allowed to try modify access via Reflection: can not instantiate type"); [EOL]             } [EOL]         } [EOL]         return ctor; [EOL]     } catch (NoSuchMethodException e) { [EOL]         ; [EOL]     } catch (Exception e) { [EOL]         ClassUtil.unwrapAndThrowAsIAE(e, "Failed to find default constructor of class " + cls.getName() + ", problem: " + e.getMessage()); [EOL]     } [EOL]     return null; [EOL] } <line_num>: 385,405
public static Object defaultValue(Class<?> cls) { [EOL]     if (cls == Integer.TYPE) { [EOL]         return Integer.valueOf(0); [EOL]     } [EOL]     if (cls == Long.TYPE) { [EOL]         return Long.valueOf(0L); [EOL]     } [EOL]     if (cls == Boolean.TYPE) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (cls == Double.TYPE) { [EOL]         return Double.valueOf(0.0); [EOL]     } [EOL]     if (cls == Float.TYPE) { [EOL]         return Float.valueOf(0.0f); [EOL]     } [EOL]     if (cls == Byte.TYPE) { [EOL]         return Byte.valueOf((byte) 0); [EOL]     } [EOL]     if (cls == Short.TYPE) { [EOL]         return Short.valueOf((short) 0); [EOL]     } [EOL]     if (cls == Character.TYPE) { [EOL]         return '\0'; [EOL]     } [EOL]     throw new IllegalArgumentException("Class " + cls.getName() + " is not a primitive type"); [EOL] } <line_num>: 417,444
public static Class<?> wrapperType(Class<?> primitiveType) { [EOL]     if (primitiveType == Integer.TYPE) { [EOL]         return Integer.class; [EOL]     } [EOL]     if (primitiveType == Long.TYPE) { [EOL]         return Long.class; [EOL]     } [EOL]     if (primitiveType == Boolean.TYPE) { [EOL]         return Boolean.class; [EOL]     } [EOL]     if (primitiveType == Double.TYPE) { [EOL]         return Double.class; [EOL]     } [EOL]     if (primitiveType == Float.TYPE) { [EOL]         return Float.class; [EOL]     } [EOL]     if (primitiveType == Byte.TYPE) { [EOL]         return Byte.class; [EOL]     } [EOL]     if (primitiveType == Short.TYPE) { [EOL]         return Short.class; [EOL]     } [EOL]     if (primitiveType == Character.TYPE) { [EOL]         return Character.class; [EOL]     } [EOL]     throw new IllegalArgumentException("Class " + primitiveType.getName() + " is not a primitive type"); [EOL] } <line_num>: 450,477
public static void checkAndFixAccess(Member member) { [EOL]     AccessibleObject ao = (AccessibleObject) member; [EOL]     try { [EOL]         ao.setAccessible(true); [EOL]     } catch (SecurityException se) { [EOL]         if (!ao.isAccessible()) { [EOL]             Class<?> declClass = member.getDeclaringClass(); [EOL]             throw new IllegalArgumentException("Can not access " + member + " (from class " + declClass.getName() + "; failed to set access: " + se.getMessage()); [EOL]         } [EOL]     } [EOL] } <line_num>: 491,514
public static Class<? extends Enum<?>> findEnumType(EnumSet<?> s) { [EOL]     if (!s.isEmpty()) { [EOL]         return findEnumType(s.iterator().next()); [EOL]     } [EOL]     return EnumTypeLocator.instance.enumTypeFor(s); [EOL] } <line_num>: 528,536
public static Class<? extends Enum<?>> findEnumType(EnumMap<?, ?> m) { [EOL]     if (!m.isEmpty()) { [EOL]         return findEnumType(m.keySet().iterator().next()); [EOL]     } [EOL]     return EnumTypeLocator.instance.enumTypeFor(m); [EOL] } <line_num>: 544,551
@SuppressWarnings("unchecked") [EOL] public static Class<? extends Enum<?>> findEnumType(Enum<?> en) { [EOL]     Class<?> ec = en.getClass(); [EOL]     if (ec.getSuperclass() != Enum.class) { [EOL]         ec = ec.getSuperclass(); [EOL]     } [EOL]     return (Class<? extends Enum<?>>) ec; [EOL] } <line_num>: 559,568
@SuppressWarnings("unchecked") [EOL] public static Class<? extends Enum<?>> findEnumType(Class<?> cls) { [EOL]     if (cls.getSuperclass() != Enum.class) { [EOL]         cls = cls.getSuperclass(); [EOL]     } [EOL]     return (Class<? extends Enum<?>>) cls; [EOL] } <line_num>: 576,584
public static boolean isJacksonStdImpl(Object impl) { [EOL]     return (impl != null) && isJacksonStdImpl(impl.getClass()); [EOL] } <line_num>: 599,601
public static boolean isJacksonStdImpl(Class<?> implClass) { [EOL]     return (implClass.getAnnotation(JacksonStdImpl.class) != null); [EOL] } <line_num>: 603,605
@SuppressWarnings("unchecked") [EOL] public Class<? extends Enum<?>> enumTypeFor(EnumSet<?> set) { [EOL]     if (enumSetTypeField != null) { [EOL]         return (Class<? extends Enum<?>>) get(set, enumSetTypeField); [EOL]     } [EOL]     throw new IllegalStateException("Can not figure out type for EnumSet (odd JDK platform?)"); [EOL] } <line_num>: 632,639
@SuppressWarnings("unchecked") [EOL] public Class<? extends Enum<?>> enumTypeFor(EnumMap<?, ?> set) { [EOL]     if (enumMapTypeField != null) { [EOL]         return (Class<? extends Enum<?>>) get(set, enumMapTypeField); [EOL]     } [EOL]     throw new IllegalStateException("Can not figure out type for EnumMap (odd JDK platform?)"); [EOL] } <line_num>: 641,648
private Object get(Object bean, Field field) { [EOL]     try { [EOL]         return field.get(bean); [EOL]     } catch (Exception e) { [EOL]         throw new IllegalArgumentException(e); [EOL]     } [EOL] } <line_num>: 650,657
private static Field locateField(Class<?> fromClass, String expectedName, Class<?> type) { [EOL]     Field found = null; [EOL]     Field[] fields = fromClass.getDeclaredFields(); [EOL]     for (Field f : fields) { [EOL]         if (expectedName.equals(f.getName()) && f.getType() == type) { [EOL]             found = f; [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (found == null) { [EOL]         for (Field f : fields) { [EOL]             if (f.getType() == type) { [EOL]                 if (found != null) [EOL]                     return null; [EOL]                 found = f; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (found != null) { [EOL]         try { [EOL]             found.setAccessible(true); [EOL]         } catch (Throwable t) { [EOL]         } [EOL]     } [EOL]     return found; [EOL] } <line_num>: 659,686
