protected BasicBeanDescription(MapperConfig<?> config, JavaType type, AnnotatedClass classDef, List<BeanPropertyDefinition> props) { [EOL]     super(type); [EOL]     _config = config; [EOL]     _annotationIntrospector = (config == null) ? null : config.getAnnotationIntrospector(); [EOL]     _classInfo = classDef; [EOL]     _properties = props; [EOL] } <line_num>: 87,96
protected BasicBeanDescription(POJOPropertiesCollector coll) { [EOL]     this(coll.getConfig(), coll.getType(), coll.getClassDef(), coll.getProperties()); [EOL]     _objectIdInfo = coll.getObjectIdInfo(); [EOL] } <line_num>: 98,102
public static BasicBeanDescription forDeserialization(POJOPropertiesCollector coll) { [EOL]     BasicBeanDescription desc = new BasicBeanDescription(coll); [EOL]     desc._anySetterMethod = coll.getAnySetterMethod(); [EOL]     desc._ignoredPropertyNames = coll.getIgnoredPropertyNames(); [EOL]     desc._injectables = coll.getInjectables(); [EOL]     desc._jsonValueMethod = coll.getJsonValueMethod(); [EOL]     return desc; [EOL] } <line_num>: 108,116
public static BasicBeanDescription forSerialization(POJOPropertiesCollector coll) { [EOL]     BasicBeanDescription desc = new BasicBeanDescription(coll); [EOL]     desc._jsonValueMethod = coll.getJsonValueMethod(); [EOL]     desc._anyGetter = coll.getAnyGetter(); [EOL]     return desc; [EOL] } <line_num>: 122,128
public static BasicBeanDescription forOtherUse(MapperConfig<?> config, JavaType type, AnnotatedClass ac) { [EOL]     return new BasicBeanDescription(config, type, ac, Collections.<BeanPropertyDefinition>emptyList()); [EOL] } <line_num>: 135,140
public boolean removeProperty(String propName) { [EOL]     Iterator<BeanPropertyDefinition> it = _properties.iterator(); [EOL]     while (it.hasNext()) { [EOL]         BeanPropertyDefinition prop = it.next(); [EOL]         if (prop.getName().equals(propName)) { [EOL]             it.remove(); [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 155,166
@Override [EOL] public AnnotatedClass getClassInfo() { [EOL]     return _classInfo; [EOL] } <line_num>: 174,175
@Override [EOL] public ObjectIdInfo getObjectIdInfo() { [EOL]     return _objectIdInfo; [EOL] } <line_num>: 177,178
@Override [EOL] public List<BeanPropertyDefinition> findProperties() { [EOL]     return _properties; [EOL] } <line_num>: 180,183
@Override [EOL] public AnnotatedMethod findJsonValueMethod() { [EOL]     return _jsonValueMethod; [EOL] } <line_num>: 185,188
@Override [EOL] public Set<String> getIgnoredPropertyNames() { [EOL]     if (_ignoredPropertyNames == null) { [EOL]         return Collections.emptySet(); [EOL]     } [EOL]     return _ignoredPropertyNames; [EOL] } <line_num>: 190,196
@Override [EOL] public boolean hasKnownClassAnnotations() { [EOL]     return _classInfo.hasAnnotations(); [EOL] } <line_num>: 198,201
@Override [EOL] public Annotations getClassAnnotations() { [EOL]     return _classInfo.getAnnotations(); [EOL] } <line_num>: 203,206
@Override [EOL] public TypeBindings bindingsForBeanType() { [EOL]     if (_bindings == null) { [EOL]         _bindings = new TypeBindings(_config.getTypeFactory(), _type); [EOL]     } [EOL]     return _bindings; [EOL] } <line_num>: 208,215
@Override [EOL] public JavaType resolveType(java.lang.reflect.Type jdkType) { [EOL]     if (jdkType == null) { [EOL]         return null; [EOL]     } [EOL]     return bindingsForBeanType().resolveType(jdkType); [EOL] } <line_num>: 217,223
@Override [EOL] public AnnotatedConstructor findDefaultConstructor() { [EOL]     return _classInfo.getDefaultConstructor(); [EOL] } <line_num>: 225,228
@Override [EOL] public AnnotatedMethod findAnySetter() throws IllegalArgumentException { [EOL]     if (_anySetterMethod != null) { [EOL]         Class<?> type = _anySetterMethod.getRawParameterType(0); [EOL]         if (type != String.class && type != Object.class) { [EOL]             throw new IllegalArgumentException("Invalid 'any-setter' annotation on method " + _anySetterMethod.getName() + "(): first argument not of type String or Object, but " + type.getName()); [EOL]         } [EOL]     } [EOL]     return _anySetterMethod; [EOL] } <line_num>: 230,248
@Override [EOL] public Map<Object, AnnotatedMember> findInjectables() { [EOL]     return _injectables; [EOL] } <line_num>: 250,253
@Override [EOL] public List<AnnotatedConstructor> getConstructors() { [EOL]     return _classInfo.getConstructors(); [EOL] } <line_num>: 255,258
@Override [EOL] public Object instantiateBean(boolean fixAccess) { [EOL]     AnnotatedConstructor ac = _classInfo.getDefaultConstructor(); [EOL]     if (ac == null) { [EOL]         return null; [EOL]     } [EOL]     if (fixAccess) { [EOL]         ac.fixAccess(); [EOL]     } [EOL]     try { [EOL]         return ac.getAnnotated().newInstance(); [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) [EOL]             throw (Error) t; [EOL]         if (t instanceof RuntimeException) [EOL]             throw (RuntimeException) t; [EOL]         throw new IllegalArgumentException("Failed to instantiate bean of type " + _classInfo.getAnnotated().getName() + ": (" + t.getClass().getName() + ") " + t.getMessage(), t); [EOL]     } [EOL] } <line_num>: 260,281
@Override [EOL] public AnnotatedMethod findMethod(String name, Class<?>[] paramTypes) { [EOL]     return _classInfo.findMethod(name, paramTypes); [EOL] } <line_num>: 289,292
@Override [EOL] public JsonFormat.Value findExpectedFormat(JsonFormat.Value defValue) { [EOL]     if (_annotationIntrospector != null) { [EOL]         JsonFormat.Value v = _annotationIntrospector.findFormat(_classInfo); [EOL]         if (v != null) { [EOL]             return v; [EOL]         } [EOL]     } [EOL]     return defValue; [EOL] } <line_num>: 300,310
@Override [EOL] public Converter<Object, Object> findSerializationConverter() { [EOL]     if (_annotationIntrospector == null) { [EOL]         return null; [EOL]     } [EOL]     return _createConverter(_annotationIntrospector.findSerializationConverter(_classInfo)); [EOL] } <line_num>: 318,325
@Override [EOL] public JsonInclude.Include findSerializationInclusion(JsonInclude.Include defValue) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return defValue; [EOL]     } [EOL]     return _annotationIntrospector.findSerializationInclusion(_classInfo, defValue); [EOL] } <line_num>: 333,340
@Override [EOL] public AnnotatedMember findAnyGetter() throws IllegalArgumentException { [EOL]     if (_anyGetter != null) { [EOL]         Class<?> type = _anyGetter.getRawType(); [EOL]         if (!Map.class.isAssignableFrom(type)) { [EOL]             throw new IllegalArgumentException("Invalid 'any-getter' annotation on method " + _anyGetter.getName() + "(): return type is not instance of java.util.Map"); [EOL]         } [EOL]     } [EOL]     return _anyGetter; [EOL] } <line_num>: 348,361
@Override [EOL] public Map<String, AnnotatedMember> findBackReferenceProperties() { [EOL]     HashMap<String, AnnotatedMember> result = null; [EOL]     for (BeanPropertyDefinition property : _properties) { [EOL]         AnnotatedMember am = property.getMutator(); [EOL]         if (am == null) { [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refDef = _annotationIntrospector.findReferenceType(am); [EOL]         if (refDef != null && refDef.isBackReference()) { [EOL]             if (result == null) { [EOL]                 result = new HashMap<String, AnnotatedMember>(); [EOL]             } [EOL]             String refName = refDef.getName(); [EOL]             if (result.put(refName, am) != null) { [EOL]                 throw new IllegalArgumentException("Multiple back-reference properties with name '" + refName + "'"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] } <line_num>: 363,384
@Override [EOL] public List<AnnotatedMethod> getFactoryMethods() { [EOL]     List<AnnotatedMethod> candidates = _classInfo.getStaticMethods(); [EOL]     if (candidates.isEmpty()) { [EOL]         return candidates; [EOL]     } [EOL]     ArrayList<AnnotatedMethod> result = new ArrayList<AnnotatedMethod>(); [EOL]     for (AnnotatedMethod am : candidates) { [EOL]         if (isFactoryMethod(am)) { [EOL]             result.add(am); [EOL]         } [EOL]     } [EOL]     return result; [EOL] } <line_num>: 392,407
@Override [EOL] public Constructor<?> findSingleArgConstructor(Class<?>... argTypes) { [EOL]     for (AnnotatedConstructor ac : _classInfo.getConstructors()) { [EOL]         if (ac.getParameterCount() == 1) { [EOL]             Class<?> actArg = ac.getRawParameterType(0); [EOL]             for (Class<?> expArg : argTypes) { [EOL]                 if (expArg == actArg) { [EOL]                     return ac.getAnnotated(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 409,427
@Override [EOL] public Method findFactoryMethod(Class<?>... expArgTypes) { [EOL]     for (AnnotatedMethod am : _classInfo.getStaticMethods()) { [EOL]         if (isFactoryMethod(am)) { [EOL]             Class<?> actualArgType = am.getRawParameterType(0); [EOL]             for (Class<?> expArgType : expArgTypes) { [EOL]                 if (actualArgType.isAssignableFrom(expArgType)) { [EOL]                     return am.getAnnotated(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 429,446
protected boolean isFactoryMethod(AnnotatedMethod am) { [EOL]     Class<?> rt = am.getRawReturnType(); [EOL]     if (!getBeanClass().isAssignableFrom(rt)) { [EOL]         return false; [EOL]     } [EOL]     if (_annotationIntrospector.hasCreatorAnnotation(am)) { [EOL]         return true; [EOL]     } [EOL]     if ("valueOf".equals(am.getName())) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 448,470
public List<String> findCreatorPropertyNames() { [EOL]     List<String> names = null; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         List<? extends AnnotatedWithParams> l = (i == 0) ? getConstructors() : getFactoryMethods(); [EOL]         for (AnnotatedWithParams creator : l) { [EOL]             int argCount = creator.getParameterCount(); [EOL]             if (argCount < 1) [EOL]                 continue; [EOL]             PropertyName name = _annotationIntrospector.findNameForDeserialization(creator.getParameter(0)); [EOL]             if (name == null) { [EOL]                 continue; [EOL]             } [EOL]             if (names == null) { [EOL]                 names = new ArrayList<String>(); [EOL]             } [EOL]             names.add(name.getSimpleName()); [EOL]             for (int p = 1; p < argCount; ++p) { [EOL]                 name = _annotationIntrospector.findNameForDeserialization(creator.getParameter(p)); [EOL]                 names.add((name == null) ? null : name.getSimpleName()); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (names == null) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     return names; [EOL] } <line_num>: 481,509
@Override [EOL] public Class<?> findPOJOBuilder() { [EOL]     return (_annotationIntrospector == null) ? null : _annotationIntrospector.findPOJOBuilder(_classInfo); [EOL] } <line_num>: 517,522
@Override [EOL] public JsonPOJOBuilder.Value findPOJOBuilderConfig() { [EOL]     return (_annotationIntrospector == null) ? null : _annotationIntrospector.findPOJOBuilderConfig(_classInfo); [EOL] } <line_num>: 524,529
@Override [EOL] public Converter<Object, Object> findDeserializationConverter() { [EOL]     if (_annotationIntrospector == null) { [EOL]         return null; [EOL]     } [EOL]     return _createConverter(_annotationIntrospector.findDeserializationConverter(_classInfo)); [EOL] } <line_num>: 531,538
public LinkedHashMap<String, AnnotatedField> _findPropertyFields(Collection<String> ignoredProperties, boolean forSerialization) { [EOL]     LinkedHashMap<String, AnnotatedField> results = new LinkedHashMap<String, AnnotatedField>(); [EOL]     for (BeanPropertyDefinition property : _properties) { [EOL]         AnnotatedField f = property.getField(); [EOL]         if (f != null) { [EOL]             String name = property.getName(); [EOL]             if (ignoredProperties != null) { [EOL]                 if (ignoredProperties.contains(name)) { [EOL]                     continue; [EOL]                 } [EOL]             } [EOL]             results.put(name, f); [EOL]         } [EOL]     } [EOL]     return results; [EOL] } <line_num>: 556,573
@SuppressWarnings("unchecked") [EOL] public Converter<Object, Object> _createConverter(Object converterDef) { [EOL]     if (converterDef == null) { [EOL]         return null; [EOL]     } [EOL]     if (converterDef instanceof Converter<?, ?>) { [EOL]         return (Converter<Object, Object>) converterDef; [EOL]     } [EOL]     if (!(converterDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Converter definition of type " + converterDef.getClass().getName() + "; expected type Converter or Class<Converter> instead"); [EOL]     } [EOL]     Class<?> converterClass = (Class<?>) converterDef; [EOL]     if (converterClass == Converter.None.class || converterClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!Converter.class.isAssignableFrom(converterClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + converterClass.getName() + "; expected Class<Converter>"); [EOL]     } [EOL]     HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]     Converter<?, ?> conv = (hi == null) ? null : hi.converterInstance(_config, _classInfo, converterClass); [EOL]     if (conv == null) { [EOL]         conv = (Converter<?, ?>) ClassUtil.createInstance(converterClass, _config.canOverrideAccessModifiers()); [EOL]     } [EOL]     return (Converter<Object, Object>) conv; [EOL] } <line_num>: 581,610
