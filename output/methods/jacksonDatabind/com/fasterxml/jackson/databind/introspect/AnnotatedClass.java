private AnnotatedClass(Class<?> cls, List<Class<?>> superTypes, AnnotationIntrospector aintr, MixInResolver mir, AnnotationMap classAnnotations) { [EOL]     _class = cls; [EOL]     _superTypes = superTypes; [EOL]     _annotationIntrospector = aintr; [EOL]     _mixInResolver = mir; [EOL]     _primaryMixIn = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(_class); [EOL]     _classAnnotations = classAnnotations; [EOL] } <line_num>: 111,122
@Override [EOL] public AnnotatedClass withAnnotations(AnnotationMap ann) { [EOL]     return new AnnotatedClass(_class, _superTypes, _annotationIntrospector, _mixInResolver, ann); [EOL] } <line_num>: 124,128
public static AnnotatedClass construct(Class<?> cls, AnnotationIntrospector aintr, MixInResolver mir) { [EOL]     return new AnnotatedClass(cls, ClassUtil.findSuperTypes(cls, null), aintr, mir, null); [EOL] } <line_num>: 135,140
public static AnnotatedClass constructWithoutSuperTypes(Class<?> cls, AnnotationIntrospector aintr, MixInResolver mir) { [EOL]     return new AnnotatedClass(cls, Collections.<Class<?>>emptyList(), aintr, mir, null); [EOL] } <line_num>: 147,152
@Override [EOL] public Class<?> getAnnotated() { [EOL]     return _class; [EOL] } <line_num>: 160,161
@Override [EOL] public int getModifiers() { [EOL]     return _class.getModifiers(); [EOL] } <line_num>: 163,164
@Override [EOL] public String getName() { [EOL]     return _class.getName(); [EOL] } <line_num>: 166,167
@Override [EOL] public <A extends Annotation> A getAnnotation(Class<A> acls) { [EOL]     if (_classAnnotations == null) { [EOL]         resolveClassAnnotations(); [EOL]     } [EOL]     return _classAnnotations.get(acls); [EOL] } <line_num>: 169,176
@Override [EOL] public Type getGenericType() { [EOL]     return _class; [EOL] } <line_num>: 178,181
@Override [EOL] public Class<?> getRawType() { [EOL]     return _class; [EOL] } <line_num>: 183,186
@Override [EOL] protected AnnotationMap getAllAnnotations() { [EOL]     if (_classAnnotations == null) { [EOL]         resolveClassAnnotations(); [EOL]     } [EOL]     return _classAnnotations; [EOL] } <line_num>: 188,194
public Annotations getAnnotations() { [EOL]     if (_classAnnotations == null) { [EOL]         resolveClassAnnotations(); [EOL]     } [EOL]     return _classAnnotations; [EOL] } <line_num>: 202,207
public boolean hasAnnotations() { [EOL]     if (_classAnnotations == null) { [EOL]         resolveClassAnnotations(); [EOL]     } [EOL]     return _classAnnotations.size() > 0; [EOL] } <line_num>: 209,214
public AnnotatedConstructor getDefaultConstructor() { [EOL]     if (!_creatorsResolved) { [EOL]         resolveCreators(); [EOL]     } [EOL]     return _defaultConstructor; [EOL] } <line_num>: 216,222
public List<AnnotatedConstructor> getConstructors() { [EOL]     if (!_creatorsResolved) { [EOL]         resolveCreators(); [EOL]     } [EOL]     return _constructors; [EOL] } <line_num>: 224,230
public List<AnnotatedMethod> getStaticMethods() { [EOL]     if (!_creatorsResolved) { [EOL]         resolveCreators(); [EOL]     } [EOL]     return _creatorMethods; [EOL] } <line_num>: 232,238
public Iterable<AnnotatedMethod> memberMethods() { [EOL]     if (_memberMethods == null) { [EOL]         resolveMemberMethods(); [EOL]     } [EOL]     return _memberMethods; [EOL] } <line_num>: 240,246
public int getMemberMethodCount() { [EOL]     if (_memberMethods == null) { [EOL]         resolveMemberMethods(); [EOL]     } [EOL]     return _memberMethods.size(); [EOL] } <line_num>: 248,254
public AnnotatedMethod findMethod(String name, Class<?>[] paramTypes) { [EOL]     if (_memberMethods == null) { [EOL]         resolveMemberMethods(); [EOL]     } [EOL]     return _memberMethods.find(name, paramTypes); [EOL] } <line_num>: 256,262
public int getFieldCount() { [EOL]     if (_fields == null) { [EOL]         resolveFields(); [EOL]     } [EOL]     return _fields.size(); [EOL] } <line_num>: 264,269
public Iterable<AnnotatedField> fields() { [EOL]     if (_fields == null) { [EOL]         resolveFields(); [EOL]     } [EOL]     return _fields; [EOL] } <line_num>: 271,277
private void resolveClassAnnotations() { [EOL]     _classAnnotations = new AnnotationMap(); [EOL]     if (_annotationIntrospector != null) { [EOL]         if (_primaryMixIn != null) { [EOL]             _addClassMixIns(_classAnnotations, _class, _primaryMixIn); [EOL]         } [EOL]         _addAnnotationsIfNotPresent(_classAnnotations, _class.getDeclaredAnnotations()); [EOL]         for (Class<?> cls : _superTypes) { [EOL]             _addClassMixIns(_classAnnotations, cls); [EOL]             _addAnnotationsIfNotPresent(_classAnnotations, cls.getDeclaredAnnotations()); [EOL]         } [EOL]         _addClassMixIns(_classAnnotations, Object.class); [EOL]     } [EOL] } <line_num>: 290,317
private void resolveCreators() { [EOL]     List<AnnotatedConstructor> constructors = null; [EOL]     Constructor<?>[] declaredCtors = _class.getDeclaredConstructors(); [EOL]     for (Constructor<?> ctor : declaredCtors) { [EOL]         if (ctor.getParameterTypes().length == 0) { [EOL]             _defaultConstructor = _constructConstructor(ctor, true); [EOL]         } else { [EOL]             if (constructors == null) { [EOL]                 constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length)); [EOL]             } [EOL]             constructors.add(_constructConstructor(ctor, false)); [EOL]         } [EOL]     } [EOL]     if (constructors == null) { [EOL]         _constructors = Collections.emptyList(); [EOL]     } else { [EOL]         _constructors = constructors; [EOL]     } [EOL]     if (_primaryMixIn != null) { [EOL]         if (_defaultConstructor != null || !_constructors.isEmpty()) { [EOL]             _addConstructorMixIns(_primaryMixIn); [EOL]         } [EOL]     } [EOL]     if (_annotationIntrospector != null) { [EOL]         if (_defaultConstructor != null) { [EOL]             if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) { [EOL]                 _defaultConstructor = null; [EOL]             } [EOL]         } [EOL]         if (_constructors != null) { [EOL]             for (int i = _constructors.size(); --i >= 0; ) { [EOL]                 if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) { [EOL]                     _constructors.remove(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     List<AnnotatedMethod> creatorMethods = null; [EOL]     for (Method m : _class.getDeclaredMethods()) { [EOL]         if (!Modifier.isStatic(m.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         if (creatorMethods == null) { [EOL]             creatorMethods = new ArrayList<AnnotatedMethod>(8); [EOL]         } [EOL]         creatorMethods.add(_constructCreatorMethod(m)); [EOL]     } [EOL]     if (creatorMethods == null) { [EOL]         _creatorMethods = Collections.emptyList(); [EOL]     } else { [EOL]         _creatorMethods = creatorMethods; [EOL]         if (_primaryMixIn != null) { [EOL]             _addFactoryMixIns(_primaryMixIn); [EOL]         } [EOL]         if (_annotationIntrospector != null) { [EOL]             for (int i = _creatorMethods.size(); --i >= 0; ) { [EOL]                 if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) { [EOL]                     _creatorMethods.remove(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     _creatorsResolved = true; [EOL] } <line_num>: 323,403
private void resolveMemberMethods() { [EOL]     _memberMethods = new AnnotatedMethodMap(); [EOL]     AnnotatedMethodMap mixins = new AnnotatedMethodMap(); [EOL]     _addMemberMethods(_class, _memberMethods, _primaryMixIn, mixins); [EOL]     for (Class<?> cls : _superTypes) { [EOL]         Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(cls); [EOL]         _addMemberMethods(cls, _memberMethods, mixin, mixins); [EOL]     } [EOL]     if (_mixInResolver != null) { [EOL]         Class<?> mixin = _mixInResolver.findMixInClassFor(Object.class); [EOL]         if (mixin != null) { [EOL]             _addMethodMixIns(_class, _memberMethods, mixin, mixins); [EOL]         } [EOL]     } [EOL]     if (_annotationIntrospector != null) { [EOL]         if (!mixins.isEmpty()) { [EOL]             Iterator<AnnotatedMethod> it = mixins.iterator(); [EOL]             while (it.hasNext()) { [EOL]                 AnnotatedMethod mixIn = it.next(); [EOL]                 try { [EOL]                     Method m = Object.class.getDeclaredMethod(mixIn.getName(), mixIn.getRawParameterTypes()); [EOL]                     if (m != null) { [EOL]                         AnnotatedMethod am = _constructMethod(m); [EOL]                         _addMixOvers(mixIn.getAnnotated(), am, false); [EOL]                         _memberMethods.add(am); [EOL]                     } [EOL]                 } catch (Exception e) { [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 411,453
private void resolveFields() { [EOL]     Map<String, AnnotatedField> foundFields = _findFields(_class, null); [EOL]     if (foundFields == null || foundFields.size() == 0) { [EOL]         _fields = Collections.emptyList(); [EOL]     } else { [EOL]         _fields = new ArrayList<AnnotatedField>(foundFields.size()); [EOL]         _fields.addAll(foundFields.values()); [EOL]     } [EOL] } <line_num>: 460,469
protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask) { [EOL]     if (_mixInResolver != null) { [EOL]         _addClassMixIns(annotations, toMask, _mixInResolver.findMixInClassFor(toMask)); [EOL]     } [EOL] } <line_num>: 483,488
protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask, Class<?> mixin) { [EOL]     if (mixin == null) { [EOL]         return; [EOL]     } [EOL]     _addAnnotationsIfNotPresent(annotations, mixin.getDeclaredAnnotations()); [EOL]     for (Class<?> parent : ClassUtil.findSuperTypes(mixin, toMask)) { [EOL]         _addAnnotationsIfNotPresent(annotations, parent.getDeclaredAnnotations()); [EOL]     } [EOL] } <line_num>: 490,509
protected void _addConstructorMixIns(Class<?> mixin) { [EOL]     MemberKey[] ctorKeys = null; [EOL]     int ctorCount = (_constructors == null) ? 0 : _constructors.size(); [EOL]     for (Constructor<?> ctor : mixin.getDeclaredConstructors()) { [EOL]         if (ctor.getParameterTypes().length == 0) { [EOL]             if (_defaultConstructor != null) { [EOL]                 _addMixOvers(ctor, _defaultConstructor, false); [EOL]             } [EOL]         } else { [EOL]             if (ctorKeys == null) { [EOL]                 ctorKeys = new MemberKey[ctorCount]; [EOL]                 for (int i = 0; i < ctorCount; ++i) { [EOL]                     ctorKeys[i] = new MemberKey(_constructors.get(i).getAnnotated()); [EOL]                 } [EOL]             } [EOL]             MemberKey key = new MemberKey(ctor); [EOL]             for (int i = 0; i < ctorCount; ++i) { [EOL]                 if (!key.equals(ctorKeys[i])) { [EOL]                     continue; [EOL]                 } [EOL]                 _addMixOvers(ctor, _constructors.get(i), true); [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 517,544
protected void _addFactoryMixIns(Class<?> mixin) { [EOL]     MemberKey[] methodKeys = null; [EOL]     int methodCount = _creatorMethods.size(); [EOL]     for (Method m : mixin.getDeclaredMethods()) { [EOL]         if (!Modifier.isStatic(m.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         if (m.getParameterTypes().length == 0) { [EOL]             continue; [EOL]         } [EOL]         if (methodKeys == null) { [EOL]             methodKeys = new MemberKey[methodCount]; [EOL]             for (int i = 0; i < methodCount; ++i) { [EOL]                 methodKeys[i] = new MemberKey(_creatorMethods.get(i).getAnnotated()); [EOL]             } [EOL]         } [EOL]         MemberKey key = new MemberKey(m); [EOL]         for (int i = 0; i < methodCount; ++i) { [EOL]             if (!key.equals(methodKeys[i])) { [EOL]                 continue; [EOL]             } [EOL]             _addMixOvers(m, _creatorMethods.get(i), true); [EOL]             break; [EOL]         } [EOL]     } [EOL] } <line_num>: 546,573
protected void _addMemberMethods(Class<?> cls, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns) { [EOL]     if (mixInCls != null) { [EOL]         _addMethodMixIns(cls, methods, mixInCls, mixIns); [EOL]     } [EOL]     if (cls == null) { [EOL]         return; [EOL]     } [EOL]     for (Method m : cls.getDeclaredMethods()) { [EOL]         if (!_isIncludableMemberMethod(m)) { [EOL]             continue; [EOL]         } [EOL]         AnnotatedMethod old = methods.find(m); [EOL]         if (old == null) { [EOL]             AnnotatedMethod newM = _constructMethod(m); [EOL]             methods.add(newM); [EOL]             old = mixIns.remove(m); [EOL]             if (old != null) { [EOL]                 _addMixOvers(old.getAnnotated(), newM, false); [EOL]             } [EOL]         } else { [EOL]             _addMixUnders(m, old); [EOL]             if (old.getDeclaringClass().isInterface() && !m.getDeclaringClass().isInterface()) { [EOL]                 methods.add(old.withMethod(m)); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 581,624
protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods, Class<?> mixInCls, AnnotatedMethodMap mixIns) { [EOL]     List<Class<?>> parents = new ArrayList<Class<?>>(); [EOL]     parents.add(mixInCls); [EOL]     ClassUtil.findSuperTypes(mixInCls, targetClass, parents); [EOL]     for (Class<?> mixin : parents) { [EOL]         for (Method m : mixin.getDeclaredMethods()) { [EOL]             if (!_isIncludableMemberMethod(m)) { [EOL]                 continue; [EOL]             } [EOL]             AnnotatedMethod am = methods.find(m); [EOL]             if (am != null) { [EOL]                 _addMixUnders(m, am); [EOL]             } else { [EOL]                 mixIns.add(_constructMethod(m)); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 626,653
protected Map<String, AnnotatedField> _findFields(Class<?> c, Map<String, AnnotatedField> fields) { [EOL]     Class<?> parent = c.getSuperclass(); [EOL]     if (parent != null) { [EOL]         fields = _findFields(parent, fields); [EOL]         for (Field f : c.getDeclaredFields()) { [EOL]             if (!_isIncludableField(f)) { [EOL]                 continue; [EOL]             } [EOL]             if (fields == null) { [EOL]                 fields = new LinkedHashMap<String, AnnotatedField>(); [EOL]             } [EOL]             fields.put(f.getName(), _constructField(f)); [EOL]         } [EOL]         if (_mixInResolver != null) { [EOL]             Class<?> mixin = _mixInResolver.findMixInClassFor(c); [EOL]             if (mixin != null) { [EOL]                 _addFieldMixIns(parent, mixin, fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     return fields; [EOL] } <line_num>: 661,699
protected void _addFieldMixIns(Class<?> targetClass, Class<?> mixInCls, Map<String, AnnotatedField> fields) { [EOL]     List<Class<?>> parents = new ArrayList<Class<?>>(); [EOL]     parents.add(mixInCls); [EOL]     ClassUtil.findSuperTypes(mixInCls, targetClass, parents); [EOL]     for (Class<?> mixin : parents) { [EOL]         for (Field mixinField : mixin.getDeclaredFields()) { [EOL]             if (!_isIncludableField(mixinField)) { [EOL]                 continue; [EOL]             } [EOL]             String name = mixinField.getName(); [EOL]             AnnotatedField maskedField = fields.get(name); [EOL]             if (maskedField != null) { [EOL]                 _addOrOverrideAnnotations(maskedField, mixinField.getDeclaredAnnotations()); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 706,726
protected AnnotatedMethod _constructMethod(Method m) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedMethod(m, _emptyAnnotationMap(), null); [EOL]     } [EOL]     return new AnnotatedMethod(m, _collectRelevantAnnotations(m.getDeclaredAnnotations()), null); [EOL] } <line_num>: 734,744
protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length)); [EOL]     } [EOL]     if (defaultCtor) { [EOL]         return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null); [EOL]     } [EOL]     Annotation[][] paramAnns = ctor.getParameterAnnotations(); [EOL]     int paramCount = ctor.getParameterTypes().length; [EOL]     AnnotationMap[] resolvedAnnotations = null; [EOL]     if (paramCount != paramAnns.length) { [EOL]         Class<?> dc = ctor.getDeclaringClass(); [EOL]         if (dc.isEnum() && (paramCount == paramAnns.length + 2)) { [EOL]             Annotation[][] old = paramAnns; [EOL]             paramAnns = new Annotation[old.length + 2][]; [EOL]             System.arraycopy(old, 0, paramAnns, 2, old.length); [EOL]             resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]         } else if (dc.isMemberClass()) { [EOL]             if (paramCount == (paramAnns.length + 1)) { [EOL]                 Annotation[][] old = paramAnns; [EOL]                 paramAnns = new Annotation[old.length + 1][]; [EOL]                 System.arraycopy(old, 0, paramAnns, 1, old.length); [EOL]                 resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]             } [EOL]         } [EOL]         if (resolvedAnnotations == null) { [EOL]             throw new IllegalStateException("Internal error: constructor for " + ctor.getDeclaringClass().getName() + " has mismatch: " + paramCount + " parameters; " + paramAnns.length + " sets of annotations"); [EOL]         } [EOL]     } else { [EOL]         resolvedAnnotations = _collectRelevantAnnotations(paramAnns); [EOL]     } [EOL]     return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), resolvedAnnotations); [EOL] } <line_num>: 746,792
protected AnnotatedMethod _constructCreatorMethod(Method m) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedMethod(m, _emptyAnnotationMap(), _emptyAnnotationMaps(m.getParameterTypes().length)); [EOL]     } [EOL]     return new AnnotatedMethod(m, _collectRelevantAnnotations(m.getDeclaredAnnotations()), _collectRelevantAnnotations(m.getParameterAnnotations())); [EOL] } <line_num>: 794,801
protected AnnotatedField _constructField(Field f) { [EOL]     if (_annotationIntrospector == null) { [EOL]         return new AnnotatedField(f, _emptyAnnotationMap()); [EOL]     } [EOL]     return new AnnotatedField(f, _collectRelevantAnnotations(f.getDeclaredAnnotations())); [EOL] } <line_num>: 803,809
private AnnotationMap _emptyAnnotationMap() { [EOL]     return new AnnotationMap(); [EOL] } <line_num>: 811,813
private AnnotationMap[] _emptyAnnotationMaps(int count) { [EOL]     if (count == 0) { [EOL]         return NO_ANNOTATION_MAPS; [EOL]     } [EOL]     AnnotationMap[] maps = new AnnotationMap[count]; [EOL]     for (int i = 0; i < count; ++i) { [EOL]         maps[i] = _emptyAnnotationMap(); [EOL]     } [EOL]     return maps; [EOL] } <line_num>: 815,824
protected boolean _isIncludableMemberMethod(Method m) { [EOL]     if (Modifier.isStatic(m.getModifiers())) { [EOL]         return false; [EOL]     } [EOL]     if (m.isSynthetic() || m.isBridge()) { [EOL]         return false; [EOL]     } [EOL]     int pcount = m.getParameterTypes().length; [EOL]     return (pcount <= 2); [EOL] } <line_num>: 832,847
private boolean _isIncludableField(Field f) { [EOL]     if (f.isSynthetic()) { [EOL]         return false; [EOL]     } [EOL]     int mods = f.getModifiers(); [EOL]     if (Modifier.isStatic(mods) || Modifier.isTransient(mods)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } <line_num>: 849,863
protected AnnotationMap[] _collectRelevantAnnotations(Annotation[][] anns) { [EOL]     int len = anns.length; [EOL]     AnnotationMap[] result = new AnnotationMap[len]; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         result[i] = _collectRelevantAnnotations(anns[i]); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 871,879
protected AnnotationMap _collectRelevantAnnotations(Annotation[] anns) { [EOL]     AnnotationMap annMap = new AnnotationMap(); [EOL]     _addAnnotationsIfNotPresent(annMap, anns); [EOL]     return annMap; [EOL] } <line_num>: 881,886
private void _addAnnotationsIfNotPresent(AnnotationMap result, Annotation[] anns) { [EOL]     if (anns != null) { [EOL]         List<Annotation[]> bundles = null; [EOL]         for (Annotation ann : anns) { [EOL]             if (_isAnnotationBundle(ann)) { [EOL]                 if (bundles == null) { [EOL]                     bundles = new LinkedList<Annotation[]>(); [EOL]                 } [EOL]                 bundles.add(ann.annotationType().getDeclaredAnnotations()); [EOL]             } else { [EOL]                 result.addIfNotPresent(ann); [EOL]             } [EOL]         } [EOL]         if (bundles != null) { [EOL]             for (Annotation[] annotations : bundles) { [EOL]                 _addAnnotationsIfNotPresent(result, annotations); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 892,912
private void _addAnnotationsIfNotPresent(AnnotatedMember target, Annotation[] anns) { [EOL]     if (anns != null) { [EOL]         List<Annotation[]> bundles = null; [EOL]         for (Annotation ann : anns) { [EOL]             if (_isAnnotationBundle(ann)) { [EOL]                 if (bundles == null) { [EOL]                     bundles = new LinkedList<Annotation[]>(); [EOL]                 } [EOL]                 bundles.add(ann.annotationType().getDeclaredAnnotations()); [EOL]             } else { [EOL]                 target.addIfNotPresent(ann); [EOL]             } [EOL]         } [EOL]         if (bundles != null) { [EOL]             for (Annotation[] annotations : bundles) { [EOL]                 _addAnnotationsIfNotPresent(target, annotations); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 914,934
private void _addOrOverrideAnnotations(AnnotatedMember target, Annotation[] anns) { [EOL]     if (anns != null) { [EOL]         List<Annotation[]> bundles = null; [EOL]         for (Annotation ann : anns) { [EOL]             if (_isAnnotationBundle(ann)) { [EOL]                 if (bundles == null) { [EOL]                     bundles = new LinkedList<Annotation[]>(); [EOL]                 } [EOL]                 bundles.add(ann.annotationType().getDeclaredAnnotations()); [EOL]             } else { [EOL]                 target.addOrOverride(ann); [EOL]             } [EOL]         } [EOL]         if (bundles != null) { [EOL]             for (Annotation[] annotations : bundles) { [EOL]                 _addOrOverrideAnnotations(target, annotations); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 936,956
protected void _addMixOvers(Constructor<?> mixin, AnnotatedConstructor target, boolean addParamAnnotations) { [EOL]     _addOrOverrideAnnotations(target, mixin.getDeclaredAnnotations()); [EOL]     if (addParamAnnotations) { [EOL]         Annotation[][] pa = mixin.getParameterAnnotations(); [EOL]         for (int i = 0, len = pa.length; i < len; ++i) { [EOL]             for (Annotation a : pa[i]) { [EOL]                 target.addOrOverrideParam(i, a); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 962,974
protected void _addMixOvers(Method mixin, AnnotatedMethod target, boolean addParamAnnotations) { [EOL]     _addOrOverrideAnnotations(target, mixin.getDeclaredAnnotations()); [EOL]     if (addParamAnnotations) { [EOL]         Annotation[][] pa = mixin.getParameterAnnotations(); [EOL]         for (int i = 0, len = pa.length; i < len; ++i) { [EOL]             for (Annotation a : pa[i]) { [EOL]                 target.addOrOverrideParam(i, a); [EOL]             } [EOL]         } [EOL]     } [EOL] } <line_num>: 980,992
protected void _addMixUnders(Method src, AnnotatedMethod target) { [EOL]     _addAnnotationsIfNotPresent(target, src.getDeclaredAnnotations()); [EOL] } <line_num>: 998,1000
private final boolean _isAnnotationBundle(Annotation ann) { [EOL]     return (_annotationIntrospector != null) && _annotationIntrospector.isAnnotationBundle(ann); [EOL] } <line_num>: 1002,1005
@Override [EOL] public String toString() { [EOL]     return "[AnnotedClass " + _class.getName() + "]"; [EOL] } <line_num>: 1013,1017
