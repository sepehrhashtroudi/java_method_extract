public <T> SimpleAbstractTypeResolver addMapping(Class<T> superType, Class<? extends T> subType) { [EOL]     if (superType == subType) { [EOL]         throw new IllegalArgumentException("Can not add mapping from class to itself"); [EOL]     } [EOL]     if (!superType.isAssignableFrom(subType)) { [EOL]         throw new IllegalArgumentException("Can not add mapping from class " + superType.getName() + " to " + subType.getName() + ", as latter is not a subtype of former"); [EOL]     } [EOL]     if (!Modifier.isAbstract(superType.getModifiers())) { [EOL]         throw new IllegalArgumentException("Can not add mapping from class " + superType.getName() + " since it is not abstract"); [EOL]     } [EOL]     _mappings.put(new ClassKey(superType), subType); [EOL]     return this; [EOL] } <line_num>: 52,68
@Override [EOL] public JavaType findTypeMapping(DeserializationConfig config, JavaType type) { [EOL]     Class<?> src = type.getRawClass(); [EOL]     Class<?> dst = _mappings.get(new ClassKey(src)); [EOL]     if (dst == null) { [EOL]         return null; [EOL]     } [EOL]     return type.narrowBy(dst); [EOL] } <line_num>: 70,80
@Override [EOL] public JavaType resolveAbstractType(DeserializationConfig config, JavaType type) { [EOL]     return null; [EOL] } <line_num>: 83,88
