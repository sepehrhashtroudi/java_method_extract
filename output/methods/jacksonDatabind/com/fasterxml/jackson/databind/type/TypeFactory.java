private TypeFactory() { [EOL]     _parser = new TypeParser(this); [EOL]     _modifiers = null; [EOL] } <line_num>: 107,110
protected TypeFactory(TypeParser p, TypeModifier[] mods) { [EOL]     _parser = p; [EOL]     _modifiers = mods; [EOL] } <line_num>: 112,115
public TypeFactory withModifier(TypeModifier mod) { [EOL]     if (_modifiers == null) { [EOL]         return new TypeFactory(_parser, new TypeModifier[] { mod }); [EOL]     } [EOL]     return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod)); [EOL] } <line_num>: 117,123
public static TypeFactory defaultInstance() { [EOL]     return instance; [EOL] } <line_num>: 130,130
public static JavaType unknownType() { [EOL]     return defaultInstance()._unknownType(); [EOL] } <line_num>: 143,145
public static Class<?> rawClass(Type t) { [EOL]     if (t instanceof Class<?>) { [EOL]         return (Class<?>) t; [EOL]     } [EOL]     return defaultInstance().constructType(t).getRawClass(); [EOL] } <line_num>: 153,159
public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) { [EOL]     if (baseType instanceof SimpleType) { [EOL]         if (subclass.isArray() || Map.class.isAssignableFrom(subclass) || Collection.class.isAssignableFrom(subclass)) { [EOL]             if (!baseType.getRawClass().isAssignableFrom(subclass)) { [EOL]                 throw new IllegalArgumentException("Class " + subclass.getClass().getName() + " not subtype of " + baseType); [EOL]             } [EOL]             JavaType subtype = _fromClass(subclass, new TypeBindings(this, baseType.getRawClass())); [EOL]             Object h = baseType.getValueHandler(); [EOL]             if (h != null) { [EOL]                 subtype = subtype.withValueHandler(h); [EOL]             } [EOL]             h = baseType.getTypeHandler(); [EOL]             if (h != null) { [EOL]                 subtype = subtype.withTypeHandler(h); [EOL]             } [EOL]             return subtype; [EOL]         } [EOL]     } [EOL]     return baseType.narrowBy(subclass); [EOL] } <line_num>: 174,202
public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException { [EOL]     return _parser.parse(canonical); [EOL] } <line_num>: 214,217
public JavaType[] findTypeParameters(JavaType type, Class<?> expType) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == expType) { [EOL]         int count = type.containedTypeCount(); [EOL]         if (count == 0) [EOL]             return null; [EOL]         JavaType[] result = new JavaType[count]; [EOL]         for (int i = 0; i < count; ++i) { [EOL]             result[i] = type.containedType(i); [EOL]         } [EOL]         return result; [EOL]     } [EOL]     return findTypeParameters(raw, expType, new TypeBindings(this, type)); [EOL] } <line_num>: 228,256
public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) { [EOL]     return findTypeParameters(clz, expType, new TypeBindings(this, clz)); [EOL] } <line_num>: 258,260
public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings) { [EOL]     HierarchicType subType = _findSuperTypeChain(clz, expType); [EOL]     if (subType == null) { [EOL]         throw new IllegalArgumentException("Class " + clz.getName() + " is not a subtype of " + expType.getName()); [EOL]     } [EOL]     HierarchicType superType = subType; [EOL]     while (superType.getSuperType() != null) { [EOL]         superType = superType.getSuperType(); [EOL]         Class<?> raw = superType.getRawClass(); [EOL]         TypeBindings newBindings = new TypeBindings(this, raw); [EOL]         if (superType.isGeneric()) { [EOL]             ParameterizedType pt = superType.asGeneric(); [EOL]             Type[] actualTypes = pt.getActualTypeArguments(); [EOL]             TypeVariable<?>[] vars = raw.getTypeParameters(); [EOL]             int len = actualTypes.length; [EOL]             for (int i = 0; i < len; ++i) { [EOL]                 String name = vars[i].getName(); [EOL]                 JavaType type = _constructType(actualTypes[i], bindings); [EOL]                 newBindings.addBinding(name, type); [EOL]             } [EOL]         } [EOL]         bindings = newBindings; [EOL]     } [EOL]     if (!superType.isGeneric()) { [EOL]         return null; [EOL]     } [EOL]     return bindings.typesAsArray(); [EOL] } <line_num>: 262,295
public JavaType moreSpecificType(JavaType type1, JavaType type2) { [EOL]     if (type1 == null) { [EOL]         return type2; [EOL]     } [EOL]     if (type2 == null) { [EOL]         return type1; [EOL]     } [EOL]     Class<?> raw1 = type1.getRawClass(); [EOL]     Class<?> raw2 = type2.getRawClass(); [EOL]     if (raw1 == raw2) { [EOL]         return type1; [EOL]     } [EOL]     if (raw1.isAssignableFrom(raw2)) { [EOL]         return type2; [EOL]     } [EOL]     return type1; [EOL] } <line_num>: 307,325
public JavaType constructType(Type type) { [EOL]     return _constructType(type, null); [EOL] } <line_num>: 333,335
public JavaType constructType(Type type, TypeBindings bindings) { [EOL]     return _constructType(type, bindings); [EOL] } <line_num>: 337,339
public JavaType constructType(TypeReference<?> typeRef) { [EOL]     return _constructType(typeRef.getType(), null); [EOL] } <line_num>: 341,343
public JavaType constructType(Type type, Class<?> context) { [EOL]     TypeBindings b = (context == null) ? null : new TypeBindings(this, context); [EOL]     return _constructType(type, b); [EOL] } <line_num>: 345,348
public JavaType constructType(Type type, JavaType context) { [EOL]     TypeBindings b = (context == null) ? null : new TypeBindings(this, context); [EOL]     return _constructType(type, b); [EOL] } <line_num>: 350,353
protected JavaType _constructType(Type type, TypeBindings context) { [EOL]     JavaType resultType; [EOL]     if (type instanceof Class<?>) { [EOL]         Class<?> cls = (Class<?>) type; [EOL]         resultType = _fromClass(cls, context); [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         resultType = _fromParamType((ParameterizedType) type, context); [EOL]     } else if (type instanceof JavaType) { [EOL]         return (JavaType) type; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         resultType = _fromArrayType((GenericArrayType) type, context); [EOL]     } else if (type instanceof TypeVariable<?>) { [EOL]         resultType = _fromVariable((TypeVariable<?>) type, context); [EOL]     } else if (type instanceof WildcardType) { [EOL]         resultType = _fromWildcard((WildcardType) type, context); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Unrecognized Type: " + ((type == null) ? "[null]" : type.toString())); [EOL]     } [EOL]     if (_modifiers != null && !resultType.isContainerType()) { [EOL]         for (TypeModifier mod : _modifiers) { [EOL]             resultType = mod.modifyType(resultType, type, context, this); [EOL]         } [EOL]     } [EOL]     return resultType; [EOL] } <line_num>: 360,398
public ArrayType constructArrayType(Class<?> elementType) { [EOL]     return ArrayType.construct(_constructType(elementType, null), null, null); [EOL] } <line_num>: 412,414
public ArrayType constructArrayType(JavaType elementType) { [EOL]     return ArrayType.construct(elementType, null, null); [EOL] } <line_num>: 422,424
public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) { [EOL]     return CollectionType.construct(collectionClass, constructType(elementClass)); [EOL] } <line_num>: 432,434
public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) { [EOL]     return CollectionType.construct(collectionClass, elementType); [EOL] } <line_num>: 442,444
public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) { [EOL]     return CollectionLikeType.construct(collectionClass, constructType(elementClass)); [EOL] } <line_num>: 452,454
public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) { [EOL]     return CollectionLikeType.construct(collectionClass, elementType); [EOL] } <line_num>: 462,464
public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) { [EOL]     return MapType.construct(mapClass, keyType, valueType); [EOL] } <line_num>: 472,474
public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) { [EOL]     return MapType.construct(mapClass, constructType(keyClass), constructType(valueClass)); [EOL] } <line_num>: 482,484
public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) { [EOL]     return MapLikeType.construct(mapClass, keyType, valueType); [EOL] } <line_num>: 492,494
public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) { [EOL]     return MapType.construct(mapClass, constructType(keyClass), constructType(valueClass)); [EOL] } <line_num>: 502,504
public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) { [EOL]     TypeVariable<?>[] typeVars = rawType.getTypeParameters(); [EOL]     if (typeVars.length != parameterTypes.length) { [EOL]         throw new IllegalArgumentException("Parameter type mismatch for " + rawType.getName() + ": expected " + typeVars.length + " parameters, was given " + parameterTypes.length); [EOL]     } [EOL]     String[] names = new String[typeVars.length]; [EOL]     for (int i = 0, len = typeVars.length; i < len; ++i) { [EOL]         names[i] = typeVars[i].getName(); [EOL]     } [EOL]     JavaType resultType = new SimpleType(rawType, names, parameterTypes, null, null, false); [EOL]     return resultType; [EOL] } <line_num>: 509,523
public JavaType uncheckedSimpleType(Class<?> cls) { [EOL]     return new SimpleType(cls); [EOL] } <line_num>: 532,534
public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) { [EOL]     int len = parameterClasses.length; [EOL]     JavaType[] pt = new JavaType[len]; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         pt[i] = _fromClass(parameterClasses[i], null); [EOL]     } [EOL]     return constructParametricType(parametrized, pt); [EOL] } <line_num>: 548,556
public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes) { [EOL]     JavaType resultType; [EOL]     if (parametrized.isArray()) { [EOL]         if (parameterTypes.length != 1) { [EOL]             throw new IllegalArgumentException("Need exactly 1 parameter type for arrays (" + parametrized.getName() + ")"); [EOL]         } [EOL]         resultType = constructArrayType(parameterTypes[0]); [EOL]     } else if (Map.class.isAssignableFrom(parametrized)) { [EOL]         if (parameterTypes.length != 2) { [EOL]             throw new IllegalArgumentException("Need exactly 2 parameter types for Map types (" + parametrized.getName() + ")"); [EOL]         } [EOL]         resultType = constructMapType((Class<Map<?, ?>>) parametrized, parameterTypes[0], parameterTypes[1]); [EOL]     } else if (Collection.class.isAssignableFrom(parametrized)) { [EOL]         if (parameterTypes.length != 1) { [EOL]             throw new IllegalArgumentException("Need exactly 1 parameter type for Collection types (" + parametrized.getName() + ")"); [EOL]         } [EOL]         resultType = constructCollectionType((Class<Collection<?>>) parametrized, parameterTypes[0]); [EOL]     } else { [EOL]         resultType = constructSimpleType(parametrized, parameterTypes); [EOL]     } [EOL]     return resultType; [EOL] } <line_num>: 571,598
public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) { [EOL]     return CollectionType.construct(collectionClass, unknownType()); [EOL] } <line_num>: 618,620
public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) { [EOL]     return CollectionLikeType.construct(collectionClass, unknownType()); [EOL] } <line_num>: 633,635
public MapType constructRawMapType(Class<? extends Map> mapClass) { [EOL]     return MapType.construct(mapClass, unknownType(), unknownType()); [EOL] } <line_num>: 648,650
public MapLikeType constructRawMapLikeType(Class<?> mapClass) { [EOL]     return MapLikeType.construct(mapClass, unknownType(), unknownType()); [EOL] } <line_num>: 663,665
protected JavaType _fromClass(Class<?> clz, TypeBindings context) { [EOL]     if (clz == String.class) [EOL]         return CORE_TYPE_STRING; [EOL]     if (clz == Boolean.TYPE) [EOL]         return CORE_TYPE_BOOL; [EOL]     if (clz == Integer.TYPE) [EOL]         return CORE_TYPE_INT; [EOL]     if (clz == Long.TYPE) [EOL]         return CORE_TYPE_LONG; [EOL]     ClassKey key = new ClassKey(clz); [EOL]     JavaType result; [EOL]     synchronized (_typeCache) { [EOL]         result = _typeCache.get(key); [EOL]     } [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (clz.isArray()) { [EOL]         result = ArrayType.construct(_constructType(clz.getComponentType(), null), null, null); [EOL]     } else if (clz.isEnum()) { [EOL]         result = new SimpleType(clz); [EOL]     } else if (Map.class.isAssignableFrom(clz)) { [EOL]         result = _mapType(clz); [EOL]     } else if (Collection.class.isAssignableFrom(clz)) { [EOL]         result = _collectionType(clz); [EOL]     } else { [EOL]         result = new SimpleType(clz); [EOL]     } [EOL]     synchronized (_typeCache) { [EOL]         _typeCache.put(key, result); [EOL]     } [EOL]     return result; [EOL] } <line_num>: 677,728
protected JavaType _fromParameterizedClass(Class<?> clz, List<JavaType> paramTypes) { [EOL]     if (clz.isArray()) { [EOL]         return ArrayType.construct(_constructType(clz.getComponentType(), null), null, null); [EOL]     } [EOL]     if (clz.isEnum()) { [EOL]         return new SimpleType(clz); [EOL]     } [EOL]     if (Map.class.isAssignableFrom(clz)) { [EOL]         JavaType keyType, contentType; [EOL]         if (paramTypes.size() > 0) { [EOL]             keyType = paramTypes.get(0); [EOL]             contentType = (paramTypes.size() >= 2) ? paramTypes.get(1) : _unknownType(); [EOL]             return MapType.construct(clz, keyType, contentType); [EOL]         } [EOL]         return _mapType(clz); [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(clz)) { [EOL]         if (paramTypes.size() >= 1) { [EOL]             return CollectionType.construct(clz, paramTypes.get(0)); [EOL]         } [EOL]         return _collectionType(clz); [EOL]     } [EOL]     if (paramTypes.size() == 0) { [EOL]         return new SimpleType(clz); [EOL]     } [EOL]     JavaType[] pt = paramTypes.toArray(new JavaType[paramTypes.size()]); [EOL]     return constructSimpleType(clz, pt); [EOL] } <line_num>: 734,764
protected JavaType _fromParamType(ParameterizedType type, TypeBindings context) { [EOL]     Class<?> rawType = (Class<?>) type.getRawType(); [EOL]     Type[] args = type.getActualTypeArguments(); [EOL]     int paramCount = (args == null) ? 0 : args.length; [EOL]     JavaType[] pt; [EOL]     if (paramCount == 0) { [EOL]         pt = NO_TYPES; [EOL]     } else { [EOL]         pt = new JavaType[paramCount]; [EOL]         for (int i = 0; i < paramCount; ++i) { [EOL]             pt[i] = _constructType(args[i], context); [EOL]         } [EOL]     } [EOL]     if (Map.class.isAssignableFrom(rawType)) { [EOL]         JavaType subtype = constructSimpleType(rawType, pt); [EOL]         JavaType[] mapParams = findTypeParameters(subtype, Map.class); [EOL]         if (mapParams.length != 2) { [EOL]             throw new IllegalArgumentException("Could not find 2 type parameters for Map class " + rawType.getName() + " (found " + mapParams.length + ")"); [EOL]         } [EOL]         return MapType.construct(rawType, mapParams[0], mapParams[1]); [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(rawType)) { [EOL]         JavaType subtype = constructSimpleType(rawType, pt); [EOL]         JavaType[] collectionParams = findTypeParameters(subtype, Collection.class); [EOL]         if (collectionParams.length != 1) { [EOL]             throw new IllegalArgumentException("Could not find 1 type parameter for Collection class " + rawType.getName() + " (found " + collectionParams.length + ")"); [EOL]         } [EOL]         return CollectionType.construct(rawType, collectionParams[0]); [EOL]     } [EOL]     if (paramCount == 0) { [EOL]         return new SimpleType(rawType); [EOL]     } [EOL]     return constructSimpleType(rawType, pt); [EOL] } <line_num>: 770,814
protected JavaType _fromArrayType(GenericArrayType type, TypeBindings context) { [EOL]     JavaType compType = _constructType(type.getGenericComponentType(), context); [EOL]     return ArrayType.construct(compType, null, null); [EOL] } <line_num>: 817,821
protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context) { [EOL]     if (context == null) { [EOL]         return _unknownType(); [EOL]     } [EOL]     String name = type.getName(); [EOL]     JavaType actualType = context.findType(name); [EOL]     if (actualType != null) { [EOL]         return actualType; [EOL]     } [EOL]     Type[] bounds = type.getBounds(); [EOL]     context._addPlaceholder(name); [EOL]     return _constructType(bounds[0], context); [EOL] } <line_num>: 823,862
protected JavaType _fromWildcard(WildcardType type, TypeBindings context) { [EOL]     return _constructType(type.getUpperBounds()[0], context); [EOL] } <line_num>: 864,875
private JavaType _mapType(Class<?> rawClass) { [EOL]     JavaType[] typeParams = findTypeParameters(rawClass, Map.class); [EOL]     if (typeParams == null) { [EOL]         return MapType.construct(rawClass, _unknownType(), _unknownType()); [EOL]     } [EOL]     if (typeParams.length != 2) { [EOL]         throw new IllegalArgumentException("Strange Map type " + rawClass.getName() + ": can not determine type parameters"); [EOL]     } [EOL]     return MapType.construct(rawClass, typeParams[0], typeParams[1]); [EOL] } <line_num>: 877,889
private JavaType _collectionType(Class<?> rawClass) { [EOL]     JavaType[] typeParams = findTypeParameters(rawClass, Collection.class); [EOL]     if (typeParams == null) { [EOL]         return CollectionType.construct(rawClass, _unknownType()); [EOL]     } [EOL]     if (typeParams.length != 1) { [EOL]         throw new IllegalArgumentException("Strange Collection type " + rawClass.getName() + ": can not determine type parameters"); [EOL]     } [EOL]     return CollectionType.construct(rawClass, typeParams[0]); [EOL] } <line_num>: 891,903
protected JavaType _resolveVariableViaSubTypes(HierarchicType leafType, String variableName, TypeBindings bindings) { [EOL]     if (leafType != null && leafType.isGeneric()) { [EOL]         TypeVariable<?>[] typeVariables = leafType.getRawClass().getTypeParameters(); [EOL]         for (int i = 0, len = typeVariables.length; i < len; ++i) { [EOL]             TypeVariable<?> tv = typeVariables[i]; [EOL]             if (variableName.equals(tv.getName())) { [EOL]                 Type type = leafType.asGeneric().getActualTypeArguments()[i]; [EOL]                 if (type instanceof TypeVariable<?>) { [EOL]                     return _resolveVariableViaSubTypes(leafType.getSubType(), ((TypeVariable<?>) type).getName(), bindings); [EOL]                 } [EOL]                 return _constructType(type, bindings); [EOL]             } [EOL]         } [EOL]     } [EOL]     return _unknownType(); [EOL] } <line_num>: 905,924
protected JavaType _unknownType() { [EOL]     return new SimpleType(Object.class); [EOL] } <line_num>: 926,928
protected HierarchicType _findSuperTypeChain(Class<?> subtype, Class<?> supertype) { [EOL]     if (supertype.isInterface()) { [EOL]         return _findSuperInterfaceChain(subtype, supertype); [EOL]     } [EOL]     return _findSuperClassChain(subtype, supertype); [EOL] } <line_num>: 942,949
protected HierarchicType _findSuperClassChain(Type currentType, Class<?> target) { [EOL]     HierarchicType current = new HierarchicType(currentType); [EOL]     Class<?> raw = current.getRawClass(); [EOL]     if (raw == target) { [EOL]         return current; [EOL]     } [EOL]     Type parent = raw.getGenericSuperclass(); [EOL]     if (parent != null) { [EOL]         HierarchicType sup = _findSuperClassChain(parent, target); [EOL]         if (sup != null) { [EOL]             sup.setSubType(current); [EOL]             current.setSuperType(sup); [EOL]             return current; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 951,969
protected HierarchicType _findSuperInterfaceChain(Type currentType, Class<?> target) { [EOL]     HierarchicType current = new HierarchicType(currentType); [EOL]     Class<?> raw = current.getRawClass(); [EOL]     if (raw == target) { [EOL]         return new HierarchicType(currentType); [EOL]     } [EOL]     if (raw == HashMap.class) { [EOL]         if (target == Map.class) { [EOL]             return _hashMapSuperInterfaceChain(current); [EOL]         } [EOL]     } [EOL]     if (raw == ArrayList.class) { [EOL]         if (target == List.class) { [EOL]             return _arrayListSuperInterfaceChain(current); [EOL]         } [EOL]     } [EOL]     return _doFindSuperInterfaceChain(current, target); [EOL] } <line_num>: 971,993
protected HierarchicType _doFindSuperInterfaceChain(HierarchicType current, Class<?> target) { [EOL]     Class<?> raw = current.getRawClass(); [EOL]     Type[] parents = raw.getGenericInterfaces(); [EOL]     if (parents != null) { [EOL]         for (Type parent : parents) { [EOL]             HierarchicType sup = _findSuperInterfaceChain(parent, target); [EOL]             if (sup != null) { [EOL]                 sup.setSubType(current); [EOL]                 current.setSuperType(sup); [EOL]                 return current; [EOL]             } [EOL]         } [EOL]     } [EOL]     Type parent = raw.getGenericSuperclass(); [EOL]     if (parent != null) { [EOL]         HierarchicType sup = _findSuperInterfaceChain(parent, target); [EOL]         if (sup != null) { [EOL]             sup.setSubType(current); [EOL]             current.setSuperType(sup); [EOL]             return current; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 995,1022
protected synchronized HierarchicType _hashMapSuperInterfaceChain(HierarchicType current) { [EOL]     if (_cachedHashMapType == null) { [EOL]         HierarchicType base = current.deepCloneWithoutSubtype(); [EOL]         _doFindSuperInterfaceChain(base, Map.class); [EOL]         _cachedHashMapType = base.getSuperType(); [EOL]     } [EOL]     HierarchicType t = _cachedHashMapType.deepCloneWithoutSubtype(); [EOL]     current.setSuperType(t); [EOL]     t.setSubType(current); [EOL]     return current; [EOL] } <line_num>: 1024,1035
protected synchronized HierarchicType _arrayListSuperInterfaceChain(HierarchicType current) { [EOL]     if (_cachedArrayListType == null) { [EOL]         HierarchicType base = current.deepCloneWithoutSubtype(); [EOL]         _doFindSuperInterfaceChain(base, List.class); [EOL]         _cachedArrayListType = base.getSuperType(); [EOL]     } [EOL]     HierarchicType t = _cachedArrayListType.deepCloneWithoutSubtype(); [EOL]     current.setSuperType(t); [EOL]     t.setSubType(current); [EOL]     return current; [EOL] } <line_num>: 1037,1048
