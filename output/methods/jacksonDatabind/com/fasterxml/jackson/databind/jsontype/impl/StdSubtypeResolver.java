public StdSubtypeResolver() { [EOL] } <line_num>: 23,23
@Override [EOL] public void registerSubtypes(NamedType... types) { [EOL]     if (_registeredSubtypes == null) { [EOL]         _registeredSubtypes = new LinkedHashSet<NamedType>(); [EOL]     } [EOL]     for (NamedType type : types) { [EOL]         _registeredSubtypes.add(type); [EOL]     } [EOL] } <line_num>: 31,40
@Override [EOL] public void registerSubtypes(Class<?>... classes) { [EOL]     NamedType[] types = new NamedType[classes.length]; [EOL]     for (int i = 0, len = classes.length; i < len; ++i) { [EOL]         types[i] = new NamedType(classes[i]); [EOL]     } [EOL]     registerSubtypes(types); [EOL] } <line_num>: 42,50
@Deprecated [EOL] @Override [EOL] public Collection<NamedType> collectAndResolveSubtypes(AnnotatedMember property, MapperConfig<?> config, AnnotationIntrospector ai) { [EOL]     return collectAndResolveSubtypes(property, config, ai, null); [EOL] } <line_num>: 55,61
@Override [EOL] public Collection<NamedType> collectAndResolveSubtypes(AnnotatedMember property, MapperConfig<?> config, AnnotationIntrospector ai, JavaType baseType) { [EOL]     Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass(); [EOL]     HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>(); [EOL]     if (_registeredSubtypes != null) { [EOL]         for (NamedType subtype : _registeredSubtypes) { [EOL]             if (rawBase.isAssignableFrom(subtype.getType())) { [EOL]                 AnnotatedClass curr = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config); [EOL]                 _collectAndResolve(curr, subtype, config, ai, collected); [EOL]             } [EOL]         } [EOL]     } [EOL]     Collection<NamedType> st = ai.findSubtypes(property); [EOL]     if (st != null) { [EOL]         for (NamedType nt : st) { [EOL]             AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(nt.getType(), ai, config); [EOL]             _collectAndResolve(ac, nt, config, ai, collected); [EOL]         } [EOL]     } [EOL]     NamedType rootType = new NamedType(rawBase, null); [EOL]     AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(rawBase, ai, config); [EOL]     _collectAndResolve(ac, rootType, config, ai, collected); [EOL]     return new ArrayList<NamedType>(collected.values()); [EOL] } <line_num>: 70,104
@Override [EOL] public Collection<NamedType> collectAndResolveSubtypes(AnnotatedClass type, MapperConfig<?> config, AnnotationIntrospector ai) { [EOL]     HashMap<NamedType, NamedType> subtypes = new HashMap<NamedType, NamedType>(); [EOL]     if (_registeredSubtypes != null) { [EOL]         Class<?> rawBase = type.getRawType(); [EOL]         for (NamedType subtype : _registeredSubtypes) { [EOL]             if (rawBase.isAssignableFrom(subtype.getType())) { [EOL]                 AnnotatedClass curr = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config); [EOL]                 _collectAndResolve(curr, subtype, config, ai, subtypes); [EOL]             } [EOL]         } [EOL]     } [EOL]     NamedType rootType = new NamedType(type.getRawType(), null); [EOL]     _collectAndResolve(type, rootType, config, ai, subtypes); [EOL]     return new ArrayList<NamedType>(subtypes.values()); [EOL] } <line_num>: 106,126
protected void _collectAndResolve(AnnotatedClass annotatedType, NamedType namedType, MapperConfig<?> config, AnnotationIntrospector ai, HashMap<NamedType, NamedType> collectedSubtypes) { [EOL]     if (!namedType.hasName()) { [EOL]         String name = ai.findTypeName(annotatedType); [EOL]         if (name != null) { [EOL]             namedType = new NamedType(namedType.getType(), name); [EOL]         } [EOL]     } [EOL]     if (collectedSubtypes.containsKey(namedType)) { [EOL]         if (namedType.hasName()) { [EOL]             NamedType prev = collectedSubtypes.get(namedType); [EOL]             if (!prev.hasName()) { [EOL]                 collectedSubtypes.put(namedType, namedType); [EOL]             } [EOL]         } [EOL]         return; [EOL]     } [EOL]     collectedSubtypes.put(namedType, namedType); [EOL]     Collection<NamedType> st = ai.findSubtypes(annotatedType); [EOL]     if (st != null && !st.isEmpty()) { [EOL]         for (NamedType subtype : st) { [EOL]             AnnotatedClass subtypeClass = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config); [EOL]             if (!subtype.hasName()) { [EOL]                 subtype = new NamedType(subtype.getType(), ai.findTypeName(subtypeClass)); [EOL]             } [EOL]             _collectAndResolve(subtypeClass, subtype, config, ai, collectedSubtypes); [EOL]         } [EOL]     } [EOL] } <line_num>: 137,172
