public AsArrayTypeDeserializer(JavaType bt, TypeIdResolver idRes, String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl) { [EOL]     super(bt, idRes, typePropertyName, typeIdVisible, defaultImpl); [EOL] } <line_num>: 29,33
public AsArrayTypeDeserializer(AsArrayTypeDeserializer src, BeanProperty property) { [EOL]     super(src, property); [EOL] } <line_num>: 35,37
@Override [EOL] public TypeDeserializer forProperty(BeanProperty prop) { [EOL]     if (prop == _property) { [EOL]         return this; [EOL]     } [EOL]     return new AsArrayTypeDeserializer(this, prop); [EOL] } <line_num>: 39,45
@Override [EOL] public As getTypeInclusion() { [EOL]     return As.WRAPPER_ARRAY; [EOL] } <line_num>: 47,50
@Override [EOL] public Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _deserialize(jp, ctxt); [EOL] } <line_num>: 55,60
@Override [EOL] public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _deserialize(jp, ctxt); [EOL] } <line_num>: 65,70
@Override [EOL] public Object deserializeTypedFromScalar(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _deserialize(jp, ctxt); [EOL] } <line_num>: 72,77
@Override [EOL] public Object deserializeTypedFromAny(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return _deserialize(jp, ctxt); [EOL] } <line_num>: 79,84
private final Object _deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     boolean hadStartArray = jp.isExpectedStartArrayToken(); [EOL]     String typeId = _locateTypeId(jp, ctxt); [EOL]     JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId); [EOL]     if (_typeIdVisible && jp.getCurrentToken() == JsonToken.START_OBJECT) { [EOL]         @SuppressWarnings("resource") [EOL]         TokenBuffer tb = new TokenBuffer(null); [EOL]         tb.writeStartObject(); [EOL]         tb.writeFieldName(_typePropertyName); [EOL]         tb.writeString(typeId); [EOL]         jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp); [EOL]         jp.nextToken(); [EOL]     } [EOL]     Object value = deser.deserialize(jp, ctxt); [EOL]     if (hadStartArray && jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, "expected closing END_ARRAY after type information and deserialized value"); [EOL]     } [EOL]     return value; [EOL] } <line_num>: 97,121
protected final String _locateTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         if (_defaultImpl != null) { [EOL]             return _idResolver.idFromBaseType(); [EOL]         } [EOL]         throw ctxt.wrongTokenException(jp, JsonToken.START_ARRAY, "need JSON Array to contain As.WRAPPER_ARRAY type information for class " + baseTypeName()); [EOL]     } [EOL]     JsonToken t = jp.nextToken(); [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String result = jp.getText(); [EOL]         jp.nextToken(); [EOL]         return result; [EOL]     } [EOL]     if (_defaultImpl != null) { [EOL]         return _idResolver.idFromBaseType(); [EOL]     } [EOL]     throw ctxt.wrongTokenException(jp, JsonToken.VALUE_STRING, "need JSON String that contains type id (for subtype of " + baseTypeName() + ")"); [EOL] } <line_num>: 123,145
