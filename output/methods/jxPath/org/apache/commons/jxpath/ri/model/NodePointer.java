protected NodePointer(NodePointer parent) { [EOL]     this.parent = parent; [EOL] } <line_num>: 106,108
protected NodePointer(NodePointer parent, Locale locale) { [EOL]     this.parent = parent; [EOL]     this.locale = locale; [EOL] } <line_num>: 110,113
public static NodePointer newNodePointer(QName name, Object bean, Locale locale) { [EOL]     NodePointer pointer = null; [EOL]     if (bean == null) { [EOL]         pointer = new NullPointer(name, locale); [EOL]         return pointer; [EOL]     } [EOL]     NodePointerFactory[] factories = JXPathContextReferenceImpl.getNodePointerFactories(); [EOL]     for (int i = 0; i < factories.length; i++) { [EOL]         pointer = factories[i].createNodePointer(name, bean, locale); [EOL]         if (pointer != null) { [EOL]             return pointer; [EOL]         } [EOL]     } [EOL]     throw new JXPathException("Could not allocate a NodePointer for object of " + bean.getClass()); [EOL] } <line_num>: 55,77
public static NodePointer newChildNodePointer(NodePointer parent, QName name, Object bean) { [EOL]     NodePointerFactory[] factories = JXPathContextReferenceImpl.getNodePointerFactories(); [EOL]     for (int i = 0; i < factories.length; i++) { [EOL]         NodePointer pointer = factories[i].createNodePointer(parent, name, bean); [EOL]         if (pointer != null) { [EOL]             return pointer; [EOL]         } [EOL]     } [EOL]     throw new JXPathException("Could not allocate a NodePointer for object of " + bean.getClass()); [EOL] } <line_num>: 83,100
public NamespaceResolver getNamespaceResolver() { [EOL]     if (namespaceResolver == null && parent != null) { [EOL]         namespaceResolver = parent.getNamespaceResolver(); [EOL]     } [EOL]     return namespaceResolver; [EOL] } <line_num>: 115,120
public void setNamespaceResolver(NamespaceResolver namespaceResolver) { [EOL]     this.namespaceResolver = namespaceResolver; [EOL] } <line_num>: 122,124
public NodePointer getParent() { [EOL]     NodePointer pointer = parent; [EOL]     while (pointer != null && pointer.isContainer()) { [EOL]         pointer = pointer.getImmediateParentPointer(); [EOL]     } [EOL]     return pointer; [EOL] } <line_num>: 126,132
public NodePointer getImmediateParentPointer() { [EOL]     return parent; [EOL] } <line_num>: 134,136
public void setAttribute(boolean attribute) { [EOL]     this.attribute = attribute; [EOL] } <line_num>: 141,143
public boolean isAttribute() { [EOL]     return attribute; [EOL] } <line_num>: 148,150
public boolean isRoot() { [EOL]     return parent == null; [EOL] } <line_num>: 155,157
public abstract boolean isLeaf(); <line_num>: 162,162
public boolean isNode() { [EOL]     return !isContainer(); [EOL] } <line_num>: 167,169
public boolean isContainer() { [EOL]     return false; [EOL] } <line_num>: 175,177
public int getIndex() { [EOL]     return index; [EOL] } <line_num>: 186,188
public void setIndex(int index) { [EOL]     this.index = index; [EOL] } <line_num>: 190,192
public abstract boolean isCollection(); <line_num>: 198,198
public abstract int getLength(); <line_num>: 205,205
public Object getValue() { [EOL]     NodePointer valuePointer = getValuePointer(); [EOL]     if (valuePointer != this) { [EOL]         return valuePointer.getValue(); [EOL]     } [EOL]     return getNode(); [EOL] } <line_num>: 212,219
public NodePointer getValuePointer() { [EOL]     NodePointer ivp = getImmediateValuePointer(); [EOL]     if (ivp != this) { [EOL]         return ivp.getValuePointer(); [EOL]     } [EOL]     return this; [EOL] } <line_num>: 238,244
public NodePointer getImmediateValuePointer() { [EOL]     return this; [EOL] } <line_num>: 252,254
public boolean isActual() { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         return true; [EOL]     } else { [EOL]         return index >= 0 && index < getLength(); [EOL]     } [EOL] } <line_num>: 269,276
public abstract QName getName(); <line_num>: 281,281
public abstract Object getBaseValue(); <line_num>: 288,288
public Object getNodeValue() { [EOL]     return getNode(); [EOL] } <line_num>: 296,298
public Object getNode() { [EOL]     return getValuePointer().getImmediateNode(); [EOL] } <line_num>: 305,307
public Object getRootNode() { [EOL]     if (rootNode == null) { [EOL]         if (parent != null) { [EOL]             rootNode = parent.getRootNode(); [EOL]         } else { [EOL]             rootNode = getImmediateNode(); [EOL]         } [EOL]     } [EOL]     return rootNode; [EOL] } <line_num>: 309,319
public abstract Object getImmediateNode(); <line_num>: 325,325
public abstract void setValue(Object value); <line_num>: 331,331
public abstract int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2); <line_num>: 337,338
public boolean testNode(NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (isContainer()) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         QName nodeName = getName(); [EOL]         if (nodeName == null) { [EOL]             return false; [EOL]         } [EOL]         String testPrefix = testName.getPrefix(); [EOL]         String nodePrefix = nodeName.getPrefix(); [EOL]         if (!equalStrings(testPrefix, nodePrefix)) { [EOL]             String testNS = getNamespaceURI(testPrefix); [EOL]             String nodeNS = getNamespaceURI(nodePrefix); [EOL]             if (!equalStrings(testNS, nodeNS)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             return true; [EOL]         } [EOL]         return testName.getName().equals(nodeName.getName()); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return isNode(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 343,379
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null && s2 != null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && !s1.equals(s2)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] } <line_num>: 381,389
public NodePointer createPath(JXPathContext context, Object value) { [EOL]     setValue(value); [EOL]     return this; [EOL] } <line_num>: 395,398
public void remove() { [EOL] } <line_num>: 403,408
public NodePointer createPath(JXPathContext context) { [EOL]     return this; [EOL] } <line_num>: 415,417
public NodePointer createChild(JXPathContext context, QName name, int index, Object value) { [EOL]     throw new JXPathException("Cannot create an object for path " + asPath() + "/" + name + "[" + (index + 1) + "]" + ", operation is not allowed for this type of node"); [EOL] } <line_num>: 425,434
public NodePointer createChild(JXPathContext context, QName name, int index) { [EOL]     throw new JXPathException("Cannot create an object for path " + asPath() + "/" + name + "[" + (index + 1) + "]" + ", operation is not allowed for this type of node"); [EOL] } <line_num>: 442,447
public NodePointer createAttribute(JXPathContext context, QName name) { [EOL]     throw new JXPathException("Cannot create an attribute for path " + asPath() + "/@" + name + ", operation is not allowed for this type of node"); [EOL] } <line_num>: 452,456
public Locale getLocale() { [EOL]     if (locale == null) { [EOL]         if (parent != null) { [EOL]             locale = parent.getLocale(); [EOL]         } [EOL]     } [EOL]     return locale; [EOL] } <line_num>: 462,469
public boolean isLanguage(String lang) { [EOL]     Locale loc = getLocale(); [EOL]     String name = loc.toString().replace('_', '-'); [EOL]     return name.toUpperCase().startsWith(lang.toUpperCase()); [EOL] } <line_num>: 475,479
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     NodePointer valuePointer = getValuePointer(); [EOL]     if (valuePointer != null && valuePointer != this) { [EOL]         return valuePointer.childIterator(test, reverse, startWith); [EOL]     } [EOL]     return null; [EOL] } <line_num>: 506,516
public NodeIterator attributeIterator(QName qname) { [EOL]     NodePointer valuePointer = getValuePointer(); [EOL]     if (valuePointer != null && valuePointer != this) { [EOL]         return valuePointer.attributeIterator(qname); [EOL]     } [EOL]     return null; [EOL] } <line_num>: 523,529
public NodeIterator namespaceIterator() { [EOL]     return null; [EOL] } <line_num>: 536,538
public NodePointer namespacePointer(String namespace) { [EOL]     return null; [EOL] } <line_num>: 545,547
public String getNamespaceURI(String prefix) { [EOL]     return null; [EOL] } <line_num>: 552,554
public String getNamespaceURI() { [EOL]     return null; [EOL] } <line_num>: 559,561
protected boolean isDefaultNamespace(String prefix) { [EOL]     if (prefix == null) { [EOL]         return true; [EOL]     } [EOL]     String namespace = getNamespaceURI(prefix); [EOL]     if (namespace == null) { [EOL]         return false; [EOL]     } [EOL]     return namespace.equals(getDefaultNamespaceURI()); [EOL] } <line_num>: 567,578
protected String getDefaultNamespaceURI() { [EOL]     return null; [EOL] } <line_num>: 580,582
public Pointer getPointerByID(JXPathContext context, String id) { [EOL]     return context.getPointerByID(id); [EOL] } <line_num>: 587,589
public Pointer getPointerByKey(JXPathContext context, String key, String value) { [EOL]     return context.getPointerByKey(key, value); [EOL] } <line_num>: 594,600
public String asPath() { [EOL]     if (parent != null && parent.isContainer()) { [EOL]         return parent.asPath(); [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]     } [EOL]     if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]         buffer.append('/'); [EOL]     } [EOL]     if (attribute) { [EOL]         buffer.append('@'); [EOL]     } [EOL]     buffer.append(getName()); [EOL]     if (index != WHOLE_COLLECTION && isCollection()) { [EOL]         buffer.append('[').append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] } <line_num>: 605,630
public Object clone() { [EOL]     try { [EOL]         NodePointer ptr = (NodePointer) super.clone(); [EOL]         if (parent != null) { [EOL]             ptr.parent = (NodePointer) parent.clone(); [EOL]         } [EOL]         return ptr; [EOL]     } catch (CloneNotSupportedException ex) { [EOL]         ex.printStackTrace(); [EOL]     } [EOL]     return null; [EOL] } <line_num>: 632,645
public String toString() { [EOL]     return asPath(); [EOL] } <line_num>: 647,649
public int compareTo(Object object) { [EOL]     NodePointer pointer = (NodePointer) object; [EOL]     if (parent == pointer.parent) { [EOL]         if (parent == null) { [EOL]             return 0; [EOL]         } [EOL]         return parent.compareChildNodePointers(this, pointer); [EOL]     } [EOL]     int depth1 = 0; [EOL]     NodePointer p1 = this; [EOL]     while (p1 != null) { [EOL]         depth1++; [EOL]         p1 = p1.parent; [EOL]     } [EOL]     int depth2 = 0; [EOL]     NodePointer p2 = pointer; [EOL]     while (p2 != null) { [EOL]         depth2++; [EOL]         p2 = p2.parent; [EOL]     } [EOL]     return compareNodePointers(this, depth1, pointer, depth2); [EOL] } <line_num>: 651,675
private int compareNodePointers(NodePointer p1, int depth1, NodePointer p2, int depth2) { [EOL]     if (depth1 < depth2) { [EOL]         int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1); [EOL]         if (r != 0) { [EOL]             return r; [EOL]         } [EOL]         return -1; [EOL]     } else if (depth1 > depth2) { [EOL]         int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2); [EOL]         if (r != 0) { [EOL]             return r; [EOL]         } [EOL]         return 1; [EOL]     } [EOL]     if (p1 == null && p2 == null) { [EOL]         return 0; [EOL]     } [EOL]     if (p1 != null && p1.equals(p2)) { [EOL]         return 0; [EOL]     } [EOL]     if (depth1 == 1) { [EOL]         throw new JXPathException("Cannot compare pointers that do not belong to the same tree: '" + p1 + "' and '" + p2 + "'"); [EOL]     } [EOL]     int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1); [EOL]     if (r != 0) { [EOL]         return r; [EOL]     } [EOL]     return p1.parent.compareChildNodePointers(p1, p2); [EOL] } <line_num>: 677,717
public void printPointerChain() { [EOL]     printDeep(this, ""); [EOL] } <line_num>: 722,724
private static void printDeep(NodePointer pointer, String indent) { [EOL]     if (indent.length() == 0) { [EOL]         System.err.println("POINTER: " + pointer + "(" + pointer.getClass().getName() + ")"); [EOL]     } else { [EOL]         System.err.println(indent + " of " + pointer + "(" + pointer.getClass().getName() + ")"); [EOL]     } [EOL]     if (pointer.getImmediateParentPointer() != null) { [EOL]         printDeep(pointer.getImmediateParentPointer(), indent + "  "); [EOL]     } [EOL] } <line_num>: 726,747
