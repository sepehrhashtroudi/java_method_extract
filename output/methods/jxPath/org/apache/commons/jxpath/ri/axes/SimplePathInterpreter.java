public static NodePointer interpretSimpleLocationPath(EvalContext context, NodePointer root, Step[] steps) { [EOL]     NodePointer pointer = doStep(context, root, steps, 0); [EOL]     return pointer; [EOL] } <line_num>: 74,81
public static NodePointer interpretSimpleExpressionPath(EvalContext context, NodePointer root, Expression[] predicates, Step[] steps) { [EOL]     NodePointer pointer = doPredicate(context, root, steps, -1, predicates, 0); [EOL]     return pointer; [EOL] } <line_num>: 92,102
private static NodePointer doStep(EvalContext context, NodePointer parent, Step[] steps, int currentStep) { [EOL]     if (parent == null) { [EOL]         return null; [EOL]     } [EOL]     if (currentStep == steps.length) { [EOL]         return parent; [EOL]     } [EOL]     parent = valuePointer(parent); [EOL]     Step step = steps[currentStep]; [EOL]     Expression[] predicates = step.getPredicates(); [EOL]     if (parent instanceof PropertyOwnerPointer) { [EOL]         if (predicates == null || predicates.length == 0) { [EOL]             return doStepNoPredicatesPropertyOwner(context, (PropertyOwnerPointer) parent, steps, currentStep); [EOL]         } else { [EOL]             return doStepPredicatesPropertyOwner(context, (PropertyOwnerPointer) parent, steps, currentStep); [EOL]         } [EOL]     } else { [EOL]         if (predicates == null || predicates.length == 0) { [EOL]             return doStepNoPredicatesStandard(context, parent, steps, currentStep); [EOL]         } else { [EOL]             return doStepPredicatesStandard(context, parent, steps, currentStep); [EOL]         } [EOL]     } [EOL] } <line_num>: 111,173
private static NodePointer doStepNoPredicatesPropertyOwner(EvalContext context, PropertyOwnerPointer parentPointer, Step[] steps, int currentStep) { [EOL]     Step step = steps[currentStep]; [EOL]     NodePointer childPointer = createChildPointerForStep(parentPointer, step); [EOL]     if (!childPointer.isActual()) { [EOL]         return createNullPointer(context, parentPointer, steps, currentStep); [EOL]     } else if (currentStep == steps.length - 1) { [EOL]         return childPointer; [EOL]     } else if (childPointer.isCollection()) { [EOL]         int bestQuality = 0; [EOL]         childPointer = (NodePointer) childPointer.clone(); [EOL]         NodePointer bestMatch = null; [EOL]         int count = childPointer.getLength(); [EOL]         for (int i = 0; i < count; i++) { [EOL]             childPointer.setIndex(i); [EOL]             NodePointer pointer = doStep(context, childPointer, steps, currentStep + 1); [EOL]             int quality = computeQuality(pointer); [EOL]             if (quality == PERFECT_MATCH) { [EOL]                 return pointer; [EOL]             } else if (quality > bestQuality) { [EOL]                 bestQuality = quality; [EOL]                 bestMatch = (NodePointer) pointer.clone(); [EOL]             } [EOL]         } [EOL]         if (bestMatch != null) { [EOL]             return bestMatch; [EOL]         } [EOL]         return createNullPointer(context, childPointer, steps, currentStep); [EOL]     } else { [EOL]         return doStep(context, childPointer, steps, currentStep + 1); [EOL]     } [EOL] } <line_num>: 184,235
private static NodePointer doStepNoPredicatesStandard(EvalContext context, NodePointer parentPointer, Step[] steps, int currentStep) { [EOL]     Step step = steps[currentStep]; [EOL]     if (step.getAxis() == Compiler.AXIS_SELF) { [EOL]         return doStep(context, parentPointer, steps, currentStep + 1); [EOL]     } [EOL]     int bestQuality = 0; [EOL]     NodePointer bestMatch = null; [EOL]     NodeIterator it = getNodeIterator(context, parentPointer, step); [EOL]     if (it != null) { [EOL]         for (int i = 1; it.setPosition(i); i++) { [EOL]             NodePointer childPointer = it.getNodePointer(); [EOL]             if (steps.length == currentStep + 1) { [EOL]                 return childPointer; [EOL]             } [EOL]             NodePointer pointer = doStep(context, childPointer, steps, currentStep + 1); [EOL]             int quality = computeQuality(pointer); [EOL]             if (quality == PERFECT_MATCH) { [EOL]                 return pointer; [EOL]             } else if (quality > bestQuality) { [EOL]                 bestQuality = quality; [EOL]                 bestMatch = (NodePointer) pointer.clone(); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (bestMatch != null) { [EOL]         return bestMatch; [EOL]     } [EOL]     return createNullPointer(context, parentPointer, steps, currentStep); [EOL] } <line_num>: 245,284
private static NodePointer doStepPredicatesPropertyOwner(EvalContext context, PropertyOwnerPointer parentPointer, Step[] steps, int currentStep) { [EOL]     Step step = steps[currentStep]; [EOL]     Expression[] predicates = step.getPredicates(); [EOL]     NodePointer childPointer = createChildPointerForStep(parentPointer, step); [EOL]     if (!childPointer.isActual()) { [EOL]         return createNullPointer(context, parentPointer, steps, currentStep); [EOL]     } [EOL]     return doPredicate(context, childPointer, steps, currentStep, predicates, 0); [EOL] } <line_num>: 291,317
private static NodePointer createChildPointerForStep(PropertyOwnerPointer parentPointer, Step step) { [EOL]     int axis = step.getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD || axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         NodePointer childPointer; [EOL]         QName name = ((NodeNameTest) step.getNodeTest()).getNodeName(); [EOL]         if (axis == Compiler.AXIS_ATTRIBUTE && isLangAttribute(name)) { [EOL]             childPointer = new LangAttributePointer(parentPointer); [EOL]         } else { [EOL]             childPointer = parentPointer.getPropertyPointer(); [EOL]             ((PropertyPointer) childPointer).setPropertyName(name.toString()); [EOL]             childPointer.setAttribute(axis == Compiler.AXIS_ATTRIBUTE); [EOL]         } [EOL]         return childPointer; [EOL]     } else { [EOL]         return parentPointer; [EOL]     } [EOL] } <line_num>: 319,340
private static NodePointer doStepPredicatesStandard(EvalContext context, NodePointer parent, Step[] steps, int currentStep) { [EOL]     Step step = steps[currentStep]; [EOL]     Expression[] predicates = step.getPredicates(); [EOL]     int axis = step.getAxis(); [EOL]     if (axis == Compiler.AXIS_SELF) { [EOL]         return doPredicate(context, parent, steps, currentStep, predicates, 0); [EOL]     } [EOL]     Expression predicate = predicates[0]; [EOL]     if (predicates.length == 1) { [EOL]         NodeIterator it = getNodeIterator(context, parent, step); [EOL]         NodePointer pointer = null; [EOL]         if (it != null) { [EOL]             if (predicate instanceof NameAttributeTest) { [EOL]                 String key = keyFromPredicate(context, predicate); [EOL]                 for (int i = 1; it.setPosition(i); i++) { [EOL]                     NodePointer ptr = it.getNodePointer(); [EOL]                     if (isNameAttributeEqual(ptr, key)) { [EOL]                         pointer = ptr; [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } else { [EOL]                 int index = indexFromPredicate(context, predicate); [EOL]                 if (it.setPosition(index + 1)) { [EOL]                     pointer = it.getNodePointer(); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (pointer != null) { [EOL]             return doStep(context, pointer, steps, currentStep + 1); [EOL]         } [EOL]     } else { [EOL]         NodeIterator it = getNodeIterator(context, parent, step); [EOL]         if (it != null) { [EOL]             List list = new ArrayList(); [EOL]             for (int i = 1; it.setPosition(i); i++) { [EOL]                 list.add(it.getNodePointer()); [EOL]             } [EOL]             NodePointer pointer = doPredicatesStandard(context, list, steps, currentStep, predicates, 0); [EOL]             if (pointer != null) { [EOL]                 return pointer; [EOL]             } [EOL]         } [EOL]     } [EOL]     return createNullPointer(context, parent, steps, currentStep); [EOL] } <line_num>: 347,418
private static NodePointer doPredicate(EvalContext context, NodePointer parent, Step[] steps, int currentStep, Expression[] predicates, int currentPredicate) { [EOL]     if (currentPredicate == predicates.length) { [EOL]         return doStep(context, parent, steps, currentStep + 1); [EOL]     } [EOL]     Expression predicate = predicates[currentPredicate]; [EOL]     if (predicate instanceof NameAttributeTest) { [EOL]         return doPredicateName(context, parent, steps, currentStep, predicates, currentPredicate); [EOL]     } else { [EOL]         return doPredicateIndex(context, parent, steps, currentStep, predicates, currentPredicate); [EOL]     } [EOL] } <line_num>: 424,452
private static NodePointer doPredicateName(EvalContext context, NodePointer parent, Step[] steps, int currentStep, Expression[] predicates, int currentPredicate) { [EOL]     Expression predicate = predicates[currentPredicate]; [EOL]     String key = keyFromPredicate(context, predicate); [EOL]     NodePointer child = valuePointer(parent); [EOL]     if (child instanceof PropertyOwnerPointer) { [EOL]         PropertyPointer pointer = ((PropertyOwnerPointer) child).getPropertyPointer(); [EOL]         pointer.setPropertyName(key); [EOL]         if (pointer.isActual()) { [EOL]             return doPredicate(context, pointer, steps, currentStep, predicates, currentPredicate + 1); [EOL]         } [EOL]     } else if (child.isCollection()) { [EOL]         NodePointer bestMatch = null; [EOL]         int bestQuality = 0; [EOL]         child = (NodePointer) child.clone(); [EOL]         int count = child.getLength(); [EOL]         for (int i = 0; i < count; i++) { [EOL]             child.setIndex(i); [EOL]             NodePointer valuePointer = valuePointer(child); [EOL]             NodePointer pointer; [EOL]             if ((valuePointer instanceof PropertyOwnerPointer) || valuePointer.isCollection()) { [EOL]                 pointer = doPredicateName(context, valuePointer, steps, currentStep, predicates, currentPredicate); [EOL]             } else if (isNameAttributeEqual(valuePointer, key)) { [EOL]                 pointer = doPredicate(context, valuePointer, steps, currentStep, predicates, currentPredicate + 1); [EOL]             } else { [EOL]                 pointer = null; [EOL]             } [EOL]             if (pointer != null) { [EOL]                 int quality = computeQuality(pointer); [EOL]                 if (quality == PERFECT_MATCH) { [EOL]                     return pointer; [EOL]                 } [EOL]                 if (quality > bestQuality) { [EOL]                     bestMatch = (NodePointer) pointer.clone(); [EOL]                     bestQuality = quality; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (bestMatch != null) { [EOL]             return bestMatch; [EOL]         } [EOL]     } else { [EOL]         NodePointer found = doPredicatesStandard(context, Collections.singletonList(child), steps, currentStep, predicates, currentPredicate); [EOL]         if (found != null) { [EOL]             return found; [EOL]         } [EOL]     } [EOL]     return createNullPointerForPredicates(context, child, steps, currentStep, predicates, currentPredicate); [EOL] } <line_num>: 454,554
private static NodePointer doPredicatesStandard(EvalContext context, List parents, Step[] steps, int currentStep, Expression[] predicates, int currentPredicate) { [EOL]     if (parents.size() == 0) { [EOL]         return null; [EOL]     } [EOL]     if (currentPredicate == predicates.length) { [EOL]         NodePointer pointer = (NodePointer) parents.get(0); [EOL]         return doStep(context, pointer, steps, currentStep + 1); [EOL]     } [EOL]     Expression predicate = predicates[currentPredicate]; [EOL]     if (predicate instanceof NameAttributeTest) { [EOL]         String key = keyFromPredicate(context, predicate); [EOL]         List newList = new ArrayList(); [EOL]         for (int i = 0; i < parents.size(); i++) { [EOL]             NodePointer pointer = (NodePointer) parents.get(i); [EOL]             if (isNameAttributeEqual(pointer, key)) { [EOL]                 newList.add(pointer); [EOL]             } [EOL]         } [EOL]         if (newList.size() == 0) { [EOL]             return null; [EOL]         } [EOL]         return doPredicatesStandard(context, newList, steps, currentStep, predicates, currentPredicate + 1); [EOL]     } else { [EOL]         int index = indexFromPredicate(context, predicate); [EOL]         if (index < 0 || index >= parents.size()) { [EOL]             return null; [EOL]         } [EOL]         NodePointer ptr = (NodePointer) parents.get(index); [EOL]         return doPredicate(context, ptr, steps, currentStep, predicates, currentPredicate + 1); [EOL]     } [EOL] } <line_num>: 560,615
private static NodePointer doPredicateIndex(EvalContext context, NodePointer parent, Step[] steps, int currentStep, Expression[] predicates, int currentPredicate) { [EOL]     Expression predicate = predicates[currentPredicate]; [EOL]     int index = indexFromPredicate(context, predicate); [EOL]     NodePointer pointer = parent; [EOL]     if (isCollectionElement(pointer, index)) { [EOL]         pointer = (NodePointer) pointer.clone(); [EOL]         pointer.setIndex(index); [EOL]         return doPredicate(context, pointer, steps, currentStep, predicates, currentPredicate + 1); [EOL]     } [EOL]     return createNullPointerForPredicates(context, parent, steps, currentStep, predicates, currentPredicate); [EOL] } <line_num>: 621,647
private static int indexFromPredicate(EvalContext context, Expression predicate) { [EOL]     Object value = predicate.computeValue(context); [EOL]     if (value instanceof EvalContext) { [EOL]         value = ((EvalContext) value).getSingleNodePointer(); [EOL]     } [EOL]     if (value instanceof NodePointer) { [EOL]         value = ((NodePointer) value).getValue(); [EOL]     } [EOL]     if (value == null) { [EOL]         throw new JXPathException("Predicate value is null: " + predicate); [EOL]     } [EOL]     if (value instanceof Number) { [EOL]         return (int) (InfoSetUtil.doubleValue(value) + 0.5) - 1; [EOL]     } else if (InfoSetUtil.booleanValue(value)) { [EOL]         return 0; [EOL]     } [EOL]     return -1; [EOL] } <line_num>: 653,676
private static String keyFromPredicate(EvalContext context, Expression predicate) { [EOL]     Expression expr = ((NameAttributeTest) predicate).getNameTestExpression(); [EOL]     return InfoSetUtil.stringValue(expr.computeValue(context)); [EOL] } <line_num>: 682,688
private static int computeQuality(NodePointer pointer) { [EOL]     int quality = PERFECT_MATCH; [EOL]     while (pointer != null && !pointer.isActual()) { [EOL]         quality--; [EOL]         pointer = pointer.getImmediateParentPointer(); [EOL]     } [EOL]     return quality; [EOL] } <line_num>: 695,702
private static boolean isNameAttributeEqual(NodePointer pointer, String name) { [EOL]     NodeIterator it = pointer.attributeIterator(QNAME_NAME); [EOL]     return it != null && it.setPosition(1) && name.equals(it.getNodePointer().getValue()); [EOL] } <line_num>: 708,716
private static boolean isCollectionElement(NodePointer pointer, int index) { [EOL]     return pointer.isActual() && (index == 0 || (pointer.isCollection() && index >= 0 && index < pointer.getLength())); [EOL] } <line_num>: 722,731
private static NodePointer valuePointer(NodePointer pointer) { [EOL]     return pointer == null ? null : pointer.getValuePointer(); [EOL] } <line_num>: 737,739
public static NodePointer createNullPointer(EvalContext context, NodePointer parent, Step[] steps, int currentStep) { [EOL]     if (currentStep == steps.length) { [EOL]         return parent; [EOL]     } [EOL]     parent = valuePointer(parent); [EOL]     Step step = steps[currentStep]; [EOL]     int axis = step.getAxis(); [EOL]     if (axis == Compiler.AXIS_CHILD || axis == Compiler.AXIS_ATTRIBUTE) { [EOL]         NullPropertyPointer pointer = new NullPropertyPointer(parent); [EOL]         QName name = ((NodeNameTest) step.getNodeTest()).getNodeName(); [EOL]         pointer.setPropertyName(name.toString()); [EOL]         pointer.setAttribute(axis == Compiler.AXIS_ATTRIBUTE); [EOL]         parent = pointer; [EOL]     } [EOL]     Expression[] predicates = step.getPredicates(); [EOL]     return createNullPointerForPredicates(context, parent, steps, currentStep, predicates, 0); [EOL] } <line_num>: 746,776
private static NodePointer createNullPointerForPredicates(EvalContext context, NodePointer parent, Step[] steps, int currentStep, Expression[] predicates, int currentPredicate) { [EOL]     for (int i = currentPredicate; i < predicates.length; i++) { [EOL]         Expression predicate = predicates[i]; [EOL]         if (predicate instanceof NameAttributeTest) { [EOL]             String key = keyFromPredicate(context, predicate); [EOL]             parent = valuePointer(parent); [EOL]             NullPropertyPointer pointer = new NullPropertyPointer(parent); [EOL]             pointer.setNameAttributeValue(key); [EOL]             parent = pointer; [EOL]         } else { [EOL]             int index = indexFromPredicate(context, predicate); [EOL]             if (parent instanceof NullPropertyPointer) { [EOL]                 parent.setIndex(index); [EOL]             } else { [EOL]                 parent = new NullElementPointer(parent, index); [EOL]             } [EOL]         } [EOL]     } [EOL]     return createNullPointer(context, parent, steps, currentStep + 1); [EOL] } <line_num>: 781,808
private static NodeIterator getNodeIterator(EvalContext context, NodePointer pointer, Step step) { [EOL]     if (step.getAxis() == Compiler.AXIS_CHILD) { [EOL]         NodeTest nodeTest = step.getNodeTest(); [EOL]         QName qname = ((NodeNameTest) nodeTest).getNodeName(); [EOL]         String prefix = qname.getPrefix(); [EOL]         String namespaceURI = prefix != null ? context.getJXPathContext().getNamespaceURI(prefix) : context.getJXPathContext().getDefaultNamespaceURI(); [EOL]         if (namespaceURI != null) { [EOL]             nodeTest = new NodeNameTest(qname, namespaceURI); [EOL]         } [EOL]         return pointer.childIterator(nodeTest, false, null); [EOL]     } else { [EOL]         if (!(step.getNodeTest() instanceof NodeNameTest)) { [EOL]             throw new UnsupportedOperationException("Not supported node test for attributes: " + step.getNodeTest()); [EOL]         } [EOL]         return pointer.attributeIterator(((NodeNameTest) step.getNodeTest()).getNodeName()); [EOL]     } [EOL] } <line_num>: 810,836
private static boolean isLangAttribute(QName name) { [EOL]     return name.getPrefix() != null && name.getPrefix().equals("xml") && name.getName().equals("lang"); [EOL] } <line_num>: 838,842
