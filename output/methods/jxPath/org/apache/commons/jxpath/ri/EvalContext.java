public EvalContext(EvalContext parentContext) { [EOL]     this.parentContext = parentContext; [EOL] } <line_num>: 63,65
public int compare(Object o1, Object o2) { [EOL]     return ((Comparable) o2).compareTo(o1); [EOL] } <line_num>: 58,60
public Pointer getContextNodePointer() { [EOL]     return getCurrentNodePointer(); [EOL] } <line_num>: 67,69
public JXPathContext getJXPathContext() { [EOL]     return getRootContext().getJXPathContext(); [EOL] } <line_num>: 71,73
public int getPosition() { [EOL]     return position; [EOL] } <line_num>: 75,77
public int getDocumentOrder() { [EOL]     if (parentContext != null && parentContext.isChildOrderingRequired()) { [EOL]         return 1; [EOL]     } [EOL]     return 0; [EOL] } <line_num>: 85,90
public boolean isChildOrderingRequired() { [EOL]     if (getDocumentOrder() != 0) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 97,104
public boolean hasNext() { [EOL]     if (pointerIterator != null) { [EOL]         return pointerIterator.hasNext(); [EOL]     } [EOL]     if (getDocumentOrder() != 0) { [EOL]         return constructIterator(); [EOL]     } else { [EOL]         if (!done && !hasPerformedIteratorStep) { [EOL]             performIteratorStep(); [EOL]         } [EOL]         return !done; [EOL]     } [EOL] } <line_num>: 109,123
public Object next() { [EOL]     if (pointerIterator != null) { [EOL]         return pointerIterator.next(); [EOL]     } [EOL]     if (getDocumentOrder() != 0) { [EOL]         if (!constructIterator()) { [EOL]             throw new NoSuchElementException(); [EOL]         } [EOL]         return pointerIterator.next(); [EOL]     } else { [EOL]         if (!done && !hasPerformedIteratorStep) { [EOL]             performIteratorStep(); [EOL]         } [EOL]         if (done) { [EOL]             throw new NoSuchElementException(); [EOL]         } [EOL]         hasPerformedIteratorStep = false; [EOL]         return getCurrentNodePointer(); [EOL]     } [EOL] } <line_num>: 128,149
private void performIteratorStep() { [EOL]     done = true; [EOL]     if (position != 0 && nextNode()) { [EOL]         done = false; [EOL]     } else { [EOL]         while (nextSet()) { [EOL]             if (nextNode()) { [EOL]                 done = false; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     hasPerformedIteratorStep = true; [EOL] } <line_num>: 154,168
public void remove() { [EOL]     throw new UnsupportedOperationException("JXPath iterators cannot remove nodes"); [EOL] } <line_num>: 173,176
private boolean constructIterator() { [EOL]     HashSet set = new HashSet(); [EOL]     ArrayList list = new ArrayList(); [EOL]     while (nextSet()) { [EOL]         while (nextNode()) { [EOL]             NodePointer pointer = getCurrentNodePointer(); [EOL]             if (!set.contains(pointer)) { [EOL]                 set.add(pointer); [EOL]                 list.add(pointer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (list.isEmpty()) { [EOL]         return false; [EOL]     } [EOL]     if (getDocumentOrder() == 1) { [EOL]         Collections.sort(list); [EOL]     } else { [EOL]         Collections.sort(list, REVERSE_COMPARATOR); [EOL]     } [EOL]     pointerIterator = list.iterator(); [EOL]     return true; [EOL] } <line_num>: 178,203
public List getContextNodeList() { [EOL]     int pos = position; [EOL]     if (pos != 0) { [EOL]         reset(); [EOL]     } [EOL]     List list = new ArrayList(); [EOL]     while (nextNode()) { [EOL]         list.add(getCurrentNodePointer()); [EOL]     } [EOL]     if (pos != 0) { [EOL]         setPosition(pos); [EOL]     } else { [EOL]         reset(); [EOL]     } [EOL]     return list; [EOL] } <line_num>: 209,225
public NodeSet getNodeSet() { [EOL]     if (position != 0) { [EOL]         throw new JXPathException("Simultaneous operations: " + "should not request pointer list while " + "iterating over an EvalContext"); [EOL]     } [EOL]     BasicNodeSet set = new BasicNodeSet(); [EOL]     while (nextSet()) { [EOL]         while (nextNode()) { [EOL]             set.add((Pointer) getCurrentNodePointer().clone()); [EOL]         } [EOL]     } [EOL]     return set; [EOL] } <line_num>: 232,247
public Object getValue() { [EOL]     return getNodeSet(); [EOL] } <line_num>: 254,256
public String toString() { [EOL]     Pointer ptr = getContextNodePointer(); [EOL]     if (ptr == null) { [EOL]         return "Empty expression context"; [EOL]     } else { [EOL]         return "Expression context [" + getPosition() + "] " + ptr.asPath(); [EOL]     } [EOL] } <line_num>: 258,266
public RootContext getRootContext() { [EOL]     if (rootContext == null) { [EOL]         rootContext = parentContext.getRootContext(); [EOL]     } [EOL]     return rootContext; [EOL] } <line_num>: 272,277
public void reset() { [EOL]     position = 0; [EOL] } <line_num>: 282,284
public int getCurrentPosition() { [EOL]     return position; [EOL] } <line_num>: 286,288
public Pointer getSingleNodePointer() { [EOL]     reset(); [EOL]     while (nextSet()) { [EOL]         if (nextNode()) { [EOL]             return getCurrentNodePointer(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 294,302
public abstract NodePointer getCurrentNodePointer(); <line_num>: 308,308
public boolean nextSet() { [EOL]     reset(); [EOL]     if (!startedSetIteration) { [EOL]         startedSetIteration = true; [EOL]         while (parentContext.nextSet()) { [EOL]             if (parentContext.nextNode()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (parentContext.nextNode()) { [EOL]         return true; [EOL]     } [EOL]     while (parentContext.nextSet()) { [EOL]         if (parentContext.nextNode()) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } <line_num>: 314,344
public abstract boolean nextNode(); <line_num>: 350,350
public boolean setPosition(int position) { [EOL]     this.position = position; [EOL]     return true; [EOL] } <line_num>: 358,361
