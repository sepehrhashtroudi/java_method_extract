public XPathParserTokenManager(SimpleCharStream stream) { [EOL]     if (SimpleCharStream.staticFlag) [EOL]         throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer."); [EOL]     input_stream = stream; [EOL] } <line_num>: 1751,1756
public XPathParserTokenManager(SimpleCharStream stream, int lexState) { [EOL]     this(stream); [EOL]     SwitchTo(lexState); [EOL] } <line_num>: 1757,1761
public void setDebugStream(java.io.PrintStream ds) { [EOL]     debugStream = ds; [EOL] } <line_num>: 9,9
private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1) { [EOL]     switch(pos) { [EOL]         case 0: [EOL]             if ((active1 & 0xc0000L) != 0L) [EOL]                 return 10; [EOL]             if ((active0 & 0xfffffffff8000000L) != 0L || (active1 & 0x3fffL) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 1: [EOL]             if ((active0 & 0x8000008000000L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0xfff7fffff0000000L) != 0L || (active1 & 0x3fffL) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 1; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 2: [EOL]             if ((active0 & 0x10000070000000L) != 0L || (active1 & 0x208L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0xffe7ffff80000000L) != 0L || (active1 & 0x3df7L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 2; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 3: [EOL]             if ((active0 & 0xc1010180000000L) != 0L || (active1 & 0xd0L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0xff26fefe00000000L) != 0L || (active1 & 0x3d27L) != 0L) { [EOL]                 if (jjmatchedPos != 3) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 3; [EOL]                 } [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 4: [EOL]             if ((active0 & 0xff62fff600000000L) != 0L || (active1 & 0x2907L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 4; [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x4000000000000L) != 0L || (active1 & 0x1420L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x800000000L) != 0L) { [EOL]                 if (jjmatchedPos < 3) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 3; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 5: [EOL]             if ((active0 & 0x8300000000000000L) != 0L || (active1 & 0x100L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x7c62ffe600000000L) != 0L || (active1 & 0x2807L) != 0L) { [EOL]                 if (jjmatchedPos != 5) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 5; [EOL]                 } [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x1000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 4) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 4; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x800000000L) != 0L) { [EOL]                 if (jjmatchedPos < 3) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 3; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 6: [EOL]             if ((active0 & 0x200000000L) != 0L || (active1 & 0x804L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x2000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 5) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 5; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x1000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 4) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 4; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0xfc62ffc400000000L) != 0L || (active1 & 0x2003L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 6; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 7: [EOL]             if ((active0 & 0xf460ffc400000000L) != 0L || (active1 & 0x2003L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 7; [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x802000000000000L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x2000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 5) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 5; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 8: [EOL]             if ((active0 & 0x7000000000000000L) != 0L || (active1 & 0x2L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x4000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 7) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 7; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x8460ff8400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL]                 if (jjmatchedPos != 8) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 8; [EOL]                 } [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 9: [EOL]             if ((active0 & 0x20000000000000L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x78000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 8) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 8; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x4000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 7) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 7; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0xb440f80400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 9; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 10: [EOL]             if ((active0 & 0x400000000000000L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x80000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 9) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 9; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x78000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 8) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 8; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0xb040f00400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 10; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 11: [EOL]             if ((active0 & 0xb040f00400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 11; [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x80000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 9) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 9; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 12: [EOL]             if ((active0 & 0x8040000000000000L) != 0L || (active1 & 0x2000L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x3000f00400000000L) != 0L || (active1 & 0x1L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 12; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 13: [EOL]             if ((active0 & 0x3000f00400000000L) != 0L || (active1 & 0x1L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 13; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 14: [EOL]             if ((active0 & 0x2000000000000000L) != 0L || (active1 & 0x1L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x1000f00400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 14; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 15: [EOL]             if ((active0 & 0x1000000000000000L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0xf00400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 15; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 16: [EOL]             if ((active0 & 0xe00400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 16; [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x100000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 15) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 15; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 17: [EOL]             if ((active0 & 0x600000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 16) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 16; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x100000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 15) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 15; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x800400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 17; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 18: [EOL]             if ((active0 & 0x400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 18; [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x800000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 17) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 17; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x600000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 16) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 16; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 19: [EOL]             if ((active0 & 0x400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 19; [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x800000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 17) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 17; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 20: [EOL]             if ((active0 & 0x400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 20; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         default: [EOL]             return -1; [EOL]     } [EOL] } <line_num>: 10,383
private final int jjStartNfa_0(int pos, long active0, long active1) { [EOL]     return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0, active1), pos + 1); [EOL] } <line_num>: 384,387
private final int jjStopAtPos(int pos, int kind) { [EOL]     jjmatchedKind = kind; [EOL]     jjmatchedPos = pos; [EOL]     return pos + 1; [EOL] } <line_num>: 388,393
private final int jjStartNfaWithStates_0(int pos, int kind, int state) { [EOL]     jjmatchedKind = kind; [EOL]     jjmatchedPos = pos; [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         return pos + 1; [EOL]     } [EOL]     return jjMoveNfa_0(state, pos + 1); [EOL] } <line_num>: 394,401
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } <line_num>: 402,479
private final int jjMoveStringLiteralDfa1_0(long active0, long active1) { [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(0, active0, active1); [EOL]         return 1; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 46: [EOL]             if ((active1 & 0x80000L) != 0L) [EOL]                 return jjStopAtPos(1, 83); [EOL]             break; [EOL]         case 47: [EOL]             if ((active0 & 0x80L) != 0L) [EOL]                 return jjStopAtPos(1, 7); [EOL]             break; [EOL]         case 61: [EOL]             if ((active0 & 0x1000L) != 0L) [EOL]                 return jjStopAtPos(1, 12); [EOL]             else if ((active0 & 0x4000L) != 0L) [EOL]                 return jjStopAtPos(1, 14); [EOL]             else if ((active0 & 0x10000L) != 0L) [EOL]                 return jjStopAtPos(1, 16); [EOL]             break; [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0xc1012000000000L, active1, 0xa0L); [EOL]         case 100: [EOL]             if ((active0 & 0x8000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(1, 51, 12); [EOL]             break; [EOL]         case 101: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x10880900000000L, active1, 0x800L); [EOL]         case 104: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x1000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x40000000L, active1, 0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x400L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x104010000000L, active1, 0L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0xa262402a0000000L, active1, 0x300dL); [EOL]         case 114: [EOL]             if ((active0 & 0x8000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(1, 27, 12); [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x420400000000L, active1, 0x12L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x8500008000000000L, active1, 0L); [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x7000000000000000L, active1, 0x340L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(0, active0, active1); [EOL] } <line_num>: 480,535
private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(0, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(1, active0, active1); [EOL]         return 2; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x400000000000000L, active1, 0x2L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x7000000000000000L, active1, 0L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x20104000000000L, active1, 0L); [EOL]         case 100: [EOL]             if ((active0 & 0x10000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 28, 12); [EOL]             else if ((active0 & 0x20000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 29, 12); [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x80000000L, active1, 0L); [EOL]         case 101: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x420000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x1000000000L, active1, 0x800L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x240800000000L, active1, 0x60L); [EOL]         case 109: [EOL]             if ((active1 & 0x200L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 73, 12); [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0xc0010200000000L, active1, 0x100L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0xa00000000000000L, active1, 0x80L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x400000000L, active1, 0x404L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x8100002000000000L, active1, 0x2001L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x3880000000000L, active1, 0L); [EOL]         case 116: [EOL]             if ((active1 & 0x8L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 67, 12); [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x8000000000L, active1, 0L); [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x4000000000000L, active1, 0x1010L); [EOL]         case 118: [EOL]             if ((active0 & 0x40000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 30, 12); [EOL]             break; [EOL]         case 120: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x100000000L, active1, 0L); [EOL]         case 121: [EOL]             if ((active0 & 0x10000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 52, 12); [EOL]             break; [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(1, active0, active1); [EOL] } <line_num>: 536,597
private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(1, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(2, active0, active1); [EOL]         return 3; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x20000000000000L, active1, 0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x100L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x200ca0400000000L, active1, 0L); [EOL]         case 101: [EOL]             if ((active0 & 0x80000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(3, 31, 12); [EOL]             else if ((active0 & 0x80000000000000L) != 0L) { [EOL]                 jjmatchedKind = 55; [EOL]                 jjmatchedPos = 3; [EOL]             } else if ((active1 & 0x10L) != 0L) [EOL]                 return jjStartNfaWithStates_0(3, 68, 12); [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x40116000000000L, active1, 0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x800000000L, active1, 0L); [EOL]         case 103: [EOL]             if ((active1 & 0x80L) != 0L) [EOL]                 return jjStartNfaWithStates_0(3, 71, 12); [EOL]             break; [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x8102000000000000L, active1, 0L); [EOL]         case 108: [EOL]             if ((active1 & 0x40L) != 0L) [EOL]                 return jjStartNfaWithStates_0(3, 70, 12); [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x241000000000L, active1, 0x804L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x200000000L, active1, 0x2001L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x4000000000000L, active1, 0x1002L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x400L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x400008000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x7000000000000000L, active1, 0x20L); [EOL]         case 116: [EOL]             if ((active0 & 0x100000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(3, 32, 12); [EOL]             else if ((active0 & 0x1000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(3, 48, 12); [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x800000000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(2, active0, active1); [EOL] } <line_num>: 598,658
private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(2, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(3, active0, active1); [EOL]         return 4; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 58: [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x800000000L, active1, 0L); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0xa00000000000000L, active1, 0x2001L); [EOL]         case 100: [EOL]             if ((active1 & 0x1000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(4, 76, 12); [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x1000000000L, active1, 0L); [EOL]         case 101: [EOL]             if ((active1 & 0x20L) != 0L) [EOL]                 return jjStartNfaWithStates_0(4, 69, 12); [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0xca0600000000L, active1, 0x104L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x8000000000L, active1, 0x800L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x20000000000000L, active1, 0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x8100002000000000L, active1, 0L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x240000000000L, active1, 0L); [EOL]         case 114: [EOL]             if ((active1 & 0x400L) != 0L) [EOL]                 return jjStartNfaWithStates_0(4, 74, 12); [EOL]             break; [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x40114000000000L, active1, 0x2L); [EOL]         case 116: [EOL]             if ((active0 & 0x4000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(4, 50, 12); [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x7402000000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(3, active0, active1); [EOL] } <line_num>: 659,704
private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(3, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(4, active0, active1); [EOL]         return 5; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x20000000000000L, active1, 0L); [EOL]         case 58: [EOL]             if ((active0 & 0x800000000L) != 0L) [EOL]                 return jjStopAtPos(5, 35); [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x1000000000L, active1, 0L); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x4L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x8000000000L, active1, 0L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x420000000000L, active1, 0L); [EOL]         case 103: [EOL]             if ((active0 & 0x100000000000000L) != 0L) { [EOL]                 jjmatchedKind = 56; [EOL]                 jjmatchedPos = 5; [EOL]             } [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x8000000000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x802000000000000L, active1, 0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x3L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x880200000000L, active1, 0x800L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x40010000000000L, active1, 0L); [EOL]         case 114: [EOL]             if ((active1 & 0x100L) != 0L) [EOL]                 return jjStartNfaWithStates_0(5, 72, 12); [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x7000000000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x400000400000000L, active1, 0L); [EOL]         case 116: [EOL]             if ((active0 & 0x200000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(5, 57, 12); [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x106000000000L, active1, 0x2000L); [EOL]         case 119: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x240000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(4, active0, active1); [EOL] } <line_num>: 705,759
private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(4, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(5, active0, active1); [EOL]         return 6; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x8400000000000000L, active1, 0x2000L); [EOL]         case 58: [EOL]             if ((active0 & 0x1000000000L) != 0L) [EOL]                 return jjStopAtPos(6, 36); [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x2000000000L, active1, 0L); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x40010000000000L, active1, 0x2L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x880000000000L, active1, 0L); [EOL]         case 103: [EOL]             if ((active1 & 0x800L) != 0L) [EOL]                 return jjStartNfaWithStates_0(6, 75, 12); [EOL]             break; [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x7000660000000000L, active1, 0x1L); [EOL]         case 110: [EOL]             if ((active1 & 0x4L) != 0L) [EOL]                 return jjStartNfaWithStates_0(6, 66, 12); [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x820000000000000L, active1, 0L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x2104000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x400000000L, active1, 0L); [EOL]         case 116: [EOL]             if ((active0 & 0x200000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(6, 33, 12); [EOL]             break; [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x8000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(5, active0, active1); [EOL] } <line_num>: 760,805
private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(5, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(6, active0, active1); [EOL]         return 7; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 58: [EOL]             if ((active0 & 0x2000000000L) != 0L) [EOL]                 return jjStopAtPos(7, 37); [EOL]             break; [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x20880000000000L, active1, 0L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x40010000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x400000000L, active1, 0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x8000000000000000L, active1, 0L); [EOL]         case 110: [EOL]             if ((active0 & 0x2000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(7, 49, 12); [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x7000660000000000L, active1, 0x2000L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x104000000000L, active1, 0L); [EOL]         case 115: [EOL]             if ((active0 & 0x800000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(7, 59, 12); [EOL]             break; [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x8000000000L, active1, 0x2L); [EOL]         case 119: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x400000000000000L, active1, 0L); [EOL]         case 122: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x1L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(6, active0, active1); [EOL] } <line_num>: 806,849
private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(6, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(7, active0, active1); [EOL]         return 8; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x100000000000L, active1, 0L); [EOL]         case 58: [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x4000000000L, active1, 0L); [EOL]         case 101: [EOL]             if ((active1 & 0x2L) != 0L) [EOL]                 return jjStartNfaWithStates_0(8, 65, 12); [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x8040018000000000L, active1, 0x1L); [EOL]         case 103: [EOL]             if ((active0 & 0x4000000000000000L) != 0L) { [EOL]                 jjmatchedKind = 62; [EOL]                 jjmatchedPos = 8; [EOL]             } [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x3000660000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x400000000000000L, active1, 0L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x20000000000000L, active1, 0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x880400000000L, active1, 0L); [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x2000L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(7, active0, active1); [EOL] } <line_num>: 850,888
private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(7, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(8, active0, active1); [EOL]         return 9; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0x3040600000000000L, active1, 0x1L); [EOL]         case 58: [EOL]             if ((active0 & 0x4000000000L) != 0L) [EOL]                 return jjStopAtPos(9, 38); [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0x78000000000L, active1, 0L); [EOL]         case 101: [EOL]             if ((active0 & 0x20000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(9, 53, 12); [EOL]             break; [EOL]         case 103: [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0x400000000L, active1, 0L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x2000L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0x8000000000000000L, active1, 0L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0x100000000000L, active1, 0L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0x400880000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(8, active0, active1); [EOL] } <line_num>: 889,924
private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(8, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(9, active0, active1); [EOL]         return 10; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x800400000000L, active1, 0L); [EOL]         case 58: [EOL]             if ((active0 & 0x8000000000L) != 0L) [EOL]                 return jjStopAtPos(10, 39); [EOL]             else if ((active0 & 0x10000000000L) != 0L) [EOL]                 return jjStopAtPos(10, 40); [EOL]             else if ((active0 & 0x20000000000L) != 0L) [EOL]                 return jjStopAtPos(10, 41); [EOL]             else if ((active0 & 0x40000000000L) != 0L) [EOL]                 return jjStopAtPos(10, 42); [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x80000000000L, active1, 0L); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x2000000000000000L, active1, 0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x1000000000000000L, active1, 0x2000L); [EOL]         case 103: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x8000000000000000L, active1, 0L); [EOL]         case 104: [EOL]             if ((active0 & 0x400000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(10, 58, 12); [EOL]             break; [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x100000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x600000000000L, active1, 0x1L); [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x40000000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(9, active0, active1); [EOL] } <line_num>: 925,968
private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(9, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(10, active0, active1); [EOL]         return 11; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x100000000000L, active1, 0L); [EOL]         case 58: [EOL]             if ((active0 & 0x80000000000L) != 0L) [EOL]                 return jjStopAtPos(11, 43); [EOL]             break; [EOL]         case 101: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x1000000000000000L, active1, 0x2000L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x2000000000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x600400000000L, active1, 0L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x800000000000L, active1, 0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0L, active1, 0x1L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x40000000000000L, active1, 0L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x8000000000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(10, active0, active1); [EOL] } <line_num>: 969,1004
private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(10, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(11, active0, active1); [EOL]         return 12; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0L, active1, 0x1L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0x600000000000L, active1, 0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0x1000000000000000L, active1, 0L); [EOL]         case 104: [EOL]             if ((active0 & 0x8000000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(12, 63, 12); [EOL]             break; [EOL]         case 105: [EOL]             if ((active0 & 0x40000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(12, 54, 12); [EOL]             break; [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0x400000000L, active1, 0L); [EOL]         case 114: [EOL]             if ((active1 & 0x2000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(12, 77, 12); [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0x800000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0x100000000000L, active1, 0L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0x2000000000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(11, active0, active1); [EOL] } <line_num>: 1005,1044
private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(11, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(12, active0, active1); [EOL]         return 13; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa14_0(active0, 0x800000000000L, active1, 0L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa14_0(active0, 0L, active1, 0x1L); [EOL]         case 101: [EOL]             return jjMoveStringLiteralDfa14_0(active0, 0x2000100000000000L, active1, 0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa14_0(active0, 0x600000000000L, active1, 0L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa14_0(active0, 0x1000000000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa14_0(active0, 0x400000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(12, active0, active1); [EOL] } <line_num>: 1045,1072
private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(12, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(13, active0, active1); [EOL]         return 14; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 101: [EOL]             if ((active1 & 0x1L) != 0L) [EOL]                 return jjStartNfaWithStates_0(14, 64, 12); [EOL]             break; [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa15_0(active0, 0x600000000000L, active1, 0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa15_0(active0, 0x100000000000L, active1, 0L); [EOL]         case 114: [EOL]             if ((active0 & 0x2000000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(14, 61, 12); [EOL]             return jjMoveStringLiteralDfa15_0(active0, 0x1000000000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa15_0(active0, 0x800000000000L, active1, 0L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa15_0(active0, 0x400000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(13, active0, active1); [EOL] } <line_num>: 1073,1104
private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(13, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(14, active0, 0L); [EOL]         return 15; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 101: [EOL]             if ((active0 & 0x1000000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(15, 60, 12); [EOL]             return jjMoveStringLiteralDfa16_0(active0, 0x800000000000L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa16_0(active0, 0x100000000000L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa16_0(active0, 0x600000000000L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa16_0(active0, 0x400000000L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(14, active0, 0L); [EOL] } <line_num>: 1105,1130
private final int jjMoveStringLiteralDfa16_0(long old0, long active0) { [EOL]     if (((active0 &= old0)) == 0L) [EOL]         return jjStartNfa_0(14, old0, 0L); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(15, active0, 0L); [EOL]         return 16; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 58: [EOL]             return jjMoveStringLiteralDfa17_0(active0, 0x100000000000L); [EOL]         case 103: [EOL]             return jjMoveStringLiteralDfa17_0(active0, 0x600000000000L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa17_0(active0, 0x800000000000L); [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa17_0(active0, 0x400000000L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(15, active0, 0L); [EOL] } <line_num>: 1131,1154
private final int jjMoveStringLiteralDfa17_0(long old0, long active0) { [EOL]     if (((active0 &= old0)) == 0L) [EOL]         return jjStartNfa_0(15, old0, 0L); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(16, active0, 0L); [EOL]         return 17; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 58: [EOL]             if ((active0 & 0x100000000000L) != 0L) [EOL]                 return jjStopAtPos(17, 44); [EOL]             return jjMoveStringLiteralDfa18_0(active0, 0x600000000000L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa18_0(active0, 0x400000000L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa18_0(active0, 0x800000000000L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(16, active0, 0L); [EOL] } <line_num>: 1155,1178
private final int jjMoveStringLiteralDfa18_0(long old0, long active0) { [EOL]     if (((active0 &= old0)) == 0L) [EOL]         return jjStartNfa_0(16, old0, 0L); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(17, active0, 0L); [EOL]         return 18; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 58: [EOL]             if ((active0 & 0x200000000000L) != 0L) [EOL]                 return jjStopAtPos(18, 45); [EOL]             else if ((active0 & 0x400000000000L) != 0L) [EOL]                 return jjStopAtPos(18, 46); [EOL]             return jjMoveStringLiteralDfa19_0(active0, 0x800000000000L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa19_0(active0, 0x400000000L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(17, active0, 0L); [EOL] } <line_num>: 1179,1202
private final int jjMoveStringLiteralDfa19_0(long old0, long active0) { [EOL]     if (((active0 &= old0)) == 0L) [EOL]         return jjStartNfa_0(17, old0, 0L); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(18, active0, 0L); [EOL]         return 19; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 58: [EOL]             if ((active0 & 0x800000000000L) != 0L) [EOL]                 return jjStopAtPos(19, 47); [EOL]             break; [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa20_0(active0, 0x400000000L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(18, active0, 0L); [EOL] } <line_num>: 1203,1224
private final int jjMoveStringLiteralDfa20_0(long old0, long active0) { [EOL]     if (((active0 &= old0)) == 0L) [EOL]         return jjStartNfa_0(18, old0, 0L); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(19, active0, 0L); [EOL]         return 20; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa21_0(active0, 0x400000000L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(19, active0, 0L); [EOL] } <line_num>: 1225,1242
private final int jjMoveStringLiteralDfa21_0(long old0, long active0) { [EOL]     if (((active0 &= old0)) == 0L) [EOL]         return jjStartNfa_0(19, old0, 0L); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(20, active0, 0L); [EOL]         return 21; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 110: [EOL]             if ((active0 & 0x400000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(21, 34, 12); [EOL]             break; [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(20, active0, 0L); [EOL] } <line_num>: 1243,1262
private final void jjCheckNAdd(int state) { [EOL]     if (jjrounds[state] != jjround) { [EOL]         jjstateSet[jjnewStateCnt++] = state; [EOL]         jjrounds[state] = jjround; [EOL]     } [EOL] } <line_num>: 1263,1270
private final void jjAddStates(int start, int end) { [EOL]     do { [EOL]         jjstateSet[jjnewStateCnt++] = jjnextStates[start]; [EOL]     } while (start++ != end); [EOL] } <line_num>: 1271,1276
private final void jjCheckNAddTwoStates(int state1, int state2) { [EOL]     jjCheckNAdd(state1); [EOL]     jjCheckNAdd(state2); [EOL] } <line_num>: 1277,1281
private final void jjCheckNAddStates(int start, int end) { [EOL]     do { [EOL]         jjCheckNAdd(jjnextStates[start]); [EOL]     } while (start++ != end); [EOL] } <line_num>: 1282,1287
private final void jjCheckNAddStates(int start) { [EOL]     jjCheckNAdd(jjnextStates[start]); [EOL]     jjCheckNAdd(jjnextStates[start + 1]); [EOL] } <line_num>: 1288,1292
private final int jjMoveNfa_0(int startState, int curPos) { [EOL]     int[] nextStates; [EOL]     int startsAt = 0; [EOL]     jjnewStateCnt = 13; [EOL]     int i = 1; [EOL]     jjstateSet[0] = startState; [EOL]     int j, kind = 0x7fffffff; [EOL]     for (; ; ) { [EOL]         if (++jjround == 0x7fffffff) [EOL]             ReInitRounds(); [EOL]         if (curChar < 64) { [EOL]             long l = 1L << curChar; [EOL]             MatchLoop: do { [EOL]                 switch(jjstateSet[--i]) { [EOL]                     case 0: [EOL]                         if ((0x3ff000000000000L & l) != 0L) { [EOL]                             if (kind > 20) [EOL]                                 kind = 20; [EOL]                             jjCheckNAddTwoStates(6, 7); [EOL]                         } else if (curChar == 46) [EOL]                             jjCheckNAdd(10); [EOL]                         else if (curChar == 39) [EOL]                             jjCheckNAddTwoStates(4, 5); [EOL]                         else if (curChar == 34) [EOL]                             jjCheckNAddTwoStates(1, 2); [EOL]                         break; [EOL]                     case 1: [EOL]                         if ((0xfffffffbffffffffL & l) != 0L) [EOL]                             jjCheckNAddTwoStates(1, 2); [EOL]                         break; [EOL]                     case 2: [EOL]                         if (curChar == 34 && kind > 18) [EOL]                             kind = 18; [EOL]                         break; [EOL]                     case 3: [EOL]                         if (curChar == 39) [EOL]                             jjCheckNAddTwoStates(4, 5); [EOL]                         break; [EOL]                     case 4: [EOL]                         if ((0xffffff7fffffffffL & l) != 0L) [EOL]                             jjCheckNAddTwoStates(4, 5); [EOL]                         break; [EOL]                     case 5: [EOL]                         if (curChar == 39 && kind > 18) [EOL]                             kind = 18; [EOL]                         break; [EOL]                     case 6: [EOL]                         if ((0x3ff000000000000L & l) == 0L) [EOL]                             break; [EOL]                         if (kind > 20) [EOL]                             kind = 20; [EOL]                         jjCheckNAddTwoStates(6, 7); [EOL]                         break; [EOL]                     case 7: [EOL]                         if (curChar != 46) [EOL]                             break; [EOL]                         if (kind > 20) [EOL]                             kind = 20; [EOL]                         jjCheckNAdd(8); [EOL]                         break; [EOL]                     case 8: [EOL]                         if ((0x3ff000000000000L & l) == 0L) [EOL]                             break; [EOL]                         if (kind > 20) [EOL]                             kind = 20; [EOL]                         jjCheckNAdd(8); [EOL]                         break; [EOL]                     case 9: [EOL]                         if (curChar == 46) [EOL]                             jjCheckNAdd(10); [EOL]                         break; [EOL]                     case 10: [EOL]                         if ((0x3ff000000000000L & l) == 0L) [EOL]                             break; [EOL]                         if (kind > 20) [EOL]                             kind = 20; [EOL]                         jjCheckNAdd(10); [EOL]                         break; [EOL]                     case 12: [EOL]                         if ((0x3ff600000000000L & l) == 0L) [EOL]                             break; [EOL]                         if (kind > 78) [EOL]                             kind = 78; [EOL]                         jjstateSet[jjnewStateCnt++] = 12; [EOL]                         break; [EOL]                     default: [EOL]                         break; [EOL]                 } [EOL]             } while (i != startsAt); [EOL]         } else if (curChar < 128) { [EOL]             long l = 1L << (curChar & 077); [EOL]             MatchLoop: do { [EOL]                 switch(jjstateSet[--i]) { [EOL]                     case 0: [EOL]                     case 12: [EOL]                         if ((0x7fffffe87fffffeL & l) == 0L) [EOL]                             break; [EOL]                         if (kind > 78) [EOL]                             kind = 78; [EOL]                         jjCheckNAdd(12); [EOL]                         break; [EOL]                     case 1: [EOL]                         jjAddStates(0, 1); [EOL]                         break; [EOL]                     case 4: [EOL]                         jjAddStates(2, 3); [EOL]                         break; [EOL]                     default: [EOL]                         break; [EOL]                 } [EOL]             } while (i != startsAt); [EOL]         } else { [EOL]             int hiByte = (int) (curChar >> 8); [EOL]             int i1 = hiByte >> 6; [EOL]             long l1 = 1L << (hiByte & 077); [EOL]             int i2 = (curChar & 0xff) >> 6; [EOL]             long l2 = 1L << (curChar & 077); [EOL]             MatchLoop: do { [EOL]                 switch(jjstateSet[--i]) { [EOL]                     case 0: [EOL]                         if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) [EOL]                             break; [EOL]                         if (kind > 78) [EOL]                             kind = 78; [EOL]                         jjCheckNAdd(12); [EOL]                         break; [EOL]                     case 1: [EOL]                         if (jjCanMove_0(hiByte, i1, i2, l1, l2)) [EOL]                             jjAddStates(0, 1); [EOL]                         break; [EOL]                     case 4: [EOL]                         if (jjCanMove_0(hiByte, i1, i2, l1, l2)) [EOL]                             jjAddStates(2, 3); [EOL]                         break; [EOL]                     case 12: [EOL]                         if (!jjCanMove_2(hiByte, i1, i2, l1, l2)) [EOL]                             break; [EOL]                         if (kind > 78) [EOL]                             kind = 78; [EOL]                         jjCheckNAdd(12); [EOL]                         break; [EOL]                     default: [EOL]                         break; [EOL]                 } [EOL]             } while (i != startsAt); [EOL]         } [EOL]         if (kind != 0x7fffffff) { [EOL]             jjmatchedKind = kind; [EOL]             jjmatchedPos = curPos; [EOL]             kind = 0x7fffffff; [EOL]         } [EOL]         ++curPos; [EOL]         if ((i = jjnewStateCnt) == (startsAt = 13 - (jjnewStateCnt = startsAt))) [EOL]             return curPos; [EOL]         try { [EOL]             curChar = input_stream.readChar(); [EOL]         } catch (java.io.IOException e) { [EOL]             return curPos; [EOL]         } [EOL]     } [EOL] } <line_num>: 1416,1586
private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2) { [EOL]     switch(hiByte) { [EOL]         case 0: [EOL]             return ((jjbitVec2[i2] & l2) != 0L); [EOL]         default: [EOL]             if ((jjbitVec0[i1] & l1) != 0L) [EOL]                 return true; [EOL]             return false; [EOL]     } [EOL] } <line_num>: 1590,1601
private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2) { [EOL]     switch(hiByte) { [EOL]         case 0: [EOL]             return ((jjbitVec4[i2] & l2) != 0L); [EOL]         case 1: [EOL]             return ((jjbitVec5[i2] & l2) != 0L); [EOL]         case 2: [EOL]             return ((jjbitVec6[i2] & l2) != 0L); [EOL]         case 3: [EOL]             return ((jjbitVec7[i2] & l2) != 0L); [EOL]         case 4: [EOL]             return ((jjbitVec8[i2] & l2) != 0L); [EOL]         case 5: [EOL]             return ((jjbitVec9[i2] & l2) != 0L); [EOL]         case 6: [EOL]             return ((jjbitVec10[i2] & l2) != 0L); [EOL]         case 9: [EOL]             return ((jjbitVec11[i2] & l2) != 0L); [EOL]         case 10: [EOL]             return ((jjbitVec12[i2] & l2) != 0L); [EOL]         case 11: [EOL]             return ((jjbitVec13[i2] & l2) != 0L); [EOL]         case 12: [EOL]             return ((jjbitVec14[i2] & l2) != 0L); [EOL]         case 13: [EOL]             return ((jjbitVec15[i2] & l2) != 0L); [EOL]         case 14: [EOL]             return ((jjbitVec16[i2] & l2) != 0L); [EOL]         case 15: [EOL]             return ((jjbitVec17[i2] & l2) != 0L); [EOL]         case 16: [EOL]             return ((jjbitVec18[i2] & l2) != 0L); [EOL]         case 17: [EOL]             return ((jjbitVec19[i2] & l2) != 0L); [EOL]         case 30: [EOL]             return ((jjbitVec20[i2] & l2) != 0L); [EOL]         case 31: [EOL]             return ((jjbitVec21[i2] & l2) != 0L); [EOL]         case 33: [EOL]             return ((jjbitVec22[i2] & l2) != 0L); [EOL]         case 48: [EOL]             return ((jjbitVec23[i2] & l2) != 0L); [EOL]         case 49: [EOL]             return ((jjbitVec24[i2] & l2) != 0L); [EOL]         case 159: [EOL]             return ((jjbitVec25[i2] & l2) != 0L); [EOL]         case 215: [EOL]             return ((jjbitVec26[i2] & l2) != 0L); [EOL]         default: [EOL]             if ((jjbitVec3[i1] & l1) != 0L) [EOL]                 return true; [EOL]             return false; [EOL]     } [EOL] } <line_num>: 1602,1657
private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2) { [EOL]     switch(hiByte) { [EOL]         case 0: [EOL]             return ((jjbitVec27[i2] & l2) != 0L); [EOL]         case 1: [EOL]             return ((jjbitVec5[i2] & l2) != 0L); [EOL]         case 2: [EOL]             return ((jjbitVec28[i2] & l2) != 0L); [EOL]         case 3: [EOL]             return ((jjbitVec29[i2] & l2) != 0L); [EOL]         case 4: [EOL]             return ((jjbitVec30[i2] & l2) != 0L); [EOL]         case 5: [EOL]             return ((jjbitVec31[i2] & l2) != 0L); [EOL]         case 6: [EOL]             return ((jjbitVec32[i2] & l2) != 0L); [EOL]         case 9: [EOL]             return ((jjbitVec33[i2] & l2) != 0L); [EOL]         case 10: [EOL]             return ((jjbitVec34[i2] & l2) != 0L); [EOL]         case 11: [EOL]             return ((jjbitVec35[i2] & l2) != 0L); [EOL]         case 12: [EOL]             return ((jjbitVec36[i2] & l2) != 0L); [EOL]         case 13: [EOL]             return ((jjbitVec37[i2] & l2) != 0L); [EOL]         case 14: [EOL]             return ((jjbitVec38[i2] & l2) != 0L); [EOL]         case 15: [EOL]             return ((jjbitVec39[i2] & l2) != 0L); [EOL]         case 16: [EOL]             return ((jjbitVec18[i2] & l2) != 0L); [EOL]         case 17: [EOL]             return ((jjbitVec19[i2] & l2) != 0L); [EOL]         case 30: [EOL]             return ((jjbitVec20[i2] & l2) != 0L); [EOL]         case 31: [EOL]             return ((jjbitVec21[i2] & l2) != 0L); [EOL]         case 32: [EOL]             return ((jjbitVec40[i2] & l2) != 0L); [EOL]         case 33: [EOL]             return ((jjbitVec22[i2] & l2) != 0L); [EOL]         case 48: [EOL]             return ((jjbitVec41[i2] & l2) != 0L); [EOL]         case 49: [EOL]             return ((jjbitVec24[i2] & l2) != 0L); [EOL]         case 159: [EOL]             return ((jjbitVec25[i2] & l2) != 0L); [EOL]         case 215: [EOL]             return ((jjbitVec26[i2] & l2) != 0L); [EOL]         default: [EOL]             if ((jjbitVec3[i1] & l1) != 0L) [EOL]                 return true; [EOL]             return false; [EOL]     } [EOL] } <line_num>: 1658,1715
public void ReInit(SimpleCharStream stream) { [EOL]     jjmatchedPos = jjnewStateCnt = 0; [EOL]     curLexState = defaultLexState; [EOL]     input_stream = stream; [EOL]     ReInitRounds(); [EOL] } <line_num>: 1762,1768
private final void ReInitRounds() { [EOL]     int i; [EOL]     jjround = 0x80000001; [EOL]     for (i = 13; i-- > 0; ) jjrounds[i] = 0x80000000; [EOL] } <line_num>: 1769,1775
public void ReInit(SimpleCharStream stream, int lexState) { [EOL]     ReInit(stream); [EOL]     SwitchTo(lexState); [EOL] } <line_num>: 1776,1780
public void SwitchTo(int lexState) { [EOL]     if (lexState >= 1 || lexState < 0) [EOL]         throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE); [EOL]     else [EOL]         curLexState = lexState; [EOL] } <line_num>: 1781,1787
protected Token jjFillToken() { [EOL]     Token t = Token.newToken(jjmatchedKind); [EOL]     t.kind = jjmatchedKind; [EOL]     String im = jjstrLiteralImages[jjmatchedKind]; [EOL]     t.image = (im == null) ? input_stream.GetImage() : im; [EOL]     t.beginLine = input_stream.getBeginLine(); [EOL]     t.beginColumn = input_stream.getBeginColumn(); [EOL]     t.endLine = input_stream.getEndLine(); [EOL]     t.endColumn = input_stream.getEndColumn(); [EOL]     return t; [EOL] } <line_num>: 1789,1800
public Token getNextToken() { [EOL]     int kind; [EOL]     Token specialToken = null; [EOL]     Token matchedToken; [EOL]     int curPos = 0; [EOL]     EOFLoop: for (; ; ) { [EOL]         try { [EOL]             curChar = input_stream.BeginToken(); [EOL]         } catch (java.io.IOException e) { [EOL]             jjmatchedKind = 0; [EOL]             matchedToken = jjFillToken(); [EOL]             return matchedToken; [EOL]         } [EOL]         try { [EOL]             input_stream.backup(0); [EOL]             while (curChar <= 32 && (0x100003600L & (1L << curChar)) != 0L) curChar = input_stream.BeginToken(); [EOL]         } catch (java.io.IOException e1) { [EOL]             continue EOFLoop; [EOL]         } [EOL]         jjmatchedKind = 0x7fffffff; [EOL]         jjmatchedPos = 0; [EOL]         curPos = jjMoveStringLiteralDfa0_0(); [EOL]         if (jjmatchedKind != 0x7fffffff) { [EOL]             if (jjmatchedPos + 1 < curPos) [EOL]                 input_stream.backup(curPos - jjmatchedPos - 1); [EOL]             if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L) { [EOL]                 matchedToken = jjFillToken(); [EOL]                 return matchedToken; [EOL]             } else { [EOL]                 continue EOFLoop; [EOL]             } [EOL]         } [EOL]         int error_line = input_stream.getEndLine(); [EOL]         int error_column = input_stream.getEndColumn(); [EOL]         String error_after = null; [EOL]         boolean EOFSeen = false; [EOL]         try { [EOL]             input_stream.readChar(); [EOL]             input_stream.backup(1); [EOL]         } catch (java.io.IOException e1) { [EOL]             EOFSeen = true; [EOL]             error_after = curPos <= 1 ? "" : input_stream.GetImage(); [EOL]             if (curChar == '\n' || curChar == '\r') { [EOL]                 error_line++; [EOL]                 error_column = 0; [EOL]             } else [EOL]                 error_column++; [EOL]         } [EOL]         if (!EOFSeen) { [EOL]             input_stream.backup(1); [EOL]             error_after = curPos <= 1 ? "" : input_stream.GetImage(); [EOL]         } [EOL]         throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR); [EOL]     } [EOL] } <line_num>: 1809,1873
