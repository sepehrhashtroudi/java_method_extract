public static Constructor lookupConstructor(Class targetClass, Object[] parameters) { [EOL]     boolean tryExact = true; [EOL]     int count = parameters == null ? 0 : parameters.length; [EOL]     Class[] types = new Class[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i]; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Constructor constructor = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             constructor = targetClass.getConstructor(types); [EOL]             if (constructor != null) { [EOL]                 return constructor; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Constructor[] constructors = targetClass.getConstructors(); [EOL]     for (int i = 0; i < constructors.length; i++) { [EOL]         int match = matchParameterTypes(constructors[i].getParameterTypes(), parameters); [EOL]         if (match != NO_MATCH) { [EOL]             if (match > currentMatch) { [EOL]                 constructor = constructors[i]; [EOL]                 currentMatch = match; [EOL]                 ambiguous = false; [EOL]             } else if (match == currentMatch) { [EOL]                 ambiguous = true; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous constructor " + Arrays.asList(parameters)); [EOL]     } [EOL]     return constructor; [EOL] } <line_num>: 41,100
public static Method lookupStaticMethod(Class targetClass, String name, Object[] parameters) { [EOL]     boolean tryExact = true; [EOL]     int count = parameters == null ? 0 : parameters.length; [EOL]     Class[] types = new Class[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i]; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), parameters); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] } <line_num>: 102,165
public static Method lookupMethod(Class targetClass, String name, Object[] parameters) { [EOL]     if (parameters == null || parameters.length < 1 || parameters[0] == null) { [EOL]         return null; [EOL]     } [EOL]     if (matchType(targetClass, parameters[0]) == NO_MATCH) { [EOL]         return null; [EOL]     } [EOL]     targetClass = TypeUtils.convert(parameters[0], targetClass).getClass(); [EOL]     boolean tryExact = true; [EOL]     int count = parameters.length - 1; [EOL]     Class[] types = new Class[count]; [EOL]     Object[] arguments = new Object[count]; [EOL]     for (int i = 0; i < count; i++) { [EOL]         Object param = parameters[i + 1]; [EOL]         arguments[i] = param; [EOL]         if (param != null) { [EOL]             types[i] = param.getClass(); [EOL]         } else { [EOL]             types[i] = null; [EOL]             tryExact = false; [EOL]         } [EOL]     } [EOL]     Method method = null; [EOL]     if (tryExact) { [EOL]         try { [EOL]             method = targetClass.getMethod(name, types); [EOL]             if (method != null && !Modifier.isStatic(method.getModifiers())) { [EOL]                 return method; [EOL]             } [EOL]         } catch (NoSuchMethodException ex) { [EOL]         } [EOL]     } [EOL]     int currentMatch = 0; [EOL]     boolean ambiguous = false; [EOL]     Method[] methods = targetClass.getMethods(); [EOL]     for (int i = 0; i < methods.length; i++) { [EOL]         if (!Modifier.isStatic(methods[i].getModifiers()) && methods[i].getName().equals(name)) { [EOL]             int match = matchParameterTypes(methods[i].getParameterTypes(), arguments); [EOL]             if (match != NO_MATCH) { [EOL]                 if (match > currentMatch) { [EOL]                     method = methods[i]; [EOL]                     currentMatch = match; [EOL]                     ambiguous = false; [EOL]                 } else if (match == currentMatch) { [EOL]                     ambiguous = true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ambiguous) { [EOL]         throw new JXPathException("Ambigous method call: " + name); [EOL]     } [EOL]     return method; [EOL] } <line_num>: 167,244
private static int matchParameterTypes(Class[] types, Object[] parameters) { [EOL]     int pi = 0; [EOL]     if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])) { [EOL]         pi++; [EOL]     } [EOL]     int length = parameters == null ? 0 : parameters.length; [EOL]     if (types.length != length + pi) { [EOL]         return NO_MATCH; [EOL]     } [EOL]     int totalMatch = EXACT_MATCH; [EOL]     for (int i = 0; i < length; i++) { [EOL]         int match = matchType(types[i + pi], parameters[i]); [EOL]         if (match == NO_MATCH) { [EOL]             return NO_MATCH; [EOL]         } [EOL]         if (match < totalMatch) { [EOL]             totalMatch = match; [EOL]         } [EOL]     } [EOL]     return totalMatch; [EOL] } <line_num>: 246,270
private static int matchType(Class expected, Object object) { [EOL]     if (object == null) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     Class actual = object.getClass(); [EOL]     if (expected.equals(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (expected.isAssignableFrom(actual)) { [EOL]         return EXACT_MATCH; [EOL]     } [EOL]     if (TypeUtils.canConvert(object, expected)) { [EOL]         return APPROXIMATE_MATCH; [EOL]     } [EOL]     return NO_MATCH; [EOL] } <line_num>: 272,291
