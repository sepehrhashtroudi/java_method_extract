public static boolean isCollection(Object value) { [EOL]     if (value == null) { [EOL]         return false; [EOL]     } [EOL]     value = getValue(value); [EOL]     if (value.getClass().isArray()) { [EOL]         return true; [EOL]     } else if (value instanceof Collection) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } <line_num>: 50,62
public static int getCollectionHint(Class clazz) { [EOL]     if (clazz.isArray()) { [EOL]         return 1; [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(clazz)) { [EOL]         return 1; [EOL]     } [EOL]     if (clazz.isPrimitive()) { [EOL]         return -1; [EOL]     } [EOL]     if (clazz.isInterface()) { [EOL]         return 0; [EOL]     } [EOL]     if (Modifier.isFinal(clazz.getModifiers())) { [EOL]         return -1; [EOL]     } [EOL]     return 0; [EOL] } <line_num>: 69,91
public static int getIndexedPropertyLength(Object object, IndexedPropertyDescriptor pd) { [EOL]     if (pd.getReadMethod() != null) { [EOL]         return getLength(getValue(object, pd)); [EOL]     } [EOL]     Method readMethod = pd.getIndexedReadMethod(); [EOL]     if (readMethod == null) { [EOL]         throw new JXPathException("No indexed read method for property " + pd.getName()); [EOL]     } [EOL]     for (int i = 0; i < UNKNOWN_LENGTH_MAX_COUNT; i++) { [EOL]         try { [EOL]             readMethod.invoke(object, new Object[] { new Integer(i) }); [EOL]         } catch (Throwable t) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     throw new JXPathException("Cannot determine the length of the indexed property " + pd.getName()); [EOL] } <line_num>: 101,127
public static int getLength(Object collection) { [EOL]     if (collection == null) { [EOL]         return 0; [EOL]     } [EOL]     collection = getValue(collection); [EOL]     if (collection.getClass().isArray()) { [EOL]         return Array.getLength(collection); [EOL]     } else if (collection instanceof Collection) { [EOL]         return ((Collection) collection).size(); [EOL]     } else { [EOL]         return 1; [EOL]     } [EOL] } <line_num>: 133,147
public static Iterator iterate(Object collection) { [EOL]     if (collection == null) { [EOL]         return Collections.EMPTY_LIST.iterator(); [EOL]     } [EOL]     if (collection.getClass().isArray()) { [EOL]         int length = Array.getLength(collection); [EOL]         if (length == 0) { [EOL]             return Collections.EMPTY_LIST.iterator(); [EOL]         } [EOL]         ArrayList list = new ArrayList(); [EOL]         for (int i = 0; i < length; i++) { [EOL]             list.add(Array.get(collection, i)); [EOL]         } [EOL]         return list.iterator(); [EOL]     } else if (collection instanceof Collection) { [EOL]         return ((Collection) collection).iterator(); [EOL]     } else { [EOL]         return Collections.singletonList(collection).iterator(); [EOL]     } [EOL] } <line_num>: 154,175
public static Object expandCollection(Object collection, int size) { [EOL]     if (collection == null) { [EOL]         return null; [EOL]     } else if (collection.getClass().isArray()) { [EOL]         Object bigger = Array.newInstance(collection.getClass().getComponentType(), size); [EOL]         System.arraycopy(collection, 0, bigger, 0, Array.getLength(collection)); [EOL]         return bigger; [EOL]     } else if (collection instanceof Collection) { [EOL]         while (((Collection) collection).size() < size) { [EOL]             ((Collection) collection).add(null); [EOL]         } [EOL]         return collection; [EOL]     } else { [EOL]         throw new JXPathException("Cannot turn " + collection.getClass().getName() + " into a collection of size " + size); [EOL]     } [EOL] } <line_num>: 181,211
public static Object remove(Object collection, int index) { [EOL]     collection = getValue(collection); [EOL]     if (collection == null) { [EOL]         return null; [EOL]     } else if (collection.getClass().isArray()) { [EOL]         int length = Array.getLength(collection); [EOL]         Object smaller = Array.newInstance(collection.getClass().getComponentType(), length - 1); [EOL]         if (index > 0) { [EOL]             System.arraycopy(collection, 0, smaller, 0, index); [EOL]         } [EOL]         if (index < length - 1) { [EOL]             System.arraycopy(collection, index + 1, smaller, index, length - index - 1); [EOL]         } [EOL]         return smaller; [EOL]     } else if (collection instanceof List) { [EOL]         int size = ((List) collection).size(); [EOL]         if (index < size) { [EOL]             ((List) collection).remove(index); [EOL]         } [EOL]         return collection; [EOL]     } else if (collection instanceof Collection) { [EOL]         Iterator it = ((Collection) collection).iterator(); [EOL]         for (int i = 0; i < index; i++) { [EOL]             if (!it.hasNext()) { [EOL]                 break; [EOL]             } [EOL]             it.next(); [EOL]         } [EOL]         if (it.hasNext()) { [EOL]             it.next(); [EOL]             it.remove(); [EOL]         } [EOL]         return collection; [EOL]     } else { [EOL]         throw new JXPathException("Cannot remove " + collection.getClass().getName() + "[" + index + "]"); [EOL]     } [EOL] } <line_num>: 216,269
public static Object getValue(Object collection, int index) { [EOL]     collection = getValue(collection); [EOL]     Object value = collection; [EOL]     if (collection != null) { [EOL]         if (collection.getClass().isArray()) { [EOL]             if (index < 0 || index >= Array.getLength(collection)) { [EOL]                 return null; [EOL]             } [EOL]             value = Array.get(collection, index); [EOL]         } else if (collection instanceof List) { [EOL]             if (index < 0 || index >= ((List) collection).size()) { [EOL]                 return null; [EOL]             } [EOL]             value = ((List) collection).get(index); [EOL]         } else if (collection instanceof Collection) { [EOL]             int i = 0; [EOL]             Iterator it = ((Collection) collection).iterator(); [EOL]             for (; i < index; i++) { [EOL]                 it.next(); [EOL]             } [EOL]             if (it.hasNext()) { [EOL]                 value = it.next(); [EOL]             } else { [EOL]                 value = null; [EOL]             } [EOL]         } [EOL]     } [EOL]     return value; [EOL] } <line_num>: 274,305
public static void setValue(Object collection, int index, Object value) { [EOL]     collection = getValue(collection); [EOL]     if (collection != null) { [EOL]         if (collection.getClass().isArray()) { [EOL]             Array.set(collection, index, convert(value, collection.getClass().getComponentType())); [EOL]         } else if (collection instanceof List) { [EOL]             ((List) collection).set(index, value); [EOL]         } else if (collection instanceof Collection) { [EOL]             throw new UnsupportedOperationException("Cannot set value of an element of a " + collection.getClass().getName()); [EOL]         } [EOL]     } [EOL] } <line_num>: 311,329
public static Object getValue(Object bean, PropertyDescriptor propertyDescriptor) { [EOL]     Object value; [EOL]     try { [EOL]         Method method = getAccessibleMethod(propertyDescriptor.getReadMethod()); [EOL]         if (method == null) { [EOL]             throw new JXPathException("No read method"); [EOL]         } [EOL]         value = method.invoke(bean, new Object[0]); [EOL]     } catch (Exception ex) { [EOL]         throw new JXPathException("Cannot access property: " + (bean == null ? "null" : bean.getClass().getName()) + "." + propertyDescriptor.getName(), ex); [EOL]     } [EOL]     return value; [EOL] } <line_num>: 335,357
public static void setValue(Object bean, PropertyDescriptor propertyDescriptor, Object value) { [EOL]     try { [EOL]         Method method = getAccessibleMethod(propertyDescriptor.getWriteMethod()); [EOL]         if (method == null) { [EOL]             throw new JXPathException("No write method"); [EOL]         } [EOL]         value = convert(value, propertyDescriptor.getPropertyType()); [EOL]         value = method.invoke(bean, new Object[] { value }); [EOL]     } catch (Exception ex) { [EOL]         throw new JXPathException("Cannot modify property: " + (bean == null ? "null" : bean.getClass().getName()) + "." + propertyDescriptor.getName(), ex); [EOL]     } [EOL] } <line_num>: 363,385
private static Object convert(Object value, Class type) { [EOL]     try { [EOL]         return TypeUtils.convert(value, type); [EOL]     } catch (Exception ex) { [EOL]         throw new JXPathException("Cannot convert value of class " + (value == null ? "null" : value.getClass().getName()) + " to type " + type, ex); [EOL]     } [EOL] } <line_num>: 387,399
public static Object getValue(Object bean, PropertyDescriptor propertyDescriptor, int index) { [EOL]     if (propertyDescriptor instanceof IndexedPropertyDescriptor) { [EOL]         try { [EOL]             IndexedPropertyDescriptor ipd = (IndexedPropertyDescriptor) propertyDescriptor; [EOL]             Method method = ipd.getIndexedReadMethod(); [EOL]             if (method != null) { [EOL]                 return method.invoke(bean, new Object[] { new Integer(index) }); [EOL]             } [EOL]         } catch (InvocationTargetException ex) { [EOL]             Throwable t = ((InvocationTargetException) ex).getTargetException(); [EOL]             if (t instanceof ArrayIndexOutOfBoundsException) { [EOL]                 return null; [EOL]             } [EOL]             throw new JXPathException("Cannot access property: " + propertyDescriptor.getName(), t); [EOL]         } catch (Throwable ex) { [EOL]             throw new JXPathException("Cannot access property: " + propertyDescriptor.getName(), ex); [EOL]         } [EOL]     } [EOL]     return getValue(getValue(bean, propertyDescriptor), index); [EOL] } <line_num>: 405,442
public static void setValue(Object bean, PropertyDescriptor propertyDescriptor, int index, Object value) { [EOL]     if (propertyDescriptor instanceof IndexedPropertyDescriptor) { [EOL]         try { [EOL]             IndexedPropertyDescriptor ipd = (IndexedPropertyDescriptor) propertyDescriptor; [EOL]             Method method = ipd.getIndexedWriteMethod(); [EOL]             if (method != null) { [EOL]                 method.invoke(bean, new Object[] { new Integer(index), convert(value, ipd.getIndexedPropertyType()) }); [EOL]                 return; [EOL]             } [EOL]         } catch (Exception ex) { [EOL]             throw new RuntimeException("Cannot access property: " + propertyDescriptor.getName() + ", " + ex.getMessage()); [EOL]         } [EOL]     } [EOL]     Object collection = getValue(bean, propertyDescriptor); [EOL]     if (isCollection(collection)) { [EOL]         setValue(collection, index, value); [EOL]     } else if (index == 0) { [EOL]         setValue(bean, propertyDescriptor, value); [EOL]     } else { [EOL]         throw new RuntimeException("Not a collection: " + propertyDescriptor.getName()); [EOL]     } [EOL] } <line_num>: 449,489
public static Object getValue(Object object) { [EOL]     while (object instanceof Container) { [EOL]         object = ((Container) object).getValue(); [EOL]     } [EOL]     return object; [EOL] } <line_num>: 495,500
public static DynamicPropertyHandler getDynamicPropertyHandler(Class clazz) { [EOL]     DynamicPropertyHandler handler = (DynamicPropertyHandler) dynamicPropertyHandlerMap.get(clazz); [EOL]     if (handler == null) { [EOL]         try { [EOL]             handler = (DynamicPropertyHandler) clazz.newInstance(); [EOL]         } catch (Exception ex) { [EOL]             throw new JXPathException("Cannot allocate dynamic property handler of class " + clazz.getName(), ex); [EOL]         } [EOL]         dynamicPropertyHandlerMap.put(clazz, handler); [EOL]     } [EOL]     return handler; [EOL] } <line_num>: 506,523
public static Method getAccessibleMethod(Method method) { [EOL]     if (method == null) { [EOL]         return (null); [EOL]     } [EOL]     if (!Modifier.isPublic(method.getModifiers())) { [EOL]         return (null); [EOL]     } [EOL]     Class clazz = method.getDeclaringClass(); [EOL]     if (Modifier.isPublic(clazz.getModifiers())) { [EOL]         return (method); [EOL]     } [EOL]     String name = method.getName(); [EOL]     Class[] parameterTypes = method.getParameterTypes(); [EOL]     while (clazz != null) { [EOL]         Method aMethod = getAccessibleMethodFromInterfaceNest(clazz, name, parameterTypes); [EOL]         if (aMethod != null) { [EOL]             return aMethod; [EOL]         } [EOL]         clazz = clazz.getSuperclass(); [EOL]         if (clazz != null && Modifier.isPublic(clazz.getModifiers())) { [EOL]             try { [EOL]                 return clazz.getDeclaredMethod(name, parameterTypes); [EOL]             } catch (NoSuchMethodException e) { [EOL]                 ; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] } <line_num>: 539,578
private static Method getAccessibleMethodFromInterfaceNest(Class clazz, String methodName, Class[] parameterTypes) { [EOL]     Method method = null; [EOL]     Class[] interfaces = clazz.getInterfaces(); [EOL]     for (int i = 0; i < interfaces.length; i++) { [EOL]         if (!Modifier.isPublic(interfaces[i].getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         try { [EOL]             method = interfaces[i].getDeclaredMethod(methodName, parameterTypes); [EOL]         } catch (NoSuchMethodException e) { [EOL]             ; [EOL]         } [EOL]         if (method != null) { [EOL]             break; [EOL]         } [EOL]         method = getAccessibleMethodFromInterfaceNest(interfaces[i], methodName, parameterTypes); [EOL]         if (method != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return (method); [EOL] } <line_num>: 591,633
