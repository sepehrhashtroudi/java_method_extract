public char getDelimiter() {	    return delimiter;	}
public char getEncapsulator() {	    return encapsulator;	}
public char getCommentStart() {	    return commentStart;	}
public CSVFormat withCommentStart(char commentStart) {	    if (isLineBreak(commentStart)) {	        throw new IllegalArgumentException("The comment start character cannot be a line break");	    }	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public boolean isCommentingEnabled() {	    return this.commentStart != DISABLED;	}
public char getEscape() {	    return escape;	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
public char getDelimiter() {	    return delimiter;	}
public CSVFormat withDelimiter(char delimiter) {	    if (isLineBreak(delimiter)) {	        throw new IllegalArgumentException("The delimiter cannot be a line break");	    }	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public char getEncapsulator() {	    return encapsulator;	}
public boolean isCommentingEnabled() {	    return this.commentStart != DISABLED;	}
public char getEscape() {	    return escape;	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
void validate() throws IllegalArgumentException {	    if (delimiter == encapsulator) {	        throw new IllegalArgumentException("The encapsulator character and the delimiter cannot be the same (\"" + encapsulator + "\")");	    }	    if (delimiter == escape) {	        throw new IllegalArgumentException("The escape character and the delimiter cannot be the same (\"" + escape + "\")");	    }	    if (delimiter == commentStart) {	        throw new IllegalArgumentException("The comment start character and the delimiter cannot be the same (\"" + commentStart + "\")");	    }	    if (encapsulator != DISABLED && encapsulator == commentStart) {	        throw new IllegalArgumentException("The comment start character and the encapsulator cannot be the same (\"" + commentStart + "\")");	    }	    if (escape != DISABLED && escape == commentStart) {	        throw new IllegalArgumentException("The comment start and the escape character cannot be the same (\"" + commentStart + "\")");	    }	}
public char getDelimiter() {	    return delimiter;	}
public char getDelimiter() {	    return delimiter;	}
public char getEncapsulator() {	    return encapsulator;	}
public char getCommentStart() {	    return commentStart;	}
public char getEscape() {	    return escape;	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public CSVFormat withSurroundingSpacesIgnored(boolean surroundingSpacesIgnored) {	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
public CSVFormat withLineSeparator(String lineSeparator) {	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public char getDelimiter() {	    return delimiter;	}
public char getEncapsulator() {	    return encapsulator;	}
public char getCommentStart() {	    return commentStart;	}
public CSVFormat withCommentStart(char commentStart) {	    if (isLineBreak(commentStart)) {	        throw new IllegalArgumentException("The comment start character cannot be a line break");	    }	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public char getEscape() {	    return escape;	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
public CSVFormat withLineSeparator(String lineSeparator) {	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public char getDelimiter() {	    return delimiter;	}
public char getEncapsulator() {	    return encapsulator;	}
public boolean isCommentingEnabled() {	    return this.commentStart != DISABLED;	}
public char getEscape() {	    return escape;	}
public CSVFormat withEscape(char escape) {	    if (isLineBreak(escape)) {	        throw new IllegalArgumentException("The escape character cannot be a line break");	    }	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
public char getDelimiter() {	    return delimiter;	}
public char getEncapsulator() {	    return encapsulator;	}
public boolean isCommentingEnabled() {	    return this.commentStart != DISABLED;	}
public char getEscape() {	    return escape;	}
public CSVFormat withEscape(char escape) {	    if (isLineBreak(escape)) {	        throw new IllegalArgumentException("The escape character cannot be a line break");	    }	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
public char getDelimiter() {	    return delimiter;	}
public char getEncapsulator() {	    return encapsulator;	}
public char getCommentStart() {	    return commentStart;	}
public CSVFormat withCommentStart(char commentStart) {	    if (isLineBreak(commentStart)) {	        throw new IllegalArgumentException("The comment start character cannot be a line break");	    }	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public char getEscape() {	    return escape;	}
public CSVFormat withEscape(char escape) {	    if (isLineBreak(escape)) {	        throw new IllegalArgumentException("The escape character cannot be a line break");	    }	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
public char getDelimiter() {	    return delimiter;	}
public char getEncapsulator() {	    return encapsulator;	}
public CSVFormat withEncapsulator(char encapsulator) {	    if (isLineBreak(encapsulator)) {	        throw new IllegalArgumentException("The encapsulator cannot be a line break");	    }	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public char getCommentStart() {	    return commentStart;	}
public char getEscape() {	    return escape;	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public CSVFormat withSurroundingSpacesIgnored(boolean surroundingSpacesIgnored) {	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
public CSVFormat withEmptyLinesIgnored(boolean emptyLinesIgnored) {	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public char getDelimiter() {	    return delimiter;	}
public char getEncapsulator() {	    return encapsulator;	}
public char getCommentStart() {	    return commentStart;	}
public char getEscape() {	    return escape;	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
public CSVFormat withEmptyLinesIgnored(boolean emptyLinesIgnored) {	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public char getDelimiter() {	    return delimiter;	}
public char getEncapsulator() {	    return encapsulator;	}
public boolean isCommentingEnabled() {	    return this.commentStart != DISABLED;	}
public char getEscape() {	    return escape;	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
public CSVFormat withEmptyLinesIgnored(boolean emptyLinesIgnored) {	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public char getDelimiter() {	    return delimiter;	}
public char getEncapsulator() {	    return encapsulator;	}
public char getCommentStart() {	    return commentStart;	}
public CSVFormat withCommentStart(char commentStart) {	    if (isLineBreak(commentStart)) {	        throw new IllegalArgumentException("The comment start character cannot be a line break");	    }	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public char getEscape() {	    return escape;	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
public char getDelimiter() {	    return delimiter;	}
public char getEncapsulator() {	    return encapsulator;	}
public char getCommentStart() {	    return commentStart;	}
public CSVFormat withCommentStart(char commentStart) {	    if (isLineBreak(commentStart)) {	        throw new IllegalArgumentException("The comment start character cannot be a line break");	    }	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public char getEscape() {	    return escape;	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public char getDelimiter() {	    return delimiter;	}
public char getEncapsulator() {	    return encapsulator;	}
public boolean isCommentingEnabled() {	    return this.commentStart != DISABLED;	}
public char getEscape() {	    return escape;	}
public CSVFormat withEscape(char escape) {	    if (isLineBreak(escape)) {	        throw new IllegalArgumentException("The escape character cannot be a line break");	    }	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
boolean isEscaping() {	    return this.escape != DISABLED;	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
boolean isEscaping() {	    return this.escape != DISABLED;	}
boolean isEncapsulating() {	    return this.encapsulator != DISABLED;	}
boolean isEncapsulating() {	    return this.encapsulator != DISABLED;	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
public char getDelimiter() {	    return delimiter;	}
public char getEncapsulator() {	    return encapsulator;	}
public boolean isCommentingEnabled() {	    return this.commentStart != DISABLED;	}
public char getEscape() {	    return escape;	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
public String getLineSeparator() {	    return lineSeparator;	}
public CSVFormat withLineSeparator(String lineSeparator) {	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public char getDelimiter() {	    return delimiter;	}
public char getEncapsulator() {	    return encapsulator;	}
public char getCommentStart() {	    return commentStart;	}
public char getEscape() {	    return escape;	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
public String getLineSeparator() {	    return lineSeparator;	}
String[] getHeader() {	    return header;	}
public char getDelimiter() {	    return delimiter;	}
public char getEncapsulator() {	    return encapsulator;	}
public char getCommentStart() {	    return commentStart;	}
public char getEscape() {	    return escape;	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
String[] getHeader() {	    return header;	}
public char getDelimiter() {	    return delimiter;	}
public char getEncapsulator() {	    return encapsulator;	}
public char getCommentStart() {	    return commentStart;	}
public char getEscape() {	    return escape;	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
String[] getHeader() {	    return header;	}
public CSVFormat withHeader(String... header) {	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public char getDelimiter() {	    return delimiter;	}
public char getEncapsulator() {	    return encapsulator;	}
public char getCommentStart() {	    return commentStart;	}
public char getEscape() {	    return escape;	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
public char getDelimiter() {	    return delimiter;	}
public char getEncapsulator() {	    return encapsulator;	}
public char getCommentStart() {	    return commentStart;	}
public char getEscape() {	    return escape;	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
public char getDelimiter() {	    return delimiter;	}
public char getEncapsulator() {	    return encapsulator;	}
public CSVFormat withEncapsulator(char encapsulator) {	    if (isLineBreak(encapsulator)) {	        throw new IllegalArgumentException("The encapsulator cannot be a line break");	    }	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public char getCommentStart() {	    return commentStart;	}
public boolean isCommentingEnabled() {	    return this.commentStart != DISABLED;	}
public char getEscape() {	    return escape;	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
public char getDelimiter() {	    return delimiter;	}
public char getEncapsulator() {	    return encapsulator;	}
public CSVFormat withEncapsulator(char encapsulator) {	    if (isLineBreak(encapsulator)) {	        throw new IllegalArgumentException("The encapsulator cannot be a line break");	    }	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public char getCommentStart() {	    return commentStart;	}
public char getEscape() {	    return escape;	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
public char getDelimiter() {	    return delimiter;	}
public CSVFormat withDelimiter(char delimiter) {	    if (isLineBreak(delimiter)) {	        throw new IllegalArgumentException("The delimiter cannot be a line break");	    }	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public char getEncapsulator() {	    return encapsulator;	}
public char getCommentStart() {	    return commentStart;	}
public char getEscape() {	    return escape;	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
public char getDelimiter() {	    return delimiter;	}
public char getEncapsulator() {	    return encapsulator;	}
public char getCommentStart() {	    return commentStart;	}
public char getEscape() {	    return escape;	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
public char getCommentStart() {	    return commentStart;	}
public char getDelimiter() {	    return delimiter;	}
public char getEncapsulator() {	    return encapsulator;	}
public char getCommentStart() {	    return commentStart;	}
public char getEscape() {	    return escape;	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
public char getDelimiter() {	    return delimiter;	}
public String format(String... values) {	    StringWriter out = new StringWriter();	    try {	        new CSVPrinter(out, this).println(values);	    } catch (IOException e) {	    }	    return out.toString().trim();	}
public String format(String... values) {	    StringWriter out = new StringWriter();	    try {	        new CSVPrinter(out, this).println(values);	    } catch (IOException e) {	    }	    return out.toString().trim();	}
public Iterable<CSVRecord> parse(Reader in) throws IOException {	    return new CSVParser(in, this);	}
public boolean isCommentingEnabled() {	    return this.commentStart != DISABLED;	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public char getEscape() {	    return escape;	}
public char getEncapsulator() {	    return encapsulator;	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
public char getDelimiter() {	    return delimiter;	}
public char getEncapsulator() {	    return encapsulator;	}
public char getCommentStart() {	    return commentStart;	}
public char getEscape() {	    return escape;	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
public char getDelimiter() {	    return delimiter;	}
@Override	public String toString() {	    StringBuilder sb = new StringBuilder();	    sb.append("Delimiter=<").append(delimiter).append('>');	    if (isEscaping()) {	        sb.append(' ');	        sb.append("Escape=<").append(escape).append('>');	    }	    if (isEncapsulating()) {	        sb.append(' ');	        sb.append("Encapsulator=<").append(encapsulator).append('>');	    }	    if (isCommentingEnabled()) {	        sb.append(' ');	        sb.append("CommentStart=<").append(commentStart).append('>');	    }	    if (isEmptyLinesIgnored()) {	        sb.append(" EmptyLines:ignored");	    }	    if (isSurroundingSpacesIgnored()) {	        sb.append(" SurroundingSpaces:ignored");	    }	    return sb.toString();	}
@Override	public String toString() {	    StringBuilder sb = new StringBuilder();	    sb.append("Delimiter=<").append(delimiter).append('>');	    if (isEscaping()) {	        sb.append(' ');	        sb.append("Escape=<").append(escape).append('>');	    }	    if (isEncapsulating()) {	        sb.append(' ');	        sb.append("Encapsulator=<").append(encapsulator).append('>');	    }	    if (isCommentingEnabled()) {	        sb.append(' ');	        sb.append("CommentStart=<").append(commentStart).append('>');	    }	    if (isEmptyLinesIgnored()) {	        sb.append(" EmptyLines:ignored");	    }	    if (isSurroundingSpacesIgnored()) {	        sb.append(" SurroundingSpaces:ignored");	    }	    return sb.toString();	}
public char getDelimiter() {	    return delimiter;	}
public char getEncapsulator() {	    return encapsulator;	}
public boolean isCommentingEnabled() {	    return this.commentStart != DISABLED;	}
public Iterable<CSVRecord> parse(Reader in) throws IOException {	    return new CSVParser(in, this);	}
public CSVFormat withEscape(char escape) {	    if (isLineBreak(escape)) {	        throw new IllegalArgumentException("The escape character cannot be a line break");	    }	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public char getDelimiter() {	    return delimiter;	}
public char getEncapsulator() {	    return encapsulator;	}
public CSVFormat withEncapsulator(char encapsulator) {	    if (isLineBreak(encapsulator)) {	        throw new IllegalArgumentException("The encapsulator cannot be a line break");	    }	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public boolean isCommentingEnabled() {	    return this.commentStart != DISABLED;	}
public char getEscape() {	    return escape;	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
public Iterable<CSVRecord> parse(Reader in) throws IOException {	    return new CSVParser(in, this);	}
public CSVFormat withDelimiter(char delimiter) {	    if (isLineBreak(delimiter)) {	        throw new IllegalArgumentException("The delimiter cannot be a line break");	    }	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public char getDelimiter() {	    return delimiter;	}
public CSVFormat withDelimiter(char delimiter) {	    if (isLineBreak(delimiter)) {	        throw new IllegalArgumentException("The delimiter cannot be a line break");	    }	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public char getEncapsulator() {	    return encapsulator;	}
public char getCommentStart() {	    return commentStart;	}
public char getEscape() {	    return escape;	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
void validate() throws IllegalArgumentException {	    if (delimiter == encapsulator) {	        throw new IllegalArgumentException("The encapsulator character and the delimiter cannot be the same (\"" + encapsulator + "\")");	    }	    if (delimiter == escape) {	        throw new IllegalArgumentException("The escape character and the delimiter cannot be the same (\"" + escape + "\")");	    }	    if (delimiter == commentStart) {	        throw new IllegalArgumentException("The comment start character and the delimiter cannot be the same (\"" + commentStart + "\")");	    }	    if (encapsulator != DISABLED && encapsulator == commentStart) {	        throw new IllegalArgumentException("The comment start character and the encapsulator cannot be the same (\"" + commentStart + "\")");	    }	    if (escape != DISABLED && escape == commentStart) {	        throw new IllegalArgumentException("The comment start and the escape character cannot be the same (\"" + commentStart + "\")");	    }	}
public String format(String... values) {	    StringWriter out = new StringWriter();	    try {	        new CSVPrinter(out, this).println(values);	    } catch (IOException e) {	    }	    return out.toString().trim();	}
void validate() throws IllegalArgumentException {	    if (delimiter == encapsulator) {	        throw new IllegalArgumentException("The encapsulator character and the delimiter cannot be the same (\"" + encapsulator + "\")");	    }	    if (delimiter == escape) {	        throw new IllegalArgumentException("The escape character and the delimiter cannot be the same (\"" + escape + "\")");	    }	    if (delimiter == commentStart) {	        throw new IllegalArgumentException("The comment start character and the delimiter cannot be the same (\"" + commentStart + "\")");	    }	    if (encapsulator != DISABLED && encapsulator == commentStart) {	        throw new IllegalArgumentException("The comment start character and the encapsulator cannot be the same (\"" + commentStart + "\")");	    }	    if (escape != DISABLED && escape == commentStart) {	        throw new IllegalArgumentException("The comment start and the escape character cannot be the same (\"" + commentStart + "\")");	    }	}
public CSVFormat withCommentStart(char commentStart) {	    if (isLineBreak(commentStart)) {	        throw new IllegalArgumentException("The comment start character cannot be a line break");	    }	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public Iterable<CSVRecord> parse(Reader in) throws IOException {	    return new CSVParser(in, this);	}
public Iterable<CSVRecord> parse(Reader in) throws IOException {	    return new CSVParser(in, this);	}
public CSVFormat withEncapsulator(char encapsulator) {	    if (isLineBreak(encapsulator)) {	        throw new IllegalArgumentException("The encapsulator cannot be a line break");	    }	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public CSVFormat withCommentStart(char commentStart) {	    if (isLineBreak(commentStart)) {	        throw new IllegalArgumentException("The comment start character cannot be a line break");	    }	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public char getDelimiter() {	    return delimiter;	}
public char getEncapsulator() {	    return encapsulator;	}
public char getCommentStart() {	    return commentStart;	}
public char getEscape() {	    return escape;	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
public CSVFormat withHeader(String... header) {	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public char getEncapsulator() {	    return encapsulator;	}
public boolean isCommentingEnabled() {	    return this.commentStart != DISABLED;	}
public CSVFormat withLineSeparator(String lineSeparator) {	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
@Override	public String toString() {	    StringBuilder sb = new StringBuilder();	    sb.append("Delimiter=<").append(delimiter).append('>');	    if (isEscaping()) {	        sb.append(' ');	        sb.append("Escape=<").append(escape).append('>');	    }	    if (isEncapsulating()) {	        sb.append(' ');	        sb.append("Encapsulator=<").append(encapsulator).append('>');	    }	    if (isCommentingEnabled()) {	        sb.append(' ');	        sb.append("CommentStart=<").append(commentStart).append('>');	    }	    if (isEmptyLinesIgnored()) {	        sb.append(" EmptyLines:ignored");	    }	    if (isSurroundingSpacesIgnored()) {	        sb.append(" SurroundingSpaces:ignored");	    }	    return sb.toString();	}
public String format(String... values) {	    StringWriter out = new StringWriter();	    try {	        new CSVPrinter(out, this).println(values);	    } catch (IOException e) {	    }	    return out.toString().trim();	}
public char getDelimiter() {	    return delimiter;	}
public char getEncapsulator() {	    return encapsulator;	}
public char getCommentStart() {	    return commentStart;	}
public char getEscape() {	    return escape;	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
public CSVFormat withEmptyLinesIgnored(boolean emptyLinesIgnored) {	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public char getDelimiter() {	    return delimiter;	}
public char getEncapsulator() {	    return encapsulator;	}
public char getCommentStart() {	    return commentStart;	}
public boolean isCommentingEnabled() {	    return this.commentStart != DISABLED;	}
public char getEscape() {	    return escape;	}
public boolean isSurroundingSpacesIgnored() {	    return surroundingSpacesIgnored;	}
public CSVFormat withSurroundingSpacesIgnored(boolean surroundingSpacesIgnored) {	    return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);	}
public boolean isEmptyLinesIgnored() {	    return emptyLinesIgnored;	}
public String getLineSeparator() {	    return lineSeparator;	}
